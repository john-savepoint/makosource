[{"type":"system","subtype":"hook_response","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"654573c2-e154-4acc-a354-3fde119d2395","hook_name":"SessionStart:Callback","hook_event":"SessionStart","stdout":"","stderr":""},{"type":"system","subtype":"hook_response","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"89fcbddc-c5b1-4c87-979b-a0fb287f69bc","hook_name":"SessionStart:startup","hook_event":"SessionStart","stdout":"","stderr":"","exit_code":0},{"type":"system","subtype":"hook_response","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"17d442fa-271d-46d1-a196-14cb1b657b35","hook_name":"SessionStart:Callback","hook_event":"SessionStart","stdout":"","stderr":""},{"type":"system","subtype":"hook_response","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"92602f03-122d-47a0-9855-15804d99afc8","hook_name":"SessionStart:startup","hook_event":"SessionStart","stdout":"inject-session-id.sh > injected session ID: ac761b5c-caa9-462d-b02f-aa1c394201b8 [source: startup]\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"**Session ID**: `ac761b5c-caa9-462d-b02f-aa1c394201b8`\\n\\nSession data stored at: `.claude/data/sessions/ac761b5c-caa9-462d-b02f-aa1c394201b8.json`\\n\"\n  }\n}\n","stderr":"","exit_code":0},{"type":"system","subtype":"hook_response","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"650672de-c3c0-469f-9116-7002b1ba0438","hook_name":"SessionStart:startup","hook_event":"SessionStart","stdout":"Claude-ac761b5c tracked in tmux ff70G-japanese-mod:56:%58\n","stderr":"","exit_code":0},{"type":"system","subtype":"hook_response","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"9b716933-9d79-4d89-9bb5-1e9bca787ba5","hook_name":"SessionStart:startup","hook_event":"SessionStart","stdout":"play-startup-sound.sh > ðŸŽ® playing startup sound [source: startup, session: ac761b5c...]\n","stderr":"","exit_code":0},{"type":"system","subtype":"hook_response","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"d2c14edd-5f22-451a-8b53-621262643106","hook_name":"SessionStart:startup","hook_event":"SessionStart","stdout":"inject-session-context.sh > Context injected: /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod on main (33 untracked, 23 modified) [~1470 tokens]\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"# Session Start Dynamic Context\\n**Updated**: 2025-12-01 22:45:42 JST (Monday)\\n**ISO 8601**: 2025-12-01T13:45:42Z\\n\\n## Current Working Directory\\n`/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod`\\n\\n\\n\\n## Git Repository Status\\n- **Current Branch**: `main`\\n- **Last Commit**: 1b7b34a - fix(scripts): fix two critical bugs in launch_standardization_agents.sh (6 minutes ago)\\n- **Untracked Files**: 33\\n- **Remote**: makosource\\tgit@github.com:john-savepoint/makosource.git (fetch)\\n\\n## Project Directory Structure (JSON)\\n\\n**Algorithm**: Levenshtein similarity ratio + semantic pattern detection\\n**Exclusions**: .gitignore patterns + hardcoded common patterns (node_modules, .git, dist, build, coverage, __pycache__)\\n**Truncation**:\\n- Files with â‰¥50% name similarity grouped (e.g., `test1.ts`, `test2.ts` â†’ `+N`)\\n- Non-semantic patterns hidden (UUIDs, session IDs, hashes, logs, tmp files)\\n- Semantic files always preserved (package.json, tsconfig.json, README.md, src/*.ts)\\n- Max depth: 2-4 levels (adaptive based on size, targets <15k tokens)\\n\\n**Reading**: `\\\"f\\\":[\\\"file.ts\\\",\\\"+5\\\"]` = 1 shown file + 5 similar/non-semantic files hidden\\n**Critical**: Source files (`src/**/*.ts`) never truncated via similarity, only via depth limits\\n\\n```json\\n{\\\".claude\\\":{\\\"data\\\":{\\\"ff7-docs-context\\\":{\\\"f\\\":[\\\"agent_summaries.json\\\",\\\"document_categories.json\\\",\\\"+4\\\"]},\\\"sessions\\\":{\\\"f\\\":[\\\"0442c7ca-eff1-466c-93f8-f629ccf6ddfb.json\\\",\\\"0cc720b2-3ab5-42f5-9a3c-7c40de6aa93e.json\\\",\\\"+2\\\"]}},\\\"logs\\\":{\\\"f\\\":[\\\"bash-output.log\\\",\\\"skill-usage.log\\\"]},\\\"tmp\\\":{\\\"agent-prompts\\\":{\\\"f\\\":[\\\"FF7_Battle_Battle_Animation_PC_output.json\\\",\\\"FF7_Battle_Battle_Animation_PC_prompt.txt\\\",\\\"+8\\\"]}}},\\\"FF7-Japanese-Mod\\\":{\\\".claude\\\":{\\\"data\\\":{\\\"sessions\\\":{\\\"f\\\":[\\\"0ba935f5-efe0-457c-ad7e-c18f89cfba18.json\\\"]}}},\\\"f\\\":[\\\"Readme.txt\\\",\\\"mod.xml\\\"]},\\\"archive\\\":{\\\"character_tables_debug\\\":{\\\"debug_cells\\\":{\\\"f\\\":[\\\"inv_jafont_1_idx006_gxy6_0.png\\\",\\\"inv_jafont_1_idx116_gxy4_7.png\\\",\\\"+32\\\"]}},\\\"character_tables_pre-interactive\\\":{\\\"f\\\":[\\\"character_map.csv\\\",\\\"character_map.json\\\",\\\"mapping_discrepancies.csv\\\",\\\"ocr_confidence.json\\\",\\\"+4\\\"]},\\\"character_tables_verification\\\":{\\\"verification\\\":{\\\"f\\\":[\\\"jafont_1_comparison.png\\\",\\\"jafont_1_generated.png\\\",\\\"+16\\\"]},\\\"verification_topleft\\\":{\\\"f\\\":[\\\"jafont_1_comparison_topleft.png\\\",\\\"jafont_1_mangaocr_topleft.png\\\",\\\"+10\\\"]}},\\\"findings_legacy\\\":{\\\"f\\\":[\\\"FINDINGS.md\\\",\\\"FINDINGS.md.backup\\\",\\\"findings2.md\\\"]},\\\"scripts\\\":{\\\"f\\\":[\\\"compare_mappings.py\\\",\\\"debug_mangaocr_cells.py\\\",\\\"generate_accurate_charmap.py\\\",\\\"manga_ocr_mapper.py\\\",\\\"measure_actual_glyph_size.py\\\",\\\"reassemble_findings.py\\\",\\\"+10\\\"]},\\\"sharded\\\":{\\\"bible\\\":{},\\\"bible_sections\\\":{\\\"f\\\":[\\\"1-executive-mission-briefing.md\\\",\\\"10-advanced-feature-furigana-support.md\\\",\\\"11-testing-verification-protocol.md\\\",\\\"12-risk-mitigation-debugging-guide.md\\\",\\\"14-reference-materials-appendices.md\\\",\\\"2-architectural-overview-strategic-analysis.md\\\",\\\"4-asset-specifications-data-structures.md\\\",\\\"5-ffnx-codebase-architecture.md\\\",\\\"6-deep-dive-technical-constraints-solutions.md\\\",\\\"7-implementation-specification-c-modifications.md\\\",\\\"conclusion.md\\\",\\\"index.md\\\",\\\"+6\\\"]},\\\"findings\\\":{},\\\"findings_sections\\\":{\\\"f\\\":[\\\"00_INDEX.md\\\",\\\"01_executive_summary.md\\\",\\\"06_ff7_text_system_architecture.md\\\",\\\"12_potential_implementation_approaches.md\\\",\\\"13_required_modifications.md\\\",\\\"14_development_roadmap_considerations.md\\\",\\\"17_next_steps.md\\\",\\\"18_conclusion.md\\\",\\\"27_breakthrough_first_ever_ff7_japanese_character_table_created.md\\\",\\\"+21\\\"]},\\\"f\\\":[\\\"README.md\\\",\\\"shard_findings.py\\\"]},\\\"f\\\":[\\\"ARCHITECTURAL_RETROSPECTIVE.md\\\",\\\"SCRAPED_URLS.md\\\",\\\"TOOL_VERIFICATION_LOG.md\\\",\\\"UNSCRAPPED_URLS.md\\\"]},\\\"assets\\\":{\\\"character_mappings\\\":{\\\"interactive_viewer\\\":{\\\"f\\\":[\\\"all_textures_corrections.json\\\",\\\"jafont_1_corrections (1).json\\\",\\\"jafont_6_final.json\\\",\\\"+11\\\"]}}},\\\"docs\\\":{\\\"character_maps\\\":{\\\"f\\\":[\\\"JAFONT_CHARACTER_MAP.md\\\",\\\"ff7_complete_mapping_compact.csv\\\"]},\\\"recent\\\":{},\\\"reference\\\":{\\\"game_engine\\\":{\\\".claude\\\":{},\\\"comparisons\\\":{\\\"f\\\":[\\\"CRITICAL_DISCREPANCIES_REQUIRING_INVESTIGATION.md\\\",\\\"FF7_Battle_Battle_Animation_PC_vs_06_BATTLE_MODULE_analysis.md\\\",\\\"FF7_Battle_Battle_Field_vs_06_BATTLE_MODULE_analysis.md\\\",\\\"repomix-comparisons-markdown.md\\\",\\\"+36\\\"]},\\\"extracted_major_sections\\\":{\\\"f\\\":[\\\"00_HEADER_TOC.md\\\",\\\"01_HISTORY.md\\\",\\\"06_BATTLE_MODULE.md\\\",\\\"11_BUGS_AND_CREDITS.md\\\",\\\"+10\\\"]},\\\"final\\\":{\\\"f\\\":[\\\"FF7_Battle_Battle_Animation_PC.md\\\"]},\\\"images\\\":{\\\"f\\\":[\\\"Engine_parts.jpg\\\",\\\"Field_BackgroundVRAM.jpg\\\",\\\"Gears_img_3.jpg\\\",\\\"+25\\\"]},\\\"markdown\\\":{\\\"f\\\":[\\\"FF7.md\\\",\\\"FF7_Chocobo_Breeding.md\\\",\\\"FF7_History.md\\\",\\\"FF7_Item_Materia_Reference.md\\\",\\\"+32\\\"]},\\\"raw\\\":{\\\"f\\\":[\\\"FF7.mediawiki\\\",\\\"FF7_Battle_Battle_Field.mediawiki\\\",\\\"+30\\\"]},\\\"f\\\":[\\\"AGENT_COMPARISON_GUIDE.md\\\",\\\"ENHANCEMENT_PLAN.md\\\",\\\"FINAL_CONVERSION_PIPELINE.md\\\",\\\"Playstation Battle Model Format.md\\\",\\\"combine_files.sh\\\",\\\"copy-paste from ff7 wiki.md\\\",\\\"ff7 game engine_meta.json\\\",\\\"links to copy in order.txt\\\",\\\"move_toc_below_heading.py\\\",\\\"scraper.py\\\",\\\"+59\\\"]},\\\"f\\\":[\\\"AF3DN_ANALYSIS.md\\\",\\\"ARCHITECTURE_CLARIFICATION.md\\\",\\\"BEGINNER_GUIDE.md\\\",\\\"MULTI_LANGUAGE_FINDINGS.md\\\",\\\"TOOL_GUIDE.md\\\",\\\"VERIFICATION_FINDINGS_SESSION_11.md\\\"]},\\\"roadmap\\\":{\\\"f\\\":[\\\"FEATURE_ROADMAP.md\\\",\\\"FFNX_CROWDSOURCED_TRANSLATION_SPEC.md\\\"]},\\\"f\\\":[\\\"7TH_HEAVEN_DEVELOPER_GUIDE.md\\\",\\\"BUILD_ENVIRONMENT_SETUP.md\\\",\\\"DOCUMENTATION_UPDATE_PLAN.md\\\",\\\"FFNX_DEVELOPER_GUIDE.md\\\",\\\"PR737_files_summary.txt\\\",\\\"README.md\\\",\\\"To-do list for documentation.md\\\",\\\"masterfindings.md\\\",\\\"+11\\\"]},\\\"japanese-assets-extracted\\\":{\\\"mod-structure\\\":{},\\\"f\\\":[\\\"FFNx-japanese.toml\\\",\\\"README.md\\\",\\\"TRANSFER_CHECKLIST.md\\\",\\\"WINDOWS_INSTALLATION_GUIDE.md\\\"]},\\\"reference\\\":{\\\"repomix_snapshots\\\":{\\\"f\\\":[\\\"FFNx_repomix.md\\\"]}},\\\"scripts\\\":{\\\"f\\\":[\\\"AGENT_LAUNCHER_USAGE.md\\\",\\\"BUG_FIXES.md\\\",\\\"extract_doc_context.py\\\",\\\"launch_standardization_agents.sh\\\"]},\\\"f\\\":[\\\"DOCUMENTATION_MAP.md\\\",\\\"README.md\\\",\\\"SIMPLE_INSTRUCTIONS.md\\\",\\\"claude.md\\\"]}\\n```\\n\\n## Tmux Environment\\n- **Session**: `ff70G-japanese-mod` (`$7`)\\n- **Window**: `claude-ac761b5c` (`@56` / index: 8)\\n- **Pane**: `%58`\\n\\n---\\n*This context was automatically injected at session start to provide current state information.*\\n\"\n  }\n}\n","stderr":"","exit_code":0},{"type":"system","subtype":"init","cwd":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","tools":["Task","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","BashOutput","KillShell","Skill","SlashCommand","EnterPlanMode","mcp__context7__resolve-library-id","mcp__context7__get-library-docs","mcp__tmux__list-sessions","mcp__tmux__find-session","mcp__tmux__list-windows","mcp__tmux__list-panes","mcp__tmux__capture-pane","mcp__tmux__create-session","mcp__tmux__create-window","mcp__tmux__execute-command","mcp__tmux__get-command-result","ListMcpResourcesTool","ReadMcpResourceTool","mcp__interactive-send-and-capture__send_and_capture","mcp__interactive-send-and-capture__capture_pane","mcp__interactive-send-and-capture__send_input","mcp__mcp-mermaid__generate_mermaid_diagram","mcp__brave-search__brave_web_search","mcp__brave-search__brave_local_search","mcp__firecrawl__firecrawl_scrape","mcp__firecrawl__firecrawl_map","mcp__firecrawl__firecrawl_search","mcp__firecrawl__firecrawl_crawl","mcp__firecrawl__firecrawl_check_crawl_status","mcp__firecrawl__firecrawl_extract"],"mcp_servers":[{"name":"fetch","status":"disabled"},{"name":"sequential-thinking","status":"disabled"},{"name":"filesystem","status":"disabled"},{"name":"shadcn-ui","status":"disabled"},{"name":"context7","status":"connected"},{"name":"tmux","status":"connected"},{"name":"serena","status":"disabled"},{"name":"interactive-send-and-capture","status":"connected"},{"name":"mcp-mermaid","status":"connected"},{"name":"chrome-devtools","status":"disabled"},{"name":"svelte","status":"disabled"},{"name":"brave-search","status":"connected"},{"name":"firecrawl","status":"connected"}],"model":"claude-opus-4-5-20251101","permissionMode":"acceptEdits","slash_commands":["claude-code-hook-builder","mermaid-diagram-writer","slash-command-builder","superpowers:brainstorm","superpowers:execute-plan","superpowers:write-plan","agent-sdk-dev:new-sdk-app","pr-review-toolkit:review-pr","commit-commands:clean_gone","commit-commands:commit-push-pr","commit-commands:commit","feature-dev:feature-dev","code-review:code-review","document-skills:xlsx","document-skills:docx","document-skills:pptx","document-skills:pdf","example-skills:skill-creator","example-skills:mcp-builder","example-skills:canvas-design","example-skills:algorithmic-art","example-skills:internal-comms","example-skills:webapp-testing","example-skills:artifacts-builder","example-skills:slack-gif-creator","example-skills:theme-factory","example-skills:brand-guidelines","superpowers:brainstorming","superpowers:condition-based-waiting","superpowers:defense-in-depth","superpowers:dispatching-parallel-agents","superpowers:executing-plans","superpowers:finishing-a-development-branch","superpowers:receiving-code-review","superpowers:requesting-code-review","superpowers:root-cause-tracing","superpowers:sharing-skills","superpowers:subagent-driven-development","superpowers:systematic-debugging","superpowers:test-driven-development","superpowers:testing-anti-patterns","superpowers:testing-skills-with-subagents","superpowers:using-git-worktrees","superpowers:using-superpowers","superpowers:verification-before-completion","superpowers:writing-plans","superpowers:writing-skills","developer-essentials:auth-implementation-patterns","developer-essentials:code-review-excellence","developer-essentials:debugging-strategies","developer-essentials:e2e-testing-patterns","developer-essentials:error-handling-patterns","developer-essentials:git-advanced-workflows","developer-essentials:monorepo-management","developer-essentials:sql-optimization-patterns","developer-essentials:git-advanced-workflows","developer-essentials:sql-optimization-patterns","developer-essentials:error-handling-patterns","developer-essentials:code-review-excellence","developer-essentials:e2e-testing-patterns","developer-essentials:auth-implementation-patterns","developer-essentials:debugging-strategies","developer-essentials:monorepo-management","compact","context","cost","init","pr-comments","release-notes","todos","review","security-review"],"apiKeySource":"none","claude_code_version":"2.0.55","output_style":"default","agents":["general-purpose","statusline-setup","Explore","Plan","superpowers:code-reviewer","agent-sdk-dev:agent-sdk-verifier-py","agent-sdk-dev:agent-sdk-verifier-ts","pr-review-toolkit:code-reviewer","pr-review-toolkit:code-simplifier","pr-review-toolkit:comment-analyzer","pr-review-toolkit:pr-test-analyzer","pr-review-toolkit:silent-failure-hunter","pr-review-toolkit:type-design-analyzer","feature-dev:code-architect","feature-dev:code-explorer","feature-dev:code-reviewer"],"skills":["claude-code-hook-builder","mermaid-diagram-writer","slash-command-builder","document-skills:xlsx","document-skills:docx","document-skills:pptx","document-skills:pdf","example-skills:skill-creator","example-skills:mcp-builder","example-skills:canvas-design","example-skills:algorithmic-art","example-skills:internal-comms","example-skills:webapp-testing","example-skills:artifacts-builder","example-skills:slack-gif-creator","example-skills:theme-factory","example-skills:brand-guidelines","superpowers:brainstorming","superpowers:condition-based-waiting","superpowers:defense-in-depth","superpowers:dispatching-parallel-agents","superpowers:executing-plans","superpowers:finishing-a-development-branch","superpowers:receiving-code-review","superpowers:requesting-code-review","superpowers:root-cause-tracing","superpowers:sharing-skills","superpowers:subagent-driven-development","superpowers:systematic-debugging","superpowers:test-driven-development","superpowers:testing-anti-patterns","superpowers:testing-skills-with-subagents","superpowers:using-git-worktrees","superpowers:using-superpowers","superpowers:verification-before-completion","superpowers:writing-plans","superpowers:writing-skills","developer-essentials:auth-implementation-patterns","developer-essentials:code-review-excellence","developer-essentials:debugging-strategies","developer-essentials:e2e-testing-patterns","developer-essentials:error-handling-patterns","developer-essentials:git-advanced-workflows","developer-essentials:monorepo-management","developer-essentials:sql-optimization-patterns","developer-essentials:git-advanced-workflows","developer-essentials:sql-optimization-patterns","developer-essentials:error-handling-patterns","developer-essentials:code-review-excellence","developer-essentials:e2e-testing-patterns","developer-essentials:auth-implementation-patterns","developer-essentials:debugging-strategies","developer-essentials:monorepo-management"],"plugins":[{"name":"document-skills","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/anthropic-agent-skills/"},{"name":"example-skills","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/anthropic-agent-skills/"},{"name":"superpowers","path":"/Users/johnzealand-doyle/.claude/plugins/cache/superpowers"},{"name":"agent-sdk-dev","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-plugins/plugins/agent-sdk-dev"},{"name":"pr-review-toolkit","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-plugins/plugins/pr-review-toolkit"},{"name":"commit-commands","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-plugins/plugins/commit-commands"},{"name":"feature-dev","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-plugins/plugins/feature-dev"},{"name":"security-guidance","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-plugins/plugins/security-guidance"},{"name":"code-review","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-plugins/plugins/code-review"},{"name":"developer-essentials","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-workflows/plugins/developer-essentials"},{"name":"explanatory-output-style","path":"/Users/johnzealand-doyle/.claude/plugins/marketplaces/claude-code-plugins/plugins/explanatory-output-style"}],"uuid":"3ec1e7d7-ad6c-4db1-bda8-794b904d9ad0"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ADo6Aj8DmJFKcZCxUqskrm","type":"message","role":"assistant","content":[{"type":"text","text":"I'll transform the FF7_Battle_Battle_Animation_PC.md document according to the standardization requirements. Let me first read the source document."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":65405,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":65405,"ephemeral_1h_input_tokens":0},"output_tokens":139,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"7d003706-0ebd-4a1e-9aed-777d6fd321c0"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ADo6Aj8DmJFKcZCxUqskrm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XtURQPpvXBGzwyFMpui1yt","name":"Read","input":{"file_path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/markdown/merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":65405,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":65405,"ephemeral_1h_input_tokens":0},"output_tokens":139,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"4ff5053d-5cd0-4ccf-8077-0eea58f8b264"},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XtURQPpvXBGzwyFMpui1yt","type":"tool_result","content":"     1â†’<!--\n     2â†’MERGE METADATA\n     3â†’Created: 2025-11-29\n     4â†’Original: FF7_Battle_Battle_Animation_PC.md (912 lines)\n     5â†’Major section: 06_BATTLE_MODULE.md\n     6â†’Merge decision: NO EXTRACTION PERFORMED\n     7â†’Reason: Individual file contains comprehensive battle animation format documentation\n     8â†’Analysis: Major section does not contain additional PC animation format details\n     9â†’Status: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\n    10â†’Restructure: Improved organization, fixed typos, enhanced readability\n    11â†’-->\n    12â†’\n    13â†’# FF7 Battle Animation Format (PC)\n    14â†’\n    15â†’- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n    16â†’  - [Overview](#overview)\n    17â†’  - [1. File Structure](#1-file-structure)\n    18â†’  - [2. Data Structures](#2-data-structures)\n    19â†’  - [3. Decoding Algorithms](#3-decoding-algorithms)\n    20â†’  - [4. Implementation Guide](#4-implementation-guide)\n    21â†’  - [5. Alternative Implementations](#5-alternative-implementations)\n    22â†’  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n    23â†’  - [Appendix B: Known Issues](#appendix-b-known-issues)\n    24â†’\n    25â†’## Overview\n    26â†’\n    27â†’This document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n    28â†’\n    29â†’### What This Document Covers\n    30â†’\n    31â†’- Binary file structure for battle animations\n    32â†’- Data structures for storing skeletal animations\n    33â†’- Compression algorithms for rotation data\n    34â†’- Complete C++ implementation with assembly optimizations\n    35â†’- Theoretical background on the compression scheme\n    36â†’\n    37â†’### File Format Basics\n    38â†’\n    39â†’Battle animation files contain skeletal animation data for character models. Each file stores:\n    40â†’- Multiple animations for a single character\n    41â†’- Per-frame bone rotations and positions\n    42â†’- Compressed delta encoding for subsequent frames\n    43â†’- Special animation markers for scripted events\n    44â†’\n    45â†’---\n    46â†’\n    47â†’## 1. File Structure\n    48â†’\n    49â†’### 1.1 Animation File Layout\n    50â†’\n    51â†’Battle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n    52â†’\n    53â†’**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n    54â†’\n    55â†’To navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n    56â†’\n    57â†’### 1.2 File Header Format\n    58â†’\n    59â†’Each animation begins with a 12-byte header followed by animation data.\n    60â†’\n    61â†’---\n    62â†’\n    63â†’## 2. Data Structures\n    64â†’\n    65â†’### 2.1 FF7FrameHeader\n    66â†’\n    67â†’**Purpose**: Main header for each animation in the file.\n    68â†’\n    69â†’**Structure** (12 bytes):\n    70â†’\n    71â†’```c\n    72â†’typedef struct FF7FrameHeader {\n    73â†’    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n    74â†’                                // NOTE: Unreliable - use skeleton file bone count instead.\n    75â†’    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n    76â†’    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n    77â†’} * PFF7FrameHeader;            // Total size: 12 bytes\n    78â†’```\n    79â†’\n    80â†’#### Special Animation Chunks\n    81â†’\n    82â†’When `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n    83â†’\n    84â†’#### Navigation Example\n    85â†’\n    86â†’To skip to animation index `iTarget`:\n    87â†’\n    88â†’```c\n    89â†’FF7FrameHeader  fhHeader;\n    90â†’DWORD           dwBytesRead;\n    91â†’for ( int I = 0; I < iTarget; I++ ) {\n    92â†’    if ( !ReadFile( hFile,\n    93â†’        &fhHeader, sizeof( fhHeader ),\n    94â†’        &dwBytesRead, NULL ) ) {\n    95â†’\n    96â†’    CloseHandle( hFile );\n    97â†’    return false;\n    98â†’    }\n    99â†’    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n   100â†’        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n   101â†’        INVALID_SET_FILE_POINTER ) {\n   102â†’            CloseHandle( hFile );\n   103â†’            return false;\n   104â†’        }\n   105â†’        continue;\n   106â†’    }\n   107â†’    // Skip this animation (size = dwChunkSize)\n   108â†’    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n   109â†’    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n   110â†’        CloseHandle( hFile );\n   111â†’        return false;\n   112â†’    }\n   113â†’}\n   114â†’// Now at the target animation\n   115â†’if ( !ReadFile( hFile,\n   116â†’    &fhHeader, sizeof( fhHeader ),\n   117â†’    &dwBytesRead, NULL ) ) {\n   118â†’\n   119â†’    CloseHandle( hFile );\n   120â†’    return false;\n   121â†’}\n   122â†’BYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n   123â†’// pbBuffer now holds animation data including FF7FrameMiniHeader\n   124â†’```\n   125â†’\n   126â†’### 2.2 FF7FrameMiniHeader\n   127â†’\n   128â†’**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n   129â†’\n   130â†’**Structure** (5 bytes):\n   131â†’\n   132â†’```c\n   133â†’typedef struct FF7FrameMiniHeader {\n   134â†’    //SHORT     sBones; // Originally thought to be bone count\n   135â†’    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n   136â†’    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n   137â†’    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n   138â†’} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n   139â†’```\n   140â†’\n   141â†’#### Field Discrepancy Notes\n   142â†’\n   143â†’**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n   144â†’\n   145â†’**Reliability**: `sFrames` and `dwFrames` rarely match.\n   146â†’- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n   147â†’- `sFrames` sometimes exceeds actual frame count\n   148â†’- **Determine actual frame count by parsing the entire chunk**\n   149â†’\n   150â†’**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n   151â†’- `sSize` appears at offset 0x00\n   152â†’- `bKey` appears at offset 0x02\n   153â†’- FF7 cannot handle this animation (likely corrupted)\n   154â†’\n   155â†’### 2.3 bKey: The Precision Field\n   156â†’\n   157â†’**Purpose**: Controls rotation data bit depth and compression level.\n   158â†’\n   159â†’#### Valid Values\n   160â†’\n   161â†’| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n   162â†’|------------|-------------------|-----------|----------------|\n   163â†’| 0          | 12                | 0-4095    | None           |\n   164â†’| 2          | 10                | 0-1023    | Low            |\n   165â†’| 4          | 8                 | 0-255     | Moderate       |\n   166â†’\n   167â†’#### How It Works\n   168â†’\n   169â†’1. **Storage**: Rotations stored using `(12 - bKey)` bits\n   170â†’2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   171â†’   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n   172â†’3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n   173â†’\n   174â†’**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n   175â†’\n   176â†’### 2.4 FF7ShortVec (Rotation Storage)\n   177â†’\n   178â†’**Purpose**: Stores one bone's rotation in three numeric forms.\n   179â†’\n   180â†’**Structure** (30 bytes):\n   181â†’\n   182â†’```c\n   183â†’typedef struct FF7ShortVec {\n   184â†’    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n   185â†’    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n   186â†’    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n   187â†’} * PFF7ShortRot;           // Total size: 30 bytes\n   188â†’```\n   189â†’\n   190â†’#### Three-Form Conversion\n   191â†’\n   192â†’Rotations are processed through three representations:\n   193â†’\n   194â†’1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n   195â†’2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   196â†’   - If `SHORT < 0`, add `0x1000` (4096)\n   197â†’3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n   198â†’\n   199â†’#### Per-Frame Processing Sequence\n   200â†’\n   201â†’**First Frame**:\n   202â†’1. Read X bits (determined by `bKey`) and store as signed SHORT\n   203â†’2. Convert SHORT to INT (add 0x1000 if negative)\n   204â†’3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n   205â†’4. Apply FLOAT rotation to model\n   206â†’\n   207â†’**Subsequent Frames**:\n   208â†’1. Read delta value, add to previous frame's SHORT\n   209â†’2. Convert updated SHORT to INT (add 0x1000 if negative)\n   210â†’3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n   211â†’4. Apply FLOAT rotation to model\n   212â†’\n   213â†’**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n   214â†’\n   215â†’### 2.5 FF7FrameBuffer (Frame Management)\n   216â†’\n   217â†’**Purpose**: Allocates memory for one frame's worth of bone rotations.\n   218â†’\n   219â†’**Structure**:\n   220â†’\n   221â†’```c\n   222â†’typedef struct FF7FrameBuffer {\n   223â†’    DWORD           dwBones;\n   224â†’    FF7ShortVec     svPosOffset;\n   225â†’    FF7ShortVec     *psvRots;\n   226â†’\n   227â†’    FF7FrameBuffer() {\n   228â†’        dwBones = 0;\n   229â†’        psvRots = NULL;\n   230â†’    }\n   231â†’    ~FF7FrameBuffer() {\n   232â†’        dwBones = 0;\n   233â†’        delete [] psvRots;\n   234â†’        psvRots = NULL;\n   235â†’    }\n   236â†’\n   237â†’    VOID    SetBones( DWORD dwTotal ) {\n   238â†’        // Delete the old\n   239â†’        dwBones = 0;\n   240â†’        delete [] psvRots;\n   241â†’\n   242â†’        // Create the new\n   243â†’        psvRots = new FF7ShortVec[dwTotal];\n   244â†’        if ( psvRots != NULL ) { dwBones = dwTotal; }\n   245â†’    }\n   246â†’} * PFF7FrameBuffer;\n   247â†’```\n   248â†’\n   249â†’**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n   250â†’\n   251â†’---\n   252â†’\n   253â†’## 3. Decoding Algorithms\n   254â†’\n   255â†’### 3.1 Bit Stream Reading\n   256â†’\n   257â†’#### GetBitsFixed Function\n   258â†’\n   259â†’**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n   260â†’\n   261â†’**Parameters**:\n   262â†’- `pbBuffer`: Byte array containing bit stream\n   263â†’- `dwStartBit`: Bit offset to start reading (modified in place)\n   264â†’- `dwTotalBits`: Number of bits to read\n   265â†’\n   266â†’**Returns**: Signed integer with sign extension.\n   267â†’\n   268â†’**Implementation**:\n   269â†’\n   270â†’```c\n   271â†’INT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\n   272â†’DWORD dwTotalBits ) {\n   273â†’    INT iReturn = 0;\n   274â†’\n   275â†’    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n   276â†’        iReturn <<= 1;\n   277â†’\n   278â†’        __asm mov eax, dwStartBit\n   279â†’        __asm mov eax, [eax]\n   280â†’        __asm cdq\n   281â†’        __asm and edx, 7\n   282â†’        __asm add eax, edx\n   283â†’        __asm sar eax, 3\n   284â†’        __asm mov ecx, pbBuffer\n   285â†’        __asm xor edx, edx\n   286â†’        __asm mov dl, byte ptr ds:[ecx+eax]\n   287â†’        __asm mov eax, dwStartBit\n   288â†’        __asm mov ecx, [eax]\n   289â†’        __asm and ecx, 7\n   290â†’        __asm mov eax, 7\n   291â†’        __asm sub eax, ecx\n   292â†’        __asm mov esi, 1\n   293â†’        __asm mov ecx, eax\n   294â†’        __asm shl esi, cl\n   295â†’        __asm and edx, esi\n   296â†’        __asm test edx, edx\n   297â†’        __asm je INCBIT\n   298â†’        iReturn++;\n   299â†’INCBIT: dwStartBit++;\n   300â†’    }\n   301â†’\n   302â†’    // Force sign bit to extend across 32-bit boundary\n   303â†’    iReturn <<= (0x20 - dwTotalBits);\n   304â†’    iReturn >>= (0x20 - dwTotalBits);\n   305â†’    return iReturn;\n   306â†’}\n   307â†’```\n   308â†’\n   309â†’### 3.2 First Frame (Uncompressed)\n   310â†’\n   311â†’The first frame stores absolute values with no delta compression.\n   312â†’\n   313â†’#### 3.2.1 Position Offsets\n   314â†’\n   315â†’**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n   316â†’\n   317â†’**Example** (Cloud's first animation, `rtda`):\n   318â†’- Bytes: `00 00 FE 2E 00 00`\n   319â†’- Values: `X=0`, `Y=-466`, `Z=0`\n   320â†’- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n   321â†’\n   322â†’**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n   323â†’\n   324â†’**Code**:\n   325â†’\n   326â†’```c\n   327â†’PFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\n   328â†’BYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n   329â†’\n   330â†’DWORD dwBitStart = 0;\n   331â†’SHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   332â†’SHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   333â†’SHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   334â†’// Result: sX=0, sY=-466, sZ=0\n   335â†’```\n   336â†’\n   337â†’#### 3.2.2 Rotation Data\n   338â†’\n   339â†’**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n   340â†’- If `bKey = 0`: 12 bits per rotation\n   341â†’- If `bKey = 2`: 10 bits per rotation\n   342â†’- If `bKey = 4`: 8 bits per rotation\n   343â†’\n   344â†’**Normalization**: Shift left by `bKey` to restore 12-bit range.\n   345â†’\n   346â†’**Code** (for each bone's 3 rotations):\n   347â†’\n   348â†’```c\n   349â†’SHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   350â†’12 - pfmhMiniHeader->bKey );\n   351â†’SHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   352â†’12 - pfmhMiniHeader->bKey );\n   353â†’SHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   354â†’12 - pfmhMiniHeader->bKey );\n   355â†’\n   356â†’// Normalize to 12-bit range\n   357â†’sRotX <<= pfmhMiniHeader->bKey;\n   358â†’sRotY <<= pfmhMiniHeader->bKey;\n   359â†’sRotZ <<= pfmhMiniHeader->bKey;\n   360â†’```\n   361â†’\n   362â†’### 3.3 Subsequent Frames (Compressed Delta Encoding)\n   363â†’\n   364â†’Frames after the first store delta values (changes from previous frame).\n   365â†’\n   366â†’#### 3.3.1 Position Deltas\n   367â†’\n   368â†’**Format**: Variable-length encoding (8 or 17 bits)\n   369â†’\n   370â†’**Algorithm**:\n   371â†’1. Read 1 flag bit\n   372â†’   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   373â†’   - If `1`: Next 16 bits are signed delta (total 17 bits)\n   374â†’\n   375â†’**GetDynamicFrameOffsetBits Function**:\n   376â†’\n   377â†’```c\n   378â†’SHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\n   379â†’DWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n   380â†’    SHORT sReturn;\n   381â†’    __asm {\n   382â†’        mov eax, dwBitStart\n   383â†’        mov eax, [eax]\n   384â†’        cdq\n   385â†’        and edx, 7\n   386â†’        add eax, edx\n   387â†’        sar eax, 3\n   388â†’        mov dwFirstByte, eax\n   389â†’        mov ecx, dwBitStart\n   390â†’        mov edx, [ecx]\n   391â†’        and edx, 7\n   392â†’        mov dwConsumedBits, edx\n   393â†’        mov eax, 7\n   394â†’        sub eax, dwConsumedBits\n   395â†’        mov dwBitsRemainingToNextByte, eax\n   396â†’        mov ecx, pBuffer\n   397â†’        add ecx, dwFirstByte\n   398â†’        xor edx, edx\n   399â†’        mov dl, byte ptr ds:[ecx]\n   400â†’        shl edx, 8\n   401â†’        mov eax, pBuffer\n   402â†’        add eax, dwFirstByte\n   403â†’        xor ecx, ecx\n   404â†’        mov cl, byte ptr ds:[eax+1]\n   405â†’        or edx, ecx\n   406â†’        mov dwTemp, edx\n   407â†’        mov ecx, dwBitsRemainingToNextByte\n   408â†’        add ecx, 8\n   409â†’        mov edx, 1\n   410â†’        shl edx, cl\n   411â†’        mov eax, dwTemp\n   412â†’        and eax, edx\n   413â†’        test eax, eax\n   414â†’        jnz SeventeenBits\n   415â†’\n   416â†’EightBits :\n   417â†’        mov ecx, dwConsumedBits\n   418â†’        add ecx, 1\n   419â†’        mov edx, dwTemp\n   420â†’        shl edx, cl\n   421â†’        movsx eax, dx\n   422â†’        sar eax, 9\n   423â†’        mov sReturn, ax\n   424â†’        mov ecx, dwBitStart\n   425â†’        mov edx, [ecx]\n   426â†’        add edx, 8\n   427â†’        mov eax, dwBitStart\n   428â†’        mov [eax], edx      // Increase dwBitStart by 8\n   429â†’        jmp End\n   430â†’\n   431â†’SeventeenBits :\n   432â†’        mov ecx, dwTemp\n   433â†’        shl ecx, 8\n   434â†’        mov edx, pBuffer\n   435â†’        add edx, dwFirstByte\n   436â†’        xor eax, eax\n   437â†’        mov al, byte ptr ds:[edx+2]\n   438â†’        or ecx, eax\n   439â†’        mov dwTemp, ecx\n   440â†’        mov ecx, dwConsumedBits\n   441â†’        add ecx, 1\n   442â†’        mov edx, dwTemp\n   443â†’        shl edx, cl\n   444â†’        shr edx, 8\n   445â†’        mov sReturn, dx\n   446â†’        mov eax, dwBitStart\n   447â†’        mov ecx, [eax]\n   448â†’        add ecx, 0x11\n   449â†’        mov edx, dwBitStart\n   450â†’        mov [edx], ecx      // Increase dwBitStart by 17\n   451â†’\n   452â†’End :\n   453â†’    }\n   454â†’    return sReturn;\n   455â†’}\n   456â†’```\n   457â†’\n   458â†’**Usage**:\n   459â†’\n   460â†’```c\n   461â†’SHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   462â†’SHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   463â†’SHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   464â†’\n   465â†’// Add deltas to previous frame\n   466â†’FF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\n   467â†’FF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\n   468â†’FF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n   469â†’```\n   470â†’\n   471â†’#### 3.3.2 Rotation Deltas\n   472â†’\n   473â†’**Format**: Complex variable-length encoding optimized for small deltas.\n   474â†’\n   475â†’**Algorithm Overview**:\n   476â†’1. Read 1 flag bit:\n   477â†’   - If `0`: Delta is zero, done\n   478â†’   - If `1`: Continue to step 2\n   479â†’2. Read 3-bit type field (values 0-7)\n   480â†’3. Decode based on type:\n   481â†’   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   482â†’   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   483â†’   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n   484â†’\n   485â†’**Signed Magnitude Transform** (Types 1-6):\n   486â†’\n   487â†’If the N-bit value is negative:\n   488â†’- Subtract `(1 << (N - 1))`\n   489â†’\n   490â†’If positive:\n   491â†’- Add `(1 << (N - 1))`\n   492â†’\n   493â†’Finally, shift left by `bKey` to adjust for precision.\n   494â†’\n   495â†’**Example** (Type 4, meaning 4 bits):\n   496â†’- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n   497â†’- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n   498â†’- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n   499â†’\n   500â†’**GetEncryptedRotationBits Function**:\n   501â†’\n   502â†’```c\n   503â†’SHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\n   504â†’INT iKeyBits ) {\n   505â†’    DWORD dwNumBits, dwType;\n   506â†’    INT iTemp;\n   507â†’    SHORT sReturn;\n   508â†’    // Check the first bit\n   509â†’    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n   510â†’    __asm mov eax, iBits\n   511â†’    __asm test eax, eax\n   512â†’    __asm jnz SecondTest\n   513â†’    __asm jmp ReturnZero    // Return 0\n   514â†’\n   515â†’SecondTest :\n   516â†’    // Get next 3 bits\n   517â†’    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n   518â†’    __asm mov eax, iBits\n   519â†’    __asm and eax, 7\n   520â†’    __asm mov dwNumBits, eax\n   521â†’    __asm mov ecx, dwNumBits\n   522â†’    __asm mov dwType, ecx\n   523â†’    __asm cmp dwType, 7\n   524â†’    __asm ja ReturnZero\n   525â†’\n   526â†’    // Switch on type\n   527â†’    switch ( dwType ) {\n   528â†’        case 0 : {\n   529â†’            __asm or eax, 0xFFFFFFFF    // EAX = -1\n   530â†’            __asm mov ecx, iKeyBits\n   531â†’            __asm shl eax, cl           // (-1 << iKeyBits)\n   532â†’            __asm mov sReturn, ax\n   533â†’            __asm jmp End\n   534â†’        }\n   535â†’        case 1 : {}\n   536â†’        case 2 : {}\n   537â†’        case 3 : {}\n   538â†’        case 4 : {}\n   539â†’        case 5 : {}\n   540â†’        case 6 : {\n   541â†’            // Read N bits\n   542â†’            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n   543â†’                dwNumBits );\n   544â†’            __asm mov eax, iTemp\n   545â†’            __asm cmp iTemp, 0\n   546â†’            __asm jl IfLessThanZero\n   547â†’            // If >= 0: add (1 << (dwNumBits - 1))\n   548â†’            __asm mov ecx, dwNumBits\n   549â†’            __asm sub ecx, 1\n   550â†’            __asm mov eax, 1\n   551â†’            __asm shl eax, cl\n   552â†’            __asm mov ecx, iTemp\n   553â†’            __asm add ecx, eax\n   554â†’            __asm mov iTemp, ecx\n   555â†’            __asm jmp AfterTests\n   556â†’IfLessThanZero :\n   557â†’            // If < 0: subtract (1 << (dwNumBits - 1))\n   558â†’            __asm mov ecx, dwNumBits\n   559â†’            __asm sub ecx, 1\n   560â†’            __asm mov edx, 1\n   561â†’            __asm shl edx, cl\n   562â†’            __asm mov eax, iTemp\n   563â†’            __asm sub eax, edx\n   564â†’            __asm mov iTemp, eax\n   565â†’\n   566â†’AfterTests :\n   567â†’            // Shift by precision\n   568â†’            __asm mov eax, iTemp\n   569â†’            __asm mov ecx, iKeyBits\n   570â†’            __asm shl eax, cl\n   571â†’            __asm mov sReturn, ax\n   572â†’            __asm jmp End\n   573â†’        }\n   574â†’\n   575â†’        case 7 : {\n   576â†’            // Uncompressed: read (12 - iKeyBits) bits\n   577â†’            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n   578â†’                12 - iKeyBits );\n   579â†’            __asm mov ecx, iKeyBits\n   580â†’            __asm shl eax, cl\n   581â†’            __asm mov sReturn, ax\n   582â†’            __asm jmp End\n   583â†’        }\n   584â†’\n   585â†’    }\n   586â†’\n   587â†’\n   588â†’ReturnZero :\n   589â†’    __asm xor ax, ax\n   590â†’    __asm mov sReturn, ax\n   591â†’\n   592â†’End :\n   593â†’\n   594â†’    return sReturn;\n   595â†’}\n   596â†’```\n   597â†’\n   598â†’---\n   599â†’\n   600â†’## 4. Implementation Guide\n   601â†’\n   602â†’### 4.1 LoadFrames Function\n   603â†’\n   604â†’**Purpose**: Load an entire frame (position + all bone rotations) at once.\n   605â†’\n   606â†’**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n   607â†’\n   608â†’**Parameters**:\n   609â†’- `pfbFrameBuffer`: Pointer to frame buffer to fill\n   610â†’- `iBones`: Number of bones in skeleton\n   611â†’- `iBitStart`: Bit offset to start reading (0 for first frame)\n   612â†’- `pbAnimBuffer`: Byte array containing animation data\n   613â†’\n   614â†’**Implementation**:\n   615â†’\n   616â†’```c\n   617â†’DWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\n   618â†’INT iBones,\n   619â†’INT iBitStart,\n   620â†’BYTE * pbAnimBuffer ) {\n   621â†’    // Get backups of parameters\n   622â†’DWORD       dwThisBitStart  = iBitStart;\n   623â†’    INT     iThisBones      = iBones;\n   624â†’    BYTE *  pbThisBuffer    = pbAnimBuffer;\n   625â†’\n   626â†’    PFF7FrameMiniHeader pfmhMiniHeader =\n   627â†’        (PFF7FrameMiniHeader)pbAnimBuffer;\n   628â†’    SHORT   sSize = pfmhMiniHeader->sSize;\n   629â†’    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n   630â†’\n   631â†’    // Skip 5-byte miniheader\n   632â†’    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n   633â†’\n   634â†’    if ( iBitStart == 0 ) { // First frame?\n   635â†’        // Uncompressed position offsets\n   636â†’        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   637â†’        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   638â†’        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   639â†’\n   640â†’        // Convert to FLOAT\n   641â†’        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n   642â†’        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n   643â†’        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n   644â†’\n   645â†’        for ( int I = 0; I < iThisBones; I++ ) {\n   646â†’            // Read rotations (12 - bKeyBits) bits each\n   647â†’            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   648â†’            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   649â†’            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   650â†’\n   651â†’            // Convert SHORT to INT (absolute value)\n   652â†’            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n   653â†’            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n   654â†’            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n   655â†’        }\n   656â†’    }\n   657â†’    else {                  // Subsequent frames\n   658â†’        SHORT sX, sY, sZ;\n   659â†’\n   660â†’        // Get position deltas\n   661â†’        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   662â†’        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   663â†’        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   664â†’\n   665â†’        // Add deltas to previous frame\n   666â†’        pfbFrameBuffer->svPosOffset.sX += sX;\n   667â†’        pfbFrameBuffer->svPosOffset.sY += sY;\n   668â†’        pfbFrameBuffer->svPosOffset.sZ += sZ;\n   669â†’\n   670â†’        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n   671â†’        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n   672â†’        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n   673â†’\n   674â†’        for ( int I = 0; I < iThisBones; I++ ) {\n   675â†’            // Get rotation deltas\n   676â†’            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   677â†’            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   678â†’            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   679â†’\n   680â†’            // Add deltas\n   681â†’            pfbFrameBuffer->psvRots[I].sX += sX;\n   682â†’            pfbFrameBuffer->psvRots[I].sY += sY;\n   683â†’            pfbFrameBuffer->psvRots[I].sZ += sZ;\n   684â†’\n   685â†’            // Note: Values can exceed 4095 through accumulation of positive deltas\n   686â†’\n   687â†’            // Convert to INT\n   688â†’            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n   689â†’            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n   690â†’            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n   691â†’        }\n   692â†’    }\n   693â†’\n   694â†’    // Return next frame's bit offset (or 0 if done)\n   695â†’    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\n   696â†’return dwThisBitStart;\n   697â†’}\n   698â†’    return 0;\n   699â†’}\n   700â†’```\n   701â†’\n   702â†’### 4.2 Complete Animation Loading Loop\n   703â†’\n   704â†’**Example**: Load all frames in an animation.\n   705â†’\n   706â†’```c\n   707â†’FF7FrameHeader fhHeader;\n   708â†’ReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\n   709â†’NULL );\n   710â†’BYTE * baData = new BYTE[fhHeader.dwChunkSize];\n   711â†’ReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\n   712â†’NULL );\n   713â†’\n   714â†’    // Allocate frame buffer\n   715â†’FF7FrameBuffer fbFrameBuffer;\n   716â†’fbFrameBuffer.SetBones( fhHeader.dwBones );\n   717â†’INT iBits = 0;\n   718â†’\n   719â†’for ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n   720â†’    // Load frame\n   721â†’    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n   722â†’\n   723â†’    // Reverse Y offset (required)\n   724â†’    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n   725â†’\n   726â†’    // Convert INT rotations to FLOAT degrees\n   727â†’    // Note: First rotation (root) is typically 0,0,0 but some animations\n   728â†’    // store a base rotation for dynamic targeting\n   729â†’    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n   730â†’        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n   731â†’        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n   732â†’        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n   733â†’    }\n   734â†’\n   735â†’    // Store frame data here (application-specific)\n   736â†’}\n   737â†’\n   738â†’delete [] baData;\n   739â†’```\n   740â†’\n   741â†’---\n   742â†’\n   743â†’## 5. Alternative Implementations\n   744â†’\n   745â†’### 5.1 Qhimm's C++ Versions\n   746â†’\n   747â†’**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n   748â†’\n   749â†’#### GetValueFromStream\n   750â†’\n   751â†’Replaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n   752â†’\n   753â†’```c\n   754â†’short GetValueFromStream( BYTE *pStreamBytes,\n   755â†’DWORD *pdwStreamBitOffset )\n   756â†’{\n   757â†’    short sValue;\n   758â†’    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n   759â†’    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n   760â†’    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n   761â†’    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n   762â†’\n   763â†’    // Test first bit to determine value size\n   764â†’    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n   765â†’    {   // 16-bit value\n   766â†’        dwNextStreamBytes = dwNextStreamBytes << 8 |\n   767â†’            pStreamBytes[dwStreamByteOffset + 2];\n   768â†’        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n   769â†’        *pdwStreamBitOffset += 17;\n   770â†’    }\n   771â†’    else\n   772â†’    {   // 7-bit value\n   773â†’        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n   774â†’        *pdwStreamBitOffset += 8;\n   775â†’    }\n   776â†’\n   777â†’    return sValue;\n   778â†’}\n   779â†’```\n   780â†’\n   781â†’#### GetCompressedDeltaFromStream\n   782â†’\n   783â†’Replaces `GetEncryptedRotationBits` with clearer C++ implementation.\n   784â†’\n   785â†’```c\n   786â†’short GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\n   787â†’int nLoweredPrecisionBits )\n   788â†’{\n   789â†’    unsigned int nBits;\n   790â†’    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n   791â†’    if (iFirstBit)\n   792â†’    {\n   793â†’        unsigned int uType = GetBitsFromStream( pStreamBytes,\n   794â†’            pdwStreamBitOffset, 3 ) & 7;\n   795â†’        switch (uType)\n   796â†’        {\n   797â†’        case 0:\n   798â†’            // Minimum decrement\n   799â†’            return (-1 << nLoweredPrecisionBits);\n   800â†’\n   801â†’        case 1: case 2: case 3: case 4: case 5: case 6:\n   802â†’            // Read N bits\n   803â†’            int iTemp = GetBitsFromStream( pStreamBytes,\n   804â†’                pdwStreamBitOffset, nBits );\n   805â†’            // Apply signed magnitude transform\n   806â†’            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n   807â†’            else            iTemp += 1 << (nBits - 1);\n   808â†’            // Adjust for precision\n   809â†’            return (iTemp << nLoweredPrecisionBits);\n   810â†’\n   811â†’        case 7:\n   812â†’            // Uncompressed\n   813â†’            iTemp = GetBitsFromStream( pStreamBytes,\n   814â†’                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n   815â†’            return (iTemp << nLoweredPrecisionBits);\n   816â†’        default:\n   817â†’        }\n   818â†’    }\n   819â†’    return 0;\n   820â†’}\n   821â†’```\n   822â†’\n   823â†’### 5.2 Rotation Compression Theory\n   824â†’\n   825â†’*Notes by Qhimm*\n   826â†’\n   827â†’#### Why This Encoding Is Efficient\n   828â†’\n   829â†’Rotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n   830â†’\n   831â†’**Bit Allocation**:\n   832â†’- Zero delta: 1 bit (`0`)\n   833â†’- Minimum decrement: 4 bits (`1 000`)\n   834â†’- Small deltas (1-6 bits): 126 possible values\n   835â†’- Large deltas: Uncompressed form\n   836â†’\n   837â†’**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n   838â†’\n   839â†’#### Signed Magnitude Encoding\n   840â†’\n   841â†’For delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n   842â†’\n   843â†’1. **Magnitude**: Value of most significant value bit\n   844â†’   - Example: Values `1` and `-2` both have magnitude `1`\n   845â†’   - Value `30` has magnitude `32`\n   846â†’\n   847â†’2. **Signed Magnitude**: Magnitude Ã— sign of value\n   848â†’   - Example: `-2` has signed magnitude `-1`\n   849â†’\n   850â†’3. **Encoding**: Subtract signed magnitude before storing\n   851â†’   - Pushes values toward zero\n   852â†’   - Ensures all transformed values fit in 6 bits or fewer\n   853â†’\n   854â†’4. **Decoding**: Add back the signed magnitude\n   855â†’   - Magnitude determined by number of bits read\n   856â†’   - Sign determined by MSB of encoded value\n   857â†’\n   858â†’#### Encoding Examples\n   859â†’\n   860â†’| Delta Value | Encoded Bits        | Notes                                    |\n   861â†’|-------------|---------------------|------------------------------------------|\n   862â†’| 0           | `0`                 | Single zero bit                          |\n   863â†’| -1          | `1 000`             | Type 0 (minimum decrement)               |\n   864â†’| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n   865â†’| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n   866â†’| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n   867â†’\n   868â†’*(Values shown in current precision as integers)*\n   869â†’\n   870â†’#### Precision Trade-offs\n   871â†’\n   872â†’Precision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n   873â†’\n   874â†’**Advantages**:\n   875â†’- Smaller raw values\n   876â†’- Increased relative span of compressed encodings\n   877â†’- Much smaller file sizes\n   878â†’\n   879â†’**Disadvantages**:\n   880â†’- Quantization error\n   881â†’- Less precise rotations\n   882â†’\n   883â†’**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n   884â†’\n   885â†’**Note**: Reduced precision is treated as rounding toward negative infinity.\n   886â†’\n   887â†’---\n   888â†’\n   889â†’## Appendix A: Quick Reference\n   890â†’\n   891â†’### Structure Sizes\n   892â†’\n   893â†’| Structure          | Size (bytes) | Offset Fields                              |\n   894â†’|--------------------|--------------|--------------------------------------------|\n   895â†’| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n   896â†’| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n   897â†’| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n   898â†’\n   899â†’### bKey Values\n   900â†’\n   901â†’| bKey | Uncompressed Bits | Formula         | Range   |\n   902â†’|------|-------------------|-----------------|---------|\n   903â†’| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n   904â†’| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n   905â†’| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n   906â†’\n   907â†’### Conversion Formulas\n   908â†’\n   909â†’**SHORT to Degrees**:\n   910â†’```\n   911â†’degrees = (SHORT / 4096) * 360\n   912â†’```\n   913â†’\n   914â†’**SHORT to INT (with wrapping)**:\n   915â†’```\n   916â†’INT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n   917â†’```\n   918â†’\n   919â†’**INT to FLOAT**:\n   920â†’```\n   921â†’FLOAT = (INT / 4096.0f) * 360.0f\n   922â†’```\n   923â†’\n   924â†’### Position Delta Encoding\n   925â†’\n   926â†’| First Bit | Total Bits | Format     |\n   927â†’|-----------|------------|------------|\n   928â†’| 0         | 8          | 7-bit delta|\n   929â†’| 1         | 17         | 16-bit delta|\n   930â†’\n   931â†’### Rotation Delta Type Field\n   932â†’\n   933â†’| Type | Bits to Read        | Meaning                        |\n   934â†’|------|---------------------|--------------------------------|\n   935â†’| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n   936â†’| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n   937â†’| 7    | `12 - bKey`         | Uncompressed rotation value    |\n   938â†’\n   939â†’---\n   940â†’\n   941â†’## Appendix B: Known Issues\n   942â†’\n   943â†’### Corrupted Animations\n   944â†’\n   945â†’**RSAA Animation 15** (playable frog):\n   946â†’- Missing `sFrames` field\n   947â†’- `sSize` appears at offset 0x00 instead of 0x02\n   948â†’- `bKey` appears at offset 0x02 instead of 0x04\n   949â†’- FF7 cannot load this animation (likely damaged in original game data)\n   950â†’\n   951â†’### Frame Count Discrepancies\n   952â†’\n   953â†’**sFrames vs. dwFrames**:\n   954â†’- Rarely match in practice\n   955â†’- `dwFrames` is more conservative (guarantees minimum)\n   956â†’- `sFrames` sometimes exceeds actual frame count\n   957â†’- **Solution**: Parse entire chunk to determine true frame count\n   958â†’\n   959â†’**Possible Causes**:\n   960â†’- Dummy frames padded for memory alignment\n   961â†’- Special-purpose data interleaved with frames\n   962â†’- Animation authoring tool artifacts\n   963â†’\n   964â†’### Root Rotation Behavior\n   965â†’\n   966â†’**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n   967â†’\n   968â†’**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n   969â†’- Model facing toward attack target\n   970â†’- Model rotating during special moves\n   971â†’\n   972â†’**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n   973â†’\n   974â†’---\n   975â†’\n   976â†’**End of Document**\n   977â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"24ec11d0-7796-4101-87eb-a63bab3848d6","tool_use_result":{"type":"text","file":{"filePath":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/markdown/merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md","content":"<!--\nMERGE METADATA\nCreated: 2025-11-29\nOriginal: FF7_Battle_Battle_Animation_PC.md (912 lines)\nMajor section: 06_BATTLE_MODULE.md\nMerge decision: NO EXTRACTION PERFORMED\nReason: Individual file contains comprehensive battle animation format documentation\nAnalysis: Major section does not contain additional PC animation format details\nStatus: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\nRestructure: Improved organization, fixed typos, enhanced readability\n-->\n\n# FF7 Battle Animation Format (PC)\n\n- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n  - [Overview](#overview)\n  - [1. File Structure](#1-file-structure)\n  - [2. Data Structures](#2-data-structures)\n  - [3. Decoding Algorithms](#3-decoding-algorithms)\n  - [4. Implementation Guide](#4-implementation-guide)\n  - [5. Alternative Implementations](#5-alternative-implementations)\n  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n  - [Appendix B: Known Issues](#appendix-b-known-issues)\n\n## Overview\n\nThis document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n\n### What This Document Covers\n\n- Binary file structure for battle animations\n- Data structures for storing skeletal animations\n- Compression algorithms for rotation data\n- Complete C++ implementation with assembly optimizations\n- Theoretical background on the compression scheme\n\n### File Format Basics\n\nBattle animation files contain skeletal animation data for character models. Each file stores:\n- Multiple animations for a single character\n- Per-frame bone rotations and positions\n- Compressed delta encoding for subsequent frames\n- Special animation markers for scripted events\n\n---\n\n## 1. File Structure\n\n### 1.1 Animation File Layout\n\nBattle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n\n**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n\nTo navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n\n### 1.2 File Header Format\n\nEach animation begins with a 12-byte header followed by animation data.\n\n---\n\n## 2. Data Structures\n\n### 2.1 FF7FrameHeader\n\n**Purpose**: Main header for each animation in the file.\n\n**Structure** (12 bytes):\n\n```c\ntypedef struct FF7FrameHeader {\n    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n                                // NOTE: Unreliable - use skeleton file bone count instead.\n    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n} * PFF7FrameHeader;            // Total size: 12 bytes\n```\n\n#### Special Animation Chunks\n\nWhen `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n\n#### Navigation Example\n\nTo skip to animation index `iTarget`:\n\n```c\nFF7FrameHeader  fhHeader;\nDWORD           dwBytesRead;\nfor ( int I = 0; I < iTarget; I++ ) {\n    if ( !ReadFile( hFile,\n        &fhHeader, sizeof( fhHeader ),\n        &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n    }\n    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n        INVALID_SET_FILE_POINTER ) {\n            CloseHandle( hFile );\n            return false;\n        }\n        continue;\n    }\n    // Skip this animation (size = dwChunkSize)\n    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n        CloseHandle( hFile );\n        return false;\n    }\n}\n// Now at the target animation\nif ( !ReadFile( hFile,\n    &fhHeader, sizeof( fhHeader ),\n    &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n}\nBYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n// pbBuffer now holds animation data including FF7FrameMiniHeader\n```\n\n### 2.2 FF7FrameMiniHeader\n\n**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n\n**Structure** (5 bytes):\n\n```c\ntypedef struct FF7FrameMiniHeader {\n    //SHORT     sBones; // Originally thought to be bone count\n    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n```\n\n#### Field Discrepancy Notes\n\n**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n\n**Reliability**: `sFrames` and `dwFrames` rarely match.\n- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n- `sFrames` sometimes exceeds actual frame count\n- **Determine actual frame count by parsing the entire chunk**\n\n**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n- `sSize` appears at offset 0x00\n- `bKey` appears at offset 0x02\n- FF7 cannot handle this animation (likely corrupted)\n\n### 2.3 bKey: The Precision Field\n\n**Purpose**: Controls rotation data bit depth and compression level.\n\n#### Valid Values\n\n| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n|------------|-------------------|-----------|----------------|\n| 0          | 12                | 0-4095    | None           |\n| 2          | 10                | 0-1023    | Low            |\n| 4          | 8                 | 0-255     | Moderate       |\n\n#### How It Works\n\n1. **Storage**: Rotations stored using `(12 - bKey)` bits\n2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n\n**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n\n### 2.4 FF7ShortVec (Rotation Storage)\n\n**Purpose**: Stores one bone's rotation in three numeric forms.\n\n**Structure** (30 bytes):\n\n```c\ntypedef struct FF7ShortVec {\n    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n} * PFF7ShortRot;           // Total size: 30 bytes\n```\n\n#### Three-Form Conversion\n\nRotations are processed through three representations:\n\n1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   - If `SHORT < 0`, add `0x1000` (4096)\n3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n\n#### Per-Frame Processing Sequence\n\n**First Frame**:\n1. Read X bits (determined by `bKey`) and store as signed SHORT\n2. Convert SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Subsequent Frames**:\n1. Read delta value, add to previous frame's SHORT\n2. Convert updated SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n\n### 2.5 FF7FrameBuffer (Frame Management)\n\n**Purpose**: Allocates memory for one frame's worth of bone rotations.\n\n**Structure**:\n\n```c\ntypedef struct FF7FrameBuffer {\n    DWORD           dwBones;\n    FF7ShortVec     svPosOffset;\n    FF7ShortVec     *psvRots;\n\n    FF7FrameBuffer() {\n        dwBones = 0;\n        psvRots = NULL;\n    }\n    ~FF7FrameBuffer() {\n        dwBones = 0;\n        delete [] psvRots;\n        psvRots = NULL;\n    }\n\n    VOID    SetBones( DWORD dwTotal ) {\n        // Delete the old\n        dwBones = 0;\n        delete [] psvRots;\n\n        // Create the new\n        psvRots = new FF7ShortVec[dwTotal];\n        if ( psvRots != NULL ) { dwBones = dwTotal; }\n    }\n} * PFF7FrameBuffer;\n```\n\n**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n\n---\n\n## 3. Decoding Algorithms\n\n### 3.1 Bit Stream Reading\n\n#### GetBitsFixed Function\n\n**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n\n**Parameters**:\n- `pbBuffer`: Byte array containing bit stream\n- `dwStartBit`: Bit offset to start reading (modified in place)\n- `dwTotalBits`: Number of bits to read\n\n**Returns**: Signed integer with sign extension.\n\n**Implementation**:\n\n```c\nINT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\nDWORD dwTotalBits ) {\n    INT iReturn = 0;\n\n    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n        iReturn <<= 1;\n\n        __asm mov eax, dwStartBit\n        __asm mov eax, [eax]\n        __asm cdq\n        __asm and edx, 7\n        __asm add eax, edx\n        __asm sar eax, 3\n        __asm mov ecx, pbBuffer\n        __asm xor edx, edx\n        __asm mov dl, byte ptr ds:[ecx+eax]\n        __asm mov eax, dwStartBit\n        __asm mov ecx, [eax]\n        __asm and ecx, 7\n        __asm mov eax, 7\n        __asm sub eax, ecx\n        __asm mov esi, 1\n        __asm mov ecx, eax\n        __asm shl esi, cl\n        __asm and edx, esi\n        __asm test edx, edx\n        __asm je INCBIT\n        iReturn++;\nINCBIT: dwStartBit++;\n    }\n\n    // Force sign bit to extend across 32-bit boundary\n    iReturn <<= (0x20 - dwTotalBits);\n    iReturn >>= (0x20 - dwTotalBits);\n    return iReturn;\n}\n```\n\n### 3.2 First Frame (Uncompressed)\n\nThe first frame stores absolute values with no delta compression.\n\n#### 3.2.1 Position Offsets\n\n**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n\n**Example** (Cloud's first animation, `rtda`):\n- Bytes: `00 00 FE 2E 00 00`\n- Values: `X=0`, `Y=-466`, `Z=0`\n- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n\n**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n\n**Code**:\n\n```c\nPFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\nBYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n\nDWORD dwBitStart = 0;\nSHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n// Result: sX=0, sY=-466, sZ=0\n```\n\n#### 3.2.2 Rotation Data\n\n**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n- If `bKey = 0`: 12 bits per rotation\n- If `bKey = 2`: 10 bits per rotation\n- If `bKey = 4`: 8 bits per rotation\n\n**Normalization**: Shift left by `bKey` to restore 12-bit range.\n\n**Code** (for each bone's 3 rotations):\n\n```c\nSHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\n\n// Normalize to 12-bit range\nsRotX <<= pfmhMiniHeader->bKey;\nsRotY <<= pfmhMiniHeader->bKey;\nsRotZ <<= pfmhMiniHeader->bKey;\n```\n\n### 3.3 Subsequent Frames (Compressed Delta Encoding)\n\nFrames after the first store delta values (changes from previous frame).\n\n#### 3.3.1 Position Deltas\n\n**Format**: Variable-length encoding (8 or 17 bits)\n\n**Algorithm**:\n1. Read 1 flag bit\n   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   - If `1`: Next 16 bits are signed delta (total 17 bits)\n\n**GetDynamicFrameOffsetBits Function**:\n\n```c\nSHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\nDWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n    SHORT sReturn;\n    __asm {\n        mov eax, dwBitStart\n        mov eax, [eax]\n        cdq\n        and edx, 7\n        add eax, edx\n        sar eax, 3\n        mov dwFirstByte, eax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        and edx, 7\n        mov dwConsumedBits, edx\n        mov eax, 7\n        sub eax, dwConsumedBits\n        mov dwBitsRemainingToNextByte, eax\n        mov ecx, pBuffer\n        add ecx, dwFirstByte\n        xor edx, edx\n        mov dl, byte ptr ds:[ecx]\n        shl edx, 8\n        mov eax, pBuffer\n        add eax, dwFirstByte\n        xor ecx, ecx\n        mov cl, byte ptr ds:[eax+1]\n        or edx, ecx\n        mov dwTemp, edx\n        mov ecx, dwBitsRemainingToNextByte\n        add ecx, 8\n        mov edx, 1\n        shl edx, cl\n        mov eax, dwTemp\n        and eax, edx\n        test eax, eax\n        jnz SeventeenBits\n\nEightBits :\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        movsx eax, dx\n        sar eax, 9\n        mov sReturn, ax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        add edx, 8\n        mov eax, dwBitStart\n        mov [eax], edx      // Increase dwBitStart by 8\n        jmp End\n\nSeventeenBits :\n        mov ecx, dwTemp\n        shl ecx, 8\n        mov edx, pBuffer\n        add edx, dwFirstByte\n        xor eax, eax\n        mov al, byte ptr ds:[edx+2]\n        or ecx, eax\n        mov dwTemp, ecx\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        shr edx, 8\n        mov sReturn, dx\n        mov eax, dwBitStart\n        mov ecx, [eax]\n        add ecx, 0x11\n        mov edx, dwBitStart\n        mov [edx], ecx      // Increase dwBitStart by 17\n\nEnd :\n    }\n    return sReturn;\n}\n```\n\n**Usage**:\n\n```c\nSHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n\n// Add deltas to previous frame\nFF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\nFF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\nFF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n```\n\n#### 3.3.2 Rotation Deltas\n\n**Format**: Complex variable-length encoding optimized for small deltas.\n\n**Algorithm Overview**:\n1. Read 1 flag bit:\n   - If `0`: Delta is zero, done\n   - If `1`: Continue to step 2\n2. Read 3-bit type field (values 0-7)\n3. Decode based on type:\n   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n\n**Signed Magnitude Transform** (Types 1-6):\n\nIf the N-bit value is negative:\n- Subtract `(1 << (N - 1))`\n\nIf positive:\n- Add `(1 << (N - 1))`\n\nFinally, shift left by `bKey` to adjust for precision.\n\n**Example** (Type 4, meaning 4 bits):\n- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n\n**GetEncryptedRotationBits Function**:\n\n```c\nSHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\nINT iKeyBits ) {\n    DWORD dwNumBits, dwType;\n    INT iTemp;\n    SHORT sReturn;\n    // Check the first bit\n    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n    __asm mov eax, iBits\n    __asm test eax, eax\n    __asm jnz SecondTest\n    __asm jmp ReturnZero    // Return 0\n\nSecondTest :\n    // Get next 3 bits\n    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n    __asm mov eax, iBits\n    __asm and eax, 7\n    __asm mov dwNumBits, eax\n    __asm mov ecx, dwNumBits\n    __asm mov dwType, ecx\n    __asm cmp dwType, 7\n    __asm ja ReturnZero\n\n    // Switch on type\n    switch ( dwType ) {\n        case 0 : {\n            __asm or eax, 0xFFFFFFFF    // EAX = -1\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl           // (-1 << iKeyBits)\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n        case 1 : {}\n        case 2 : {}\n        case 3 : {}\n        case 4 : {}\n        case 5 : {}\n        case 6 : {\n            // Read N bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                dwNumBits );\n            __asm mov eax, iTemp\n            __asm cmp iTemp, 0\n            __asm jl IfLessThanZero\n            // If >= 0: add (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov eax, 1\n            __asm shl eax, cl\n            __asm mov ecx, iTemp\n            __asm add ecx, eax\n            __asm mov iTemp, ecx\n            __asm jmp AfterTests\nIfLessThanZero :\n            // If < 0: subtract (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov edx, 1\n            __asm shl edx, cl\n            __asm mov eax, iTemp\n            __asm sub eax, edx\n            __asm mov iTemp, eax\n\nAfterTests :\n            // Shift by precision\n            __asm mov eax, iTemp\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n        case 7 : {\n            // Uncompressed: read (12 - iKeyBits) bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                12 - iKeyBits );\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n    }\n\n\nReturnZero :\n    __asm xor ax, ax\n    __asm mov sReturn, ax\n\nEnd :\n\n    return sReturn;\n}\n```\n\n---\n\n## 4. Implementation Guide\n\n### 4.1 LoadFrames Function\n\n**Purpose**: Load an entire frame (position + all bone rotations) at once.\n\n**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n\n**Parameters**:\n- `pfbFrameBuffer`: Pointer to frame buffer to fill\n- `iBones`: Number of bones in skeleton\n- `iBitStart`: Bit offset to start reading (0 for first frame)\n- `pbAnimBuffer`: Byte array containing animation data\n\n**Implementation**:\n\n```c\nDWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\nINT iBones,\nINT iBitStart,\nBYTE * pbAnimBuffer ) {\n    // Get backups of parameters\nDWORD       dwThisBitStart  = iBitStart;\n    INT     iThisBones      = iBones;\n    BYTE *  pbThisBuffer    = pbAnimBuffer;\n\n    PFF7FrameMiniHeader pfmhMiniHeader =\n        (PFF7FrameMiniHeader)pbAnimBuffer;\n    SHORT   sSize = pfmhMiniHeader->sSize;\n    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n\n    // Skip 5-byte miniheader\n    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n\n    if ( iBitStart == 0 ) { // First frame?\n        // Uncompressed position offsets\n        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n\n        // Convert to FLOAT\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Read rotations (12 - bKeyBits) bits each\n            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n\n            // Convert SHORT to INT (absolute value)\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n    else {                  // Subsequent frames\n        SHORT sX, sY, sZ;\n\n        // Get position deltas\n        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n\n        // Add deltas to previous frame\n        pfbFrameBuffer->svPosOffset.sX += sX;\n        pfbFrameBuffer->svPosOffset.sY += sY;\n        pfbFrameBuffer->svPosOffset.sZ += sZ;\n\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Get rotation deltas\n            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n\n            // Add deltas\n            pfbFrameBuffer->psvRots[I].sX += sX;\n            pfbFrameBuffer->psvRots[I].sY += sY;\n            pfbFrameBuffer->psvRots[I].sZ += sZ;\n\n            // Note: Values can exceed 4095 through accumulation of positive deltas\n\n            // Convert to INT\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n\n    // Return next frame's bit offset (or 0 if done)\n    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\nreturn dwThisBitStart;\n}\n    return 0;\n}\n```\n\n### 4.2 Complete Animation Loading Loop\n\n**Example**: Load all frames in an animation.\n\n```c\nFF7FrameHeader fhHeader;\nReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\nNULL );\nBYTE * baData = new BYTE[fhHeader.dwChunkSize];\nReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\nNULL );\n\n    // Allocate frame buffer\nFF7FrameBuffer fbFrameBuffer;\nfbFrameBuffer.SetBones( fhHeader.dwBones );\nINT iBits = 0;\n\nfor ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n    // Load frame\n    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n\n    // Reverse Y offset (required)\n    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n\n    // Convert INT rotations to FLOAT degrees\n    // Note: First rotation (root) is typically 0,0,0 but some animations\n    // store a base rotation for dynamic targeting\n    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n    }\n\n    // Store frame data here (application-specific)\n}\n\ndelete [] baData;\n```\n\n---\n\n## 5. Alternative Implementations\n\n### 5.1 Qhimm's C++ Versions\n\n**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n\n#### GetValueFromStream\n\nReplaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n\n```c\nshort GetValueFromStream( BYTE *pStreamBytes,\nDWORD *pdwStreamBitOffset )\n{\n    short sValue;\n    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n\n    // Test first bit to determine value size\n    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n    {   // 16-bit value\n        dwNextStreamBytes = dwNextStreamBytes << 8 |\n            pStreamBytes[dwStreamByteOffset + 2];\n        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n        *pdwStreamBitOffset += 17;\n    }\n    else\n    {   // 7-bit value\n        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n        *pdwStreamBitOffset += 8;\n    }\n\n    return sValue;\n}\n```\n\n#### GetCompressedDeltaFromStream\n\nReplaces `GetEncryptedRotationBits` with clearer C++ implementation.\n\n```c\nshort GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\nint nLoweredPrecisionBits )\n{\n    unsigned int nBits;\n    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n    if (iFirstBit)\n    {\n        unsigned int uType = GetBitsFromStream( pStreamBytes,\n            pdwStreamBitOffset, 3 ) & 7;\n        switch (uType)\n        {\n        case 0:\n            // Minimum decrement\n            return (-1 << nLoweredPrecisionBits);\n\n        case 1: case 2: case 3: case 4: case 5: case 6:\n            // Read N bits\n            int iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, nBits );\n            // Apply signed magnitude transform\n            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n            else            iTemp += 1 << (nBits - 1);\n            // Adjust for precision\n            return (iTemp << nLoweredPrecisionBits);\n\n        case 7:\n            // Uncompressed\n            iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n            return (iTemp << nLoweredPrecisionBits);\n        default:\n        }\n    }\n    return 0;\n}\n```\n\n### 5.2 Rotation Compression Theory\n\n*Notes by Qhimm*\n\n#### Why This Encoding Is Efficient\n\nRotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n\n**Bit Allocation**:\n- Zero delta: 1 bit (`0`)\n- Minimum decrement: 4 bits (`1 000`)\n- Small deltas (1-6 bits): 126 possible values\n- Large deltas: Uncompressed form\n\n**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n\n#### Signed Magnitude Encoding\n\nFor delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n\n1. **Magnitude**: Value of most significant value bit\n   - Example: Values `1` and `-2` both have magnitude `1`\n   - Value `30` has magnitude `32`\n\n2. **Signed Magnitude**: Magnitude Ã— sign of value\n   - Example: `-2` has signed magnitude `-1`\n\n3. **Encoding**: Subtract signed magnitude before storing\n   - Pushes values toward zero\n   - Ensures all transformed values fit in 6 bits or fewer\n\n4. **Decoding**: Add back the signed magnitude\n   - Magnitude determined by number of bits read\n   - Sign determined by MSB of encoded value\n\n#### Encoding Examples\n\n| Delta Value | Encoded Bits        | Notes                                    |\n|-------------|---------------------|------------------------------------------|\n| 0           | `0`                 | Single zero bit                          |\n| -1          | `1 000`             | Type 0 (minimum decrement)               |\n| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n\n*(Values shown in current precision as integers)*\n\n#### Precision Trade-offs\n\nPrecision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n\n**Advantages**:\n- Smaller raw values\n- Increased relative span of compressed encodings\n- Much smaller file sizes\n\n**Disadvantages**:\n- Quantization error\n- Less precise rotations\n\n**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n\n**Note**: Reduced precision is treated as rounding toward negative infinity.\n\n---\n\n## Appendix A: Quick Reference\n\n### Structure Sizes\n\n| Structure          | Size (bytes) | Offset Fields                              |\n|--------------------|--------------|--------------------------------------------|\n| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n\n### bKey Values\n\n| bKey | Uncompressed Bits | Formula         | Range   |\n|------|-------------------|-----------------|---------|\n| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n\n### Conversion Formulas\n\n**SHORT to Degrees**:\n```\ndegrees = (SHORT / 4096) * 360\n```\n\n**SHORT to INT (with wrapping)**:\n```\nINT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n```\n\n**INT to FLOAT**:\n```\nFLOAT = (INT / 4096.0f) * 360.0f\n```\n\n### Position Delta Encoding\n\n| First Bit | Total Bits | Format     |\n|-----------|------------|------------|\n| 0         | 8          | 7-bit delta|\n| 1         | 17         | 16-bit delta|\n\n### Rotation Delta Type Field\n\n| Type | Bits to Read        | Meaning                        |\n|------|---------------------|--------------------------------|\n| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n| 7    | `12 - bKey`         | Uncompressed rotation value    |\n\n---\n\n## Appendix B: Known Issues\n\n### Corrupted Animations\n\n**RSAA Animation 15** (playable frog):\n- Missing `sFrames` field\n- `sSize` appears at offset 0x00 instead of 0x02\n- `bKey` appears at offset 0x02 instead of 0x04\n- FF7 cannot load this animation (likely damaged in original game data)\n\n### Frame Count Discrepancies\n\n**sFrames vs. dwFrames**:\n- Rarely match in practice\n- `dwFrames` is more conservative (guarantees minimum)\n- `sFrames` sometimes exceeds actual frame count\n- **Solution**: Parse entire chunk to determine true frame count\n\n**Possible Causes**:\n- Dummy frames padded for memory alignment\n- Special-purpose data interleaved with frames\n- Animation authoring tool artifacts\n\n### Root Rotation Behavior\n\n**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n\n**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n- Model facing toward attack target\n- Model rotating during special moves\n\n**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n\n---\n\n**End of Document**\n","numLines":977,"startLine":1,"totalLines":977}}},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q7yjCrR2Jz6v4hozP7E5nT","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check if there are any images referenced in this document or related images in the images directory:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14126,"cache_read_input_tokens":65405,"cache_creation":{"ephemeral_5m_input_tokens":14126,"ephemeral_1h_input_tokens":0},"output_tokens":250,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"26fbf6fe-72b1-4a2c-b2fb-5f9273e65ab7"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q7yjCrR2Jz6v4hozP7E5nT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mq5vfKKX1RzdzEkDgUKPKh","name":"Glob","input":{"pattern":"**/images/*","path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14126,"cache_read_input_tokens":65405,"cache_creation":{"ephemeral_5m_input_tokens":14126,"ephemeral_1h_input_tokens":0},"output_tokens":250,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"16a88ed1-9670-4e11-9a56-e23b31629161"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q7yjCrR2Jz6v4hozP7E5nT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X3y623PTZdjxq5fZio5tHu","name":"Grep","input":{"pattern":"\\!\\[","path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/markdown/merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14126,"cache_read_input_tokens":65405,"cache_creation":{"ephemeral_5m_input_tokens":14126,"ephemeral_1h_input_tokens":0},"output_tokens":250,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"ae5b342d-9226-4135-99c6-715b9719003b"},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mq5vfKKX1RzdzEkDgUKPKh","type":"tool_result","content":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Engine_parts.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Field_BackgroundVRAM.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Gears_img_3.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Gears_img_4.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Kernel_table.png\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Windowbin.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_PC_Textures.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_PCT_Annotated.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Begin.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Party.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Item.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Magic.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Equip.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Status.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Change.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Limit.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Config.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Form.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Save.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Name.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Shop.jpg\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_TIM_file_layout.png\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_TIM_file_clut.png\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_16.png\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_TIM_file_image.png\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_24.png\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_8.png\n/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_4.png"}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"9be07b9d-bdef-4855-8b90-f6a70fa12aad","tool_use_result":{"filenames":["/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Engine_parts.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Field_BackgroundVRAM.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Gears_img_3.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Gears_img_4.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Kernel_table.png","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Windowbin.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_PC_Textures.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_PCT_Annotated.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Begin.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Party.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Item.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Magic.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Equip.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Status.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Change.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Limit.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Config.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Form.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Save.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Name.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/Menu_Shop.jpg","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_TIM_file_layout.png","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_TIM_file_clut.png","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_16.png","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_TIM_file_image.png","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_24.png","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_8.png","/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/images/PSX_color_formats_4.png"],"durationMs":12,"numFiles":28,"truncated":false}},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X3y623PTZdjxq5fZio5tHu","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"30181928-544a-493d-b24d-dfdf099b8dd4","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GJq3A6e6uakum9Zd2hr8NF","type":"message","role":"assistant","content":[{"type":"text","text":"Good - no images are referenced in the document. Now let me check the final directory to see if it exists:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1497,"cache_read_input_tokens":79531,"cache_creation":{"ephemeral_5m_input_tokens":1497,"ephemeral_1h_input_tokens":0},"output_tokens":150,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"3d288478-aba6-41dc-9fb3-d52310c8cf12"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GJq3A6e6uakum9Zd2hr8NF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VFmRmeydgkqaEqdaDkobM3","name":"Bash","input":{"command":"ls -la /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/ 2>/dev/null || echo \"Directory does not exist or is empty\"","description":"Check if final directory exists"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1497,"cache_read_input_tokens":79531,"cache_creation":{"ephemeral_5m_input_tokens":1497,"ephemeral_1h_input_tokens":0},"output_tokens":150,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"743ebf4c-711a-401a-9a54-26b71a4ca986"},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VFmRmeydgkqaEqdaDkobM3","type":"tool_result","content":"total 72\ndrwxr-xr-x@  3 johnzealand-doyle  staff     96 Dec  1 22:07 .\ndrwxr-xr-x@ 80 johnzealand-doyle  staff   2560 Dec  1 20:15 ..\n-rw-------@  1 johnzealand-doyle  staff  33759 Dec  1 22:07 FF7_Battle_Battle_Animation_PC.md","is_error":false}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"26ad5cd1-9a82-4335-86f8-95cd02e83ac3","tool_use_result":{"stdout":"total 72\ndrwxr-xr-x@  3 johnzealand-doyle  staff     96 Dec  1 22:07 .\ndrwxr-xr-x@ 80 johnzealand-doyle  staff   2560 Dec  1 20:15 ..\n-rw-------@  1 johnzealand-doyle  staff  33759 Dec  1 22:07 FF7_Battle_Battle_Animation_PC.md","stderr":"","interrupted":false,"isImage":false}},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016fy5uMi49NUfiec1eXtp2Z","type":"message","role":"assistant","content":[{"type":"text","text":"The file already exists. Let me check what's in it to understand if it was a previous attempt:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":381,"cache_read_input_tokens":81028,"cache_creation":{"ephemeral_5m_input_tokens":381,"ephemeral_1h_input_tokens":0},"output_tokens":137,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"c4485657-e35f-42f5-a36b-f83275e1ad40"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016fy5uMi49NUfiec1eXtp2Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DrnvwCKvXHiuDDUJpFdL32","name":"Read","input":{"file_path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":381,"cache_read_input_tokens":81028,"cache_creation":{"ephemeral_5m_input_tokens":381,"ephemeral_1h_input_tokens":0},"output_tokens":137,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"1d922415-a6d6-4ec4-8bdd-dd0d8d3819df"},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DrnvwCKvXHiuDDUJpFdL32","type":"tool_result","content":"     1â†’---\n     2â†’title: \"FF7 Battle Animation Format (PC)\"\n     3â†’module: \"Battle\"\n     4â†’created: \"2025-11-29 16:15 JST\"\n     5â†’modified: \"2025-12-01 22:04 JST\"\n     6â†’session_id: \"6136e9a8-64f9-4433-adfc-6f7e0338819b\"\n     7â†’author: \"Generated by Claude Code Documentation Standardization Agent\"\n     8â†’status: \"Complete\"\n     9â†’\n    10â†’# LLM-specific metadata (CRITICAL for routing)\n    11â†’llm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\n    12â†’llm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\n    13â†’llm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\n    14â†’llm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n    15â†’\n    16â†’# Backlinks (leave empty - populated in pass 2)\n    17â†’referenced_by: []\n    18â†’---\n    19â†’\n    20â†’<!--\n    21â†’STANDARDIZATION METADATA\n    22â†’Original: FF7_Battle_Battle_Animation_PC.md\n    23â†’Source: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\n    24â†’Standardized: 2025-12-01 22:04 JST\n    25â†’Session-ID: 6136e9a8-64f9-4433-adfc-6f7e0338819b\n    26â†’Agent: FF7 Documentation Standardization Agent v1.0\n    27â†’\n    28â†’Previous Merge Metadata:\n    29â†’MERGE METADATA\n    30â†’Created: 2025-11-29\n    31â†’Original: FF7_Battle_Battle_Animation_PC.md (912 lines)\n    32â†’Major section: 06_BATTLE_MODULE.md\n    33â†’Merge decision: NO EXTRACTION PERFORMED\n    34â†’Reason: Individual file contains comprehensive battle animation format documentation\n    35â†’Analysis: Major section does not contain additional PC animation format details\n    36â†’Status: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\n    37â†’Restructure: Improved organization, fixed typos, enhanced readability\n    38â†’\n    39â†’Standardization Changes Applied:\n    40â†’- Added YAML frontmatter with LLM routing metadata\n    41â†’- Added HTML comment metadata block preserving original merge metadata\n    42â†’- Added LLM context block for routing decisions\n    43â†’- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n    44â†’- Verified all code blocks have language tags (already present)\n    45â†’- Verified no wiki-style links present (none to convert)\n    46â†’- Verified no image references (none present in original)\n    47â†’- Added related document cross-references in frontmatter\n    48â†’\n    49â†’LLM CONTEXT BLOCK (Read this first for routing decisions):\n    50â†’This document provides comprehensive reverse-engineering documentation for FF7's PC battle\n    51â†’animation binary format, originally documented by L. Spiro. It covers the complete data\n    52â†’pipeline from file parsing through skeletal rotation decoding, including bit-stream reading\n    53â†’algorithms, delta compression schemes, and C++ implementations with inline assembly. Key\n    54â†’concepts include the bKey precision field controlling rotation bit depth, signed magnitude\n    55â†’encoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\n    56â†’is the definitive reference for implementing animation loaders or debugging animation playback.\n    57â†’Cross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n    58â†’-->\n    59â†’\n    60â†’# FF7 Battle Animation Format (PC)\n    61â†’\n    62â†’- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n    63â†’  - [Overview](#overview)\n    64â†’  - [1. File Structure](#1-file-structure)\n    65â†’  - [2. Data Structures](#2-data-structures)\n    66â†’  - [3. Decoding Algorithms](#3-decoding-algorithms)\n    67â†’  - [4. Implementation Guide](#4-implementation-guide)\n    68â†’  - [5. Alternative Implementations](#5-alternative-implementations)\n    69â†’  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n    70â†’  - [Appendix B: Known Issues](#appendix-b-known-issues)\n    71â†’\n    72â†’## Overview\n    73â†’\n    74â†’This document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n    75â†’\n    76â†’### What This Document Covers\n    77â†’\n    78â†’- Binary file structure for battle animations\n    79â†’- Data structures for storing skeletal animations\n    80â†’- Compression algorithms for rotation data\n    81â†’- Complete C++ implementation with assembly optimizations\n    82â†’- Theoretical background on the compression scheme\n    83â†’\n    84â†’### File Format Basics\n    85â†’\n    86â†’Battle animation files contain skeletal animation data for character models. Each file stores:\n    87â†’- Multiple animations for a single character\n    88â†’- Per-frame bone rotations and positions\n    89â†’- Compressed delta encoding for subsequent frames\n    90â†’- Special animation markers for scripted events\n    91â†’\n    92â†’---\n    93â†’\n    94â†’## 1. File Structure\n    95â†’\n    96â†’### 1.1 Animation File Layout\n    97â†’\n    98â†’Battle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n    99â†’\n   100â†’**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"c33609cb-234a-4a89-b064-af9e11422c80","tool_use_result":{"type":"text","file":{"filePath":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md","content":"---\ntitle: \"FF7 Battle Animation Format (PC)\"\nmodule: \"Battle\"\ncreated: \"2025-11-29 16:15 JST\"\nmodified: \"2025-12-01 22:04 JST\"\nsession_id: \"6136e9a8-64f9-4433-adfc-6f7e0338819b\"\nauthor: \"Generated by Claude Code Documentation Standardization Agent\"\nstatus: \"Complete\"\n\n# LLM-specific metadata (CRITICAL for routing)\nllm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\nllm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\nllm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\nllm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n\n# Backlinks (leave empty - populated in pass 2)\nreferenced_by: []\n---\n\n<!--\nSTANDARDIZATION METADATA\nOriginal: FF7_Battle_Battle_Animation_PC.md\nSource: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\nStandardized: 2025-12-01 22:04 JST\nSession-ID: 6136e9a8-64f9-4433-adfc-6f7e0338819b\nAgent: FF7 Documentation Standardization Agent v1.0\n\nPrevious Merge Metadata:\nMERGE METADATA\nCreated: 2025-11-29\nOriginal: FF7_Battle_Battle_Animation_PC.md (912 lines)\nMajor section: 06_BATTLE_MODULE.md\nMerge decision: NO EXTRACTION PERFORMED\nReason: Individual file contains comprehensive battle animation format documentation\nAnalysis: Major section does not contain additional PC animation format details\nStatus: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\nRestructure: Improved organization, fixed typos, enhanced readability\n\nStandardization Changes Applied:\n- Added YAML frontmatter with LLM routing metadata\n- Added HTML comment metadata block preserving original merge metadata\n- Added LLM context block for routing decisions\n- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n- Verified all code blocks have language tags (already present)\n- Verified no wiki-style links present (none to convert)\n- Verified no image references (none present in original)\n- Added related document cross-references in frontmatter\n\nLLM CONTEXT BLOCK (Read this first for routing decisions):\nThis document provides comprehensive reverse-engineering documentation for FF7's PC battle\nanimation binary format, originally documented by L. Spiro. It covers the complete data\npipeline from file parsing through skeletal rotation decoding, including bit-stream reading\nalgorithms, delta compression schemes, and C++ implementations with inline assembly. Key\nconcepts include the bKey precision field controlling rotation bit depth, signed magnitude\nencoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\nis the definitive reference for implementing animation loaders or debugging animation playback.\nCross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n-->\n\n# FF7 Battle Animation Format (PC)\n\n- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n  - [Overview](#overview)\n  - [1. File Structure](#1-file-structure)\n  - [2. Data Structures](#2-data-structures)\n  - [3. Decoding Algorithms](#3-decoding-algorithms)\n  - [4. Implementation Guide](#4-implementation-guide)\n  - [5. Alternative Implementations](#5-alternative-implementations)\n  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n  - [Appendix B: Known Issues](#appendix-b-known-issues)\n\n## Overview\n\nThis document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n\n### What This Document Covers\n\n- Binary file structure for battle animations\n- Data structures for storing skeletal animations\n- Compression algorithms for rotation data\n- Complete C++ implementation with assembly optimizations\n- Theoretical background on the compression scheme\n\n### File Format Basics\n\nBattle animation files contain skeletal animation data for character models. Each file stores:\n- Multiple animations for a single character\n- Per-frame bone rotations and positions\n- Compressed delta encoding for subsequent frames\n- Special animation markers for scripted events\n\n---\n\n## 1. File Structure\n\n### 1.1 Animation File Layout\n\nBattle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n\n**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.","numLines":100,"startLine":1,"totalLines":1024}}},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01F1VVVKAty8yHpZHNHWFc7L","type":"message","role":"assistant","content":[{"type":"text","text":"I see there's already a previous standardization attempt. However, I notice several issues with it:\n\n1. **YAML frontmatter is malformed** - Lines 10-17 have comments inside the YAML block that should be proper YAML, not markdown-style comments\n2. The session ID needs to be updated to the current session\n\nLet me read the complete file to understand the full scope:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1818,"cache_read_input_tokens":81409,"cache_creation":{"ephemeral_5m_input_tokens":1818,"ephemeral_1h_input_tokens":0},"output_tokens":185,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"04f4beee-906a-4640-a9cf-1a2484bc279c"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01F1VVVKAty8yHpZHNHWFc7L","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BzRNuqtaPAGa4kboZy95CL","name":"Read","input":{"file_path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1818,"cache_read_input_tokens":81409,"cache_creation":{"ephemeral_5m_input_tokens":1818,"ephemeral_1h_input_tokens":0},"output_tokens":185,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"9ba37147-c73b-438a-81c2-d3906cf8eefd"},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BzRNuqtaPAGa4kboZy95CL","type":"tool_result","content":"     1â†’---\n     2â†’title: \"FF7 Battle Animation Format (PC)\"\n     3â†’module: \"Battle\"\n     4â†’created: \"2025-11-29 16:15 JST\"\n     5â†’modified: \"2025-12-01 22:04 JST\"\n     6â†’session_id: \"6136e9a8-64f9-4433-adfc-6f7e0338819b\"\n     7â†’author: \"Generated by Claude Code Documentation Standardization Agent\"\n     8â†’status: \"Complete\"\n     9â†’\n    10â†’# LLM-specific metadata (CRITICAL for routing)\n    11â†’llm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\n    12â†’llm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\n    13â†’llm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\n    14â†’llm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n    15â†’\n    16â†’# Backlinks (leave empty - populated in pass 2)\n    17â†’referenced_by: []\n    18â†’---\n    19â†’\n    20â†’<!--\n    21â†’STANDARDIZATION METADATA\n    22â†’Original: FF7_Battle_Battle_Animation_PC.md\n    23â†’Source: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\n    24â†’Standardized: 2025-12-01 22:04 JST\n    25â†’Session-ID: 6136e9a8-64f9-4433-adfc-6f7e0338819b\n    26â†’Agent: FF7 Documentation Standardization Agent v1.0\n    27â†’\n    28â†’Previous Merge Metadata:\n    29â†’MERGE METADATA\n    30â†’Created: 2025-11-29\n    31â†’Original: FF7_Battle_Battle_Animation_PC.md (912 lines)\n    32â†’Major section: 06_BATTLE_MODULE.md\n    33â†’Merge decision: NO EXTRACTION PERFORMED\n    34â†’Reason: Individual file contains comprehensive battle animation format documentation\n    35â†’Analysis: Major section does not contain additional PC animation format details\n    36â†’Status: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\n    37â†’Restructure: Improved organization, fixed typos, enhanced readability\n    38â†’\n    39â†’Standardization Changes Applied:\n    40â†’- Added YAML frontmatter with LLM routing metadata\n    41â†’- Added HTML comment metadata block preserving original merge metadata\n    42â†’- Added LLM context block for routing decisions\n    43â†’- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n    44â†’- Verified all code blocks have language tags (already present)\n    45â†’- Verified no wiki-style links present (none to convert)\n    46â†’- Verified no image references (none present in original)\n    47â†’- Added related document cross-references in frontmatter\n    48â†’\n    49â†’LLM CONTEXT BLOCK (Read this first for routing decisions):\n    50â†’This document provides comprehensive reverse-engineering documentation for FF7's PC battle\n    51â†’animation binary format, originally documented by L. Spiro. It covers the complete data\n    52â†’pipeline from file parsing through skeletal rotation decoding, including bit-stream reading\n    53â†’algorithms, delta compression schemes, and C++ implementations with inline assembly. Key\n    54â†’concepts include the bKey precision field controlling rotation bit depth, signed magnitude\n    55â†’encoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\n    56â†’is the definitive reference for implementing animation loaders or debugging animation playback.\n    57â†’Cross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n    58â†’-->\n    59â†’\n    60â†’# FF7 Battle Animation Format (PC)\n    61â†’\n    62â†’- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n    63â†’  - [Overview](#overview)\n    64â†’  - [1. File Structure](#1-file-structure)\n    65â†’  - [2. Data Structures](#2-data-structures)\n    66â†’  - [3. Decoding Algorithms](#3-decoding-algorithms)\n    67â†’  - [4. Implementation Guide](#4-implementation-guide)\n    68â†’  - [5. Alternative Implementations](#5-alternative-implementations)\n    69â†’  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n    70â†’  - [Appendix B: Known Issues](#appendix-b-known-issues)\n    71â†’\n    72â†’## Overview\n    73â†’\n    74â†’This document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n    75â†’\n    76â†’### What This Document Covers\n    77â†’\n    78â†’- Binary file structure for battle animations\n    79â†’- Data structures for storing skeletal animations\n    80â†’- Compression algorithms for rotation data\n    81â†’- Complete C++ implementation with assembly optimizations\n    82â†’- Theoretical background on the compression scheme\n    83â†’\n    84â†’### File Format Basics\n    85â†’\n    86â†’Battle animation files contain skeletal animation data for character models. Each file stores:\n    87â†’- Multiple animations for a single character\n    88â†’- Per-frame bone rotations and positions\n    89â†’- Compressed delta encoding for subsequent frames\n    90â†’- Special animation markers for scripted events\n    91â†’\n    92â†’---\n    93â†’\n    94â†’## 1. File Structure\n    95â†’\n    96â†’### 1.1 Animation File Layout\n    97â†’\n    98â†’Battle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n    99â†’\n   100â†’**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n   101â†’\n   102â†’To navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n   103â†’\n   104â†’### 1.2 File Header Format\n   105â†’\n   106â†’Each animation begins with a 12-byte header followed by animation data.\n   107â†’\n   108â†’---\n   109â†’\n   110â†’## 2. Data Structures\n   111â†’\n   112â†’### 2.1 FF7FrameHeader\n   113â†’\n   114â†’**Purpose**: Main header for each animation in the file.\n   115â†’\n   116â†’**Structure** (12 bytes):\n   117â†’\n   118â†’```c\n   119â†’typedef struct FF7FrameHeader {\n   120â†’    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n   121â†’                                // NOTE: Unreliable - use skeleton file bone count instead.\n   122â†’    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n   123â†’    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n   124â†’} * PFF7FrameHeader;            // Total size: 12 bytes\n   125â†’```\n   126â†’\n   127â†’#### Special Animation Chunks\n   128â†’\n   129â†’When `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n   130â†’\n   131â†’#### Navigation Example\n   132â†’\n   133â†’To skip to animation index `iTarget`:\n   134â†’\n   135â†’```c\n   136â†’FF7FrameHeader  fhHeader;\n   137â†’DWORD           dwBytesRead;\n   138â†’for ( int I = 0; I < iTarget; I++ ) {\n   139â†’    if ( !ReadFile( hFile,\n   140â†’        &fhHeader, sizeof( fhHeader ),\n   141â†’        &dwBytesRead, NULL ) ) {\n   142â†’\n   143â†’    CloseHandle( hFile );\n   144â†’    return false;\n   145â†’    }\n   146â†’    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n   147â†’        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n   148â†’        INVALID_SET_FILE_POINTER ) {\n   149â†’            CloseHandle( hFile );\n   150â†’            return false;\n   151â†’        }\n   152â†’        continue;\n   153â†’    }\n   154â†’    // Skip this animation (size = dwChunkSize)\n   155â†’    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n   156â†’    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n   157â†’        CloseHandle( hFile );\n   158â†’        return false;\n   159â†’    }\n   160â†’}\n   161â†’// Now at the target animation\n   162â†’if ( !ReadFile( hFile,\n   163â†’    &fhHeader, sizeof( fhHeader ),\n   164â†’    &dwBytesRead, NULL ) ) {\n   165â†’\n   166â†’    CloseHandle( hFile );\n   167â†’    return false;\n   168â†’}\n   169â†’BYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n   170â†’// pbBuffer now holds animation data including FF7FrameMiniHeader\n   171â†’```\n   172â†’\n   173â†’### 2.2 FF7FrameMiniHeader\n   174â†’\n   175â†’**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n   176â†’\n   177â†’**Structure** (5 bytes):\n   178â†’\n   179â†’```c\n   180â†’typedef struct FF7FrameMiniHeader {\n   181â†’    //SHORT     sBones; // Originally thought to be bone count\n   182â†’    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n   183â†’    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n   184â†’    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n   185â†’} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n   186â†’```\n   187â†’\n   188â†’#### Field Discrepancy Notes\n   189â†’\n   190â†’**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n   191â†’\n   192â†’**Reliability**: `sFrames` and `dwFrames` rarely match.\n   193â†’- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n   194â†’- `sFrames` sometimes exceeds actual frame count\n   195â†’- **Determine actual frame count by parsing the entire chunk**\n   196â†’\n   197â†’**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n   198â†’- `sSize` appears at offset 0x00\n   199â†’- `bKey` appears at offset 0x02\n   200â†’- FF7 cannot handle this animation (likely corrupted)\n   201â†’\n   202â†’### 2.3 bKey: The Precision Field\n   203â†’\n   204â†’**Purpose**: Controls rotation data bit depth and compression level.\n   205â†’\n   206â†’#### Valid Values\n   207â†’\n   208â†’| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n   209â†’|------------|-------------------|-----------|----------------|\n   210â†’| 0          | 12                | 0-4095    | None           |\n   211â†’| 2          | 10                | 0-1023    | Low            |\n   212â†’| 4          | 8                 | 0-255     | Moderate       |\n   213â†’\n   214â†’#### How It Works\n   215â†’\n   216â†’1. **Storage**: Rotations stored using `(12 - bKey)` bits\n   217â†’2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   218â†’   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n   219â†’3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n   220â†’\n   221â†’**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n   222â†’\n   223â†’### 2.4 FF7ShortVec (Rotation Storage)\n   224â†’\n   225â†’**Purpose**: Stores one bone's rotation in three numeric forms.\n   226â†’\n   227â†’**Structure** (30 bytes):\n   228â†’\n   229â†’```c\n   230â†’typedef struct FF7ShortVec {\n   231â†’    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n   232â†’    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n   233â†’    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n   234â†’} * PFF7ShortRot;           // Total size: 30 bytes\n   235â†’```\n   236â†’\n   237â†’#### Three-Form Conversion\n   238â†’\n   239â†’Rotations are processed through three representations:\n   240â†’\n   241â†’1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n   242â†’2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   243â†’   - If `SHORT < 0`, add `0x1000` (4096)\n   244â†’3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n   245â†’\n   246â†’#### Per-Frame Processing Sequence\n   247â†’\n   248â†’**First Frame**:\n   249â†’1. Read X bits (determined by `bKey`) and store as signed SHORT\n   250â†’2. Convert SHORT to INT (add 0x1000 if negative)\n   251â†’3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n   252â†’4. Apply FLOAT rotation to model\n   253â†’\n   254â†’**Subsequent Frames**:\n   255â†’1. Read delta value, add to previous frame's SHORT\n   256â†’2. Convert updated SHORT to INT (add 0x1000 if negative)\n   257â†’3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n   258â†’4. Apply FLOAT rotation to model\n   259â†’\n   260â†’**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n   261â†’\n   262â†’### 2.5 FF7FrameBuffer (Frame Management)\n   263â†’\n   264â†’**Purpose**: Allocates memory for one frame's worth of bone rotations.\n   265â†’\n   266â†’**Structure**:\n   267â†’\n   268â†’```cpp\n   269â†’typedef struct FF7FrameBuffer {\n   270â†’    DWORD           dwBones;\n   271â†’    FF7ShortVec     svPosOffset;\n   272â†’    FF7ShortVec     *psvRots;\n   273â†’\n   274â†’    FF7FrameBuffer() {\n   275â†’        dwBones = 0;\n   276â†’        psvRots = NULL;\n   277â†’    }\n   278â†’    ~FF7FrameBuffer() {\n   279â†’        dwBones = 0;\n   280â†’        delete [] psvRots;\n   281â†’        psvRots = NULL;\n   282â†’    }\n   283â†’\n   284â†’    VOID    SetBones( DWORD dwTotal ) {\n   285â†’        // Delete the old\n   286â†’        dwBones = 0;\n   287â†’        delete [] psvRots;\n   288â†’\n   289â†’        // Create the new\n   290â†’        psvRots = new FF7ShortVec[dwTotal];\n   291â†’        if ( psvRots != NULL ) { dwBones = dwTotal; }\n   292â†’    }\n   293â†’} * PFF7FrameBuffer;\n   294â†’```\n   295â†’\n   296â†’**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n   297â†’\n   298â†’---\n   299â†’\n   300â†’## 3. Decoding Algorithms\n   301â†’\n   302â†’### 3.1 Bit Stream Reading\n   303â†’\n   304â†’#### GetBitsFixed Function\n   305â†’\n   306â†’**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n   307â†’\n   308â†’**Parameters**:\n   309â†’- `pbBuffer`: Byte array containing bit stream\n   310â†’- `dwStartBit`: Bit offset to start reading (modified in place)\n   311â†’- `dwTotalBits`: Number of bits to read\n   312â†’\n   313â†’**Returns**: Signed integer with sign extension.\n   314â†’\n   315â†’**Implementation**:\n   316â†’\n   317â†’```c\n   318â†’INT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\n   319â†’DWORD dwTotalBits ) {\n   320â†’    INT iReturn = 0;\n   321â†’\n   322â†’    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n   323â†’        iReturn <<= 1;\n   324â†’\n   325â†’        __asm mov eax, dwStartBit\n   326â†’        __asm mov eax, [eax]\n   327â†’        __asm cdq\n   328â†’        __asm and edx, 7\n   329â†’        __asm add eax, edx\n   330â†’        __asm sar eax, 3\n   331â†’        __asm mov ecx, pbBuffer\n   332â†’        __asm xor edx, edx\n   333â†’        __asm mov dl, byte ptr ds:[ecx+eax]\n   334â†’        __asm mov eax, dwStartBit\n   335â†’        __asm mov ecx, [eax]\n   336â†’        __asm and ecx, 7\n   337â†’        __asm mov eax, 7\n   338â†’        __asm sub eax, ecx\n   339â†’        __asm mov esi, 1\n   340â†’        __asm mov ecx, eax\n   341â†’        __asm shl esi, cl\n   342â†’        __asm and edx, esi\n   343â†’        __asm test edx, edx\n   344â†’        __asm je INCBIT\n   345â†’        iReturn++;\n   346â†’INCBIT: dwStartBit++;\n   347â†’    }\n   348â†’\n   349â†’    // Force sign bit to extend across 32-bit boundary\n   350â†’    iReturn <<= (0x20 - dwTotalBits);\n   351â†’    iReturn >>= (0x20 - dwTotalBits);\n   352â†’    return iReturn;\n   353â†’}\n   354â†’```\n   355â†’\n   356â†’### 3.2 First Frame (Uncompressed)\n   357â†’\n   358â†’The first frame stores absolute values with no delta compression.\n   359â†’\n   360â†’#### 3.2.1 Position Offsets\n   361â†’\n   362â†’**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n   363â†’\n   364â†’**Example** (Cloud's first animation, `rtda`):\n   365â†’- Bytes: `00 00 FE 2E 00 00`\n   366â†’- Values: `X=0`, `Y=-466`, `Z=0`\n   367â†’- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n   368â†’\n   369â†’**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n   370â†’\n   371â†’**Code**:\n   372â†’\n   373â†’```c\n   374â†’PFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\n   375â†’BYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n   376â†’\n   377â†’DWORD dwBitStart = 0;\n   378â†’SHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   379â†’SHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   380â†’SHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   381â†’// Result: sX=0, sY=-466, sZ=0\n   382â†’```\n   383â†’\n   384â†’#### 3.2.2 Rotation Data\n   385â†’\n   386â†’**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n   387â†’- If `bKey = 0`: 12 bits per rotation\n   388â†’- If `bKey = 2`: 10 bits per rotation\n   389â†’- If `bKey = 4`: 8 bits per rotation\n   390â†’\n   391â†’**Normalization**: Shift left by `bKey` to restore 12-bit range.\n   392â†’\n   393â†’**Code** (for each bone's 3 rotations):\n   394â†’\n   395â†’```c\n   396â†’SHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   397â†’12 - pfmhMiniHeader->bKey );\n   398â†’SHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   399â†’12 - pfmhMiniHeader->bKey );\n   400â†’SHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   401â†’12 - pfmhMiniHeader->bKey );\n   402â†’\n   403â†’// Normalize to 12-bit range\n   404â†’sRotX <<= pfmhMiniHeader->bKey;\n   405â†’sRotY <<= pfmhMiniHeader->bKey;\n   406â†’sRotZ <<= pfmhMiniHeader->bKey;\n   407â†’```\n   408â†’\n   409â†’### 3.3 Subsequent Frames (Compressed Delta Encoding)\n   410â†’\n   411â†’Frames after the first store delta values (changes from previous frame).\n   412â†’\n   413â†’#### 3.3.1 Position Deltas\n   414â†’\n   415â†’**Format**: Variable-length encoding (8 or 17 bits)\n   416â†’\n   417â†’**Algorithm**:\n   418â†’1. Read 1 flag bit\n   419â†’   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   420â†’   - If `1`: Next 16 bits are signed delta (total 17 bits)\n   421â†’\n   422â†’**GetDynamicFrameOffsetBits Function**:\n   423â†’\n   424â†’```c\n   425â†’SHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\n   426â†’DWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n   427â†’    SHORT sReturn;\n   428â†’    __asm {\n   429â†’        mov eax, dwBitStart\n   430â†’        mov eax, [eax]\n   431â†’        cdq\n   432â†’        and edx, 7\n   433â†’        add eax, edx\n   434â†’        sar eax, 3\n   435â†’        mov dwFirstByte, eax\n   436â†’        mov ecx, dwBitStart\n   437â†’        mov edx, [ecx]\n   438â†’        and edx, 7\n   439â†’        mov dwConsumedBits, edx\n   440â†’        mov eax, 7\n   441â†’        sub eax, dwConsumedBits\n   442â†’        mov dwBitsRemainingToNextByte, eax\n   443â†’        mov ecx, pBuffer\n   444â†’        add ecx, dwFirstByte\n   445â†’        xor edx, edx\n   446â†’        mov dl, byte ptr ds:[ecx]\n   447â†’        shl edx, 8\n   448â†’        mov eax, pBuffer\n   449â†’        add eax, dwFirstByte\n   450â†’        xor ecx, ecx\n   451â†’        mov cl, byte ptr ds:[eax+1]\n   452â†’        or edx, ecx\n   453â†’        mov dwTemp, edx\n   454â†’        mov ecx, dwBitsRemainingToNextByte\n   455â†’        add ecx, 8\n   456â†’        mov edx, 1\n   457â†’        shl edx, cl\n   458â†’        mov eax, dwTemp\n   459â†’        and eax, edx\n   460â†’        test eax, eax\n   461â†’        jnz SeventeenBits\n   462â†’\n   463â†’EightBits :\n   464â†’        mov ecx, dwConsumedBits\n   465â†’        add ecx, 1\n   466â†’        mov edx, dwTemp\n   467â†’        shl edx, cl\n   468â†’        movsx eax, dx\n   469â†’        sar eax, 9\n   470â†’        mov sReturn, ax\n   471â†’        mov ecx, dwBitStart\n   472â†’        mov edx, [ecx]\n   473â†’        add edx, 8\n   474â†’        mov eax, dwBitStart\n   475â†’        mov [eax], edx      // Increase dwBitStart by 8\n   476â†’        jmp End\n   477â†’\n   478â†’SeventeenBits :\n   479â†’        mov ecx, dwTemp\n   480â†’        shl ecx, 8\n   481â†’        mov edx, pBuffer\n   482â†’        add edx, dwFirstByte\n   483â†’        xor eax, eax\n   484â†’        mov al, byte ptr ds:[edx+2]\n   485â†’        or ecx, eax\n   486â†’        mov dwTemp, ecx\n   487â†’        mov ecx, dwConsumedBits\n   488â†’        add ecx, 1\n   489â†’        mov edx, dwTemp\n   490â†’        shl edx, cl\n   491â†’        shr edx, 8\n   492â†’        mov sReturn, dx\n   493â†’        mov eax, dwBitStart\n   494â†’        mov ecx, [eax]\n   495â†’        add ecx, 0x11\n   496â†’        mov edx, dwBitStart\n   497â†’        mov [edx], ecx      // Increase dwBitStart by 17\n   498â†’\n   499â†’End :\n   500â†’    }\n   501â†’    return sReturn;\n   502â†’}\n   503â†’```\n   504â†’\n   505â†’**Usage**:\n   506â†’\n   507â†’```c\n   508â†’SHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   509â†’SHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   510â†’SHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   511â†’\n   512â†’// Add deltas to previous frame\n   513â†’FF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\n   514â†’FF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\n   515â†’FF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n   516â†’```\n   517â†’\n   518â†’#### 3.3.2 Rotation Deltas\n   519â†’\n   520â†’**Format**: Complex variable-length encoding optimized for small deltas.\n   521â†’\n   522â†’**Algorithm Overview**:\n   523â†’1. Read 1 flag bit:\n   524â†’   - If `0`: Delta is zero, done\n   525â†’   - If `1`: Continue to step 2\n   526â†’2. Read 3-bit type field (values 0-7)\n   527â†’3. Decode based on type:\n   528â†’   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   529â†’   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   530â†’   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n   531â†’\n   532â†’**Signed Magnitude Transform** (Types 1-6):\n   533â†’\n   534â†’If the N-bit value is negative:\n   535â†’- Subtract `(1 << (N - 1))`\n   536â†’\n   537â†’If positive:\n   538â†’- Add `(1 << (N - 1))`\n   539â†’\n   540â†’Finally, shift left by `bKey` to adjust for precision.\n   541â†’\n   542â†’**Example** (Type 4, meaning 4 bits):\n   543â†’- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n   544â†’- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n   545â†’- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n   546â†’\n   547â†’**GetEncryptedRotationBits Function**:\n   548â†’\n   549â†’```c\n   550â†’SHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\n   551â†’INT iKeyBits ) {\n   552â†’    DWORD dwNumBits, dwType;\n   553â†’    INT iTemp;\n   554â†’    SHORT sReturn;\n   555â†’    // Check the first bit\n   556â†’    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n   557â†’    __asm mov eax, iBits\n   558â†’    __asm test eax, eax\n   559â†’    __asm jnz SecondTest\n   560â†’    __asm jmp ReturnZero    // Return 0\n   561â†’\n   562â†’SecondTest :\n   563â†’    // Get next 3 bits\n   564â†’    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n   565â†’    __asm mov eax, iBits\n   566â†’    __asm and eax, 7\n   567â†’    __asm mov dwNumBits, eax\n   568â†’    __asm mov ecx, dwNumBits\n   569â†’    __asm mov dwType, ecx\n   570â†’    __asm cmp dwType, 7\n   571â†’    __asm ja ReturnZero\n   572â†’\n   573â†’    // Switch on type\n   574â†’    switch ( dwType ) {\n   575â†’        case 0 : {\n   576â†’            __asm or eax, 0xFFFFFFFF    // EAX = -1\n   577â†’            __asm mov ecx, iKeyBits\n   578â†’            __asm shl eax, cl           // (-1 << iKeyBits)\n   579â†’            __asm mov sReturn, ax\n   580â†’            __asm jmp End\n   581â†’        }\n   582â†’        case 1 : {}\n   583â†’        case 2 : {}\n   584â†’        case 3 : {}\n   585â†’        case 4 : {}\n   586â†’        case 5 : {}\n   587â†’        case 6 : {\n   588â†’            // Read N bits\n   589â†’            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n   590â†’                dwNumBits );\n   591â†’            __asm mov eax, iTemp\n   592â†’            __asm cmp iTemp, 0\n   593â†’            __asm jl IfLessThanZero\n   594â†’            // If >= 0: add (1 << (dwNumBits - 1))\n   595â†’            __asm mov ecx, dwNumBits\n   596â†’            __asm sub ecx, 1\n   597â†’            __asm mov eax, 1\n   598â†’            __asm shl eax, cl\n   599â†’            __asm mov ecx, iTemp\n   600â†’            __asm add ecx, eax\n   601â†’            __asm mov iTemp, ecx\n   602â†’            __asm jmp AfterTests\n   603â†’IfLessThanZero :\n   604â†’            // If < 0: subtract (1 << (dwNumBits - 1))\n   605â†’            __asm mov ecx, dwNumBits\n   606â†’            __asm sub ecx, 1\n   607â†’            __asm mov edx, 1\n   608â†’            __asm shl edx, cl\n   609â†’            __asm mov eax, iTemp\n   610â†’            __asm sub eax, edx\n   611â†’            __asm mov iTemp, eax\n   612â†’\n   613â†’AfterTests :\n   614â†’            // Shift by precision\n   615â†’            __asm mov eax, iTemp\n   616â†’            __asm mov ecx, iKeyBits\n   617â†’            __asm shl eax, cl\n   618â†’            __asm mov sReturn, ax\n   619â†’            __asm jmp End\n   620â†’        }\n   621â†’\n   622â†’        case 7 : {\n   623â†’            // Uncompressed: read (12 - iKeyBits) bits\n   624â†’            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n   625â†’                12 - iKeyBits );\n   626â†’            __asm mov ecx, iKeyBits\n   627â†’            __asm shl eax, cl\n   628â†’            __asm mov sReturn, ax\n   629â†’            __asm jmp End\n   630â†’        }\n   631â†’\n   632â†’    }\n   633â†’\n   634â†’\n   635â†’ReturnZero :\n   636â†’    __asm xor ax, ax\n   637â†’    __asm mov sReturn, ax\n   638â†’\n   639â†’End :\n   640â†’\n   641â†’    return sReturn;\n   642â†’}\n   643â†’```\n   644â†’\n   645â†’---\n   646â†’\n   647â†’## 4. Implementation Guide\n   648â†’\n   649â†’### 4.1 LoadFrames Function\n   650â†’\n   651â†’**Purpose**: Load an entire frame (position + all bone rotations) at once.\n   652â†’\n   653â†’**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n   654â†’\n   655â†’**Parameters**:\n   656â†’- `pfbFrameBuffer`: Pointer to frame buffer to fill\n   657â†’- `iBones`: Number of bones in skeleton\n   658â†’- `iBitStart`: Bit offset to start reading (0 for first frame)\n   659â†’- `pbAnimBuffer`: Byte array containing animation data\n   660â†’\n   661â†’**Implementation**:\n   662â†’\n   663â†’```c\n   664â†’DWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\n   665â†’INT iBones,\n   666â†’INT iBitStart,\n   667â†’BYTE * pbAnimBuffer ) {\n   668â†’    // Get backups of parameters\n   669â†’DWORD       dwThisBitStart  = iBitStart;\n   670â†’    INT     iThisBones      = iBones;\n   671â†’    BYTE *  pbThisBuffer    = pbAnimBuffer;\n   672â†’\n   673â†’    PFF7FrameMiniHeader pfmhMiniHeader =\n   674â†’        (PFF7FrameMiniHeader)pbAnimBuffer;\n   675â†’    SHORT   sSize = pfmhMiniHeader->sSize;\n   676â†’    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n   677â†’\n   678â†’    // Skip 5-byte miniheader\n   679â†’    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n   680â†’\n   681â†’    if ( iBitStart == 0 ) { // First frame?\n   682â†’        // Uncompressed position offsets\n   683â†’        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   684â†’        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   685â†’        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   686â†’\n   687â†’        // Convert to FLOAT\n   688â†’        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n   689â†’        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n   690â†’        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n   691â†’\n   692â†’        for ( int I = 0; I < iThisBones; I++ ) {\n   693â†’            // Read rotations (12 - bKeyBits) bits each\n   694â†’            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   695â†’            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   696â†’            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   697â†’\n   698â†’            // Convert SHORT to INT (absolute value)\n   699â†’            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n   700â†’            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n   701â†’            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n   702â†’        }\n   703â†’    }\n   704â†’    else {                  // Subsequent frames\n   705â†’        SHORT sX, sY, sZ;\n   706â†’\n   707â†’        // Get position deltas\n   708â†’        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   709â†’        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   710â†’        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   711â†’\n   712â†’        // Add deltas to previous frame\n   713â†’        pfbFrameBuffer->svPosOffset.sX += sX;\n   714â†’        pfbFrameBuffer->svPosOffset.sY += sY;\n   715â†’        pfbFrameBuffer->svPosOffset.sZ += sZ;\n   716â†’\n   717â†’        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n   718â†’        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n   719â†’        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n   720â†’\n   721â†’        for ( int I = 0; I < iThisBones; I++ ) {\n   722â†’            // Get rotation deltas\n   723â†’            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   724â†’            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   725â†’            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   726â†’\n   727â†’            // Add deltas\n   728â†’            pfbFrameBuffer->psvRots[I].sX += sX;\n   729â†’            pfbFrameBuffer->psvRots[I].sY += sY;\n   730â†’            pfbFrameBuffer->psvRots[I].sZ += sZ;\n   731â†’\n   732â†’            // Note: Values can exceed 4095 through accumulation of positive deltas\n   733â†’\n   734â†’            // Convert to INT\n   735â†’            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n   736â†’            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n   737â†’            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n   738â†’        }\n   739â†’    }\n   740â†’\n   741â†’    // Return next frame's bit offset (or 0 if done)\n   742â†’    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\n   743â†’return dwThisBitStart;\n   744â†’}\n   745â†’    return 0;\n   746â†’}\n   747â†’```\n   748â†’\n   749â†’### 4.2 Complete Animation Loading Loop\n   750â†’\n   751â†’**Example**: Load all frames in an animation.\n   752â†’\n   753â†’```c\n   754â†’FF7FrameHeader fhHeader;\n   755â†’ReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\n   756â†’NULL );\n   757â†’BYTE * baData = new BYTE[fhHeader.dwChunkSize];\n   758â†’ReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\n   759â†’NULL );\n   760â†’\n   761â†’    // Allocate frame buffer\n   762â†’FF7FrameBuffer fbFrameBuffer;\n   763â†’fbFrameBuffer.SetBones( fhHeader.dwBones );\n   764â†’INT iBits = 0;\n   765â†’\n   766â†’for ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n   767â†’    // Load frame\n   768â†’    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n   769â†’\n   770â†’    // Reverse Y offset (required)\n   771â†’    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n   772â†’\n   773â†’    // Convert INT rotations to FLOAT degrees\n   774â†’    // Note: First rotation (root) is typically 0,0,0 but some animations\n   775â†’    // store a base rotation for dynamic targeting\n   776â†’    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n   777â†’        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n   778â†’        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n   779â†’        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n   780â†’    }\n   781â†’\n   782â†’    // Store frame data here (application-specific)\n   783â†’}\n   784â†’\n   785â†’delete [] baData;\n   786â†’```\n   787â†’\n   788â†’---\n   789â†’\n   790â†’## 5. Alternative Implementations\n   791â†’\n   792â†’### 5.1 Qhimm's C++ Versions\n   793â†’\n   794â†’**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n   795â†’\n   796â†’#### GetValueFromStream\n   797â†’\n   798â†’Replaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n   799â†’\n   800â†’```cpp\n   801â†’short GetValueFromStream( BYTE *pStreamBytes,\n   802â†’DWORD *pdwStreamBitOffset )\n   803â†’{\n   804â†’    short sValue;\n   805â†’    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n   806â†’    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n   807â†’    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n   808â†’    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n   809â†’\n   810â†’    // Test first bit to determine value size\n   811â†’    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n   812â†’    {   // 16-bit value\n   813â†’        dwNextStreamBytes = dwNextStreamBytes << 8 |\n   814â†’            pStreamBytes[dwStreamByteOffset + 2];\n   815â†’        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n   816â†’        *pdwStreamBitOffset += 17;\n   817â†’    }\n   818â†’    else\n   819â†’    {   // 7-bit value\n   820â†’        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n   821â†’        *pdwStreamBitOffset += 8;\n   822â†’    }\n   823â†’\n   824â†’    return sValue;\n   825â†’}\n   826â†’```\n   827â†’\n   828â†’#### GetCompressedDeltaFromStream\n   829â†’\n   830â†’Replaces `GetEncryptedRotationBits` with clearer C++ implementation.\n   831â†’\n   832â†’```cpp\n   833â†’short GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\n   834â†’int nLoweredPrecisionBits )\n   835â†’{\n   836â†’    unsigned int nBits;\n   837â†’    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n   838â†’    if (iFirstBit)\n   839â†’    {\n   840â†’        unsigned int uType = GetBitsFromStream( pStreamBytes,\n   841â†’            pdwStreamBitOffset, 3 ) & 7;\n   842â†’        switch (uType)\n   843â†’        {\n   844â†’        case 0:\n   845â†’            // Minimum decrement\n   846â†’            return (-1 << nLoweredPrecisionBits);\n   847â†’\n   848â†’        case 1: case 2: case 3: case 4: case 5: case 6:\n   849â†’            // Read N bits\n   850â†’            int iTemp = GetBitsFromStream( pStreamBytes,\n   851â†’                pdwStreamBitOffset, nBits );\n   852â†’            // Apply signed magnitude transform\n   853â†’            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n   854â†’            else            iTemp += 1 << (nBits - 1);\n   855â†’            // Adjust for precision\n   856â†’            return (iTemp << nLoweredPrecisionBits);\n   857â†’\n   858â†’        case 7:\n   859â†’            // Uncompressed\n   860â†’            iTemp = GetBitsFromStream( pStreamBytes,\n   861â†’                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n   862â†’            return (iTemp << nLoweredPrecisionBits);\n   863â†’        default:\n   864â†’        }\n   865â†’    }\n   866â†’    return 0;\n   867â†’}\n   868â†’```\n   869â†’\n   870â†’### 5.2 Rotation Compression Theory\n   871â†’\n   872â†’*Notes by Qhimm*\n   873â†’\n   874â†’#### Why This Encoding Is Efficient\n   875â†’\n   876â†’Rotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n   877â†’\n   878â†’**Bit Allocation**:\n   879â†’- Zero delta: 1 bit (`0`)\n   880â†’- Minimum decrement: 4 bits (`1 000`)\n   881â†’- Small deltas (1-6 bits): 126 possible values\n   882â†’- Large deltas: Uncompressed form\n   883â†’\n   884â†’**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n   885â†’\n   886â†’#### Signed Magnitude Encoding\n   887â†’\n   888â†’For delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n   889â†’\n   890â†’1. **Magnitude**: Value of most significant value bit\n   891â†’   - Example: Values `1` and `-2` both have magnitude `1`\n   892â†’   - Value `30` has magnitude `32`\n   893â†’\n   894â†’2. **Signed Magnitude**: Magnitude Ã— sign of value\n   895â†’   - Example: `-2` has signed magnitude `-1`\n   896â†’\n   897â†’3. **Encoding**: Subtract signed magnitude before storing\n   898â†’   - Pushes values toward zero\n   899â†’   - Ensures all transformed values fit in 6 bits or fewer\n   900â†’\n   901â†’4. **Decoding**: Add back the signed magnitude\n   902â†’   - Magnitude determined by number of bits read\n   903â†’   - Sign determined by MSB of encoded value\n   904â†’\n   905â†’#### Encoding Examples\n   906â†’\n   907â†’| Delta Value | Encoded Bits        | Notes                                    |\n   908â†’|-------------|---------------------|------------------------------------------|\n   909â†’| 0           | `0`                 | Single zero bit                          |\n   910â†’| -1          | `1 000`             | Type 0 (minimum decrement)               |\n   911â†’| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n   912â†’| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n   913â†’| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n   914â†’\n   915â†’*(Values shown in current precision as integers)*\n   916â†’\n   917â†’#### Precision Trade-offs\n   918â†’\n   919â†’Precision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n   920â†’\n   921â†’**Advantages**:\n   922â†’- Smaller raw values\n   923â†’- Increased relative span of compressed encodings\n   924â†’- Much smaller file sizes\n   925â†’\n   926â†’**Disadvantages**:\n   927â†’- Quantization error\n   928â†’- Less precise rotations\n   929â†’\n   930â†’**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n   931â†’\n   932â†’**Note**: Reduced precision is treated as rounding toward negative infinity.\n   933â†’\n   934â†’---\n   935â†’\n   936â†’## Appendix A: Quick Reference\n   937â†’\n   938â†’### Structure Sizes\n   939â†’\n   940â†’| Structure          | Size (bytes) | Offset Fields                              |\n   941â†’|--------------------|--------------|--------------------------------------------|\n   942â†’| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n   943â†’| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n   944â†’| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n   945â†’\n   946â†’### bKey Values\n   947â†’\n   948â†’| bKey | Uncompressed Bits | Formula         | Range   |\n   949â†’|------|-------------------|-----------------|---------|\n   950â†’| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n   951â†’| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n   952â†’| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n   953â†’\n   954â†’### Conversion Formulas\n   955â†’\n   956â†’**SHORT to Degrees**:\n   957â†’```text\n   958â†’degrees = (SHORT / 4096) * 360\n   959â†’```\n   960â†’\n   961â†’**SHORT to INT (with wrapping)**:\n   962â†’```text\n   963â†’INT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n   964â†’```\n   965â†’\n   966â†’**INT to FLOAT**:\n   967â†’```text\n   968â†’FLOAT = (INT / 4096.0f) * 360.0f\n   969â†’```\n   970â†’\n   971â†’### Position Delta Encoding\n   972â†’\n   973â†’| First Bit | Total Bits | Format     |\n   974â†’|-----------|------------|------------|\n   975â†’| 0         | 8          | 7-bit delta|\n   976â†’| 1         | 17         | 16-bit delta|\n   977â†’\n   978â†’### Rotation Delta Type Field\n   979â†’\n   980â†’| Type | Bits to Read        | Meaning                        |\n   981â†’|------|---------------------|--------------------------------|\n   982â†’| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n   983â†’| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n   984â†’| 7    | `12 - bKey`         | Uncompressed rotation value    |\n   985â†’\n   986â†’---\n   987â†’\n   988â†’## Appendix B: Known Issues\n   989â†’\n   990â†’### Corrupted Animations\n   991â†’\n   992â†’**RSAA Animation 15** (playable frog):\n   993â†’- Missing `sFrames` field\n   994â†’- `sSize` appears at offset 0x00 instead of 0x02\n   995â†’- `bKey` appears at offset 0x02 instead of 0x04\n   996â†’- FF7 cannot load this animation (likely damaged in original game data)\n   997â†’\n   998â†’### Frame Count Discrepancies\n   999â†’\n  1000â†’**sFrames vs. dwFrames**:\n  1001â†’- Rarely match in practice\n  1002â†’- `dwFrames` is more conservative (guarantees minimum)\n  1003â†’- `sFrames` sometimes exceeds actual frame count\n  1004â†’- **Solution**: Parse entire chunk to determine true frame count\n  1005â†’\n  1006â†’**Possible Causes**:\n  1007â†’- Dummy frames padded for memory alignment\n  1008â†’- Special-purpose data interleaved with frames\n  1009â†’- Animation authoring tool artifacts\n  1010â†’\n  1011â†’### Root Rotation Behavior\n  1012â†’\n  1013â†’**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n  1014â†’\n  1015â†’**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n  1016â†’- Model facing toward attack target\n  1017â†’- Model rotating during special moves\n  1018â†’\n  1019â†’**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n  1020â†’\n  1021â†’---\n  1022â†’\n  1023â†’**End of Document**\n  1024â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"1abbb345-6d76-4c38-aa61-91da5303a722","tool_use_result":{"type":"text","file":{"filePath":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md","content":"---\ntitle: \"FF7 Battle Animation Format (PC)\"\nmodule: \"Battle\"\ncreated: \"2025-11-29 16:15 JST\"\nmodified: \"2025-12-01 22:04 JST\"\nsession_id: \"6136e9a8-64f9-4433-adfc-6f7e0338819b\"\nauthor: \"Generated by Claude Code Documentation Standardization Agent\"\nstatus: \"Complete\"\n\n# LLM-specific metadata (CRITICAL for routing)\nllm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\nllm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\nllm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\nllm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n\n# Backlinks (leave empty - populated in pass 2)\nreferenced_by: []\n---\n\n<!--\nSTANDARDIZATION METADATA\nOriginal: FF7_Battle_Battle_Animation_PC.md\nSource: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\nStandardized: 2025-12-01 22:04 JST\nSession-ID: 6136e9a8-64f9-4433-adfc-6f7e0338819b\nAgent: FF7 Documentation Standardization Agent v1.0\n\nPrevious Merge Metadata:\nMERGE METADATA\nCreated: 2025-11-29\nOriginal: FF7_Battle_Battle_Animation_PC.md (912 lines)\nMajor section: 06_BATTLE_MODULE.md\nMerge decision: NO EXTRACTION PERFORMED\nReason: Individual file contains comprehensive battle animation format documentation\nAnalysis: Major section does not contain additional PC animation format details\nStatus: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\nRestructure: Improved organization, fixed typos, enhanced readability\n\nStandardization Changes Applied:\n- Added YAML frontmatter with LLM routing metadata\n- Added HTML comment metadata block preserving original merge metadata\n- Added LLM context block for routing decisions\n- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n- Verified all code blocks have language tags (already present)\n- Verified no wiki-style links present (none to convert)\n- Verified no image references (none present in original)\n- Added related document cross-references in frontmatter\n\nLLM CONTEXT BLOCK (Read this first for routing decisions):\nThis document provides comprehensive reverse-engineering documentation for FF7's PC battle\nanimation binary format, originally documented by L. Spiro. It covers the complete data\npipeline from file parsing through skeletal rotation decoding, including bit-stream reading\nalgorithms, delta compression schemes, and C++ implementations with inline assembly. Key\nconcepts include the bKey precision field controlling rotation bit depth, signed magnitude\nencoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\nis the definitive reference for implementing animation loaders or debugging animation playback.\nCross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n-->\n\n# FF7 Battle Animation Format (PC)\n\n- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n  - [Overview](#overview)\n  - [1. File Structure](#1-file-structure)\n  - [2. Data Structures](#2-data-structures)\n  - [3. Decoding Algorithms](#3-decoding-algorithms)\n  - [4. Implementation Guide](#4-implementation-guide)\n  - [5. Alternative Implementations](#5-alternative-implementations)\n  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n  - [Appendix B: Known Issues](#appendix-b-known-issues)\n\n## Overview\n\nThis document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n\n### What This Document Covers\n\n- Binary file structure for battle animations\n- Data structures for storing skeletal animations\n- Compression algorithms for rotation data\n- Complete C++ implementation with assembly optimizations\n- Theoretical background on the compression scheme\n\n### File Format Basics\n\nBattle animation files contain skeletal animation data for character models. Each file stores:\n- Multiple animations for a single character\n- Per-frame bone rotations and positions\n- Compressed delta encoding for subsequent frames\n- Special animation markers for scripted events\n\n---\n\n## 1. File Structure\n\n### 1.1 Animation File Layout\n\nBattle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n\n**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n\nTo navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n\n### 1.2 File Header Format\n\nEach animation begins with a 12-byte header followed by animation data.\n\n---\n\n## 2. Data Structures\n\n### 2.1 FF7FrameHeader\n\n**Purpose**: Main header for each animation in the file.\n\n**Structure** (12 bytes):\n\n```c\ntypedef struct FF7FrameHeader {\n    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n                                // NOTE: Unreliable - use skeleton file bone count instead.\n    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n} * PFF7FrameHeader;            // Total size: 12 bytes\n```\n\n#### Special Animation Chunks\n\nWhen `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n\n#### Navigation Example\n\nTo skip to animation index `iTarget`:\n\n```c\nFF7FrameHeader  fhHeader;\nDWORD           dwBytesRead;\nfor ( int I = 0; I < iTarget; I++ ) {\n    if ( !ReadFile( hFile,\n        &fhHeader, sizeof( fhHeader ),\n        &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n    }\n    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n        INVALID_SET_FILE_POINTER ) {\n            CloseHandle( hFile );\n            return false;\n        }\n        continue;\n    }\n    // Skip this animation (size = dwChunkSize)\n    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n        CloseHandle( hFile );\n        return false;\n    }\n}\n// Now at the target animation\nif ( !ReadFile( hFile,\n    &fhHeader, sizeof( fhHeader ),\n    &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n}\nBYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n// pbBuffer now holds animation data including FF7FrameMiniHeader\n```\n\n### 2.2 FF7FrameMiniHeader\n\n**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n\n**Structure** (5 bytes):\n\n```c\ntypedef struct FF7FrameMiniHeader {\n    //SHORT     sBones; // Originally thought to be bone count\n    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n```\n\n#### Field Discrepancy Notes\n\n**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n\n**Reliability**: `sFrames` and `dwFrames` rarely match.\n- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n- `sFrames` sometimes exceeds actual frame count\n- **Determine actual frame count by parsing the entire chunk**\n\n**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n- `sSize` appears at offset 0x00\n- `bKey` appears at offset 0x02\n- FF7 cannot handle this animation (likely corrupted)\n\n### 2.3 bKey: The Precision Field\n\n**Purpose**: Controls rotation data bit depth and compression level.\n\n#### Valid Values\n\n| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n|------------|-------------------|-----------|----------------|\n| 0          | 12                | 0-4095    | None           |\n| 2          | 10                | 0-1023    | Low            |\n| 4          | 8                 | 0-255     | Moderate       |\n\n#### How It Works\n\n1. **Storage**: Rotations stored using `(12 - bKey)` bits\n2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n\n**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n\n### 2.4 FF7ShortVec (Rotation Storage)\n\n**Purpose**: Stores one bone's rotation in three numeric forms.\n\n**Structure** (30 bytes):\n\n```c\ntypedef struct FF7ShortVec {\n    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n} * PFF7ShortRot;           // Total size: 30 bytes\n```\n\n#### Three-Form Conversion\n\nRotations are processed through three representations:\n\n1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   - If `SHORT < 0`, add `0x1000` (4096)\n3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n\n#### Per-Frame Processing Sequence\n\n**First Frame**:\n1. Read X bits (determined by `bKey`) and store as signed SHORT\n2. Convert SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Subsequent Frames**:\n1. Read delta value, add to previous frame's SHORT\n2. Convert updated SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n\n### 2.5 FF7FrameBuffer (Frame Management)\n\n**Purpose**: Allocates memory for one frame's worth of bone rotations.\n\n**Structure**:\n\n```cpp\ntypedef struct FF7FrameBuffer {\n    DWORD           dwBones;\n    FF7ShortVec     svPosOffset;\n    FF7ShortVec     *psvRots;\n\n    FF7FrameBuffer() {\n        dwBones = 0;\n        psvRots = NULL;\n    }\n    ~FF7FrameBuffer() {\n        dwBones = 0;\n        delete [] psvRots;\n        psvRots = NULL;\n    }\n\n    VOID    SetBones( DWORD dwTotal ) {\n        // Delete the old\n        dwBones = 0;\n        delete [] psvRots;\n\n        // Create the new\n        psvRots = new FF7ShortVec[dwTotal];\n        if ( psvRots != NULL ) { dwBones = dwTotal; }\n    }\n} * PFF7FrameBuffer;\n```\n\n**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n\n---\n\n## 3. Decoding Algorithms\n\n### 3.1 Bit Stream Reading\n\n#### GetBitsFixed Function\n\n**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n\n**Parameters**:\n- `pbBuffer`: Byte array containing bit stream\n- `dwStartBit`: Bit offset to start reading (modified in place)\n- `dwTotalBits`: Number of bits to read\n\n**Returns**: Signed integer with sign extension.\n\n**Implementation**:\n\n```c\nINT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\nDWORD dwTotalBits ) {\n    INT iReturn = 0;\n\n    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n        iReturn <<= 1;\n\n        __asm mov eax, dwStartBit\n        __asm mov eax, [eax]\n        __asm cdq\n        __asm and edx, 7\n        __asm add eax, edx\n        __asm sar eax, 3\n        __asm mov ecx, pbBuffer\n        __asm xor edx, edx\n        __asm mov dl, byte ptr ds:[ecx+eax]\n        __asm mov eax, dwStartBit\n        __asm mov ecx, [eax]\n        __asm and ecx, 7\n        __asm mov eax, 7\n        __asm sub eax, ecx\n        __asm mov esi, 1\n        __asm mov ecx, eax\n        __asm shl esi, cl\n        __asm and edx, esi\n        __asm test edx, edx\n        __asm je INCBIT\n        iReturn++;\nINCBIT: dwStartBit++;\n    }\n\n    // Force sign bit to extend across 32-bit boundary\n    iReturn <<= (0x20 - dwTotalBits);\n    iReturn >>= (0x20 - dwTotalBits);\n    return iReturn;\n}\n```\n\n### 3.2 First Frame (Uncompressed)\n\nThe first frame stores absolute values with no delta compression.\n\n#### 3.2.1 Position Offsets\n\n**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n\n**Example** (Cloud's first animation, `rtda`):\n- Bytes: `00 00 FE 2E 00 00`\n- Values: `X=0`, `Y=-466`, `Z=0`\n- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n\n**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n\n**Code**:\n\n```c\nPFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\nBYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n\nDWORD dwBitStart = 0;\nSHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n// Result: sX=0, sY=-466, sZ=0\n```\n\n#### 3.2.2 Rotation Data\n\n**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n- If `bKey = 0`: 12 bits per rotation\n- If `bKey = 2`: 10 bits per rotation\n- If `bKey = 4`: 8 bits per rotation\n\n**Normalization**: Shift left by `bKey` to restore 12-bit range.\n\n**Code** (for each bone's 3 rotations):\n\n```c\nSHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\n\n// Normalize to 12-bit range\nsRotX <<= pfmhMiniHeader->bKey;\nsRotY <<= pfmhMiniHeader->bKey;\nsRotZ <<= pfmhMiniHeader->bKey;\n```\n\n### 3.3 Subsequent Frames (Compressed Delta Encoding)\n\nFrames after the first store delta values (changes from previous frame).\n\n#### 3.3.1 Position Deltas\n\n**Format**: Variable-length encoding (8 or 17 bits)\n\n**Algorithm**:\n1. Read 1 flag bit\n   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   - If `1`: Next 16 bits are signed delta (total 17 bits)\n\n**GetDynamicFrameOffsetBits Function**:\n\n```c\nSHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\nDWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n    SHORT sReturn;\n    __asm {\n        mov eax, dwBitStart\n        mov eax, [eax]\n        cdq\n        and edx, 7\n        add eax, edx\n        sar eax, 3\n        mov dwFirstByte, eax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        and edx, 7\n        mov dwConsumedBits, edx\n        mov eax, 7\n        sub eax, dwConsumedBits\n        mov dwBitsRemainingToNextByte, eax\n        mov ecx, pBuffer\n        add ecx, dwFirstByte\n        xor edx, edx\n        mov dl, byte ptr ds:[ecx]\n        shl edx, 8\n        mov eax, pBuffer\n        add eax, dwFirstByte\n        xor ecx, ecx\n        mov cl, byte ptr ds:[eax+1]\n        or edx, ecx\n        mov dwTemp, edx\n        mov ecx, dwBitsRemainingToNextByte\n        add ecx, 8\n        mov edx, 1\n        shl edx, cl\n        mov eax, dwTemp\n        and eax, edx\n        test eax, eax\n        jnz SeventeenBits\n\nEightBits :\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        movsx eax, dx\n        sar eax, 9\n        mov sReturn, ax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        add edx, 8\n        mov eax, dwBitStart\n        mov [eax], edx      // Increase dwBitStart by 8\n        jmp End\n\nSeventeenBits :\n        mov ecx, dwTemp\n        shl ecx, 8\n        mov edx, pBuffer\n        add edx, dwFirstByte\n        xor eax, eax\n        mov al, byte ptr ds:[edx+2]\n        or ecx, eax\n        mov dwTemp, ecx\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        shr edx, 8\n        mov sReturn, dx\n        mov eax, dwBitStart\n        mov ecx, [eax]\n        add ecx, 0x11\n        mov edx, dwBitStart\n        mov [edx], ecx      // Increase dwBitStart by 17\n\nEnd :\n    }\n    return sReturn;\n}\n```\n\n**Usage**:\n\n```c\nSHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n\n// Add deltas to previous frame\nFF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\nFF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\nFF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n```\n\n#### 3.3.2 Rotation Deltas\n\n**Format**: Complex variable-length encoding optimized for small deltas.\n\n**Algorithm Overview**:\n1. Read 1 flag bit:\n   - If `0`: Delta is zero, done\n   - If `1`: Continue to step 2\n2. Read 3-bit type field (values 0-7)\n3. Decode based on type:\n   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n\n**Signed Magnitude Transform** (Types 1-6):\n\nIf the N-bit value is negative:\n- Subtract `(1 << (N - 1))`\n\nIf positive:\n- Add `(1 << (N - 1))`\n\nFinally, shift left by `bKey` to adjust for precision.\n\n**Example** (Type 4, meaning 4 bits):\n- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n\n**GetEncryptedRotationBits Function**:\n\n```c\nSHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\nINT iKeyBits ) {\n    DWORD dwNumBits, dwType;\n    INT iTemp;\n    SHORT sReturn;\n    // Check the first bit\n    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n    __asm mov eax, iBits\n    __asm test eax, eax\n    __asm jnz SecondTest\n    __asm jmp ReturnZero    // Return 0\n\nSecondTest :\n    // Get next 3 bits\n    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n    __asm mov eax, iBits\n    __asm and eax, 7\n    __asm mov dwNumBits, eax\n    __asm mov ecx, dwNumBits\n    __asm mov dwType, ecx\n    __asm cmp dwType, 7\n    __asm ja ReturnZero\n\n    // Switch on type\n    switch ( dwType ) {\n        case 0 : {\n            __asm or eax, 0xFFFFFFFF    // EAX = -1\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl           // (-1 << iKeyBits)\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n        case 1 : {}\n        case 2 : {}\n        case 3 : {}\n        case 4 : {}\n        case 5 : {}\n        case 6 : {\n            // Read N bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                dwNumBits );\n            __asm mov eax, iTemp\n            __asm cmp iTemp, 0\n            __asm jl IfLessThanZero\n            // If >= 0: add (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov eax, 1\n            __asm shl eax, cl\n            __asm mov ecx, iTemp\n            __asm add ecx, eax\n            __asm mov iTemp, ecx\n            __asm jmp AfterTests\nIfLessThanZero :\n            // If < 0: subtract (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov edx, 1\n            __asm shl edx, cl\n            __asm mov eax, iTemp\n            __asm sub eax, edx\n            __asm mov iTemp, eax\n\nAfterTests :\n            // Shift by precision\n            __asm mov eax, iTemp\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n        case 7 : {\n            // Uncompressed: read (12 - iKeyBits) bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                12 - iKeyBits );\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n    }\n\n\nReturnZero :\n    __asm xor ax, ax\n    __asm mov sReturn, ax\n\nEnd :\n\n    return sReturn;\n}\n```\n\n---\n\n## 4. Implementation Guide\n\n### 4.1 LoadFrames Function\n\n**Purpose**: Load an entire frame (position + all bone rotations) at once.\n\n**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n\n**Parameters**:\n- `pfbFrameBuffer`: Pointer to frame buffer to fill\n- `iBones`: Number of bones in skeleton\n- `iBitStart`: Bit offset to start reading (0 for first frame)\n- `pbAnimBuffer`: Byte array containing animation data\n\n**Implementation**:\n\n```c\nDWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\nINT iBones,\nINT iBitStart,\nBYTE * pbAnimBuffer ) {\n    // Get backups of parameters\nDWORD       dwThisBitStart  = iBitStart;\n    INT     iThisBones      = iBones;\n    BYTE *  pbThisBuffer    = pbAnimBuffer;\n\n    PFF7FrameMiniHeader pfmhMiniHeader =\n        (PFF7FrameMiniHeader)pbAnimBuffer;\n    SHORT   sSize = pfmhMiniHeader->sSize;\n    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n\n    // Skip 5-byte miniheader\n    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n\n    if ( iBitStart == 0 ) { // First frame?\n        // Uncompressed position offsets\n        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n\n        // Convert to FLOAT\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Read rotations (12 - bKeyBits) bits each\n            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n\n            // Convert SHORT to INT (absolute value)\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n    else {                  // Subsequent frames\n        SHORT sX, sY, sZ;\n\n        // Get position deltas\n        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n\n        // Add deltas to previous frame\n        pfbFrameBuffer->svPosOffset.sX += sX;\n        pfbFrameBuffer->svPosOffset.sY += sY;\n        pfbFrameBuffer->svPosOffset.sZ += sZ;\n\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Get rotation deltas\n            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n\n            // Add deltas\n            pfbFrameBuffer->psvRots[I].sX += sX;\n            pfbFrameBuffer->psvRots[I].sY += sY;\n            pfbFrameBuffer->psvRots[I].sZ += sZ;\n\n            // Note: Values can exceed 4095 through accumulation of positive deltas\n\n            // Convert to INT\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n\n    // Return next frame's bit offset (or 0 if done)\n    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\nreturn dwThisBitStart;\n}\n    return 0;\n}\n```\n\n### 4.2 Complete Animation Loading Loop\n\n**Example**: Load all frames in an animation.\n\n```c\nFF7FrameHeader fhHeader;\nReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\nNULL );\nBYTE * baData = new BYTE[fhHeader.dwChunkSize];\nReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\nNULL );\n\n    // Allocate frame buffer\nFF7FrameBuffer fbFrameBuffer;\nfbFrameBuffer.SetBones( fhHeader.dwBones );\nINT iBits = 0;\n\nfor ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n    // Load frame\n    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n\n    // Reverse Y offset (required)\n    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n\n    // Convert INT rotations to FLOAT degrees\n    // Note: First rotation (root) is typically 0,0,0 but some animations\n    // store a base rotation for dynamic targeting\n    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n    }\n\n    // Store frame data here (application-specific)\n}\n\ndelete [] baData;\n```\n\n---\n\n## 5. Alternative Implementations\n\n### 5.1 Qhimm's C++ Versions\n\n**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n\n#### GetValueFromStream\n\nReplaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n\n```cpp\nshort GetValueFromStream( BYTE *pStreamBytes,\nDWORD *pdwStreamBitOffset )\n{\n    short sValue;\n    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n\n    // Test first bit to determine value size\n    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n    {   // 16-bit value\n        dwNextStreamBytes = dwNextStreamBytes << 8 |\n            pStreamBytes[dwStreamByteOffset + 2];\n        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n        *pdwStreamBitOffset += 17;\n    }\n    else\n    {   // 7-bit value\n        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n        *pdwStreamBitOffset += 8;\n    }\n\n    return sValue;\n}\n```\n\n#### GetCompressedDeltaFromStream\n\nReplaces `GetEncryptedRotationBits` with clearer C++ implementation.\n\n```cpp\nshort GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\nint nLoweredPrecisionBits )\n{\n    unsigned int nBits;\n    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n    if (iFirstBit)\n    {\n        unsigned int uType = GetBitsFromStream( pStreamBytes,\n            pdwStreamBitOffset, 3 ) & 7;\n        switch (uType)\n        {\n        case 0:\n            // Minimum decrement\n            return (-1 << nLoweredPrecisionBits);\n\n        case 1: case 2: case 3: case 4: case 5: case 6:\n            // Read N bits\n            int iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, nBits );\n            // Apply signed magnitude transform\n            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n            else            iTemp += 1 << (nBits - 1);\n            // Adjust for precision\n            return (iTemp << nLoweredPrecisionBits);\n\n        case 7:\n            // Uncompressed\n            iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n            return (iTemp << nLoweredPrecisionBits);\n        default:\n        }\n    }\n    return 0;\n}\n```\n\n### 5.2 Rotation Compression Theory\n\n*Notes by Qhimm*\n\n#### Why This Encoding Is Efficient\n\nRotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n\n**Bit Allocation**:\n- Zero delta: 1 bit (`0`)\n- Minimum decrement: 4 bits (`1 000`)\n- Small deltas (1-6 bits): 126 possible values\n- Large deltas: Uncompressed form\n\n**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n\n#### Signed Magnitude Encoding\n\nFor delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n\n1. **Magnitude**: Value of most significant value bit\n   - Example: Values `1` and `-2` both have magnitude `1`\n   - Value `30` has magnitude `32`\n\n2. **Signed Magnitude**: Magnitude Ã— sign of value\n   - Example: `-2` has signed magnitude `-1`\n\n3. **Encoding**: Subtract signed magnitude before storing\n   - Pushes values toward zero\n   - Ensures all transformed values fit in 6 bits or fewer\n\n4. **Decoding**: Add back the signed magnitude\n   - Magnitude determined by number of bits read\n   - Sign determined by MSB of encoded value\n\n#### Encoding Examples\n\n| Delta Value | Encoded Bits        | Notes                                    |\n|-------------|---------------------|------------------------------------------|\n| 0           | `0`                 | Single zero bit                          |\n| -1          | `1 000`             | Type 0 (minimum decrement)               |\n| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n\n*(Values shown in current precision as integers)*\n\n#### Precision Trade-offs\n\nPrecision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n\n**Advantages**:\n- Smaller raw values\n- Increased relative span of compressed encodings\n- Much smaller file sizes\n\n**Disadvantages**:\n- Quantization error\n- Less precise rotations\n\n**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n\n**Note**: Reduced precision is treated as rounding toward negative infinity.\n\n---\n\n## Appendix A: Quick Reference\n\n### Structure Sizes\n\n| Structure          | Size (bytes) | Offset Fields                              |\n|--------------------|--------------|--------------------------------------------|\n| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n\n### bKey Values\n\n| bKey | Uncompressed Bits | Formula         | Range   |\n|------|-------------------|-----------------|---------|\n| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n\n### Conversion Formulas\n\n**SHORT to Degrees**:\n```text\ndegrees = (SHORT / 4096) * 360\n```\n\n**SHORT to INT (with wrapping)**:\n```text\nINT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n```\n\n**INT to FLOAT**:\n```text\nFLOAT = (INT / 4096.0f) * 360.0f\n```\n\n### Position Delta Encoding\n\n| First Bit | Total Bits | Format     |\n|-----------|------------|------------|\n| 0         | 8          | 7-bit delta|\n| 1         | 17         | 16-bit delta|\n\n### Rotation Delta Type Field\n\n| Type | Bits to Read        | Meaning                        |\n|------|---------------------|--------------------------------|\n| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n| 7    | `12 - bKey`         | Uncompressed rotation value    |\n\n---\n\n## Appendix B: Known Issues\n\n### Corrupted Animations\n\n**RSAA Animation 15** (playable frog):\n- Missing `sFrames` field\n- `sSize` appears at offset 0x00 instead of 0x02\n- `bKey` appears at offset 0x02 instead of 0x04\n- FF7 cannot load this animation (likely damaged in original game data)\n\n### Frame Count Discrepancies\n\n**sFrames vs. dwFrames**:\n- Rarely match in practice\n- `dwFrames` is more conservative (guarantees minimum)\n- `sFrames` sometimes exceeds actual frame count\n- **Solution**: Parse entire chunk to determine true frame count\n\n**Possible Causes**:\n- Dummy frames padded for memory alignment\n- Special-purpose data interleaved with frames\n- Animation authoring tool artifacts\n\n### Root Rotation Behavior\n\n**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n\n**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n- Model facing toward attack target\n- Model rotating during special moves\n\n**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n\n---\n\n**End of Document**\n","numLines":1024,"startLine":1,"totalLines":1024}}},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011bE8b6YEwyyQ3QN4dosGCM","type":"message","role":"assistant","content":[{"type":"text","text":"`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\nThe existing file has a **critical YAML frontmatter error**: Lines 10-17 use markdown-style comments (`#`) inside YAML, but YAML comments start with `#` followed by a space at the START of a line. The way they're written makes them look like comments but they're actually being parsed as (invalid) YAML keys. This will break any YAML parser.\n\nAdditionally, I need to update the session ID to the current session: `887a1b3f-e34c-44f4-8434-e7e55610b603`\n`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n\nNow I'll create the properly standardized document with correct YAML frontmatter:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15172,"cache_read_input_tokens":83227,"cache_creation":{"ephemeral_5m_input_tokens":15172,"ephemeral_1h_input_tokens":0},"output_tokens":11772,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"e65758c9-7c77-4700-a233-4c824cfb47b2"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011bE8b6YEwyyQ3QN4dosGCM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CmUzdrhve8Ezj29kZ1gaGa","name":"Write","input":{"file_path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md","content":"---\ntitle: \"FF7 Battle Animation Format (PC)\"\nmodule: \"Battle\"\ncreated: \"2025-11-29 16:15 JST\"\nmodified: \"2025-12-01 21:20 JST\"\nsession_id: \"887a1b3f-e34c-44f4-8434-e7e55610b603\"\nauthor: \"Generated by Claude Code Documentation Standardization Agent\"\nstatus: \"Complete\"\n\nllm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\nllm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\nllm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\nllm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n\nreferenced_by: []\n---\n\n<!--\nSTANDARDIZATION METADATA\nOriginal: FF7_Battle_Battle_Animation_PC.md\nSource: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\nStandardized: 2025-12-01 21:20 JST\nSession-ID: 887a1b3f-e34c-44f4-8434-e7e55610b603\nAgent: FF7 Documentation Standardization Agent v1.0\n\nPrevious Merge Metadata:\nMERGE METADATA\nCreated: 2025-11-29\nOriginal: FF7_Battle_Battle_Animation_PC.md (912 lines)\nMajor section: 06_BATTLE_MODULE.md\nMerge decision: NO EXTRACTION PERFORMED\nReason: Individual file contains comprehensive battle animation format documentation\nAnalysis: Major section does not contain additional PC animation format details\nStatus: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\nRestructure: Improved organization, fixed typos, enhanced readability\n\nStandardization Changes Applied:\n- Added YAML frontmatter with LLM routing metadata (proper YAML syntax)\n- Fixed previous YAML frontmatter error (markdown comments inside YAML block)\n- Added HTML comment metadata block preserving original merge metadata\n- Added LLM context block for routing decisions\n- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n- Verified all code blocks have language tags (already present)\n- Verified no wiki-style links present (none to convert)\n- Verified no image references (none present in original)\n- Added related document cross-references in frontmatter\n- Updated session ID to current session\n\nLLM CONTEXT BLOCK (Read this first for routing decisions):\nThis document provides comprehensive reverse-engineering documentation for FF7's PC battle\nanimation binary format, originally documented by L. Spiro. It covers the complete data\npipeline from file parsing through skeletal rotation decoding, including bit-stream reading\nalgorithms, delta compression schemes, and C++ implementations with inline assembly. Key\nconcepts include the bKey precision field controlling rotation bit depth, signed magnitude\nencoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\nis the definitive reference for implementing animation loaders or debugging animation playback.\nCross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n-->\n\n# FF7 Battle Animation Format (PC)\n\n- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n  - [Overview](#overview)\n  - [1. File Structure](#1-file-structure)\n  - [2. Data Structures](#2-data-structures)\n  - [3. Decoding Algorithms](#3-decoding-algorithms)\n  - [4. Implementation Guide](#4-implementation-guide)\n  - [5. Alternative Implementations](#5-alternative-implementations)\n  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n  - [Appendix B: Known Issues](#appendix-b-known-issues)\n\n## Overview\n\nThis document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n\n### What This Document Covers\n\n- Binary file structure for battle animations\n- Data structures for storing skeletal animations\n- Compression algorithms for rotation data\n- Complete C++ implementation with assembly optimizations\n- Theoretical background on the compression scheme\n\n### File Format Basics\n\nBattle animation files contain skeletal animation data for character models. Each file stores:\n- Multiple animations for a single character\n- Per-frame bone rotations and positions\n- Compressed delta encoding for subsequent frames\n- Special animation markers for scripted events\n\n---\n\n## 1. File Structure\n\n### 1.1 Animation File Layout\n\nBattle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n\n**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n\nTo navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n\n### 1.2 File Header Format\n\nEach animation begins with a 12-byte header followed by animation data.\n\n---\n\n## 2. Data Structures\n\n### 2.1 FF7FrameHeader\n\n**Purpose**: Main header for each animation in the file.\n\n**Structure** (12 bytes):\n\n```c\ntypedef struct FF7FrameHeader {\n    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n                                // NOTE: Unreliable - use skeleton file bone count instead.\n    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n} * PFF7FrameHeader;            // Total size: 12 bytes\n```\n\n#### Special Animation Chunks\n\nWhen `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n\n#### Navigation Example\n\nTo skip to animation index `iTarget`:\n\n```c\nFF7FrameHeader  fhHeader;\nDWORD           dwBytesRead;\nfor ( int I = 0; I < iTarget; I++ ) {\n    if ( !ReadFile( hFile,\n        &fhHeader, sizeof( fhHeader ),\n        &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n    }\n    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n        INVALID_SET_FILE_POINTER ) {\n            CloseHandle( hFile );\n            return false;\n        }\n        continue;\n    }\n    // Skip this animation (size = dwChunkSize)\n    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n        CloseHandle( hFile );\n        return false;\n    }\n}\n// Now at the target animation\nif ( !ReadFile( hFile,\n    &fhHeader, sizeof( fhHeader ),\n    &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n}\nBYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n// pbBuffer now holds animation data including FF7FrameMiniHeader\n```\n\n### 2.2 FF7FrameMiniHeader\n\n**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n\n**Structure** (5 bytes):\n\n```c\ntypedef struct FF7FrameMiniHeader {\n    //SHORT     sBones; // Originally thought to be bone count\n    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n```\n\n#### Field Discrepancy Notes\n\n**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n\n**Reliability**: `sFrames` and `dwFrames` rarely match.\n- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n- `sFrames` sometimes exceeds actual frame count\n- **Determine actual frame count by parsing the entire chunk**\n\n**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n- `sSize` appears at offset 0x00\n- `bKey` appears at offset 0x02\n- FF7 cannot handle this animation (likely corrupted)\n\n### 2.3 bKey: The Precision Field\n\n**Purpose**: Controls rotation data bit depth and compression level.\n\n#### Valid Values\n\n| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n|------------|-------------------|-----------|----------------|\n| 0          | 12                | 0-4095    | None           |\n| 2          | 10                | 0-1023    | Low            |\n| 4          | 8                 | 0-255     | Moderate       |\n\n#### How It Works\n\n1. **Storage**: Rotations stored using `(12 - bKey)` bits\n2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n\n**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n\n### 2.4 FF7ShortVec (Rotation Storage)\n\n**Purpose**: Stores one bone's rotation in three numeric forms.\n\n**Structure** (30 bytes):\n\n```c\ntypedef struct FF7ShortVec {\n    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n} * PFF7ShortRot;           // Total size: 30 bytes\n```\n\n#### Three-Form Conversion\n\nRotations are processed through three representations:\n\n1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   - If `SHORT < 0`, add `0x1000` (4096)\n3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n\n#### Per-Frame Processing Sequence\n\n**First Frame**:\n1. Read X bits (determined by `bKey`) and store as signed SHORT\n2. Convert SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Subsequent Frames**:\n1. Read delta value, add to previous frame's SHORT\n2. Convert updated SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n\n### 2.5 FF7FrameBuffer (Frame Management)\n\n**Purpose**: Allocates memory for one frame's worth of bone rotations.\n\n**Structure**:\n\n```cpp\ntypedef struct FF7FrameBuffer {\n    DWORD           dwBones;\n    FF7ShortVec     svPosOffset;\n    FF7ShortVec     *psvRots;\n\n    FF7FrameBuffer() {\n        dwBones = 0;\n        psvRots = NULL;\n    }\n    ~FF7FrameBuffer() {\n        dwBones = 0;\n        delete [] psvRots;\n        psvRots = NULL;\n    }\n\n    VOID    SetBones( DWORD dwTotal ) {\n        // Delete the old\n        dwBones = 0;\n        delete [] psvRots;\n\n        // Create the new\n        psvRots = new FF7ShortVec[dwTotal];\n        if ( psvRots != NULL ) { dwBones = dwTotal; }\n    }\n} * PFF7FrameBuffer;\n```\n\n**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n\n---\n\n## 3. Decoding Algorithms\n\n### 3.1 Bit Stream Reading\n\n#### GetBitsFixed Function\n\n**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n\n**Parameters**:\n- `pbBuffer`: Byte array containing bit stream\n- `dwStartBit`: Bit offset to start reading (modified in place)\n- `dwTotalBits`: Number of bits to read\n\n**Returns**: Signed integer with sign extension.\n\n**Implementation**:\n\n```c\nINT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\nDWORD dwTotalBits ) {\n    INT iReturn = 0;\n\n    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n        iReturn <<= 1;\n\n        __asm mov eax, dwStartBit\n        __asm mov eax, [eax]\n        __asm cdq\n        __asm and edx, 7\n        __asm add eax, edx\n        __asm sar eax, 3\n        __asm mov ecx, pbBuffer\n        __asm xor edx, edx\n        __asm mov dl, byte ptr ds:[ecx+eax]\n        __asm mov eax, dwStartBit\n        __asm mov ecx, [eax]\n        __asm and ecx, 7\n        __asm mov eax, 7\n        __asm sub eax, ecx\n        __asm mov esi, 1\n        __asm mov ecx, eax\n        __asm shl esi, cl\n        __asm and edx, esi\n        __asm test edx, edx\n        __asm je INCBIT\n        iReturn++;\nINCBIT: dwStartBit++;\n    }\n\n    // Force sign bit to extend across 32-bit boundary\n    iReturn <<= (0x20 - dwTotalBits);\n    iReturn >>= (0x20 - dwTotalBits);\n    return iReturn;\n}\n```\n\n### 3.2 First Frame (Uncompressed)\n\nThe first frame stores absolute values with no delta compression.\n\n#### 3.2.1 Position Offsets\n\n**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n\n**Example** (Cloud's first animation, `rtda`):\n- Bytes: `00 00 FE 2E 00 00`\n- Values: `X=0`, `Y=-466`, `Z=0`\n- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n\n**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n\n**Code**:\n\n```c\nPFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\nBYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n\nDWORD dwBitStart = 0;\nSHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n// Result: sX=0, sY=-466, sZ=0\n```\n\n#### 3.2.2 Rotation Data\n\n**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n- If `bKey = 0`: 12 bits per rotation\n- If `bKey = 2`: 10 bits per rotation\n- If `bKey = 4`: 8 bits per rotation\n\n**Normalization**: Shift left by `bKey` to restore 12-bit range.\n\n**Code** (for each bone's 3 rotations):\n\n```c\nSHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\n\n// Normalize to 12-bit range\nsRotX <<= pfmhMiniHeader->bKey;\nsRotY <<= pfmhMiniHeader->bKey;\nsRotZ <<= pfmhMiniHeader->bKey;\n```\n\n### 3.3 Subsequent Frames (Compressed Delta Encoding)\n\nFrames after the first store delta values (changes from previous frame).\n\n#### 3.3.1 Position Deltas\n\n**Format**: Variable-length encoding (8 or 17 bits)\n\n**Algorithm**:\n1. Read 1 flag bit\n   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   - If `1`: Next 16 bits are signed delta (total 17 bits)\n\n**GetDynamicFrameOffsetBits Function**:\n\n```c\nSHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\nDWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n    SHORT sReturn;\n    __asm {\n        mov eax, dwBitStart\n        mov eax, [eax]\n        cdq\n        and edx, 7\n        add eax, edx\n        sar eax, 3\n        mov dwFirstByte, eax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        and edx, 7\n        mov dwConsumedBits, edx\n        mov eax, 7\n        sub eax, dwConsumedBits\n        mov dwBitsRemainingToNextByte, eax\n        mov ecx, pBuffer\n        add ecx, dwFirstByte\n        xor edx, edx\n        mov dl, byte ptr ds:[ecx]\n        shl edx, 8\n        mov eax, pBuffer\n        add eax, dwFirstByte\n        xor ecx, ecx\n        mov cl, byte ptr ds:[eax+1]\n        or edx, ecx\n        mov dwTemp, edx\n        mov ecx, dwBitsRemainingToNextByte\n        add ecx, 8\n        mov edx, 1\n        shl edx, cl\n        mov eax, dwTemp\n        and eax, edx\n        test eax, eax\n        jnz SeventeenBits\n\nEightBits :\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        movsx eax, dx\n        sar eax, 9\n        mov sReturn, ax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        add edx, 8\n        mov eax, dwBitStart\n        mov [eax], edx      // Increase dwBitStart by 8\n        jmp End\n\nSeventeenBits :\n        mov ecx, dwTemp\n        shl ecx, 8\n        mov edx, pBuffer\n        add edx, dwFirstByte\n        xor eax, eax\n        mov al, byte ptr ds:[edx+2]\n        or ecx, eax\n        mov dwTemp, ecx\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        shr edx, 8\n        mov sReturn, dx\n        mov eax, dwBitStart\n        mov ecx, [eax]\n        add ecx, 0x11\n        mov edx, dwBitStart\n        mov [edx], ecx      // Increase dwBitStart by 17\n\nEnd :\n    }\n    return sReturn;\n}\n```\n\n**Usage**:\n\n```c\nSHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n\n// Add deltas to previous frame\nFF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\nFF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\nFF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n```\n\n#### 3.3.2 Rotation Deltas\n\n**Format**: Complex variable-length encoding optimized for small deltas.\n\n**Algorithm Overview**:\n1. Read 1 flag bit:\n   - If `0`: Delta is zero, done\n   - If `1`: Continue to step 2\n2. Read 3-bit type field (values 0-7)\n3. Decode based on type:\n   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n\n**Signed Magnitude Transform** (Types 1-6):\n\nIf the N-bit value is negative:\n- Subtract `(1 << (N - 1))`\n\nIf positive:\n- Add `(1 << (N - 1))`\n\nFinally, shift left by `bKey` to adjust for precision.\n\n**Example** (Type 4, meaning 4 bits):\n- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n\n**GetEncryptedRotationBits Function**:\n\n```c\nSHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\nINT iKeyBits ) {\n    DWORD dwNumBits, dwType;\n    INT iTemp;\n    SHORT sReturn;\n    // Check the first bit\n    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n    __asm mov eax, iBits\n    __asm test eax, eax\n    __asm jnz SecondTest\n    __asm jmp ReturnZero    // Return 0\n\nSecondTest :\n    // Get next 3 bits\n    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n    __asm mov eax, iBits\n    __asm and eax, 7\n    __asm mov dwNumBits, eax\n    __asm mov ecx, dwNumBits\n    __asm mov dwType, ecx\n    __asm cmp dwType, 7\n    __asm ja ReturnZero\n\n    // Switch on type\n    switch ( dwType ) {\n        case 0 : {\n            __asm or eax, 0xFFFFFFFF    // EAX = -1\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl           // (-1 << iKeyBits)\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n        case 1 : {}\n        case 2 : {}\n        case 3 : {}\n        case 4 : {}\n        case 5 : {}\n        case 6 : {\n            // Read N bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                dwNumBits );\n            __asm mov eax, iTemp\n            __asm cmp iTemp, 0\n            __asm jl IfLessThanZero\n            // If >= 0: add (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov eax, 1\n            __asm shl eax, cl\n            __asm mov ecx, iTemp\n            __asm add ecx, eax\n            __asm mov iTemp, ecx\n            __asm jmp AfterTests\nIfLessThanZero :\n            // If < 0: subtract (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov edx, 1\n            __asm shl edx, cl\n            __asm mov eax, iTemp\n            __asm sub eax, edx\n            __asm mov iTemp, eax\n\nAfterTests :\n            // Shift by precision\n            __asm mov eax, iTemp\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n        case 7 : {\n            // Uncompressed: read (12 - iKeyBits) bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                12 - iKeyBits );\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n    }\n\n\nReturnZero :\n    __asm xor ax, ax\n    __asm mov sReturn, ax\n\nEnd :\n\n    return sReturn;\n}\n```\n\n---\n\n## 4. Implementation Guide\n\n### 4.1 LoadFrames Function\n\n**Purpose**: Load an entire frame (position + all bone rotations) at once.\n\n**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n\n**Parameters**:\n- `pfbFrameBuffer`: Pointer to frame buffer to fill\n- `iBones`: Number of bones in skeleton\n- `iBitStart`: Bit offset to start reading (0 for first frame)\n- `pbAnimBuffer`: Byte array containing animation data\n\n**Implementation**:\n\n```c\nDWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\nINT iBones,\nINT iBitStart,\nBYTE * pbAnimBuffer ) {\n    // Get backups of parameters\nDWORD       dwThisBitStart  = iBitStart;\n    INT     iThisBones      = iBones;\n    BYTE *  pbThisBuffer    = pbAnimBuffer;\n\n    PFF7FrameMiniHeader pfmhMiniHeader =\n        (PFF7FrameMiniHeader)pbAnimBuffer;\n    SHORT   sSize = pfmhMiniHeader->sSize;\n    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n\n    // Skip 5-byte miniheader\n    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n\n    if ( iBitStart == 0 ) { // First frame?\n        // Uncompressed position offsets\n        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n\n        // Convert to FLOAT\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Read rotations (12 - bKeyBits) bits each\n            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n\n            // Convert SHORT to INT (absolute value)\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n    else {                  // Subsequent frames\n        SHORT sX, sY, sZ;\n\n        // Get position deltas\n        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n\n        // Add deltas to previous frame\n        pfbFrameBuffer->svPosOffset.sX += sX;\n        pfbFrameBuffer->svPosOffset.sY += sY;\n        pfbFrameBuffer->svPosOffset.sZ += sZ;\n\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Get rotation deltas\n            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n\n            // Add deltas\n            pfbFrameBuffer->psvRots[I].sX += sX;\n            pfbFrameBuffer->psvRots[I].sY += sY;\n            pfbFrameBuffer->psvRots[I].sZ += sZ;\n\n            // Note: Values can exceed 4095 through accumulation of positive deltas\n\n            // Convert to INT\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n\n    // Return next frame's bit offset (or 0 if done)\n    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\nreturn dwThisBitStart;\n}\n    return 0;\n}\n```\n\n### 4.2 Complete Animation Loading Loop\n\n**Example**: Load all frames in an animation.\n\n```c\nFF7FrameHeader fhHeader;\nReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\nNULL );\nBYTE * baData = new BYTE[fhHeader.dwChunkSize];\nReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\nNULL );\n\n    // Allocate frame buffer\nFF7FrameBuffer fbFrameBuffer;\nfbFrameBuffer.SetBones( fhHeader.dwBones );\nINT iBits = 0;\n\nfor ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n    // Load frame\n    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n\n    // Reverse Y offset (required)\n    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n\n    // Convert INT rotations to FLOAT degrees\n    // Note: First rotation (root) is typically 0,0,0 but some animations\n    // store a base rotation for dynamic targeting\n    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n    }\n\n    // Store frame data here (application-specific)\n}\n\ndelete [] baData;\n```\n\n---\n\n## 5. Alternative Implementations\n\n### 5.1 Qhimm's C++ Versions\n\n**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n\n#### GetValueFromStream\n\nReplaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n\n```cpp\nshort GetValueFromStream( BYTE *pStreamBytes,\nDWORD *pdwStreamBitOffset )\n{\n    short sValue;\n    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n\n    // Test first bit to determine value size\n    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n    {   // 16-bit value\n        dwNextStreamBytes = dwNextStreamBytes << 8 |\n            pStreamBytes[dwStreamByteOffset + 2];\n        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n        *pdwStreamBitOffset += 17;\n    }\n    else\n    {   // 7-bit value\n        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n        *pdwStreamBitOffset += 8;\n    }\n\n    return sValue;\n}\n```\n\n#### GetCompressedDeltaFromStream\n\nReplaces `GetEncryptedRotationBits` with clearer C++ implementation.\n\n```cpp\nshort GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\nint nLoweredPrecisionBits )\n{\n    unsigned int nBits;\n    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n    if (iFirstBit)\n    {\n        unsigned int uType = GetBitsFromStream( pStreamBytes,\n            pdwStreamBitOffset, 3 ) & 7;\n        switch (uType)\n        {\n        case 0:\n            // Minimum decrement\n            return (-1 << nLoweredPrecisionBits);\n\n        case 1: case 2: case 3: case 4: case 5: case 6:\n            // Read N bits\n            int iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, nBits );\n            // Apply signed magnitude transform\n            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n            else            iTemp += 1 << (nBits - 1);\n            // Adjust for precision\n            return (iTemp << nLoweredPrecisionBits);\n\n        case 7:\n            // Uncompressed\n            iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n            return (iTemp << nLoweredPrecisionBits);\n        default:\n        }\n    }\n    return 0;\n}\n```\n\n### 5.2 Rotation Compression Theory\n\n*Notes by Qhimm*\n\n#### Why This Encoding Is Efficient\n\nRotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n\n**Bit Allocation**:\n- Zero delta: 1 bit (`0`)\n- Minimum decrement: 4 bits (`1 000`)\n- Small deltas (1-6 bits): 126 possible values\n- Large deltas: Uncompressed form\n\n**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n\n#### Signed Magnitude Encoding\n\nFor delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n\n1. **Magnitude**: Value of most significant value bit\n   - Example: Values `1` and `-2` both have magnitude `1`\n   - Value `30` has magnitude `32`\n\n2. **Signed Magnitude**: Magnitude Ã— sign of value\n   - Example: `-2` has signed magnitude `-1`\n\n3. **Encoding**: Subtract signed magnitude before storing\n   - Pushes values toward zero\n   - Ensures all transformed values fit in 6 bits or fewer\n\n4. **Decoding**: Add back the signed magnitude\n   - Magnitude determined by number of bits read\n   - Sign determined by MSB of encoded value\n\n#### Encoding Examples\n\n| Delta Value | Encoded Bits        | Notes                                    |\n|-------------|---------------------|------------------------------------------|\n| 0           | `0`                 | Single zero bit                          |\n| -1          | `1 000`             | Type 0 (minimum decrement)               |\n| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n\n*(Values shown in current precision as integers)*\n\n#### Precision Trade-offs\n\nPrecision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n\n**Advantages**:\n- Smaller raw values\n- Increased relative span of compressed encodings\n- Much smaller file sizes\n\n**Disadvantages**:\n- Quantization error\n- Less precise rotations\n\n**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n\n**Note**: Reduced precision is treated as rounding toward negative infinity.\n\n---\n\n## Appendix A: Quick Reference\n\n### Structure Sizes\n\n| Structure          | Size (bytes) | Offset Fields                              |\n|--------------------|--------------|--------------------------------------------|\n| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n\n### bKey Values\n\n| bKey | Uncompressed Bits | Formula         | Range   |\n|------|-------------------|-----------------|---------|\n| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n\n### Conversion Formulas\n\n**SHORT to Degrees**:\n```text\ndegrees = (SHORT / 4096) * 360\n```\n\n**SHORT to INT (with wrapping)**:\n```text\nINT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n```\n\n**INT to FLOAT**:\n```text\nFLOAT = (INT / 4096.0f) * 360.0f\n```\n\n### Position Delta Encoding\n\n| First Bit | Total Bits | Format     |\n|-----------|------------|------------|\n| 0         | 8          | 7-bit delta|\n| 1         | 17         | 16-bit delta|\n\n### Rotation Delta Type Field\n\n| Type | Bits to Read        | Meaning                        |\n|------|---------------------|--------------------------------|\n| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n| 7    | `12 - bKey`         | Uncompressed rotation value    |\n\n---\n\n## Appendix B: Known Issues\n\n### Corrupted Animations\n\n**RSAA Animation 15** (playable frog):\n- Missing `sFrames` field\n- `sSize` appears at offset 0x00 instead of 0x02\n- `bKey` appears at offset 0x02 instead of 0x04\n- FF7 cannot load this animation (likely damaged in original game data)\n\n### Frame Count Discrepancies\n\n**sFrames vs. dwFrames**:\n- Rarely match in practice\n- `dwFrames` is more conservative (guarantees minimum)\n- `sFrames` sometimes exceeds actual frame count\n- **Solution**: Parse entire chunk to determine true frame count\n\n**Possible Causes**:\n- Dummy frames padded for memory alignment\n- Special-purpose data interleaved with frames\n- Animation authoring tool artifacts\n\n### Root Rotation Behavior\n\n**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n\n**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n- Model facing toward attack target\n- Model rotating during special moves\n\n**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n\n---\n\n**End of Document**\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15172,"cache_read_input_tokens":83227,"cache_creation":{"ephemeral_5m_input_tokens":15172,"ephemeral_1h_input_tokens":0},"output_tokens":11772,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"c3dda02b-76b8-4ae9-8173-c231b88f1fe8"},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CmUzdrhve8Ezj29kZ1gaGa","type":"tool_result","content":"The file /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1â†’---\n     2â†’title: \"FF7 Battle Animation Format (PC)\"\n     3â†’module: \"Battle\"\n     4â†’created: \"2025-11-29 16:15 JST\"\n     5â†’modified: \"2025-12-01 21:20 JST\"\n     6â†’session_id: \"887a1b3f-e34c-44f4-8434-e7e55610b603\"\n     7â†’author: \"Generated by Claude Code Documentation Standardization Agent\"\n     8â†’status: \"Complete\"\n     9â†’\n    10â†’llm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\n    11â†’llm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\n    12â†’llm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\n    13â†’llm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n    14â†’\n    15â†’referenced_by: []\n    16â†’---\n    17â†’\n    18â†’<!--\n    19â†’STANDARDIZATION METADATA\n    20â†’Original: FF7_Battle_Battle_Animation_PC.md\n    21â†’Source: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\n    22â†’Standardized: 2025-12-01 21:20 JST\n    23â†’Session-ID: 887a1b3f-e34c-44f4-8434-e7e55610b603\n    24â†’Agent: FF7 Documentation Standardization Agent v1.0\n    25â†’\n    26â†’Previous Merge Metadata:\n    27â†’MERGE METADATA\n    28â†’Created: 2025-11-29\n    29â†’Original: FF7_Battle_Battle_Animation_PC.md (912 lines)\n    30â†’Major section: 06_BATTLE_MODULE.md\n    31â†’Merge decision: NO EXTRACTION PERFORMED\n    32â†’Reason: Individual file contains comprehensive battle animation format documentation\n    33â†’Analysis: Major section does not contain additional PC animation format details\n    34â†’Status: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\n    35â†’Restructure: Improved organization, fixed typos, enhanced readability\n    36â†’\n    37â†’Standardization Changes Applied:\n    38â†’- Added YAML frontmatter with LLM routing metadata (proper YAML syntax)\n    39â†’- Fixed previous YAML frontmatter error (markdown comments inside YAML block)\n    40â†’- Added HTML comment metadata block preserving original merge metadata\n    41â†’- Added LLM context block for routing decisions\n    42â†’- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n    43â†’- Verified all code blocks have language tags (already present)\n    44â†’- Verified no wiki-style links present (none to convert)\n    45â†’- Verified no image references (none present in original)\n    46â†’- Added related document cross-references in frontmatter\n    47â†’- Updated session ID to current session\n    48â†’\n    49â†’LLM CONTEXT BLOCK (Read this first for routing decisions):\n    50â†’This document provides comprehensive reverse-engineering documentation for FF7's PC battle\n    51â†’animation binary format, originally documented by L. Spiro. It covers the complete data\n    52â†’pipeline from file parsing through skeletal rotation decoding, including bit-stream reading\n    53â†’algorithms, delta compression schemes, and C++ implementations with inline assembly. Key\n    54â†’concepts include the bKey precision field controlling rotation bit depth, signed magnitude\n    55â†’encoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\n    56â†’is the definitive reference for implementing animation loaders or debugging animation playback.\n    57â†’Cross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n    58â†’-->\n    59â†’\n    60â†’# FF7 Battle Animation Format (PC)\n    61â†’\n    62â†’- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n    63â†’  - [Overview](#overview)\n    64â†’  - [1. File Structure](#1-file-structure)\n    65â†’  - [2. Data Structures](#2-data-structures)\n    66â†’  - [3. Decoding Algorithms](#3-decoding-algorithms)\n    67â†’  - [4. Implementation Guide](#4-implementation-guide)\n    68â†’  - [5. Alternative Implementations](#5-alternative-implementations)\n    69â†’  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n    70â†’  - [Appendix B: Known Issues](#appendix-b-known-issues)\n    71â†’\n    72â†’## Overview\n    73â†’\n    74â†’This document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n    75â†’\n    76â†’### What This Document Covers\n    77â†’\n    78â†’- Binary file structure for battle animations\n    79â†’- Data structures for storing skeletal animations\n    80â†’- Compression algorithms for rotation data\n    81â†’- Complete C++ implementation with assembly optimizations\n    82â†’- Theoretical background on the compression scheme\n    83â†’\n    84â†’### File Format Basics\n    85â†’\n    86â†’Battle animation files contain skeletal animation data for character models. Each file stores:\n    87â†’- Multiple animations for a single character\n    88â†’- Per-frame bone rotations and positions\n    89â†’- Compressed delta encoding for subsequent frames\n    90â†’- Special animation markers for scripted events\n    91â†’\n    92â†’---\n    93â†’\n    94â†’## 1. File Structure\n    95â†’\n    96â†’### 1.1 Animation File Layout\n    97â†’\n    98â†’Battle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n    99â†’\n   100â†’**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n   101â†’\n   102â†’To navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n   103â†’\n   104â†’### 1.2 File Header Format\n   105â†’\n   106â†’Each animation begins with a 12-byte header followed by animation data.\n   107â†’\n   108â†’---\n   109â†’\n   110â†’## 2. Data Structures\n   111â†’\n   112â†’### 2.1 FF7FrameHeader\n   113â†’\n   114â†’**Purpose**: Main header for each animation in the file.\n   115â†’\n   116â†’**Structure** (12 bytes):\n   117â†’\n   118â†’```c\n   119â†’typedef struct FF7FrameHeader {\n   120â†’    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n   121â†’                                // NOTE: Unreliable - use skeleton file bone count instead.\n   122â†’    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n   123â†’    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n   124â†’} * PFF7FrameHeader;            // Total size: 12 bytes\n   125â†’```\n   126â†’\n   127â†’#### Special Animation Chunks\n   128â†’\n   129â†’When `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n   130â†’\n   131â†’#### Navigation Example\n   132â†’\n   133â†’To skip to animation index `iTarget`:\n   134â†’\n   135â†’```c\n   136â†’FF7FrameHeader  fhHeader;\n   137â†’DWORD           dwBytesRead;\n   138â†’for ( int I = 0; I < iTarget; I++ ) {\n   139â†’    if ( !ReadFile( hFile,\n   140â†’        &fhHeader, sizeof( fhHeader ),\n   141â†’        &dwBytesRead, NULL ) ) {\n   142â†’\n   143â†’    CloseHandle( hFile );\n   144â†’    return false;\n   145â†’    }\n   146â†’    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n   147â†’        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n   148â†’        INVALID_SET_FILE_POINTER ) {\n   149â†’            CloseHandle( hFile );\n   150â†’            return false;\n   151â†’        }\n   152â†’        continue;\n   153â†’    }\n   154â†’    // Skip this animation (size = dwChunkSize)\n   155â†’    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n   156â†’    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n   157â†’        CloseHandle( hFile );\n   158â†’        return false;\n   159â†’    }\n   160â†’}\n   161â†’// Now at the target animation\n   162â†’if ( !ReadFile( hFile,\n   163â†’    &fhHeader, sizeof( fhHeader ),\n   164â†’    &dwBytesRead, NULL ) ) {\n   165â†’\n   166â†’    CloseHandle( hFile );\n   167â†’    return false;\n   168â†’}\n   169â†’BYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n   170â†’// pbBuffer now holds animation data including FF7FrameMiniHeader\n   171â†’```\n   172â†’\n   173â†’### 2.2 FF7FrameMiniHeader\n   174â†’\n   175â†’**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n   176â†’\n   177â†’**Structure** (5 bytes):\n   178â†’\n   179â†’```c\n   180â†’typedef struct FF7FrameMiniHeader {\n   181â†’    //SHORT     sBones; // Originally thought to be bone count\n   182â†’    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n   183â†’    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n   184â†’    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n   185â†’} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n   186â†’```\n   187â†’\n   188â†’#### Field Discrepancy Notes\n   189â†’\n   190â†’**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n   191â†’\n   192â†’**Reliability**: `sFrames` and `dwFrames` rarely match.\n   193â†’- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n   194â†’- `sFrames` sometimes exceeds actual frame count\n   195â†’- **Determine actual frame count by parsing the entire chunk**\n   196â†’\n   197â†’**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n   198â†’- `sSize` appears at offset 0x00\n   199â†’- `bKey` appears at offset 0x02\n   200â†’- FF7 cannot handle this animation (likely corrupted)\n   201â†’\n   202â†’### 2.3 bKey: The Precision Field\n   203â†’\n   204â†’**Purpose**: Controls rotation data bit depth and compression level.\n   205â†’\n   206â†’#### Valid Values\n   207â†’\n   208â†’| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n   209â†’|------------|-------------------|-----------|----------------|\n   210â†’| 0          | 12                | 0-4095    | None           |\n   211â†’| 2          | 10                | 0-1023    | Low            |\n   212â†’| 4          | 8                 | 0-255     | Moderate       |\n   213â†’\n   214â†’#### How It Works\n   215â†’\n   216â†’1. **Storage**: Rotations stored using `(12 - bKey)` bits\n   217â†’2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   218â†’   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n   219â†’3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n   220â†’\n   221â†’**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n   222â†’\n   223â†’### 2.4 FF7ShortVec (Rotation Storage)\n   224â†’\n   225â†’**Purpose**: Stores one bone's rotation in three numeric forms.\n   226â†’\n   227â†’**Structure** (30 bytes):\n   228â†’\n   229â†’```c\n   230â†’typedef struct FF7ShortVec {\n   231â†’    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n   232â†’    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n   233â†’    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n   234â†’} * PFF7ShortRot;           // Total size: 30 bytes\n   235â†’```\n   236â†’\n   237â†’#### Three-Form Conversion\n   238â†’\n   239â†’Rotations are processed through three representations:\n   240â†’\n   241â†’1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n   242â†’2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   243â†’   - If `SHORT < 0`, add `0x1000` (4096)\n   244â†’3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n   245â†’\n   246â†’#### Per-Frame Processing Sequence\n   247â†’\n   248â†’**First Frame**:\n   249â†’1. Read X bits (determined by `bKey`) and store as signed SHORT\n   250â†’2. Convert SHORT to INT (add 0x1000 if negative)\n   251â†’3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n   252â†’4. Apply FLOAT rotation to model\n   253â†’\n   254â†’**Subsequent Frames**:\n   255â†’1. Read delta value, add to previous frame's SHORT\n   256â†’2. Convert updated SHORT to INT (add 0x1000 if negative)\n   257â†’3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n   258â†’4. Apply FLOAT rotation to model\n   259â†’\n   260â†’**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n   261â†’\n   262â†’### 2.5 FF7FrameBuffer (Frame Management)\n   263â†’\n   264â†’**Purpose**: Allocates memory for one frame's worth of bone rotations.\n   265â†’\n   266â†’**Structure**:\n   267â†’\n   268â†’```cpp\n   269â†’typedef struct FF7FrameBuffer {\n   270â†’    DWORD           dwBones;\n   271â†’    FF7ShortVec     svPosOffset;\n   272â†’    FF7ShortVec     *psvRots;\n   273â†’\n   274â†’    FF7FrameBuffer() {\n   275â†’        dwBones = 0;\n   276â†’        psvRots = NULL;\n   277â†’    }\n   278â†’    ~FF7FrameBuffer() {\n   279â†’        dwBones = 0;\n   280â†’        delete [] psvRots;\n   281â†’        psvRots = NULL;\n   282â†’    }\n   283â†’\n   284â†’    VOID    SetBones( DWORD dwTotal ) {\n   285â†’        // Delete the old\n   286â†’        dwBones = 0;\n   287â†’        delete [] psvRots;\n   288â†’\n   289â†’        // Create the new\n   290â†’        psvRots = new FF7ShortVec[dwTotal];\n   291â†’        if ( psvRots != NULL ) { dwBones = dwTotal; }\n   292â†’    }\n   293â†’} * PFF7FrameBuffer;\n   294â†’```\n   295â†’\n   296â†’**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n   297â†’\n   298â†’---\n   299â†’\n   300â†’## 3. Decoding Algorithms\n   301â†’\n   302â†’### 3.1 Bit Stream Reading\n   303â†’\n   304â†’#### GetBitsFixed Function\n   305â†’\n   306â†’**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n   307â†’\n   308â†’**Parameters**:\n   309â†’- `pbBuffer`: Byte array containing bit stream\n   310â†’- `dwStartBit`: Bit offset to start reading (modified in place)\n   311â†’- `dwTotalBits`: Number of bits to read\n   312â†’\n   313â†’**Returns**: Signed integer with sign extension.\n   314â†’\n   315â†’**Implementation**:\n   316â†’\n   317â†’```c\n   318â†’INT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\n   319â†’DWORD dwTotalBits ) {\n   320â†’    INT iReturn = 0;\n   321â†’\n   322â†’    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n   323â†’        iReturn <<= 1;\n   324â†’\n   325â†’        __asm mov eax, dwStartBit\n   326â†’        __asm mov eax, [eax]\n   327â†’        __asm cdq\n   328â†’        __asm and edx, 7\n   329â†’        __asm add eax, edx\n   330â†’        __asm sar eax, 3\n   331â†’        __asm mov ecx, pbBuffer\n   332â†’        __asm xor edx, edx\n   333â†’        __asm mov dl, byte ptr ds:[ecx+eax]\n   334â†’        __asm mov eax, dwStartBit\n   335â†’        __asm mov ecx, [eax]\n   336â†’        __asm and ecx, 7\n   337â†’        __asm mov eax, 7\n   338â†’        __asm sub eax, ecx\n   339â†’        __asm mov esi, 1\n   340â†’        __asm mov ecx, eax\n   341â†’        __asm shl esi, cl\n   342â†’        __asm and edx, esi\n   343â†’        __asm test edx, edx\n   344â†’        __asm je INCBIT\n   345â†’        iReturn++;\n   346â†’INCBIT: dwStartBit++;\n   347â†’    }\n   348â†’\n   349â†’    // Force sign bit to extend across 32-bit boundary\n   350â†’    iReturn <<= (0x20 - dwTotalBits);\n   351â†’    iReturn >>= (0x20 - dwTotalBits);\n   352â†’    return iReturn;\n   353â†’}\n   354â†’```\n   355â†’\n   356â†’### 3.2 First Frame (Uncompressed)\n   357â†’\n   358â†’The first frame stores absolute values with no delta compression.\n   359â†’\n   360â†’#### 3.2.1 Position Offsets\n   361â†’\n   362â†’**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n   363â†’\n   364â†’**Example** (Cloud's first animation, `rtda`):\n   365â†’- Bytes: `00 00 FE 2E 00 00`\n   366â†’- Values: `X=0`, `Y=-466`, `Z=0`\n   367â†’- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n   368â†’\n   369â†’**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n   370â†’\n   371â†’**Code**:\n   372â†’\n   373â†’```c\n   374â†’PFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\n   375â†’BYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n   376â†’\n   377â†’DWORD dwBitStart = 0;\n   378â†’SHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   379â†’SHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   380â†’SHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n   381â†’// Result: sX=0, sY=-466, sZ=0\n   382â†’```\n   383â†’\n   384â†’#### 3.2.2 Rotation Data\n   385â†’\n   386â†’**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n   387â†’- If `bKey = 0`: 12 bits per rotation\n   388â†’- If `bKey = 2`: 10 bits per rotation\n   389â†’- If `bKey = 4`: 8 bits per rotation\n   390â†’\n   391â†’**Normalization**: Shift left by `bKey` to restore 12-bit range.\n   392â†’\n   393â†’**Code** (for each bone's 3 rotations):\n   394â†’\n   395â†’```c\n   396â†’SHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   397â†’12 - pfmhMiniHeader->bKey );\n   398â†’SHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   399â†’12 - pfmhMiniHeader->bKey );\n   400â†’SHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n   401â†’12 - pfmhMiniHeader->bKey );\n   402â†’\n   403â†’// Normalize to 12-bit range\n   404â†’sRotX <<= pfmhMiniHeader->bKey;\n   405â†’sRotY <<= pfmhMiniHeader->bKey;\n   406â†’sRotZ <<= pfmhMiniHeader->bKey;\n   407â†’```\n   408â†’\n   409â†’### 3.3 Subsequent Frames (Compressed Delta Encoding)\n   410â†’\n   411â†’Frames after the first store delta values (changes from previous frame).\n   412â†’\n   413â†’#### 3.3.1 Position Deltas\n   414â†’\n   415â†’**Format**: Variable-length encoding (8 or 17 bits)\n   416â†’\n   417â†’**Algorithm**:\n   418â†’1. Read 1 flag bit\n   419â†’   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   420â†’   - If `1`: Next 16 bits are signed delta (total 17 bits)\n   421â†’\n   422â†’**GetDynamicFrameOffsetBits Function**:\n   423â†’\n   424â†’```c\n   425â†’SHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\n   426â†’DWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n   427â†’    SHORT sReturn;\n   428â†’    __asm {\n   429â†’        mov eax, dwBitStart\n   430â†’        mov eax, [eax]\n   431â†’        cdq\n   432â†’        and edx, 7\n   433â†’        add eax, edx\n   434â†’        sar eax, 3\n   435â†’        mov dwFirstByte, eax\n   436â†’        mov ecx, dwBitStart\n   437â†’        mov edx, [ecx]\n   438â†’        and edx, 7\n   439â†’        mov dwConsumedBits, edx\n   440â†’        mov eax, 7\n   441â†’        sub eax, dwConsumedBits\n   442â†’        mov dwBitsRemainingToNextByte, eax\n   443â†’        mov ecx, pBuffer\n   444â†’        add ecx, dwFirstByte\n   445â†’        xor edx, edx\n   446â†’        mov dl, byte ptr ds:[ecx]\n   447â†’        shl edx, 8\n   448â†’        mov eax, pBuffer\n   449â†’        add eax, dwFirstByte\n   450â†’        xor ecx, ecx\n   451â†’        mov cl, byte ptr ds:[eax+1]\n   452â†’        or edx, ecx\n   453â†’        mov dwTemp, edx\n   454â†’        mov ecx, dwBitsRemainingToNextByte\n   455â†’        add ecx, 8\n   456â†’        mov edx, 1\n   457â†’        shl edx, cl\n   458â†’        mov eax, dwTemp\n   459â†’        and eax, edx\n   460â†’        test eax, eax\n   461â†’        jnz SeventeenBits\n   462â†’\n   463â†’EightBits :\n   464â†’        mov ecx, dwConsumedBits\n   465â†’        add ecx, 1\n   466â†’        mov edx, dwTemp\n   467â†’        shl edx, cl\n   468â†’        movsx eax, dx\n   469â†’        sar eax, 9\n   470â†’        mov sReturn, ax\n   471â†’        mov ecx, dwBitStart\n   472â†’        mov edx, [ecx]\n   473â†’        add edx, 8\n   474â†’        mov eax, dwBitStart\n   475â†’        mov [eax], edx      // Increase dwBitStart by 8\n   476â†’        jmp End\n   477â†’\n   478â†’SeventeenBits :\n   479â†’        mov ecx, dwTemp\n   480â†’        shl ecx, 8\n   481â†’        mov edx, pBuffer\n   482â†’        add edx, dwFirstByte\n   483â†’        xor eax, eax\n   484â†’        mov al, byte ptr ds:[edx+2]\n   485â†’        or ecx, eax\n   486â†’        mov dwTemp, ecx\n   487â†’        mov ecx, dwConsumedBits\n   488â†’        add ecx, 1\n   489â†’        mov edx, dwTemp\n   490â†’        shl edx, cl\n   491â†’        shr edx, 8\n   492â†’        mov sReturn, dx\n   493â†’        mov eax, dwBitStart\n   494â†’        mov ecx, [eax]\n   495â†’        add ecx, 0x11\n   496â†’        mov edx, dwBitStart\n   497â†’        mov [edx], ecx      // Increase dwBitStart by 17\n   498â†’\n   499â†’End :\n   500â†’    }\n   501â†’    return sReturn;\n   502â†’}\n   503â†’```\n   504â†’\n   505â†’**Usage**:\n   506â†’\n   507â†’```c\n   508â†’SHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   509â†’SHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   510â†’SHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n   511â†’\n   512â†’// Add deltas to previous frame\n   513â†’FF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\n   514â†’FF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\n   515â†’FF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n   516â†’```\n   517â†’\n   518â†’#### 3.3.2 Rotation Deltas\n   519â†’\n   520â†’**Format**: Complex variable-length encoding optimized for small deltas.\n   521â†’\n   522â†’**Algorithm Overview**:\n   523â†’1. Read 1 flag bit:\n   524â†’   - If `0`: Delta is zero, done\n   525â†’   - If `1`: Continue to step 2\n   526â†’2. Read 3-bit type field (values 0-7)\n   527â†’3. Decode based on type:\n   528â†’   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   529â†’   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   530â†’   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n   531â†’\n   532â†’**Signed Magnitude Transform** (Types 1-6):\n   533â†’\n   534â†’If the N-bit value is negative:\n   535â†’- Subtract `(1 << (N - 1))`\n   536â†’\n   537â†’If positive:\n   538â†’- Add `(1 << (N - 1))`\n   539â†’\n   540â†’Finally, shift left by `bKey` to adjust for precision.\n   541â†’\n   542â†’**Example** (Type 4, meaning 4 bits):\n   543â†’- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n   544â†’- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n   545â†’- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n   546â†’\n   547â†’**GetEncryptedRotationBits Function**:\n   548â†’\n   549â†’```c\n   550â†’SHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\n   551â†’INT iKeyBits ) {\n   552â†’    DWORD dwNumBits, dwType;\n   553â†’    INT iTemp;\n   554â†’    SHORT sReturn;\n   555â†’    // Check the first bit\n   556â†’    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n   557â†’    __asm mov eax, iBits\n   558â†’    __asm test eax, eax\n   559â†’    __asm jnz SecondTest\n   560â†’    __asm jmp ReturnZero    // Return 0\n   561â†’\n   562â†’SecondTest :\n   563â†’    // Get next 3 bits\n   564â†’    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n   565â†’    __asm mov eax, iBits\n   566â†’    __asm and eax, 7\n   567â†’    __asm mov dwNumBits, eax\n   568â†’    __asm mov ecx, dwNumBits\n   569â†’    __asm mov dwType, ecx\n   570â†’    __asm cmp dwType, 7\n   571â†’    __asm ja ReturnZero\n   572â†’\n   573â†’    // Switch on type\n   574â†’    switch ( dwType ) {\n   575â†’        case 0 : {\n   576â†’            __asm or eax, 0xFFFFFFFF    // EAX = -1\n   577â†’            __asm mov ecx, iKeyBits\n   578â†’            __asm shl eax, cl           // (-1 << iKeyBits)\n   579â†’            __asm mov sReturn, ax\n   580â†’            __asm jmp End\n   581â†’        }\n   582â†’        case 1 : {}\n   583â†’        case 2 : {}\n   584â†’        case 3 : {}\n   585â†’        case 4 : {}\n   586â†’        case 5 : {}\n   587â†’        case 6 : {\n   588â†’            // Read N bits\n   589â†’            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n   590â†’                dwNumBits );\n   591â†’            __asm mov eax, iTemp\n   592â†’            __asm cmp iTemp, 0\n   593â†’            __asm jl IfLessThanZero\n   594â†’            // If >= 0: add (1 << (dwNumBits - 1))\n   595â†’            __asm mov ecx, dwNumBits\n   596â†’            __asm sub ecx, 1\n   597â†’            __asm mov eax, 1\n   598â†’            __asm shl eax, cl\n   599â†’            __asm mov ecx, iTemp\n   600â†’            __asm add ecx, eax\n   601â†’            __asm mov iTemp, ecx\n   602â†’            __asm jmp AfterTests\n   603â†’IfLessThanZero :\n   604â†’            // If < 0: subtract (1 << (dwNumBits - 1))\n   605â†’            __asm mov ecx, dwNumBits\n   606â†’            __asm sub ecx, 1\n   607â†’            __asm mov edx, 1\n   608â†’            __asm shl edx, cl\n   609â†’            __asm mov eax, iTemp\n   610â†’            __asm sub eax, edx\n   611â†’            __asm mov iTemp, eax\n   612â†’\n   613â†’AfterTests :\n   614â†’            // Shift by precision\n   615â†’            __asm mov eax, iTemp\n   616â†’            __asm mov ecx, iKeyBits\n   617â†’            __asm shl eax, cl\n   618â†’            __asm mov sReturn, ax\n   619â†’            __asm jmp End\n   620â†’        }\n   621â†’\n   622â†’        case 7 : {\n   623â†’            // Uncompressed: read (12 - iKeyBits) bits\n   624â†’            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n   625â†’                12 - iKeyBits );\n   626â†’            __asm mov ecx, iKeyBits\n   627â†’            __asm shl eax, cl\n   628â†’            __asm mov sReturn, ax\n   629â†’            __asm jmp End\n   630â†’        }\n   631â†’\n   632â†’    }\n   633â†’\n   634â†’\n   635â†’ReturnZero :\n   636â†’    __asm xor ax, ax\n   637â†’    __asm mov sReturn, ax\n   638â†’\n   639â†’End :\n   640â†’\n   641â†’    return sReturn;\n   642â†’}\n   643â†’```\n   644â†’\n   645â†’---\n   646â†’\n   647â†’## 4. Implementation Guide\n   648â†’\n   649â†’### 4.1 LoadFrames Function\n   650â†’\n   651â†’**Purpose**: Load an entire frame (position + all bone rotations) at once.\n   652â†’\n   653â†’**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n   654â†’\n   655â†’**Parameters**:\n   656â†’- `pfbFrameBuffer`: Pointer to frame buffer to fill\n   657â†’- `iBones`: Number of bones in skeleton\n   658â†’- `iBitStart`: Bit offset to start reading (0 for first frame)\n   659â†’- `pbAnimBuffer`: Byte array containing animation data\n   660â†’\n   661â†’**Implementation**:\n   662â†’\n   663â†’```c\n   664â†’DWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\n   665â†’INT iBones,\n   666â†’INT iBitStart,\n   667â†’BYTE * pbAnimBuffer ) {\n   668â†’    // Get backups of parameters\n   669â†’DWORD       dwThisBitStart  = iBitStart;\n   670â†’    INT     iThisBones      = iBones;\n   671â†’    BYTE *  pbThisBuffer    = pbAnimBuffer;\n   672â†’\n   673â†’    PFF7FrameMiniHeader pfmhMiniHeader =\n   674â†’        (PFF7FrameMiniHeader)pbAnimBuffer;\n   675â†’    SHORT   sSize = pfmhMiniHeader->sSize;\n   676â†’    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n   677â†’\n   678â†’    // Skip 5-byte miniheader\n   679â†’    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n   680â†’\n   681â†’    if ( iBitStart == 0 ) { // First frame?\n   682â†’        // Uncompressed position offsets\n   683â†’        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   684â†’        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   685â†’        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n   686â†’\n   687â†’        // Convert to FLOAT\n   688â†’        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n   689â†’        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n   690â†’        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n   691â†’\n   692â†’        for ( int I = 0; I < iThisBones; I++ ) {\n   693â†’            // Read rotations (12 - bKeyBits) bits each\n   694â†’            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   695â†’            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   696â†’            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n   697â†’\n   698â†’            // Convert SHORT to INT (absolute value)\n   699â†’            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n   700â†’            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n   701â†’            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n   702â†’        }\n   703â†’    }\n   704â†’    else {                  // Subsequent frames\n   705â†’        SHORT sX, sY, sZ;\n   706â†’\n   707â†’        // Get position deltas\n   708â†’        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   709â†’        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   710â†’        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n   711â†’\n   712â†’        // Add deltas to previous frame\n   713â†’        pfbFrameBuffer->svPosOffset.sX += sX;\n   714â†’        pfbFrameBuffer->svPosOffset.sY += sY;\n   715â†’        pfbFrameBuffer->svPosOffset.sZ += sZ;\n   716â†’\n   717â†’        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n   718â†’        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n   719â†’        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n   720â†’\n   721â†’        for ( int I = 0; I < iThisBones; I++ ) {\n   722â†’            // Get rotation deltas\n   723â†’            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   724â†’            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   725â†’            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n   726â†’\n   727â†’            // Add deltas\n   728â†’            pfbFrameBuffer->psvRots[I].sX += sX;\n   729â†’            pfbFrameBuffer->psvRots[I].sY += sY;\n   730â†’            pfbFrameBuffer->psvRots[I].sZ += sZ;\n   731â†’\n   732â†’            // Note: Values can exceed 4095 through accumulation of positive deltas\n   733â†’\n   734â†’            // Convert to INT\n   735â†’            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n   736â†’            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n   737â†’            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n   738â†’        }\n   739â†’    }\n   740â†’\n   741â†’    // Return next frame's bit offset (or 0 if done)\n   742â†’    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\n   743â†’return dwThisBitStart;\n   744â†’}\n   745â†’    return 0;\n   746â†’}\n   747â†’```\n   748â†’\n   749â†’### 4.2 Complete Animation Loading Loop\n   750â†’\n   751â†’**Example**: Load all frames in an animation.\n   752â†’\n   753â†’```c\n   754â†’FF7FrameHeader fhHeader;\n   755â†’ReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\n   756â†’NULL );\n   757â†’BYTE * baData = new BYTE[fhHeader.dwChunkSize];\n   758â†’ReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\n   759â†’NULL );\n   760â†’\n   761â†’    // Allocate frame buffer\n   762â†’FF7FrameBuffer fbFrameBuffer;\n   763â†’fbFrameBuffer.SetBones( fhHeader.dwBones );\n   764â†’INT iBits = 0;\n   765â†’\n   766â†’for ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n   767â†’    // Load frame\n   768â†’    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n   769â†’\n   770â†’    // Reverse Y offset (required)\n   771â†’    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n   772â†’\n   773â†’    // Convert INT rotations to FLOAT degrees\n   774â†’    // Note: First rotation (root) is typically 0,0,0 but some animations\n   775â†’    // store a base rotation for dynamic targeting\n   776â†’    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n   777â†’        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n   778â†’        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n   779â†’        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n   780â†’    }\n   781â†’\n   782â†’    // Store frame data here (application-specific)\n   783â†’}\n   784â†’\n   785â†’delete [] baData;\n   786â†’```\n   787â†’\n   788â†’---\n   789â†’\n   790â†’## 5. Alternative Implementations\n   791â†’\n   792â†’### 5.1 Qhimm's C++ Versions\n   793â†’\n   794â†’**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n   795â†’\n   796â†’#### GetValueFromStream\n   797â†’\n   798â†’Replaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n   799â†’\n   800â†’```cpp\n   801â†’short GetValueFromStream( BYTE *pStreamBytes,\n   802â†’DWORD *pdwStreamBitOffset )\n   803â†’{\n   804â†’    short sValue;\n   805â†’    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n   806â†’    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n   807â†’    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n   808â†’    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n   809â†’\n   810â†’    // Test first bit to determine value size\n   811â†’    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n   812â†’    {   // 16-bit value\n   813â†’        dwNextStreamBytes = dwNextStreamBytes << 8 |\n   814â†’            pStreamBytes[dwStreamByteOffset + 2];\n   815â†’        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n   816â†’        *pdwStreamBitOffset += 17;\n   817â†’    }\n   818â†’    else\n   819â†’    {   // 7-bit value\n   820â†’        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n   821â†’        *pdwStreamBitOffset += 8;\n   822â†’    }\n   823â†’\n   824â†’    return sValue;\n   825â†’}\n   826â†’```\n   827â†’\n   828â†’#### GetCompressedDeltaFromStream\n   829â†’\n   830â†’Replaces `GetEncryptedRotationBits` with clearer C++ implementation.\n   831â†’\n   832â†’```cpp\n   833â†’short GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\n   834â†’int nLoweredPrecisionBits )\n   835â†’{\n   836â†’    unsigned int nBits;\n   837â†’    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n   838â†’    if (iFirstBit)\n   839â†’    {\n   840â†’        unsigned int uType = GetBitsFromStream( pStreamBytes,\n   841â†’            pdwStreamBitOffset, 3 ) & 7;\n   842â†’        switch (uType)\n   843â†’        {\n   844â†’        case 0:\n   845â†’            // Minimum decrement\n   846â†’            return (-1 << nLoweredPrecisionBits);\n   847â†’\n   848â†’        case 1: case 2: case 3: case 4: case 5: case 6:\n   849â†’            // Read N bits\n   850â†’            int iTemp = GetBitsFromStream( pStreamBytes,\n   851â†’                pdwStreamBitOffset, nBits );\n   852â†’            // Apply signed magnitude transform\n   853â†’            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n   854â†’            else            iTemp += 1 << (nBits - 1);\n   855â†’            // Adjust for precision\n   856â†’            return (iTemp << nLoweredPrecisionBits);\n   857â†’\n   858â†’        case 7:\n   859â†’            // Uncompressed\n   860â†’            iTemp = GetBitsFromStream( pStreamBytes,\n   861â†’                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n   862â†’            return (iTemp << nLoweredPrecisionBits);\n   863â†’        default:\n   864â†’        }\n   865â†’    }\n   866â†’    return 0;\n   867â†’}\n   868â†’```\n   869â†’\n   870â†’### 5.2 Rotation Compression Theory\n   871â†’\n   872â†’*Notes by Qhimm*\n   873â†’\n   874â†’#### Why This Encoding Is Efficient\n   875â†’\n   876â†’Rotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n   877â†’\n   878â†’**Bit Allocation**:\n   879â†’- Zero delta: 1 bit (`0`)\n   880â†’- Minimum decrement: 4 bits (`1 000`)\n   881â†’- Small deltas (1-6 bits): 126 possible values\n   882â†’- Large deltas: Uncompressed form\n   883â†’\n   884â†’**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n   885â†’\n   886â†’#### Signed Magnitude Encoding\n   887â†’\n   888â†’For delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n   889â†’\n   890â†’1. **Magnitude**: Value of most significant value bit\n   891â†’   - Example: Values `1` and `-2` both have magnitude `1`\n   892â†’   - Value `30` has magnitude `32`\n   893â†’\n   894â†’2. **Signed Magnitude**: Magnitude Ã— sign of value\n   895â†’   - Example: `-2` has signed magnitude `-1`\n   896â†’\n   897â†’3. **Encoding**: Subtract signed magnitude before storing\n   898â†’   - Pushes values toward zero\n   899â†’   - Ensures all transformed values fit in 6 bits or fewer\n   900â†’\n   901â†’4. **Decoding**: Add back the signed magnitude\n   902â†’   - Magnitude determined by number of bits read\n   903â†’   - Sign determined by MSB of encoded value\n   904â†’\n   905â†’#### Encoding Examples\n   906â†’\n   907â†’| Delta Value | Encoded Bits        | Notes                                    |\n   908â†’|-------------|---------------------|------------------------------------------|\n   909â†’| 0           | `0`                 | Single zero bit                          |\n   910â†’| -1          | `1 000`             | Type 0 (minimum decrement)               |\n   911â†’| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n   912â†’| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n   913â†’| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n   914â†’\n   915â†’*(Values shown in current precision as integers)*\n   916â†’\n   917â†’#### Precision Trade-offs\n   918â†’\n   919â†’Precision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n   920â†’\n   921â†’**Advantages**:\n   922â†’- Smaller raw values\n   923â†’- Increased relative span of compressed encodings\n   924â†’- Much smaller file sizes\n   925â†’\n   926â†’**Disadvantages**:\n   927â†’- Quantization error\n   928â†’- Less precise rotations\n   929â†’\n   930â†’**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n   931â†’\n   932â†’**Note**: Reduced precision is treated as rounding toward negative infinity.\n   933â†’\n   934â†’---\n   935â†’\n   936â†’## Appendix A: Quick Reference\n   937â†’\n   938â†’### Structure Sizes\n   939â†’\n   940â†’| Structure          | Size (bytes) | Offset Fields                              |\n   941â†’|--------------------|--------------|--------------------------------------------|\n   942â†’| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n   943â†’| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n   944â†’| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n   945â†’\n   946â†’### bKey Values\n   947â†’\n   948â†’| bKey | Uncompressed Bits | Formula         | Range   |\n   949â†’|------|-------------------|-----------------|---------|\n   950â†’| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n   951â†’| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n   952â†’| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n   953â†’\n   954â†’### Conversion Formulas\n   955â†’\n   956â†’**SHORT to Degrees**:\n   957â†’```text\n   958â†’degrees = (SHORT / 4096) * 360\n   959â†’```\n   960â†’\n   961â†’**SHORT to INT (with wrapping)**:\n   962â†’```text\n   963â†’INT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n   964â†’```\n   965â†’\n   966â†’**INT to FLOAT**:\n   967â†’```text\n   968â†’FLOAT = (INT / 4096.0f) * 360.0f\n   969â†’```\n   970â†’\n   971â†’### Position Delta Encoding\n   972â†’\n   973â†’| First Bit | Total Bits | Format     |\n   974â†’|-----------|------------|------------|\n   975â†’| 0         | 8          | 7-bit delta|\n   976â†’| 1         | 17         | 16-bit delta|\n   977â†’\n   978â†’### Rotation Delta Type Field\n   979â†’\n   980â†’| Type | Bits to Read        | Meaning                        |\n   981â†’|------|---------------------|--------------------------------|\n   982â†’| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n   983â†’| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n   984â†’| 7    | `12 - bKey`         | Uncompressed rotation value    |\n   985â†’\n   986â†’---\n   987â†’\n   988â†’## Appendix B: Known Issues\n   989â†’\n   990â†’### Corrupted Animations\n   991â†’\n   992â†’**RSAA Animation 15** (playable frog):\n   993â†’- Missing `sFrames` field\n   994â†’- `sSize` appears at offset 0x00 instead of 0x02\n   995â†’- `bKey` appears at offset 0x02 instead of 0x04\n   996â†’- FF7 cannot load this animation (likely damaged in original game data)\n   997â†’\n   998â†’### Frame Count Discrepancies\n   999â†’\n  1000â†’**sFrames vs. dwFrames**:\n  1001â†’- Rarely match in practice\n  1002â†’- `dwFrames` is more conservative (guarantees minimum)\n  1003â†’- `sFrames` sometimes exceeds actual frame count\n  1004â†’- **Solution**: Parse entire chunk to determine true frame count\n  1005â†’\n  1006â†’**Possible Causes**:\n  1007â†’- Dummy frames padded for memory alignment\n  1008â†’- Special-purpose data interleaved with frames\n  1009â†’- Animation authoring tool artifacts\n  1010â†’\n  1011â†’### Root Rotation Behavior\n  1012â†’\n  1013â†’**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n  1014â†’\n  1015â†’**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n  1016â†’- Model facing toward attack target\n  1017â†’- Model rotating during special moves\n  1018â†’\n  1019â†’**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n  1020â†’\n  1021â†’---\n  1022â†’\n  1023â†’**End of Document**\n  1024â†’"}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"5f352875-41db-4ab7-bdc1-9d773cbad1b7","tool_use_result":{"type":"update","filePath":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md","content":"---\ntitle: \"FF7 Battle Animation Format (PC)\"\nmodule: \"Battle\"\ncreated: \"2025-11-29 16:15 JST\"\nmodified: \"2025-12-01 21:20 JST\"\nsession_id: \"887a1b3f-e34c-44f4-8434-e7e55610b603\"\nauthor: \"Generated by Claude Code Documentation Standardization Agent\"\nstatus: \"Complete\"\n\nllm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\nllm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\nllm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\nllm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n\nreferenced_by: []\n---\n\n<!--\nSTANDARDIZATION METADATA\nOriginal: FF7_Battle_Battle_Animation_PC.md\nSource: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\nStandardized: 2025-12-01 21:20 JST\nSession-ID: 887a1b3f-e34c-44f4-8434-e7e55610b603\nAgent: FF7 Documentation Standardization Agent v1.0\n\nPrevious Merge Metadata:\nMERGE METADATA\nCreated: 2025-11-29\nOriginal: FF7_Battle_Battle_Animation_PC.md (912 lines)\nMajor section: 06_BATTLE_MODULE.md\nMerge decision: NO EXTRACTION PERFORMED\nReason: Individual file contains comprehensive battle animation format documentation\nAnalysis: Major section does not contain additional PC animation format details\nStatus: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\nRestructure: Improved organization, fixed typos, enhanced readability\n\nStandardization Changes Applied:\n- Added YAML frontmatter with LLM routing metadata (proper YAML syntax)\n- Fixed previous YAML frontmatter error (markdown comments inside YAML block)\n- Added HTML comment metadata block preserving original merge metadata\n- Added LLM context block for routing decisions\n- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n- Verified all code blocks have language tags (already present)\n- Verified no wiki-style links present (none to convert)\n- Verified no image references (none present in original)\n- Added related document cross-references in frontmatter\n- Updated session ID to current session\n\nLLM CONTEXT BLOCK (Read this first for routing decisions):\nThis document provides comprehensive reverse-engineering documentation for FF7's PC battle\nanimation binary format, originally documented by L. Spiro. It covers the complete data\npipeline from file parsing through skeletal rotation decoding, including bit-stream reading\nalgorithms, delta compression schemes, and C++ implementations with inline assembly. Key\nconcepts include the bKey precision field controlling rotation bit depth, signed magnitude\nencoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\nis the definitive reference for implementing animation loaders or debugging animation playback.\nCross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n-->\n\n# FF7 Battle Animation Format (PC)\n\n- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n  - [Overview](#overview)\n  - [1. File Structure](#1-file-structure)\n  - [2. Data Structures](#2-data-structures)\n  - [3. Decoding Algorithms](#3-decoding-algorithms)\n  - [4. Implementation Guide](#4-implementation-guide)\n  - [5. Alternative Implementations](#5-alternative-implementations)\n  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n  - [Appendix B: Known Issues](#appendix-b-known-issues)\n\n## Overview\n\nThis document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n\n### What This Document Covers\n\n- Binary file structure for battle animations\n- Data structures for storing skeletal animations\n- Compression algorithms for rotation data\n- Complete C++ implementation with assembly optimizations\n- Theoretical background on the compression scheme\n\n### File Format Basics\n\nBattle animation files contain skeletal animation data for character models. Each file stores:\n- Multiple animations for a single character\n- Per-frame bone rotations and positions\n- Compressed delta encoding for subsequent frames\n- Special animation markers for scripted events\n\n---\n\n## 1. File Structure\n\n### 1.1 Animation File Layout\n\nBattle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n\n**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n\nTo navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n\n### 1.2 File Header Format\n\nEach animation begins with a 12-byte header followed by animation data.\n\n---\n\n## 2. Data Structures\n\n### 2.1 FF7FrameHeader\n\n**Purpose**: Main header for each animation in the file.\n\n**Structure** (12 bytes):\n\n```c\ntypedef struct FF7FrameHeader {\n    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n                                // NOTE: Unreliable - use skeleton file bone count instead.\n    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n} * PFF7FrameHeader;            // Total size: 12 bytes\n```\n\n#### Special Animation Chunks\n\nWhen `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n\n#### Navigation Example\n\nTo skip to animation index `iTarget`:\n\n```c\nFF7FrameHeader  fhHeader;\nDWORD           dwBytesRead;\nfor ( int I = 0; I < iTarget; I++ ) {\n    if ( !ReadFile( hFile,\n        &fhHeader, sizeof( fhHeader ),\n        &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n    }\n    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n        INVALID_SET_FILE_POINTER ) {\n            CloseHandle( hFile );\n            return false;\n        }\n        continue;\n    }\n    // Skip this animation (size = dwChunkSize)\n    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n        CloseHandle( hFile );\n        return false;\n    }\n}\n// Now at the target animation\nif ( !ReadFile( hFile,\n    &fhHeader, sizeof( fhHeader ),\n    &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n}\nBYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n// pbBuffer now holds animation data including FF7FrameMiniHeader\n```\n\n### 2.2 FF7FrameMiniHeader\n\n**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n\n**Structure** (5 bytes):\n\n```c\ntypedef struct FF7FrameMiniHeader {\n    //SHORT     sBones; // Originally thought to be bone count\n    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n```\n\n#### Field Discrepancy Notes\n\n**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n\n**Reliability**: `sFrames` and `dwFrames` rarely match.\n- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n- `sFrames` sometimes exceeds actual frame count\n- **Determine actual frame count by parsing the entire chunk**\n\n**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n- `sSize` appears at offset 0x00\n- `bKey` appears at offset 0x02\n- FF7 cannot handle this animation (likely corrupted)\n\n### 2.3 bKey: The Precision Field\n\n**Purpose**: Controls rotation data bit depth and compression level.\n\n#### Valid Values\n\n| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n|------------|-------------------|-----------|----------------|\n| 0          | 12                | 0-4095    | None           |\n| 2          | 10                | 0-1023    | Low            |\n| 4          | 8                 | 0-255     | Moderate       |\n\n#### How It Works\n\n1. **Storage**: Rotations stored using `(12 - bKey)` bits\n2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n\n**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n\n### 2.4 FF7ShortVec (Rotation Storage)\n\n**Purpose**: Stores one bone's rotation in three numeric forms.\n\n**Structure** (30 bytes):\n\n```c\ntypedef struct FF7ShortVec {\n    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n} * PFF7ShortRot;           // Total size: 30 bytes\n```\n\n#### Three-Form Conversion\n\nRotations are processed through three representations:\n\n1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   - If `SHORT < 0`, add `0x1000` (4096)\n3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n\n#### Per-Frame Processing Sequence\n\n**First Frame**:\n1. Read X bits (determined by `bKey`) and store as signed SHORT\n2. Convert SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Subsequent Frames**:\n1. Read delta value, add to previous frame's SHORT\n2. Convert updated SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n\n### 2.5 FF7FrameBuffer (Frame Management)\n\n**Purpose**: Allocates memory for one frame's worth of bone rotations.\n\n**Structure**:\n\n```cpp\ntypedef struct FF7FrameBuffer {\n    DWORD           dwBones;\n    FF7ShortVec     svPosOffset;\n    FF7ShortVec     *psvRots;\n\n    FF7FrameBuffer() {\n        dwBones = 0;\n        psvRots = NULL;\n    }\n    ~FF7FrameBuffer() {\n        dwBones = 0;\n        delete [] psvRots;\n        psvRots = NULL;\n    }\n\n    VOID    SetBones( DWORD dwTotal ) {\n        // Delete the old\n        dwBones = 0;\n        delete [] psvRots;\n\n        // Create the new\n        psvRots = new FF7ShortVec[dwTotal];\n        if ( psvRots != NULL ) { dwBones = dwTotal; }\n    }\n} * PFF7FrameBuffer;\n```\n\n**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n\n---\n\n## 3. Decoding Algorithms\n\n### 3.1 Bit Stream Reading\n\n#### GetBitsFixed Function\n\n**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n\n**Parameters**:\n- `pbBuffer`: Byte array containing bit stream\n- `dwStartBit`: Bit offset to start reading (modified in place)\n- `dwTotalBits`: Number of bits to read\n\n**Returns**: Signed integer with sign extension.\n\n**Implementation**:\n\n```c\nINT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\nDWORD dwTotalBits ) {\n    INT iReturn = 0;\n\n    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n        iReturn <<= 1;\n\n        __asm mov eax, dwStartBit\n        __asm mov eax, [eax]\n        __asm cdq\n        __asm and edx, 7\n        __asm add eax, edx\n        __asm sar eax, 3\n        __asm mov ecx, pbBuffer\n        __asm xor edx, edx\n        __asm mov dl, byte ptr ds:[ecx+eax]\n        __asm mov eax, dwStartBit\n        __asm mov ecx, [eax]\n        __asm and ecx, 7\n        __asm mov eax, 7\n        __asm sub eax, ecx\n        __asm mov esi, 1\n        __asm mov ecx, eax\n        __asm shl esi, cl\n        __asm and edx, esi\n        __asm test edx, edx\n        __asm je INCBIT\n        iReturn++;\nINCBIT: dwStartBit++;\n    }\n\n    // Force sign bit to extend across 32-bit boundary\n    iReturn <<= (0x20 - dwTotalBits);\n    iReturn >>= (0x20 - dwTotalBits);\n    return iReturn;\n}\n```\n\n### 3.2 First Frame (Uncompressed)\n\nThe first frame stores absolute values with no delta compression.\n\n#### 3.2.1 Position Offsets\n\n**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n\n**Example** (Cloud's first animation, `rtda`):\n- Bytes: `00 00 FE 2E 00 00`\n- Values: `X=0`, `Y=-466`, `Z=0`\n- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n\n**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n\n**Code**:\n\n```c\nPFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\nBYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n\nDWORD dwBitStart = 0;\nSHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n// Result: sX=0, sY=-466, sZ=0\n```\n\n#### 3.2.2 Rotation Data\n\n**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n- If `bKey = 0`: 12 bits per rotation\n- If `bKey = 2`: 10 bits per rotation\n- If `bKey = 4`: 8 bits per rotation\n\n**Normalization**: Shift left by `bKey` to restore 12-bit range.\n\n**Code** (for each bone's 3 rotations):\n\n```c\nSHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\n\n// Normalize to 12-bit range\nsRotX <<= pfmhMiniHeader->bKey;\nsRotY <<= pfmhMiniHeader->bKey;\nsRotZ <<= pfmhMiniHeader->bKey;\n```\n\n### 3.3 Subsequent Frames (Compressed Delta Encoding)\n\nFrames after the first store delta values (changes from previous frame).\n\n#### 3.3.1 Position Deltas\n\n**Format**: Variable-length encoding (8 or 17 bits)\n\n**Algorithm**:\n1. Read 1 flag bit\n   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   - If `1`: Next 16 bits are signed delta (total 17 bits)\n\n**GetDynamicFrameOffsetBits Function**:\n\n```c\nSHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\nDWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n    SHORT sReturn;\n    __asm {\n        mov eax, dwBitStart\n        mov eax, [eax]\n        cdq\n        and edx, 7\n        add eax, edx\n        sar eax, 3\n        mov dwFirstByte, eax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        and edx, 7\n        mov dwConsumedBits, edx\n        mov eax, 7\n        sub eax, dwConsumedBits\n        mov dwBitsRemainingToNextByte, eax\n        mov ecx, pBuffer\n        add ecx, dwFirstByte\n        xor edx, edx\n        mov dl, byte ptr ds:[ecx]\n        shl edx, 8\n        mov eax, pBuffer\n        add eax, dwFirstByte\n        xor ecx, ecx\n        mov cl, byte ptr ds:[eax+1]\n        or edx, ecx\n        mov dwTemp, edx\n        mov ecx, dwBitsRemainingToNextByte\n        add ecx, 8\n        mov edx, 1\n        shl edx, cl\n        mov eax, dwTemp\n        and eax, edx\n        test eax, eax\n        jnz SeventeenBits\n\nEightBits :\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        movsx eax, dx\n        sar eax, 9\n        mov sReturn, ax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        add edx, 8\n        mov eax, dwBitStart\n        mov [eax], edx      // Increase dwBitStart by 8\n        jmp End\n\nSeventeenBits :\n        mov ecx, dwTemp\n        shl ecx, 8\n        mov edx, pBuffer\n        add edx, dwFirstByte\n        xor eax, eax\n        mov al, byte ptr ds:[edx+2]\n        or ecx, eax\n        mov dwTemp, ecx\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        shr edx, 8\n        mov sReturn, dx\n        mov eax, dwBitStart\n        mov ecx, [eax]\n        add ecx, 0x11\n        mov edx, dwBitStart\n        mov [edx], ecx      // Increase dwBitStart by 17\n\nEnd :\n    }\n    return sReturn;\n}\n```\n\n**Usage**:\n\n```c\nSHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n\n// Add deltas to previous frame\nFF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\nFF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\nFF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n```\n\n#### 3.3.2 Rotation Deltas\n\n**Format**: Complex variable-length encoding optimized for small deltas.\n\n**Algorithm Overview**:\n1. Read 1 flag bit:\n   - If `0`: Delta is zero, done\n   - If `1`: Continue to step 2\n2. Read 3-bit type field (values 0-7)\n3. Decode based on type:\n   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n\n**Signed Magnitude Transform** (Types 1-6):\n\nIf the N-bit value is negative:\n- Subtract `(1 << (N - 1))`\n\nIf positive:\n- Add `(1 << (N - 1))`\n\nFinally, shift left by `bKey` to adjust for precision.\n\n**Example** (Type 4, meaning 4 bits):\n- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n\n**GetEncryptedRotationBits Function**:\n\n```c\nSHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\nINT iKeyBits ) {\n    DWORD dwNumBits, dwType;\n    INT iTemp;\n    SHORT sReturn;\n    // Check the first bit\n    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n    __asm mov eax, iBits\n    __asm test eax, eax\n    __asm jnz SecondTest\n    __asm jmp ReturnZero    // Return 0\n\nSecondTest :\n    // Get next 3 bits\n    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n    __asm mov eax, iBits\n    __asm and eax, 7\n    __asm mov dwNumBits, eax\n    __asm mov ecx, dwNumBits\n    __asm mov dwType, ecx\n    __asm cmp dwType, 7\n    __asm ja ReturnZero\n\n    // Switch on type\n    switch ( dwType ) {\n        case 0 : {\n            __asm or eax, 0xFFFFFFFF    // EAX = -1\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl           // (-1 << iKeyBits)\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n        case 1 : {}\n        case 2 : {}\n        case 3 : {}\n        case 4 : {}\n        case 5 : {}\n        case 6 : {\n            // Read N bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                dwNumBits );\n            __asm mov eax, iTemp\n            __asm cmp iTemp, 0\n            __asm jl IfLessThanZero\n            // If >= 0: add (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov eax, 1\n            __asm shl eax, cl\n            __asm mov ecx, iTemp\n            __asm add ecx, eax\n            __asm mov iTemp, ecx\n            __asm jmp AfterTests\nIfLessThanZero :\n            // If < 0: subtract (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov edx, 1\n            __asm shl edx, cl\n            __asm mov eax, iTemp\n            __asm sub eax, edx\n            __asm mov iTemp, eax\n\nAfterTests :\n            // Shift by precision\n            __asm mov eax, iTemp\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n        case 7 : {\n            // Uncompressed: read (12 - iKeyBits) bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                12 - iKeyBits );\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n    }\n\n\nReturnZero :\n    __asm xor ax, ax\n    __asm mov sReturn, ax\n\nEnd :\n\n    return sReturn;\n}\n```\n\n---\n\n## 4. Implementation Guide\n\n### 4.1 LoadFrames Function\n\n**Purpose**: Load an entire frame (position + all bone rotations) at once.\n\n**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n\n**Parameters**:\n- `pfbFrameBuffer`: Pointer to frame buffer to fill\n- `iBones`: Number of bones in skeleton\n- `iBitStart`: Bit offset to start reading (0 for first frame)\n- `pbAnimBuffer`: Byte array containing animation data\n\n**Implementation**:\n\n```c\nDWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\nINT iBones,\nINT iBitStart,\nBYTE * pbAnimBuffer ) {\n    // Get backups of parameters\nDWORD       dwThisBitStart  = iBitStart;\n    INT     iThisBones      = iBones;\n    BYTE *  pbThisBuffer    = pbAnimBuffer;\n\n    PFF7FrameMiniHeader pfmhMiniHeader =\n        (PFF7FrameMiniHeader)pbAnimBuffer;\n    SHORT   sSize = pfmhMiniHeader->sSize;\n    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n\n    // Skip 5-byte miniheader\n    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n\n    if ( iBitStart == 0 ) { // First frame?\n        // Uncompressed position offsets\n        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n\n        // Convert to FLOAT\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Read rotations (12 - bKeyBits) bits each\n            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n\n            // Convert SHORT to INT (absolute value)\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n    else {                  // Subsequent frames\n        SHORT sX, sY, sZ;\n\n        // Get position deltas\n        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n\n        // Add deltas to previous frame\n        pfbFrameBuffer->svPosOffset.sX += sX;\n        pfbFrameBuffer->svPosOffset.sY += sY;\n        pfbFrameBuffer->svPosOffset.sZ += sZ;\n\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Get rotation deltas\n            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n\n            // Add deltas\n            pfbFrameBuffer->psvRots[I].sX += sX;\n            pfbFrameBuffer->psvRots[I].sY += sY;\n            pfbFrameBuffer->psvRots[I].sZ += sZ;\n\n            // Note: Values can exceed 4095 through accumulation of positive deltas\n\n            // Convert to INT\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n\n    // Return next frame's bit offset (or 0 if done)\n    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\nreturn dwThisBitStart;\n}\n    return 0;\n}\n```\n\n### 4.2 Complete Animation Loading Loop\n\n**Example**: Load all frames in an animation.\n\n```c\nFF7FrameHeader fhHeader;\nReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\nNULL );\nBYTE * baData = new BYTE[fhHeader.dwChunkSize];\nReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\nNULL );\n\n    // Allocate frame buffer\nFF7FrameBuffer fbFrameBuffer;\nfbFrameBuffer.SetBones( fhHeader.dwBones );\nINT iBits = 0;\n\nfor ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n    // Load frame\n    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n\n    // Reverse Y offset (required)\n    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n\n    // Convert INT rotations to FLOAT degrees\n    // Note: First rotation (root) is typically 0,0,0 but some animations\n    // store a base rotation for dynamic targeting\n    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n    }\n\n    // Store frame data here (application-specific)\n}\n\ndelete [] baData;\n```\n\n---\n\n## 5. Alternative Implementations\n\n### 5.1 Qhimm's C++ Versions\n\n**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n\n#### GetValueFromStream\n\nReplaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n\n```cpp\nshort GetValueFromStream( BYTE *pStreamBytes,\nDWORD *pdwStreamBitOffset )\n{\n    short sValue;\n    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n\n    // Test first bit to determine value size\n    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n    {   // 16-bit value\n        dwNextStreamBytes = dwNextStreamBytes << 8 |\n            pStreamBytes[dwStreamByteOffset + 2];\n        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n        *pdwStreamBitOffset += 17;\n    }\n    else\n    {   // 7-bit value\n        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n        *pdwStreamBitOffset += 8;\n    }\n\n    return sValue;\n}\n```\n\n#### GetCompressedDeltaFromStream\n\nReplaces `GetEncryptedRotationBits` with clearer C++ implementation.\n\n```cpp\nshort GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\nint nLoweredPrecisionBits )\n{\n    unsigned int nBits;\n    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n    if (iFirstBit)\n    {\n        unsigned int uType = GetBitsFromStream( pStreamBytes,\n            pdwStreamBitOffset, 3 ) & 7;\n        switch (uType)\n        {\n        case 0:\n            // Minimum decrement\n            return (-1 << nLoweredPrecisionBits);\n\n        case 1: case 2: case 3: case 4: case 5: case 6:\n            // Read N bits\n            int iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, nBits );\n            // Apply signed magnitude transform\n            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n            else            iTemp += 1 << (nBits - 1);\n            // Adjust for precision\n            return (iTemp << nLoweredPrecisionBits);\n\n        case 7:\n            // Uncompressed\n            iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n            return (iTemp << nLoweredPrecisionBits);\n        default:\n        }\n    }\n    return 0;\n}\n```\n\n### 5.2 Rotation Compression Theory\n\n*Notes by Qhimm*\n\n#### Why This Encoding Is Efficient\n\nRotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n\n**Bit Allocation**:\n- Zero delta: 1 bit (`0`)\n- Minimum decrement: 4 bits (`1 000`)\n- Small deltas (1-6 bits): 126 possible values\n- Large deltas: Uncompressed form\n\n**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n\n#### Signed Magnitude Encoding\n\nFor delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n\n1. **Magnitude**: Value of most significant value bit\n   - Example: Values `1` and `-2` both have magnitude `1`\n   - Value `30` has magnitude `32`\n\n2. **Signed Magnitude**: Magnitude Ã— sign of value\n   - Example: `-2` has signed magnitude `-1`\n\n3. **Encoding**: Subtract signed magnitude before storing\n   - Pushes values toward zero\n   - Ensures all transformed values fit in 6 bits or fewer\n\n4. **Decoding**: Add back the signed magnitude\n   - Magnitude determined by number of bits read\n   - Sign determined by MSB of encoded value\n\n#### Encoding Examples\n\n| Delta Value | Encoded Bits        | Notes                                    |\n|-------------|---------------------|------------------------------------------|\n| 0           | `0`                 | Single zero bit                          |\n| -1          | `1 000`             | Type 0 (minimum decrement)               |\n| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n\n*(Values shown in current precision as integers)*\n\n#### Precision Trade-offs\n\nPrecision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n\n**Advantages**:\n- Smaller raw values\n- Increased relative span of compressed encodings\n- Much smaller file sizes\n\n**Disadvantages**:\n- Quantization error\n- Less precise rotations\n\n**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n\n**Note**: Reduced precision is treated as rounding toward negative infinity.\n\n---\n\n## Appendix A: Quick Reference\n\n### Structure Sizes\n\n| Structure          | Size (bytes) | Offset Fields                              |\n|--------------------|--------------|--------------------------------------------|\n| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n\n### bKey Values\n\n| bKey | Uncompressed Bits | Formula         | Range   |\n|------|-------------------|-----------------|---------|\n| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n\n### Conversion Formulas\n\n**SHORT to Degrees**:\n```text\ndegrees = (SHORT / 4096) * 360\n```\n\n**SHORT to INT (with wrapping)**:\n```text\nINT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n```\n\n**INT to FLOAT**:\n```text\nFLOAT = (INT / 4096.0f) * 360.0f\n```\n\n### Position Delta Encoding\n\n| First Bit | Total Bits | Format     |\n|-----------|------------|------------|\n| 0         | 8          | 7-bit delta|\n| 1         | 17         | 16-bit delta|\n\n### Rotation Delta Type Field\n\n| Type | Bits to Read        | Meaning                        |\n|------|---------------------|--------------------------------|\n| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n| 7    | `12 - bKey`         | Uncompressed rotation value    |\n\n---\n\n## Appendix B: Known Issues\n\n### Corrupted Animations\n\n**RSAA Animation 15** (playable frog):\n- Missing `sFrames` field\n- `sSize` appears at offset 0x00 instead of 0x02\n- `bKey` appears at offset 0x02 instead of 0x04\n- FF7 cannot load this animation (likely damaged in original game data)\n\n### Frame Count Discrepancies\n\n**sFrames vs. dwFrames**:\n- Rarely match in practice\n- `dwFrames` is more conservative (guarantees minimum)\n- `sFrames` sometimes exceeds actual frame count\n- **Solution**: Parse entire chunk to determine true frame count\n\n**Possible Causes**:\n- Dummy frames padded for memory alignment\n- Special-purpose data interleaved with frames\n- Animation authoring tool artifacts\n\n### Root Rotation Behavior\n\n**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n\n**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n- Model facing toward attack target\n- Model rotating during special moves\n\n**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n\n---\n\n**End of Document**\n","structuredPatch":[{"oldStart":2,"oldLines":18,"newStart":2,"newLines":16,"lines":[" title: \"FF7 Battle Animation Format (PC)\""," module: \"Battle\""," created: \"2025-11-29 16:15 JST\"","-modified: \"2025-12-01 22:04 JST\"","-session_id: \"6136e9a8-64f9-4433-adfc-6f7e0338819b\"","+modified: \"2025-12-01 21:20 JST\"","+session_id: \"887a1b3f-e34c-44f4-8434-e7e55610b603\""," author: \"Generated by Claude Code Documentation Standardization Agent\""," status: \"Complete\""," ","-# LLM-specific metadata (CRITICAL for routing)"," llm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\""," llm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]"," llm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]"," llm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]"," ","-# Backlinks (leave empty - populated in pass 2)"," referenced_by: []"," ---"," "]},{"oldStart":21,"oldLines":8,"newStart":19,"newLines":8,"lines":[" STANDARDIZATION METADATA"," Original: FF7_Battle_Battle_Animation_PC.md"," Source: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md","-Standardized: 2025-12-01 22:04 JST","-Session-ID: 6136e9a8-64f9-4433-adfc-6f7e0338819b","+Standardized: 2025-12-01 21:20 JST","+Session-ID: 887a1b3f-e34c-44f4-8434-e7e55610b603"," Agent: FF7 Documentation Standardization Agent v1.0"," "," Previous Merge Metadata:"]},{"oldStart":37,"oldLines":7,"newStart":35,"newLines":8,"lines":[" Restructure: Improved organization, fixed typos, enhanced readability"," "," Standardization Changes Applied:","-- Added YAML frontmatter with LLM routing metadata","+- Added YAML frontmatter with LLM routing metadata (proper YAML syntax)","+- Fixed previous YAML frontmatter error (markdown comments inside YAML block)"," - Added HTML comment metadata block preserving original merge metadata"," - Added LLM context block for routing decisions"," - Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)"]},{"oldStart":45,"oldLines":6,"newStart":44,"newLines":7,"lines":[" - Verified no wiki-style links present (none to convert)"," - Verified no image references (none present in original)"," - Added related document cross-references in frontmatter","+- Updated session ID to current session"," "," LLM CONTEXT BLOCK (Read this first for routing decisions):"," This document provides comprehensive reverse-engineering documentation for FF7's PC battle"]}],"originalFile":"---\ntitle: \"FF7 Battle Animation Format (PC)\"\nmodule: \"Battle\"\ncreated: \"2025-11-29 16:15 JST\"\nmodified: \"2025-12-01 22:04 JST\"\nsession_id: \"6136e9a8-64f9-4433-adfc-6f7e0338819b\"\nauthor: \"Generated by Claude Code Documentation Standardization Agent\"\nstatus: \"Complete\"\n\n# LLM-specific metadata (CRITICAL for routing)\nllm_summary: \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\"\nllm_tags: [\"battle-animation\", \"skeletal-animation\", \"delta-compression\", \"bit-stream\", \"rotation-encoding\", \"pc-format\"]\nllm_primary_topics: [\"Animation file structure\", \"FF7FrameHeader format\", \"Bit stream decoding\", \"Rotation delta compression\", \"Position offset encoding\"]\nllm_related_docs: [\"FF7_Battle_Battle_Mechanics.md\", \"FF7_Battle_Battle_Scenes.md\", \"FF7_Playstation_Battle_Model_Format.md\"]\n\n# Backlinks (leave empty - populated in pass 2)\nreferenced_by: []\n---\n\n<!--\nSTANDARDIZATION METADATA\nOriginal: FF7_Battle_Battle_Animation_PC.md\nSource: merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md\nStandardized: 2025-12-01 22:04 JST\nSession-ID: 6136e9a8-64f9-4433-adfc-6f7e0338819b\nAgent: FF7 Documentation Standardization Agent v1.0\n\nPrevious Merge Metadata:\nMERGE METADATA\nCreated: 2025-11-29\nOriginal: FF7_Battle_Battle_Animation_PC.md (912 lines)\nMajor section: 06_BATTLE_MODULE.md\nMerge decision: NO EXTRACTION PERFORMED\nReason: Individual file contains comprehensive battle animation format documentation\nAnalysis: Major section does not contain additional PC animation format details\nStatus: COMPLETE - Restructured for clarity 2025-11-29 16:15 JST\nRestructure: Improved organization, fixed typos, enhanced readability\n\nStandardization Changes Applied:\n- Added YAML frontmatter with LLM routing metadata\n- Added HTML comment metadata block preserving original merge metadata\n- Added LLM context block for routing decisions\n- Verified heading hierarchy (already correct: H1â†’H2â†’H3â†’H4)\n- Verified all code blocks have language tags (already present)\n- Verified no wiki-style links present (none to convert)\n- Verified no image references (none present in original)\n- Added related document cross-references in frontmatter\n\nLLM CONTEXT BLOCK (Read this first for routing decisions):\nThis document provides comprehensive reverse-engineering documentation for FF7's PC battle\nanimation binary format, originally documented by L. Spiro. It covers the complete data\npipeline from file parsing through skeletal rotation decoding, including bit-stream reading\nalgorithms, delta compression schemes, and C++ implementations with inline assembly. Key\nconcepts include the bKey precision field controlling rotation bit depth, signed magnitude\nencoding for rotation deltas, and the FF7FrameBuffer structure for frame management. This\nis the definitive reference for implementing animation loaders or debugging animation playback.\nCross-reference with FF7_Playstation_Battle_Model_Format.md for PSX format comparison.\n-->\n\n# FF7 Battle Animation Format (PC)\n\n- [FF7 Battle Animation Format (PC)](#ff7-battle-animation-format-pc)\n  - [Overview](#overview)\n  - [1. File Structure](#1-file-structure)\n  - [2. Data Structures](#2-data-structures)\n  - [3. Decoding Algorithms](#3-decoding-algorithms)\n  - [4. Implementation Guide](#4-implementation-guide)\n  - [5. Alternative Implementations](#5-alternative-implementations)\n  - [Appendix A: Quick Reference](#appendix-a-quick-reference)\n  - [Appendix B: Known Issues](#appendix-b-known-issues)\n\n## Overview\n\nThis document describes the Final Fantasy VII battle animation file format for PC, reverse-engineered by **L. Spiro**. Contributions by **Halkun** (wiki conversion) and **Borde** (additional notes).\n\n### What This Document Covers\n\n- Binary file structure for battle animations\n- Data structures for storing skeletal animations\n- Compression algorithms for rotation data\n- Complete C++ implementation with assembly optimizations\n- Theoretical background on the compression scheme\n\n### File Format Basics\n\nBattle animation files contain skeletal animation data for character models. Each file stores:\n- Multiple animations for a single character\n- Per-frame bone rotations and positions\n- Compressed delta encoding for subsequent frames\n- Special animation markers for scripted events\n\n---\n\n## 1. File Structure\n\n### 1.1 Animation File Layout\n\nBattle animation files begin with a **DWORD** indicating the total number of animations. This count includes both regular animations and special animation markers (non-animation data such as script keys or damage number triggers).\n\n**Example**: Cloud's battle animation file (`rtda`) contains 94 (0x5E) animations.\n\nTo navigate between animations, start reading at offset `0x04` and parse each animation header sequentially.\n\n### 1.2 File Header Format\n\nEach animation begins with a 12-byte header followed by animation data.\n\n---\n\n## 2. Data Structures\n\n### 2.1 FF7FrameHeader\n\n**Purpose**: Main header for each animation in the file.\n\n**Structure** (12 bytes):\n\n```c\ntypedef struct FF7FrameHeader {\n    DWORD       dwBones;        // Bones in model + 1 (weapon animations always 1). Offset: 0x00\n                                // NOTE: Unreliable - use skeleton file bone count instead.\n    DWORD       dwFrames;       // Frame count in this animation. Offset: 0x04\n    DWORD       dwChunkSize;    // Size of animation data in bytes. Offset: 0x08\n} * PFF7FrameHeader;            // Total size: 12 bytes\n```\n\n#### Special Animation Chunks\n\nWhen `dwChunkSize < 11`, this is a special (non-animation) data chunk. Skip it by advancing 8 bytes past the header.\n\n#### Navigation Example\n\nTo skip to animation index `iTarget`:\n\n```c\nFF7FrameHeader  fhHeader;\nDWORD           dwBytesRead;\nfor ( int I = 0; I < iTarget; I++ ) {\n    if ( !ReadFile( hFile,\n        &fhHeader, sizeof( fhHeader ),\n        &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n    }\n    if ( fhHeader.dwChunkSize < 11 ) {  // Special chunk\n        if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==\n        INVALID_SET_FILE_POINTER ) {\n            CloseHandle( hFile );\n            return false;\n        }\n        continue;\n    }\n    // Skip this animation (size = dwChunkSize)\n    if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,\n    FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {\n        CloseHandle( hFile );\n        return false;\n    }\n}\n// Now at the target animation\nif ( !ReadFile( hFile,\n    &fhHeader, sizeof( fhHeader ),\n    &dwBytesRead, NULL ) ) {\n\n    CloseHandle( hFile );\n    return false;\n}\nBYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];\n// pbBuffer now holds animation data including FF7FrameMiniHeader\n```\n\n### 2.2 FF7FrameMiniHeader\n\n**Purpose**: Per-animation metadata embedded at the start of each animation's data chunk.\n\n**Structure** (5 bytes):\n\n```c\ntypedef struct FF7FrameMiniHeader {\n    //SHORT     sBones; // Originally thought to be bone count\n    SHORT       sFrames;// Apparent frame count (may exceed dwFrames). Offset: 0x00\n    SHORT       sSize;  // Size of animation data in bytes. Offset: 0x02\n    BYTE        bKey;   // Precision key for rotation encoding (0, 2, or 4). Offset: 0x04\n} * PFF7FrameMiniHeader;    // Total size: 5 bytes\n```\n\n#### Field Discrepancy Notes\n\n**Field Naming Issue**: The field named `sBones` should probably be `sFrames`, as it appears to hold a frame counter.\n\n**Reliability**: `sFrames` and `dwFrames` rarely match.\n- `dwFrames` is conservativeâ€”guarantees at least that many frames exist\n- `sFrames` sometimes exceeds actual frame count\n- **Determine actual frame count by parsing the entire chunk**\n\n**Known Corruption**: Animation 15 in RSAA (playable frog) lacks the `sFrames` field entirely:\n- `sSize` appears at offset 0x00\n- `bKey` appears at offset 0x02\n- FF7 cannot handle this animation (likely corrupted)\n\n### 2.3 bKey: The Precision Field\n\n**Purpose**: Controls rotation data bit depth and compression level.\n\n#### Valid Values\n\n| bKey Value | Uncompressed Bits | Bit Range | Precision Loss |\n|------------|-------------------|-----------|----------------|\n| 0          | 12                | 0-4095    | None           |\n| 2          | 10                | 0-1023    | Low            |\n| 4          | 8                 | 0-255     | Moderate       |\n\n#### How It Works\n\n1. **Storage**: Rotations stored using `(12 - bKey)` bits\n2. **Decoding**: Shift left by `bKey` to restore 12-bit range\n   - Example: 8-bit value `0xFF` (255) becomes `0xFF0` (4080) after `<< 4`\n3. **Trade-off**: Lower precision reduces file size; acceptable for delta-encoded rotations\n\n**Why Lower Precision Works**: Most skeletal animations change by small increments between frames. Large rotations (e.g., spinning blades on Aero Combatant) are round numbers (90Â°, 180Â°) that lose no meaningful precision even at 8-bit depth.\n\n### 2.4 FF7ShortVec (Rotation Storage)\n\n**Purpose**: Stores one bone's rotation in three numeric forms.\n\n**Structure** (30 bytes):\n\n```c\ntypedef struct FF7ShortVec {\n    SHORT   sX, sY, sZ;     // Signed short versions. Offset: 0x00\n    INT iX, iY, iZ;     // Integer representation (always positive). Offset: 0x06\n    FLOAT   fX, fY, fZ;     // Final float degrees. Offset: 0x12\n} * PFF7ShortRot;           // Total size: 30 bytes\n```\n\n#### Three-Form Conversion\n\nRotations are processed through three representations:\n\n1. **SHORT** (signed 16-bit): Raw value from file, range 0-4095 (0Â° to 360Â°)\n2. **INT** (unsigned 32-bit): Absolute value with wrapping\n   - If `SHORT < 0`, add `0x1000` (4096)\n3. **FLOAT**: Final degrees using formula: `(INT / 4096) * 360`\n\n#### Per-Frame Processing Sequence\n\n**First Frame**:\n1. Read X bits (determined by `bKey`) and store as signed SHORT\n2. Convert SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Subsequent Frames**:\n1. Read delta value, add to previous frame's SHORT\n2. Convert updated SHORT to INT (add 0x1000 if negative)\n3. Convert INT to FLOAT: `(INT / 4096 * 360)`\n4. Apply FLOAT rotation to model\n\n**Root Rotation**: The first rotation is always `(0, 0, 0)` and is not part of the skeleton network. Some animations store non-zero values here for dynamic targeting during battle.\n\n### 2.5 FF7FrameBuffer (Frame Management)\n\n**Purpose**: Allocates memory for one frame's worth of bone rotations.\n\n**Structure**:\n\n```cpp\ntypedef struct FF7FrameBuffer {\n    DWORD           dwBones;\n    FF7ShortVec     svPosOffset;\n    FF7ShortVec     *psvRots;\n\n    FF7FrameBuffer() {\n        dwBones = 0;\n        psvRots = NULL;\n    }\n    ~FF7FrameBuffer() {\n        dwBones = 0;\n        delete [] psvRots;\n        psvRots = NULL;\n    }\n\n    VOID    SetBones( DWORD dwTotal ) {\n        // Delete the old\n        dwBones = 0;\n        delete [] psvRots;\n\n        // Create the new\n        psvRots = new FF7ShortVec[dwTotal];\n        if ( psvRots != NULL ) { dwBones = dwTotal; }\n    }\n} * PFF7FrameBuffer;\n```\n\n**Usage**: Call `FF7FrameBuffer.SetBones(boneCount)` with your animation's bone count to allocate rotation storage.\n\n---\n\n## 3. Decoding Algorithms\n\n### 3.1 Bit Stream Reading\n\n#### GetBitsFixed Function\n\n**Purpose**: Reads arbitrary bit sequences from a byte buffer.\n\n**Parameters**:\n- `pbBuffer`: Byte array containing bit stream\n- `dwStartBit`: Bit offset to start reading (modified in place)\n- `dwTotalBits`: Number of bits to read\n\n**Returns**: Signed integer with sign extension.\n\n**Implementation**:\n\n```c\nINT GetBitsFixed( BYTE * pbBuffer, DWORD &dwStartBit,\nDWORD dwTotalBits ) {\n    INT iReturn = 0;\n\n    for ( DWORD I = 0; I < dwTotalBits; I++ ) {\n        iReturn <<= 1;\n\n        __asm mov eax, dwStartBit\n        __asm mov eax, [eax]\n        __asm cdq\n        __asm and edx, 7\n        __asm add eax, edx\n        __asm sar eax, 3\n        __asm mov ecx, pbBuffer\n        __asm xor edx, edx\n        __asm mov dl, byte ptr ds:[ecx+eax]\n        __asm mov eax, dwStartBit\n        __asm mov ecx, [eax]\n        __asm and ecx, 7\n        __asm mov eax, 7\n        __asm sub eax, ecx\n        __asm mov esi, 1\n        __asm mov ecx, eax\n        __asm shl esi, cl\n        __asm and edx, esi\n        __asm test edx, edx\n        __asm je INCBIT\n        iReturn++;\nINCBIT: dwStartBit++;\n    }\n\n    // Force sign bit to extend across 32-bit boundary\n    iReturn <<= (0x20 - dwTotalBits);\n    iReturn >>= (0x20 - dwTotalBits);\n    return iReturn;\n}\n```\n\n### 3.2 First Frame (Uncompressed)\n\nThe first frame stores absolute values with no delta compression.\n\n#### 3.2.1 Position Offsets\n\n**Format**: Always 16 bits per axis (X, Y, Z), stored as signed SHORTs.\n\n**Example** (Cloud's first animation, `rtda`):\n- Bytes: `00 00 FE 2E 00 00`\n- Values: `X=0`, `Y=-466`, `Z=0`\n- Total: 16 bits Ã— 3 = 48 bits = 6 bytes\n\n**Note**: Y-axis is stored inverted but can be ignored during initial parsing.\n\n**Code**:\n\n```c\nPFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;\nBYTE * pbAnimBuffer = &pbBuffer[5];  // Skip 5-byte miniheader\n\nDWORD dwBitStart = 0;\nSHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\nSHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );\n// Result: sX=0, sY=-466, sZ=0\n```\n\n#### 3.2.2 Rotation Data\n\n**Bit Count**: Determined by `bKey` using formula `(12 - bKey)`\n- If `bKey = 0`: 12 bits per rotation\n- If `bKey = 2`: 10 bits per rotation\n- If `bKey = 4`: 8 bits per rotation\n\n**Normalization**: Shift left by `bKey` to restore 12-bit range.\n\n**Code** (for each bone's 3 rotations):\n\n```c\nSHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\nSHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,\n12 - pfmhMiniHeader->bKey );\n\n// Normalize to 12-bit range\nsRotX <<= pfmhMiniHeader->bKey;\nsRotY <<= pfmhMiniHeader->bKey;\nsRotZ <<= pfmhMiniHeader->bKey;\n```\n\n### 3.3 Subsequent Frames (Compressed Delta Encoding)\n\nFrames after the first store delta values (changes from previous frame).\n\n#### 3.3.1 Position Deltas\n\n**Format**: Variable-length encoding (8 or 17 bits)\n\n**Algorithm**:\n1. Read 1 flag bit\n   - If `0`: Next 7 bits are signed delta (total 8 bits)\n   - If `1`: Next 16 bits are signed delta (total 17 bits)\n\n**GetDynamicFrameOffsetBits Function**:\n\n```c\nSHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &dwBitStart ) {\nDWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;\n    SHORT sReturn;\n    __asm {\n        mov eax, dwBitStart\n        mov eax, [eax]\n        cdq\n        and edx, 7\n        add eax, edx\n        sar eax, 3\n        mov dwFirstByte, eax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        and edx, 7\n        mov dwConsumedBits, edx\n        mov eax, 7\n        sub eax, dwConsumedBits\n        mov dwBitsRemainingToNextByte, eax\n        mov ecx, pBuffer\n        add ecx, dwFirstByte\n        xor edx, edx\n        mov dl, byte ptr ds:[ecx]\n        shl edx, 8\n        mov eax, pBuffer\n        add eax, dwFirstByte\n        xor ecx, ecx\n        mov cl, byte ptr ds:[eax+1]\n        or edx, ecx\n        mov dwTemp, edx\n        mov ecx, dwBitsRemainingToNextByte\n        add ecx, 8\n        mov edx, 1\n        shl edx, cl\n        mov eax, dwTemp\n        and eax, edx\n        test eax, eax\n        jnz SeventeenBits\n\nEightBits :\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        movsx eax, dx\n        sar eax, 9\n        mov sReturn, ax\n        mov ecx, dwBitStart\n        mov edx, [ecx]\n        add edx, 8\n        mov eax, dwBitStart\n        mov [eax], edx      // Increase dwBitStart by 8\n        jmp End\n\nSeventeenBits :\n        mov ecx, dwTemp\n        shl ecx, 8\n        mov edx, pBuffer\n        add edx, dwFirstByte\n        xor eax, eax\n        mov al, byte ptr ds:[edx+2]\n        or ecx, eax\n        mov dwTemp, ecx\n        mov ecx, dwConsumedBits\n        add ecx, 1\n        mov edx, dwTemp\n        shl edx, cl\n        shr edx, 8\n        mov sReturn, dx\n        mov eax, dwBitStart\n        mov ecx, [eax]\n        add ecx, 0x11\n        mov edx, dwBitStart\n        mov [edx], ecx      // Increase dwBitStart by 17\n\nEnd :\n    }\n    return sReturn;\n}\n```\n\n**Usage**:\n\n```c\nSHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\nSHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );\n\n// Add deltas to previous frame\nFF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sDeltaX;\nFF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sDeltaY;\nFF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sDeltaZ;\n```\n\n#### 3.3.2 Rotation Deltas\n\n**Format**: Complex variable-length encoding optimized for small deltas.\n\n**Algorithm Overview**:\n1. Read 1 flag bit:\n   - If `0`: Delta is zero, done\n   - If `1`: Continue to step 2\n2. Read 3-bit type field (values 0-7)\n3. Decode based on type:\n   - **Type 0**: Minimum decrement `(-1 << bKey)`\n   - **Types 1-6**: Read N bits, apply signed magnitude transform\n   - **Type 7**: Uncompressed value `(12 - bKey)` bits\n\n**Signed Magnitude Transform** (Types 1-6):\n\nIf the N-bit value is negative:\n- Subtract `(1 << (N - 1))`\n\nIf positive:\n- Add `(1 << (N - 1))`\n\nFinally, shift left by `bKey` to adjust for precision.\n\n**Example** (Type 4, meaning 4 bits):\n- Read 4-bit value (e.g., binary `1011` = -5 in signed form)\n- Since negative: subtract `(1 << 3)` = 8 â†’ `-5 - 8 = -13`\n- Shift left by `bKey` (e.g., if `bKey=2`): `-13 << 2 = -52`\n\n**GetEncryptedRotationBits Function**:\n\n```c\nSHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &dwBitStart,\nINT iKeyBits ) {\n    DWORD dwNumBits, dwType;\n    INT iTemp;\n    SHORT sReturn;\n    // Check the first bit\n    INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );\n    __asm mov eax, iBits\n    __asm test eax, eax\n    __asm jnz SecondTest\n    __asm jmp ReturnZero    // Return 0\n\nSecondTest :\n    // Get next 3 bits\n    iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );\n    __asm mov eax, iBits\n    __asm and eax, 7\n    __asm mov dwNumBits, eax\n    __asm mov ecx, dwNumBits\n    __asm mov dwType, ecx\n    __asm cmp dwType, 7\n    __asm ja ReturnZero\n\n    // Switch on type\n    switch ( dwType ) {\n        case 0 : {\n            __asm or eax, 0xFFFFFFFF    // EAX = -1\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl           // (-1 << iKeyBits)\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n        case 1 : {}\n        case 2 : {}\n        case 3 : {}\n        case 4 : {}\n        case 5 : {}\n        case 6 : {\n            // Read N bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                dwNumBits );\n            __asm mov eax, iTemp\n            __asm cmp iTemp, 0\n            __asm jl IfLessThanZero\n            // If >= 0: add (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov eax, 1\n            __asm shl eax, cl\n            __asm mov ecx, iTemp\n            __asm add ecx, eax\n            __asm mov iTemp, ecx\n            __asm jmp AfterTests\nIfLessThanZero :\n            // If < 0: subtract (1 << (dwNumBits - 1))\n            __asm mov ecx, dwNumBits\n            __asm sub ecx, 1\n            __asm mov edx, 1\n            __asm shl edx, cl\n            __asm mov eax, iTemp\n            __asm sub eax, edx\n            __asm mov iTemp, eax\n\nAfterTests :\n            // Shift by precision\n            __asm mov eax, iTemp\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n        case 7 : {\n            // Uncompressed: read (12 - iKeyBits) bits\n            iTemp = GetBitsFixed( pBuffer, dwBitStart,\n                12 - iKeyBits );\n            __asm mov ecx, iKeyBits\n            __asm shl eax, cl\n            __asm mov sReturn, ax\n            __asm jmp End\n        }\n\n    }\n\n\nReturnZero :\n    __asm xor ax, ax\n    __asm mov sReturn, ax\n\nEnd :\n\n    return sReturn;\n}\n```\n\n---\n\n## 4. Implementation Guide\n\n### 4.1 LoadFrames Function\n\n**Purpose**: Load an entire frame (position + all bone rotations) at once.\n\n**Returns**: Bit offset where next frame begins (or 0 if no more frames).\n\n**Parameters**:\n- `pfbFrameBuffer`: Pointer to frame buffer to fill\n- `iBones`: Number of bones in skeleton\n- `iBitStart`: Bit offset to start reading (0 for first frame)\n- `pbAnimBuffer`: Byte array containing animation data\n\n**Implementation**:\n\n```c\nDWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,\nINT iBones,\nINT iBitStart,\nBYTE * pbAnimBuffer ) {\n    // Get backups of parameters\nDWORD       dwThisBitStart  = iBitStart;\n    INT     iThisBones      = iBones;\n    BYTE *  pbThisBuffer    = pbAnimBuffer;\n\n    PFF7FrameMiniHeader pfmhMiniHeader =\n        (PFF7FrameMiniHeader)pbAnimBuffer;\n    SHORT   sSize = pfmhMiniHeader->sSize;\n    BYTE    bKeyBits = pfmhMiniHeader->bKey;\n\n    // Skip 5-byte miniheader\n    pbThisBuffer += sizeof( FF7FrameMiniHeader );\n\n    if ( iBitStart == 0 ) { // First frame?\n        // Uncompressed position offsets\n        pfbFrameBuffer->svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n        pfbFrameBuffer->svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );\n\n        // Convert to FLOAT\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Read rotations (12 - bKeyBits) bits each\n            pfbFrameBuffer->psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n            pfbFrameBuffer->psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) << bKeyBits);\n\n            // Convert SHORT to INT (absolute value)\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n    else {                  // Subsequent frames\n        SHORT sX, sY, sZ;\n\n        // Get position deltas\n        sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n        sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );\n\n        // Add deltas to previous frame\n        pfbFrameBuffer->svPosOffset.sX += sX;\n        pfbFrameBuffer->svPosOffset.sY += sY;\n        pfbFrameBuffer->svPosOffset.sZ += sZ;\n\n        pfbFrameBuffer->svPosOffset.fX = (FLOAT)pfbFrameBuffer->svPosOffset.sX;\n        pfbFrameBuffer->svPosOffset.fY = (FLOAT)pfbFrameBuffer->svPosOffset.sY;\n        pfbFrameBuffer->svPosOffset.fZ = (FLOAT)pfbFrameBuffer->svPosOffset.sZ;\n\n        for ( int I = 0; I < iThisBones; I++ ) {\n            // Get rotation deltas\n            sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n            sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );\n\n            // Add deltas\n            pfbFrameBuffer->psvRots[I].sX += sX;\n            pfbFrameBuffer->psvRots[I].sY += sY;\n            pfbFrameBuffer->psvRots[I].sZ += sZ;\n\n            // Note: Values can exceed 4095 through accumulation of positive deltas\n\n            // Convert to INT\n            pfbFrameBuffer->psvRots[I].iX = (pfbFrameBuffer->psvRots[I].sX < 0) ? pfbFrameBuffer->psvRots[I].sX + 0x1000 : pfbFrameBuffer->psvRots[I].sX;\n            pfbFrameBuffer->psvRots[I].iY = (pfbFrameBuffer->psvRots[I].sY < 0) ? pfbFrameBuffer->psvRots[I].sY + 0x1000 : pfbFrameBuffer->psvRots[I].sY;\n            pfbFrameBuffer->psvRots[I].iZ = (pfbFrameBuffer->psvRots[I].sZ < 0) ? pfbFrameBuffer->psvRots[I].sZ + 0x1000 : pfbFrameBuffer->psvRots[I].sZ;\n        }\n    }\n\n    // Return next frame's bit offset (or 0 if done)\n    if ( (SHORT)(dwThisBitStart / 8) < sSize ) {\nreturn dwThisBitStart;\n}\n    return 0;\n}\n```\n\n### 4.2 Complete Animation Loading Loop\n\n**Example**: Load all frames in an animation.\n\n```c\nFF7FrameHeader fhHeader;\nReadFile( hFile, &fhHeader, sizeof( fhHeader ), &ulBytesRead,\nNULL );\nBYTE * baData = new BYTE[fhHeader.dwChunkSize];\nReadFile( hFile, &baData, fhHeader.dwChunkSize, &ulBytesRead,\nNULL );\n\n    // Allocate frame buffer\nFF7FrameBuffer fbFrameBuffer;\nfbFrameBuffer.SetBones( fhHeader.dwBones );\nINT iBits = 0;\n\nfor ( DWORD J = 0; J < fhHeader.dwFrames; J++ ) {\n    // Load frame\n    iBits = LoadFrames( &fbFrameBuffer, fhHeader.dwBones, iBits, baData );\n\n    // Reverse Y offset (required)\n    fbFrameBuffer.svPosOffset.fY = 0.0f - fbFrameBuffer.svPosOffset.fY;\n\n    // Convert INT rotations to FLOAT degrees\n    // Note: First rotation (root) is typically 0,0,0 but some animations\n    // store a base rotation for dynamic targeting\n    for ( DWORD I = 0; I < fhHeader.dwBones - 1; I++ ) {\n        fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;\n        fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;\n    }\n\n    // Store frame data here (application-specific)\n}\n\ndelete [] baData;\n```\n\n---\n\n## 5. Alternative Implementations\n\n### 5.1 Qhimm's C++ Versions\n\n**Qhimm** rewrote the assembly functions in pure C++ for better readability. He also provided theoretical background on the compression scheme.\n\n#### GetValueFromStream\n\nReplaces `GetDynamicFrameOffsetBits` with clearer C++ implementation.\n\n```cpp\nshort GetValueFromStream( BYTE *pStreamBytes,\nDWORD *pdwStreamBitOffset )\n{\n    short sValue;\n    DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;\n    DWORD dwCurrentBitsEaten = *pdwStreamBitOffset % 8;\n    DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;\n    DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] << 8 | pStreamBytes[dwStreamByteOffset + 1];\n\n    // Test first bit to determine value size\n    if (dwNextStreamBytes & (1 << (dwTypeBitShift + 8)))\n    {   // 16-bit value\n        dwNextStreamBytes = dwNextStreamBytes << 8 |\n            pStreamBytes[dwStreamByteOffset + 2];\n        sValue = (dwNextStreamBytes << (dwCurrentBitsEaten + 1)) >> 8;\n        *pdwStreamBitOffset += 17;\n    }\n    else\n    {   // 7-bit value\n        sValue = ((short)(dwNextStreamBytes << (dwCurrentBitsEaten + 1))) >> 9;\n        *pdwStreamBitOffset += 8;\n    }\n\n    return sValue;\n}\n```\n\n#### GetCompressedDeltaFromStream\n\nReplaces `GetEncryptedRotationBits` with clearer C++ implementation.\n\n```cpp\nshort GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,\nint nLoweredPrecisionBits )\n{\n    unsigned int nBits;\n    int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );\n    if (iFirstBit)\n    {\n        unsigned int uType = GetBitsFromStream( pStreamBytes,\n            pdwStreamBitOffset, 3 ) & 7;\n        switch (uType)\n        {\n        case 0:\n            // Minimum decrement\n            return (-1 << nLoweredPrecisionBits);\n\n        case 1: case 2: case 3: case 4: case 5: case 6:\n            // Read N bits\n            int iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, nBits );\n            // Apply signed magnitude transform\n            if (iTemp < 0)  iTemp -= 1 << (nBits - 1);\n            else            iTemp += 1 << (nBits - 1);\n            // Adjust for precision\n            return (iTemp << nLoweredPrecisionBits);\n\n        case 7:\n            // Uncompressed\n            iTemp = GetBitsFromStream( pStreamBytes,\n                pdwStreamBitOffset, 12 - nLoweredPrecisionBits );\n            return (iTemp << nLoweredPrecisionBits);\n        default:\n        }\n    }\n    return 0;\n}\n```\n\n### 5.2 Rotation Compression Theory\n\n*Notes by Qhimm*\n\n#### Why This Encoding Is Efficient\n\nRotational deltas in skeletal animation are typically small. The compression scheme allocates fewer bits to small deltas and more bits to large changes.\n\n**Bit Allocation**:\n- Zero delta: 1 bit (`0`)\n- Minimum decrement: 4 bits (`1 000`)\n- Small deltas (1-6 bits): 126 possible values\n- Large deltas: Uncompressed form\n\n**Total Coverage**: 128 delta values in the range `[-64, 63]` can be stored in compressed form. This is efficient because most rotational changes in character animation are incremental.\n\n#### Signed Magnitude Encoding\n\nFor delta types 1-6, the encoding uses signed magnitude to pack values efficiently:\n\n1. **Magnitude**: Value of most significant value bit\n   - Example: Values `1` and `-2` both have magnitude `1`\n   - Value `30` has magnitude `32`\n\n2. **Signed Magnitude**: Magnitude Ã— sign of value\n   - Example: `-2` has signed magnitude `-1`\n\n3. **Encoding**: Subtract signed magnitude before storing\n   - Pushes values toward zero\n   - Ensures all transformed values fit in 6 bits or fewer\n\n4. **Decoding**: Add back the signed magnitude\n   - Magnitude determined by number of bits read\n   - Sign determined by MSB of encoded value\n\n#### Encoding Examples\n\n| Delta Value | Encoded Bits        | Notes                                    |\n|-------------|---------------------|------------------------------------------|\n| 0           | `0`                 | Single zero bit                          |\n| -1          | `1 000`             | Type 0 (minimum decrement)               |\n| -5          | `1 011 111`         | Type 3 (3 bits)                          |\n| 15          | `1 100 0111`        | Type 4 (4 bits)                          |\n| 128         | `1 111 xxxx10000000`| Type 7 (depends on precision)            |\n\n*(Values shown in current precision as integers)*\n\n#### Precision Trade-offs\n\nPrecision can be reduced by 2 or 4 bits (from 12 bits down to 10 or 8):\n\n**Advantages**:\n- Smaller raw values\n- Increased relative span of compressed encodings\n- Much smaller file sizes\n\n**Disadvantages**:\n- Quantization error\n- Less precise rotations\n\n**When It Works Well**: Most skeletal animations change gradually. Large rotations (spinning objects) are typically round numbers (90Â°, 180Â°, 270Â°) that lose negligible precision even at 8-bit depth.\n\n**Note**: Reduced precision is treated as rounding toward negative infinity.\n\n---\n\n## Appendix A: Quick Reference\n\n### Structure Sizes\n\n| Structure          | Size (bytes) | Offset Fields                              |\n|--------------------|--------------|--------------------------------------------|\n| FF7FrameHeader     | 12           | dwBones: 0x00, dwFrames: 0x04, dwChunkSize: 0x08 |\n| FF7FrameMiniHeader | 5            | sFrames: 0x00, sSize: 0x02, bKey: 0x04     |\n| FF7ShortVec        | 30           | SHORT: 0x00, INT: 0x06, FLOAT: 0x12        |\n\n### bKey Values\n\n| bKey | Uncompressed Bits | Formula         | Range   |\n|------|-------------------|-----------------|---------|\n| 0    | 12                | `12 - 0 = 12`   | 0-4095  |\n| 2    | 10                | `12 - 2 = 10`   | 0-1023  |\n| 4    | 8                 | `12 - 4 = 8`    | 0-255   |\n\n### Conversion Formulas\n\n**SHORT to Degrees**:\n```text\ndegrees = (SHORT / 4096) * 360\n```\n\n**SHORT to INT (with wrapping)**:\n```text\nINT = (SHORT < 0) ? SHORT + 0x1000 : SHORT\n```\n\n**INT to FLOAT**:\n```text\nFLOAT = (INT / 4096.0f) * 360.0f\n```\n\n### Position Delta Encoding\n\n| First Bit | Total Bits | Format     |\n|-----------|------------|------------|\n| 0         | 8          | 7-bit delta|\n| 1         | 17         | 16-bit delta|\n\n### Rotation Delta Type Field\n\n| Type | Bits to Read        | Meaning                        |\n|------|---------------------|--------------------------------|\n| 0    | 0                   | Minimum decrement: `(-1 << bKey)` |\n| 1-6  | N (= type value)    | Signed magnitude encoded delta |\n| 7    | `12 - bKey`         | Uncompressed rotation value    |\n\n---\n\n## Appendix B: Known Issues\n\n### Corrupted Animations\n\n**RSAA Animation 15** (playable frog):\n- Missing `sFrames` field\n- `sSize` appears at offset 0x00 instead of 0x02\n- `bKey` appears at offset 0x02 instead of 0x04\n- FF7 cannot load this animation (likely damaged in original game data)\n\n### Frame Count Discrepancies\n\n**sFrames vs. dwFrames**:\n- Rarely match in practice\n- `dwFrames` is more conservative (guarantees minimum)\n- `sFrames` sometimes exceeds actual frame count\n- **Solution**: Parse entire chunk to determine true frame count\n\n**Possible Causes**:\n- Dummy frames padded for memory alignment\n- Special-purpose data interleaved with frames\n- Animation authoring tool artifacts\n\n### Root Rotation Behavior\n\n**Standard Behavior**: First rotation is always `(0, 0, 0)` and not part of skeleton.\n\n**Exception**: Some animations store non-zero root rotations for dynamic targeting:\n- Model facing toward attack target\n- Model rotating during special moves\n\n**Recommendation**: Do not skip root rotation unconditionally. Check if non-zero before using for targeting logic.\n\n---\n\n**End of Document**\n"}},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FrHUwUbrGguvW2N2Kdhaes","type":"message","role":"assistant","content":[{"type":"text","text":"The file has been written. Now let me count the lines and code blocks to produce the complete summary report:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":26653,"cache_read_input_tokens":98399,"cache_creation":{"ephemeral_5m_input_tokens":26653,"ephemeral_1h_input_tokens":0},"output_tokens":438,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"65914cc5-47ef-40e8-ae1b-139d4d8b4dc2"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FrHUwUbrGguvW2N2Kdhaes","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JyRXFRscGWtM8Qv5yPPoTZ","name":"Bash","input":{"command":"wc -l /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md && wc -l /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/markdown/merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md","description":"Count lines in both files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":26653,"cache_read_input_tokens":98399,"cache_creation":{"ephemeral_5m_input_tokens":26653,"ephemeral_1h_input_tokens":0},"output_tokens":438,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"6ba27c10-fb97-4e44-b3b2-0088559078c3"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FrHUwUbrGguvW2N2Kdhaes","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WniDis5DCKx3ayypbrVJ3J","name":"Grep","input":{"pattern":"^```","path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md","output_mode":"count"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":26653,"cache_read_input_tokens":98399,"cache_creation":{"ephemeral_5m_input_tokens":26653,"ephemeral_1h_input_tokens":0},"output_tokens":438,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"0378a524-d289-4b73-984b-7c460ce4a109"},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FrHUwUbrGguvW2N2Kdhaes","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kn8PEHDqassqbUZPjSzPsd","name":"Grep","input":{"pattern":"^\\|","path":"/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md","output_mode":"count"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":26653,"cache_read_input_tokens":98399,"cache_creation":{"ephemeral_5m_input_tokens":26653,"ephemeral_1h_input_tokens":0},"output_tokens":438,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"088ca2c1-c1aa-4261-97ca-71904c9e9294"},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kn8PEHDqassqbUZPjSzPsd","type":"tool_result","content":"31\n\nFound 0 total occurrences across 0 files."}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"ce416e19-ce46-455d-947b-b40fddecccf1","tool_use_result":{"mode":"count","numFiles":0,"filenames":[],"content":"31","numMatches":0}},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WniDis5DCKx3ayypbrVJ3J","type":"tool_result","content":"36\n\nFound 0 total occurrences across 0 files."}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"c14e7266-33b5-4b90-9e5f-2a4e5323f90c","tool_use_result":{"mode":"count","numFiles":0,"filenames":[],"content":"36","numMatches":0}},{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JyRXFRscGWtM8Qv5yPPoTZ","type":"tool_result","content":"    1023 /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md\n     976 /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/markdown/merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md","is_error":false}]},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"496b2fd5-4840-47de-8b1e-983a816ab46f","tool_use_result":{"stdout":"    1023 /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md\n     976 /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/markdown/merged_with_pdf_content/FF7_Battle_Battle_Animation_PC.md","stderr":"","interrupted":false,"isImage":false}},{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01G3LhGWuamzrSkXbMS6igvo","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have all the data needed for the summary report. Let me output it:\n\n`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n**Key transformation details for this document:**\n\n1. **YAML frontmatter fix**: The previous attempt had markdown-style comments (`# comment`) inside YAML which would break parsers. YAML comments must be separate lines starting with `#` at the beginning, not inline. The corrected version uses proper YAML key-value pairs.\n\n2. **Heading hierarchy**: This document was already well-structured with proper H1â†’H2â†’H3â†’H4 progression, so no heading changes were needed.\n\n3. **Code block languages**: All 18 code blocks already had proper language tags (`c`, `cpp`, `text`), demonstrating good original documentation quality.\n`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n\n## Agent Summary Report\n\n```json\n{\n  \"filename\": \"FF7_Battle_Battle_Animation_PC.md\",\n  \"module\": \"Battle\",\n  \"line_count\": 1023,\n  \"original_line_count\": 976,\n  \"llm_summary\": \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\",\n  \"primary_topics\": [\n    \"Animation file structure\",\n    \"FF7FrameHeader format\",\n    \"Bit stream decoding\",\n    \"Rotation delta compression\",\n    \"Position offset encoding\"\n  ],\n  \"heading_changes\": \"No heading hierarchy changes required - document already followed correct H1â†’H2â†’H3â†’H4 progression\",\n  \"outbound_links\": [\n    {\n      \"target\": \"FF7_Battle_Battle_Mechanics.md\",\n      \"anchor\": null,\n      \"text\": \"Related document (frontmatter)\",\n      \"line_number\": 13\n    },\n    {\n      \"target\": \"FF7_Battle_Battle_Scenes.md\",\n      \"anchor\": null,\n      \"text\": \"Related document (frontmatter)\",\n      \"line_number\": 13\n    },\n    {\n      \"target\": \"FF7_Playstation_Battle_Model_Format.md\",\n      \"anchor\": null,\n      \"text\": \"Related document (frontmatter)\",\n      \"line_number\": 13\n    }\n  ],\n  \"images_count\": 0,\n  \"images_updated\": [],\n  \"wiki_links_converted\": 0,\n  \"tables_count\": 10,\n  \"code_blocks_count\": 18,\n  \"issues_found\": [\n    \"Previous standardization attempt had malformed YAML frontmatter (markdown comments inside YAML block)\"\n  ],\n  \"processing_notes\": \"Document was already well-structured from previous restructuring (2025-11-29). Main transformation was fixing YAML frontmatter syntax error from earlier standardization attempt, adding proper LLM metadata as separate YAML keys, and updating session ID. All technical content preserved exactly. Heading hierarchy and code block language tags were already correct.\"\n}\n```\n\n---\n\n## Transformation Complete\n\n**File written to**: `/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md`\n\n### Verification Checklist\n\n- [x] YAML frontmatter complete with all required fields (proper syntax)\n- [x] HTML metadata block preserves original merge metadata + documents changes\n- [x] LLM summary is 1-2 sentences, concrete and actionable\n- [x] Heading hierarchy is H1â†’H2â†’H3â†’H4 (no skips) - **already correct**\n- [x] All cross-document links use standard markdown (in frontmatter `llm_related_docs`)\n- [x] All images use `../images/` path - **N/A (no images in document)**\n- [x] All code blocks have language tags - **already correct** (18 blocks: `c`, `cpp`, `text`)\n- [x] All technical content preserved exactly\n- [x] Agent summary report JSON is complete"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":84,"cache_creation_input_tokens":679,"cache_read_input_tokens":125052,"cache_creation":{"ephemeral_5m_input_tokens":679,"ephemeral_1h_input_tokens":0},"output_tokens":1002,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","uuid":"2ecb55ec-6e4d-47d3-b257-f0dd9b832c3b"},{"type":"result","subtype":"success","is_error":false,"duration_ms":259017,"duration_api_ms":271446,"num_turns":11,"result":"Now I have all the data needed for the summary report. Let me output it:\n\n`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n**Key transformation details for this document:**\n\n1. **YAML frontmatter fix**: The previous attempt had markdown-style comments (`# comment`) inside YAML which would break parsers. YAML comments must be separate lines starting with `#` at the beginning, not inline. The corrected version uses proper YAML key-value pairs.\n\n2. **Heading hierarchy**: This document was already well-structured with proper H1â†’H2â†’H3â†’H4 progression, so no heading changes were needed.\n\n3. **Code block languages**: All 18 code blocks already had proper language tags (`c`, `cpp`, `text`), demonstrating good original documentation quality.\n`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n\n## Agent Summary Report\n\n```json\n{\n  \"filename\": \"FF7_Battle_Battle_Animation_PC.md\",\n  \"module\": \"Battle\",\n  \"line_count\": 1023,\n  \"original_line_count\": 976,\n  \"llm_summary\": \"Specifies PC battle animation binary format including skeletal data structures, delta compression algorithms, and C++ decoding implementations. LLMs should read this when parsing animation files, implementing animation loaders, or debugging rotation/position data issues.\",\n  \"primary_topics\": [\n    \"Animation file structure\",\n    \"FF7FrameHeader format\",\n    \"Bit stream decoding\",\n    \"Rotation delta compression\",\n    \"Position offset encoding\"\n  ],\n  \"heading_changes\": \"No heading hierarchy changes required - document already followed correct H1â†’H2â†’H3â†’H4 progression\",\n  \"outbound_links\": [\n    {\n      \"target\": \"FF7_Battle_Battle_Mechanics.md\",\n      \"anchor\": null,\n      \"text\": \"Related document (frontmatter)\",\n      \"line_number\": 13\n    },\n    {\n      \"target\": \"FF7_Battle_Battle_Scenes.md\",\n      \"anchor\": null,\n      \"text\": \"Related document (frontmatter)\",\n      \"line_number\": 13\n    },\n    {\n      \"target\": \"FF7_Playstation_Battle_Model_Format.md\",\n      \"anchor\": null,\n      \"text\": \"Related document (frontmatter)\",\n      \"line_number\": 13\n    }\n  ],\n  \"images_count\": 0,\n  \"images_updated\": [],\n  \"wiki_links_converted\": 0,\n  \"tables_count\": 10,\n  \"code_blocks_count\": 18,\n  \"issues_found\": [\n    \"Previous standardization attempt had malformed YAML frontmatter (markdown comments inside YAML block)\"\n  ],\n  \"processing_notes\": \"Document was already well-structured from previous restructuring (2025-11-29). Main transformation was fixing YAML frontmatter syntax error from earlier standardization attempt, adding proper LLM metadata as separate YAML keys, and updating session ID. All technical content preserved exactly. Heading hierarchy and code block language tags were already correct.\"\n}\n```\n\n---\n\n## Transformation Complete\n\n**File written to**: `/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/game_engine/final/FF7_Battle_Battle_Animation_PC.md`\n\n### Verification Checklist\n\n- [x] YAML frontmatter complete with all required fields (proper syntax)\n- [x] HTML metadata block preserves original merge metadata + documents changes\n- [x] LLM summary is 1-2 sentences, concrete and actionable\n- [x] Heading hierarchy is H1â†’H2â†’H3â†’H4 (no skips) - **already correct**\n- [x] All cross-document links use standard markdown (in frontmatter `llm_related_docs`)\n- [x] All images use `../images/` path - **N/A (no images in document)**\n- [x] All code blocks have language tags - **already correct** (18 blocks: `c`, `cpp`, `text`)\n- [x] All technical content preserved exactly\n- [x] Agent summary report JSON is complete","session_id":"ac761b5c-caa9-462d-b02f-aa1c394201b8","total_cost_usd":1.5495009999999998,"usage":{"input_tokens":86,"cache_creation_input_tokens":125731,"cache_read_input_tokens":614051,"output_tokens":14073,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":125731}},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":1004,"outputTokens":288,"cacheReadInputTokens":0,"cacheCreationInputTokens":19363,"webSearchRequests":0,"costUSD":0.026647749999999994,"contextWindow":200000},"claude-sonnet-4-5-20250929":{"inputTokens":3,"outputTokens":295,"cacheReadInputTokens":0,"cacheCreationInputTokens":19552,"webSearchRequests":0,"costUSD":0.07775399999999999,"contextWindow":200000},"claude-opus-4-5-20251101":{"inputTokens":86,"outputTokens":14073,"cacheReadInputTokens":614051,"cacheCreationInputTokens":125731,"webSearchRequests":0,"costUSD":1.44509925,"contextWindow":200000}},"permission_denials":[],"uuid":"7c4273d1-320c-4d4d-8283-287ceb2ef011"}]
