This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .github/**, .vcpkg/versions/**, .vcpkg/ports/**, misc/hext/**/es/**, misc/hext/**/fr/**, src/ff8/**, src/ff8_data.cpp, src/ff8_opengl.cpp, src/ff8.h, src/ff8_data.h, misc/FFNx.vibrate.ff8.*.toml, misc/FF8.reg, docs/ff8/**, Changelog.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
choco/
  main.cpp
docs/
  mods/
    audio_engine.md
    devtools.md
    direct_mode.md
    exe_data.md
    external_textures.md
    video_encoding_guide.md
  faq.md
  how_to_install.md
  readme.md
  shortcuts.md
misc/
  hext/
    ff7/
      de/
        FFNx._GLOBALS.txt
        FFNx.BATTLE.fullscreen.txt
        FFNx.BATTLE.restore_modals.txt
        FFNx.BATTLE.transparent_modals.txt
        FFNx.FIELD.transparent_modals.txt
        FFNx.MENU.cursor_vertical_center.txt
      en/
        FFNx._GLOBALS.txt
        FFNx.BATTLE.fullscreen.txt
        FFNx.BATTLE.restore_modals.txt
        FFNx.BATTLE.transparent_modals.txt
        FFNx.FIELD.transparent_modals.txt
        FFNx.MENU.cursor_vertical_center.txt
  FFNx-Choco.def
  FFNx.ambient.toml
  FFNx.blit.frag
  FFNx.blit.vert
  FFNx.common.sh
  FFNx.def
  FFNx.field.shadow.frag
  FFNx.field.shadow.vert
  FFNx.frag
  FFNx.lighting.frag
  FFNx.lighting.sh
  FFNx.lighting.toml
  FFNx.lighting.vert
  FFNx.music.toml
  FFNx.overlay.frag
  FFNx.overlay.vert
  FFNx.pcf.sh
  FFNx.post.frag
  FFNx.post.vert
  FFNx.SFX.toml
  FFNx.shadowmap.frag
  FFNx.shadowmap.vert
  FFNx.time.toml
  FFNx.toml
  FFNx.varying.flat.def.sc
  FFNx.varying.smooth.def.sc
  FFNx.vert
  FFNx.voice.toml
  version.rc.in
src/
  audio/
    memorystream/
      memorystream.cpp
      memorystream.h
    openpsf/
      openpsf.cpp
      openpsf.h
    vgmstream/
      vgmstream.cpp
      vgmstream.h
  ff7/
    battle/
      animations.cpp
      animations.h
      battle.cpp
      camera.cpp
      camera.h
      defs.h
      effect.cpp
      effect.h
      menu.cpp
      menu.h
    field/
      background.cpp
      background.h
      camera.cpp
      camera.h
      defs.h
      enter.h
      field.cpp
      model.cpp
      model.h
      opcode.cpp
      opcode.h
      utils.h
    world/
      camera.cpp
      camera.h
      defs.h
      player.cpp
      renderer.cpp
      renderer.h
      utils.h
      world.cpp
      world.h
    defs.h
    dsound.cpp
    file.cpp
    graphics.cpp
    kernel.cpp
    loaders.cpp
    menu.cpp
    minigames.cpp
    misc.cpp
    time.cpp
    time.h
    widescreen.cpp
    widescreen.h
  gl/
    deferred.cpp
    gl.cpp
    special_case.cpp
    texture.cpp
  image/
    image.cpp
    image.h
    tim.cpp
    tim.h
  imgui_club/
    imgui_memory_editor.h
  video/
    movies.cpp
    movies.h
  achievement.cpp
  achievement.h
  api.cpp
  api.h
  audio.cpp
  audio.h
  cfg.cpp
  cfg.h
  common_imports.h
  common.cpp
  common.h
  crashdump.cpp
  crashdump.h
  exe_data.cpp
  exe_data.h
  external_mesh.cpp
  external_mesh.h
  externals_102_de.h
  externals_102_fr.h
  externals_102_sp.h
  externals_102_us.h
  fake_dd.cpp
  fake_dd.h
  ff7_data.h
  ff7_opengl.cpp
  ff7.h
  field.cpp
  field.h
  game_cfg.cpp
  game_cfg.h
  gamehacks.cpp
  gamehacks.h
  gamepad.cpp
  gamepad.h
  gl.h
  globals.h
  hext.cpp
  hext.h
  input.cpp
  input.h
  joystick.cpp
  joystick.h
  lighting_debug.cpp
  lighting_debug.h
  lighting.cpp
  lighting.h
  log.cpp
  log.h
  macro.h
  matrix.cpp
  matrix.h
  metadata.cpp
  metadata.h
  movies.cpp
  movies.h
  music.cpp
  music.h
  overlay.cpp
  overlay.h
  patch.cpp
  patch.h
  redirect.cpp
  redirect.h
  renderer.cpp
  renderer.h
  saveload.cpp
  saveload.h
  sfx.cpp
  sfx.h
  utils.cpp
  utils.h
  vibration.cpp
  vibration.h
  voice.cpp
  voice.h
  widescreen.h
  wine.h
  world.cpp
  world.h
.editorconfig
.gitignore
.gitmodules
.vsconfig
cmake-format.yaml
CMakeLists.txt
CMakePresets.json
COPYING.TXT
README.md
vcpkg-configuration.json
vcpkg.json
```

# Files

## File: choco/main.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2020 Marcin Gomulak                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <windows.h>
#include <Shlwapi.h>
#include <ShlObj_core.h>

void get_userdata_path(PCHAR buffer, size_t bufSize, bool isSavegameFile)
{
	PWSTR outPath = NULL;

	HRESULT hr = SHGetKnownFolderPath(FOLDERID_Documents, KF_FLAG_DEFAULT, NULL, &outPath);

	if (SUCCEEDED(hr))
	{
		wcstombs(buffer, outPath, bufSize);

		CoTaskMemFree(outPath);
		PathAppendA(buffer, R"(Square Enix\FINAL FANTASY VIII Steam)");

		if (isSavegameFile)
		{
      // Search for the first "user_" match in the game path
      CHAR searchPath[MAX_PATH];
      WIN32_FIND_DATA pathFound;
      HANDLE hFind;

      strcpy(searchPath, buffer);
      strcat(searchPath, R"(\user_*)");
      if (hFind = FindFirstFileA(searchPath, &pathFound))
      {
        PathAppendA(buffer, pathFound.cFileName);
        FindClose(hFind);
      }
		}
	}
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  return TRUE;
}

__declspec(dllexport) HANDLE __stdcall dotemuCreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
  HANDLE ret = INVALID_HANDLE_VALUE;

  if (StrStrIA(lpFileName, R"(SAVE\)") != NULL) // SAVE\SLOTX\saveN or save\chocorpg
	{
		CHAR newPath[MAX_PATH]{ 0 };
		CHAR saveFileName[50]{ 0 };

		// Search for the next character pointer after "SAVE\"
		const char* pos = StrStrIA(lpFileName, R"(SAVE\)") + 5;
		strcpy(saveFileName, pos);
		_strlwr(saveFileName);
		char* posSeparator = strstr(saveFileName, R"(\)");
		if (posSeparator != NULL)
		{
			*posSeparator = '_';
		}
		strcat(saveFileName, R"(.ff8)");

		get_userdata_path(newPath, sizeof(newPath), true);
		PathAppendA(newPath, saveFileName);

		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
  else
  {
    ret = CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
  }

  return ret;
}

__declspec(dllexport) HANDLE __stdcall dotemuCreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
{
  return CreateMutexA(lpMutexAttributes, bInitialOwner, lpName);
}
````

## File: docs/mods/audio_engine.md
````markdown
## Audio Engine

The new FFNx Audio Engine is completely configurable by you! Every audio layer can now have its own `config.toml` file, which through it you can customize the Audio Engine behavior when a track is going to be played.

The `config.toml` MUST BE within the relative configured `external_*_path` entry in the [FFNx.toml](misc/FFNx.toml) file.
For example, for the SFX layer on default configuration, the file should be placed in `sfx/config.toml`.

Feel free to check the example configuration included in each FFNx release.

### Audio Engine Layers

The current supported Audio Engine layers are:

- [SFX](misc/FFNx.SFX.toml): in-game audio sound effects ( menu cursor sound, battle sword slash sound, etc. )
- [Music](misc/FFNx.music.toml): in-game audio music ( world theme, field theme, etc. )
- Voice: in-game audio voice acting ( dialog voice acting )
- Ambient: in-game audio atmosphere effects

## Music List

> Courtesy of [myst6re](https://github.com/myst6re)

Following below, you can find a list of file names that you can replace when using the external music layer, depending on the game you target.

Those filenames can be used directly within the relative Music folder and also within the Music TOML configuration file.

### FF7

| File name | Description                                    |
| --------- | ---------------------------------------------- |
| aseri     | Hurry!                                         |
| aseri2    | Hurry Faster!                                  |
| ayasi     | Lurking in the Darkness                        |
| barret    | Barret's Theme                                 |
| bat       | Fighting                                       |
| bee       | Honeybee Manor                                 |
| bokujo    | Farm Boy                                       |
| boo       | Life Stream                                    |
| cannon    | The Makou Cannon Fires                         |
| canyon    | Cosmo Canyon                                   |
| cephiros  | Those Chosen by the Planet                     |
| chase     | Crazy Motorcycle                               |
| chu       | Still More Fighting                            |
| chu2      | J-E-N-O-V-A                                    |
| cinco     | Cinco de Chocobo                               |
| cintro    | Those chosen by the planet (intro)             |
| comical   | Comical (deleted song)                         |
| condor    | Fortress of the Condor                         |
| corel     | Mining Town                                    |
| corneo    | Don of the Slums                               |
| costa     | Costa del Sol                                  |
| crlost    | Tango of Tears                                 |
| crwin     | A Great Success                                |
| date      | Interrupted by Fireworks                       |
| dokubo    | Underneath the Rotting Pizza                   |
| dun2      | Chasing the Black-Caped Man                    |
| earis     | Aerith's Theme                                 |
| earislo   | Flowers Blooming in the Church                 |
| elec      | Electric de Chocobo                            |
| fan2      | Fanfare                                        |
| fanfare   | Fanfare (alternate)                            |
| fiddle    | Fiddle de Chocobo                              |
| fin       | World Crisis                                   |
| geki      | Debut                                          |
| gold1     | Gold Saucer                                    |
| guitar2   | On the Other Side of the Mountain              |
| gun       | ShinRa Army Wages a Full-Scale Attack          |
| hen       | Who Am I                                       |
| hiku      | Highwind Takes to the Skies                    |
| horror    | Trail of Blood                                 |
| iseki     | You Can Hear the Cry of the Planet             |
| jukai     | Forest Temple                                  |
| junon     | Off the Edge of Despair                        |
| jyro      | Steal the Tiny Bronco!                         |
| ketc      | Cait Sith's Theme                              |
| kita      | The Great Northern Cave                        |
| kurai     | Anxious Heart                                  |
| lb1       | The Birth of God                               |
| lb2       | A One-Winged Angel                             |
| ld        | Judgement Day                                  |
| makoro    | Makou Reactor                                  |
| mati      | Ahead on Our Way                               |
| mekyu     | Reunion                                        |
| mogu      | Highwind Takes to the Skies (Moggle version)   |
| mura1     | Parochial Town                                 |
| nointro   | Sephiroth intro                                |
| oa        | Opening - Bombing Mission                      |
| ob        | Bombing Mission                                |
| odds      | Racing Chocobos                                |
| over2     | Continue                                       |
| parade    | Rufus' Welcoming Ceremony                      |
| pj        | Jenova Absolute                                |
| pre       | Prelude                                        |
| red       | Red XIII's Theme                               |
| rhythm    | Turk's Theme                                   |
| riku      | unknown                                        |
| ro        | The Countdown Begins                           |
| rocket    | Oppressed People                               |
| roll      | Staff Roll                                     |
| rukei     | Sandy Badlands                                 |
| sadbar    | Mark of the Traitor                            |
| sadsid    | Sending a Dream Into the Universe              |
| sea       | A Secret, Sleeping in the Deep Sea             |
| seto      | Great Warrior                                  |
| si        | unknown                                        |
| sid2      | Cid's Theme                                    |
| sido      | It's Difficult to Stand on Both Feet, Isn't It |
| siera     | If You Open Your Heart                         |
| sinra     | ShinRa Corporation                             |
| sinraslo  | Infiltrating ShinRa Tower                      |
| snow      | Buried in the Snow                             |
| ta        | FF VII Main Theme                              |
| tb        | FF VII Main Theme (alternate)                  |
| tender    | Holding My Thoughts In My Heart                |
| tifa      | Tifa's Theme                                   |
| tm        | On That Day, 5 Years Ago                       |
| utai      | Wutai                                          |
| vincent   | The Nightmare's Beginning                      |
| walz      | Waltz de Chocobo                               |
| weapon    | Weapon Raid                                    |
| wind      | Wind                                           |
| yado      | Good Night, Until Tomorrow                     |
| yufi      | Descendant of Shinobi                          |
| yufi2     | Stolen Materia                                 |
| yume      | Who Are You                                    |
| heart     |                                                |
| sato      |                                                |
| sensui    |                                                |
| wind      |                                                |

### FF8

| File name    | Description                            |
| ------------ | -------------------------------------- |
| lose         | The Loser                              |
| win          | The Winner                             |
| run          | Never Look Back                        |
| battle       | Don't Be Afraid                        |
| end          | Dead End                               |
| antena       | Starting Up                            |
| waiting      | Intruders                              |
| kani         | Don't Be Afraid (Alternate)            |
| battle2      | Force Your Way                         |
| Parade2      | Fithos Lusec Wecos Vinosec (Variation) |
| fuan2        | Unrest                                 |
| march2       | The Stage Is Set                       |
| joriku       | The Landing                            |
| julia        | Love Grows                             |
| waltz        | Waltz For the Moon                     |
| friend       | Ami                                    |
| dangeon      | Find Your Way                          |
| pianosol     | Julia                                  |
| Parade       | FITHOS LUSEC WECOS VINOSEC             |
| march1       | SeeD                                   |
| himitsu      | Tell Me                                |
| garden       | Balamb Garden                          |
| fuan         | Fear                                   |
| polka2       | Dance with the Balamb-Fish             |
| anthem       | Cactus Jack (Galbadian Anthem)         |
| m7f5         | The Mission                            |
| majo         | Succession of Witches                  |
| field        | Blue Fields                            |
| guitar       | Breezy                                 |
| resistan     | Timber Owls                            |
| kaiso        | Fragments of Memories                  |
| horizon      | Fisherman's Horizon                    |
| master       | Heresy                                 |
| rinoa        | My Mind                                |
| travia       | Where I Belong                         |
| antena2      | Starting Up (Variation)                |
| truth        | Truth                                  |
| jail         | Trust Me                               |
| gargarde     | Galbadia Garden                        |
| timber       | Martial Law                            |
| garbadia     | Under Her Control                      |
| pinch        | Only a Plank Between One and Perdition |
| scene1       | Junction                               |
| pub          | Roses And Wine                         |
| bat3         | The Man With the Machine Gun           |
| stage        | A Sacrifice                            |
| choco        | Odeka ke Chocobo                       |
| white        | Drifting                               |
| majomv       | Wounded                                |
| musho        | Jailed                                 |
| missile      | Retaliation                            |
| enzetu       | The Oath                               |
| card         | Shuffle Or Boogie                      |
| gomon        | Rivals                                 |
| soto         | Blue Sky                               |
| majobat      | Premonition                            |
| Gar3         | Galbadia Garden (Variation)            |
| Bossbat2     | Maybe I'm a Lion                       |
| lasdun       | The Castle                             |
| gafly        | Movin'                                 |
| demo         | Overture                               |
| spy          | The Spy                                |
| mods         | Mods de Chocobo                        |
| salt         | The Salt Flats                         |
| alien        | Residents                              |
| sekichu      | Lunatic Pandora                        |
| esta         | Silence and Motion                     |
| moonmv       | Tears of the Moon                      |
| hikutei      | Ride On                                |
| bossbat1     | The Legendary Beast                    |
| rag1         | Slide Show Part 1                      |
| rag2         | Slide Show Part 2                      |
| lasboss      | The Extreme (no effects)               |
| lasbossintro | The Extreme (intro)                    |
| keisho       | The Successor                          |
| ashuku       | Compression of Time                    |
| joriku2      | The Landing                            |
| combat       |                                        |
| funsui       |                                        |
| ante         |                                        |
| wind         |                                        |
| Flangchorus  |                                        |
| dubchorus    |                                        |
| Solochorus   |                                        |
| Femalechorus |                                        |
| chorus       |                                        |
| reet         |                                        |
| soyo         |                                        |
| rouka        |                                        |
| night        |                                        |
| sea          |                                        |
| train        |                                        |
| mdmotor      |                                        |
| laswhite     |                                        |
| lasbl        |                                        |
````

## File: docs/mods/devtools.md
````markdown
# DevTools

If you're a modder and you want to test some of your changes faster than usually playing the game, this section may be of your interest.

FFNx brings a whole new game changer tooling that will allow you to explore more of the game engine, while playing everytime you prefer.

In order to use it, you must enable the relative flag on your [`FFNx.toml` config file](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L259).

## Field Debug

This tool will allow you to jump from field to field. It is actually supported on both FF7 and FF8.

## World Debug

This will will allow you to futher investigate the World geometry and much more. Currently supported on FF8 only.
````

## File: docs/mods/direct_mode.md
````markdown
# Direct mode

The Direct mode allows modders to bypass game archives
(LGP for FF7 or FS/FI/FL for FF8) and read files directly from the directory
pointed by the `direct_mode_path` configuration entry.

For example: if FF7 is looking for aaab.rsd in char.lgp, this mode will make it open direct/char/aaab.rsd first,
If this file doesn't exist it will look for the original in the LGP archive
Another example: if FF8 is looking for c:/data/en/FIELD/mapdata/bc/bccent12/bccent12.msd in field.fs,
this mode will make it open direct/FIELD/mapdata/bc/bccent12/bccent12.msd if it exists.
````

## File: docs/mods/exe_data.md
````markdown
# EXE data

Sometimes texts and textures are stored inside the EXE, instead in the data directory.
In this case it is harder for modders to mod the game.

This feature allows modders to override data from the EXE via the
(Direct Mode)[direct_mode.md] feature.

Use the `save_exe_data` option to dump files to the direct/exe/ directory.
And then FFNx will look for those files directly instead of data from the EXE.

## Supported data

### FF8

- `battle_scans.msd`: Texts in battle scans. Note: this is not exactly the same
  format in the EXE, the msd format is used because it is a well documented format
  of FF8.
- `card_names.msd`: Card names. Note: this is not exactly the same
  format in the EXE, the msd format is used because it is a well documented format
  of FF8.
- `card_texts.msd`: Card module texts. Note: this is not exactly the same
  format in the EXE, the msd format is used because it is a well documented format
  of FF8.
- `draw_point.msd`: Draw point and Disc error messages
````

## File: docs/mods/external_textures.md
````markdown
# External textures

You can override game's textures with images in DDS (recommended) or PNG format.
To know where to put your custom textures, set the option `trace_loaders` to `true` and look at the content of FFNx.log
when the game is running.

It is also possible to dump textures on runtime in PNG format by setting the option `save_textures` to true.

By default, FFNx looks for textures relatively to the `./mods/Textures` directory, this path can be changed via the option `mod_path`.

## FF8

[List of external textures](../ff8/mods/external_textures.md)
````

## File: docs/mods/video_encoding_guide.md
````markdown
# Video Encoding Guide

This guide explains how to edit and encode FMV videos for high quality and proper playback within FFNx. For the most part, FFNx behaves like a generic ffmpeg-based video player. However, some default behavior differs in order to correctly play back Playstation 1 videos, upscales of Playstation 1 videos, FF7 PC release videos, and FF8 Steam release videos. **Therefore, videos of other provenance that are missing colorimetry metadata may play back with incorrect colors.** Additionally, FFNx does not handle the full range of exotic inputs that a media player like VLC might.

1. [Container Format](#container-format)
2. [Video Codec](#video-codec)
3. [Audio Codec](#audio-codec)
4. [Suggested Workflow](#suggested-workflow)
5. [Pixel Format](#pixel-format)
6. [Bit Depth](#bit-depth)
7. [Color Matrix](#color-matrix)
8. [Color Primaries (Color Gamut)](#color-primaries-color-gamut)
9. [Color Range](#color-range)
10. [Transfer Characteristics (Gamma)](#transfer-characteristics-gamma)
11. [Full Colorimetry Conversion Example](#full-colorimetry-conversion-example)
11. [Editing Metadata without Re-Encoding](#editing-metadata-without-re-encoding)

### Container Format
**Recommended:** mkv  
**Permitted:** Anything ffmpeg can decode  
**Notes:**
- Simply rename your file to end with .avi, regardless of its actual type.

### Video Codec
**Recommended:** x264  
**Permitted:** Anything ffmpeg can decode  
**Notes:**  
- x264 is recommended because it is widely used and well tested.
- The standalone x264 command-line encoder is recommended over ffmpeg or GUI-based tools.

### Audio Codec
**Recommended:** opus  
**Permitted:** Anything ffmpeg can decode  
**Notes:**  
- The audio for the Playstation 1 videos has an odd sample rate. It is recommended to resample to 48kHz using soxr before encoding. E.g.: `ffmpeg -i input.wav -af aresample=resampler=soxr -ar 48000 output.wav` (It's better to do a high-quality upsample at encode time and potentially downsample at playback time than to upsample at playback time.) 
- Since the additional space required is trivial relative to a typical FF7 + 7th Heaven install, encoding audio at a bitrate comfortably above "transparency" is recommended. (Consider 256 for opus, 320 for aac, `-q 9` for vorbis.) 
- If encoding to opus, the standalone opusenc encoder is recommended.
- If encoding to aac, it is strongly recommended to use Apple's encoder (see [qaac](https://github.com/nu774/qaac/wiki)) because ffmpeg's aac encoders are terrible.
- Be careful with vorbis encoders. Some will downsample to 22050Hz by default. This is undesirable because it distorts frequencies above [11025Hz](https://www.rapidtables.com/tools/tone-generator.html?f=11025), which are not only audible to humans, but also musically relevant. (See [Nyquist-Shannon theorem](https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem).)


### Suggested Workflow
- Extract videos from Playstation disks to a series of .png images using [jPSXdec](https://github.com/m35/jpsxdec).
     - Also extract to any avi format to get wav audio. (Must be demuxed later.) 
- Do pre-processing with a frameserver and save output back to a series of .png images.
     - VapourSynth is recommended over AviSynth(+) because it has better performance, better stability, and does not have functions with undesirable "gotcha" default parameters like AviSynth does (e.g., ConvertToYUV() does a PC->TV range conversion by default).
     - [fmtconv](https://github.com/EleonoreMizo/fmtconv) is recommended for all color, bit-depth, and pixel format conversions, for both VapourSynth and AviSynth.
- Batch process your .png images through your AI upscaler program.
- Do post-processing with a frameserver, piping output to your encoder.
- Encode with the standalone x264 command-line encoder.
- Mux audio and video using mkvtoolsnix.
- Rename mkv file to avi.

### Pixel Format
**Recommended:** yuv420 family (yuv420p10le in specific)   
**Permitted:** Anything ffmpeg can decode  
**Notes:**  
- yuv420 is standard for digital video because the human vision has about half the resolving power for chroma as for luma.
- FFNx resamples to yuv444 internally. So, if you use yuv422 or yuv444, the extra chroma data won't be "wasted."
     - (Exception: BGR24 is not converted to yuv444; rather the RGB values are used directly. This pixel format is used by the avi files in the PC release of FF7.) 

### Bit Depth
**Recommended:** 10 bits per color  
**Permitted:** Anything ffmpeg can decode  
**Notes:**  
- FFNx converts to 8 bits per color internally, as it must for display on standard 8-bit monitors.
- Nevertheless, 10-bit encoding is recommended, even for 8-bit source material destined for an 8-bit monitor, because it reduces banding and compression artifacts and yields better quality at the same file size (or smaller file size at the same quality).
- Generally, the first thing your frameserver script should do is increase the bit depth to at least 16, and the last thing it should do is reduce the bit depth to 10. Working in a high bit depth prevents banding and other color errors caused by rounding.
- Depending on your operating system and the age of your x264 encoder, you might have separate binaries for 8-bit and 10-bit encoding, or a single binary that can do both. The relevant parameters for the dual-depth binary are `--input-depth` and `--output-depth` both of which should be 10. 

### Color Matrix
**Background Info:** The color matrix is used to convert between YUV and RGB. The same matrix must be used for playback as was used at encoding time.  
**x264 encoder parameter:** `--colormatrix` Possible values are `undef`, `bt709`, `fcc`, `bt470bg`, `smpte170m`, `smpte240m`, `GBR`, `YCgCo`, `bt2020nc`, `bt2020c`, `smpte2085`, `chroma-derived-nc`,         `chroma-derived-c`, and `ICtCp`. This parameter only sets the metadata used for playback; it does not do a color matrix conversion.  
**Recommended:** `bt709` for new material or if doing a color matrix and gamut conversion in a frameserver. Otherwise retain the source material's matrix.  
**Permitted:** Anything ffmpeg can decode  
**FFNx default behavior:** If the color matrix metadata is absent or `undef`, `smpte170m` (bt601) is assumed. Except `bt709` is assumed for FF8 when the video has HD dimensions and no colorimetry metadata.  
**Notes:**
- The original Playstation 1 videos use the bt601 color matrix. (See [jpsxdec documentation](https://github.com/m35/jpsxdec/blob/readme/jpsxdec/PlayStation1_STR_format.txt)).
     - There are some small errors in the Playstation 1's matrix values (rounding errors? electrical engineering compromises?), but jpsxdec accounts for them, so a standard matrix should be used thereafter.
- The avi video files from the PC edition of FF7 use an RGB pixel format, and thus no YUV->RGB color matrix is needed.
- The avi video files from the Steam edition of FF8 appear to use the bt709 color matrix.
- FFNx handles bt601 and bt709 natively. Anything else will be converted to bt601 using ffmpeg's swscale component. In this case, the metadata for color matrix, color primaries, and transfer properties must be set correctly. Otherwise ffmpeg must guess about these values when converting, and may guess incorrectly.
- The color matrix of an unlabeled video is almost always either bt601 or bt709. Which one can usually be ascertained by "eyeballing" it using a tool that can swap which matrix is used for display (such as [vsedit](https://github.com/YomikoR/VapourSynth-Editor)). [This page](http://avisynth.nl/index.php/Colorimetry) explains how greens and reds will look wrong when the incorrect matrix is used. For live-action content, you can usually tell by looking at a tree or bush. For animated and computer-generated content it can be more difficult to distinguish incorrect color from artistic intent.

### Color Primaries (Color Gamut)
**Background Info:** The color gamut is the range of visible light that a playback device is physically capable of producing. Video is "mastered" with a particular class of playback device in mind (e.g., American CRT television sets with SMPTE-C phospors). To correctly play back video mastered for one gamut on a device with a different gamut, a conversion must be made so that the second device will produce the same visible colors as the first, to the extent it's physically able to.  
**x264 encoder parameter:** `--colorprim` Possible values are `undef`, `bt709`, `bt470m`, `bt470bg`, `smpte170m`, `smpte240m`, `film`, `bt2020`, `smpte428`, `smpte431`, `smpte432`. This parameter only sets the metadata used for playback; it does not do a color gamut conversion.  
**Recommended:** `undef` for NTSC-J material, otherwise the color gamut of the source material (likely `bt709` when color matrix is bt709 and `smpte170m` or `bt470bg` when color matrix is bt601).   
**Permitted:** `undef`, `bt709`, `bt470m`, `smpte170m`, `smpte240m`, `bt470bg` _If video metadata specifies unsupported color primaries, the video will fail to play._  
**FFNx default behavior:** If the color primary metadata is absent or `undef`, the NTSC-J color gamut is generally assumed. Except that `bt709` is assumed when (1) the color matrix is bt709, or (2) for FF8 when the video has HD dimensions and no colorimetry metadata, or (3) if the file name is eidoslogo.avi or sqlogo.avi.  
**Notes:**
- The original Playstation 1 videos were mastered for playback using the "NTSC-J" gamut from the Japanese television standard in force in the 1990s.  
     - Unfortunately, neither the x264 encoder nor ffmpeg have an enum for this color gamut. So FFNx must hijack `undef` to mean "NTSC-J." **Therefore, unless the exceptions noted above apply, a video that is not NTSC-J will play back with (very) incorrect colors in FFNx if the `--colorprim` metadata is absent.**
     - fmtconv is capable of doing conversions to/from the NTSC-J color gamut.
- In the absence of metadata, `bt709` (sRGB) is assumed for eidoslogo.avi and sqlogo.avi because these files don't exist on the Playstation discs, and were presumably created for the PC release, presumably using the sRGB gamut.
- The avi video files from the Steam edition of FF8 appear to use the bt709 color gamut. (Gamut conversion from NTSC-J was already done when these videos were encoded.)
- The `bt709` color gamut is the same as sRGB, used by modern computer monitors. FFNx will ultimately convert everything to this color gamut. (Except if HDR is enabled, everything will instead be converted to the rec2020 color gamut used by HDR monitors.)
- Due to some compromises necessary for rendering gameplay, videos are subject to two sequential color gamut conversions in some circumstances. This is not ideal, but it cannot be avoided. Sequential color gamut conversions happen when:
     - When NTSC-J mode is enabled, and the video's color gamut is not NTSC-J.
     - When HDR is enabled, and NTSC-J mode is disabled, and the video's color gamut is not `bt709` (sRGB).
- The `bt470m` color gamut was deprecated in television standards in 1979. If `bt470m` metadata is encountered, FFNx will assume it's an error and that `smpte170m` was intended.
- `smpte170m` is SMPTE-C, the North American standard for standard definition television. `smpte240m` is identical.
- `bt470bg` is EBU (PAL), the European standard for standard definition television.
- The color primaries of an unlabeled video likely match its color matrix, as follows: `bt709` for bt709, `smpte170m` for NTSC bt601, `bt470bg` for PAL bt601. NTSC-J is limited to material mastered for playback on Japanese CRT television sets. Videos created from still images created in image editing software like Photoshop and GIMP likely use the sRGB (`bt709`) gamut.

### Color Range
**Background Info:** Whether or not the full bit depth is used. If not, color values must be shifted and scaled for playback. See first note below for details.  
**x264 encoder parameters:** `--input-range` and `--range` Possible values are `pc`, `tv`, and `auto`. The latter parameter sets the metadata used for playback. If the former parameter differs, the encoder will perform a conversion. However, converting in the framesever is preferrable.  
**Recommended:** `pc` (full range)   
**Permitted:** `pc`, `tv`, unspecified  
**FFNx default behavior:** If the color range metadata is absent, tv range is assumed. (Except for pixel formats that are inherently full range.)  
**Notes:**  
- Full range (PC range) uses the entire bit depth available. (0-255 for 8 bits per color.) TV range is compressed and shifted to avoid using the upper and lower ~9% of the bit depth. (16-235 luma and 16-240 chroma for 8 bits per color.) TV range was devised as a workaround for the unavoidable over- and undershoots in analog singal processing. (See [Gibbs phenomenon](https://en.wikipedia.org/wiki/Gibbs_phenomenon).) TV range persisted into the age of digital video for purposes of backwards compatibility with analog television sets. It serves little purpose today, and none whatsoever with respect to content destined for a computer monitor.  
- Conversion from full range to tv range should be avoided because color data is irreparably discarded. This tends to cause [color banding](https://en.wikipedia.org/wiki/Colour_banding).
- When playing back tv-range videos, FFNx shifts and scales color values up to full range, with dithering.
     - (Dithering is not performed on the DirectX 9 experimental backend because a necessary shader function isn't supported.)
- For a limited class of high-bit-depth, tv-range videos, it's theoretically possible to recover 8 bits of full-range data. However, FFNx does not attempt this because doing so would mean giving up dithering for _all_ high-bit-depth, tv-range videos. (In particular, the extremely popular SYW upscale videos are high bit depth and tv range, but aren't in this limited class, and therefore benefit only from dithering.)
- The original Playstation 1 videos are full range.
- The avi video files from the PC edition of FF7 are full range.
- The avi video files from the Steam edition of FF8 are tv range. (Surprising and disappointing.)
- Several ffmpeg-based video players (notably including VLC) suffer from a bug in which, under certain circumstances, they apply an unnecessary and incorrect tv->pc range conversion to video that is already full range. FFNx does **_NOT_** have this bug.
- The color range of an unlabeled video can be ascertained using the [histogram filter for VapourSynth](https://vsdb.top/plugins/hist) or [AviSynth](http://avisynth.nl/index.php/Histogram). (See the AviSynth link for useful documentation.)

### Transfer Characteristics (Gamma)
**Background Info:** The gamma function used to convert between linear RGB and gamma-encoded RGB. (See [gamma correction](https://en.wikipedia.org/wiki/Gamma_correction).) At playback time, the inverse of whatever gamma function was previously used must be used to recover linear RGB, which can then be re-gamma-encoded using the inverse of the playback device's gamma function.  
**x264 encoder parameter:** `--transfer` Possible values are `undef`, `bt709`, `bt470m`, `bt470bg`, `smpte170m`, `smpte240m`, `linear`, `log100`, `log316`, `iec61966-2-4`, `bt1361e`, `iec61966-2-1`, `bt2020-10`, `bt2020-12`, `smpte2084`, `smpte428`, and `arib-std-b67`. This parameter only sets the metadata used for playback; it does not do a gamma conversion.  
**Recommended:** The inverse of whatever gamma function was previously used to convert from linear RGB to gamma-encoded RGB. If you didn't do such a conversion, then retain the source material's transfer characteristics.  
**Permitted:** `undef`, `bt709`, `bt470bg`, `iec61966-2-1`, `smpte170m`, `bt2020-10`, `bt2020-12`, `iec61966-2-4`, `bt1361e` (ffmpeg's AVCOL_TRC_GAMMA22 is also supported, but there's no way to flag that in x264's metadata.)  _If video metadata specifies unsupported transfer characteristics, the video will fail to play._  
**FFNx default behavior:** If the transfer characteristics metadata is absent or `undef`, FFNx will generally use custom gamma function that's been tweaked to look good with Playstation movies (orginal and upscaled). Except `bt709` is assumed when the color matrix is bt709 or for FF8 when the video has HD dimensions and no colorimetry metadata, and `bt470bg` is assumed when the color gamut is bt470bg.  
**Notes:**
- The gamma function used for the original Playstation 1 videos is a bit of a mystery. One would assume compliance with the applicable television standard, and thus `smpte170m`. However, using SMPTE170M, or any other piecewise function, for playback results in noticeable banding near black within the "toe slope." (Also, the SMPTE170M function is deliberately overbright in order to counteract other factors with playback on CRT television sets.) The nominal gamma for NTSC television was 2.2. However, using a pure 2.2 curve causes details in shadowy areas to be lost to darkness. A pure curve around 1.9 or 2.0 better preserves details in shadows, but blows out highlights. In sum, we don't know what gamma function was used originally, and all of the likely candidates have flaws. Given this uncertainty, in the absence of metadata, FFNx defaults to a custom gamma function (which we call "toeless sRGB") that avoids each of these flaws. It's certainly not the real inverse of the original gamma function, but the results look very good.
- `iec61966-2-1` is the sRGB gamma function. Computer monitors use this gamma function. FFNx will ultimately convert everything to this. The average of this function is roughly equivalent to a pure 2.2 curve. (Except if HDR is enabled, everything will instead be converted to the rec2084 ("PQ") gamma function used by HDR monitors.)
- `smpte170m`, `bt709`, `bt2020-10`, `bt2020-12`, `iec61966-2-4`, and `bt1361e` are all functionally identical. This is the gamma function used in the NTSC and HD television standards. The average of this function is roughly equivalent to a pure 1.9 curve (though 2.0 is often cited). This is deliberately overbright in order to counteract other factors with playback on CRT television sets.
- `bt470bg` is the gamma function for PAL standard definition television. It's a pure 2.8 gamma curve. (Though, the actual behavior of PAL CRT television sets was not really as high as 2.8.) 
-  Aside from Playstation 1 videos (see above), the transfer characteristics of an unlabeled video are most likely `smpte170m`.

### Full Colorimetry Conversion Example
The correct frameserver procedure for completely converting all colorimetry properties is somewhat complicated. Therefore, an example is provided here. The steps are:
1. Increase working bit depth to (at least) 16 bits per color. If the input is tv range, do a range conversion in the same operation.
2. Convert to (gamma encoded) RGB using the source color matrix.
3. Convert to linear RGB using the source gamma function.
4. Convert from the source color gamut to the destination color gamut.
5. Convert to gamma encoded RGB using the destination gamma function.
    - However, if you want to use FFNx's custom gamma function at playback, then instead just use the inverse of step 3 and set the `--transfer` metadata to `undef`.
6. Convert to YUV using the destination color matrix.
7. Downsample to 10 bits per color for output.
8. Set metadata encoder parameters correctly for the destination color properties.

Here is a sample VapourSynth script converting a Playstation video to bt709:
```
import vapoursynth as vs
core = vs.core
video = core.ffms2.Source('path/to/input.avi')
video = core.fmtc.bitdepth(video, bits=16, fulls=True, fulld=True) #use fulls=False if the source is tv range
video = core.std.SetFrameProp(video, prop='_ColorRange', intval=0) # 0 means full range
video = core.fmtc.resample(video,css='444', fulls=True, fulld=True) # YUV->RGB conversion will require 444
video = core.fmtc.matrix(video, mats="601", matd="RGB", fulls=True, fulld=True)
# assume 2.2 pure gamma curve for playstation videos; would normally use transs/transd instead of gcor, but there's no 2.2 option
video = core.fmtc.transfer(video, transs="linear", transd="linear", gcor=2.2, fulls=True, fulld=True) 
video = core.fmtc.primaries(video, prims="ntscj", primd="709")
# Because we want to use FFNx's custom gamma function, rather than converting to bt709's gamma function, invert the earlier step and set metadata to undef
# Again, would normally use transs/transd instead of gcor, but there's no 2.2 option
video = core.fmtc.transfer(video, transs="linear", transd="linear", gcor=1.0/2.2, fulls=True, fulld=True)
# If we wanted to convert the gamma function to bt709, we'd use this instead
# video = core.fmtc.transfer(video, transs="linear", transd="bt709", fulls=True, fulld=True)
video = core.fmtc.matrix(video, mats="RGB", matd="709", fulls=True, fulld=True)
video = core.fmtc.resample(video,css='420', fulls=True, fulld=True)
video = core.fmtc.bitdepth(video, bits=10, fulls=True, fulld=False)
video.set_output() 
# remember to set encoder parameters --input depth 10 --output-depth 10 --colormatrix bt709 --colorprim 709 --input-range pc --range pc --transfer undef (so that FFNx will use its custom gamma function)
```

### Editing Metadata without Re-Encoding
Because FFNx often interprets missing or undefined metadata in unusual ways in order to correctly play back its most common inputs (Playstation 1 videos, upscales of Playstation 1 videos, FF7 PC release videos, and FF8 Steam release videos), there will be circumstances where videos of other provenance that are missing colorimetry metadata will play back with incorrect colors. Such videos can be made to play back correctly in FFNx by editing their metadata to correctly describe their colorimetry.

It is possible to edit the metadata of a video stream using ffmpeg without re-encoding it. Please consult [ffmpeg's bitstream filters documentation](https://ffmpeg.org/ffmpeg-bitstream-filters.html). Assuming your video is x264, you will also need the tables in Annex E of [the h264 spec](https://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-H.264-201602-S!!PDF-E&type=items).

Note that ffmpeg is confused by renaming other containers (e.g., mkv) to avi, so the input file name should be changed back to the correct extension first.

Here is an example command that changes the video metadata to bt601 color matrix, undefined color primaries, undefined transfer characteristics, and full range:
```
ffmpeg -i input.mkv -c:v copy -bsf:v h264_metadata=matrix_coefficients=6:colour_primaries=2:transfer_characteristics=2:video_full_range_flag=1 -c:a copy output.mkv
```
````

## File: docs/faq.md
````markdown
# FAQ

## Common

### I have an AMD GPU and the game has weird visual artifacts while playing

If you own an AMD GPU, chances are you have some settings in your GPU which makes the rendering not optimal or with visual artifacts.

You can try the following steps to fix ( not 100% guarantee but worth a try ):

1. Download the latest AMD Drivers https://www.amd.com/en/support
2. Install the drivers and remember to pick the option **Restore settings to Factory default** while installing
3. When opening the AMD Control Panel for the first time, remember to choose the **Standard** profile.
4. Set `renderer_backend = 4` on the [FFNx.toml](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L20) config file.

After doing those steps, you should be able to play normally without any visible visual artifact.

## Final Fantasy VII

### Game crashed, now what?

Don't panic. FFNx creates an emergency save for you automatically, located next to your own `ff7.exe` file, located in `saves\crash.ff7`. You can rename this file to for eg. `save00.ff7` and load the first slot on the new game screen.

BE AWARE that this is an emergency save and not everything might have been saved. **Use at your own risk.**

#### If you ARE NOT using 7th Heaven / any third party mod pack

You may open an issue here: https://github.com/julianxhokaxhiu/FFNx/issues

Remember to include:
- the `FFNx.log` file you got immediately after the crash ( if you run the game again, it will be overwritten and precious information to understand the issue will be lost forever )
- the `crash.ff7` file you can find under `saves\` directory
- a description of the issue and how to replicate it
- a proof ( picture or video ) that shows the intended issue

#### If you ARE using 7th Heaven / any third party mod pack

Please approach relative Mod Authors through the support links that you can find here: https://github.com/julianxhokaxhiu/FFNx#support

DO NOT attempt to open an issue in this repository. It will be closed immediately without further explainations.

### I installed the 1998 edition from CDs but movies are not playing

In order to fix that behavior you need to:

- Find the path where `ff7.exe` is installed ( for eg. `C:\Games\Final Fantasy VII` )
- Open `RegEdit.exe` and go to this key:
  - x32: `HKEY_LOCAL_MACHINE\SOFTWARE\Square Soft, Inc.\Final Fantasy VII`
  - x64: `HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Square Soft, Inc.\Final Fantasy VII`
- Update the key named `MoviePath` value to `c:\games\final fantasy vii\Data\Movies\`
- Copy the movie files from all your CDs into `c:\games\final fantasy vii\Data\Movies\`

You should now be able to play vanilla movies as well as the one distributed via mods.

## Final Fantasy VIII

### Game crashed, now what?

You may open an issue here: https://github.com/julianxhokaxhiu/FFNx/issues

Remember to include:
- the `FFNx.log` file you got immediately after the crash ( if you run the game again, it will be overwritten and precious information to understand the issue will be lost forever )
- a save file of the nearest location required to replicate the issue
- a description of the issue and how to replicate it
- a proof ( picture or video ) that shows the intended issue

### After installing the game on Windows 10, when I attempt to run it, it starts as a process but shows nothing

This might happen because your game installation might have got corrupted. There might be many issues affecting this.

One of the possible fixes you can try is:
- Pick the CD-ROM drive letter on your Windows installation ( say E: )
- Open `RegEdit.exe` and go to this key:
  - x32: `HKEY_LOCAL_MACHINE\SOFTWARE\Square Soft, Inc\FINAL FANTASY VIII\1.00`
  - x64: `HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Square Soft, Inc\FINAL FANTASY VIII\1.00`
- Update the key named `DataDrive` value to `e:`

Try to run again the game. If everything was done correctly, the game should start fine.
````

## File: docs/how_to_install.md
````markdown
# How-to: Install

Independently of the way you decide to install FFNx, in order to use it you MUST have a legal copy of the game. Support will NOT be provided if the game will NOT be detected as genuine.

## Canary vs Stable

FFNx comes in two flavors, resembling the Google Chrome release names. Unlike this one though, we don't need all the others.

- **Stable:** this is a fully tested, and hopefully, bug free release.
  > It is commonly accepted for long gameplay sessions and generic users. If in doubt, use this one first.
- **Canary:** this is like a nightly release, but untested. Feel free to use it at your own risk.
  > This is what users need to try before reporting any issue encountered in this channel, or if you want to try the latest development updates going on in FFNx.

## Standalone

### Final Fantasy VII

**Supported Languages:** EN, DE, FR, SP, JP\*

> \*: Japanese support is currently work in progress. The game starts fine but font is not rendering properly and battles do crash sometimes.

#### [1998 Eidos Release](https://www.mobygames.com/game/windows/final-fantasy-vii)

0. Install the game on this path: `C:\Games\Final Fantasy VII`
1. Update your game to v1.02 ( https://www.gamefront.com/games/final-fantasy-7-advent-children/file/final-fantasy-7-retail-v1-02-patch )
2. Download the latest `FFNx-FF7_1998` release here: https://github.com/julianxhokaxhiu/FFNx/releases
3. Extract the ZIP content next to `ff7.exe` file
4. Double click on [`FFNx.reg`](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FF7.reg)
5. Click on Yes.
6. Enjoy!

#### [2013 Steam Release](https://store.steampowered.com/app/39140/FINAL_FANTASY_VII/)

0. Install the game using the Steam Client
1. Make sure you run at least your game once ( until the new game screen )
2. Open the installation directory of the game ( see [How to access game files](https://steamcommunity.com/sharedfiles/filedetails/?id=760447682) )
3. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
4. Extract the ZIP content next to your `ff7_*.exe` file ( for eg. for EN language `ff7_en.exe`)
5. Replace all files when asked.
6. Enjoy!

#### [2013 eStore Release](http://www.jp.square-enix.com/ffvii-pc-jp/)

0. Install the game using the eStore installer.
1. Open the installation directory of the game
2. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
3. Extract the ZIP content next to your `ff7_*.exe` file ( for eg. for EN language `ff7_en.exe`)
4. Replace all files when asked.
5. Enjoy!

#### [Android Release](https://play.google.com/store/apps/details?id=com.square_enix.android_googleplay.FFVII)

0. Install the game in your Android device.
1. Locate the OBB file ( usually in `Android/obb` or `/obb` in your internal storage )
2. Save the OBB file in your Windows desktop
3. Rename the OBB file extension from `.obb` to `.zip` and extract it
4. In the extracted folder, go to `ff7_1.02` directory
5. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
6. Extract the ZIP content next to the `ff7_*.exe` files
7. Update `FFNx.toml` flags with these values:

```toml
ffmpeg_video_ext = "webm"
external_music_path = "data/music_2"
external_music_ext = "akb"
```

9. You can now run any `ff7_*.exe` file you prefer. Enjoy!

### Final Fantasy VIII

**Supported Languages:** EN, DE, FR, SP, IT, JP

#### [2000 Squaresoft Release](https://www.mobygames.com/game/windows/final-fantasy-viii)

0. Install the game on this path: `C:\Games\Final Fantasy VIII`
1. Update your game to v1.2 ( you can find a collection here: https://www.ff8.fr/telechargements/programmes )
2. Download the latest `FFNx-FF8_2000` release here: https://github.com/julianxhokaxhiu/FFNx/releases
3. Extract the ZIP content next to `ff8.exe` file
4. Double click on [`FFNx.reg`](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FF8.reg)
5. Enjoy!

#### [2013 Steam Release](https://store.steampowered.com/app/39150/FINAL_FANTASY_VIII/)

0. Install the game using Steam Client
1. Make sure you run at least your game once ( until the new game screen )
2. Open the installation directory of the game ( see [How to access game files](https://steamcommunity.com/sharedfiles/filedetails/?id=760447682) )
3. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
4. Extract the ZIP content next to your `ff8_*.exe` file ( for eg. for EN language `ff8_en.exe`)
5. Replace all files when asked.
6. Enjoy!

## Mod Launchers

### 7thHeaven 2.4.0+

0. Install Final Fantasy VII using the Steam Client
1. Download and install the latest 7th Heaven release here: https://github.com/tsunamods-codes/7th-Heaven/releases
2. Launch `7th Heaven` and click Play on the top left
3. Enjoy!

### SYW Steam all in one

0. Install Final Fantasy VII using the Steam Client
1. Follow installation instructions here: http://forum.tsunamods.com/viewtopic.php?f=69&p=716&sid=a91d0f964f413cc24c649298cf6f764b#p716
2. Enjoy!
````

## File: docs/readme.md
````markdown
# FFNx documentation

Welcome to the FFNx documentation!

## Common

- [How To Install](how_to_install.md)
- [FAQ - Frequently Asked Questions](faq.md)
- [Built-In Shortcuts](shortcuts.md)

## FF7

## FF8

 - [FF8 Specific documentation](ff8/readme.md)

## Modding

- [DevTools](mods/devtools.md)
- [Direct Mode](mods/direct_mode.md)
- [EXE Data](mods/exe_data.md)
- [Audio Engine](mods/audio_engine.md)
- [Video Encoding Guide](mods/video_encoding_guide.md)
- [External textures](mods/external_textures.md)
````

## File: docs/shortcuts.md
````markdown
# Shortcuts

FFNx comes with various built-in shortcuts which would allow you to boost or enjoy your gameplay experience.

### Fullscreen

You can toggle the fullscreen mode in any moment while playing by using the related shortcuts.

Shortcuts:

- Keyboard Shortcut: `Alt + Enter`

### Borderless

You can toggle the borderless mode in any moment while playing by using the related shortcuts.

Shortcuts:

- Keyboard Shortcut: `Shift + Enter`

### Aspect Ratio

You can toggle the aspect ratio ( 4:3 or 16:9 ) in any moment while playing by using the related shortcuts.

Shortcuts:

- Keyboard Shortcut: `Shift + Arrow Left/Right`

### FMV Skip

This cheat will allow you to skip movies in-game.

Shortcuts:

- Keyboard Shortcut: `CTRL + S`
- Gamepad Shortcut: `L3` THEN `SQUARE` (XInput: `LSB` THEN `X`)

### Battle mode toggle

This cheat will allow you to disable battle encounters while in the worldmap or in field.

Shortcuts:

- Keyboard Shortcut: `CTRL + B`
- Gamepad Shortcut: `L3` THEN `CIRCLE` (XInput: `LSB` THEN `B`)

### Speedhack

This cheat will allow you to boost the gameplay timing up to 8x ( by default, [you can configure this](<(https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L200)>) up to your pleasure ).

Shortcuts:

- Keyboard Shortcut: `CTRL + Arrow Up/Down`
- Gamepad Shortcut: `L3` THEN `L1/R1` (XInput: `LSB` THEN `LB/RB`)

You can toggle the speedhack (enable/disable) when you want by using these Shortcuts:

- Keyboard Shortcut: `CTRL + Arrow Left/Right`
- Gamepad Shortcut: `L3` THEN `L2/R2` (XInput: `LSB` THEN `LT/RT`)

### Soft Reset

This cheat will allow you to reset the game like on PSX, by triggering the game over screen wherever you are.

Shortcuts:

- Keyboard Shortcut: `CTRL + R`
- Gamepad Shortcut: `L3` THEN `START + SELECT` (XInput: `LSB` THEN `BACK + START`)

### Auto-Attack ( FF7 only! )

This cheat will allow you to auto-attack the enemies in battle, instead of pressing the action button continously.

Shortcuts:

- Keyboard Shortcut: `CTRL + A`
- Gamepad Shortcut: `L3` THEN `TRIANGLE` (XInput: `LSB` THEN `Y`)

### Toggle Music on Battle pause ( FF7 only! )

This cheat will allow you to resume the music playback while battle is on pause. By pressing the key combination you will be able to toggle the playback ( pause/resume ).

Shortcuts:

- Keyboard Shortcut: `CTRL + M`

### Voice Auto-Text

This cheat will allow you to toggle the voice auto text feature while playing the game. By pressing the key combination you will be able to toggle the auto advance of text boxes as voice line finishes to play.

Shortcuts:

- Keyboard Shortcut: `CTRL + T`

### Quit Game ( FF8 only! )

Shortcuts:

- Keyboard Shortcut: `CTRL + Q` (For Qwerty keyboards)
- Keyboard Shortcut: `CTRL + A` (For Azerty keyboards)
````

## File: misc/hext/ff7/de/FFNx._GLOBALS.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Transparency value for ALL dialogs
# Suggested range of values: 00 - E6 ( 0% - 90%)
# Default: BF ( 75% )
+8ABD0
6E6C53 = BF
````

## File: misc/hext/ff7/de/FFNx.BATTLE.fullscreen.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Fullscreen battle scenes
41B51A = E0
41B4E8 = 00

+8ABE0
6CF639 = F4
6CF6CB = F4
6CF852 = 1A
6CF8D7 = 82
6CF934 = 82
6CF977 = 82
6CF9D5 = 82

+8ABDD
6D7A8F = 0D
6D7B0F = 0F

+8ABDD
6D0B45 = 90 90 90 90 90

+8ABD0
6DC991 = 92
6DCA16 = 92

+8ABD0
6DD06F = 77
6DD096 = 77
6DD0BE = 77
6DD0E0 = 77
6DD105 = 77
6DD12A = 77
6DD14F = 77
6DD3BA = 80
6DD49A = 80
6DD44D = 80
6DD539 = 84
6DD584 = 84
6DD5D6 = 84
6DD603 = 82
6DD6BD = 84
6DD6EB = 82
6DD750 = 84
6DD78F = 8E
6DD7C0 = 82
6DD86F = 82
6DD8A4 = 82
6DD8D4 = 82
6DD956 = 82
6DD9C3 = 82
6DD9F8 = 82

+8ABD0
6DE5E1 = 78
6DE66D = 78
6DE6B4 = 78
6DE71C = 78
6DE7BC = 7A
6DEC56 = 76
6DED78 = 7A
6DEDA3 = 84
6DEDA9 = A0
6DEDDE = 82
6DEDE4 = B0
6DEECB = 7E

+8ABD0
6DF4E2 = 77
6DF492 = 86
6DF4BA = 77
6DF533 = 73
6DFA14 = 76
6DFB51 = 7E
6DFC1C = 84
6DFC46 = 76

+8ABD0
6E0723 = 76
6E080C = 7E
6E0823 = 74
6E0A0F = F6
6E0A15 = 76
6E0B2D = 7E
6E0B54 = 76
6E0B59 = 1A
6E0D3B = 79
6E0D40 = 70
6E0D74 = A6
6E0D79 = 82
6E0D92 = C2
6E0D97 = 82
6E0DB3 = 8E
6E0DDB = AA
6E0DFD = C6
6E0E18 = 76

+8ABD0
6E13A1 = 82
6E148C = 82
6E14C1 = 82
6E14F1 = 82
6E1535 = 82
6E1555 = 94
6E162B = 82
6E1660 = 82
6E1690 = 82
6E16D4 = 82
6E16F4 = 94
6E1863 = 82
6E1891 = 76
6E18D4 = 76
6E18FB = 76

+8ABD0
6E2014 = 7E
6E2189 = 76
6E2429 = 18

+8ABD0
6E316D = 76
6E325A = 58
6E3892 = 80
6E38AD = A6
6E38F9 = 80
6E3918 = 9C
6E3964 = 76
6E3A35 = 08 01
6E3B8D = 9A
6E3BBB = AC
6E3C31 = 8A
6E3C59 = 9A

+76A68
91C342 = 70
91C3DA = 70
91C472 = 70
91C50A = 70
91C5A2 = 70
91C5B6 = 10 02
91C5BA = 10 02
91C63A = 70
91C6D2 = 70
91C76A = 70
91CE8A = 70
91CF22 = 70
91CF38 = 70
91CFBA = 70

+76A68
91D0EA = 40
91D182 = 70
91D2B2 = 70
91D34A = 70
91D3E2 = 70

+76AE8
91E7FC = 54
91E990 = 48 6A
````

## File: misc/hext/ff7/de/FFNx.BATTLE.restore_modals.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

![BATTLE] Entering FRAME_QUIT

# Add transparency support for BATTLE dialogs
+8ABD0
6E9475 = 0F 84 B3 01 00 00
````

## File: misc/hext/ff7/de/FFNx.BATTLE.transparent_modals.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

![BATTLE] Entering FRAME_INITIALIZE

# Add transparency support for BATTLE dialogs
+8ABD0
6E9475 = 90 90 90 90 90 90
````

## File: misc/hext/ff7/de/FFNx.FIELD.transparent_modals.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Add transparency support for FIELD dialogs
+8ABD0
6EB022 = 90 90 90 90 90 90
````

## File: misc/hext/ff7/de/FFNx.MENU.cursor_vertical_center.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Fix Main Menu cursor position ( vcenter relative to text entry )
+8B250
715240 = 14
71526B = 14
````

## File: misc/hext/ff7/en/FFNx._GLOBALS.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Transparency value for ALL dialogs
# Suggested range of values: 00 - E6 ( 0% - 90%)
# Default: BF ( 75% )
6E6C53 = BF
````

## File: misc/hext/ff7/en/FFNx.BATTLE.fullscreen.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Fullscreen battle scenes
41B51A = E0
41B4E8 = 00

6CF639 = F4
6CF6CB = F4
6CF852 = 1A
6CF8D7 = 82
6CF934 = 82
6CF977 = 82
6CF9D5 = 82

6D7A8F = 0D
6D7B0F = 0F

6D0B45 = 90 90 90 90 90

6DC991 = 92
6DCA16 = 92

6DD06F = 77
6DD096 = 77
6DD0BE = 77
6DD0E0 = 77
6DD105 = 77
6DD12A = 77
6DD14F = 77
6DD3BA = 80
6DD49A = 80
6DD44D = 80
6DD539 = 84
6DD584 = 84
6DD5D6 = 84
6DD603 = 82
6DD6BD = 84
6DD6EB = 82
6DD750 = 84
6DD78F = 8E
6DD7C0 = 82
6DD86F = 82
6DD8A4 = 82
6DD8D4 = 82
6DD956 = 82
6DD9C3 = 82
6DD9F8 = 82

6DE5E1 = 78
6DE66D = 78
6DE6B4 = 78
6DE71C = 78
6DE7BC = 7A
6DEC56 = 76
6DED78 = 7A
6DEDA3 = 84
6DEDA9 = A0
6DEDDE = 82
6DEDE4 = B0
6DEECB = 7E

6DF4E2 = 77
6DF492 = 86
6DF4BA = 77
6DF533 = 73
6DFA14 = 76
6DFB51 = 7E
6DFC1C = 84
6DFC46 = 76

6E0723 = 76
6E080C = 7E
6E0823 = 74
6E0A0F = F6
6E0A15 = 76
6E0B2D = 7E
6E0B54 = 76
6E0B59 = 1A
6E0D3B = 79
6E0D40 = 70
6E0D74 = A6
6E0D79 = 82
6E0D92 = C2
6E0D97 = 82
6E0DB3 = 8E
6E0DDB = AA
6E0DFD = C6
6E0E18 = 76

6E13A1 = 82
6E148C = 82
6E14C1 = 82
6E14F1 = 82
6E1535 = 82
6E1555 = 94
6E162B = 82
6E1660 = 82
6E1690 = 82
6E16D4 = 82
6E16F4 = 94
6E1863 = 82
6E1891 = 76
6E18D4 = 76
6E18FB = 76

6E2014 = 7E
6E2189 = 76
6E2429 = 18

6E316D = 76
6E325A = 58
6E3892 = 80
6E38AD = A6
6E38F9 = 80
6E3918 = 9C
6E3964 = 76
6E3A35 = 08 01
6E3B8D = 9A
6E3BBB = AC
6E3C31 = 8A
6E3C59 = 9A

91C342 = 70
91C3DA = 70
91C472 = 70
91C50A = 70
91C5A2 = 70
91C5B6 = 10 02
91C5BA = 10 02
91C63A = 70
91C6D2 = 70
91C76A = 70
91CE8A = 70
91CF22 = 70
91CF38 = 70
91CFBA = 70

91D0EA = 40
91D182 = 70
91D2B2 = 70
91D34A = 70
91D3E2 = 70

91E7FC = 54
91E990 = 48 6A
````

## File: misc/hext/ff7/en/FFNx.BATTLE.restore_modals.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

![BATTLE] Entering FRAME_QUIT

# Add transparency support for BATTLE dialogs
6E9475 = 0F 84 B3 01 00 00
````

## File: misc/hext/ff7/en/FFNx.BATTLE.transparent_modals.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

![BATTLE] Entering FRAME_INITIALIZE

# Add transparency support for BATTLE dialogs
6E9475 = 90 90 90 90 90 90
````

## File: misc/hext/ff7/en/FFNx.FIELD.transparent_modals.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Add transparency support for FIELD dialogs
6EB022 = 90 90 90 90 90 90
````

## File: misc/hext/ff7/en/FFNx.MENU.cursor_vertical_center.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

# Fix Main Menu cursor position ( vcenter relative to text entry )
715240 = 14
71526B = 14
````

## File: misc/FFNx-Choco.def
````
;*****************************************************************************;
;    Copyright (C) 2009 Aali132                                               ;
;    Copyright (C) 2018 quantumpencil                                         ;
;    Copyright (C) 2018 Maxime Bacoux                                         ;
;    Copyright (C) 2020 myst6re                                               ;
;    Copyright (C) 2020 Chris Rizzitello                                      ;
;    Copyright (C) 2020 John Pritchard                                        ;
;    Copyright (C) 2025 Julian Xhokaxhiu                                      ;
;                                                                             ;
;    This file is part of FFNx                                                ;
;                                                                             ;
;    FFNx is free software: you can redistribute it and/or modify             ;
;    it under the terms of the GNU General Public License as published by     ;
;    the Free Software Foundation, either version 3 of the License            ;
;                                                                             ;
;    FFNx is distributed in the hope that it will be useful,                  ;
;    but WITHOUT ANY WARRANTY; without even the implied warranty of           ;
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            ;
;    GNU General Public License for more details.                             ;
;*****************************************************************************;

LIBRARY AF4DN.P
EXPORTS
; Required for the Steam driver injection
dotemuCreateFileA
dotemuCreateMutexA
````

## File: misc/FFNx.ambient.toml
````toml
# FFNx Audio Engine config file - Ambient layer

### HOW TO: ###################################################################
# Sections may be commented by default with an initial # character.
# Remove the initial # character to set the entire sections block and its flags
# -----------------------------------------------------------------------------
# Syntax:
# [ID]
# flag = value
# another_flag = value
###############################################################################

### SUPPORTED FLAGS: ##########################################################
# shuffle: Shuffle an SFX ID with one of the given IDs in the array. IDs MUST
# be numbers ONLY and MUST NOT contain any special character like - or _.
# This flag MUST NOT be used in pair with 'sequential'.
# -----------------------------------------------------------------------------
# sequential: Sequentially playback an SFX ID with the ones provided in the
# array. IDs MUST be numbers ONLY and MUST NOT contain any special character
# like - or _. This flag MUST NOT be used in pair with 'shuffle'.
# -----------------------------------------------------------------------------
# fade_in: Fade in the track on play. The value MUST be a floating point
# number and if 0.0 ( default ) then the track will NOT fade.
# -----------------------------------------------------------------------------
# fade_out: Fade out the track on stop. The value MUST be a floating point
# number and if 0.0 ( default ) then the track will NOT fade.
# -----------------------------------------------------------------------------
# volume: Allow volume to be adjusted for a specific track.
###############################################################################

# Example
# -----------------------------------------------------------------------------
#[field_123]
#shuffle = [ "field_121", "field_122", "field_124" ]
#sequential = [ "field_121", "field_122", "field_124" ]
#fade_in = 0.0
#fade_out = 0.0
#volume = 50
````

## File: misc/FFNx.blit.frag
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input v_texcoord0

#include <bgfx/bgfx_shader.sh>
#include "FFNx.common.sh"

SAMPLER2D(tex_0, 0);

void main()
{
	gl_FragColor = texture2D(tex_0, v_texcoord0.xy);
}
````

## File: misc/FFNx.blit.vert
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input a_position, a_texcoord0
$output v_texcoord0

#include <bgfx/bgfx_shader.sh>

void main()
{
    vec4 pos = a_position;

    pos.w = 1.0 / pos.w;
    pos.xyz *= pos.w;
    pos = mul(u_proj, pos);

    gl_Position = pos;
    v_texcoord0 = a_texcoord0;
}
````

## File: misc/FFNx.common.sh
````bash
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

// Gamut LUT
SAMPLER2D(tex_10, 10);

// YUV to RGB ---------------------------------------------------------
// tv-range functions include implicit range expansion

vec3 toRGB_bt601_fullrange(vec3 yuv_input)
{
	const mat3 jpeg_rgb_transform = mat3(
		vec3(+1.000, +1.000, +1.000),
		vec3(+0.000, -0.202008 / 0.587, +1.772),
		vec3(+1.402, -0.419198 / 0.587, +0.000)
	);
	return saturate(instMul(jpeg_rgb_transform, yuv_input));
}

vec3 toRGB_bt601_tvrange(vec3 yuv_input)
{
	const mat3 mpeg_rgb_transform = mat3(
		vec3(+255.0 / 219.0, +255.0 / 219.0, +255.0 / 219.0),
		vec3(+0.000, -25.75602 / 65.744 , +225.93 / 112.0),
		vec3(+178.755 / 112.0, -53.447745 / 65.744 , +0.000)
	);
	return saturate(instMul(mpeg_rgb_transform, yuv_input));
}

vec3 toRGB_bt709_fullrange(vec3 yuv_input)
{
	const mat3 bt709full_rgb_transform = mat3(
		vec3(+1.000, +1.000, +1.000),
		vec3(+0.000, -0.13397432 / 0.7152, +1.8556),
		vec3(+1.5748, -0.33480248 / 0.7152 , +0.000)
	);
	return saturate(instMul(bt709full_rgb_transform, yuv_input));
}

vec3 toRGB_bt709_tvrange(vec3 yuv_input)
{
	const mat3 bt709tv_rgb_transform = mat3(
		vec3(+255.0 / 219.0, +255.0 / 219.0, +255.0 / 219.0),
		vec3(+0.000, -17.0817258 / 80.1024 , +236.589 / 112.0),
		vec3(+200.787 / 112.0, -42.6873162 / 80.1024 , +0.000)
	);
	return saturate(instMul(bt709tv_rgb_transform, yuv_input));
}


// Gamma functions ------------------------------------------------

// gamma encoded --> linear:

// sRGB
vec3 toLinear(vec3 _rgb)
{
	bvec3 cutoff = lessThan(_rgb.rgb, vec3_splat(0.04045));
	vec3 higher = pow((_rgb.rgb + vec3_splat(0.055)) / vec3_splat(1.055), vec3_splat(2.4));
	vec3 lower = _rgb.rgb / vec3_splat(12.92);

	return saturate(mix(higher, lower, cutoff));
}

vec3 toLinearSMPTE170M(vec3 _rgb)
{
	bvec3 cutoff = lessThan(_rgb.rgb, vec3_splat(0.0812));
	vec3 higher = pow((_rgb.rgb + vec3_splat(0.099)) / vec3_splat(1.099), (vec3_splat(1.0) / vec3_splat(0.45)));
	vec3 lower = _rgb.rgb / vec3_splat(4.5);

	return saturate(mix(higher, lower, cutoff));
}

vec3 toLinear2pt2(vec3 _rgb)
{
	return saturate(pow(_rgb.rgb, vec3_splat(2.2)));
}

// Microsoft says PAL uses a pure 2.8 gamma curve. See: https://learn.microsoft.com/en-us/windows/win32/api/mfobjects/ne-mfobjects-mfvideotransferfunction
// ffmpeg thinks there *should* be a linear toe slope, but uses a pure curve since they cannot find any documentation for it. See: https://github.com/FFmpeg/FFmpeg/blob/master/libavfilter/vf_colorspace.c#L162
// In any event, Poynton says 2.8 is "unrealistically high" and PAL CRT units did not really behave like that.
// PAL switched to the SMPTE170M function in 2005 (see BT1700)
vec3 toLinear2pt8(vec3 _rgb)
{
	return saturate(pow(_rgb.rgb, vec3_splat(2.8)));
}

// This is an unprincipled, bespoke gamma function that "looks good" with FF7 videos, while all other options are problematic:
//   - Functions with toe slopes cause banding near black in these videos.
//   - A pure 2.2 power function loses details in shadow to darkness.
//   - A pure 2.0 power function blows out highlights.
// While unmoored from any theoretical or mathematical justification, this function avoids all those problems.
vec3 toLinearToelessSRGB(vec3 _rgb)
{
	vec3 twoPtwo = toLinear2pt2(_rgb);
	vec3 sRGB = toLinear(_rgb);
	bvec3 useSRGB = lessThan(sRGB, twoPtwo);
	vec3 proportion = pow(_rgb / vec3_splat(0.389223), vec3_splat(1.0 / 2.2));
	vec3 merged = mix(twoPtwo, sRGB, proportion);
	return saturate(mix(merged, sRGB, useSRGB));
}

// linear --> gamma encoded:

// sRGB
vec3 toGamma(vec3 _rgb)
{
	bvec3 cutoff = lessThan(_rgb.rgb, vec3_splat(0.0031308));
	vec3 higher = vec3_splat(1.055) * pow(_rgb.rgb, vec3_splat(1.0/2.4)) - vec3_splat(0.055);
	vec3 lower = _rgb.rgb * vec3_splat(12.92);

	return saturate(mix(higher, lower, cutoff));
}

// See https://github.com/Microsoft/DirectX-Graphics-Samples/blob/master/MiniEngine/Core/Shaders/ColorSpaceUtility.hlsli#L75
// max_nits should be "the brightness level that SDR 'white' is rendered at within an HDR monitor" (probably 100-200ish)
// Google Chrome uses a default of 200 if autodetection fails.
vec3 ApplyREC2084Curve(vec3 _color, float max_nits)
{
	// reference PQ OETF will yield reference OOTF when
	// displayed on  a reference monitor employing EOTF

	float m1 = 2610.0 / 4096.0 * 1.0 / 4;
	float m2 = 2523.0 / 4096.0 * 128;
	float c1 = 3424.0 / 4096.0;
	float c2 = 2413.0 / 4096.0 * 32;
	float c3 = 2392.0 / 4096.0 * 32;

	vec3 Lp = pow(_color * (vec3_splat(max_nits)/vec3_splat(10000.0)), vec3_splat(m1));
	return saturate(pow((c1 + c2 * Lp) / (vec3_splat(1.0) + c3 * Lp), vec3_splat(m2)));
}


// Gamut conversions ---------------------------------------------
// These functions all take a linear RGB input and produce a linear RGB output.
// Mathematically, they are equivalent to:
//   1. Convert linear RGB to XYZ using the source gamut's red/green/blue points
//   2. Do a gamut conversion from the source gamut to the destination gamut
//   3. Covert XYZ to linear RGB using the destination gamut's red/green/blue points
// But all of that has been pre-computed into a single matrix multiply operation.

// Note: sRGB is the same gamut as rec709 video.

// Note: High precision values are used for the "D65" whitepoint. (x=0.312713, y=0.329016)

// Note: There are (at least) three different whitepoints that are all referred to as "D93"/"9300K."
// The one used here is 9300K+27mpcd (x=0.281, y=0.311), which is what NTSC-J television sets used.

// Most of the gamut conversion matrices have been replacved with LUTs.
// We will want to bring them back for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.

// To rec2020:
// See https://github.com/Microsoft/DirectX-Graphics-Samples/blob/master/MiniEngine/Core/Shaders/ColorSpaceUtility.hlsli#L120
vec3 convertGamut_SRGBtoREC2020(vec3 rgb_input)
{
	mat3 toRec2020 = mat3(
		vec3(+0.628252390228217, +0.069018748494509, +0.016358741846493),
		vec3(+0.329243684863216, +0.9191169021082, +0.087837787397663),
		vec3(+0.042503924908568, +0.011864349397292, +0.895803470755843)
	);
	return saturate(instMul(toRec2020, rgb_input));
}

vec3 convertGamut_NTSCJtoREC2020(vec3 rgb_input)
{
	mat3 NTSCJtoRec2020 = mat3(
		vec3(+0.835314787642499, +0.064086581191406, -0.00258827855966),
		vec3(+0.139190018780176, +0.859494098117681, +0.036362217824334),
		vec3(+0.025495200617381, +0.076419362630435, +0.966226011255509)
	);
	return saturate(instMul(NTSCJtoRec2020, rgb_input));
}


// This is a generic 3D LUT function.
// We're using it to do gamut conversions when a gamut compression mapping algorithm is necessary to avoid losing detail to clipping.
// Since that's waaaay too compute heavy, we precompute it, then use a LUT.
// Renderer::AssignGamutLUT() in renderer.cpp is in charge of making sure the correct LUT is bound.
// Expects:
// - coords 0,0 in the upper left corner
// - 4096x64 dimensions
// - linear rgb (unlike most other textures BGFX is NOT doing a linearize for us; we expect the image is linear to start with)
// - black in the upper left corner
// - green on the vertical axis
// - red on the small horizontal axis
// - blue on the large horizontal axis

vec3 GamutLUT(vec3 rgb_input)
{
	vec3 temp = saturate(rgb_input) * vec3_splat(63.0);
	vec3 floors = floor(temp);
	vec3 ceils = ceil(temp);
	vec3 ceilweights = saturate(temp - floors);

	// driver might not correctly sample a 1.0 coordinate
	// so we are going to add a just-under-half-step offset to red and green, then increase their divisors by 1
	// This should get us a slightly lower coordinate within the same pixel
	floors = floors + vec3(0.4999, 0.4999, 0.0);
	ceils = ceils + vec3(0.4999, 0.4999, 0.0);
	floors = floors / vec3(4096.0, 64.0, 64.0);
	ceils = ceils / vec3(4096.0, 64.0, 64.0);

	vec3 RfGfBf = (texture2D(tex_10, vec2(floors.b + floors.r, floors.g))).xyz;
	vec3 RfGfBc = (texture2D(tex_10, vec2(ceils.b + floors.r, floors.g))).xyz;
	vec3 RfGcBf = (texture2D(tex_10, vec2(floors.b + floors.r, ceils.g))).xyz;
	vec3 RfGcBc = (texture2D(tex_10, vec2(ceils.b + floors.r, ceils.g))).xyz;
	vec3 RcGfBf = (texture2D(tex_10, vec2(floors.b + ceils.r, floors.g))).xyz;
	vec3 RcGfBc = (texture2D(tex_10, vec2(ceils.b + ceils.r, floors.g))).xyz;
	vec3 RcGcBf = (texture2D(tex_10, vec2(floors.b + ceils.r, ceils.g))).xyz;
	vec3 RcGcBc = (texture2D(tex_10, vec2(ceils.b + ceils.r, ceils.g))).xyz;

	vec3 RfGf = mix(RfGfBf, RfGfBc, vec3_splat(ceilweights.b));
	vec3 RfGc = mix(RfGcBf, RfGcBc, vec3_splat(ceilweights.b));
	vec3 RcGf = mix(RcGfBf, RcGfBc, vec3_splat(ceilweights.b));
	vec3 RcGc = mix(RcGcBf, RcGcBc, vec3_splat(ceilweights.b));

	vec3 Rf = mix(RfGf, RfGc, vec3_splat(ceilweights.g));
	vec3 Rc = mix(RcGf, RcGc, vec3_splat(ceilweights.g));

	vec3 outcolor = mix(Rf, Rc, vec3_splat(ceilweights.r));

	return outcolor;
}

// Dithering ---------------------------------------------

// Apply Martin Roberts' quasirandom dithering scaled below a specified level of precision.
// See https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
// pixelval: float (range 0-1) pixel color trio.
// coords: float (range 0-1) pixel coordinates, i.e., v_texcoord0.xy
// ydims: integer dimensions of first channel's texture
// udims & vdims: integer dimensions of first second and third channels' textures (may differ from ydim for various yuv formats)
// scale_divisor: step size divisor to scale the dithering to fit within. E.g., use 255.0 for dithering 8-bit values.
// xyoffset: value to add to x & y coords. Should be at least 1 to avoid x=0 and y=0. Should be different if the same input is dithered twice.
// (This function will be used twice if TV-range video is dithered for range expansion, then again for HDR bit depth increase.)
vec3 QuasirandomDither(vec3 pixelval, vec2 coords, ivec2 ydims, ivec2 udims, ivec2 vdims, float scale_divisor, float xyoffset)
{
	// get integer range x,y coords for this pixel
	// invert one axis for u and the other axis for v to decouple dither patterns across channels
	// see https://blog.kaetemi.be/2015/04/01/practical-bayer-dithering/
	// add 1 to avoid x=0 and y=0
	vec3 xpos = vec3(
		round(float(ydims.x) * coords.x)  + xyoffset,
		round(float(udims.x) * (1.0 - coords.x)) + xyoffset,
		round(float(vdims.x) * coords.x)  + xyoffset
	);
	vec3 ypos = vec3(
		round(float(ydims.y) * coords.y) + xyoffset,
		round(float(udims.y) * coords.y) + xyoffset,
		round(float(vdims.y) * (1.0 - coords.y)) + xyoffset
	);
	// R series magic
	vec3 dither = fract((xpos * vec3_splat(0.7548776662)) + (ypos * vec3_splat(0.56984029)));
	// triangular wave function
	// if exactly 0.5, then pass through so we don't get a 1.0
	bvec3 smallcutoff = lessThan(dither, vec3_splat(0.5));
	bvec3 bigcutoff = greaterThan(dither, vec3_splat(0.5));
	dither = mix(dither, dither * vec3_splat(2.0), smallcutoff);
	dither = mix(dither, vec3_splat(2.0) - (dither * vec3_splat(2.0)), bigcutoff);
	// shift down by half
	dither = dither - vec3_splat(0.5);
	// scale down below the specified step size
	dither = dither / vec3_splat(scale_divisor);
	// add to input
	vec3 tempout = saturate(pixelval + dither);

	// don't dither colors so close to 0 or 1 that dithering is asymmetric
	bvec3 highcutoff = greaterThan(pixelval, vec3_splat(1.0 - (0.5 / scale_divisor)));
	bvec3 lowcutoff = lessThan(pixelval, vec3_splat(0.5 / scale_divisor));
	vec3 outcolor = mix(tempout, pixelval, highcutoff);
	outcolor = mix(outcolor, pixelval, lowcutoff);
	return outcolor;
}

// Fog ---------------------------------------------
vec3 ApplyWorldFog(vec3 color, vec3 viewPosition)
{
	float d = sqrt(dot(viewPosition, viewPosition));
	float s0 = 0;
	float e0 = 10000;

	float density = 0.00025;
	float t = 1 / exp (d * density);

	vec3 fogColor0 = vec3(0.1, 0.1, 0.2);
	vec3 outColor = mix(color * fogColor0, color, t);

	float e1 = 15000;
	float t2 = 1.0 - saturate((d - e0) / e1);
	outColor *= t2;

	return outColor;
}

// Spherical world  ---------------------------------------------
#define cplx vec2
#define cplx_new(re, im) vec2(re, im)
#define cplx_re(z) z.x
#define cplx_im(z) z.y
#define cplx_exp(z) (exp(z.x) * cplx_new(cos(z.y), sin(z.y)))
#define cplx_scale(z, scalar) (z * scalar)
#define cplx_abs(z) (sqrt(z.x * z.x + z.y * z.y))

vec3 ApplySphericalWorld(vec3 viewPosition, float radiusScale)
{
	vec3 outResult = vec3(0.0, 0.0, 0.0);

	float rp = -250000 * radiusScale;

	vec2 planedir = normalize(vec2(viewPosition.x, viewPosition.z));
	cplx plane = cplx_new(viewPosition.y, sqrt((viewPosition.x) * (viewPosition.x) + (viewPosition.z) * (viewPosition.z)));
	cplx circle = rp * cplx_exp(cplx_scale(plane, 1.0 / rp)) - cplx_new(rp, 0);
	outResult.x = cplx_im(circle) * planedir.x;
	outResult.z = cplx_im(circle) * planedir.y;
	outResult.y = cplx_re(circle);

	return outResult;
}
````

## File: misc/FFNx.def
````
;*****************************************************************************;
;    Copyright (C) 2009 Aali132                                               ;
;    Copyright (C) 2018 quantumpencil                                         ;
;    Copyright (C) 2018 Maxime Bacoux                                         ;
;    Copyright (C) 2020 myst6re                                               ;
;    Copyright (C) 2020 Chris Rizzitello                                      ;
;    Copyright (C) 2020 John Pritchard                                        ;
;    Copyright (C) 2025 Julian Xhokaxhiu                                      ;
;                                                                             ;
;    This file is part of FFNx                                                ;
;                                                                             ;
;    FFNx is free software: you can redistribute it and/or modify             ;
;    it under the terms of the GNU General Public License as published by     ;
;    the Free Software Foundation, either version 3 of the License            ;
;                                                                             ;
;    FFNx is distributed in the hope that it will be useful,                  ;
;    but WITHOUT ANY WARRANTY; without even the implied warranty of           ;
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            ;
;    GNU General Public License for more details.                             ;
;*****************************************************************************;

LIBRARY FFNx.dll
EXPORTS
; Required by FF8 2000 injection. Ordinal 5 is required in order to inject as eax.dll
EAXDirectSoundCreate @5
; Required for the Steam driver injection
dotemuRegOpenKeyExA
dotemuRegCloseKey
dotemuRegFlushKey
dotemuRegDeleteValueA
dotemuRegSetValueExA
dotemuRegQueryValueExA
dotemuCreateFileA
dotemuGetDriveTypeA
dotemuDeleteFileA
; Required by FF7 DLL load injection
new_dll_graphics_driver
; FFNx APIs
nxRegisterMouseListener
nxRegisterKeyListener
````

## File: misc/FFNx.field.shadow.frag
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input v_position0, v_color0, v_shadow0

#include <bgfx/bgfx_shader.sh>
#define FIELD_SHADOW 1
#include "FFNx.pcf.sh"

uniform vec4 lightingDebugData;

// ---
#define isShowWalkmeshEnabled lightingDebugData.y > 0.0

void main()
{
    // Shadow UV
    vec4 shadowUv = v_shadow0  / v_shadow0.w;

    // Shadow Factor
    float shadowFactor = sampleShadowMapPCF7x7(shadowUv.xyz, v_position0.xyz);
    float shadowOcclusion = fieldShadowData.x;
    shadowFactor = shadowOcclusion + (1.0 - shadowOcclusion) * shadowFactor;

    if(isShowWalkmeshEnabled)
    {
        gl_FragColor = vec4(v_color0.rgb * shadowFactor, 1.0);
    }
    else
    {
        gl_FragColor = vec4(0.0, 0.0, 0.0, mix(0.0, 1.0 -  shadowFactor, v_color0.a));
    }

#if BGFX_SHADER_LANGUAGE_HLSL > 400
    // Offsets depth to prevent some weird occlusion problems with field 2D tiles
    float depthOffset = 0.0075;
    gl_FragDepth =  (1.0 + depthOffset) * gl_FragCoord.z - depthOffset;
#endif
}
````

## File: misc/FFNx.field.shadow.vert
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input a_position, a_color0
$output v_position0, v_color0, v_shadow0

#include <bgfx/bgfx_shader.sh>

uniform mat4 d3dViewport;
uniform mat4 d3dProjection;
uniform mat4 worldView;
uniform mat4 lightViewProjTexMatrix;

void main()
{
    v_position0 = vec4(a_position.xyz, 1.0);
    v_color0 = a_color0;
    v_shadow0 = mul(mul(lightViewProjTexMatrix, worldView), v_position0);
    gl_Position = mul(mul(d3dViewport, mul(d3dProjection, worldView)), v_position0);
}
````

## File: misc/FFNx.frag
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input v_color0, v_texcoord0, v_position0, v_normal0

#include <bgfx/bgfx_shader.sh>
#include "FFNx.common.sh"

SAMPLER2D(tex_0, 0);
SAMPLER2D(tex_1, 1);
SAMPLER2D(tex_2, 2);

uniform mat4 invViewMatrix;

uniform vec4 VSFlags;
uniform vec4 FSAlphaFlags;
uniform vec4 FSMiscFlags;
uniform vec4 FSHDRFlags;
uniform vec4 FSTexFlags;
uniform vec4 WMFlags;
uniform vec4 FSMovieFlags;
uniform vec4 TimeColor;
uniform vec4 TimeData;
uniform vec4 gameLightingFlags;
uniform vec4 gameGlobalLightColor;
uniform vec4 gameLightColor1;
uniform vec4 gameLightColor2;
uniform vec4 gameLightColor3;
uniform vec4 gameLightDir1;
uniform vec4 gameLightDir2;
uniform vec4 gameLightDir3;
uniform vec4 gameScriptedLightColor;

#define isTLVertex VSFlags.x > 0.0
#define isFBTexture VSFlags.z > 0.0
#define isTexture VSFlags.w > 0.0
// ---
#define inAlphaRef FSAlphaFlags.x

#define isAlphaNever abs(FSAlphaFlags.y - 0.0) < 0.00001
#define isAlphaLess abs(FSAlphaFlags.y - 1.0) < 0.00001
#define isAlphaEqual abs(FSAlphaFlags.y - 2.0) < 0.00001
#define isAlphaLEqual abs(FSAlphaFlags.y - 3.0) < 0.00001
#define isAlphaGreater abs(FSAlphaFlags.y - 4.0) < 0.00001
#define isAlphaNotEqual abs(FSAlphaFlags.y - 5.0) < 0.00001
#define isAlphaGEqual abs(FSAlphaFlags.y - 6.0) < 0.00001

#define doAlphaTest FSAlphaFlags.z > 0.0


// ---
#define isFullRange FSMiscFlags.x > 0.0
#define isYUV FSMiscFlags.y > 0.0
#define modulateAlpha FSMiscFlags.z > 0.0
#define isMovie FSMiscFlags.w > 0.0

#define isHDR FSHDRFlags.x > 0.0
#define monitorNits FSHDRFlags.y

#define doGamutOverride FSHDRFlags.z > 0.0


#define isBT601ColorMatrix abs(FSMovieFlags.x - 0.0) < 0.00001
#define isBT709ColorMatrix abs(FSMovieFlags.x - 1.0) < 0.00001
#define isBRG24ColorMatrix abs(FSMovieFlags.x - 2.0) < 0.00001

#define isSRGBColorGamut abs(FSMovieFlags.y - 0.0) < 0.00001
#define isNTSCJColorGamut abs(FSMovieFlags.y - 1.0) < 0.00001
#define isSMPTECColorGamut abs(FSMovieFlags.y - 2.0) < 0.00001
#define isEBUColorGamut abs(FSMovieFlags.y - 3.0) < 0.00001

#define isSRGBGamma abs(FSMovieFlags.z - 0.0) < 0.00001
#define is2pt2Gamma abs(FSMovieFlags.z - 1.0) < 0.00001
#define is170MGamma abs(FSMovieFlags.z - 2.0) < 0.00001
#define isToelessSRGBGamma abs(FSMovieFlags.z - 3.0) < 0.00001
#define is2pt8Gamma abs(FSMovieFlags.z - 4.0) < 0.00001

#define isOverallSRGBColorGamut abs(FSMovieFlags.w - 0.0) < 0.00001
#define isOverallNTSCJColorGamut abs(FSMovieFlags.w - 1.0) < 0.00001

#define isTimeEnabled TimeData.x > 0.0
#define isTimeFilterEnabled TimeData.x > 0.0 && TimeData.y > 0.0

#define gameLightingMode gameLightingFlags.x
#define GAME_LIGHTING_PER_PIXEL 2

#define isFogEnabled WMFlags.y > 0.0

void main()
{
    vec4 color = vec4(toLinear(v_color0.rgb), v_color0.a);

    if (isTexture)
    {
        if (isYUV)
        {
            vec3 yuv = vec3(
                texture2D(tex_0, v_texcoord0.xy).r,
                texture2D(tex_1, v_texcoord0.xy).r,
                texture2D(tex_2, v_texcoord0.xy).r
            );

            if (!(isFullRange)){
                // dither prior to range conversion
                ivec2 ydimensions = textureSize(tex_0, 0);
                ivec2 udimensions = textureSize(tex_1, 0);
                ivec2 vdimensions = textureSize(tex_2, 0);
                yuv = QuasirandomDither(yuv, v_texcoord0.xy, ydimensions, udimensions, vdimensions, 255.0, 1.0);
                // clamp back to tv range
                yuv = clamp(yuv, vec3_splat(16.0/255.0), vec3(235.0/255.0, 240.0/255.0, 240.0/255.0));
            }

            if (isBT601ColorMatrix){
                yuv.g = yuv.g - (128.0/255.0);
                yuv.b = yuv.b - (128.0/255.0);
                if (isFullRange){
                    color.rgb = toRGB_bt601_fullrange(yuv);
                }
                else {
                    yuv.r = saturate(yuv.r - (16.0/255.0));
                    color.rgb = toRGB_bt601_tvrange(yuv);
                }
            }
            else if (isBT709ColorMatrix){
                yuv.g = yuv.g - (128.0/255.0);
                yuv.b = yuv.b - (128.0/255.0);
                if (isFullRange){
                    color.rgb = toRGB_bt709_fullrange(yuv);
                }
                else {
                    yuv.r = saturate(yuv.r - (16.0/255.0));
                    color.rgb = toRGB_bt709_tvrange(yuv);
                }
            }
            else if (isBRG24ColorMatrix){
                color.rgb = yuv;
            }
            // default should be unreachable
            else {
                color.rgb = vec3_splat(0.5);
            }

            // Use a different inverse gamma function depending on the FMV's metadata
            if (isToelessSRGBGamma){
                color.rgb = toLinearToelessSRGB(color.rgb);
            }
            else if (is2pt2Gamma){
                color.rgb = toLinear2pt2(color.rgb);
            }
            else if (is170MGamma){
                color.rgb = toLinearSMPTE170M(color.rgb);
            }
            else if (is2pt8Gamma){
                color.rgb = toLinear2pt8(color.rgb);
            }
            else {
                color.rgb = toLinear(color.rgb);
            }

            // Convert gamut to BT709/SRGB or NTSC-J, depending on what we're going to do in post.
            // This approach has the unfortunate drawback of resulting in two gamut conversions for some inputs.
            // But it seems to be the only way to avoid breaking stuff that has expectations about the texture colors (like animated field textures).
            // Use of NTSC-J as the source gamut  for the original videos and their derivatives is a *highly* probable guess:
            // It looks correct, is consistent with the PS1's movie decoder chip's known use of BT601 color matrix, and conforms with Japanese TV standards of the time.
            if (isOverallNTSCJColorGamut){
                // do nothing for NTSC-J
                if ((isSRGBColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
                    color.rgb = GamutLUT(color.rgb);
                    // dither after the LUT operation
                    ivec2 dimensions = textureSize(tex_0, 0);
                    color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
                }
                // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
            }
            // overall sRGB
            else {
                // do nothing for sRGB
                if ((isNTSCJColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
                    color.rgb = GamutLUT(color.rgb);
                    // dither after the LUT operation
                    ivec2 dimensions = textureSize(tex_0, 0);
                    color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
                }
                // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
            }

            color.a = 1.0;
        }
        else
        {
            vec4 texture_color = texture2D(tex_0, v_texcoord0.xy);

            if (doAlphaTest)
            {
                //NEVER
                if (isAlphaNever) discard;

                //LESS
                if (isAlphaLess)
                {
                    if (!(texture_color.a < inAlphaRef)) discard;
                }

                //EQUAL
                if (isAlphaEqual)
                {
                    if (!(texture_color.a == inAlphaRef)) discard;
                }

                //LEQUAL
                if (isAlphaLEqual)
                {
                    if (!(texture_color.a <= inAlphaRef)) discard;
                }

                //GREATER
                if (isAlphaGreater)
                {
                    if (!(texture_color.a > inAlphaRef)) discard;
                }

                //NOTEQUAL
                if (isAlphaNotEqual)
                {
                    if (!(texture_color.a != inAlphaRef)) discard;
                }

                //GEQUAL
                if (isAlphaGEqual)
                {
                    if (!(texture_color.a >= inAlphaRef)) discard;
                }
            }

            if (isFBTexture)
            {
                if(all(equal(texture_color.rgb,vec3_splat(0.0)))) discard;

                // This was previously in gamma space, so linearize again.
                texture_color.rgb = toLinear(texture_color.rgb);
            }
            // This stanza currently does nothing because there's no way to set doGamutOverride.
            // Hopefully the future will bring a way to set this for types of textures (e.g., world, model, field, spell, etc.) or even for individual textures based on metadata.
            else if (doGamutOverride){
                texture_color.rgb = GamutLUT(texture_color.rgb);
                ivec2 dimensions = textureSize(tex_0, 0);
                texture_color.rgb = QuasirandomDither(texture_color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 1.0);
                // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
            }

            if (isMovie) texture_color.a = 1.0;

            if (texture_color.a == 0.0) discard;

            if (modulateAlpha) color *= texture_color;
            else
            {
                color.rgb *= texture_color.rgb;
			    color.a = texture_color.a;
            }
        }
    }

    if (isTimeFilterEnabled) color.rgb *= TimeColor.rgb;

    if (!(isTLVertex) && isFogEnabled) color.rgb = ApplyWorldFog(color.rgb, v_position0.xyz);

    // return to gamma space so we can do alpha blending the same way FF7/8 did.
    color.rgb = toGamma(color.rgb);

    // In this default shader, lighting is applied in gamma space so that it does better match the original lighting
    if (gameLightingMode == GAME_LIGHTING_PER_PIXEL)
    {
        vec3 normal = normalize(v_normal0);
        vec3 worldNormal = mul(invViewMatrix, vec4(normal, 0)).xyz;
        float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
        float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
        float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
        vec3 light1Ambient = gameLightColor1.rgb * dotLight1 * dotLight1;
        vec3 light2Ambient = gameLightColor2.rgb * dotLight2 * dotLight2;
        vec3 light3Ambient = gameLightColor3.rgb * dotLight3 * dotLight3;
        vec3 lightAmbient = gameScriptedLightColor.rgb * (gameGlobalLightColor.rgb + light1Ambient + light2Ambient + light3Ambient);
        color.rgb *= gameGlobalLightColor.w * lightAmbient;
    }
    
    gl_FragColor = color;
}
````

## File: misc/FFNx.lighting.frag
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0

#include <bgfx/bgfx_shader.sh>
#include "FFNx.lighting.sh"

// TEX_YUV
SAMPLER2D(tex_0, 0); // Y
SAMPLER2D(tex_1, 1); // U
SAMPLER2D(tex_2, 2); // V
// TEX_NML
SAMPLER2D(tex_5, 5);
// TEX_PBR
SAMPLER2D(tex_6, 6);

uniform vec4 VSFlags;
uniform vec4 FSAlphaFlags;
uniform vec4 FSMiscFlags;
uniform vec4 FSHDRFlags;
uniform vec4 FSTexFlags;
uniform vec4 WMFlags;
uniform vec4 FSMovieFlags;

uniform vec4 lightingSettings;
uniform vec4 lightingDebugData;
uniform vec4 materialData;
uniform vec4 materialScaleData;
uniform vec4 iblData;
uniform vec4 gameLightingFlags;
uniform vec4 gameGlobalLightColor;
uniform vec4 gameLightColor1;
uniform vec4 gameLightColor2;
uniform vec4 gameLightColor3;
uniform vec4 gameLightDir1;
uniform vec4 gameLightDir2;
uniform vec4 gameLightDir3;
uniform vec4 gameScriptedLightColor;

#define isTLVertex VSFlags.x > 0.0
#define isFBTexture VSFlags.z > 0.0
#define isTexture VSFlags.w > 0.0
// ---
#define inAlphaRef FSAlphaFlags.x

#define isAlphaNever abs(FSAlphaFlags.y - 0.0) < 0.00001
#define isAlphaLess abs(FSAlphaFlags.y - 1.0) < 0.00001
#define isAlphaEqual abs(FSAlphaFlags.y - 2.0) < 0.00001
#define isAlphaLEqual abs(FSAlphaFlags.y - 3.0) < 0.00001
#define isAlphaGreater abs(FSAlphaFlags.y - 4.0) < 0.00001
#define isAlphaNotEqual abs(FSAlphaFlags.y - 5.0) < 0.00001
#define isAlphaGEqual abs(FSAlphaFlags.y - 6.0) < 0.00001

#define doAlphaTest FSAlphaFlags.z > 0.0

// ---
#define isFullRange FSMiscFlags.x > 0.0
#define isYUV FSMiscFlags.y > 0.0
#define modulateAlpha FSMiscFlags.z > 0.0
#define isMovie FSMiscFlags.w > 0.0

#define isHDR FSHDRFlags.x > 0.0
#define monitorNits FSHDRFlags.y

#define doGamutOverride FSHDRFlags.z > 0.0

#define isBT601ColorMatrix abs(FSMovieFlags.x - 0.0) < 0.00001
#define isBT709ColorMatrix abs(FSMovieFlags.x - 1.0) < 0.00001
#define isBRG24ColorMatrix abs(FSMovieFlags.x - 2.0) < 0.00001

#define isSRGBColorGamut abs(FSMovieFlags.y - 0.0) < 0.00001
#define isNTSCJColorGamut abs(FSMovieFlags.y - 1.0) < 0.00001
#define isSMPTECColorGamut abs(FSMovieFlags.y - 2.0) < 0.00001
#define isEBUColorGamut abs(FSMovieFlags.y - 3.0) < 0.00001

#define isSRGBGamma abs(FSMovieFlags.z - 0.0) < 0.00001
#define is2pt2Gamma abs(FSMovieFlags.z - 1.0) < 0.00001
#define is170MGamma abs(FSMovieFlags.z - 2.0) < 0.00001
#define isToelessSRGBGamma abs(FSMovieFlags.z - 3.0) < 0.00001
#define is2pt8Gamma abs(FSMovieFlags.z - 4.0) < 0.00001

#define isOverallSRGBColorGamut abs(FSMovieFlags.w - 0.0) < 0.00001
#define isOverallNTSCJColorGamut abs(FSMovieFlags.w - 1.0) < 0.00001

// ---
#define debugOutput lightingDebugData.z
#define DEBUG_OUTPUT_DISABLED 0
#define DEBUG_OUTPUT_COLOR 1
#define DEBUG_OUTPUT_NORMAL 2
#define DEBUG_OUTPUT_ROUGHNESS 3
#define DEBUG_OUTPUT_METALLIC 4
#define DEBUG_OUTPUT_AO 5
#define DEBUG_OUTPUT_SPECULAR 6
#define DEBUG_OUTPUT_IBL_SPECULAR 7
#define DEBUG_OUTPUT_IBL_DIFFUSE 8

#define isPbrTextureEnabled lightingSettings.x > 0.0
#define isEnvironmentLightingEnabled lightingSettings.y > 0.0

#define isFogEnabled WMFlags.y > 0.0

#define isNmlTextureLoaded FSTexFlags.x > 0.0
#define isPbrTextureLoaded FSTexFlags.y > 0.0
#define isIblTextureLoaded FSTexFlags.z > 0.0

#define gameLightingMode gameLightingFlags.x
#define GAME_LIGHTING_PER_PIXEL 2

void main()
{
    vec4 color = v_color0;
    vec4 color_nml = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 color_pbr = vec4(0.0, 0.0, 0.0, 0.0);

    if (isTexture)
    {
        if (isYUV)
        {
            vec3 yuv = vec3(
                texture2D(tex_0, v_texcoord0.xy).r,
                texture2D(tex_1, v_texcoord0.xy).r,
                texture2D(tex_2, v_texcoord0.xy).r
            );

            if (!(isFullRange)){
                // dither prior to range conversion
                ivec2 ydimensions = textureSize(tex_0, 0);
                ivec2 udimensions = textureSize(tex_1, 0);
                ivec2 vdimensions = textureSize(tex_2, 0);
                yuv = QuasirandomDither(yuv, v_texcoord0.xy, ydimensions, udimensions, vdimensions, 255.0, 1.0);
                // clamp back to tv range
                yuv = clamp(yuv, vec3_splat(16.0/255.0), vec3(235.0/255.0, 240.0/255.0, 240.0/255.0));
            }

            if (isBT601ColorMatrix){
                yuv.g = yuv.g - (128.0/255.0);
                yuv.b = yuv.b - (128.0/255.0);
                if (isFullRange){
                    color.rgb = toRGB_bt601_fullrange(yuv);
                }
                else {
                    yuv.r = saturate(yuv.r - (16.0/255.0));
                    color.rgb = toRGB_bt601_tvrange(yuv);
                }

            }
            else if (isBT709ColorMatrix){
                yuv.g = yuv.g - (128.0/255.0);
                yuv.b = yuv.b - (128.0/255.0);
                if (isFullRange){
                    color.rgb = toRGB_bt709_fullrange(yuv);
                }
                else {
                    yuv.r = saturate(yuv.r - (16.0/255.0));
                    color.rgb = toRGB_bt709_tvrange(yuv);
                }

            }
            else if (isBRG24ColorMatrix){
                color.rgb = yuv;
            }
            // default should be unreachable
            else {
                color.rgb = vec3_splat(0.5);
            }

            // Use a different inverse gamma function depending on the FMV's metadata
            if (isToelessSRGBGamma){
                color.rgb = toLinearToelessSRGB(color.rgb);
            }
            else if (is2pt2Gamma){
                color.rgb = toLinear2pt2(color.rgb);
            }
            else if (is170MGamma){
                color.rgb = toLinearSMPTE170M(color.rgb);
            }
            else if (is2pt8Gamma){
                color.rgb = toLinear2pt8(color.rgb);
            }
            else {
                color.rgb = toLinear(color.rgb);
            }

            // Convert gamut to BT709/SRGB or NTSC-J, depending on what we're going to do in post.
            // This approach has the unfortunate drawback of resulting in two gamut conversions for some inputs.
            // But it seems to be the only way to avoid breaking stuff that has expectations about the texture colors (like animated field textures).
            // Use of NTSC-J as the source gamut  for the original videos and their derivatives is a *highly* probable guess:
            // It looks correct, is consistent with the PS1's movie decoder chip's known use of BT601 color matrix, and conforms with Japanese TV standards of the time.
            if (isOverallNTSCJColorGamut){
                // do nothing for NTSC-J
                if ((isSRGBColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
                    color.rgb = GamutLUT(color.rgb);
                    // dither after the LUT operation
                    ivec2 dimensions = textureSize(tex_0, 0);
                    color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
                }
                // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
            }
            // overall sRGB
            else {
                // do nothing for sRGB
                if ((isNTSCJColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
                    color.rgb = GamutLUT(color.rgb);
                    // dither after the LUT operation
                    ivec2 dimensions = textureSize(tex_0, 0);
                    color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
                }
                // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
            }

            color.a = 1.0;
        }
        else
        {
            vec4 texture_color = texture2D(tex_0, v_texcoord0.xy);

            if (isNmlTextureLoaded) color_nml = texture2D(tex_5, v_texcoord0.xy);
            if (isPbrTextureLoaded) color_pbr = texture2D(tex_6, v_texcoord0.xy);

            if (doAlphaTest)
            {
                //NEVER
                if (isAlphaNever) discard;

                //LESS
                if (isAlphaLess)
                {
                    if (!(texture_color.a < inAlphaRef)) discard;
                }

                //EQUAL
                if (isAlphaEqual)
                {
                    if (!(texture_color.a == inAlphaRef)) discard;
                }

                //LEQUAL
                if (isAlphaLEqual)
                {
                    if (!(texture_color.a <= inAlphaRef)) discard;
                }

                //GREATER
                if (isAlphaGreater)
                {
                    if (!(texture_color.a > inAlphaRef)) discard;
                }

                //NOTEQUAL
                if (isAlphaNotEqual)
                {
                    if (!(texture_color.a != inAlphaRef)) discard;
                }

                //GEQUAL
                if (isAlphaGEqual)
                {
                    if (!(texture_color.a >= inAlphaRef)) discard;
                }
            }

            if (isFBTexture)
            {
                if(all(equal(texture_color.rgb,vec3_splat(0.0)))) discard;

                // This was previously in gamma space, so linearize again.
                texture_color.rgb = toLinear(texture_color.rgb);
            }
            // This stanza currently does nothing because there's no way to set doGamutOverride.
            // Hopefully the future will bring a way to set this for types of textures (e.g., world, model, field, spell, etc.) or even for individual textures based on metadata.
            else if (doGamutOverride){
                texture_color.rgb = GamutLUT(texture_color.rgb);
                ivec2 dimensions = textureSize(tex_0, 0);
                texture_color.rgb = QuasirandomDither(texture_color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 1.0);
                // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
            }

            if (isMovie) texture_color.a = 1.0;

            if (texture_color.a == 0.0) discard;

            if (modulateAlpha) color *= texture_color;
            else
            {
                color.rgb *= texture_color.rgb;
			    color.a = texture_color.a;
            }
        }
    }

    vec3 normal = vec3(0.0, 0.0, 0.0);
    if(isTLVertex)
    {
        gl_FragColor = color;
        if(isTimeFilterEnabled)
        {
            gl_FragColor.rgb *= TimeColor.rgb;
        }
    }
    else
    {
        // Shadow UV
        vec3 shadowUv = v_shadow0.xyz / v_shadow0.w;

        // View Direction
        vec3 viewDir = normalize(-v_position0.xyz);

        // Normal
        normal = normalize(v_normal0);
        if(isNmlTextureLoaded && isPbrTextureEnabled) normal = perturb_normal(normal, v_position0.xyz, color_nml.rgb, v_texcoord0.xy );

        // Roughness
        float perceptualRoughness = materialData.x;
        if(isPbrTextureLoaded && isPbrTextureEnabled) perceptualRoughness = color_pbr.r * materialScaleData.x;
        float roughness = min(max(0.001, perceptualRoughness * perceptualRoughness), 1.0);

        // Metallic
        float metallic = materialData.y;
        if(isPbrTextureLoaded && isPbrTextureEnabled) metallic = color_pbr.g * materialScaleData.y;
        metallic = min(1.0, metallic);

        // Specular (dielectric)
        float specular = materialData.z;
        if(isPbrTextureLoaded && isPbrTextureEnabled) specular = color_pbr.b * materialScaleData.z;
        specular = min(1.0, specular);

        // Ambient Occlusion
        float ao = 1.0;
        if(isPbrTextureLoaded && isPbrTextureEnabled) ao = color_pbr.a;

        // Luminance
        vec3 luminance = calcLuminance(color.rgb, v_position0.xyz, viewDir, normal, perceptualRoughness, roughness, metallic, specular, shadowUv);

        // Indirect Luminance
        vec3 indirectLuminance = vec3_splat(0.0);
        vec3 specularIbl = vec3_splat(0.0);
        vec3 diffuseIbl = vec3_splat(0.0);
        if(isIblTextureLoaded && isEnvironmentLightingEnabled)
        {
            // Specular IBL
            vec3 R = mul(invViewMatrix, vec4(reflect(-viewDir, normal), 0)).xyz;
            float iblMipCount = iblData.x;
            float iblLod = CalcMipmapFromRoughness(roughness, iblMipCount);
            specularIbl = textureCubeLod(tex_7, R, iblLod).rgb;

            // Diffuse IBL
            vec3 worldNormal = mul(invViewMatrix, vec4(normal, 0)).xyz;
            diffuseIbl = textureCube(tex_8, worldNormal).rgb;

            indirectLuminance = CalcIblIndirectLuminance(color.rgb, specularIbl, diffuseIbl, viewDir, normal, roughness, metallic, specular, ao);
        }
        else
        {
            indirectLuminance = CalcConstIndirectLuminance(color.rgb);
        }

        if(debugOutput == DEBUG_OUTPUT_COLOR)
        {
            gl_FragColor = color;
        }
        else if(debugOutput == DEBUG_OUTPUT_NORMAL)
        {
            gl_FragColor = vec4(0.5 * normal + 0.5, 1.0);
        }
        else if(debugOutput == DEBUG_OUTPUT_ROUGHNESS)
        {
            gl_FragColor = vec4(vec3_splat(perceptualRoughness), 1.0);
        }
        else if(debugOutput == DEBUG_OUTPUT_METALLIC)
        {
            gl_FragColor = vec4(vec3_splat(metallic), 1.0);
        }
        else if(debugOutput == DEBUG_OUTPUT_AO)
        {
            gl_FragColor = vec4(vec3_splat(ao), 1.0);
        }
        else if(debugOutput == DEBUG_OUTPUT_SPECULAR)
        {
            gl_FragColor = vec4(vec3_splat(specular), 1.0);
        }
        else if(debugOutput == DEBUG_OUTPUT_IBL_SPECULAR)
        {
            gl_FragColor = vec4(specularIbl, 1.0);
        }
        else if(debugOutput == DEBUG_OUTPUT_IBL_DIFFUSE)
        {
            gl_FragColor = vec4(diffuseIbl, 1.0);
        }
        else
        {
            gl_FragColor = vec4(luminance + indirectLuminance, color.a);
        }

        if (isFogEnabled && debugOutput == DEBUG_OUTPUT_DISABLED ) gl_FragColor.rgb = ApplyWorldFog(gl_FragColor.rgb, v_position0.xyz);
    }

    if(!(isTLVertex) && gameLightingMode == GAME_LIGHTING_PER_PIXEL && debugOutput == DEBUG_OUTPUT_DISABLED)
    {
        vec3 worldNormal = mul(invViewMatrix, vec4(normal, 0)).xyz;
        float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
        float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
        float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
        vec3 light1Ambient = toLinear(gameLightColor1.rgb) * dotLight1 * dotLight1;
        vec3 light2Ambient = toLinear(gameLightColor2.rgb) * dotLight2 * dotLight2;
        vec3 light3Ambient = toLinear(gameLightColor3.rgb) * dotLight3 * dotLight3;
        vec3 lightAmbient = toLinear(gameScriptedLightColor.rgb) * (toLinear(gameGlobalLightColor.rgb) + light1Ambient + light2Ambient + light3Ambient);
        gl_FragColor.rgb *= gameGlobalLightColor.w * lightAmbient;
    }

    // return to gamma space so we can do alpha blending the same way FF7/8 did.
    gl_FragColor.rgb = toGamma(gl_FragColor.rgb);
}
````

## File: misc/FFNx.lighting.sh
````bash
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "FFNx.pcf.sh"
#include "FFNx.common.sh"

// Specular IBL cubemap
SAMPLERCUBE(tex_7, 7);
// Diffuse IBL cubemap
SAMPLERCUBE(tex_8, 8);
// BRDF
SAMPLER2D(tex_9, 9);

uniform vec4 lightDirData;
uniform vec4 lightData;
uniform vec4 ambientLightData;
uniform vec4 TimeColor;
uniform vec4 TimeData;

#define isTimeEnabled TimeData.x > 0.0
#define isTimeFilterEnabled TimeData.x > 0.0 && TimeData.y > 0.0

#define INV_PI 0.31831

// Normal Mapping Without Precomputed Tangents
// http://www.thetenthplanet.de/archives/1180
mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );

    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

    // construct a scale-invariant frame
    float invmax = inversesqrt(max( dot(T,T), dot(B,B)));

    return transpose(mat3(T * invmax, B * invmax, N));
}

vec3 perturb_normal(vec3 N, vec3 V, vec3 normalmap, vec2 texcoord)
{
    // assume N, the interpolated vertex normal and
    // V, the view vector (vertex to eye)
    vec3 normalMapRemapped = normalmap * 255.0/127.0 - 128.0/127.0;

    // Blend tangent space normal at uv mirror edges to prevent discontinuities
    float blendRange = 0.1;
    float borderCoeff_u = fract(texcoord.x);
    float borderCoeff_v = fract(texcoord.y);
    borderCoeff_u = borderCoeff_u < 0.5 ? borderCoeff_u : 1.0 - borderCoeff_u;
    borderCoeff_v = borderCoeff_v < 0.5 ? borderCoeff_v : 1.0 - borderCoeff_v;
    float t_u = min(1.0, borderCoeff_u / blendRange);
    float t_v = min(1.0, borderCoeff_v / blendRange);
    float newNormalMapX = mix(0.0, normalMapRemapped.x, smoothstep(0.0, 1.0, t_u));
    float newNormalMapY = mix(0.0, normalMapRemapped.y, smoothstep(0.0, 1.0, t_v));
    normalMapRemapped = vec3(newNormalMapX, newNormalMapY, sqrt(1.0 - newNormalMapX * newNormalMapX + newNormalMapY * newNormalMapY));

    // Build matrix to transform from tangent to view space
    mat3 TBN = cotangent_frame(N, -V, texcoord);

    return normalize(mul(TBN, normalMapRemapped));
}

vec3 fresnelSchlick(vec3 F0, float cosTheta)
{
    float Fc = pow( 1 - cosTheta, 5 );
	return saturate( 50.0 * F0.g ) * Fc + (1 - Fc) * F0;
}

float normalDistributionGgx(vec3 N, vec3 H, float perceptualRoughness)
{
    float a2     = perceptualRoughness*perceptualRoughness;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = M_PI * denom * denom;

    return num / denom;
}

float visiblilitySchlick(float perceptualRoughness, float NoV, float NoL)
{
	float k = (perceptualRoughness + 1) / 8.0;
	float visSchlickV = NoV * (1 - k) + k;
	float visSchlickL = NoL * (1 - k) + k;
	return 0.25 / (visSchlickV * visSchlickL);
}

vec3 specularCookTorranceBrdf(vec3 F0, vec3 N, vec3 V, vec3 L, float perceptualRoughness, float roughness)
{
    vec3 H = normalize(V + L);
    float dotNV = saturate(dot(N, V)) + 1e-5;
    float dotNL = saturate(dot(N, L));
    float dotVH = saturate(dot(V, H));
    float d = normalDistributionGgx(N, H, roughness);
    float g = visiblilitySchlick(perceptualRoughness, dotNV, dotNL);
    vec3 f = fresnelSchlick(F0, dotVH);
    return d * g * f;
}

float CalcMipmapFromRoughness(float roughness, float mipCount)
{
	float level = 3.0 - 1.15 * log2( roughness );
	return mipCount - 1.0 - level;
}

// Calculates luminance using Physically-Based Rendering (PBR)
// https://learnopengl.com/PBR/Theory
vec3 calcLuminance(vec3 albedo, vec3 viewSpacePosition, vec3 viewDir, vec3 normal, float perceptualRoughness, float roughness, float metallic, float specular, vec3 shadowUv)
{
    float shadowFactor = sampleShadowMapPCF7x7(shadowUv.xyz, viewSpacePosition.xyz);

    // Light
    float lightIntensity = lightData.w;
    vec3 lightColor = toLinear(lightData.rgb);
    if(isTimeEnabled)
    {
        lightColor *= TimeColor.rgb;
    }

    vec3 lightDir = normalize(lightDirData.xyz);

    vec3 F0 = mix(specular * vec3_splat(0.08), albedo, metallic);

    vec3 H = normalize(viewDir + lightDir);
    float dotVH = saturate(dot(viewDir, H));

    // Diffuse
    vec3 diffuseLuminance = (1.0 - metallic) * INV_PI * albedo;

    // Specular
    vec3 specularLuminance = specularCookTorranceBrdf(F0, normal, viewDir, lightDir, perceptualRoughness, roughness);

    // Lambert cosine
    float NdotL = max(0.0, dot(normal, lightDir));

    return shadowFactor * lightIntensity * lightColor * (diffuseLuminance + specularLuminance) * NdotL;
}

vec3 CalcIblIndirectLuminance(vec3 albedo, vec3 specularIbl, vec3 diffuseIbl, vec3 V, vec3 N, float roughness, float metallic, float specular, float ao)
{
    float dotNV = saturate(dot(N, V));
    vec2 envBRDF = texture2D(tex_9, vec2(dotNV, 1.0 - roughness)).xy;

    vec3 F0 = mix(specular * vec3_splat(0.08), albedo, metallic);
    vec3 indirectSpecular = specularIbl * (F0 * envBRDF.x + envBRDF.y);

    vec3 diffuse = diffuseIbl * albedo;
    vec3 indirectDiffuse = (1.0 - metallic) * diffuse;

    vec3 ambientLightColor = toLinear(ambientLightData.rgb);
    float ambientLightIntensity = ambientLightData.w;

    return (indirectDiffuse + indirectSpecular) * ambientLightColor * ambientLightIntensity * ao;
}

vec3 CalcConstIndirectLuminance(vec3 albedo)
{
    // Ambient
    vec3 ambientLightColor = toLinear(ambientLightData.rgb);
    if(isTimeEnabled)
    {
        ambientLightColor *= TimeColor.rgb;
    }

    float ambientLightIntensity = ambientLightData.w;
    vec3 ambient = ambientLightIntensity * ambientLightColor * INV_PI * albedo.rgb;

    return ambient;
}
````

## File: misc/FFNx.lighting.toml
````toml
# FFNx Lighting config file

### HOW TO: ###################################################################
# Sections may be commented by default with an initial # character.
# Remove the initial # character to set the entire sections block and its flags
# -----------------------------------------------------------------------------
###############################################################################

### SUPPORTED FLAGS: ##########################################################
# disable_lighting_textures : disables lighting for models using the given
# texture names
###############################################################################

light_rotation_vertical = 60.0
light_rotation_horizontal = 60.0
light_intensity = 4.0
light_color = [ 1.0, 1.0, 1.0 ]
ambient_light_intensity = 1.0
ambient_light_color = [ 1.0, 1.0, 1.0 ]
material_roughness = 0.7
material_metallic = 0.5
material_specular = 0.1

disable_lighting_textures = [
  "STAGE01_T05", "STAGE02_T01", "STAGE02_T02", "STAGE03_T01", "STAGE04_T01",
  "STAGE05_T01", "STAGE05_T02", "STAGE06_T01", "STAGE06_T02", "STAGE07_T01",
  "STAGE07_T02", "STAGE08_T01", "STAGE08_T02", "STAGE19_T01", "STAGE19_T02",
  "STAGE19_T03", "STAGE20_T01", "STAGE20_T02", "STAGE23_T01", "STAGE23_T02",
  "STAGE33_T01", "STAGE33_T02", "STAGE34_T01", "STAGE34_T02", "STAGE36_T01",
  "STAGE36_T02", "STAGE38_T01", "STAGE39_T01", "STAGE40_T02", "STAGE40_T03",
  "STAGE44_T01", "STAGE47_T01", "STAGE47_T02", "STAGE53_T01", "STAGE58_T01",
  "STAGE58_T02", "STAGE59_T01", "STAGE61_T01", "STAGE61_T02", "STAGE62_T01",
  "STAGE62_T02", "STAGE63_T01", "STAGE63_T02", "STAGE64_T01", "STAGE64_T02",
  "STAGE65_T01", "STAGE66_T01", "STAGE66_T02", "STAGE67_T01", "STAGE67_T02",
  "STAGE68_T06", "STAGE69_T04", "STAGE70_T01", "STAGE70_T02", "STAGE71_T01",
  "STAGE71_T02", "STAGE72_T01", "STAGE72_T02", "STAGE79_T01", "STAGE80_T01",
  "STAGE80_T02", "STAGE81_T01", "STAGE81_T02", "STAGE84_T01", "STAGE84_T02",
  "STAGE84_T03", "STAGE87_T01", "STAGE87_T02", "STAGE88_T01", "STAGE88_T02",
  "STAGE89_T01"
]

[field_ancnt1]
shadowmap_fade_start_distance = 200.0

[field_anfrst_3]
shadowmap_fade_start_distance = 200.0

[field_blin66_5]
shadowmap_fade_start_distance = 200.0

[field_blin68_1]
shadowmap_fade_start_distance = 100.0

[field_blinst_1]
shadowmap_fade_start_distance = 200.0

[field_blinst_2]
shadowmap_fade_start_distance = 200.0

[field_blinst_3]
shadowmap_fade_start_distance = 200.0

[field_blue_1]
shadowmap_area = 6000.0

[field_convil_1]
shadowmap_fade_start_distance = 200.0

[field_cos_btm]
shadowmap_fade_start_distance = 200.0

[field_cos_top]
shadowmap_fade_start_distance = 200.0

[field_del1]
shadowmap_area = 3500.0

[field_del12]
shadowmap_area = 3500.0

[field_del2]
shadowmap_fade_start_distance = 100.0

[field_fship_4]
shadowmap_fade_start_distance = 200.0

[field_fship_42]
shadowmap_fade_start_distance = 200.0

[field_gaia_2]
shadowmap_fade_start_distance = 200.0

[field_gaiafoot]
shadowmap_area = 3500.0

[field_gaiin_1]
shadowmap_fade_range = 100.0
shadowmap_fade_start_distance = 100.0

[field_gnmkf]
shadowmap_area = 3800.0

[field_holu_2]
shadowmap_fade_start_distance = 100.0

[field_junair]
shadowmap_area = 3600.0

[field_junonr1]
shadowmap_area = 4000.0

[field_las0_1]
shadowmap_fade_start_distance = 200.0

[field_las1_2]
shadowmap_fade_start_distance = 200.0

[field_losin1]
shadowmap_fade_start_distance = 100.0

[field_losin2]
shadowmap_fade_start_distance = 200.0

[field_losin3]
shadowmap_fade_start_distance = 100.0

[field_loslake1]
shadowmap_fade_start_distance = 200.0

[field_lost1]
shadowmap_area = 3100.0

[field_md8_32]
shadowmap_fade_start_distance = 200.0

[field_md8_b1]
shadowmap_fade_start_distance = 200.0

[field_md8_b2]
shadowmap_fade_start_distance = 200.0

[field_mds7st32]
shadowmap_area = 3500.0

[field_mtcrl_3]
shadowmap_fade_start_distance = 200.0

[field_mtcrl_9]
shadowmap_area = 5100.0

[field_rcktbas1]
shadowmap_fade_start_distance = 200.0

[field_sandun_1]
shadowmap_fade_start_distance = 200.0

[field_sango1]
shadowmap_fade_start_distance = 100.0

[field_sango2]
shadowmap_area = 6000.0

[field_sango3]
shadowmap_fade_start_distance = 200.0

[field_shpin_2]
shadowmap_fade_start_distance = 200.0

[field_shpin_22]
shadowmap_fade_start_distance = 200.0

[field_sinin3]
shadowmap_fade_start_distance = 200.0

[field_trnad_3]
shadowmap_area = 3750.0
````

## File: misc/FFNx.lighting.vert
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input a_position, a_color0, a_texcoord0, a_normal
$output v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0

#include <bgfx/bgfx_shader.sh>
#include "FFNx.common.sh"

uniform mat4 d3dViewport;
uniform mat4 d3dProjection;
uniform mat4 viewMatrix;
uniform mat4 worldView;
uniform mat4 normalMatrix;
uniform mat4 lightViewProjTexMatrix;
uniform mat4 invViewMatrix;

uniform vec4 VSFlags;
uniform vec4 WMFlags;
uniform vec4 lightingDebugData;
uniform vec4 gameLightingFlags;
uniform vec4 gameGlobalLightColor;
uniform vec4 gameLightColor1;
uniform vec4 gameLightColor2;
uniform vec4 gameLightColor3;
uniform vec4 gameLightDir1;
uniform vec4 gameLightDir2;
uniform vec4 gameLightDir3;
uniform vec4 gameScriptedLightColor;

#define isTLVertex VSFlags.x > 0.0
#define blendMode VSFlags.y
#define isFBTexture VSFlags.z > 0.0
#define isNotTexture VSFlags.w == 0.0

#define isApplySphericalWorld WMFlags.x > 0.0
#define sphericaWorldRadiusScale WMFlags.x

#define isHide2dEnabled lightingDebugData.x > 0.0

#define gameLightingMode gameLightingFlags.x
#define GAME_LIGHTING_PER_VERTEX 1

void main()
{
	vec4 pos = a_position;
    vec4 color = a_color0;
    vec2 coords = a_texcoord0;

    color.rgb = toLinear(color.bgr);

    if (isTLVertex)
    {
        pos.w = 1.0 / pos.w;
        pos.xyz *= pos.w;
        pos = mul(u_proj, pos);

        if (isHide2dEnabled) pos = vec4_splat(0.0);
    }
    else
    {
        v_position0 = mul(worldView, vec4(pos.xyz, 1.0));

        if (isApplySphericalWorld) pos.xyz = ApplySphericalWorld(v_position0.xyz, sphericaWorldRadiusScale);
        else pos = v_position0;

        v_shadow0 = mul(lightViewProjTexMatrix, v_position0);
        v_normal0 = mul(normalMatrix, vec4(a_normal, 0.0)).xyz;
        pos = mul(mul(d3dViewport, d3dProjection), vec4(pos.xyz, 1.0));

        if (gameLightingMode == GAME_LIGHTING_PER_VERTEX)
        {
            vec3 worldNormal = mul(invViewMatrix, vec4(v_normal0, 0)).xyz;
            float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
            float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
            float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
            vec3 light1Ambient = toLinear(gameLightColor1.rgb) * dotLight1 * dotLight1;
            vec3 light2Ambient = toLinear(gameLightColor2.rgb) * dotLight2 * dotLight2;
            vec3 light3Ambient = toLinear(gameLightColor3.rgb) * dotLight3 * dotLight3;
            vec3 lightAmbient = toLinear(gameScriptedLightColor.rgb) * (toLinear(gameGlobalLightColor.rgb) + light1Ambient + light2Ambient + light3Ambient);
            color.rgb *= gameGlobalLightColor.w * lightAmbient;
        }

        if (color.a > 0.5) color.a = 0.5;
    }

    if (blendMode == 4.0) color.a = 1.0;
    else if (blendMode == 3.0) color.a = 0.25;

#if BGFX_SHADER_LANGUAGE_HLSL
#else
    #if BGFX_SHADER_LANGUAGE_SPIRV
    #else
        if (isFBTexture) coords.y = 1.0 - coords.y;
    #endif
#endif

    gl_Position = pos;
    v_color0 = color;
    v_texcoord0 = coords;
}
````

## File: misc/FFNx.music.toml
````toml
# FFNx Audio Engine config file - Music layer

### HOW TO: ###################################################################
# Sections may be commented by default with an initial # character.
# Remove the initial # character to set the entire sections block and its flags
# -----------------------------------------------------------------------------
# Syntax:
# [MUSIC_NAME]
# flag = value
# another_flag = value
###############################################################################

### SUPPORTED FLAGS: ##########################################################
# offset_seconds: Offset in seconds. Plays the music at this value instead of
# from the begining. Set this value to "sync" to play the music at
# the current offset of the previous playing music (can be slow).
# -----------------------------------------------------------------------------
# no_intro_track: [FF8 Only] Name of the "no intro" music. When the "no intro"
# version is detected, plays this music instead.
# -----------------------------------------------------------------------------
# intro_seconds: [FF8 Only] Offset in seconds. When the "no intro" version is
# detected, skips the beginning of the music.
# -----------------------------------------------------------------------------
# shuffle: Shuffle an SFX ID with one of the given IDs in the array.
# -----------------------------------------------------------------------------
# disabled: Set this flag to true to never play this music and act like it was
# never triggered by the game.
# -----------------------------------------------------------------------------
# relative_speed: Set the music relative speed, with 1.0 is the normal speed,
# between 0.0 and 1.0 (not included) the music is slowed down, and above 1.0
# the music is sped up.
###############################################################################

# This entry will shuffle "battle" with "battle2", "bossbat1" and "bossbat2".
# Everytime the game engine will try to playback 1, one of the entries in the
# array will be picked randomly.
# -----------------------------------------------------------------------------
#[battle]
#shuffle = [ "battle2", "bossbat1", "bossbat2" ]

# Plays gar3 when gargade (GGU theme) is played but the "no intro" flag is set
# -----------------------------------------------------------------------------
#[gargarde]
#no_intro_track = "gar3"

# Skip 20.5 seconds of hikutei (Ragnarok theme) if the "no intro" flag is set
# -----------------------------------------------------------------------------
#[hikutei]
#intro_seconds = 20.5
````

## File: misc/FFNx.overlay.frag
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input v_color0, v_texcoord0

#include <bgfx/bgfx_shader.sh>

SAMPLER2D(s_tex, 0);

void main()
{
	vec4 texel = texture2D(s_tex, v_texcoord0);
	gl_FragColor = texel * v_color0;
}
````

## File: misc/FFNx.overlay.vert
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input a_position, a_texcoord0, a_color0
$output v_color0, v_texcoord0

#include <bgfx/bgfx_shader.sh>
#include "FFNx.common.sh"

void main()
{
	vec2 pos = 2.0*a_position.xy*u_viewTexel.xy;
	gl_Position = vec4(pos.x - 1.0, 1.0 - pos.y, 0.0, 1.0);
	v_texcoord0 = a_texcoord0;
	v_color0    = a_color0;
}
````

## File: misc/FFNx.pcf.sh
````bash
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

// TEX_S
SAMPLER2DSHADOW(tex_3, 3);
// TEX_D
SAMPLER2D(tex_4, 4);

uniform mat4 invViewMatrix;
uniform mat4 lightInvViewProjTexMatrix;
uniform vec4 fieldShadowData;
uniform vec4 shadowData;

float sampleShadowMap(vec2 base_uv, float u, float v, float shadowMapSizeInv, float lightDepth, vec3 worldSpacePos)
{
    vec2 uv = base_uv + vec2(u, v) * shadowMapSizeInv;

    vec3 shadowUv = vec3(uv, lightDepth);
    if(shadowUv.x < 0.0 || shadowUv.x > 1.0 || shadowUv.y < 0.0 || shadowUv.y > 1.0 || lightDepth < 0.0 || lightDepth > 1.0) return 1.0;

    float shadowFactor = shadow2D(tex_3, shadowUv);

#ifdef FIELD_SHADOW
#if BGFX_SHADER_LANGUAGE_HLSL > 400
    // Fade out shadows as the vertical distance between occluder and walkmesh increases
    // This is to prevent shadows being projected to multiple floors

    float shadowDistance = 0.0;
    vec4 lightDepths = textureGather(tex_4, shadowUv.xy, 0);
    for(int i = 0; i < 4; ++i)
    {
        vec4 shadowPos = vec4(shadowUv.xy, lightDepths[i], 1.0);
        vec4 worldSpaceShadowPos = mul(mul(invViewMatrix, lightInvViewProjTexMatrix), shadowPos);
        worldSpaceShadowPos.xyz /= worldSpaceShadowPos.w;

        shadowDistance = max(shadowDistance, worldSpaceShadowPos.z - worldSpacePos.z);
    }

    float shadowFadeStartDistance = fieldShadowData.y;
    float fadeRange = fieldShadowData.z;
    float fadeFactor = max(0.0, min(1.0, (shadowDistance - shadowFadeStartDistance) / fadeRange));

    shadowFactor = mix(shadowFactor, 1.0, fadeFactor);
#endif
#endif

    return shadowFactor;
}

// Shadow filtering (OptimizedPCF)
// https://github.com/TheRealMJP/Shadows/blob/master/Shadows/Mesh.hlsl
float sampleShadowMapPCF7x7(vec3 shadowPos, vec3 worldSpacePos)
{
    float lightDepth = shadowPos.z;
    lightDepth -= shadowData.x;

    float shadowMapSize = shadowData.w;
    float shadowMapSizeInv = 1.0 / shadowMapSize;

    vec2 uv = shadowPos.xy * shadowMapSize;

    vec2 base_uv;
    base_uv.x = floor(uv.x + 0.5);
    base_uv.y = floor(uv.y + 0.5);

    float s = (uv.x + 0.5 - base_uv.x);
    float t = (uv.y + 0.5 - base_uv.y);

    base_uv -= vec2(0.5, 0.5);
    base_uv *= shadowMapSizeInv;

    float uw0 = (5 * s - 6);
    float uw1 = (11 * s - 28);
    float uw2 = -(11 * s + 17);
    float uw3 = -(5 * s + 1);

    float u0 = (4 * s - 5) / uw0 - 3;
    float u1 = (4 * s - 16) / uw1 - 1;
    float u2 = -(7 * s + 5) / uw2 + 1;
    float u3 = -s / uw3 + 3;

    float vw0 = (5 * t - 6);
    float vw1 = (11 * t - 28);
    float vw2 = -(11 * t + 17);
    float vw3 = -(5 * t + 1);

    float v0 = (4 * t - 5) / vw0 - 3;
    float v1 = (4 * t - 16) / vw1 - 1;
    float v2 = -(7 * t + 5) / vw2 + 1;
    float v3 = -t / vw3 + 3;

    float sum = 0.0;

    sum += uw0 * vw0 * sampleShadowMap(base_uv, u0, v0, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw1 * vw0 * sampleShadowMap(base_uv, u1, v0, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw2 * vw0 * sampleShadowMap(base_uv, u2, v0, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw3 * vw0 * sampleShadowMap(base_uv, u3, v0, shadowMapSizeInv, lightDepth, worldSpacePos);

    sum += uw0 * vw1 * sampleShadowMap(base_uv, u0, v1, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw1 * vw1 * sampleShadowMap(base_uv, u1, v1, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw2 * vw1 * sampleShadowMap(base_uv, u2, v1, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw3 * vw1 * sampleShadowMap(base_uv, u3, v1, shadowMapSizeInv, lightDepth, worldSpacePos);

    sum += uw0 * vw2 * sampleShadowMap(base_uv, u0, v2, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw1 * vw2 * sampleShadowMap(base_uv, u1, v2, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw2 * vw2 * sampleShadowMap(base_uv, u2, v2, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw3 * vw2 * sampleShadowMap(base_uv, u3, v2, shadowMapSizeInv, lightDepth, worldSpacePos);

    sum += uw0 * vw3 * sampleShadowMap(base_uv, u0, v3, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw1 * vw3 * sampleShadowMap(base_uv, u1, v3, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw2 * vw3 * sampleShadowMap(base_uv, u2, v3, shadowMapSizeInv, lightDepth, worldSpacePos);
    sum += uw3 * vw3 * sampleShadowMap(base_uv, u3, v3, shadowMapSizeInv, lightDepth, worldSpacePos);

    vec2 baseUvShifted = abs(base_uv * 2.0 - 1.0);
    float fadeCoeff = saturate(max(baseUvShifted.x, baseUvShifted.y) - 0.9) / 0.1;

    return mix(sum * 1.0 / 2704.0, 1.0, fadeCoeff);
}
````

## File: misc/FFNx.post.frag
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input v_color0, v_texcoord0

#include <bgfx/bgfx_shader.sh>
#include "FFNx.common.sh"

SAMPLER2D(tex_0, 0);

uniform vec4 FSHDRFlags;
uniform vec4 FSMovieFlags;

#define isHDR FSHDRFlags.x > 0.0
#define monitorNits FSHDRFlags.y

#define isOverallSRGBColorGamut abs(FSMovieFlags.w - 0.0) < 0.00001
#define isOverallNTSCJColorGamut abs(FSMovieFlags.w - 1.0) < 0.00001

void main()
{
	vec4 color = texture2D(tex_0, v_texcoord0.xy);

	if (isHDR) {
		// back to linear for gamut conversion and PQ gamma curve
		color.rgb = toLinear(color.rgb);

		// TODO: If/when a full 10-bit pathway is available for 10-bit FMVs, don't dither those
		ivec2 dimensions = textureSize(tex_0, 0);
		color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 2160.0);
		if (isOverallNTSCJColorGamut){
			color.rgb = convertGamut_NTSCJtoREC2020(color.rgb);
		}
		else {
			color.rgb = convertGamut_SRGBtoREC2020(color.rgb);
		}
		color.rgb = ApplyREC2084Curve(color.rgb, monitorNits);
	}
	else if (isOverallNTSCJColorGamut){
		color.rgb = toLinear(color.rgb);
		color.rgb = GamutLUT(color.rgb);
		// dither after the LUT operation
		ivec2 dimensions = textureSize(tex_0, 0);
		color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 2160.0);
		color.rgb = toGamma(color.rgb);
	}

	gl_FragColor = color;
}
````

## File: misc/FFNx.post.vert
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input a_position, a_color0, a_texcoord0
$output v_color0, v_texcoord0

#include <bgfx/bgfx_shader.sh>

void main()
{
	vec4 pos = a_position;
    vec4 color = a_color0;
    vec2 coords = a_texcoord0;

    color.rgba = color.bgra;

    pos.w = 1.0 / pos.w;
    pos.xyz *= pos.w;
    pos = mul(u_proj, pos);

    gl_Position = pos;
    v_color0 = color;
    v_texcoord0 = coords;
}
````

## File: misc/FFNx.SFX.toml
````toml
# FFNx Audio Engine config file - SFX layer

### HOW TO: ###################################################################
# Sections may be commented by default with an initial # character.
# Remove the initial # character to set the entire sections block and its flags
# -----------------------------------------------------------------------------
# Syntax:
# [ID]
# flag = value
# another_flag = value
###############################################################################

### SUPPORTED FLAGS: ##########################################################
# shuffle: Shuffle an SFX ID with one of the given IDs in the array. IDs MUST
# be numbers ONLY and MUST NOT contain any special character like - or _.
# This flag MUST NOT be used in pair with 'sequential'.
# -----------------------------------------------------------------------------
# sequential: Sequentially playback an SFX ID with the ones provided in the
# array. IDs MUST be numbers ONLY and MUST NOT contain any special character
# like - or _. This flag MUST NOT be used in pair with 'shuffle'.
# -----------------------------------------------------------------------------
# loop: Enable loop for the requested SFX ID
# -----------------------------------------------------------------------------
# skip: Enable this flag to skip playing the SFX ID and have silence instead.
# PLEASE NOTE: this flag will "fake a match" on the engine, to ensure silent
# playback so it will not be a "skip" in the sense of moving on to the
# next match.
###############################################################################

# This entry will shuffle the SFX ID 1 ( menu cursor ) with the ID 2, 3 or 4.
# Everytime the game engine will try to playback 1, one of the entries in the
# array will be picked randomly.
# -----------------------------------------------------------------------------
#[1]
#shuffle = [ 2, 3, 4 ]
#sequential = [ 2, 3, 4 ]
#loop = true
#skip = false
````

## File: misc/FFNx.shadowmap.frag
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0

#include <bgfx/bgfx_shader.sh>

SAMPLER2D(tex_0, 0);

uniform vec4 VSFlags;
uniform vec4 FSAlphaFlags;
uniform vec4 FSTexFlags;

#define isTexture VSFlags.w > 0.0
// ---
#define inAlphaRef FSAlphaFlags.x

#define isAlphaNever abs(FSAlphaFlags.y - 0.0) < 0.00001
#define isAlphaLess abs(FSAlphaFlags.y - 1.0) < 0.00001
#define isAlphaEqual abs(FSAlphaFlags.y - 2.0) < 0.00001
#define isAlphaLEqual abs(FSAlphaFlags.y - 3.0) < 0.00001
#define isAlphaGreater abs(FSAlphaFlags.y - 4.0) < 0.00001
#define isAlphaNotEqual abs(FSAlphaFlags.y - 5.0) < 0.00001
#define isAlphaGEqual abs(FSAlphaFlags.y - 6.0) < 0.00001

#define doAlphaTest FSAlphaFlags.z > 0.0

void main()
{
	vec4 color = v_color0;

    if (isTexture)
    {
        vec4 texture_color = texture2D(tex_0, v_texcoord0.xy);

        if (doAlphaTest)
        {
            //NEVER
            if (isAlphaNever) discard;

            //LESS
            if (isAlphaLess)
            {
                if (!(texture_color.a < inAlphaRef)) discard;
            }

            //EQUAL
            if (isAlphaEqual)
            {
                if (!(texture_color.a == inAlphaRef)) discard;
            }

            //LEQUAL
            if (isAlphaLEqual)
            {
                if (!(texture_color.a <= inAlphaRef)) discard;
            }

            //GREATER
            if (isAlphaGreater)
            {
                if (!(texture_color.a > inAlphaRef)) discard;
            }

            //NOTEQUAL
            if (isAlphaNotEqual)
            {
                if (!(texture_color.a != inAlphaRef)) discard;
            }

            //GEQUAL
            if (isAlphaGEqual)
            {
                if (!(texture_color.a >= inAlphaRef)) discard;
            }
        }

        if (texture_color.a == 0.0) discard;

    }
    else if(color.a < 0.0 && color.r + color.g + color.b == 0.0)
	{
        discard;
    }

    gl_FragColor = vec4_splat(0.0);
}
````

## File: misc/FFNx.shadowmap.vert
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input a_position, a_color0, a_texcoord0, a_normal
$output v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0

#include <bgfx/bgfx_shader.sh>

uniform mat4 worldView;
uniform mat4 lightViewProjMatrix;

void main()
{
	vec4 pos = a_position;
    vec4 color = a_color0;
    vec2 coords = a_texcoord0;

    color.rgba = color.bgra;

    if (color.a > 0.5) color.a = 0.5;
    else if(color.r + color.g + color.b == 0.0)
    {
        color.a = -1;
    }

    pos = mul(mul(lightViewProjMatrix, worldView), vec4(pos.xyz, 1.0));

    gl_Position = pos;
    v_color0 = color;
    v_texcoord0 = coords;
}
````

## File: misc/FFNx.time.toml
````toml
# FFNx Time Cycle config file

### HOW TO: ###################################################################
# Sections may be commented by default with an initial # character.
# Remove the initial # character to set the entire sections block and its flags
# -----------------------------------------------------------------------------
###############################################################################

### SUPPORTED FLAGS: ##########################################################
# sunrise_time : sunrise time in hours
# morning_time : morning time in hours
# midday_time : midday time in hours
# afternoon_time : afternoon time in hours
# night_time : night time in hours

# frames_per_minute : frames per minutes
# (e.g. 5 results in a 8 min cycle, 10 in a 16 min cycle, 15 in 24 min cycle)

# morning_color : RGB filter values for the morning color
# midday_color : RGB filter values for the midday color
# afternoon_color : RGB filter values for the afternoon color
# night_color : RGB filter values for the night color

# options_address : address for pointer to unused game data to store time related options
# (BIT 0: global time cycle flag, BIT 1: update timer flag, BIT 2: Outdoor field flag)

# minutes_address : address for pointer to unused game data to store the minutes
# hours_address : address for pointer to unused game data to store the hours
# days_address : address for pointer to unused game data to store the days
# months_address : address for pointer to unused game data to store the months

# month_char_0_address : address to the first character of the month string
# month_char_1_address : address to the second character of the month string
# month_char_2_address : address to the third character of the month string

# month_x_char_0 : value of first character of month x (replace x by month index between 0 and 11)
# month_x_char_1 : value of first character of month x (replace x by month index between 0 and 11)
# month_x_char_2 : value of first character of month x (replace x by month index between 0 and 11)
###############################################################################

#sunrise_time = 6.0
#morning_time = 7.0
#midday_time = 15.0
#afternoon_time = 19.0
#night_time = 20.0

#frames_per_minute = 5

#morning_color = [ 0.75, 0.5, 0.5 ]
#midday_color = [ 1.0, 1.0, 1.0 ]
#afternoon_color = [ 0.9, 0.4, 0.3 ]
#night_color = [ 0.075, 0.075, 0.25 ]

#options_address = "DC08E6"
#minutes_address = "DC08E8"
#hours_address = "DC08EB"
#days_address = "DC08EA"
#months_address = "DC08E9"

#month_char_0_address = "DC0BFC"
#month_char_1_address = "DC0BFD"
#month_char_2_address = "DC0BFE"

#month_0_char_0 = 42
#month_0_char_1 = 65
#month_0_char_2 = 78

#month_1_char_0 = 38
#month_1_char_1 = 69
#month_1_char_2 = 66

#month_2_char_0 = 45
#month_2_char_1 = 65
#month_2_char_2 = 82

#month_3_char_0 = 33
#month_3_char_1 = 65
#month_3_char_2 = 89

#month_4_char_0 = 45
#month_4_char_1 = 65
#month_4_char_2 = 89

#month_5_char_0 = 42
#month_5_char_1 = 85
#month_5_char_2 = 78

#month_6_char_0 = 42
#month_6_char_1 = 85
#month_6_char_2 = 76

#month_7_char_0 = 33
#month_7_char_1 = 85
#month_7_char_2 = 71

#month_8_char_0 = 51
#month_8_char_1 = 69
#month_8_char_2 = 80

#month_9_char_0 = 47
#month_9_char_1 = 67
#month_9_char_2 = 84

#month_10_char_0 = 46
#month_10_char_1 = 79
#month_10_char_2 = 86

#month_11_char_0 = 36
#month_11_char_1 = 69
#month_11_char_2 = 67
````

## File: misc/FFNx.toml
````toml
# FFNx config file

###############################################################################
# COMMON OPTIONS FOR BOTH FF7 AND FF8
###############################################################################

#########################
## DISPLAY
#########################

#[DISPLAY INDEX]
# The display where you want the game to run. By default the window will be created on the primary display.
# NOTE: If the value is set lower than 1, it will pick the primary display. If the value is set higher to the maximum number of screens, it will pick the last one.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
display_index = -1

#[RENDERING BACKEND]
# Available choices are:
# - 0: Auto ( default, will pick the best rendering backend for your GPU )
# - 1: OpenGL ( works fine on Intel/Nvidia, MAY break on AMD )
# - 2: UNUSED ( used to be Direct3D9, no more supported )
# - 3: Direct3D11 ( works fine under any GPU on Windows )
# - 4: Direct3D12
# - 5: Vulkan
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
renderer_backend = 0

#[FULLSCREEN]
# If off, it will run in window mode.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
fullscreen = false

#[BORDERLESS]
# If off, it will run using the default window style.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
borderless = false

#[RESOLUTION]
# Resolution of the game.
# Default (value = 0):
# - Window mode will use 640x480
# - Fullscreen mode will use your desktop resolution
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
window_size_x = 0
window_size_y = 0

#[INTERNAL RESOLUTION SCALE]
# The scale is in multiples of 640x480
# The scale factor is used to multiply the internally used resolution to a given size before it is scaled to the final screen or window resolution.
# This is required to avoid visual glitches that may happen when the game is not rendered in a 4:3 aspect ratio.
# This is optional for native 4:3 resolutions, but it can enhance visual quality at values higher than the current screen or window resolution ( like Nvidia DSR ).
# A setting of 0 will attempt to find a scale factor that most closely matches the current screen or window resolution.
# Default = 0
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
internal_resolution_scale = 0

#[ASPECT RATIO]
# Preserve original game aspect ratio of (4:3) by adding black bars on the left and right side (if needed)
# When off the game will be stretched to fit the window's aspect ratio; Be aware the game may look wrong though.
# 0: Preserves original game aspect ratio of (4:3) by adding black bars on the left and right side (if needed)
# 1: Stretched to fit the window's aspect ratio; Be aware the game may look wrong though.
# 2: New 16:9 aspect ratio mode without stretching the image. Fields that lack horizontal scrolling will show black bars on the left and right side.
# 3: New 16:10 aspect ratio which crops the left and right edges of the image so that it can stretch to fill a 16:10 screen.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
aspect_ratio = 0

#[UNCROP]
# Uncrops the image to remove the black bars on the top and bottom of the screen.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_uncrop = false

#[ENABLE VSYNC]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_vsync = true

#[REFRESH RATE]
# Screen refresh rate.
# Default is 0 = use current screen refresh rate
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
refresh_rate = 0

#[ANTIALIASING]
# Enable antialiasing filtering, this is done in the last pass when downsampling from the current supersampled rendering ( based on internal_resolution_scale logic )
# Available choices are:
# - 0: Disabled ( Default )
# - 2: 2x
# - 4: 4x
# - 8: 8x
# - 16: 16x
# If you set any value that is different than those, it will pick the higher option ( eg. if you pick 6 it will be 8, if you pick 1 it will be 2, and so on ).
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_antialiasing = 0

#[ANISOTROPIC]
# Enable anisotropic filtering, for high-res textures and overall rendering
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_anisotropic = true

#[BILINEAR]
# Enable bilinear filtering on 3D textures. For FF7, textures in menu are also filtered.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_bilinear = false

#[LIGHTING]
# Enable advanced lighting mode with real-time shadows.
# NOTICE: Parameters such as light direction and color can be edited on the lighting debug window in the FFNx DevTools.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_lighting = false

#[PREFER LIGHTING CPU CALCULATIONS]
# Prefer lighting CPU calculations.
# If disabled, the driver will try to inherit models normal data first although this process might bring some artifacts visually.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
prefer_lighting_cpu_calculations = true

#[GAME LIGHTING]
# This flag sets the method used to calculate the original game lighting.
# Available choices are:
# - 0: Original ( will inherit the default original CPU-based lighting of the PC version )
# - 1: Per-Vertex ( will calculate lighting in the GPU per-vertex and closely match the look of the PSX version )
# - 2: Per-Pixel ( same as above but calculates lighting per-pixel for a smoother result )
# This flag only works with FF7 and will be set automatically to Original mode for FF8.
# This option is automatically set to Per-Vertex mode when advanced lighting is enabled.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
game_lighting = 1

#[EXTERNAL IBL PATH]
# Path for external lighting files.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_lighting_path = "lighting"

#[DAY-NIGHT TIME CYCLE]
# Enable day-night time cycle.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_time_cycle = false

#[EXTERNAL DAY NIGHT CYCLE PATH]
# Path for external day-night time files.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_time_cycle_path = "time"

#[EXTERNAL WORLDMAP MESH]
# Enable worldmap external meshes.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_worldmap_external_mesh = false

#[EXTERNAL MESH PATH]
# Path for external mesh files.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_mesh_path = "mesh"

#[HDR]
# This flag will set the brightness level that SDR "white" is rendered at within an HDR monitor.
# By default is set to 0, which means to attempt autodetection of the correct value for your monitor via software.
# Autodetection may fail on some monitor models.
# Autodetection WILL fail on Windows older than Win10 Fall Creators Update (version 1709).
# Autodetection WILL fail on WINE (at least as of WINE version 7.22).
# If autodetection is attempted and fails, a default value of 200 nits will be used.
# NOTE: FFNx.log will tell you if autodetection succeeded, and what value was autodetected.
# NOTE: The autodetected (or default) value MIGHT be wrong sometimes; use this flag if brightness does not look correct.
# Sane values are likely in the range 100-200 nits.
hdr_max_nits = 0

#[COLOR GAMUT]
# If enabled, performs a conversion to simulate the color gamut of the 1990s Japanese television sets that FF7 and FF8 were originally designed for.
# The resulting colors are generally brighter and more vivid.
# This mode is appropriate for:
# (1) Vanilla FF7/FF8.
# (2) Mod assets that are upscales of the original assets.
# (3) Mod assets made from scratch where the modder used the original assets as a color reference without doing a gamut conversion.
# This mode is not appropriate for mod assets made from scratch that truly use the sRGB color gamut.
# Such assets can be made suitable for this mode using this converter program: https://github.com/ChthonVII/gamutthingy
enable_ntscj_gamut_mode = false

#########################
# Audio Player Options
#########################

#[NUMBER OF CHANNELS]
# This flag will set the number of channels you want to use.
# You can force a Stereo output ( 2.0 ) on a 7.1 system for example, by setting this flag to 2.
# The number MUST always be EVEN ( eg. 2, 4, 6, 8). If you have 5.1 set, then use 6 ( 5+1 ). If you have 7.1 set, then use 8 ( 7+1 ).
# NOTE: 0 = Autodetect. It will use the number of channels set in your audio card and/or inherited through audio software enhancements suites.
# WARNING: This flag WILL impact the OVERALL external audio layer ( Music, SFX, Voice, Ambient, etc.)!
external_audio_number_of_channels = 2

#[SAMPLE RATE]
# This flag will set the sample rate you want to use.
# The number MUST be one of the known sample rates values ( 44100, 48000, etc. )
# NOTE: 0 = Autodetect. It will use the sample rate set in your audio card and/or inherited through audio software enhancements suites.
# WARNING: This flag WILL impact the OVERALL external audio layer ( Music, SFX, Voice, Ambient, etc.)!
external_audio_sample_rate = 44100

#[USE EXTERNAL SFX]
# This flag will enable/disable the support of an enhanced audio layer to reproduce sounds in-game.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
use_external_sfx = false

#[EXTERNAL SFX VOLUME]
# This setting will allow you to configure the volume of the SFX layer.
# Possible values: 0..100
# If -1, the engine will try to detect the volume by other meanings:
# - FF7 1998: It will attempt to use the original game registry paths
# - FF7 Steam: It will attempt to read it from the ff7sound.cfg file
# - FF8 2000: It will be set to 100% by default
# - FF8 Steam: It will be set to 100% by default
external_sfx_volume = -1

#[EXTERNAL SFX PATH]
# Path of the external sound files
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_sfx_path = "sfx"

#[EXTERNAL SFX EXTENSION]
# The type of file to search for. By default is ogg.
# You can use a list to specify multiple extensions, ordered by priority.
# Example: ["ogg", "flac"]
# Supported extensions:
# - https://github.com/losnoco/vgmstream#supported-file-types
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_sfx_ext = "ogg"

#[EXTERNAL SFX ALWAYS CENTERED]
# This flag will force the external SFX sounds to be played always on the center position instead of inheriting the left/center/right original logic.
external_sfx_always_centered = false

#[USE EXTERNAL MUSIC]
# This flag will enable/disable the support of an enhanced audio layer to reproduce music in-game.
# If you leave out the default configuration FFNx will autodetect your environment and will set it to the best available option.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
use_external_music = false

#[EXTERNAL MUSIC VOLUME]
# This setting will allow you to configure the volume of the Music layer.
# Possible values: 0..100
# If -1, the engine will try to detect the volume by other meanings:
# - FF7 1998: It will attempt to use the original game registry paths
# - FF7 Steam: It will attempt to read it from the ff7sound.cfg file
# - FF8 2000: It will be set to 100% by default
# - FF8 Steam: It will be set to 100% by default
external_music_volume = -1

#[EXTERNAL MUSIC RESUME]
# This flag will enable the support for music resume on known areas of the game ( for eg. World-Map ).
# If you enable this flag, instead of starting the OST for a known area from the beginning everytime, it will resume where you left it off the last time you visited it.
external_music_resume = true

#[EXTERNAL MUSIC SYNCHRONIZATION]
# This flag will enable the support for music synchronization.
# If you enable this flag, music mods can use the "sync" feature to start a music at the time offset of the previous playing music.
external_music_sync = false

#[EXTERNAL MUSIC PATH]
# Path of the external music files
# Will try to load from this path before using the default for your Version of the game
# Defaults:
# - FF7 1998: music/vgmstream ( 7h-era compatibility )
# - FF7 eStore: data/music_ogg
# - FF7 Steam: data/music_ogg
# - FF8 2000/Steam: data/music/dmusic/ogg
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_music_path = ""

#[EXTERNAL MUSIC EXTENSION]
# The type of file to search for. By default is ogg.
# You can use a list to specify multiple extensions, ordered by priority.
# Example: ["minipsf", "ogg"]
# Supported extensions:
# - https://github.com/losnoco/vgmstream#supported-file-types
# - psf, psf2, minipsf, minipsf2 (PSF and PSF2) if you provide the Highly Experimental BIOS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_music_ext = "ogg"

#[EXTERNAL MUSIC HIGHLY EXPERIMENTAL BIOS]
# This flag will enable support to PSF and PSF2 formats.
# You need to provide a BIOS generated for the Highly Experimental project (hebios.bin).
# To find one compiled BIOS: https://git.lopez-snowhill.net/chris/foo_psf
# To generate one: https://git.lopez-snowhill.net/chris/highly_experimental
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
he_bios_path = ""

#[EXTERNAL VOICE PATH]
# Path of the external voice files
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_voice_path = "voice"

#[EXTERNAL VOICE EXTENSION]
# The type of file to search for. By default is ogg.
# You can use a list to specify multiple extensions, ordered by priority.
# Example: ["ogg", "flac"]
# Supported extensions:
# - https://github.com/losnoco/vgmstream#supported-file-types
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_voice_ext = "ogg"

#[EXTERNAL VOICE VOLUME]
# This setting will allow you to configure the volume of the Voice layer.
# Possible values: 0..100
# If -1, the engine will try to detect the volume by other meanings:
# - FF7 1998: It will attempt to use the FFNx registry paths ( also used by 7th Heaven )
# - FF7 Steam: It will be set to 100% by default
# - FF8 2000: It will be set to 100% by default
# - FF8 Steam: It will be set to 100% by default
external_voice_volume = -1

#[ENABLE VOICE MUSIC FADE]
# This flag will enable the music volume fade out and fade in, when a voice acting is being played back.
# Please note this flag will take effect ONLY when "use_external_music" is enabled.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_voice_music_fade = false

#[EXTERNAL VOICE MUSIC FADE VOLUME]
# This flag will set to how much the volume will be lowered down when a voice acting is going to be played back. When the voice file will be finished, the music volume will be then restored to its previous value.
# Range: 0-100 ( Min = 0, Max = 100)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_voice_music_fade_volume = 25

#[ENABLE VOICE AUTO TEXT]
# This will allow you to enable or disable the Voice Auto-Text feature. When enabled the game will automatically close the dialogue as soon as the voice acting is finished for that line.
enable_voice_auto_text = true

#[EXTERNAL AMBIENT PATH]
# Path of the external ambient files
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_ambient_path = "ambient"

#[EXTERNAL AMBIENT EXTENSION]
# The type of file to search for. By default is ogg.
# You can use a list to specify multiple extensions, ordered by priority.
# Example: ["ogg", "flac"]
# Supported extensions:
# - https://github.com/losnoco/vgmstream#supported-file-types
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_ambient_ext = "ogg"

#[EXTERNAL AMBIENT VOLUME]
# This setting will allow you to configure the volume of the Ambient layer.
# Possible values: 0..100
# If -1, the engine will try to detect the volume by other meanings:
# - FF7 1998: It will attempt to use the FFNx registry paths ( also used by 7th Heaven )
# - FF7 Steam: It will be set to 100% by default
# - FF8 2000: It will be set to 100% by default
# - FF8 Steam: It will be set to 100% by default
external_ambient_volume = -1

###########################
# Video Player Options
###########################

#[ENABLE FFMPEG VIDEOS]
# This flag will enable/disable the support of FFMpeg layer to reproduce movies in-game.
# Default Value (-1) sets the flag, depending on the game version.
# - FF7 1998 - true
# - FF7/FF8 Steam - true
# - FF8 2000 - false
# It is suggested to keep the default behavior unless you really know what are you doing.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_ffmpeg_videos = -1

#[FFMPEG VIDEO VOLUME]
# This setting will allow you to configure the volume of the FFMpeg Video layer.
# Possible values: 0..100
# If -1, the engine will try to detect the volume by other meanings:
# - FF7 1998: It will attempt to use the FFNx registry paths ( also used by 7th Heaven )
# - FF7 Steam: It will be set to 100% by default
# - FF8 2000: NOT SUPPORTED!
# - FF8 Steam: It will be set to 100% by default
ffmpeg_video_volume = -1

#[FFMPEG VIDEO FILE EXTENSION]
# The type of file that the ffmpeg layer will search for. Default is avi.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ffmpeg_video_ext = "avi"

#[EXTERNAL MOVIE AUDIO FILE EXTENSION]
# The type of audio file to search for. Default is ogg.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_movie_audio_ext = "ogg"

###########################
# Controller Options
###########################

#[ANALOGUE CONTROLS]
# FF7: This flag will enable analogue joystick input for controlling the player in fields and the camera in battles.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_analogue_controls = false

#[INVERT VERTICAL CAMERA CONTROLS]
# FF7: This flag will enable inverted camera vertical movement when controlling the camera in battles.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_inverted_vertical_camera_controls = false

#[INVERT HORIZONTAL CAMERA CONTROLS]
# FF7: This flag will enable inverted camera horizontal movement when controlling the camera in battles.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_inverted_horizontal_camera_controls = false

#[LEFT ANALOG STICK DEADZONE]
# FF7: Sets the deadzone for the left analog stick. Values are from 0 to 1.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
left_analog_stick_deadzone = 0.1

#[RIGHT ANALOG STICK DEADZONE]
# FF7: Sets the deadzone for the right analog stick. Values are from 0 to 1.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
right_analog_stick_deadzone = 0.1

#[LEFT ANALOG TRIGGER DEADZONE]
# FF7: Sets the deadzone for the left analog trigger. Values are from 0 to 1.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
left_analog_trigger_deadzone = 0.1

#[RIGHT ANALOG TRIGGER DEADZONE]
# FF7: Sets the deadzone for the right analog trigger. Values are from 0 to 1.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
right_analog_trigger_deadzone = 0.1

#[AUTO RUN]
# FF7: This flag enables mode to walk or run depending on how much the left analog stick is tilt.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_auto_run = false

#[EXTERNAL VIBRATE PATH]
# Path of the external vibrate files
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
external_vibrate_path = "vibrate"

###############################
# MUST SET FOR VERSIONS BELOW
# FF7 2012   FF7 STEAM
# FF8 2013   FF8 STEAM
###############################
# The folder name in your game Documents path ( for eg. for FF7 is "C:\Users\JohnDoe\Documents\Square Enix\FINAL FANTASY VII Steam\user_XXXXXXX")
# Use this only if you have MORE THAN ONE user_* directories. If not, just leave this commented as the driver will autodetect the directory.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
steam_game_userdata = ""

###########################
# Steam Achievement Options
###########################

#[STEAM ACHIEVEMENTS EXTENSION]
# This flag will enable steam overlay and steam achievements (Steam MUST be running and you must be online and
# connected to the Internet to unlock achievement).
# Note: incompatible with mods that change dramatically the gameplay (for example, New Threat mod), use it at your own risk
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_steam_achievements = false

########################
## MODDER OPTIONS
########################

#[TEXTURE PATH]
# Mod directory where textures will be loaded from
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
mod_path = "mods/Textures"

# Mod extension
# You can change the extension list, ordered by priority. DO NOT add new extensions, driver will become unstable.
# Default: ["dds", "png"]
# Additionally available supported extensions: [ "psd", "tga", "exr" ]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
mod_ext = ["dds", "png"]

# Show every failed attempt at loading a .png or .dds texture
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
show_missing_textures = false

# Dump internal textures to PNG files in the mod_path
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
save_textures = false

# Dump internal legacy textures to PNG files in the mod_path
# FF7: There is currently no legacy format
# FF8: Field backgrounds will be saved in Tonberry's format, instead of FFNx one
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
save_textures_legacy = false

# Dump identified data from EXE to "<direct_mode_path>/exe/"
# List of files dumped here: https://github.com/julianxhokaxhiu/FFNx/tree/master/docs/mods/exe_data.md
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
save_exe_data = false

# This path is where the Hext patching layer will look for txt files.
# The path will ALWAYS have appended:
# 1. The game name ( if FF7 it will be "ff7/", if FF8 will be "ff8/")
# 2. The game language ( for eg. if ff7_en it will be "en" )
# The resulting path will then be "<hext_patching_path>/ff7/en", if you run for eg. FF7 English
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
hext_patching_path = "hext"

# This is the path where files where be read directly, instead then reading them inside the LGP/FS archives.
# For example: if FF7 is looking for aaab.rsd in char.lgp, this option will make it open direct/char/aaab.rsd first,
# If this file doesn't exist it will look for the original in the LGP archive
# Another example: if FF8 is looking for c:/data/en/FIELD/mapdata/bc/bccent12/bccent12.msd in field.fs,
# this option will make it open direct/FIELD/mapdata/bc/bccent12/bccent12.msd if it exists
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
direct_mode_path = "direct"

# This path will define where the driver will look first, allowing you to override core game files, if needed
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
override_path = "override"

# This path will define where the driver will look for mod_path textures first, allowing you to override mod_path textures, if needed-
# This flag is empty by default to ensure performance is not dropped.
override_mod_path = ""

#[SPEEDHACK]
# Set the step when increasing the speedhack speed
#~~~~~~~~~~~~~~~~~~~~~~~~~~
speedhack_step = 0.5

# Set the limit of the speedhack multiplier
#~~~~~~~~~~~~~~~~~~~~~~~~~~
speedhack_max = 8.0
speedhack_min = 1.0

#[EXPERIMENTAL]
# Enable support for animated textures.
# WARNING: This flag MAY degrade the gameplay performance. Enable at your own risk.
#~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_animated_textures = false

# Disable animated textures on the fields listed below.
# This field can be a single field name, or an array of field names.
# NOTE: This is an actual BLACKLIST and it will have an impact ONLY when 'enable_animated_textures = true'
disable_animated_textures_on_field = ""

##########################
# DEBUGGING OPTIONS
# These options are mostly useful for developers or people reporting crashes.
# Please do enable them only when required.
##########################

# Enable FFNx DevTools
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
enable_devtools = false

# Set hotkey to toggle the DevTools window.
# This is specified by a virtual-key code hexadecimal value, see: https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Default: 0x7B ( VK_F12 )
devtools_hotkey = 0x7B

# Display the verion of FFNx in upper right corner ( when fullscreen ) or in the title bar ( when windowed )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
show_version = true

# Display frames per second counter in upper right corner ( when fullscreen ) or in the title bar ( when windowed )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
show_fps = false

# Display Rendering backend in upper right corner ( when fullscreen ) or in the title bar ( when windowed )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
show_renderer_backend = true

# Display some real-time debug information
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
show_stats = false

# Enable logging
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
show_applog = true

# Dump in the logs more verbose error messages coming directly from the engine
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
more_debug = false

# Show on screen error messages ( only on fullscreen )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
show_error_popup = false

# Enable this flag if you want to see more verbose output from the backend renderer.
# Usually useful for debug pruposes. Do not enable otherwise.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
renderer_debug = false

# Enable this flag if you want to go into debug mode for steam achievements (open popup window for achievements).
# Useful for debug purposes. Do not enable otherwise.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
steam_achievements_debug_mode = false

# Creates a full crashdump file if the game crashes. Useful to be analyzed with WinDbg when reporting issues.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
create_crash_dump = false

# Various flags which will help in further debugging the game engine logics.
# Some flags may not generate any output depending on the game you play.

# trace_all - Dump in the logs whatever APIs is being called from the Engine in FFNx. Overrides all the others below.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_all = false

# trace_renderer - Dump in the logs only APIs that has to do with the rendering engine
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_renderer = false

# trace_movies - Dump in the logs only APIs that has to do with movie playback
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_movies = false

# trace_music - Dump in the logs only APIs that has to do with music playback
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_music = false

# trace_sfx - Dump in the logs only APIs that has to do with sfx playback
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_sfx = false

# trace_fake_dx - Dump in the logs only APIs that has to do with directdraw emulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_fake_dx = false

# trace_direct - Dump in the logs only APIs that has to do with Archive loading
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_direct = false

# trace_files - Dump in the logs only APIs that has to do with filesystem operations
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_files = false

# trace_loaders - Dump in the logs only APIs that has to do with internal textures overrides
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_loaders = false

# trace_vram - Dump in the logs only APIs that has to do with FF8 VRAM
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_vram = false

# trace_opcodes - Dump in the logs only APIs that has to do with field opcodes
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_opcodes = false

# trace_voice - Dump in the logs only APIs that has to do with voice playback
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_voice = false

# trace_ambient - Dump in the logs only APIs that has to do with ambient playback
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_ambient = false

# trace_gamepad - Dump in the logs only APIs that has to do with gamepad
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_gamepad = false

# trace_achievement - Dump in the logs only APIs that has to do with steam achievements
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_achievement = false

# trace_battle_animation - Dump in the logs only APIs that has to do with battle animation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_battle_animation = false

# trace_battle_text - Dump in the logs only APIs that has to do with battle text (dialogue, ...)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
trace_battle_text = false

# vertex_log - Dump in the logs current engine vertex data being passed to the GPU for drawing
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
vertex_log = false

# uniform_log - Dump in the logs current engine uniform data being passed to the GPU shaders
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
uniform_log = false

###############################################################################
# OPTIONS ONLY FOR FF7
###############################################################################

## ENHANCEMENTS

# FPS Limiter
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This flag will overwrite the internal FPS limiter of the game.
# Available choices are:
# - 0: Original ( will inherit the default vanilla game behavior, some bugs may appear )
# - 1: Default ( an hybrid mode that fixes most of the known game limiter bugs while preserving the original FPS )
# - 2: 30 FPS ( it will bump Battle mode to 30 FPS, everything else will run in vanilla mode )
# - 3: 60 FPS ( all the game will run in 60 FPS, use this option at your own risk )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff7_fps_limiter = 1

# Allow the sfx footstep sound to be played everytime you move in fields
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff7_footsteps = false

# Include armor in magic defense calculation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
mdef_fix = true

# Play opening music via external music, the opening movie needs to be modified to not play the music
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff7_external_opening_music = false

# FIELD mode vertical center
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This flag will center vertically the game when in FIELD mode
# NOTE: Previously this was done via a hext file
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff7_field_center = true

## MODDER OPTIONS - These options are mostly useful to modders and should not be enabled during normal play.

# This is the path where your savefiles will be read.
# Notice that the path will be relative to your FF7 Game install directory, where usually the "save" directory is stored.
# PLEASE NOTE: THIS IS A VALID OPTION ONLY FOR FF7 1998/eStore edition. It will NOT work on the Steam edition!
save_path = "save"

# FIELD advanced blinking
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This flag will enable advanced blinking for Field models.
# NOTE: Models have to be patched to support this feature. Vanilla models work out of the box.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff7_advanced_blinking = false

###############################################################################
# OPTIONS ONLY FOR FF8
###############################################################################

## ENHANCEMENTS

# Load higher resolution textures on worldmap
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff8_worldmap_internal_highres_textures = true

# Attempt to fix texturing holes by restoring full precision from the game data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff8_fix_uv_coords_precision = true

# Always use original filenames when looking for external music files.
# Example: `005s-battle.ogg` instead of `battle.ogg`.
# Use this option if you want to use OGG files from Remastered Edition directly in external music
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff8_external_music_force_original_filenames = false

# Use icon textures for gamepad buttons instead of "B1", "B2", etc...
# By default the PS1 icons are used from the game data.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff8_use_gamepad_icons = false

# Allows the windows to not be focused but still get controller inputs
# By default this is false
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff8_always_capture_input = false

# FPS Limiter
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This flag will overwrite the internal FPS limiter of the game.
# Available choices are:
# - 0: Original ( will inherit the default vanilla game behavior, some bugs may appear )
# - 1: Default ( an hybrid mode that fixes most of the known game limiter bugs while preserving the original FPS )
# - 2: 30 FPS ( it will bump Battle mode to 30 FPS, everything else will run in vanilla mode )
# - 3: 60 FPS ( all the game will run in 60 FPS, use this option at your own risk )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff8_fps_limiter = 1

## GAME INSTALLATION OPTIONS

#[APP PATH]
# Overrides the app path if set, can be relative
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
app_path = ""

#[DATA DRIVE]
# Overrides the data drive to read disks if set. Ignored in the Steam edition.
# Example: "F:"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
data_drive = ""

## DEBUGGING OPTIONS - These options are mostly useful for developers or people reporting crashes. Please do enable them only when required.

# Show the PSX SSIGPU VRAM window
#~~~~~~~~~~~~~~~~~~~~~~~~~~~
ff8_ssigpu_debug = false
````

## File: misc/FFNx.varying.flat.def.sc
````
flat vec4 v_color0    : COLOR0    = vec4(0.0, 0.0, 0.0, 0.0);
centroid vec2 v_texcoord0 : TEXCOORD0 = vec2(0.0, 0.0);
vec4 v_position0 : TEXCOORD4 = vec4(0.0, 0.0, 0.0, 0.0);
vec4 v_shadow0 : TEXCOORD5 = vec4(0.0, 0.0, 0.0, 0.0);
vec3 v_normal0 : NORMAL = vec3(0.0, 0.0, 0.0);

vec4 a_position  : POSITION;
vec4 a_color0    : COLOR0;
vec2 a_texcoord0 : TEXCOORD0;
vec3 a_normal : NORMAL;
````

## File: misc/FFNx.varying.smooth.def.sc
````
smooth vec4 v_color0    : COLOR0    = vec4(0.0, 0.0, 0.0, 0.0);
centroid vec2 v_texcoord0 : TEXCOORD0 = vec2(0.0, 0.0);
vec4 v_position0 : TEXCOORD4 = vec4(0.0, 0.0, 0.0, 0.0);
vec4 v_shadow0 : TEXCOORD5 = vec4(0.0, 0.0, 0.0, 0.0);
vec3 v_normal0 : NORMAL = vec3(0.0, 0.0, 0.0);

vec4 a_position  : POSITION;
vec4 a_color0    : COLOR0;
vec2 a_texcoord0 : TEXCOORD0;
vec3 a_normal : NORMAL;
````

## File: misc/FFNx.vert
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

$input a_position, a_color0, a_texcoord0, a_normal
$output v_color0, v_texcoord0, v_position0, v_normal0

#include <bgfx/bgfx_shader.sh>
#include "FFNx.common.sh"

uniform mat4 d3dViewport;
uniform mat4 d3dProjection;
uniform mat4 worldView;
uniform mat4 normalMatrix;
uniform mat4 invViewMatrix;
uniform vec4 gameLightingFlags;
uniform vec4 gameGlobalLightColor;
uniform vec4 gameLightColor1;
uniform vec4 gameLightColor2;
uniform vec4 gameLightColor3;
uniform vec4 gameLightDir1;
uniform vec4 gameLightDir2;
uniform vec4 gameLightDir3;
uniform vec4 gameScriptedLightColor;

uniform vec4 VSFlags;
uniform vec4 WMFlags;

#define isTLVertex VSFlags.x > 0.0
#define blendMode VSFlags.y
#define isFBTexture VSFlags.z > 0.0

#define isApplySphericalWorld WMFlags.x > 0.0
#define sphericaWorldRadiusScale  WMFlags.x

#define gameLightingMode gameLightingFlags.x
#define GAME_LIGHTING_PER_VERTEX 1

void main()
{
    vec4 pos = a_position;
    vec4 color = a_color0;
    vec2 coords = a_texcoord0;

    color.rgb = color.bgr;

    if (isTLVertex)
    {
        pos.w = 1.0 / pos.w;
        pos.xyz *= pos.w;
        pos = mul(u_proj, pos);
    }
    else
    {
        v_position0 = mul(worldView, vec4(pos.xyz, 1.0));

        if (isApplySphericalWorld) pos.xyz = ApplySphericalWorld(v_position0.xyz, sphericaWorldRadiusScale);
        else pos = v_position0;

        pos = mul(mul(d3dViewport, d3dProjection), vec4(pos.xyz, 1.0));
        v_normal0 = mul(normalMatrix, vec4(a_normal, 0.0)).xyz;

        // In this default shader, lighting is applied in gamma space so that it does better match the original lighting
        if (gameLightingMode == GAME_LIGHTING_PER_VERTEX)
        {
            vec3 worldNormal = mul(invViewMatrix, vec4(v_normal0, 0)).xyz;
            float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
            float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
            float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
            vec3 light1Ambient = gameLightColor1.rgb * dotLight1 * dotLight1;
            vec3 light2Ambient = gameLightColor2.rgb * dotLight2 * dotLight2;
            vec3 light3Ambient = gameLightColor3.rgb * dotLight3 * dotLight3;
            vec3 lightAmbient = gameScriptedLightColor.rgb * (gameGlobalLightColor.rgb + light1Ambient + light2Ambient + light3Ambient);
            color.rgb *= gameGlobalLightColor.w * lightAmbient;
        }

        if (color.a > 0.5) color.a = 0.5;
    }

    if (blendMode == 4.0) color.a = 1.0;
    else if (blendMode == 3.0) color.a = 0.25;

#if BGFX_SHADER_LANGUAGE_HLSL
#else
    #if BGFX_SHADER_LANGUAGE_SPIRV
    #else
        if (isFBTexture) coords.y = 1.0 - coords.y;
    #endif
#endif

    gl_Position = pos;
    v_color0 = color;
    v_texcoord0 = coords;
}
````

## File: misc/FFNx.voice.toml
````toml
# FFNx Audio Engine config file - Voice layer

### HOW TO: ###################################################################
# Sections may be commented by default with an initial # character.
# Remove the initial # character to set the entire sections block and its flags
# -----------------------------------------------------------------------------
# Syntax:
# [FIELDNAME/FILENAME(.GAME_MOMENT)]
# flag = value
# another_flag = value
# -----------------------------------------------------------------------------
# where:
# - FIELDNAME: the current field name, for eg. 'md1stin'
# - FILENAME: the filename as you have it in your own folder,
#             for eg. '6' for 6.ogg
# - GAME_MOMENT: OPTIONAL attribute to assign a flag only when game moment
#                matches the ID given, for eg. 'gm-123'
###############################################################################

### SUPPORTED FLAGS: ##########################################################
# volume: Allow volume to be adjusted for a specific track.
# -----------------------------------------------------------------------------
# shuffle: Shuffle a voice track with any of the given one in the array. Each
# item MUST be a string. This flag MUST NOT be used in pair with 'sequential'.
# -----------------------------------------------------------------------------
# sequential: Sequentially playback a voice track with the ones provided in the
# array. Each item MUST be a string. This flag MUST NOT be used in pair with
# 'shuffle'.
###############################################################################

# This entry will set the volume to 50%
# -----------------------------------------------------------------------------
#[md1stin-6]
#volume = 50
#shuffle = [ "foo", "bar" ]
#sequential = [ "foo", "bar" ]

# This entry will set the volume to 0% only when game moment is 123
# -----------------------------------------------------------------------------
#[md1stin-6.gm-123]
#volume = 50
#shuffle = [ "foo", "bar" ]
#sequential = [ "foo", "bar" ]
````

## File: misc/version.rc.in
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <windows.h>

#define VER_FILEVERSION             @_DLL_RCVERSION@
#define VER_FILEVERSION_STR         "@_DLL_RCSTRVERSION@\0"

#define VER_PRODUCTVERSION          @_DLL_RCVERSION@
#define VER_PRODUCTVERSION_STR      "@_DLL_RCSTRVERSION@\0"

#define VER_INTERNALNAME            "@RELEASE_NAME@"
#define VER_PRODUCTNAME             "@RELEASE_NAME@"
#define VER_ORIGINALFILENAME        "@RELEASE_NAME@.dll"

VS_VERSION_INFO VERSIONINFO
FILEVERSION     VER_FILEVERSION
PRODUCTVERSION  VER_PRODUCTVERSION
FILEOS          VOS__WINDOWS32
FILETYPE        VFT_DLL
FILESUBTYPE     VFT2_UNKNOWN
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "CompanyName",      "Julian Xhokaxhiu"
            VALUE "FileDescription",  "Next generation driver for Final Fantasy VII and Final Fantasy VIII ( with native Steam 2013 release support! )"
            VALUE "FileVersion",      VER_FILEVERSION_STR
            VALUE "InternalName",     VER_INTERNALNAME
            VALUE "LegalCopyright",   "GPLv3"
            VALUE "LegalTrademarks1", ""
            VALUE "LegalTrademarks2", ""
            VALUE "OriginalFilename", VER_ORIGINALFILENAME
            VALUE "ProductName",      VER_PRODUCTNAME
            VALUE "ProductVersion",   VER_PRODUCTVERSION_STR
        END
    END

    BLOCK "VarFileInfo"
    BEGIN
        /* The following line should only be modified for localized versions.     */
        /* It consists of any number of WORD,WORD pairs, with each pair           */
        /* describing a language,codepage combination supported by the file.      */
        /*                                                                        */
        /* For example, a file might have values "0x409,1252" indicating that it  */
        /* supports English language (0x409) in the Windows ANSI codepage (1252). */

        VALUE "Translation", 0x409, 1252

    END
END
````

## File: src/audio/memorystream/memorystream.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "memorystream.h"

namespace SoLoud
{
	MemoryStreamInstance::MemoryStreamInstance(MemoryStream* aParent)
	{
		mParent = aParent;
		mOffset = 0;
	}

	uint32_t MemoryStreamInstance::getAudio(float* aBuffer, uint32_t aSamplesToRead, uint32_t aBufferSize)
	{
		uint32_t j, k;
		uint32_t future_offset = mOffset + (aSamplesToRead * mChannels), current_offset = mParent->mPushOffset / sizeof(float);

		if (future_offset <= current_offset)
		{
			for (j = 0; j < aSamplesToRead; j++)
			{
				for (k = 0; k < mChannels; k++)
				{
					aBuffer[k * aSamplesToRead + j] = mParent->mData[mOffset + (j * mChannels) + k];
				}
			}

			mOffset += aSamplesToRead * mChannels;

			return aSamplesToRead;
		}

		return 0;
	}

	bool MemoryStreamInstance::hasEnded()
	{
		if (mOffset >= mParent->mSampleCount)
		{
			return 1;
		}
		return 0;
	}

	MemoryStream::MemoryStream(float sampleRate, uint32_t sampleCount, uint32_t channels)
	{
		mBaseSamplerate = sampleRate;
		mSampleCount = sampleCount;
		mChannels = channels;

    mData = new float[mSampleCount]{ NULL };
    mPushLength = mSampleCount * sizeof(float);
    mPushOffset = 0;
	}

	MemoryStream::~MemoryStream()
	{
		stop();

		delete[] mData;
	}

  result MemoryStream::push(uint8_t* data, uint32_t size)
  {
    uint32_t leftSpace = mPushLength - mPushOffset;

    if ( size > leftSpace ) size = leftSpace;

    memcpy((uint8_t*)mData + mPushOffset, data, size);

    mPushOffset += size;

    return SO_NO_ERROR;
  }

	AudioSourceInstance* MemoryStream::createInstance()
	{
		return new MemoryStreamInstance(this);
	}

	double MemoryStream::getLength()
	{
		if (mBaseSamplerate == 0)
			return 0;

		return mSampleCount / mBaseSamplerate;
	}
};
````

## File: src/audio/memorystream/memorystream.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>
#include <soloud.h>

namespace SoLoud
{
	class MemoryStream : public AudioSource
	{
	public:
		uint32_t mPushLength;
		uint32_t mPushOffset;
		uint32_t mSampleCount;
		float* mData;

		MemoryStream(float sampleRate, uint32_t sampleCount, uint32_t channels);
		virtual ~MemoryStream();

    result push(uint8_t* data, uint32_t size);

		virtual AudioSourceInstance* createInstance();
		time getLength();
	};

	class MemoryStreamInstance : public AudioSourceInstance
	{
		MemoryStream* mParent;
		uint32_t mOffset;
	public:
		MemoryStreamInstance(MemoryStream* aParent);
		virtual uint32_t getAudio(float* aBuffer, uint32_t aSamplesToRead, uint32_t aBufferSize);
		virtual bool hasEnded();
	};
};
````

## File: src/audio/openpsf/openpsf.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "openpsf.h"
#include "utils.h"
#include "log.h"

constexpr auto SOLOUD_OPENPSF_VOLUME_SCALE = float(3.2f / double(0x8000));

namespace SoLoud
{
	OpenPsfInstance::OpenPsfInstance(OpenPsf* aParent)
	{
		ended = false;
		mParent = aParent;
		mOffset = 0;
		mStreamBufferSize = SAMPLE_GRANULARITY * aParent->mChannels;
		mStreamBuffer = new int16_t[mStreamBufferSize];
		mStreamBufferSize *= sizeof(int16_t);
	}

	OpenPsfInstance::~OpenPsfInstance()
	{
		delete[] mStreamBuffer;
	}

	unsigned int OpenPsfInstance::getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
	{
		unsigned int offset = 0;
		unsigned int i, j, k;

		for (i = 0; i < aSamplesToRead; i += SAMPLE_GRANULARITY)
		{
			memset(mStreamBuffer, 0, mStreamBufferSize);
			unsigned int blockSize = aSamplesToRead - i > SAMPLE_GRANULARITY ? SAMPLE_GRANULARITY : aSamplesToRead - i;
			int r = mParent->stream->decode(mStreamBuffer, blockSize);

			if (r == 0) {
				ended = true;
				break;
			}
			else if (r < 0) {
				ffnx_error("OpenPsfInstance::%s Decoding error: %s\n%s\n", __func__, mParent->stream->get_last_error(), mParent->stream->get_last_status());
				break;
			}

			offset += r;

			for (j = 0; j < blockSize; j++)
			{
				for (k = 0; k < mChannels; k++)
				{
					aBuffer[k * aSamplesToRead + i + j] = mStreamBuffer[j * mChannels + k] * SOLOUD_OPENPSF_VOLUME_SCALE;
				}
			}
		}

		mOffset += offset;

		return offset;
	}

	result OpenPsfInstance::rewind()
	{
		mParent->stream->rewind();

		ended = false;
		mOffset = 0;
		mStreamPosition = 0.0f;
		return SO_NO_ERROR;
	}

	result OpenPsfInstance::seek(double aSeconds, float *mScratch, unsigned int mScratchSize)
	{
		double offset = aSeconds - mStreamPosition;

		if (offset <= 0)
		{
			if (rewind() != SO_NO_ERROR)
			{
				// can't do generic seek backwards unless we can rewind.
				return NOT_IMPLEMENTED;
			}
			offset = aSeconds;
		}

		int samples_to_discard = int(floor(mSamplerate * offset));

		mOffset = samples_to_discard;

		while (samples_to_discard)
		{
			samples_to_discard -= mParent->stream->decode(nullptr, samples_to_discard);
		}

		mStreamPosition = aSeconds;
		return SO_NO_ERROR;
	}

	bool OpenPsfInstance::hasEnded()
	{
		return !(mFlags & AudioSourceInstance::LOOPING) && (ended || mOffset >= mParent->mSampleCount);
	}

	OpenPsf::OpenPsf() :
		stream(nullptr), mSampleCount(0)
	{
	}

	OpenPsf::~OpenPsf()
	{
		stop();

		if (stream != nullptr) {
			delete stream;
		}
	}

	bool OpenPsf::is_our_path(const char* aFilename)
	{
		const char* ext = strrchr(aFilename, '.');
		if (!ext) {
			return Psf::is_our_path(aFilename, aFilename);
		}
		return Psf::is_our_path(aFilename, ext + 1);
	}

	result OpenPsf::load(const char* aFilename, bool suppressOpeningSilence)
	{
		mBaseSamplerate = 0;

		if (aFilename == nullptr) {
			return INVALID_PARAMETER;
		}

		if (! fileExists(aFilename)) {
			return FILE_NOT_FOUND;
		}

		stop();

		stream = new Psf(suppressOpeningSilence ? PsfFlags::SuppressOpeningSilence : PsfFlags::PsfDefaults, 0);
		if (!stream->open(aFilename, true)) {
			ffnx_error("Cannot open file %s: %s\n%s\n", aFilename, stream->get_last_error(), stream->get_last_status());
			return FILE_LOAD_FAILED;
		}

		mBaseSamplerate = float(stream->get_sample_rate());
		mSampleCount = stream->get_sample_count();
		mChannels = stream->get_channel_count();
		setLooping(true);

		if (trace_all || trace_music) ffnx_info("Opening file %s with openPSF (samplerate: %i, samplecount: %i, channels: %i):\n%s\n",
			aFilename, int(mBaseSamplerate), stream->get_sample_count(), mChannels, stream->get_last_status());

		return SO_NO_ERROR;
	}

	AudioSourceInstance* OpenPsf::createInstance()
	{
		return new OpenPsfInstance(this);
	}

	double OpenPsf::getLength()
	{
		if (mBaseSamplerate == 0) {
			return 0;
		}

		return mSampleCount / mBaseSamplerate;
	}
};
````

## File: src/audio/openpsf/openpsf.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <soloud.h>
#include <stdint.h>
#include <openpsf/openpsf.h>

namespace SoLoud
{
	class OpenPsf : public AudioSource
	{
	public:
		Psf* stream;
		unsigned int mSampleCount;

		OpenPsf();
		virtual ~OpenPsf();
		static bool is_our_path(const char* aFilename);
		result load(const char* aFilename, bool suppressOpeningSilence = false);

		virtual AudioSourceInstance* createInstance();
		time getLength();
	};

	class OpenPsfInstance : public AudioSourceInstance
	{
		size_t mStreamBufferSize;
		int16_t* mStreamBuffer;
		OpenPsf* mParent;
		unsigned int mOffset;
		bool ended;
	public:
		OpenPsfInstance(OpenPsf* aParent);
		virtual ~OpenPsfInstance();
		virtual unsigned int getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
		virtual result rewind();
		virtual result seek(double aSeconds, float *mScratch, unsigned int mScratchSize);
		virtual bool hasEnded();
	};
};
````

## File: src/audio/vgmstream/vgmstream.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "vgmstream.h"
#include "../../utils.h"

namespace SoLoud
{
	VGMStreamInstance::VGMStreamInstance(VGMStream* aParent)
	{
		mParent = aParent;
		mStreamBuffer = new sample_t[SAMPLE_GRANULARITY * aParent->mChannels];

		rewind();
	}

	VGMStreamInstance::~VGMStreamInstance()
	{
		delete[] mStreamBuffer;
	}

	unsigned int VGMStreamInstance::getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
	{
		memset(mStreamBuffer, 0, sizeof(sample_t) * SAMPLE_GRANULARITY * mChannels);
		int sample_count = render_vgmstream2(mStreamBuffer, aSamplesToRead, mParent->mStream);

		for (int j = 0; j < sample_count; j++)
		{
			for (unsigned int k = 0; k < mChannels; k++)
			{
				aBuffer[k * aSamplesToRead + j] = mStreamBuffer[(j * mChannels) + k] / (float)INT16_MAX;
			}
		}

		mOffset += sample_count;

		// If the song is looping, recalculate the offset correctly
		if (mFlags & AudioSourceInstance::LOOPING) {
			if (mOffset >= mParent->mStream->loop_end_sample)
			{
				mOffset = mOffset - mParent->mSampleCount + mParent->mStream->loop_start_sample;
			}
		}

		return sample_count;
	}

	result VGMStreamInstance::rewind()
	{
		reset_vgmstream(mParent->mStream);

		mOffset = 0;
		mStreamPosition = 0.0f;
		return SO_NO_ERROR;
	}

	result VGMStreamInstance::seek(double aSeconds, float* mScratch, unsigned int mScratchSize)
	{
		mOffset = int(floor(mSamplerate * aSeconds));

		seek_vgmstream(mParent->mStream, mOffset);

		mStreamPosition = aSeconds;
		return SO_NO_ERROR;
	}

	bool VGMStreamInstance::hasEnded()
	{
		if (!(mFlags & AudioSourceInstance::LOOPING) && mOffset >= mParent->mSampleCount)
		{
			return 1;
		}
		return 0;
	}

	VGMStream::VGMStream()
	{
		mSampleCount = 0;
	}

	VGMStream::~VGMStream()
	{
		stop();

		close_vgmstream(mStream);
	}

	VGMSTREAM* VGMStream::init_vgmstream_with_extension(const char* aFilename, const char* ext)
	{
		STREAMFILE* streamFile = open_stdio_streamfile(aFilename);
		if (streamFile == nullptr) {
			return nullptr;
		}
		// Force extension
		streamFile = open_fakename_streamfile_f(streamFile, nullptr, ext);
		if (streamFile == nullptr) {
			return nullptr;
		}
		VGMSTREAM* stream = init_vgmstream_from_STREAMFILE(streamFile);
		close_streamfile(streamFile);
		return stream;
	}

	result VGMStream::load(const char* aFilename, const char* ext)
	{
		mBaseSamplerate = 0;

		if (aFilename == 0)
			return INVALID_PARAMETER;

		if (! fileExists(aFilename))
			return FILE_NOT_FOUND;

		stop();

		if (ext && ext[0] != '\0') {
			mStream = init_vgmstream_with_extension(aFilename, ext);
		}
		else {
			mStream = init_vgmstream(aFilename);
		}

		if (mStream == nullptr) {
			return FILE_LOAD_FAILED;
		}

		mBaseSamplerate = (float)mStream->sample_rate;
		mSampleCount = (unsigned int)mStream->num_samples;
		mChannels = mStream->channels;

		// Autodetect looping from the file itself and just inform SoLoud about it
		if (mStream->loop_flag) setLooping(true);
		// If the file has no loop tags, but the users wants to loop, force a basic start to end loop
		else if (mFlags & AudioSourceInstance::LOOPING) vgmstream_force_loop(mStream, true, 0, mStream->num_samples);

		return SO_NO_ERROR;
	}

	AudioSourceInstance* VGMStream::createInstance()
	{
		return new VGMStreamInstance(this);
	}

	double VGMStream::getLength()
	{
		if (mBaseSamplerate == 0)
			return 0;

		return mSampleCount / mBaseSamplerate;
	}
};
````

## File: src/audio/vgmstream/vgmstream.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <soloud.h>

#if defined(__cplusplus)
extern "C" {
#endif

#include <libvgmstream/vgmstream.h>

#if defined(__cplusplus)
}
#endif

namespace SoLoud
{
	class VGMStream : public AudioSource
	{
		static VGMSTREAM* init_vgmstream_with_extension(const char* aFilename, const char* ext);
	public:
		VGMSTREAM* mStream;
		unsigned int mSampleCount;

		sample_t* mData;

		VGMStream();
		virtual ~VGMStream();
		result load(const char* aFilename, const char* ext = nullptr);

		virtual AudioSourceInstance* createInstance();
		time getLength();
	};

	class VGMStreamInstance : public AudioSourceInstance
	{
		sample_t* mStreamBuffer;
		VGMStream* mParent;
		unsigned int mOffset;
	public:
		VGMStreamInstance(VGMStream* aParent);
		virtual ~VGMStreamInstance();
		virtual unsigned int getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
		virtual result rewind();
		virtual result seek(double aSeconds, float *mScratch, unsigned int mScratchSize);
		virtual bool hasEnded();
	};
};
````

## File: src/ff7/battle/animations.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <unordered_set>
#include <unordered_map>
#include <intrin.h>
#include <algorithm>

#include "../../ff7.h"
#include "../../log.h"
#include "../../patch.h"
#include "../../globals.h"

#include "animations.h"
#include "defs.h"
#include "effect.h"
#include "menu.h"
#include "../widescreen.h"

namespace ff7::battle
{
    byte y_pos_offset_display_damage_30[] = {0, 1, 2, 3, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 7, 7, 6, 6, 5, 4, 3, 2};
    byte y_pos_offset_display_damage_60[] = {0, 1, 2, 3, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7, 6, 6, 5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, 4, 4, 3, 2, 1, 0, 0, 1, 1, 0, 0, 0};
    WORD ff7_odin_steel_frames_AEEC14;
    std::map<uint32_t, std::set<short>> kotr_excluded_frames;
    std::map<uint32_t, int> camera_thresholds_by_address, model_thresholds_by_address;
    std::set<uint32_t> fixed_effect100_addresses, one_call_effect100_addresses, camera_effect100_addresses, model_effect100_addresses;

    std::array<AuxiliaryEffectHandler, 100> aux_effect100_handler;
    std::array<AuxiliaryEffectHandler, 60> aux_effect60_handler;
    std::array<AuxiliaryEffectHandler, 10> aux_effect10_handler;

    std::shared_ptr<EffectDecorator> currentEffectDecorator;
    bool isAddFunctionDisabled = false;

    byte getActorIdleAnimScript(byte actorID)
    {
        return ff7_externals.g_actor_idle_scripts[actorID];
    }

    battle_model_state *getBattleModelState(byte actorID)
    {
        return &(ff7_externals.g_battle_model_state[actorID]);
    }

    battle_model_state_small *getSmallBattleModelState(byte actorID)
    {
        return &(ff7_externals.g_small_battle_model_state[actorID]);
    }

    byte *getAnimScriptPointer(byte **ptrToScriptTable, battle_model_state &ownerModelState)
    {
        byte *scriptPtr = ptrToScriptTable[ownerModelState.animScriptIndex];
        if (ownerModelState.animScriptIndex >= 0x2E && ownerModelState.animScriptIndex <= 0x3B && ownerModelState.animScriptIndex != 0x33)
        {
            if (ownerModelState.animScriptIndex == 0x39)
                ownerModelState.field_25 |= 0x80u;
            scriptPtr = ff7_externals.animation_script_pointers[ownerModelState.animScriptIndex - 0x2E];
        }
        return scriptPtr;
    }

    void run_animation_script(byte actorID, byte **ptrToScriptTable)
    {
        // creates copy of model states
        battle_model_state ownerModelState = *getBattleModelState(actorID);
        battle_model_state_small smallModelState = *getSmallBattleModelState(actorID);

        byte script_wait_frames = *ff7_externals.g_script_wait_frames;
        bool hasSetWaitFrames = false;

        if (!*ff7_externals.g_is_battle_paused)
        {
            bool isScriptActive = true;
            byte *scriptPtr = getAnimScriptPointer(ptrToScriptTable, ownerModelState);

            if (ownerModelState.modelEffectFlags & 1)
            {
                ownerModelState.isScriptExecuting = 1;
                ownerModelState.currentScriptPosition = 0;
                ownerModelState.waitFrames = 0;
            }
            if (ownerModelState.isScriptExecuting)
            {
                ownerModelState.playedAnimFrames = 0;
                while (isScriptActive)
                {
                    byte currentOpCode = scriptPtr[ownerModelState.currentScriptPosition++];

                    switch (currentOpCode)
                    {
                    case 0xC5:
                        ownerModelState.waitFrames = script_wait_frames;
                        hasSetWaitFrames = true;
                        break;
                    case 0xC6:
                        script_wait_frames = std::min(scriptPtr[ownerModelState.currentScriptPosition++] * battle_frame_multiplier, 255);
                        break;
                    case 0x9E:
                        if (actorID == *ff7_externals.special_actor_id)
                        {
                            if (*ff7_externals.effect100_counter != 0)
                                ownerModelState.currentScriptPosition--;
                        }
                        else if (!(getBattleModelState(*ff7_externals.special_actor_id)->actorIsNotActing == 1 && *ff7_externals.effect100_counter == 0))
                        {
                            ownerModelState.currentScriptPosition--;
                        }
                        isScriptActive = false;
                        break;
                    case 0xB3:
                        if ((smallModelState.field_0 & 0x1000) != 0)
                        {
                            byte position;
                            do
                                position = scriptPtr[ownerModelState.currentScriptPosition++];
                            while (position != 0xB2);
                        }
                        break;
                    case 0xC1:
                        ownerModelState.currentScriptPosition = 0;
                        byte position;
                        do
                            position = scriptPtr[ownerModelState.currentScriptPosition++];
                        while (position != 0xC9);
                        break;
                    case 0xCA:
                        if (*ff7_externals.g_is_effect_loading)
                        {
                            ownerModelState.currentScriptPosition = 0;
                            byte position;
                            do
                                position = scriptPtr[ownerModelState.currentScriptPosition++];
                            while (position != 0xC9);
                        }
                        break;
                    case 0xCE:
                        if (actorID >= 4)
                        {
                            byte position;
                            do
                                position = scriptPtr[ownerModelState.currentScriptPosition++];
                            while (position != 0xCD);
                        }
                        break;
                    case 0xEB:
                    case 0xEC:
                        if (*ff7_externals.g_is_effect_loading)
                        {
                            ownerModelState.currentScriptPosition--;
                            isScriptActive = false;
                        }
                        break;
                    case 0xF3:
                        if (ownerModelState.waitFrames != 0)
                        {
                            ownerModelState.waitFrames--;
                            ownerModelState.currentScriptPosition--;
                            isScriptActive = false;
                        }
                        break;
                    case 0xF4:
                        ownerModelState.waitFrames = std::min(scriptPtr[ownerModelState.currentScriptPosition++] * battle_frame_multiplier, 255);
                        hasSetWaitFrames = true;
                        break;
                    case 0xFE:
                        if (ownerModelState.waitFrames == 0)
                        {
                            currentOpCode = scriptPtr[ownerModelState.currentScriptPosition];
                            if (currentOpCode == 0xC0)
                            {
                                ownerModelState.currentScriptPosition = 0;
                                ownerModelState.waitFrames = 0;
                                ownerModelState.isScriptExecuting = 0;
                                ownerModelState.runningAnimIdx = *scriptPtr;
                                ownerModelState.animScriptIndex = getActorIdleAnimScript(actorID);
                                scriptPtr = ptrToScriptTable[ownerModelState.animScriptIndex];
                            }
                        }
                        break;
                    case 0xEE:
                    case 0xFF:
                        ownerModelState.actorIsNotActing = 1;
                        ownerModelState.currentScriptPosition = 0;
                        ownerModelState.isScriptExecuting = 0;
                        ownerModelState.waitFrames = 0;
                        ownerModelState.animScriptIndex = getActorIdleAnimScript(actorID);
                        scriptPtr = ptrToScriptTable[ownerModelState.animScriptIndex];
                        break;
                    default:
                        if (numArgsOpCode.contains(currentOpCode))
                        {
                            ownerModelState.currentScriptPosition += numArgsOpCode.at(currentOpCode);
                            if (endingOpCode.contains(currentOpCode))
                                isScriptActive = false;
                        }
                        else
                        {
                            isScriptActive = false;
                        }
                        break;
                    }
                }
            }
        }

        // execute original run animation script
        ((void (*)(byte, byte **))ff7_externals.run_animation_script)(actorID, ptrToScriptTable);

        if(hasSetWaitFrames)
            getBattleModelState(actorID)->waitFrames = ownerModelState.waitFrames;
    }

    int add_fn_to_effect100_fn(uint32_t function)
    {
        int idx;
        for (idx = 0; idx < ff7_externals.effect100_array_fn.size(); idx++)
        {
            if (ff7_externals.effect100_array_fn[idx] == 0 && *ff7_externals.effect100_array_idx <= idx)
                break;
        }
        if (idx >= ff7_externals.effect100_array_fn.size())
            return 0xFFFF;
        if (isAddFunctionDisabled)
            return idx;

        ff7_externals.effect100_array_fn[idx] = function;
        ff7_externals.effect100_array_data[idx].field_0 = *ff7_externals.effect100_array_idx;
        *ff7_externals.effect100_counter = *ff7_externals.effect100_counter + 1;

        aux_effect100_handler[idx] = AuxiliaryEffectHandler();
        return idx;
    }

    void add_kotr_camera_fn_to_effect100_fn(DWORD param_1, DWORD param_2, WORD param_3)
    {
        ff7_externals.add_kotr_camera_fn_to_effect100_fn_476AAB(param_1, param_2, param_3);

        int kotr_camera_idx = ff7_externals.effect100_array_fn.size() - 1;
        aux_effect100_handler[kotr_camera_idx] = AuxiliaryEffectHandler();
    }

    void execute_effect100_fn()
    {
        uint16_t &fn_index = *ff7_externals.effect100_array_idx;
        for (fn_index = 0; fn_index < ff7_externals.effect100_array_fn.size(); fn_index++)
        {
            if(ff7_externals.effect100_array_fn[fn_index] && *ff7_externals.g_is_battle_running_9AD1AC)
            {
                if (aux_effect100_handler[fn_index].isFirstFrame())
                {
                    if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.display_battle_action_text_42782A)
                    {
                        ff7_externals.effect100_array_data[fn_index].field_6 *= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.battle_sub_425D29)
                    {
                        ff7_externals.effect100_array_data[fn_index].n_frames *= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.battle_sub_5BDA0F)
                    {
                        ff7_externals.effect100_array_data[fn_index].field_2 /= battle_frame_multiplier;
                        ff7_externals.effect100_array_data[fn_index].n_frames *= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.tifa_limit_1_2_sub_4E3D51 ||
                            ff7_externals.effect100_array_fn[fn_index] == ff7_externals.tifa_limit_2_1_sub_4E48D4)
                    {
                        ff7_externals.effect100_array_data[fn_index].field_1A *= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.run_odin_steel_sub_4A9908)
                    {
                        ff7_odin_steel_frames_AEEC14 = *ff7_externals.field_odin_frames_AEEC14 * battle_frame_multiplier;
                    }
                    else if (fixed_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
                    {
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<NoEffectDecorator>());
                    }
                    else if (one_call_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
                    {
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<OneCallEffectDecorator>(battle_frame_multiplier));
                    }
                    else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.run_chocobuckle_main_loop_560C32)
                    {
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<ModelInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, false,
                                                                                                                            &ff7_externals.effect100_array_data[fn_index].field_0, 3, 10000));
                    }
                    else if(ff7_externals.effect100_array_fn[fn_index] == ff7_externals.barret_limit_4_1_model_movement_4698EF)
                    {
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<ModelInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, false,
                                                                                                                            &ff7_externals.effect100_array_data[fn_index].field_0, *ff7_externals.barret_limit_4_1_actor_id, 3000));
                    }
                    else if (model_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
                    {
                        int threshold = 1000;
                        if (model_thresholds_by_address.contains(ff7_externals.effect100_array_fn[fn_index]))
                            threshold = model_thresholds_by_address[ff7_externals.effect100_array_fn[fn_index]];
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<ModelInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, true,
                                                                                                                            &ff7_externals.effect100_array_data[fn_index].field_0, 3, threshold));
                    }
                    else if (camera_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
                    {
                        int threshold = 1500;
                        if (camera_thresholds_by_address.contains(ff7_externals.effect100_array_fn[fn_index]))
                            threshold = camera_thresholds_by_address[ff7_externals.effect100_array_fn[fn_index]];
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<CameraInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, &ff7_externals.effect100_array_data[fn_index].field_0, threshold));
                    }
                    else if (kotr_excluded_frames.contains(ff7_externals.effect100_array_fn[fn_index]))
                    {
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<FixCounterExceptionEffectDecorator>(battle_frame_multiplier, &ff7_externals.effect100_array_data[fn_index].field_0,
                                                                                                                                &ff7_externals.effect100_array_data[fn_index].field_2, &isAddFunctionDisabled, kotr_excluded_frames[ff7_externals.effect100_array_fn[fn_index]]));
                    }
                    else
                    {
                        aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<InterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused));
                    }

                    if (trace_all || trace_battle_animation)
                        ffnx_trace("%s - begin function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
                                ff7_externals.effect100_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
                                ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);

                    aux_effect100_handler[fn_index].disableFirstFrame();
                }

                currentEffectDecorator = aux_effect100_handler[fn_index].getEffectDecorator();
                aux_effect100_handler[fn_index].executeEffectFunction(ff7_externals.effect100_array_fn[fn_index]);
                currentEffectDecorator = nullptr;

                if (ff7_externals.effect100_array_data[fn_index].field_0 == (uint16_t)-1)
                {
                    if (trace_all || trace_battle_animation)
                        ffnx_trace("%s - end function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
                                ff7_externals.effect100_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
                                ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);

                    ff7_externals.effect100_array_data[fn_index].field_0 = 0;
                    ff7_externals.effect100_array_data[fn_index].field_2 = 0;
                    ff7_externals.effect100_array_fn[fn_index] = 0;
                    *ff7_externals.effect100_counter = *ff7_externals.effect100_counter - 1;
                }
            }
            else if(ff7_externals.effect100_array_fn[fn_index] == ff7_externals.display_battle_action_text_42782A)
            {
                if (aux_effect100_handler[fn_index].isFirstFrame())
                {
                    ff7_externals.effect100_array_data[fn_index].field_6 *= battle_frame_multiplier;
                    aux_effect100_handler[fn_index].disableFirstFrame();
                }

                ((void (*)())ff7_externals.effect100_array_fn[fn_index])();
            }
        }
        fn_index = 0;
    }

    int add_fn_to_effect10_fn(uint32_t function)
    {
        int idx;
        for (idx = 0; idx < ff7_externals.effect10_array_fn.size(); idx++)
        {
            if (ff7_externals.effect10_array_fn[idx] == 0 && *ff7_externals.effect10_array_idx <= idx)
                break;
        }
        if (idx >= ff7_externals.effect10_array_fn.size())
            return 0xFFFF;
        if (isAddFunctionDisabled)
            return idx;

        ff7_externals.effect10_array_fn[idx] = function;
        ff7_externals.effect10_array_data[idx].field_0 = *ff7_externals.effect10_array_idx;
        *ff7_externals.effect10_counter = *ff7_externals.effect10_counter + 1;

        aux_effect10_handler[idx] = AuxiliaryEffectHandler();
        return idx;
    }

    void execute_effect10_fn()
    {
        uint16_t &fn_index = *ff7_externals.effect10_array_idx;
        for (fn_index = 0; fn_index < ff7_externals.effect10_array_fn.size(); fn_index++)
        {
            auto &effect10_data = ff7_externals.effect10_array_data[fn_index];
            if (ff7_externals.effect10_array_fn[fn_index] != 0)
            {
                if (aux_effect10_handler[fn_index].isFirstFrame())
                {
                    if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_426DE3)
                    {
                        // Related to resting positions
                        effect10_data.n_frames *= battle_frame_multiplier;
                        effect10_data.field_18 *= battle_frame_multiplier;
                        effect10_data.field_C /= battle_frame_multiplier;
                        effect10_data.field_E /= battle_frame_multiplier;
                        effect10_data.field_6 /= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_426941)
                    {
                        // Increment model position X and Z for n_frames
                        // Used by Tonberry to set the position after its moving animation
                        if(effect10_data.n_frames > 1)
                        {
                            effect10_data.n_frames *= battle_frame_multiplier;
                            effect10_data.field_A /= battle_frame_multiplier;
                            effect10_data.field_C /= battle_frame_multiplier;
                        }
                    }
                    else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_426899)
                    {
                        // Related to resting Y rotation
                        effect10_data.n_frames *= battle_frame_multiplier;
                        effect10_data.field_E /= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_4267F1)
                    {
                        // Related to resting Y position
                        effect10_data.n_frames *= battle_frame_multiplier;
                        effect10_data.field_A /= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_426A26)
                    {
                        // Animation of moving characters from attacker to attacked
                        effect10_data.n_frames *= battle_frame_multiplier;
                        effect10_data.field_18 *= battle_frame_multiplier;
                        effect10_data.field_C /= battle_frame_multiplier;
                        effect10_data.field_E /= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_42739D)
                    {
                        // Animation of moving characters from attacker to attacked
                        effect10_data.n_frames *= battle_frame_multiplier;
                        effect10_data.field_19 *= battle_frame_multiplier;
                        effect10_data.field_1A *= battle_frame_multiplier;
                        effect10_data.field_C /= battle_frame_multiplier;
                        effect10_data.field_E /= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_426F58)
                    {
                        effect10_data.n_frames *= battle_frame_multiplier;
                        // Do not modify the others, already done elsewhere
                    }
                    else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_4270DE)
                    {
                        // Animation of moving characters for some limit breaks from attacker to attacked
                        effect10_data.n_frames *= battle_frame_multiplier;
                        effect10_data.field_19 *= battle_frame_multiplier;
                        effect10_data.field_1A *= battle_frame_multiplier;
                        effect10_data.field_C /= battle_frame_multiplier;
                        effect10_data.field_E /= battle_frame_multiplier;
                        effect10_data.field_14 /= battle_frame_multiplier;
                    }
                    if (trace_all || trace_battle_animation)
                        ffnx_trace("%s - begin function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
                                ff7_externals.effect10_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
                                ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);

                    aux_effect10_handler[fn_index].disableFirstFrame();
                }

                ((void (*)())ff7_externals.effect10_array_fn[fn_index])();

                if (effect10_data.field_0 == (uint16_t)-1)
                {
                    if (trace_all || trace_battle_animation)
                        ffnx_trace("%s - end function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
                                ff7_externals.effect10_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
                                ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);

                    effect10_data.field_0 = 0;
                    effect10_data.field_2 = 0;
                    ff7_externals.effect10_array_fn[fn_index] = 0;
                    *ff7_externals.effect10_counter = *ff7_externals.effect10_counter - 1;
                }
            }
        }
        fn_index = 0;
    }

    int add_fn_to_effect60_fn(uint32_t function)
    {
        int idx;
        for (idx = 0; idx < ff7_externals.effect60_array_fn.size(); idx++)
        {
            if (ff7_externals.effect60_array_fn[idx] == 0 && *ff7_externals.effect60_array_idx <= idx)
                break;
        }
        if (idx >= ff7_externals.effect60_array_fn.size())
            return 0xFFFF;
        if (isAddFunctionDisabled)
            return idx;

        ff7_externals.effect60_array_fn[idx] = function;
        ff7_externals.effect60_array_data[idx].field_0 = *ff7_externals.effect60_array_idx;
        *ff7_externals.effect60_counter = *ff7_externals.effect60_counter + 1;

        aux_effect60_handler[idx] = AuxiliaryEffectHandler();
        return idx;
    }

    void execute_effect60_fn()
    {
        uint16_t &fn_index = *ff7_externals.effect60_array_idx;
        for (fn_index = 0; fn_index < ff7_externals.effect60_array_fn.size(); fn_index++)
        {
            if (ff7_externals.effect60_array_fn[fn_index] != 0)
            {
                if (aux_effect60_handler[fn_index].isFirstFrame())
                {
                    if (ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_4276B6 ||
                        ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_4255B7 ||
                        ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_427737 ||
                        ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_425AAD ||
                        ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_427AF1 ||
                        ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_4277B1)
                    {
                        ff7_externals.effect60_array_data[fn_index].n_frames *= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5BD96D)
                    {
                        ff7_externals.effect60_array_data[fn_index].n_frames *= battle_frame_multiplier;
                        ff7_externals.effect60_array_data[fn_index].field_2 /= battle_frame_multiplier;
                    }
                    else if (ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_425E5F ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5C1C8F ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5BCF9D ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.handle_aura_effects_425520 ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_boss_death_sub_5BC5EC ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5BCD42 ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.display_battle_damage_5BB410 ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.limit_break_aura_effects_5C0572 ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.enemy_skill_aura_effects_5C06BF ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.summon_aura_effects_5C0953 ||
                            ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5C18BC)
                    {
                        aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<NoEffectDecorator>());
                    }
                    else if(ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_smoke_move_handler_5BE4E2)
                    {
                        aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<OneCallEffectDecorator>(battle_frame_multiplier));
                    }
                    else if(ff7_externals.effect60_array_fn[fn_index] == ff7_externals.vincent_limit_satan_slam_camera_45CF2A)
                    {
                        aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<CameraInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, &ff7_externals.effect60_array_data[fn_index].field_0));
                    }
                    else
                    {
                        aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<InterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused));
                    }

                    if (trace_all || trace_battle_animation)
                        ffnx_trace("%s - begin function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
                                ff7_externals.effect60_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
                                ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);

                    aux_effect60_handler[fn_index].disableFirstFrame();
                }

                currentEffectDecorator = aux_effect60_handler[fn_index].getEffectDecorator();
                aux_effect60_handler[fn_index].executeEffectFunction(ff7_externals.effect60_array_fn[fn_index]);
                currentEffectDecorator = nullptr;

                if (ff7_externals.effect60_array_data[fn_index].field_0 == (uint16_t)-1)
                {
                    if (trace_all || trace_battle_animation)
                        ffnx_trace("%s - end function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
                                ff7_externals.effect60_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
                                ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);

                    ff7_externals.effect60_array_data[fn_index].field_0 = 0;
                    ff7_externals.effect60_array_data[fn_index].field_2 = 0;
                    ff7_externals.effect60_array_fn[fn_index] = 0;
                    *ff7_externals.effect60_counter = *ff7_externals.effect60_counter - 1;
                }
            }
        }
        fn_index = 0;
    }

    void run_boss_death_animation_5BC5EC()
    {
        auto &fn_data = ff7_externals.effect60_array_data[*ff7_externals.effect60_array_idx];
        if (fn_data.n_frames == 0)
        {
            fn_data.field_0 = 0xFFFF;
        }
        else
        {
            if (fn_data.n_frames == (58 * battle_frame_multiplier) || fn_data.n_frames == (64 * battle_frame_multiplier))
                *ff7_externals.field_battle_BFB2E0 = ((uint32_t(*)(byte, byte, byte))ff7_externals.battle_boss_death_call_5BD436)(0xFA, 0xFA, 0xFA);

            std::array<short, 8> offset_z_position{64, 32, 0, -32, -64, -32, 0, 32};
            int index = ((fn_data.n_frames * (4 / battle_frame_multiplier)) % offset_z_position.size());
            getBattleModelState(fn_data.field_8)->modelPosition.z = fn_data.field_A + offset_z_position[index];
            fn_data.n_frames--;
        }
    }

    int get_n_frames_display_action_string()
    {
        int shiftValue = 2 - battle_frame_multiplier / 2;
        return ((int)*ff7_externals.field_byte_DC0E11 >> shiftValue) + 4 * battle_frame_multiplier;
    }

    void run_disintegrate_1_death_sub_5BC04D(byte effect10_array_idx)
    {
        auto &fn_data = ff7_externals.effect10_array_data[effect10_array_idx];
        auto &battle_model_state = *getBattleModelState(fn_data.field_8);
        if (fn_data.n_frames == 0)
        {
            fn_data.field_0 = 0xFFFF;
            battle_model_state.field_25 &= 0x7F;
            battle_model_state.field_C &= 0xFFDF;
            battle_model_state.actorIsNotActing = 1;
            ((void (*)(byte))ff7_externals.battle_sub_42C0A7)(fn_data.field_8);
        }
        else
        {
            battle_model_state.field_14 += 0x80 / battle_frame_multiplier;
            if (battle_model_state.field_28 > 0)
                battle_model_state.field_28 -= 0x10 / battle_frame_multiplier;

            battle_model_state.field_1AC8 = 1;

            // effect10_array_data_8FE1F6 is a short array of 15 size. To avoid overflowing, divide also the index
            battle_model_state.field_1ADC += (float)(int)ff7_externals.effect10_array_data_8FE1F6[(int)(fn_data.n_frames / battle_frame_multiplier)] / battle_frame_multiplier;
            battle_model_state.field_1ACC += 22.5f / battle_frame_multiplier;
            battle_model_state.field_1AD0 += 22.5f / battle_frame_multiplier;
            battle_model_state.field_1AD4 += 22.5f / battle_frame_multiplier;
            fn_data.n_frames--;
        }
    }

    void battle_move_character_sub_426F58()
    {
        auto &fn_data = ff7_externals.effect10_array_data[*ff7_externals.effect10_array_idx];
        if (fn_data.n_frames == 0)
        {
            fn_data.field_0 = 0xFFFF;
        }
        else
        {
            *ff7_externals.g_script_args[2] = fn_data.field_A;
            *ff7_externals.g_script_args[3] = fn_data.field_8;
            *ff7_externals.g_script_args[4] = fn_data.field_10;
            getBattleModelState(*ff7_externals.g_script_args[3])->modelPosition.x += fn_data.field_C / battle_frame_multiplier;
            getBattleModelState(*ff7_externals.g_script_args[3])->modelPosition.z += fn_data.field_E / battle_frame_multiplier;

            int index = (int)(fn_data.field_18 / battle_frame_multiplier) + *ff7_externals.g_script_args[4] * 8; // to avoid overflow
            getBattleModelState(*ff7_externals.g_script_args[3])->modelPosition.y += ff7_externals.resting_Y_array_data[index] / battle_frame_multiplier;
            fn_data.field_18++;
            fn_data.n_frames--;
        }
    }

    void battle_play_sfx_delayed_427737()
    {
        constexpr byte cid_id = 0x08;
        constexpr short cloud_sfx_attack_id = 18;

        byte actor_id = ff7_externals.anim_event_queue[0].attackerID;
        auto &fn_data = ff7_externals.effect60_array_data[*ff7_externals.effect60_array_idx];

        // Disable bugged battle SFX when Cid is attacking, but SFX ID is cloud's one
        if(ff7_externals.battle_context->actor_vars[actor_id].index == cid_id && fn_data.field_6 == cloud_sfx_attack_id)
        {
            fn_data.field_0 = 0xFFFF;
        }
        else
        {
            if ( fn_data.n_frames )
            {
                fn_data.n_frames--;
            }
            else
            {
                ff7_externals.battle_play_sfx_sound_430D32(fn_data.field_6, *ff7_externals.g_active_actor_id, 0);
                fn_data.field_0 = 0xFFFF;
            }
        }
    }

    void run_ifrit_movement_596702()
    {
        auto &effect_data = ff7_externals.effect100_array_data[*ff7_externals.effect100_array_idx];
        vector3<short> &ifrit_position = *ff7_externals.battle_ifrit_model_position;

        int frames = effect_data.field_2;
        if((*ff7_externals.byte_BCC788 & 1) == 0)
        {
            *ff7_externals.byte_BCC788 |= 1u;
            *ff7_externals.ifrit_vector3_int_ptr_BCC6A8 = ff7_externals.battle_sub_661000(0);
        }
        std::vector<int> ifrit_og_phases = {0, 30, 131, 146, 149, 169};
        std::vector<int> ifrit_new_phases;
        std::transform(ifrit_og_phases.begin(), ifrit_og_phases.end(), std::back_inserter(ifrit_new_phases), [](int value){return value * battle_frame_multiplier;});
        if(!*ff7_externals.g_is_battle_paused)
        {
            if(frames >= ifrit_new_phases[0] && frames < ifrit_new_phases[1])
            {
                int internal_frames = frames - ifrit_new_phases[0];
                ifrit_position.y = -2000 * internal_frames / (ifrit_new_phases[1] - ifrit_new_phases[0]);
            }
            else if(frames >= ifrit_new_phases[2] && frames < ifrit_new_phases[3])
            {
                short previous_position = -2000 * (ifrit_new_phases[1] - 1) / (ifrit_new_phases[1] - ifrit_new_phases[0]);
                int internal_frames = frames - ifrit_new_phases[2];
                ifrit_position.y = previous_position - 150 * (internal_frames + 1) / (ifrit_new_phases[3] - ifrit_new_phases[2]);
                ifrit_position.z -= 20 / battle_frame_multiplier;
            }
            else if(frames >= ifrit_new_phases[3] && frames < ifrit_new_phases[4])
            {
                ifrit_position.y += 1000 / battle_frame_multiplier;
                ifrit_position.z += 2000 / battle_frame_multiplier;
            }
            else if(frames >= ifrit_new_phases[4] && frames < ifrit_new_phases[5])
            {
                int internal_frames = frames - ifrit_new_phases[4];
                ifrit_position.x = 0;
                ifrit_position.y = 500;
                ifrit_position.z = 30000 * internal_frames / (ifrit_new_phases[5] - ifrit_new_phases[4]) - 5000;
            }
            else if(frames >= ifrit_new_phases[5])
            {
                effect_data.field_0 = (uint16_t)-1;
                return;
            }

            ff7_externals.engine_set_game_engine_rot_matrix_663673(ff7_externals.ifrit_rot_matrix_BCC768);
            ff7_externals.engine_set_game_engine_position_663707(ff7_externals.ifrit_rot_matrix_BCC768);
            ff7_externals.engine_apply_translation_with_delta_662ECC(ff7_externals.battle_ifrit_model_position, *ff7_externals.ifrit_vector3_int_ptr_BCC6A8, &(*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)[1].y);
            getBattleModelState(3)->modelPosition.x = (*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)->x;
            getBattleModelState(3)->modelPosition.y = (*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)->y;
            getBattleModelState(3)->modelPosition.z = (*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)->z;
            effect_data.field_2++;
        }
    }

    int battle_animate_material_texture(material_anim_ctx *materialCtx, int a2, int a3, int retVal)
    {
        float field_8_float, field_8_float_shifted;
        int alpha, only_color_no_alpha, field_C;
        p_hundred *aux_gfx;
        struc_173 *palette_aux;
        color_ui8 color;
        rotation_matrix *rot_matrix;
        struc_84 *draw_chain;
        ff7_game_obj *game_object;
        ff7_polygon_set *poly_set;
        uint32_t *materialRSD;

        palette_extra &palette_extra_data = *ff7_externals.palette_extra_data_C06A00;

        // Interpolation of material texture with previous frame data if available
        std::shared_ptr<InterpolationEffectDecorator> effectDecorator = std::dynamic_pointer_cast<InterpolationEffectDecorator>(currentEffectDecorator);
        if (effectDecorator)
        {
            uint32_t uniqueID = (uint32_t)_ReturnAddress();
            if (!effectDecorator->doInterpolation())
            {
                interpolationable_data currData;
                currData.rot_matrix = *ff7_externals.get_global_model_matrix_buffer_66100D();
                currData.material_ctx = *materialCtx;
                currData.color = ff7_externals.get_stored_color_66101A();
                currData.palette = *ff7_externals.palette_extra_data_C06A00;
                effectDecorator->saveInterpolationData(std::move(currData), uniqueID);
            }
            else
            {
                effectDecorator->interpolateRotationMatrix(ff7_externals.get_global_model_matrix_buffer_66100D(), uniqueID);
                effectDecorator->interpolateMaterialContext(*materialCtx, uniqueID);
                effectDecorator->interpolateColor(&(*ff7_externals.global_game_engine_data)->secondary_color, uniqueID);
                effectDecorator->interpolatePalette(palette_extra_data, uniqueID);
            }
            effectDecorator->addTextureIndex();
        }
        // -----------------------------------------------

        if (!ff7_externals.battle_sub_66C3BF())
        {
            palette_extra_data.field_1C = 0;
            palette_extra_data.field_20 = 0;
            palette_extra_data.scroll_v = 0;
            palette_extra_data.field_28 = 0;
            return retVal;
        }
        materialRSD = materialCtx->materialRSD;
        if (materialCtx->materialRSD)
        {
            if (materialRSD[1])
            {
                rot_matrix = ff7_externals.get_global_model_matrix_buffer_66100D();
                game_object = (ff7_game_obj *)common_externals.get_game_object();
                poly_set = (ff7_polygon_set*) materialRSD[1];
                draw_chain = ff7_externals.get_draw_chain_68F860(&poly_set->field_14, poly_set->field_14.graphics_instance);
                if (draw_chain)
                {
                    draw_chain->field_4 = 1;
                    aux_gfx = ff7_externals.battle_sub_5D1AAA(0, poly_set);
                    palette_aux = &draw_chain->struc_173;
                    if ((materialCtx->negateColumnFlags & 0x80) != 0)
                    {
                        alpha = ff7_externals.get_alpha_from_transparency_429343(materialCtx->transparency);
                    }
                    else if (materialCtx->transparency >= 128)
                    {
                        alpha = 255;
                    }
                    else
                    {
                        alpha = 2 * materialCtx->transparency;
                    }
                    color = ff7_externals.get_stored_color_66101A();
                    if (game_object->current_gfx_driver != 1)
                    {
                        if (*(DWORD*)&color == -16777216)
                            ff7_externals.battle_sub_68CF75(10, palette_aux);
                        else
                            ff7_externals.battle_sub_68CF75(9, palette_aux);
                        draw_chain->struc_173.color = color;
                        draw_chain->struc_173.color.a = alpha;
                        goto ANIMATE_MATERIAL_2;
                    }
                    only_color_no_alpha = *(DWORD *)&color & 0xFFFFFF;
                    if ((materialCtx->negateColumnFlags & 0x10) != 0)
                    {
                        if (only_color_no_alpha)
                        {
                            ff7_externals.battle_sub_68CF75(11, palette_aux);
                        ANIMATE_MATERIAL_1:
                            draw_chain->struc_173.color = color;
                            draw_chain->struc_173.color.a = alpha;
                        ANIMATE_MATERIAL_2:
                            field_C = materialCtx->field_C & 0xFFFFFFDF;
                            if (field_C && field_C < 2)
                            {
                                draw_chain->struc_173.setrenderstate = 1;
                                aux_gfx = (p_hundred*)*((DWORD*)&poly_set->struc_173 + field_C);
                            }
                            if (palette_extra_data.field_28)
                            {
                                draw_chain->struc_173.setrenderstate = 1;
                                aux_gfx = palette_extra_data.aux_gfx_ptr;
                                palette_extra_data.field_28 = 0;
                            }
                            if (materialCtx->field_8)
                            {
                                draw_chain->struc_173.scroll_uv = 2;
                                field_8_float = (byte)materialCtx->field_8;
                                field_8_float_shifted = ((int)materialCtx->field_8 >> 8);
                                draw_chain->struc_173.u_offset = field_8_float * 0.00390625;
                                draw_chain->struc_173.v_offset = field_8_float_shifted * 0.00390625;
                            }
                            else
                            {
                                draw_chain->struc_173.scroll_uv = 1;
                            }
                            if (materialCtx->paletteIdx)
                            {
                                draw_chain->struc_173.change_palette = 1;
                                draw_chain->struc_173.palette_index = materialCtx->paletteIdx >> 6;
                            }
                            else
                            {
                                draw_chain->struc_173.change_palette = 0;
                                draw_chain->struc_173.palette_index = 0;
                            }
                            if (palette_extra_data.field_1C)
                            {
                                draw_chain->struc_173.add_offsets = 1;
                                draw_chain->struc_173.x_offset = palette_extra_data.x_offset;
                                draw_chain->struc_173.y_offset = palette_extra_data.y_offset;
                                draw_chain->struc_173.z_offset = palette_extra_data.z_offset;
                                palette_extra_data.field_1C = 0;
                            }
                            if (palette_extra_data.field_20)
                            {
                                draw_chain->struc_173.field_7 = palette_extra_data.field_24;
                                draw_chain->struc_173.z_offset2 = palette_extra_data.z_offset_2;
                                palette_extra_data.field_20 = 0;
                            }
                            if (palette_extra_data.scroll_v)
                            {
                                draw_chain->struc_173.scroll_v = palette_extra_data.scroll_v;
                                draw_chain->struc_173.v_offset = palette_extra_data.v_offset;
                                palette_extra_data.scroll_v = 0;
                            }
                            draw_chain->struc_173.hundred_data = aux_gfx;
                            ff7_externals.create_rot_matrix_from_word_matrix_6617E9(rot_matrix, &draw_chain->matrix);
                            if ((materialCtx->negateColumnFlags & 7) != 0)
                            {
                                if ( (materialCtx->negateColumnFlags & 1) != 0 )
                                {
                                    draw_chain->matrix.m[0][0] = -draw_chain->matrix.m[0][0];
                                    draw_chain->matrix.m[0][1] = -draw_chain->matrix.m[0][1];
                                    draw_chain->matrix.m[0][2] = -draw_chain->matrix.m[0][2];
                                }
                                if ( (materialCtx->negateColumnFlags & 2) != 0 )
                                {
                                    draw_chain->matrix.m[1][0] = -draw_chain->matrix.m[1][0];
                                    draw_chain->matrix.m[1][1] = -draw_chain->matrix.m[1][1];
                                    draw_chain->matrix.m[1][2] = -draw_chain->matrix.m[1][2];
                                }
                                if ( (materialCtx->negateColumnFlags & 4) != 0 )
                                {
                                    draw_chain->matrix.m[2][0] = -draw_chain->matrix.m[2][0];
                                    draw_chain->matrix.m[2][1] = -draw_chain->matrix.m[2][1];
                                    draw_chain->matrix.m[2][2] = -draw_chain->matrix.m[2][2];
                                }
                            }
                            return retVal;
                        }
                    }
                    else if (only_color_no_alpha && alpha != 255)
                    {
                        ff7_externals.battle_sub_68CF75(13, palette_aux);
                        goto ANIMATE_MATERIAL_1;
                    }
                    ff7_externals.battle_sub_68CF75(12, palette_aux);
                    goto ANIMATE_MATERIAL_1;
                }
            }
        }
        return retVal;
    }

    int battle_animate_texture_spt(texture_spt_anim_ctx *texture_ctx, int a2, int a3, int retVal)
    {
        bool flag;
        color_ui8 color_rgba;
        WORD texture_field_C;
        byte blue_color;
        byte green_color;
        byte red_color;
        int page_idx, tex_page_idx, palette_idx;
        float x_left, y_top;
        float u_right, u_left, u_left_1, u_left_2, u_scale;
        float v_top, v_bottom, v_top_1, v_top_2, v_scale;
        float quad_width, quad_height;
        struc_84 *draw_chain;
        struc_186 *drawable_state;
        page_spt *page_spt_ptr;
        tex_page_list *page_list;
        rotation_matrix *rot_matrix;
        ff7_graphics_object *drawable;
        texture_spt *effect_spt;

        // Interpolation of texture SPT with previous frame data if available
        std::shared_ptr<InterpolationEffectDecorator> effectDecorator = std::dynamic_pointer_cast<InterpolationEffectDecorator>(currentEffectDecorator);
        if (effectDecorator && effectDecorator->getTextureNumCalls() == 1)
        {
            uint32_t uniqueID = (uint32_t)_ReturnAddress();
            if (!effectDecorator->doInterpolation())
            {
                interpolationable_data currData;
                currData.rot_matrix = *ff7_externals.get_global_model_matrix_buffer_66100D();
                currData.color = texture_ctx->color;
                effectDecorator->saveInterpolationData(std::move(currData), uniqueID);
            }
            else
            {
                effectDecorator->interpolateRotationMatrix(ff7_externals.get_global_model_matrix_buffer_66100D(), uniqueID);
                effectDecorator->interpolateColor(&texture_ctx->color, uniqueID);
            }
            effectDecorator->addTextureIndex();
        }
        // -----------------------------------------------

        if (!ff7_externals.battle_sub_66C3BF())
            return retVal;

        rot_matrix = ff7_externals.get_global_model_matrix_buffer_66100D();
        effect_spt = texture_ctx->effect_spt;
        drawable = texture_ctx->effectDrawable;
        if (texture_ctx->effect_spt && drawable && drawable->hundred_data && drawable->hundred_data->texture_set)
        {
            flag = (texture_ctx->field_C & 0x8000u) != 0;
            page_idx = texture_ctx->field_C & 0x7FFF;
            if (page_idx >= effect_spt->spt_handle_copy[1])
                page_idx = effect_spt->spt_handle_copy[1] - 1;
            if (page_idx >= 0 && page_idx < effect_spt->spt_handle_copy[1])
            {
                page_list = &effect_spt->pages[page_idx];
                page_spt_ptr = page_list->page_spt_ptr;
                for (int i = page_list->field_0[1]; i > 0; --i)
                {
                    if (effect_spt->tex_page_count > 1)
                    {
                        drawable = 0;
                        tex_page_idx = 0;
                        while (effect_spt->tex_page_count)
                        {
                            if (page_spt_ptr->field_C == effect_spt->field_10[tex_page_idx])
                            {
                                drawable = effect_spt->game_drawable[tex_page_idx];
                                draw_chain = ff7_externals.get_draw_chain_671C71(drawable);
                                goto ANIMATE_TEXTURE;
                            }
                            ++tex_page_idx;
                        }
                    }
                    draw_chain = ff7_externals.get_draw_chain_671C71(drawable);
                ANIMATE_TEXTURE:
                    if (draw_chain)
                    {
                        if (texture_ctx->color.r < 128u)
                            red_color = 2 * texture_ctx->color.r;
                        else
                            red_color = -1;
                        if (texture_ctx->color.g < 128u)
                            green_color = 2 * texture_ctx->color.g;
                        else
                            green_color = -1;
                        if (texture_ctx->color.b < 128u)
                            blue_color = 2 * texture_ctx->color.b;
                        else
                            blue_color = -1;
                        color_rgba.r = red_color;
                        color_rgba.g = green_color;
                        color_rgba.b = blue_color;
                        color_rgba.a = ((ff7_polygon_set*)drawable->polygon_set)->hundred_data->vertex_alpha;
                        x_left = (8 * page_spt_ptr->field_4);
                        y_top = (8 * page_spt_ptr->field_6);
                        quad_width = (8 * (byte)page_spt_ptr->field_10);
                        quad_height = (8 * (byte)page_spt_ptr->field_12);
                        u_left_1 = page_spt_ptr->uScale * drawable->u_offset + drawable->u_offset / 2.0;
                        v_top_1 = page_spt_ptr->vScale * drawable->v_offset + drawable->v_offset / 2.0;
                        u_scale = ((byte)page_spt_ptr->field_10 - 1);
                        v_scale = ((byte)page_spt_ptr->field_12 - 1);
                        u_left_2 = drawable->u_offset * u_scale;
                        v_top_2 = drawable->v_offset * v_scale;
                        drawable_state = draw_chain->struc_186;
                        if ((page_spt_ptr->field_0 & 1) != 0)
                        {
                            u_right = page_spt_ptr->uScale * drawable->u_offset + drawable->u_offset / 2.0;
                            u_left = u_left_1 + u_left_2;
                        }
                        else
                        {
                            u_left = page_spt_ptr->uScale * drawable->u_offset + drawable->u_offset / 2.0;
                            u_right = u_left_1 + u_left_2;
                        }
                        if ((page_spt_ptr->field_0 & 2) != 0)
                        {
                            v_bottom = page_spt_ptr->vScale * drawable->v_offset + drawable->v_offset / 2.0;
                            v_top = v_top_1 + v_top_2;
                        }
                        else
                        {
                            v_top = page_spt_ptr->vScale * drawable->v_offset + drawable->v_offset / 2.0;
                            v_bottom = v_top_1 + v_top_2;
                        }

                        // Temporary fix for Pollensalta cold breath bg widescreen fix 
                        // (The correct solution should be to edit the file `magic/ff7/data/battle/special/hubuki/kemu.s` to edit the texture page)
                        if(widescreen_enabled && (uint32_t)texture_ctx == ff7_externals.pollensalta_cold_breath_bg_texture_ctx)
                        {
                            float widescreen_multiplier = ((float)wide_viewport_width / (float)wide_viewport_height) / (4 / 3.f);
                            quad_width *= widescreen_multiplier;
                            quad_height *= widescreen_multiplier;
                        }

                        drawable_state->vertices[0].x = x_left;
                        drawable_state->vertices[0].y = y_top;
                        drawable_state->vertices[0].z = 0.0;
                        drawable_state->colors[0] = color_rgba;
                        drawable_state->texcoords[0].u = u_left;
                        drawable_state->texcoords[0].v = v_top;
                        drawable_state->vertices[1].x = x_left;
                        drawable_state->vertices[1].y = y_top + quad_height;
                        drawable_state->vertices[1].z = 0.0;
                        drawable_state->colors[1] = color_rgba;
                        drawable_state->texcoords[1].u = u_left;
                        drawable_state->texcoords[1].v = v_bottom;
                        drawable_state->vertices[2].x = x_left + quad_width;
                        drawable_state->vertices[2].y = y_top;
                        drawable_state->vertices[2].z = 0.0;
                        drawable_state->colors[2] = color_rgba;
                        drawable_state->texcoords[2].u = u_right;
                        drawable_state->texcoords[2].v = v_top;
                        drawable_state->vertices[3].x = x_left + quad_width;
                        drawable_state->vertices[3].y = y_top + quad_height;
                        drawable_state->vertices[3].z = 0.0;
                        drawable_state->colors[3] = color_rgba;
                        drawable_state->texcoords[3].u = u_right;
                        drawable_state->texcoords[3].v = v_bottom;
                        if (flag)
                        {
                            drawable_state->palette_index = texture_ctx->field_E >> 6;
                        }
                        else
                        {
                            palette_idx = (page_spt_ptr->palette_something >> 6) - ((ff7_tex_header*)((ff7_texture_set*)(drawable->hundred_data->texture_set))->tex_header)->field_E0;
                            if (palette_idx < 0)
                                palette_idx = 0;
                            drawable_state->palette_index = palette_idx;
                        }
                        ff7_externals.create_rot_matrix_from_word_matrix_6617E9(rot_matrix, &draw_chain->matrix);
                    }
                    ++page_spt_ptr;
                }
            }
        }
        return retVal;
    }

    void battle_sub_6CE81E()
    {
        // Gun effect uses a variable that is toggle true and false each frame in 15 FPS. With greater FPS, this should change less frequently
        if(frame_counter % battle_frame_multiplier == 0)
        {
            ff7_externals.battle_sub_6CE81E();
        }
    }

    void battleground_shake_train()
    {
        if(frame_counter % battle_frame_multiplier == 0)
        {
            ff7_externals.battleground_shake_train_42F088();
        }
    }



    void animations_hook_init()
    {
        // 3d model animation
        if(ff7_fps_limiter == FPS_LIMITER_30FPS)
        {
            patch_multiply_code<byte>(ff7_externals.battle_update_3d_model_data + 0x13E, battle_frame_multiplier);
            patch_multiply_code<byte>(ff7_externals.battle_update_3d_model_data + 0x316, battle_frame_multiplier);
        }

        replace_call_function(ff7_externals.battle_sub_42A5EB + 0xB8, run_animation_script);
        replace_call_function(ff7_externals.battle_sub_42E275 + 0xB2, run_animation_script);
        replace_call_function(ff7_externals.battle_sub_42E34A + 0x76, run_animation_script);
        replace_call_function(ff7_externals.battle_sub_5BD5E9 + 0x22F, run_animation_script);
        replace_call_function(ff7_externals.run_summon_animations_script_sub_5C1D9A + 0x4A, run_animation_script);
        replace_function(ff7_externals.add_fn_to_effect100_fn, add_fn_to_effect100_fn);
        replace_function(ff7_externals.add_fn_to_effect10_fn, add_fn_to_effect10_fn);
        replace_function(ff7_externals.add_fn_to_effect60_fn, add_fn_to_effect60_fn);
        replace_function(ff7_externals.execute_effect100_fn, execute_effect100_fn);
        replace_function(ff7_externals.execute_effect10_fn, execute_effect10_fn);
        replace_function(ff7_externals.execute_effect60_fn, execute_effect60_fn);

        // Normal enemy death
        patch_multiply_code<WORD>(ff7_externals.battle_enemy_death_5BBD24 + 0x40, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_enemy_death_sub_5BBE32 + 0xA8, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_enemy_death_sub_5BBE32 + 0xCB, battle_frame_multiplier);

        // Enemy death - iainuki
        patch_multiply_code<WORD>(ff7_externals.battle_iainuki_death_5BCAAA + 0x40, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0x9F, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0xC2, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0xE3, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0x104, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0x154, battle_frame_multiplier);

        // Boss death
        patch_multiply_code<WORD>(ff7_externals.battle_boss_death_5BC48C + 0x40, battle_frame_multiplier);
        patch_multiply_code<WORD>(ff7_externals.battle_boss_death_5BC48C + 0xCF, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_boss_death_sub_5BC6ED + 0xCF, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_boss_death_sub_5BC6ED + 0xF1, battle_frame_multiplier);
        replace_function(ff7_externals.battle_boss_death_sub_5BC5EC, run_boss_death_animation_5BC5EC);

        // Enemy death - melting
        patch_multiply_code<WORD>(ff7_externals.battle_melting_death_5BC21F + 0x40, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0xAB, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_melting_death_sub_5BC32D + 0xCE, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0xEE, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0x10D, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0x12C, battle_frame_multiplier);

        // Enemy death - disintegrate 2
        patch_multiply_code<WORD>(ff7_externals.battle_disintegrate_2_death_5BBA82 + 0x40, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_disintegrate_2_death_sub_5BBBDE + 0xB9, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_disintegrate_2_death_sub_5BBBDE + 0xDB, battle_frame_multiplier);
        patch_divide_code<float>((uint32_t)ff7_externals.field_float_battle_7B7680, battle_frame_multiplier); // float value used also elsewhere

        // Enemy death - morph
        patch_multiply_code<WORD>(ff7_externals.battle_morph_death_5BC812 + 0x40, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_morph_death_sub_5BC920 + 0x9F, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_morph_death_sub_5BC920 + 0xC2, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_morph_death_sub_5BC920 + 0xE3, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_morph_death_sub_5BC920 + 0x104, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_morph_death_sub_5BC920 + 0x154, battle_frame_multiplier);

        // Enemy death - disintegrate 1
        patch_multiply_code<WORD>(ff7_externals.battle_disintegrate_1_death_5BBF31 + 0x40, battle_frame_multiplier);
        replace_function(ff7_externals.battle_disintegrate_1_death_sub_5BC04D, run_disintegrate_1_death_sub_5BC04D);

        // Display string related
        replace_function(ff7_externals.get_n_frames_display_action_string, get_n_frames_display_action_string);
        patch_multiply_code<WORD>(ff7_externals.battle_sub_434C8B + 0x4F, battle_frame_multiplier); // unknown display text frame to keep
        patch_multiply_code<WORD>(ff7_externals.battle_sub_435D81 + 0x6A8, battle_frame_multiplier); // all lucky 7s frame to keep the text

        // Character movement (e.g. movement animation for attacks)
        replace_function(ff7_externals.battle_move_character_sub_426F58, battle_move_character_sub_426F58);

        // Character fade in/out (i.e. multiply g_script_wait_frames and other things)
        patch_multiply_code<byte>(ff7_externals.battle_sub_42A72D + 0x11A, battle_frame_multiplier);
        patch_multiply_code<WORD>(ff7_externals.vincent_limit_fade_effect_sub_5D4240 + 0x24, battle_frame_multiplier);
        patch_multiply_code<WORD>(ff7_externals.vincent_limit_fade_effect_sub_5D4240 + 0x57, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.vincent_limit_fade_effect_sub_5D4240 + 0x6E, battle_frame_multiplier);
        patch_multiply_code<WORD>(ff7_externals.battle_sub_5C18BC + 0xDC, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_sub_5C18BC + 0xE4, battle_frame_multiplier);
        patch_multiply_code<WORD>(ff7_externals.battle_sub_5C1C8F + 0x55, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_sub_5C1C8F + 0x5D, battle_frame_multiplier);

        // Summons
        patch_multiply_code<byte>(ff7_externals.run_summon_animations_5C0E4B + 0x75, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.run_summon_animations_5C0E4B + 0x6D, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.run_summon_animations_5C0E4B + 0x15B, battle_frame_multiplier);
        memset_code(ff7_externals.run_shiva_camera_58E60D + 0xC2D, 0x90, 6);
        patch_code_dword(ff7_externals.run_ramuh_camera_597206 + 0x44, 0x000B9585);
        memset_code(ff7_externals.run_odin_gunge_camera_4A0F52 + 0xC0C, 0x90, 6);
        patch_multiply_code<DWORD>(ff7_externals.run_odin_steel_sub_4A9908 + 0x5E, battle_frame_multiplier);
        patch_multiply_code<DWORD>(ff7_externals.run_odin_steel_sub_4A9908 + 0x25D, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.run_odin_steel_sub_4A9908 + 0x265, battle_frame_multiplier);
        patch_code_dword(ff7_externals.run_odin_steel_sub_4A9908 + 0x316, (DWORD)&ff7_odin_steel_frames_AEEC14);
        replace_call_function(ff7_externals.run_summon_kotr_sub_476857 + 0x1C6, add_kotr_camera_fn_to_effect100_fn);
        replace_function(ff7_externals.run_ifrit_movement_596702, run_ifrit_movement_596702);
        patch_code_byte(ff7_externals.run_shiva_movement_592538 + 0x14D, 92);
        patch_code_byte(ff7_externals.run_shiva_movement_592538 + 0x153, 91);
        patch_code_int(ff7_externals.run_bahamut_neo_movement_48D7BC + 0x62, 206);
        patch_code_byte(ff7_externals.run_bahamut_movement_49ADEC + 0x69, 83);
        patch_code_byte(ff7_externals.run_odin_gunge_movement_4A584D + 0x1D0, 26);

        // Show Damage
        patch_multiply_code<WORD>(ff7_externals.display_battle_damage_5BB410 + 0x54, battle_frame_multiplier);
        if(battle_frame_multiplier == 2)
        {
            patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x1E2, (DWORD)y_pos_offset_display_damage_30);
            patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x2D7, (DWORD)y_pos_offset_display_damage_30);
        }
        else if(battle_frame_multiplier == 4)
        {
            patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x1E2, (DWORD)y_pos_offset_display_damage_60);
            patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x2D7, (DWORD)y_pos_offset_display_damage_60);
        }

        // Aura animation (magic, limit break, enemy skill, summon)
        patch_divide_code<DWORD>(ff7_externals.limit_break_aura_effects_5C0572 + 0x4C, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0x6E, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.limit_break_aura_effects_5C0572 + 0x7A, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0x98, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0xAD, battle_frame_multiplier);
        patch_code_byte(ff7_externals.limit_break_aura_effects_5C0572 + 0xB0, 0x9 - battle_frame_multiplier / 2);
        patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0x13E, battle_frame_multiplier);
        patch_multiply_code<DWORD>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x5C, battle_frame_multiplier);
        patch_code_byte(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x64, 0x7 - battle_frame_multiplier / 2);
        patch_multiply_code<DWORD>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x81, battle_frame_multiplier);
        patch_code_byte(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x89, 0xA - battle_frame_multiplier / 2);
        patch_multiply_code<byte>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xA7, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xB3, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xD6, battle_frame_multiplier);
        patch_code_byte(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xD9, 0xC - battle_frame_multiplier / 2);
        patch_multiply_code<byte>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x182, battle_frame_multiplier);
        patch_code_byte(ff7_externals.summon_aura_effects_5C0953 + 0x4D, 0xC - battle_frame_multiplier / 2);
        patch_multiply_code<byte>(ff7_externals.summon_aura_effects_5C0953 + 0x19D, battle_frame_multiplier);

        // Limit break effects
        patch_multiply_code<byte>(ff7_externals.tifa_limit_2_1_sub_4E48D4 + 0x1FE, battle_frame_multiplier);
        memset_code(ff7_externals.aerith_limit_2_1_sub_45B0CF + 0xCE, 0x90, 6);
        patch_multiply_code<byte>(ff7_externals.aerith_limit_2_1_sub_45B0CF + 0xE2, battle_frame_multiplier);

        // Magics
        patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x3B, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x2FB, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x302, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x8F0, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x8F7, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x4A, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_loop_5D602A + 0xC1, battle_frame_multiplier);
        patch_code_byte(ff7_externals.battle_escape_magic_loop_5D602A + 0x6A8, 4 + battle_frame_multiplier / 2);
        patch_divide_code<WORD>(ff7_externals.battle_escape_magic_loop_5D602A + 0x6CF, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x12C, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x131, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x148, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x14D, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x164, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x169, battle_frame_multiplier);
        byte lea_eax_ecx_15[] = {0x8D, 0x54, 0x08, 0xEB};
        byte lea_eax_ecx_10[] = {0x8D, 0x54, 0x08, 0xF0};
        memcpy_code(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1B2, lea_eax_ecx_15, sizeof(lea_eax_ecx_15));
        memcpy_code(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1CE, lea_eax_ecx_10, sizeof(lea_eax_ecx_10));
        patch_divide_code<byte>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1E6, battle_frame_multiplier);
        patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1E8, battle_frame_multiplier);

        // Effect60 related
        patch_multiply_code<WORD>(ff7_externals.battle_sub_425E5F + 0x3A, battle_frame_multiplier);

        // Bad workaround to fix ESUI compatibility with 30fps when no widescreen mod is enabled
        if (ff7_fps_limiter == FPS_LIMITER_60FPS || (ff7_fps_limiter == FPS_LIMITER_30FPS && widescreen_enabled)) 
        {
            patch_multiply_code<WORD>(ff7_externals.battle_sub_5BCF9D + 0x3A, battle_frame_multiplier);
        }
        patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x1DC, 0x2 - battle_frame_multiplier / 2);
        patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x203, 0x2 - battle_frame_multiplier / 2);

        patch_multiply_code<WORD>(ff7_externals.battle_sub_5BCD42 + 0x5B, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_sub_5BCD42 + 0x6E, battle_frame_multiplier);

        replace_function(ff7_externals.battle_sub_427737, battle_play_sfx_delayed_427737);

        // Tifa slots speed patch (bitwise and with 0x7 changed to 0x3)
        patch_code_byte((uint32_t)ff7_externals.display_tifa_slots_handler_6E3135 + 0x168, 0x3);
        patch_code_byte((uint32_t)ff7_externals.display_tifa_slots_handler_6E3135 + 0x16B, 0xCA);

        // Texture material animation
        replace_function(ff7_externals.battle_animate_material_texture, battle_animate_material_texture);
        replace_function(ff7_externals.battle_animate_texture_spt, battle_animate_texture_spt);

        // Toggle variable related to gun effect
        replace_call_function(ff7_externals.battle_sub_42D808 + 0x117, battle_sub_6CE81E);

        // 3D Battleground (mesh: horizontal, vertical, rotating, midgar flashback rain)
        // Lifestream final battle with sephiroth cannot be interpolated, it will be left like this which is still good
        replace_call_function(ff7_externals.update_3d_battleground + 0xBF, battleground_shake_train);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x1D4, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x1ED, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x206, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x21C, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x232, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x24B, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x264, battle_frame_multiplier);
        patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x27D, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.update_3d_battleground + 0x617, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.update_3d_battleground + 0x6CE, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battleground_vertical_scrolling_42F126 + 0x10, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battleground_vertical_scrolling_42F126 + 0x22, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battleground_vertical_scrolling_42F126 + 0x42, battle_frame_multiplier);
        patch_code_word(ff7_externals.battleground_vertical_scrolling_42F126 + 0x78, (0x1F + 1) * battle_frame_multiplier - 1);
        patch_divide_code<WORD>(ff7_externals.update_3d_battleground + 0x881, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.update_3d_battleground + 0x8C7, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.update_3d_battleground + 0x90C, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battleground_midgar_flashback_rain_5BDC4F + 0x44, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battleground_midgar_flashback_rain_5BDC4F + 0x71, battle_frame_multiplier);
        patch_divide_code<byte>(ff7_externals.battleground_midgar_flashback_rain_5BDC4F + 0x156, battle_frame_multiplier);

        // Other animations (Status effects: confusion, sleep, and silence; and player mark on top of head)
        // And fixes for manipulate, poison and regen color effect on characters 3d models
        patch_divide_code<WORD>(ff7_externals.battle_sub_5B9EC2 + 0x1CB, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_sub_5B9EC2 + 0x292, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_sub_5B9EC2 + 0x2A8, battle_frame_multiplier);
        patch_divide_code<WORD>(ff7_externals.battle_sub_5B9EC2 + 0x2D0, battle_frame_multiplier);
        patch_code_byte(ff7_externals.battle_sub_5B9EC2 + 0x316, (0x1F + 1) * battle_frame_multiplier - 1);
        patch_code_byte(ff7_externals.battle_handle_status_effect_anim_5BA7C0 + 0x97, 0x3 + battle_frame_multiplier / 2);
        patch_divide_code<WORD>(ff7_externals.battle_handle_player_mark_5B9C8E + 0x6A, battle_frame_multiplier);

        if(ff7_fps_limiter == FPS_LIMITER_60FPS)
        {
            // Speed up window menu closing speed to fix Bizarro menu box softlock
            patch_code_byte(ff7_externals.battle_menu_closing_window_box_6DAEF0 + 0x29, 0x2 - 1);
            patch_code_byte(ff7_externals.battle_menu_closing_window_box_6DAEF0 + 0x72, 0x2 - 1);
        }

        // Delay animation of battle target pointer
        replace_call_function(ff7_externals.battle_update_targeting_info_6E6291 + 0x682, delay_battle_target_pointer_animation_type);
        memset_code(ff7_externals.battle_update_targeting_info_6E6291 + 0x687, 0x90, 10);
        replace_call_function(ff7_externals.battle_update_targeting_info_6E6291 + 0x752, delay_battle_target_pointer_animation_type);
        memset_code(ff7_externals.battle_update_targeting_info_6E6291 + 0x757, 0x90, 10);
        replace_call_function(ff7_externals.battle_update_targeting_info_6E6291 + 0x81C, delay_battle_target_pointer_animation_type);
        memset_code(ff7_externals.battle_update_targeting_info_6E6291 + 0x821, 0x90, 10);

        // Populate map and set data for better performance with decorators initialization
        fixed_effect100_addresses.insert(ff7_externals.battle_enemy_death_5BBD24);
        fixed_effect100_addresses.insert(ff7_externals.battle_iainuki_death_5BCAAA);
        fixed_effect100_addresses.insert(ff7_externals.battle_boss_death_5BC48C);
        fixed_effect100_addresses.insert(ff7_externals.battle_melting_death_5BC21F);
        fixed_effect100_addresses.insert(ff7_externals.battle_disintegrate_2_death_5BBA82);
        fixed_effect100_addresses.insert(ff7_externals.battle_morph_death_5BC812);
        fixed_effect100_addresses.insert(ff7_externals.run_summon_animations_5C0E4B);
        fixed_effect100_addresses.insert(ff7_externals.run_summon_animations_script_5C1B81);
        fixed_effect100_addresses.insert(ff7_externals.goblin_punch_flash_573291);
        fixed_effect100_addresses.insert(ff7_externals.run_ifrit_movement_596702);
        fixed_effect100_addresses.insert(ff7_externals.vincent_limit_fade_effect_sub_5D4240);
        fixed_effect100_addresses.insert(ff7_externals.cloud_limit_2_2_sub_467256);
        fixed_effect100_addresses.insert(ff7_externals.battle_escape_magic_loop_5D602A);
        one_call_effect100_addresses.insert(ff7_externals.run_bahamut_zero_main_loop_484A16);
        one_call_effect100_addresses.insert(ff7_externals.death_sentence_main_loop_5661A0);
        one_call_effect100_addresses.insert(ff7_externals.roulette_skill_main_loop_566287);
        one_call_effect100_addresses.insert(ff7_externals.bomb_blast_black_bg_effect_537427);
        one_call_effect100_addresses.insert(ff7_externals.run_confu_main_loop_5600BE);
        one_call_effect100_addresses.insert(ff7_externals.death_kill_sub_loop_5624A5);
        one_call_effect100_addresses.insert(ff7_externals.death_kill_sub_loop_562C60);
        model_thresholds_by_address[ff7_externals.run_alexander_movement_5078D8] = 3000;
        camera_thresholds_by_address[ff7_externals.run_ramuh_camera_597206] = 5000;
        camera_thresholds_by_address[ff7_externals.run_typhoon_camera_4D594C] = 5000;
        camera_thresholds_by_address[ff7_externals.run_kotr_camera_476AFB] = 5000;
        camera_thresholds_by_address[ff7_externals.run_kujata_camera_4F9A4D] = 5000;
        camera_thresholds_by_address[ff7_externals.run_bahamut_zero_camera_483866] = 4000;
        camera_thresholds_by_address[ff7_externals.barret_limit_4_1_camera_4688A2] = 4000;
        camera_effect100_addresses.insert(ff7_externals.run_chocomog_camera_509B10);
        camera_effect100_addresses.insert(ff7_externals.run_fat_chocobo_camera_507CA4);
        camera_effect100_addresses.insert(ff7_externals.run_ifrit_camera_592A36);
        camera_effect100_addresses.insert(ff7_externals.run_shiva_camera_58E60D);
        camera_effect100_addresses.insert(ff7_externals.run_ramuh_camera_597206);
        camera_effect100_addresses.insert(ff7_externals.run_alexander_camera_501637);
        camera_effect100_addresses.insert(ff7_externals.run_bahamut_camera_497A37);
        camera_effect100_addresses.insert(ff7_externals.run_phoenix_camera_515238);
        camera_effect100_addresses.insert(ff7_externals.run_titan_camera_59B4B0);
        camera_effect100_addresses.insert(ff7_externals.run_hades_camera_4B65A8);
        camera_effect100_addresses.insert(ff7_externals.run_leviathan_camera_5B0716);
        camera_effect100_addresses.insert(ff7_externals.run_odin_gunge_camera_4A0F52);
        camera_effect100_addresses.insert(ff7_externals.run_odin_steel_camera_4A5D3C);
        camera_effect100_addresses.insert(ff7_externals.run_bahamut_neo_camera_48C75D);
        camera_effect100_addresses.insert(ff7_externals.run_kujata_camera_4F9A4D);
        camera_effect100_addresses.insert(ff7_externals.run_typhoon_camera_4D594C);
        camera_effect100_addresses.insert(ff7_externals.run_bahamut_zero_camera_483866);
        camera_effect100_addresses.insert(ff7_externals.run_kotr_camera_476AFB);
        camera_effect100_addresses.insert(ff7_externals.barret_limit_4_1_camera_4688A2);
        camera_effect100_addresses.insert(ff7_externals.aerith_limit_4_1_camera_473CC2);
        camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_439EE0);
        camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_44A7D2);
        camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_44EDC0);
        camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_4522AD);
        camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_457C60);
        model_effect100_addresses.insert(ff7_externals.run_fat_chocobo_movement_509692);
        model_effect100_addresses.insert(ff7_externals.run_bahamut_movement_49ADEC);
        model_effect100_addresses.insert(ff7_externals.run_bahamut_neo_movement_48D7BC);
        model_effect100_addresses.insert(ff7_externals.run_odin_gunge_movement_4A584D);
        model_effect100_addresses.insert(ff7_externals.run_odin_steel_movement_4A6CB8);
        model_effect100_addresses.insert(ff7_externals.run_phoenix_movement_518AFF);
        model_effect100_addresses.insert(ff7_externals.run_chocomog_movement_50B1A3);
        model_effect100_addresses.insert(ff7_externals.run_bahamut_zero_movement_48BBFC);
        model_effect100_addresses.insert(ff7_externals.run_shiva_movement_592538);
        model_effect100_addresses.insert(ff7_externals.run_alexander_movement_5078D8);
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[0]] = {50};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[1]] = {50};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[2]] = {};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[3]] = {52};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[4]] = {35};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[5]] = {14};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[6]] = {};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[7]] = {26};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[8]] = {71};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[9]] = {51};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[10]] = {56};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[11]] = {56};
        kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[12]] = {112};
    }
}
````

## File: src/ff7/battle/animations.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <unordered_map>
#include <unordered_set>
#include <stdint.h>
#include <windows.h>

namespace ff7::battle
{
    const std::unordered_map<byte, int> numArgsOpCode = {
        {0x8E, 0},
        {0x8F, 0},
        {0x90, 3},
        {0x91, 1}, // Function added
        {0x92, 0},
        {0x93, 0}, // Function added
        {0x94, 5}, // Function added
        {0x95, 0},
        {0x96, 2}, // effect60 fn added (barret gun)
        {0x97, 2}, // Run enemy death animations
        {0x98, 1}, // Display action text
        {0x99, 6},
        {0x9A, 4},
        {0x9B, 0},
        {0x9C, 0},
        {0x9D, 1}, // Dispatches Tifa limit breaks
        {0x9E, 0xFF},
        {0x9F, 0},
        {0xA0, 1},
        {0xA1, 2},
        {0xA2, 1},
        {0xA3, 1},
        {0xA4, 0}, // Spell aura related
        {0xA5, 0}, // Spell aura related
        {0xA6, 0},
        {0xA7, 1},
        {0xA8, 2}, // Move actor to resting position
        {0xA9, 2},
        {0xAA, 0},
        {0xAB, 4},
        {0xAC, 1}, // Vincent related
        {0xAD, 5}, // Barret related machine gun effect
        {0xAE, 0}, // Resting position related
        {0xAF, 1}, // Resting position reset
        {0xB0, 0}, // Resting position related
        {0xB1, 0}, // Resting position related
        {0xB2, 0}, // nop
        {0xB3, 0xFF},
        {0xB4, 0}, // Y rotation
        {0xB5, 11},
        {0xB6, 1}, // running animation related
        {0xB7, 0}, // death effects
        {0xB8, 0},
        {0xB9, 1}, // setup animation camera data
        {0xBA, 2}, // resting Y rotation
        {0xBC, 1}, // Idle camera index
        {0xBD, 4}, // rotate to target animation
        {0xBE, 1}, // not Tifa stuff
        {0xBF, 2},
        {0xC1, 0xFF},
        {0xC2, 1}, // display damage
        {0xC3, 0}, // some effects
        {0xC4, 3}, // resting Y rotation (inverting direction)
        {0xC5, 0}, // set frames to wait to 0xBFD0F0
        {0xC6, 1}, // set 0xBFD0F0 frames to wait
        {0xC7, 3}, // enemy animation thing
        {0xC8, 5}, // effects thing
        {0xC9, 0}, // nop
        {0xCA, 0xFF},
        {0xCB, 8},
        {0xCC, 1}, // move effects thing
        {0xCE, 1},
        {0xCF, 8}, // 3d move effects
        {0xD0, 3}, // move effects
        {0xD1, 5}, // move effects
        {0xD2, 0},
        {0xD3, 0},
        {0xD4, 3}, // move effects
        {0xD5, 8}, // move effects
        {0xD6, 1}, // effects thing
        {0xD7, 2}, // effects thing
        {0xD8, 3}, // effects thing
        {0xDA, 1},
        {0xDB, 4}, // effect machine gun
        {0xDC, 3}, // rotation stuff
        {0xDD, 2}, // machine gun effects
        {0xDE, 2}, // machine gun stuff
        {0xDF, 0}, // resting Y rotation
        {0xE0, 0}, // spell aura related
        {0xE1, 0}, // appear model
        {0xE2, 0}, // vanish model
        {0xE3, 0}, // position actor
        {0xE4, 0}, // resting stuff
        {0xE5, 0}, // rotation stuff
        {0xE6, 0}, // spell aura stuff
        {0xE7, 1},
        {0xE8, 0},
        {0xE9, 3}, // move effects
        {0xEA, 0}, // display action string effect
        {0xEB, 0xFF},
        {0xEC, 0xFF},
        {0xED, 0}, // resting stuff
        {0xEE, 0xFF},
        {0xF0, 0}, // foot dust effect
        {0xF1, -1},
        {0xF2, 0}, // nop
        {0xF3, 0xFF},
        {0xF4, 0xFF},
        {0xF5, 1}, // game init enemies
        {0xF6, 0}, // Run normal enemy death animation effects
        {0xF7, 1}, // delay damage display effect
        {0xF8, 1}, // effect stuff
        {0xF9, 0}, // resets actor orientation
        {0xFA, 0},
        {0xFB, 4},
        {0xFC, 0}, // setting orientation for target-all action
        {0xFD, 6}, // set resting position
        {0xFE, 0xFF},
        {0xFF, 0xFF},
    };

    const std::unordered_set<byte> endingOpCode{{0xA2, 0xA7, 0xA9, 0xB6, 0xF1}};
}
````

## File: src/ff7/battle/battle.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../../globals.h"
#include "../../log.h"
#include "../../achievement.h"

#include "defs.h"

namespace ff7::battle
{
	void magic_thread_start(void (*func)())
	{
		ff7_externals.destroy_magic_effects();

		/*
		* Original function creates a separate thread but the code is not thread
		* safe in any way! Luckily modern PCs are fast enough to load magic
		* effects synchronously.
		*/
		func();
	}

	void load_battle_stage(int param_1, int battle_location_id, int **param_3){
		((void(*)(int, int, int **)) ff7_externals.load_battle_stage)(param_1, battle_location_id, param_3);

		g_FF7SteamAchievements->initCharStatsBeforeBattle(ff7_externals.savemap->chars);
		g_FF7SteamAchievements->unlockBattleSquareAchievement(battle_location_id);
	}

	void battle_sub_5C7F94(int param_1, int param_2){
		((void(*)(int, int)) ff7_externals.battle_sub_5C7F94)(param_1, param_2);

		if (trace_all || trace_achievement)
			ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);
		g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil);
	}

	void display_battle_action_text_sub_6D71FA(short command_id, short action_id){
		ff7_externals.battle_actor_data->formation_entry = 1;
		ff7_externals.battle_actor_data->command_index = command_id;
		ff7_externals.battle_actor_data->action_index = action_id;

		g_FF7SteamAchievements->unlockFirstLimitBreakAchievement(command_id, action_id);
	}

	int load_scene_bin_chunk(char *filename, int offset, int size, char **out_buffer, void (*callback)(void))
	{
		int ret = ff7_externals.engine_load_bin_file_sub_419210(filename, offset, size, out_buffer, callback);

		char chunk_file[1024]{0};
		uint32_t chunk_size = 0;
		FILE* fd;

		_snprintf(chunk_file, sizeof(chunk_file), "%s/%s/battle/scene.bin.chunk.%i", basedir, direct_mode_path.c_str(), ff7_externals.modules_global_object->battle_id / 4);

		if ((fd = fopen(chunk_file, "rb")) != NULL)
		{
			fseek(fd, 0L, SEEK_END);
			chunk_size = ftell(fd);
			fseek(fd, 0L, SEEK_SET);
			fread(*out_buffer, sizeof(byte), chunk_size, fd);

			ffnx_trace("%s: scene overridden using %s\n", __func__, chunk_file);
			fclose(fd);
		}
		else if (trace_direct)
			ffnx_trace("%s: could not find %s\n", __func__, chunk_file);

		return ret;
	}
}
````

## File: src/ff7/battle/camera.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/
#include "camera.h"
#include "defs.h"

#include <unordered_set>
#include <unordered_map>
#include <span>

#include "../../patch.h"
#include "../../globals.h"

#include <bx/math.h>

namespace ff7::battle
{
    Camera camera;

    const std::unordered_map<byte, int> numArgsPositionOpCode{{0xD5, 2}, {0xD6, 0}, {0xD7, 2}, {0xD8, 9}, {0xD9, 0}, {0xDA, 0}, {0xDB, 0}, {0xDC, 0}, {0xDD, 1}, {0xDE, 1}, {0xDF, 0}, {0xE0, 2}, {0xE1, 0}, {0xE2, 1}, {0xE3, 9}, {0xE4, 8}, {0xE5, 8}, {0xE6, 7}, {0xE7, 8}, {0xE9, 8}, {0xEB, 9}, {0xEF, 8}, {0xF0, 7}, {0xF1, 0}, {0xF2, 5}, {0xF3, 5}, {0xF4, -1}, {0xF5, 1}, {0xF7, 7}, {0xF8, 12}, {0xF9, 6}, {0xFE, 0}, {0xFF, -1}};
    const std::unordered_map<byte, int> numArgsOpCode{{0xD8, 9}, {0xD9, 0}, {0xDB, 0}, {0xDC, 0}, {0xDD, 1}, {0xDE, 1}, {0xDF, 0}, {0xE0, 2}, {0xE1, 0}, {0xE2, 1}, {0xE3, 9}, {0xE4, 8}, {0xE5, 8}, {0xE6, 7}, {0xE8, 8}, {0xEA, 8}, {0xEC, 9}, {0xF0, 8}, {0xF4, -1}, {0xF5, 1}, {0xF8, 7}, {0xF9, 7}, {0xFA, 6}, {0xFE, 0}, {0xFF, -1}};
    const std::unordered_set<byte> endingFocalOpCodes{0xF0, 0xF8, 0xF9, 0xFF};
    const std::unordered_set<byte> endingPositionOpCodes{0xEF, 0xF0, 0xF7, 0xFF};
    constexpr int CAMERA_ARRAY_SIZE = 16;
    std::array<bool, CAMERA_ARRAY_SIZE> isNewCameraFunction{};

    byte *getCameraScriptPointer(char variationIndex, short cameraScriptIdx, bool isCameraFocalPoint)
    {
        int internalOffset = isCameraFocalPoint ? 4 : 0;
        if (cameraScriptIdx == -1)
            return isCameraFocalPoint ? ff7_externals.battle_camera_focal_scripts_8FEE30 : ff7_externals.battle_camera_position_scripts_8FEE2C;
        else if (cameraScriptIdx == -2)
            return isCameraFocalPoint ? (byte *)ff7_externals.battle_camera_focal_scripts_901270[*ff7_externals.battle_camera_script_index] : (byte *)ff7_externals.battle_camera_position_scripts_9010D0[*ff7_externals.battle_camera_script_index];
        else if (cameraScriptIdx == -3)
        {
            int outerOffset = variationIndex * 4 + *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + 0x8 + internalOffset) - *ff7_externals.battle_camera_script_offset;
            int finalOffset = *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + outerOffset) - *ff7_externals.battle_camera_script_offset;
            return (byte *)(*ff7_externals.battle_camera_global_scripts_9A13BC + finalOffset);
        }
        int outerOffset = (3 * cameraScriptIdx + variationIndex) * 4 + *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + internalOffset) - *ff7_externals.battle_camera_script_offset;
        int finalOffset = *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + outerOffset) - *ff7_externals.battle_camera_script_offset;
        return (byte *)(*ff7_externals.battle_camera_global_scripts_9A13BC + finalOffset);
    }

    bool simulateCameraScript(byte *scriptPtr, short &currentPosition, short &framesToWait, const std::unordered_map<byte, int> &numArgsOpCode,
                            const std::unordered_set<byte> &endingOpCodes)
    {
        bool executedOpCodeF5 = false;
        bool isScriptActive = true;
        while (isScriptActive)
        {
            byte currentOpCode = scriptPtr[currentPosition++];

            switch (currentOpCode)
            {
            case 0xF4:
                if (framesToWait != 0)
                {
                    framesToWait--;
                    currentPosition--;
                    isScriptActive = false;
                }
                break;
            case 0xF5:
                if(scriptPtr[currentPosition] == 0xFF)
                {
                    framesToWait = -1;
                    currentPosition++;
                }
                else
                {
                    executedOpCodeF5 = true;
                    framesToWait = scriptPtr[currentPosition++] * battle_frame_multiplier;
                }
                break;
            case 0xFE:
                if (framesToWait == 0)
                {
                    currentOpCode = scriptPtr[currentPosition];

                    if (currentOpCode == 192)
                    {
                        framesToWait = 0;
                        currentPosition = 0;
                    }
                }
                break;
            default:
                if (numArgsOpCode.contains(currentOpCode))
                {
                    currentPosition += numArgsOpCode.at(currentOpCode);

                    if (endingOpCodes.contains(currentOpCode))
                        isScriptActive = false;
                }
                else
                {
                    isScriptActive = false;
                }
                break;
            }
        }

        return executedOpCodeF5;
    }

    int add_fn_to_camera_fn(uint32_t function)
    {
        auto element = std::find(ff7_externals.camera_fn_array.begin(), ff7_externals.camera_fn_array.end(), 0);
        if (element != ff7_externals.camera_fn_array.end())
        {
            int index = std::distance(ff7_externals.camera_fn_array.begin(), element);
            ff7_externals.camera_fn_array[index] = function;
            ff7_externals.camera_fn_data[index].field_0 = *ff7_externals.camera_fn_index;
            *ff7_externals.camera_fn_counter = *ff7_externals.camera_fn_counter + 1;

            isNewCameraFunction[index] = true;
            return index;
        }
        return 0xFFFF;
    }

    void execute_camera_functions()
    {
        uint16_t &fn_index = *ff7_externals.camera_fn_index;
        for (fn_index = 0; fn_index < CAMERA_ARRAY_SIZE; fn_index++)
        {
            if (ff7_externals.camera_fn_array[fn_index] != 0)
            {
                if (isNewCameraFunction[fn_index])
                {
                    if (ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_position_sub_5C5B9C ||
                        ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_focal_sub_5C5F5E ||
                        ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_position_sub_5C557D ||
                        ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_focal_sub_5C5714)
                    {
                        ff7_externals.camera_fn_data[fn_index].n_frames *= battle_frame_multiplier;
                    }
                    else if (ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_position_sub_5C3D0D)
                    {
                        ff7_externals.camera_fn_data[fn_index].n_frames *= battle_frame_multiplier;
                        ff7_externals.camera_fn_data[fn_index].field_8 /= battle_frame_multiplier;
                        ff7_externals.camera_fn_data[fn_index].field_6 /= battle_frame_multiplier;
                        ff7_externals.camera_fn_data[fn_index].field_E /= battle_frame_multiplier;
                    }

                    isNewCameraFunction[fn_index] = false;
                }

                ((void (*)())ff7_externals.camera_fn_array[fn_index])();
                if (ff7_externals.camera_fn_data[fn_index].field_0 == (uint16_t)-1)
                {
                    ff7_externals.camera_fn_data[fn_index].field_0 = 0;
                    ff7_externals.camera_fn_data[fn_index].field_2 = 0;
                    ff7_externals.camera_fn_array[fn_index] = 0;
                    *ff7_externals.camera_fn_counter = *ff7_externals.camera_fn_counter - 1;
                }
            }
        }
        fn_index = 0;
    }

    void run_camera_focal_position_script(char variationIndex, DWORD param_2, short cameraScriptIdx)
    {
        auto cameraPosition = ff7_externals.battle_camera_focal_point;

        byte *scriptPtr = getCameraScriptPointer(variationIndex, cameraScriptIdx, true);
        short currentPosition = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].current_position;
        short framesToWait = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].frames_to_wait;

        bool executedOpCodeF5 = simulateCameraScript(scriptPtr, currentPosition, framesToWait, numArgsOpCode, endingFocalOpCodes);

        ((void (*)(char, DWORD, short))ff7_externals.set_camera_focal_position_scripts)(variationIndex, param_2, cameraScriptIdx);

        if (executedOpCodeF5)
            cameraPosition[variationIndex].frames_to_wait = framesToWait;
    }

    void run_camera_position_script(char variationIndex, DWORD param_2, short cameraScriptIdx)
    {
        auto cameraPosition = ff7_externals.battle_camera_position;

        byte *scriptPtr = getCameraScriptPointer(variationIndex, cameraScriptIdx, false);
        short currentPosition = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].current_position;
        short framesToWait = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].frames_to_wait;

        bool executedOpCodeF5 = simulateCameraScript(scriptPtr, currentPosition, framesToWait, numArgsPositionOpCode, endingPositionOpCodes);

        ((void (*)(char, DWORD, short))ff7_externals.set_camera_position_scripts)(variationIndex, param_2, cameraScriptIdx);

        if (executedOpCodeF5)
            cameraPosition[variationIndex].frames_to_wait = framesToWait;
    }

    void compute_interpolation_to_formation_camera()
    {
        ff7_externals.battle_camera_position[3].point = *ff7_externals.g_battle_camera_position;
        ff7_externals.battle_camera_focal_point[3].point = *ff7_externals.g_battle_camera_focal_point;
        int frame_steps = 2 * battle_frame_multiplier;
        vector3<short> delta_position, delta_focal_point;
        if (*ff7_externals.is_camera_moving_BFB2DC)
        {
            delta_position.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.x - ff7_externals.battle_camera_position[3].point.x) / frame_steps;
            if(delta_position.x == 0)
                delta_position.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.x - ff7_externals.battle_camera_position[3].point.x) % frame_steps;
            ff7_externals.battle_camera_position[3].point.x += delta_position.x;

            delta_position.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.y - ff7_externals.battle_camera_position[3].point.y) / frame_steps;
            if(delta_position.y == 0)
                delta_position.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.y - ff7_externals.battle_camera_position[3].point.y) % frame_steps;
            ff7_externals.battle_camera_position[3].point.y += delta_position.y;

            delta_position.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.z - ff7_externals.battle_camera_position[3].point.z) / frame_steps;
            if(delta_position.z == 0)
                delta_position.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.z - ff7_externals.battle_camera_position[3].point.z) % frame_steps;
            ff7_externals.battle_camera_position[3].point.z += delta_position.z;

            delta_focal_point.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.x - ff7_externals.battle_camera_focal_point[3].point.x) / frame_steps;
            if(delta_focal_point.x == 0)
                delta_focal_point.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.x - ff7_externals.battle_camera_focal_point[3].point.x) % frame_steps;
            ff7_externals.battle_camera_focal_point[3].point.x += delta_focal_point.x;

            delta_focal_point.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.y - ff7_externals.battle_camera_focal_point[3].point.y) / frame_steps;
            if(delta_focal_point.y == 0)
                delta_focal_point.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.y - ff7_externals.battle_camera_focal_point[3].point.y) % frame_steps;
            ff7_externals.battle_camera_focal_point[3].point.y += delta_focal_point.y;

            delta_focal_point.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.z - ff7_externals.battle_camera_focal_point[3].point.z) / frame_steps;
            if(delta_focal_point.z == 0)
                delta_focal_point.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.z - ff7_externals.battle_camera_focal_point[3].point.z) % frame_steps;
            ff7_externals.battle_camera_focal_point[3].point.z += delta_focal_point.z;

            if (!delta_position.x && !delta_position.y && !delta_position.z && !delta_focal_point.x && !delta_focal_point.y && !delta_focal_point.z)
                *ff7_externals.is_camera_moving_BFB2DC = 0;
        }
    }

    void update_battle_camera(short cameraScriptIndex)
    {
        vector3<short>* pGlobalCameraPos = ff7_externals.g_battle_camera_position;
        vector3<short>* pCameraPosition = &ff7_externals.battle_camera_position[*ff7_externals.g_variation_index].point;
        vector3<short>* pFormationCameraPos = &ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position;

        ((void(*)(short))ff7_externals.update_battle_camera_sub_5C20CE)(cameraScriptIndex);

        byte battle_enter_frames_to_wait = *ff7_externals.battle_enter_frames_to_wait;
        if(cameraScriptIndex == -2 && battle_enter_frames_to_wait > 5)
        {
            camera.reset();
            camera.setupInitialCamera();
        }

        if((std::abs(pGlobalCameraPos->x - pFormationCameraPos->x) <= 1 &&
            std::abs(pGlobalCameraPos->y - pFormationCameraPos->y) <= 1 &&
            std::abs(pGlobalCameraPos->z - pFormationCameraPos->z) <= 1))
        {
            camera.controlCamera(pGlobalCameraPos);
            *pFormationCameraPos = *pGlobalCameraPos;
            *pCameraPosition = *pGlobalCameraPos;
        }

        if(cameraScriptIndex == -3) camera.reset();
    }

    void camera_hook_init()
    {
        replace_function(ff7_externals.execute_camera_functions, execute_camera_functions);
        replace_function(ff7_externals.add_fn_to_camera_fn_array, add_fn_to_camera_fn);
        replace_call_function(ff7_externals.handle_camera_functions + 0x35, run_camera_focal_position_script);
        replace_call_function(ff7_externals.handle_camera_functions + 0x4B, run_camera_position_script);

        // Battle outro camera frame fix: patch DAT_009AE138 (frames to wait before closing battle mode)
        patch_multiply_code<DWORD>(ff7_externals.battle_sub_430DD0 + 0x3DE, battle_frame_multiplier);
        patch_multiply_code<DWORD>(ff7_externals.battle_sub_430DD0 + 0x361, battle_frame_multiplier);
        patch_multiply_code<DWORD>(ff7_externals.battle_sub_430DD0 + 0x326, battle_frame_multiplier);

        // Battle outro fading speed fix
        patch_multiply_code<byte>(ff7_externals.battle_sub_430DD0 + 0x60E, battle_frame_multiplier);

        // Battle intro camera frame fix: patch DAT_00BFD0F4 (frames to wait before atb starts)
        patch_multiply_code<byte>(ff7_externals.battle_sub_429AC0 + 0x152, battle_frame_multiplier);
        patch_multiply_code<byte>(ff7_externals.battle_sub_429D8A + 0x1D8, battle_frame_multiplier);

        // Move camera back to formation camera FPS fix
        replace_function(ff7_externals.compute_interpolation_to_formation_camera, compute_interpolation_to_formation_camera);
    }

    void Camera::setRotationSpeed(float rotX, float rotY, float rotZ)
    {
        rotationSpeed.x = rotX / static_cast<float>(battle_frame_multiplier);
        rotationSpeed.y = rotY / static_cast<float>(battle_frame_multiplier);
        rotationSpeed.z = rotZ / static_cast<float>(battle_frame_multiplier);
    }

    void Camera::setZoomSpeed(float speed)
    {
        zoomSpeed = speed / static_cast<float>(battle_frame_multiplier);
    }

    void Camera::reset()
    {
        rotationOffset.x = 0.0f;
        rotationOffset.y = 0.0f;
        zoomOffset = 0.0f;
    }

    void  Camera::setupInitialCamera()
    {
        vector3<short>* pFormationCameraPos = &ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position;
        vector3<short>* pFormationCameraFocusPos = &ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point;

        initialCameraPos.x = pFormationCameraPos->x;
        initialCameraPos.y = pFormationCameraPos->y;
        initialCameraPos.z = pFormationCameraPos->z;

        initialCameraFocusPos.x = pFormationCameraFocusPos->x;
        initialCameraFocusPos.y = pFormationCameraFocusPos->y;
        initialCameraFocusPos.z = pFormationCameraFocusPos->z;
    }

    void Camera::controlCamera(vector3<short>* cameraPosition)
    {
        static WORD last_battle_id = 0;

        bx::Vec3 cameraPos = {
            static_cast<float>(initialCameraPos.x),
            static_cast<float>(initialCameraPos.y),
            static_cast<float>(initialCameraPos.z)};
        bx::Vec3 cameraFocusPos = {
            static_cast<float>(initialCameraFocusPos.x),
            static_cast<float>(initialCameraFocusPos.y),
            static_cast<float>(initialCameraFocusPos.z)};

        float dist = bx::distance(cameraFocusPos, cameraPos);
        float candidateDist = dist - (zoomOffset + zoomSpeed);
        if(candidateDist < maxZoomDist && candidateDist > minZoomDist)
        {
            zoomOffset = zoomOffset + zoomSpeed;
        }

        bx::Vec3 up = { 0, 1, 0 };
        bx::Vec3 forward =  { cameraFocusPos.x - cameraPos.x,
                            cameraFocusPos.y - cameraPos.y,
                            cameraFocusPos.z - cameraPos.z};
        forward  = bx::normalize(forward);
        bx::Vec3 right = bx::cross(forward, up);

        cameraPos = bx::add(cameraPos, bx::mul(forward, zoomOffset));

        float dot = bx::dot(bx::mul(forward, 1.0), up);
        float angle = 180.0f * std::acosf(dot) / M_PI;
        float candidateAngle = angle + rotationOffset.x + rotationSpeed.x;
        rotationOffset.x += rotationSpeed.x;
        if(candidateAngle < minVerticalAngle)
            rotationOffset.x += minVerticalAngle - candidateAngle;
        if(candidateAngle > maxVerticalAngle)
            rotationOffset.x -= candidateAngle - maxVerticalAngle;

        rotationOffset.y = std::remainder(rotationOffset.y + rotationSpeed.y, 360.0f);

        auto quaternionH = bx::fromAxisAngle(up, M_PI * rotationOffset.y / 180.0f);
        auto quaternionV = bx::fromAxisAngle(right, M_PI * rotationOffset.x / 180.0f);

        auto quaternion = bx::mul(quaternionV, quaternionH);
        quaternion = bx::normalize(quaternion);

        float focusToOriginMatrix[16];
        bx::mtxTranslate(focusToOriginMatrix, -cameraFocusPos.x, -cameraFocusPos.y, -cameraFocusPos.z);

        float originToFocusMatrix[16];
        bx::mtxTranslate(originToFocusMatrix, cameraFocusPos.x, cameraFocusPos.y, cameraFocusPos.z);

        float rotMat[16];
        bx::mtxFromQuaternion(rotMat, quaternion);

        float tmp[16];
        bx::mtxMul(tmp, focusToOriginMatrix, rotMat);

        float tmp2[16];
        bx::mtxMul(tmp2, tmp, originToFocusMatrix);

        // Get new camera pos
        float newCameraPos[4] =  { 0.0f, 0.0f, 0.0f , 1.0f};
        float oldCameraPos[4] =  { cameraPos.x, cameraPos.y, cameraPos.z, 1.0f};
        bx::vec4MulMtx(newCameraPos, oldCameraPos, tmp2);

        cameraPosition->x = newCameraPos[0];
        cameraPosition->y = newCameraPos[1];
        cameraPosition->z = newCameraPos[2];
    }
}
````

## File: src/ff7/battle/camera.h
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "matrix.h"

namespace ff7::battle
{
    class Camera
    {
        public:
            Camera() = default;
            ~Camera() = default;

            void setRotationSpeed(float rotX, float rotY, float rotZ);
            vector3<float> getRotationSpeed();
            void setZoomSpeed(float speed);
            float getZoomSpeed();
            void reset();
            void setupInitialCamera();

            void controlCamera(vector3<short>* cameraPosition);
        private:
            vector3<float> rotationSpeed = { 0.0, 0.0, 0.0 };
            vector3<float> rotationOffset = { 0.0, 0.0, 0.0 };
            vector3<float> initialCameraPos = { 0.0, 0.0, 0.0 };
            vector3<float> initialCameraFocusPos = { 0.0, 0.0, 0.0 };
            float zoomSpeed = 0.0f;
            float zoomOffset = 0.0f;
            const float minZoomDist = 5000.0f;
            const float maxZoomDist = 30000.0f;
            const float minVerticalAngle = 5.0f;
            const float maxVerticalAngle = 85.0f;
    };

    inline vector3<float> Camera::getRotationSpeed()
    {
        return rotationSpeed;
    }

    inline float Camera::getZoomSpeed()
    {
        return zoomSpeed;
    }

    extern Camera camera;
}
````

## File: src/ff7/battle/defs.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

namespace ff7::battle
{
    // Camera
    void camera_hook_init();
    void update_battle_camera(short cameraScriptIndex);
    void update_idle_battle_camera();

    // Animations
    void animations_hook_init();

    // Battle
    void magic_thread_start(void (*func)());
    void load_battle_stage(int param_1, int battle_location_id, int **param_3);
    void battle_sub_5C7F94(int param_1, int param_2);
    void display_battle_action_text_sub_6D71FA(short command_id, short action_id);
    int load_scene_bin_chunk(char *filename, int offset, int size, char **out_buffer, void (*callback)(void));

    // Menu
    void battle_menu_enter();
    void draw_ui_graphics_objects_wrapper(int flag, int type);
}
````

## File: src/ff7/battle/effect.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "effect.h"

#include "../../globals.h"

namespace ff7::battle
{
    AuxiliaryEffectHandler::AuxiliaryEffectHandler()
    {
        this->isFirstTimeRunning = true;
        this->effectDecorator = std::make_shared<NoEffectDecorator>();
    }

    void NoEffectDecorator::callEffectFunction(uint32_t function)
    {
        ((void(*)())function)();
    }

    void OneCallEffectDecorator::callEffectFunction(uint32_t function)
    {
        if(this->frameCounter % this->frequency == 0)
        {
            ((void(*)())function)();
        }
        this->frameCounter++;
    }

    void PauseEffectDecorator::callEffectFunction(uint32_t function)
    {
        byte wasPaused = *this->isBattlePaused;
        if(this->frameCounter % this->frequency != 0)
        {
            *this->isBattlePaused = 1;
        }

        ((void(*)())function)();

        if(this->frameCounter % this->frequency != 0)
        {
            *this->isBattlePaused = wasPaused;
        }
        this->frameCounter++;
    }

    void FixCounterEffectDecorator::callEffectFunction(uint32_t function)
    {
        uint16_t currentEffectActive = *this->effectActive;
        short currentCounter = *this->effectCounter;
        if(this->frameCounter % this->frequency == 0)
        {
            ((void(*)())function)();
        }
        else
        {
            *this->isAddFunctionDisabled = true;
            ((void(*)())function)();
            *this->isAddFunctionDisabled = false;
            *this->effectCounter = currentCounter;
        }

        // Change active status of the function only at the last repeated frame
        if(this->frameCounter % this->frequency != this->frequency - 1)
        {
            *this->effectActive = currentEffectActive;
        }

        this->frameCounter++;
    }

    void FixCounterExceptionEffectDecorator::callEffectFunction(uint32_t function)
    {
        uint16_t currentEffectActive = *this->effectActive;
        short currentCounter = *this->effectCounter;

        if(this->frameCounter % this->frequency == 0)
        {
            ((void(*)())function)();
        }
        else
        {
            *this->isAddFunctionDisabled = true;
            if(!this->excludedFrames.contains(currentCounter)){
                ((void(*)())function)();
            }
            else
            {
                *this->effectCounter = *this->effectCounter + 1;
                ((void(*)())function)();
            }
            *this->effectCounter = currentCounter;
            *this->isAddFunctionDisabled = false;
        }

        // Change active status of the function only at the last repeated frame
        if(this->frameCounter % this->frequency != this->frequency - 1)
        {
            *this->effectActive = currentEffectActive;
        }

        this->frameCounter++;
    }

    InterpolationEffectDecorator::InterpolationEffectDecorator(int frequency, byte* isBattlePausedExt)
    {
        this->frameCounter = 0;
        this->frequency = frequency;
        this->isBattlePaused = isBattlePausedExt;
        this->textureCallIdx = 0;
    }

    uint64_t InterpolationEffectDecorator::getCantorHash(uint32_t x, uint32_t y)
    {
        return ((x + y) * (x + y + 1)) / 2 + y;
    }

    void InterpolationEffectDecorator::callEffectFunction(uint32_t function)
    {
        byte wasPaused = *this->isBattlePaused;
        this->textureCallIdx = 0;

        if(this->frameCounter % this->frequency == 0)
        {
            this->previousFrameDataMap.clear();
            this->_doInterpolation = false;
            ((void(*)())function)();
            this->textureNumCalls = this->textureCallIdx;
        }
        else
        {
            this->_doInterpolation = true;
            *this->isBattlePaused = 1;
            ((void(*)())function)();
            *this->isBattlePaused = wasPaused;
        }

        this->frameCounter++;
    }

    void InterpolationEffectDecorator::saveInterpolationData(interpolationable_data &&currData, uint32_t returnAddress)
    {
        uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
        this->previousFrameDataMap[hash] = std::move(currData);
    }

    void InterpolationEffectDecorator::interpolateRotationMatrix(rotation_matrix* nextRotationMatrix, uint32_t returnAddress)
    {
        uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
        if(this->previousFrameDataMap.contains(hash))
        {
            int interpolationStep = this->frameCounter % this->frequency;
            const rotation_matrix &previousMatrix = this->previousFrameDataMap[hash].rot_matrix;
            for(int i = 0; i < 3; i++)
                for(int j = 0; j < 3; j++)
                    nextRotationMatrix->r3_sub_matrix[i][j] = interpolateValue(previousMatrix.r3_sub_matrix[i][j],nextRotationMatrix->r3_sub_matrix[i][j], interpolationStep, this->frequency);

            for(int i = 0; i < 3; i++)
                nextRotationMatrix->position[i] = interpolateValue(previousMatrix.position[i], nextRotationMatrix->position[i], interpolationStep, this->frequency);
        }
    }

    void InterpolationEffectDecorator::interpolateMaterialContext(material_anim_ctx &nextMaterialCtx, uint32_t returnAddress)
    {
        uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
        if(this->previousFrameDataMap.contains(hash))
        {
            int interpolationStep = this->frameCounter % this->frequency;
            const material_anim_ctx &previousMaterialCtx = this->previousFrameDataMap[hash].material_ctx;
            nextMaterialCtx.transparency = interpolateValue(previousMaterialCtx.transparency, nextMaterialCtx.transparency, interpolationStep, this->frequency);
            nextMaterialCtx.field_8 = interpolateValue(previousMaterialCtx.field_8, nextMaterialCtx.field_8, interpolationStep, this->frequency);
        }
    }

    void InterpolationEffectDecorator::interpolateColor(color_ui8 *nextColor, uint32_t returnAddress)
    {
        uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
        if(this->previousFrameDataMap.contains(hash))
        {
            int interpolationStep = this->frameCounter % this->frequency;
            const color_ui8 previousColor = this->previousFrameDataMap[hash].color;
            nextColor->b = interpolateValue(previousColor.b, nextColor->b, interpolationStep, this->frequency);
            nextColor->g = interpolateValue(previousColor.g, nextColor->g, interpolationStep, this->frequency);
            nextColor->r = interpolateValue(previousColor.r, nextColor->r, interpolationStep, this->frequency);
            nextColor->a = interpolateValue(previousColor.a, nextColor->a, interpolationStep, this->frequency);
        }
    }

    void InterpolationEffectDecorator::interpolatePalette(palette_extra &nextPalette, uint32_t returnAddress)
    {
        uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
        if(this->previousFrameDataMap.contains(hash))
        {
            int interpolationStep = this->frameCounter % this->frequency;
            const palette_extra &previousPalette = this->previousFrameDataMap[hash].palette;
            nextPalette.x_offset = interpolateValue(previousPalette.x_offset, nextPalette.x_offset, interpolationStep, this->frequency);
            nextPalette.y_offset = interpolateValue(previousPalette.y_offset, nextPalette.y_offset, interpolationStep, this->frequency);
            nextPalette.z_offset = interpolateValue(previousPalette.z_offset, nextPalette.z_offset, interpolationStep, this->frequency);
            nextPalette.field_24 = interpolateValue(previousPalette.field_24, nextPalette.field_24, interpolationStep, this->frequency);
            nextPalette.z_offset_2 = interpolateValue(previousPalette.z_offset_2, nextPalette.z_offset_2, interpolationStep, this->frequency);
            nextPalette.scroll_v = interpolateValue(previousPalette.scroll_v, nextPalette.scroll_v, interpolationStep, this->frequency);
            nextPalette.v_offset = interpolateValue(previousPalette.v_offset, nextPalette.v_offset, interpolationStep, this->frequency);
        }
    }

    bool ModelInterpolationEffectDecorator::isSmoothMovement(vector3<short> previous, vector3<short> next)
    {
        double distance = std::sqrt(std::pow(next.x - previous.x, 2) + std::pow(next.y - previous.y, 2) + std::pow(next.z - previous.z, 2));
        return distance < this->threshold;
    }

    void ModelInterpolationEffectDecorator::callEffectFunction(uint32_t function)
    {
        byte wasPaused = *this->isBattlePaused;
        uint16_t currentEffectActive = *this->effectActive;

        if(this->frameCounter == 0)
        {
            ((void(*)())function)();
            this->nextPosition = ff7_externals.g_battle_model_state[this->actorID].modelPosition;
        }
        else
        {
            int interpolationStep = this->frameCounter % this->frequency;
            if((this->frameCounter - 1) % this->frequency == 0)
            {
                this->previousPosition = this->nextPosition;
                ((void(*)())function)();
                this->nextPosition = ff7_externals.g_battle_model_state[this->actorID].modelPosition;

                if(isSmoothMovement(this->previousPosition, this->nextPosition))
                {
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition.x = interpolateValue(this->previousPosition.x, this->nextPosition.x, interpolationStep, this->frequency);
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition.y = interpolateValue(this->previousPosition.y, this->nextPosition.y, interpolationStep, this->frequency);
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition.z = interpolateValue(this->previousPosition.z, this->nextPosition.z, interpolationStep, this->frequency);
                }
                else
                {
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition = this->previousPosition;
                }

                if(*this->effectActive == (uint16_t)-1 && currentEffectActive != *this->effectActive)
                {
                    *this->effectActive = currentEffectActive;
                    this->finalFrame = this->frameCounter + this->frequency - 1;
                }
            }
            else if((this->frameCounter - 1) % this->frequency == this->frequency - 1)
            {
                if(usePauseTrick)
                {
                    *this->isBattlePaused = 1;
                    ((void(*)())function)();
                    *this->isBattlePaused = wasPaused;
                }

                ff7_externals.g_battle_model_state[this->actorID].modelPosition = this->nextPosition;
            }
            else
            {
                if(usePauseTrick)
                {
                    *this->isBattlePaused = 1;
                    ((void(*)())function)();
                    *this->isBattlePaused = wasPaused;
                }

                if(isSmoothMovement(this->previousPosition, this->nextPosition))
                {
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition.x = interpolateValue(this->previousPosition.x, this->nextPosition.x, interpolationStep, this->frequency);
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition.y = interpolateValue(this->previousPosition.y, this->nextPosition.y, interpolationStep, this->frequency);
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition.z = interpolateValue(this->previousPosition.z, this->nextPosition.z, interpolationStep, this->frequency);
                }
                else
                {
                    ff7_externals.g_battle_model_state[this->actorID].modelPosition = this->previousPosition;
                }
            }
        }

        if(this->finalFrame == this->frameCounter)
        {
            *this->effectActive = (uint16_t)-1;
        }

        this->frameCounter++;
    }

    bool CameraInterpolationEffectDecorator::isSmoothMovement(vector3<short> previous, vector3<short> next)
    {
        double distance = std::sqrt(std::pow(next.x - previous.x, 2) + std::pow(next.y - previous.y, 2) + std::pow(next.z - previous.z, 2));
        return distance < this->threshold;
    }

    void CameraInterpolationEffectDecorator::callEffectFunction(uint32_t function)
    {
        byte wasPaused = *this->isBattlePaused;
        uint16_t currentEffectActive = *this->effectActive;

        if(this->frameCounter == 0)
        {
            ((void(*)())function)();
            this->nextCameraPosition = *ff7_externals.g_battle_camera_position;
            this->nextCameraFocalPoint = *ff7_externals.g_battle_camera_focal_point;
        }
        else
        {
            int interpolationStep = this->frameCounter % this->frequency;
            if((this->frameCounter - 1) % this->frequency == 0)
            {
                this->previousCameraPosition = this->nextCameraPosition;
                this->previousCameraFocalPoint = this->nextCameraFocalPoint;
                ((void(*)())function)();
                this->nextCameraPosition = *ff7_externals.g_battle_camera_position;
                this->nextCameraFocalPoint = *ff7_externals.g_battle_camera_focal_point;

                if(isSmoothMovement(this->previousCameraPosition, this->nextCameraPosition) && isSmoothMovement(this->previousCameraFocalPoint, this->nextCameraFocalPoint))
                {
                    ff7_externals.g_battle_camera_position->x = interpolateValue(this->previousCameraPosition.x, this->nextCameraPosition.x, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_position->y = interpolateValue(this->previousCameraPosition.y, this->nextCameraPosition.y, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_position->z = interpolateValue(this->previousCameraPosition.z, this->nextCameraPosition.z, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_focal_point->x = interpolateValue(this->previousCameraFocalPoint.x, this->nextCameraFocalPoint.x, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_focal_point->y = interpolateValue(this->previousCameraFocalPoint.y, this->nextCameraFocalPoint.y, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_focal_point->z = interpolateValue(this->previousCameraFocalPoint.z, this->nextCameraFocalPoint.z, interpolationStep, this->frequency);
                }
                else
                {
                    *ff7_externals.g_battle_camera_position = this->previousCameraPosition;
                    *ff7_externals.g_battle_camera_focal_point = this->previousCameraFocalPoint;
                }

                if(*this->effectActive == (uint16_t)-1 && currentEffectActive != *this->effectActive)
                {
                    *this->effectActive = currentEffectActive;
                    this->finalFrame = this->frameCounter + this->frequency - 1;
                }
            }
            else if((this->frameCounter - 1) % this->frequency == this->frequency - 1)
            {
                *this->isBattlePaused = 1;
                ((void(*)())function)();
                *this->isBattlePaused = wasPaused;

                *ff7_externals.g_battle_camera_position = this->nextCameraPosition;
                *ff7_externals.g_battle_camera_focal_point = this->nextCameraFocalPoint;
            }
            else
            {
                *this->isBattlePaused = 1;
                ((void(*)())function)();
                *this->isBattlePaused = wasPaused;

                if(isSmoothMovement(this->previousCameraPosition, this->nextCameraPosition) && isSmoothMovement(this->previousCameraFocalPoint, this->nextCameraFocalPoint))
                {
                    ff7_externals.g_battle_camera_position->x = interpolateValue(this->previousCameraPosition.x, this->nextCameraPosition.x, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_position->y = interpolateValue(this->previousCameraPosition.y, this->nextCameraPosition.y, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_position->z = interpolateValue(this->previousCameraPosition.z, this->nextCameraPosition.z, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_focal_point->x = interpolateValue(this->previousCameraFocalPoint.x, this->nextCameraFocalPoint.x, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_focal_point->y = interpolateValue(this->previousCameraFocalPoint.y, this->nextCameraFocalPoint.y, interpolationStep, this->frequency);
                    ff7_externals.g_battle_camera_focal_point->z = interpolateValue(this->previousCameraFocalPoint.z, this->nextCameraFocalPoint.z, interpolationStep, this->frequency);
                }
                else
                {
                    *ff7_externals.g_battle_camera_position = this->previousCameraPosition;
                    *ff7_externals.g_battle_camera_focal_point = this->previousCameraFocalPoint;
                }
            }
        }

        if(this->finalFrame == this->frameCounter)
        {
            *this->effectActive = (uint16_t)-1;
        }

        this->frameCounter++;
    }
}
````

## File: src/ff7/battle/effect.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "../../ff7.h"

#include <set>
#include <unordered_map>
#include <memory>

namespace ff7::battle
{
    struct interpolationable_data
    {
        rotation_matrix rot_matrix;
        material_anim_ctx material_ctx;
        color_ui8 color;
        palette_extra palette;
    };

    class EffectDecorator
    {
    public:
        virtual void callEffectFunction(uint32_t function) = 0;
    };

    class NoEffectDecorator: public EffectDecorator
    {
    public:
        NoEffectDecorator() = default;
        void callEffectFunction(uint32_t function) override;
    };

    class OneCallEffectDecorator: public EffectDecorator
    {
    protected:
        int frameCounter;
        int frequency;
        OneCallEffectDecorator() = default;

    public:
        OneCallEffectDecorator(int frequency): frameCounter(0), frequency(frequency) {};
        void callEffectFunction(uint32_t function) override;
    };

    class PauseEffectDecorator: public EffectDecorator
    {
    protected:
        int frameCounter;
        int frequency;
        byte* isBattlePaused;
        PauseEffectDecorator() = default;

    public:
        PauseEffectDecorator(int frequency, byte* isBattlePausedExt): frameCounter(0), frequency(frequency), isBattlePaused(isBattlePausedExt) {};
        void callEffectFunction(uint32_t function) override;
    };

    class FixCounterEffectDecorator: public EffectDecorator
    {
    protected:
        int frameCounter;
        int frequency;
        uint16_t *effectActive;
        short *effectCounter;
        bool *isAddFunctionDisabled;
        FixCounterEffectDecorator() = default;

    public:
        FixCounterEffectDecorator(int frequency, uint16_t* effectActive, short* effectCounter, bool* isAddFunctionDisabled): frameCounter(0),
                                                                                                        frequency(frequency),
                                                                                                        effectActive(effectActive),
                                                                                                        effectCounter(effectCounter),
                                                                                                        isAddFunctionDisabled(isAddFunctionDisabled) {};
        void callEffectFunction(uint32_t function) override;
    };

    class FixCounterExceptionEffectDecorator: public FixCounterEffectDecorator
    {
    protected:
        std::set<short> excludedFrames;

    public:
        inline FixCounterExceptionEffectDecorator(int frequency, uint16_t* effectActive, short* effectCounter,
                                                bool* isAddFunctionDisabled, std::set<short> excludedFrames) : FixCounterEffectDecorator(frequency, effectActive, effectCounter, isAddFunctionDisabled)
        {
            this->excludedFrames = excludedFrames;
        }
        void callEffectFunction(uint32_t function) override;
    };

    class InterpolationEffectDecorator: public PauseEffectDecorator
    {
    protected:
        std::unordered_map<uint64_t, interpolationable_data> previousFrameDataMap;
        int textureCallIdx;
        int textureNumCalls;
        bool _doInterpolation;

    public:
        InterpolationEffectDecorator(int frequency, byte* isBattlePausedExt);
        void callEffectFunction(uint32_t function) override;
        uint64_t getCantorHash(uint32_t x, uint32_t y);

        inline bool doInterpolation(){return _doInterpolation;}
        inline void addTextureIndex(){textureCallIdx++;}
        inline int getTextureNumCalls(){return textureNumCalls;}

        void saveInterpolationData(interpolationable_data &&currData, uint32_t materialAddress);
        void interpolateRotationMatrix(rotation_matrix* nextRotationMatrix, uint32_t materialAddress);
        void interpolateMaterialContext(material_anim_ctx &nextMaterialCtx, uint32_t materialAddress);
        void interpolateColor(color_ui8 *color, uint32_t materialAddress);
        void interpolatePalette(palette_extra &paletteExtraData, uint32_t materialAddress);
    };

    class ModelInterpolationEffectDecorator: public PauseEffectDecorator
    {
    protected:
        uint16_t *effectActive;
        int actorID;
        int finalFrame = -1;
        bool usePauseTrick = true;
        int threshold = 1000;

        vector3<short> previousPosition;
        vector3<short> nextPosition;

        bool isSmoothMovement(vector3<short> previous, vector3<short> next);

    public:
        ModelInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, bool usePauseTrick, uint16_t* effectActive,
                                        int actorID) : PauseEffectDecorator(frequency, isBattlePausedExt), usePauseTrick(usePauseTrick),
                                                        effectActive(effectActive), actorID(actorID) {};

        ModelInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, bool usePauseTrick, uint16_t* effectActive,
                                        int actorID, int threshold) : PauseEffectDecorator(frequency, isBattlePausedExt), usePauseTrick(usePauseTrick),
                                                                        effectActive(effectActive), actorID(actorID), threshold(threshold) {};

        void callEffectFunction(uint32_t function) override;
    };

    class CameraInterpolationEffectDecorator: public PauseEffectDecorator
    {
    protected:
        uint16_t *effectActive;
        int finalFrame = -1;
        int threshold = 1500;

        vector3<short> previousCameraPosition;
        vector3<short> previousCameraFocalPoint;
        vector3<short> nextCameraPosition;
        vector3<short> nextCameraFocalPoint;

        bool isSmoothMovement(vector3<short> previous, vector3<short> next);

    public:
        CameraInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, uint16_t* effectActive): PauseEffectDecorator(frequency, isBattlePausedExt),
                                                                                                            effectActive(effectActive) {};

        CameraInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, uint16_t* effectActive, int threshold): PauseEffectDecorator(frequency, isBattlePausedExt),
                                                                                                                        effectActive(effectActive),
                                                                                                                        threshold(threshold) {};

        void callEffectFunction(uint32_t function) override;
    };

    class AuxiliaryEffectHandler
    {
    private:
        bool isFirstTimeRunning;
        std::shared_ptr<EffectDecorator> effectDecorator;

    public:
        AuxiliaryEffectHandler();

        inline std::shared_ptr<EffectDecorator> getEffectDecorator() {return effectDecorator;}
        inline bool isFirstFrame() {return isFirstTimeRunning;}

        inline void setEffectDecorator(std::shared_ptr<EffectDecorator> effectDecorator) {this->effectDecorator = std::move(effectDecorator);}
        inline void disableFirstFrame() {this->isFirstTimeRunning = false;}
        inline void executeEffectFunction(uint32_t effectFunction) {effectDecorator->callEffectFunction(effectFunction);}
    };

    template <typename T>
    T interpolateValue(T previous, T next, int step, int n_steps)
    {
        return previous + ((next - previous) * step) / n_steps;
    }
}
````

## File: src/ff7/battle/menu.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../../globals.h"
#include "../../renderer.h"

#include "menu.h"
#include "cfg.h"
#include "defs.h"
#include "gl.h"

namespace ff7::battle
{
    void battle_menu_enter()
    {
        *ff7_externals.g_do_render_menu = 0;
        battle_depth_clear();

        if (enable_time_cycle) newRenderer.setTimeFilterEnabled(false);
    }

    void battle_depth_clear()
    {
        if(gl_defer_battle_depth_clear()) return;

        newRenderer.clearDepthBuffer();
    }

    void delay_battle_target_pointer_animation_type()
    {
        if(frame_counter % battle_frame_multiplier == 0)
        {
            (*ff7_externals.targeting_actor_id_DC3C98)++;
        }
    }

    void draw_ui_graphics_objects_wrapper(int flag, int type)
    {
        if (enable_time_cycle) newRenderer.setTimeFilterEnabled(false);

        ff7_externals.battle_draw_call_42908C(flag, type);

        if (enable_time_cycle) newRenderer.setTimeFilterEnabled(true);
    }
}
````

## File: src/ff7/battle/menu.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

namespace ff7::battle
{
    void delay_battle_target_pointer_animation_type();
    void battle_depth_clear();
}
````

## File: src/ff7/field/background.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../../common.h"
#include "../../globals.h"
#include "../widescreen.h"

#include "../../renderer.h"

#include "background.h"
#include "defs.h"
#include "utils.h"
#include "camera.h"

#include <functional>

namespace ff7::field
{
    constexpr float MIN_STEP_INVERSE = 10.f;

    // ##################################################################
    // ----------------- DRAW GRAPHICS RELATED --------------------------
    // ##################################################################

    void field_layer1_pick_tiles(short bg_position_x, short bg_position_y)
    {
        int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
        vector2<float> bg_position, initial_pos, tile_position;
        field_tile* layer1_tiles = *ff7_externals.field_layer1_tiles;

        bg_position.x = bg_position_x;
        bg_position.y = bg_position_y;
        if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
        {
            if(is_position_valid(bg_main_layer_pos))
            {
                bg_position.x = bg_main_layer_pos.x;
                bg_position.y = bg_main_layer_pos.y;
            }
        }

        initial_pos.x = field_bg_multiplier * (320 - bg_position.x);
        initial_pos.y = field_bg_multiplier * ((ff7_field_center ? 232 : 224) - bg_position.y);

        if(*ff7_externals.field_special_y_offset > 0 && bg_position.y <= 6)
            initial_pos.y -= field_bg_multiplier * (*ff7_externals.field_special_y_offset);

        for(int i = 0; i < *ff7_externals.field_layer1_tiles_num; i++)
        {
            uint32_t tile_index = (*ff7_externals.field_layer1_palette_sort)[i];
            layer1_tiles[tile_index].field_1044 = 1;

            tile_position.x = initial_pos.x + field_bg_multiplier * layer1_tiles[tile_index].x;
            tile_position.y = initial_pos.y + field_bg_multiplier * layer1_tiles[tile_index].y;
            ff7_externals.add_page_tile(tile_position.x, tile_position.y, 0.9997, layer1_tiles[tile_index].u,
                                        layer1_tiles[tile_index].v, layer1_tiles[tile_index].palette_index, layer1_tiles[tile_index].page);
        }
    }

    void field_layer2_pick_tiles(short bg_position_x, short bg_position_y)
    {
        int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
        field_tile *layer2_tiles = *ff7_externals.field_layer2_tiles;
        vector2<float> bg_position, initial_pos;

        bg_position.x = bg_position_x;
        bg_position.y = bg_position_y;
        if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
        {
            if(is_position_valid(bg_main_layer_pos))
            {
                bg_position.x = bg_main_layer_pos.x;
                bg_position.y = bg_main_layer_pos.y;
            }
        }

        initial_pos.x = (320 - bg_position.x) * field_bg_multiplier;
        initial_pos.y = ((ff7_field_center ? 232 : 224) - bg_position.y) * field_bg_multiplier;
        if(*ff7_externals.field_special_y_offset > 0 && bg_position.y <= 8)
            initial_pos.y -= (*ff7_externals.field_special_y_offset) * field_bg_multiplier;

        for(int i = 0; i < *ff7_externals.field_layer2_tiles_num; i++)
        {
            uint32_t tile_index = (*ff7_externals.field_layer2_palette_sort)[i];
            vector2<float> tile_position;

            char anim_group = layer2_tiles[tile_index].anim_group;
            if(anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer2_tiles[tile_index].anim_bitmask))
                continue;

            layer2_tiles[tile_index].field_1040 = 1;

            tile_position.x = layer2_tiles[tile_index].x * field_bg_multiplier + initial_pos.x;
            tile_position.y = layer2_tiles[tile_index].y * field_bg_multiplier + initial_pos.y;

            uint32_t page = (layer2_tiles[tile_index].use_fx_page) ? layer2_tiles[tile_index].fx_page : layer2_tiles[tile_index].page;

            if(layer2_tiles[tile_index].use_fx_page && layer2_tiles[tile_index].blend_mode == 2) page += 14;
            if(layer2_tiles[tile_index].use_fx_page && layer2_tiles[tile_index].blend_mode == 3) page += 18;

            ff7_externals.add_page_tile(tile_position.x, tile_position.y, layer2_tiles[tile_index].z, layer2_tiles[tile_index].u,
                                        layer2_tiles[tile_index].v, layer2_tiles[tile_index].palette_index, page);
        }
    }

    void field_layer3_shift_tile_position(vector2<float>* tile_position, vector2<float>* bg_position, int layer3_width, int layer3_height)
    {
        const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
        const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
        const int top_offset = 256 + (enable_uncrop ? 8 : 0);
        const int bottom_offset = enable_uncrop ? 8 : 0;
        const int half_width = is_fieldmap_wide() ? ceil(wide_viewport_width / 4) : 160;
        const int half_height = enable_uncrop ? 120 : 112;

        if(tile_position->x <= bg_position->x - left_offset || tile_position->x >= bg_position->x + right_offset)
            tile_position->x += (tile_position->x >= bg_position->x - half_width) ? -layer3_width : layer3_width;

        if(tile_position->y <= bg_position->y - top_offset || tile_position->y >= bg_position->y + bottom_offset)
            tile_position->y += (tile_position->y >= bg_position->y - half_height) ? -layer3_height : layer3_height;
    }

    void field_layer3_pick_tiles(short bg_position_x, short bg_position_y)
    {
        if(!*ff7_externals.do_draw_layer3_CFFE3C)
            return;

        float z_value;
        int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
        field_tile *layer3_tiles = *ff7_externals.field_layer3_tiles;
        vector2<float> bg_position, initial_pos;

        bg_position.x = bg_position_x;
        bg_position.y = bg_position_y;
        if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
        {
            if(is_position_valid(bg_layer3_pos))
            {
                bg_position.x = bg_layer3_pos.x;
                bg_position.y = bg_layer3_pos.y;
            }
        }

        initial_pos.x = (320 - bg_position.x) * field_bg_multiplier;
        initial_pos.y = ((ff7_field_center ? 232 : 224) - bg_position.y) * field_bg_multiplier;
        if(ff7_externals.modules_global_object->field_B0 < 0xFFF)
            z_value = ff7_externals.field_layer_sub_623C0F(ff7_externals.field_camera_rotation_matrix_CFF3D8, ff7_externals.modules_global_object->field_B0, 0, 0);
        else
            z_value = 0.9998;

        const bool do_increase_height = enable_uncrop;
        const bool do_increase_width = is_fieldmap_wide() && (*ff7_externals.field_triggers_header)->bg3_width < ceil(wide_viewport_width / 2);
        const int layer3_width = (*ff7_externals.field_triggers_header)->bg3_width * (do_increase_width ? 2 : 1);
        const int layer3_height = (*ff7_externals.field_triggers_header)->bg3_height * (do_increase_height ? 2 : 1);
        const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
        const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
        const int top_offset = 256 + (enable_uncrop ? 8 : 0);
        const int bottom_offset = enable_uncrop ? 8 : 0;

        for(int i = 0; i < *ff7_externals.field_layer3_tiles_num; i++)
        {
            uint32_t tile_index = (*ff7_externals.field_layer3_palette_sort)[i];
            vector2<float> tile_position = {
                static_cast<float>(layer3_tiles[tile_index].x),
                static_cast<float>(layer3_tiles[tile_index].y)
            };

            field_layer3_shift_tile_position(&tile_position, &bg_position, layer3_width, layer3_height);

            char anim_group = layer3_tiles[tile_index].anim_group;
            if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
                tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
                (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer3_tiles[tile_index].anim_bitmask)))
                continue;

            layer3_tiles[tile_index].field_1040 = 1;
            tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
            tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;

            uint32_t page = (layer3_tiles[tile_index].use_fx_page) ? layer3_tiles[tile_index].fx_page : layer3_tiles[tile_index].page;

            ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer3_tiles[tile_index].u,
                                        layer3_tiles[tile_index].v, layer3_tiles[tile_index].palette_index, page);
        }

        if(widescreen_enabled || enable_uncrop)
        {
            // Apply repeat x-y for background layer 4 tiles
            std::vector<vector2<int>> tile_offsets;
            if(do_increase_height)
                tile_offsets.push_back(vector2<int>{0, layer3_height /2});

            if(do_increase_width){
                tile_offsets.push_back(vector2<int>{layer3_width / 2, 0});
                tile_offsets.push_back(vector2<int>{layer3_width / 2, layer3_height / 2});
            }

            for(vector2<int> tile_offset: tile_offsets)
            {
                for(int i = 0; i < *ff7_externals.field_layer3_tiles_num; i++)
                {
                    uint32_t tile_index = (*ff7_externals.field_layer3_palette_sort)[i];
                    vector2<float> tile_position = {
                        static_cast<float>(layer3_tiles[tile_index].x + tile_offset.x),
                        static_cast<float>(layer3_tiles[tile_index].y + tile_offset.y)
                    };

                    field_layer3_shift_tile_position(&tile_position, &bg_position, layer3_width, layer3_height);

                    char anim_group = layer3_tiles[tile_index].anim_group;
                    if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
                        tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
                        (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer3_tiles[tile_index].anim_bitmask)))
                        continue;

                    layer3_tiles[tile_index].field_1040 = 1;
                    tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
                    tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;

                    uint32_t page = (layer3_tiles[tile_index].use_fx_page) ? layer3_tiles[tile_index].fx_page : layer3_tiles[tile_index].page;

                    ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer3_tiles[tile_index].u,
                                                layer3_tiles[tile_index].v, layer3_tiles[tile_index].palette_index, page);
                }
            }
        }
        *ff7_externals.field_layer3_flag_CFFE40 = 1;
    }

    void field_layer4_shift_tile_position(vector2<float>* tile_position, vector2<float>* bg_position, int layer4_width, int layer4_height)
    {
        const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
        const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
        const int top_offset = 256 + (enable_uncrop ? 8 : 0);
        const int bottom_offset = enable_uncrop ? 8 : 0;
        const int half_width = is_fieldmap_wide() ? ceil(wide_viewport_width / 4) : 160;

        if(tile_position->x <= bg_position->x - left_offset || tile_position->x >= bg_position->x + right_offset)
            tile_position->x += (tile_position->x >= bg_position->x - half_width) ? -layer4_width : layer4_width;

        if(tile_position->y <= bg_position->y - top_offset || tile_position->y >= bg_position->y + bottom_offset)
            tile_position->y += (tile_position->y >= bg_position->y + bottom_offset) ? -layer4_height : layer4_height;

        if(widescreen_enabled && is_fieldmap_wide())
        {
            tile_position->x -= widescreen.getHorizontalOffset();
        }
    }

    void field_layer4_pick_tiles(short bg_position_x, short bg_position_y)
    {
        if(*ff7_externals.do_draw_layer4_CFFEA4)
        {
            int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
            field_tile *layer4_tiles = *ff7_externals.field_layer4_tiles;
            vector2<float> bg_position, initial_pos;

            bg_position.x = bg_position_x;
            bg_position.y = bg_position_y;
            if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
            {
                if(is_position_valid(bg_layer4_pos))
                {
                    bg_position.x = bg_layer4_pos.x;
                    bg_position.y = bg_layer4_pos.y;
                }
            }

            initial_pos.x = (320 - bg_position.x) * field_bg_multiplier;
            initial_pos.y = ((ff7_field_center ? 232 : 224) - bg_position.y) * field_bg_multiplier;
            float z_value = ff7_externals.field_layer_sub_623C0F(ff7_externals.field_camera_rotation_matrix_CFF3D8, ff7_externals.modules_global_object->field_AE, 0, 0);

            const bool do_increase_height = enable_uncrop;
            const bool do_increase_width = is_fieldmap_wide() && (*ff7_externals.field_triggers_header)->bg4_width < ceil(wide_viewport_width / 2);
            const int layer4_width = (*ff7_externals.field_triggers_header)->bg4_width * (do_increase_width ? 2 : 1);
            const int layer4_height = (*ff7_externals.field_triggers_header)->bg4_height * (do_increase_height ? 2 : 1);
            const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
            const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
            const int top_offset = 256 + (enable_uncrop ? 8 : 0);
            const int bottom_offset = enable_uncrop ? 8 : 0;

            for(int i = 0; i < *ff7_externals.field_layer4_tiles_num; i++)
            {
                uint32_t tile_index = (*ff7_externals.field_layer4_palette_sort)[i];
                vector2<float> tile_position = {
                    static_cast<float>(layer4_tiles[tile_index].x),
                    static_cast<float>(layer4_tiles[tile_index].y)
                };

                field_layer4_shift_tile_position(&tile_position, &bg_position, layer4_width, layer4_height);

                char anim_group = layer4_tiles[tile_index].anim_group;
                if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
                    tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
                    (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer4_tiles[tile_index].anim_bitmask)))
                    continue;

                layer4_tiles[tile_index].field_1040 = 1;
                tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
                tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;

                if(!*ff7_externals.field_layer_CFF1D8 || layer4_tiles[tile_index].palette_index != (*ff7_externals.field_palette_D00088) + 1)
                {
                    uint32_t page = (layer4_tiles[tile_index].use_fx_page) ? layer4_tiles[tile_index].fx_page : layer4_tiles[tile_index].page;
                    ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer4_tiles[tile_index].u,
                                                layer4_tiles[tile_index].v, layer4_tiles[tile_index].palette_index, page);
                }
            }

            if(widescreen_enabled || enable_uncrop)
            {
                // Apply repeat x-y for background layer 4 tiles
                std::vector<vector2<int>> tile_offsets;
                if(do_increase_height)
                    tile_offsets.push_back(vector2<int>{0, layer4_height /2});

                if(do_increase_width){
                    tile_offsets.push_back(vector2<int>{layer4_width / 2, 0});
                    tile_offsets.push_back(vector2<int>{layer4_width / 2, layer4_height / 2});
                }
                for(vector2<int> tile_offset: tile_offsets){
                    for(int i = 0; i < *ff7_externals.field_layer4_tiles_num; i++)
                    {
                        uint32_t tile_index = (*ff7_externals.field_layer4_palette_sort)[i];
                        vector2<float> tile_position = {
                            static_cast<float>(layer4_tiles[tile_index].x + tile_offset.x),
                            static_cast<float>(layer4_tiles[tile_index].y + tile_offset.y)
                        };

                        field_layer4_shift_tile_position(&tile_position, &bg_position, layer4_width, layer4_height);

                        char anim_group = layer4_tiles[tile_index].anim_group;
                        if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
                            tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
                            (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer4_tiles[tile_index].anim_bitmask)))
                            continue;

                        layer4_tiles[tile_index].field_1040 = 1;
                        tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
                        tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;

                        if(!*ff7_externals.field_layer_CFF1D8 || layer4_tiles[tile_index].palette_index != (*ff7_externals.field_palette_D00088) + 1)
                        {
                            uint32_t page = (layer4_tiles[tile_index].use_fx_page) ? layer4_tiles[tile_index].fx_page : layer4_tiles[tile_index].page;
                            ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer4_tiles[tile_index].u,
                                                        layer4_tiles[tile_index].v, layer4_tiles[tile_index].palette_index, page);
                        }
                    }
                }
            }

            *ff7_externals.field_layer4_flag_CFFEA8 = 1;
        }
    }


    void ff7_field_submit_draw_arrow(field_arrow_graphics_data* arrow_data)
    {
        // Add delta world position lost due to non-float calculation
        if(is_position_valid(field_3d_world_pos))
        {
            int view_multiplier = *ff7_externals.field_bg_multiplier;
            vector2<float> delta;
            delta.x = field_3d_world_pos.x - *ff7_externals.field_world_pos_x * view_multiplier;
            delta.y = field_3d_world_pos.y - *ff7_externals.field_world_pos_y * view_multiplier;
            for(int i = 0; i < 4; i++)
            {
                arrow_data->vertices[i].x += delta.x;
                arrow_data->vertices[i].y += delta.y;
            }
        }

        ff7_externals.field_submit_draw_arrow_63A171(arrow_data);
    }

    void ff7_field_submit_draw_cursor(field_arrow_graphics_data* arrow_data)
    {
        // Add delta position lost due to non-float calculation
        if(is_position_valid(cursor_position))
        {
            vector2<float> delta;
            delta.x = cursor_position.x - *ff7_externals.field_cursor_pos_x;
            delta.y = cursor_position.y - *ff7_externals.field_cursor_pos_y;
            for(int i = 0; i < 4; i++)
            {
                arrow_data->vertices[i].x += delta.x;
                arrow_data->vertices[i].y += delta.y;
            }
        }

        ff7_externals.field_submit_draw_arrow_63A171(arrow_data);
    }

    // ##################################################################
    // ##################################################################
    // ##################################################################

    void field_clip_with_camera_range_float(vector2<float>* point)
    {
        field_trigger_header* field_triggers_header_ptr = *ff7_externals.field_triggers_header;
        float half_width = 160;
        auto camera_range = field_triggers_header_ptr->camera_range;

        if(widescreen_enabled || enable_uncrop)
        {
            camera_range = widescreen.getCameraRange();
        }

        if(is_fieldmap_wide())
        {
            // Adjustment to prevent scrolling stopping one pixel too early
            camera_range.left += 1;
            camera_range.right -= 1;

            // This centers the background if necessary
            int cameraRangeSize = camera_range.right - camera_range.left;
            half_width = 160 + std::min(53, cameraRangeSize / 2 - 160);

            point->x += widescreen.getHorizontalOffset();
            if(widescreen.isResetVerticalPos()) point->y = 0;
            point->y += widescreen.getVerticalOffset();
        }

        if (point->x > camera_range.right - half_width)
            point->x = camera_range.right - half_width;
        if (point->x < camera_range.left + half_width)
            point->x = camera_range.left + half_width;
        if (point->y > camera_range.bottom - 120)
            point->y = camera_range.bottom - 120;
        if (point->y < camera_range.top + 120)
            point->y = camera_range.top + 120;

        if (enable_analogue_controls)
        {
            float accelCoeff = 0.1f / static_cast<float>(common_frame_multiplier);
            float maxScroll = 120;
            float maxScrollY = maxScroll * camera.getScrollingDirY();
            float maxScrollX = maxScroll * camera.getScrollingDirX();

            if (maxScrollX > 0.0) maxScrollX = std::min(maxScrollX, (camera_range.right - half_width - point->x));
            else maxScrollX = std::max(maxScrollX, camera_range.left + half_width - point->x);
            if (maxScrollY > 0.0) maxScrollY =  std::min(maxScrollY, (camera_range.bottom - 120 - point->y));
            else maxScrollY =  std::max(maxScrollY, camera_range.top + 120 - point->y);

            camera.setScrollingOffset(camera.getScrollingOffsetX() + accelCoeff * (maxScrollX - camera.getScrollingOffsetX()),
                                      camera.getScrollingOffsetY() + accelCoeff * (maxScrollY - camera.getScrollingOffsetY()));

            point->x += camera.getScrollingOffsetX();
            point->y += camera.getScrollingOffsetY();

            if (point->x > camera_range.right - half_width)
                point->x = camera_range.right - half_width;
            if (point->x < camera_range.left + half_width)
                point->x = camera_range.left + half_width;
            if (point->y > camera_range.bottom - 120)
                point->y = camera_range.bottom - 120;
            if (point->y < camera_range.top + 120)
                point->y = camera_range.top + 120;
        }
    }

    void float_sub_643628(field_trigger_header *trigger_header, vector2<float> *delta_position)
    {
        float half_width = 160;
        auto camera_range = trigger_header->camera_range;

        if (enable_uncrop || widescreen_enabled)
        {
            camera_range = widescreen.getCameraRange();
        }

        if(is_fieldmap_wide())
        {
            // This centers the background if necessary
            int cameraRangeSize = camera_range.right - camera_range.left;
            half_width = 160 + std::min(53, cameraRangeSize / 2 - 160);
        }

        if (trigger_header->field_14[0] == 1)
        {
            float diff_top_bottom = camera_range.bottom - 120 - (camera_range.top + 120);
            float diff_right_left = camera_range.right - half_width - (camera_range.left + half_width);
            float temp_1 = -(diff_top_bottom * (camera_range.top + 120 - delta_position->y) + diff_right_left * (camera_range.left + half_width - delta_position->x));
            float temp_square_value = (diff_top_bottom * diff_top_bottom + diff_right_left * diff_right_left) / 256.f;
            delta_position->x = ((diff_right_left * temp_1 / temp_square_value) / 256.f) + camera_range.left + half_width;
            delta_position->y = ((diff_top_bottom * temp_1 / temp_square_value) / 256.f) + camera_range.top + 120;
        }
        if (trigger_header->field_14[0] == 2)
        {
            float diff_bottom_top = camera_range.top + 120 - (camera_range.bottom - 120);
            float diff_right_left = camera_range.right - half_width - (camera_range.left + half_width);
            float temp_1 = -((diff_bottom_top) * (camera_range.bottom - 120 - delta_position->y) + diff_right_left * (camera_range.left + half_width - delta_position->x));
            float temp_square_value = (diff_bottom_top * diff_bottom_top + diff_right_left * diff_right_left) / 256.f;
            delta_position->x = ((diff_right_left * temp_1 / temp_square_value) / 256.f) + camera_range.left + half_width;
            delta_position->y = ((diff_bottom_top * temp_1 / temp_square_value) / 256.f) + camera_range.bottom - 120;
        }
    }

    void ff7_field_clip_with_camera_range(vector2<short>* point)
    {
        vector2<float> proxy_point = {(float)point->x, (float)point->y};
        field_clip_with_camera_range_float(&proxy_point);
        point->x = round(proxy_point.x);
        point->y = round(proxy_point.y);
    }

    void ff7_field_layer3_clip_with_camera_range(field_trigger_header* trigger_header, vector2<short>* point)
    {
        vector2<float> proxy_point = {(float)point->x, (float)point->y};
        float_sub_643628(*ff7_externals.field_triggers_header, &proxy_point);
        point->x = round(proxy_point.x);
        point->y = round(proxy_point.y);
    }

    void field_widescreen_width_clip_with_camera_range(vector2<short>* point)
    {
        if(!widescreen.isScriptedClipEnabled())
        {
            return;
        }

        auto camera_range = widescreen.getCameraRange();

        // Adjustment to prevent scrolling stopping one pixel too early
        camera_range.left += 1;
        camera_range.right -= 1;

        // This centers the background if necessary
        int cameraRangeSize = camera_range.right - camera_range.left;
        float half_width = 160 + std::min(53, cameraRangeSize / 2 - 160);

        point->x += widescreen.getHorizontalOffset();

        if (point->x > camera_range.right - half_width)
            point->x = camera_range.right - half_width;
        if (point->x < camera_range.left + half_width)
            point->x = camera_range.left + half_width;
    }

    void field_uncropped_height_clip_with_camera_range(vector2<short>* point)
    {
        if(!widescreen.isScriptedClipEnabled())
        {
            return;
        }

        auto camera_range = widescreen.getCameraRange();

        point->y += widescreen.getVerticalOffset();

        if(widescreen.isScriptedVerticalClipEnabled())
        {
            if (point->y > camera_range.bottom - 120)
                point->y = camera_range.bottom - 120;
            if (point->y < camera_range.top + 120)
                point->y = camera_range.top + 120;
        }
    }

    void engine_set_game_engine_world_coord_float_661B23(int field_world_x, int field_world_y)
    {
        ff7_externals.engine_set_game_engine_world_coord_661B23(field_world_x, field_world_y);

        // Override field_9A8 and field_9AC values with accurate field world coordinates position when possible
        ff7_game_obj* game_obj = (ff7_game_obj*)common_externals.get_game_object();
        if(game_obj)
        {
            if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
            {
                if(is_position_valid(field_3d_world_pos))
                {
                    *(float*)&game_obj->field_9A8 = field_3d_world_pos.x;
                    *(float*)&game_obj->field_9AC = field_3d_world_pos.y;
                }
            }
        }
    }

    void engine_sub_661B68(int field_world_x, int field_world_y)
    {
        ff7_game_obj* game_obj = (ff7_game_obj*)common_externals.get_game_object();
        if(game_obj)
        {
            engine_set_game_engine_world_coord_float_661B23(field_world_x, field_world_y);
            ff7_externals.engine_sub_67CCDE(*(float*)&game_obj->field_99C, *(float*)&game_obj->field_9A0, *(float*)&game_obj->field_9A4,
                *(float*)&game_obj->field_9A8, *(float*)&game_obj->field_9AC, (float)(int)game_obj->_res_w, (float)(int)game_obj->_res_h, game_obj);
        }
    }

    void ff7_field_set_world_coordinate_640EB7()
    {
        if(is_position_valid(field_3d_world_pos) || *ff7_externals.field_world_pos_x != *ff7_externals.field_prev_world_pos_x || *ff7_externals.field_world_pos_y != *ff7_externals.field_prev_world_pos_y)
        {
            *ff7_externals.field_prev_world_pos_x = *ff7_externals.field_world_pos_x;
            *ff7_externals.field_prev_world_pos_y = *ff7_externals.field_world_pos_y;
            engine_sub_661B68((*ff7_externals.field_bg_multiplier) * (*ff7_externals.field_world_pos_x), (*ff7_externals.field_bg_multiplier) * (*ff7_externals.field_world_pos_y));
        }
    }

    void field_apply_player_position_2D_translation_float(vector2<float>* point, int model_id)
    {
        vector3<float> player_position;
        field_event_data* field_event_data_ptr = *ff7_externals.field_event_data_ptr;

        player_position.x = field_event_data_ptr[model_id].model_pos.x / 4096.f;
        player_position.y = field_event_data_ptr[model_id].model_pos.y / 4096.f;
        player_position.z = ff7_externals.modules_global_object->field_16 + (field_event_data_ptr[model_id].model_pos.z / 4096.f);
        field_apply_2D_translation_float_64314F(&player_position, point);
        point->x -= ff7_externals.field_viewport_xy_CFF204->x;
        point->y -= ff7_externals.field_viewport_xy_CFF204->y;
    }

    void field_init_scripted_bg_movement()
    {
        vector2<short> world_pos;
        if ( !ff7_externals.modules_global_object->world_move_status )
        {
            last_valid_scripted_field_delta_world_pos = {INVALID_VALUE, INVALID_VALUE};

            switch ( ff7_externals.modules_global_object->world_move_mode )
            {
            case 0:
                *ff7_externals.field_bg_flag_CC15E4 = 0;
                *ff7_externals.field_curr_delta_world_pos_x = 0;
                *ff7_externals.field_curr_delta_world_pos_y = 0;
                ff7_externals.modules_global_object->world_move_status = 2;

                last_valid_scripted_field_delta_world_pos = field_curr_delta_world_pos;
                break;
            case 1:
                *ff7_externals.field_bg_flag_CC15E4 = 1;
                ff7_externals.modules_global_object->world_move_status = 1;
                break;
            case 2:
            case 3:
                *ff7_externals.field_bg_flag_CC15E4 = 1;
                *ff7_externals.scripted_world_move_n_steps = ff7_externals.modules_global_object->field_20;
                *ff7_externals.scripted_world_move_step_index = 0;
                world_pos = {-(*ff7_externals.field_curr_delta_world_pos_x), -(*ff7_externals.field_curr_delta_world_pos_y)};

                if(is_fieldmap_wide())
                    field_widescreen_width_clip_with_camera_range(&world_pos);
                if(is_fieldmap_uncropped())
                    field_uncropped_height_clip_with_camera_range(&world_pos);
                

                *ff7_externals.scripted_world_initial_pos_x = -world_pos.x;
                *ff7_externals.scripted_world_initial_pos_y = -world_pos.y;
                ff7_externals.modules_global_object->world_move_status = 1;
                break;
            case 4:
                *ff7_externals.field_bg_flag_CC15E4 = 1;

                world_pos = {-(ff7_externals.modules_global_object->field_A), -(ff7_externals.modules_global_object->field_C)};
                if(is_fieldmap_wide())
                    field_widescreen_width_clip_with_camera_range(&world_pos);
                if(is_fieldmap_uncropped())
                    field_uncropped_height_clip_with_camera_range(&world_pos);

                *ff7_externals.field_curr_delta_world_pos_x = -world_pos.x;
                *ff7_externals.field_curr_delta_world_pos_y = -world_pos.y;
                ff7_externals.modules_global_object->world_move_status = 2;
                break;
            case 5:
            case 6:
                *ff7_externals.field_bg_flag_CC15E4 = 1;
                *ff7_externals.scripted_world_move_n_steps = ff7_externals.modules_global_object->field_20;
                *ff7_externals.scripted_world_move_step_index = 0;

                world_pos = {(-*ff7_externals.field_curr_delta_world_pos_x), -(*ff7_externals.field_curr_delta_world_pos_y)};
                if(is_fieldmap_wide())
                    field_widescreen_width_clip_with_camera_range(&world_pos);
                if(is_fieldmap_uncropped())
                    field_uncropped_height_clip_with_camera_range(&world_pos);

                *ff7_externals.scripted_world_initial_pos_x = -world_pos.x;
                *ff7_externals.scripted_world_initial_pos_y = -world_pos.y;

                world_pos = {-(ff7_externals.modules_global_object->field_A), -(ff7_externals.modules_global_object->field_C)};
                if(is_fieldmap_wide())
                    field_widescreen_width_clip_with_camera_range(&world_pos);
                if(is_fieldmap_uncropped())
                    field_uncropped_height_clip_with_camera_range(&world_pos);

                *ff7_externals.scripted_world_final_pos_x = -world_pos.x;
                *ff7_externals.scripted_world_final_pos_y = -world_pos.y;
                ff7_externals.modules_global_object->world_move_status = 1;
                break;
            default:
                return;
            }
        }
    }

    void field_update_scripted_bg_movement()
    {
        vector2<short> world_pos;
        vector2<float> world_pos_float;

        field_curr_delta_world_pos = {INVALID_VALUE, INVALID_VALUE};
        if(ff7_externals.modules_global_object->world_move_status == 1)
        {
            switch(ff7_externals.modules_global_object->world_move_mode)
            {
            case 1:
                ff7_externals.set_world_pos_based_on_player_pos_643C86(&world_pos);
                ff7_field_clip_with_camera_range(&world_pos);
                *ff7_externals.field_curr_delta_world_pos_x = -world_pos.x;
                *ff7_externals.field_curr_delta_world_pos_y = -world_pos.y;

                // Smooth background movement with floating point
                if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
                {
                    field_apply_player_position_2D_translation_float(&world_pos_float, ff7_externals.modules_global_object->world_move_follow_model_id);
                    field_clip_with_camera_range_float(&world_pos_float);
                    field_curr_delta_world_pos.x = -world_pos_float.x;
                    field_curr_delta_world_pos.y = -world_pos_float.y;
                }
                break;
            case 2:
            case 3:
                if(*ff7_externals.scripted_world_move_n_steps)
                {
                    ff7_externals.set_world_pos_based_on_player_pos_643C86(&world_pos);
                    ff7_field_clip_with_camera_range(&world_pos);
                    std::function<int(int, int, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 2 ?
                        ff7_externals.field_get_linear_interpolated_value : ff7_externals.field_get_smooth_interpolated_value;
                    *ff7_externals.field_curr_delta_world_pos_x = field_get_interpolated_value(
                        *ff7_externals.scripted_world_initial_pos_x,
                        -world_pos.x,
                        *ff7_externals.scripted_world_move_n_steps,
                        *ff7_externals.scripted_world_move_step_index
                    );
                    *ff7_externals.field_curr_delta_world_pos_y = field_get_interpolated_value(
                        *ff7_externals.scripted_world_initial_pos_y,
                        -world_pos.y,
                        *ff7_externals.scripted_world_move_n_steps,
                        *ff7_externals.scripted_world_move_step_index
                    );

                    // Smooth background movement with floating point
                    if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
                    {
                        field_apply_player_position_2D_translation_float(&world_pos_float, ff7_externals.modules_global_object->world_move_follow_model_id);
                        field_clip_with_camera_range_float(&world_pos_float);
                        std::function<float(float, float, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 2 ?
                            field_get_linear_interpolated_value_float : field_get_smooth_interpolated_value_float;
                        field_curr_delta_world_pos.x = field_get_interpolated_value(
                            *ff7_externals.scripted_world_initial_pos_x,
                            -world_pos_float.x,
                            *ff7_externals.scripted_world_move_n_steps,
                            *ff7_externals.scripted_world_move_step_index
                        );
                        field_curr_delta_world_pos.y = field_get_interpolated_value(
                            *ff7_externals.scripted_world_initial_pos_y,
                            -world_pos_float.y,
                            *ff7_externals.scripted_world_move_n_steps,
                            *ff7_externals.scripted_world_move_step_index
                        );
                    }

                    if(*ff7_externals.scripted_world_move_n_steps == *ff7_externals.scripted_world_move_step_index)
                        ff7_externals.modules_global_object->world_move_status = 2;
                    else
                        (*ff7_externals.scripted_world_move_step_index)++;
                }
                else
                {
                    ff7_externals.modules_global_object->world_move_status = 2;
                }
                break;
            case 5:
            case 6:
                if(*ff7_externals.scripted_world_move_n_steps)
                {
                    if(is_fieldmap_wide())
                    {
                        world_pos = {-(*ff7_externals.scripted_world_final_pos_x), -(*ff7_externals.scripted_world_final_pos_y)};
                        field_widescreen_width_clip_with_camera_range(&world_pos);
                        *ff7_externals.scripted_world_final_pos_x = -world_pos.x;

                        world_pos = {-(*ff7_externals.scripted_world_initial_pos_x), -(*ff7_externals.scripted_world_initial_pos_y)};
                        field_widescreen_width_clip_with_camera_range(&world_pos);
                        *ff7_externals.scripted_world_initial_pos_x = -world_pos.x;
                    }
                    if(is_fieldmap_uncropped())
                        field_uncropped_height_clip_with_camera_range(&world_pos);

                    std::function<int(int, int, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 5 ?
                        ff7_externals.field_get_linear_interpolated_value : ff7_externals.field_get_smooth_interpolated_value;
                    *ff7_externals.field_curr_delta_world_pos_x = field_get_interpolated_value(
                        *ff7_externals.scripted_world_initial_pos_x,
                        *ff7_externals.scripted_world_final_pos_x,
                        *ff7_externals.scripted_world_move_n_steps,
                        *ff7_externals.scripted_world_move_step_index
                    );
                    *ff7_externals.field_curr_delta_world_pos_y = field_get_interpolated_value(
                        *ff7_externals.scripted_world_initial_pos_y,
                        *ff7_externals.scripted_world_final_pos_y,
                        *ff7_externals.scripted_world_move_n_steps,
                        *ff7_externals.scripted_world_move_step_index
                    );

                    // Smooth background movement with floating point
                    if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
                    {
                        std::function<float(float, float, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 5 ?
                            field_get_linear_interpolated_value_float : field_get_smooth_interpolated_value_float;
                        field_curr_delta_world_pos.x = field_get_interpolated_value(
                            *ff7_externals.scripted_world_initial_pos_x,
                            *ff7_externals.scripted_world_final_pos_x,
                            *ff7_externals.scripted_world_move_n_steps,
                            *ff7_externals.scripted_world_move_step_index
                        );
                        field_curr_delta_world_pos.y = field_get_interpolated_value(
                            *ff7_externals.scripted_world_initial_pos_y,
                            *ff7_externals.scripted_world_final_pos_y,
                            *ff7_externals.scripted_world_move_n_steps,
                            *ff7_externals.scripted_world_move_step_index
                        );
                    }

                    if(*ff7_externals.scripted_world_move_n_steps == *ff7_externals.scripted_world_move_step_index)
                        ff7_externals.modules_global_object->world_move_status = 2;
                    else
                        (*ff7_externals.scripted_world_move_step_index)++;
                }
                else
                {
                    ff7_externals.modules_global_object->world_move_status = 2;
                }
                break;
            default:
                break;
            }

            if(is_fieldmap_wide())
            {
                world_pos = {-(*ff7_externals.field_curr_delta_world_pos_x), -(*ff7_externals.field_curr_delta_world_pos_y)};
                field_widescreen_width_clip_with_camera_range(&world_pos);
                *ff7_externals.field_curr_delta_world_pos_x = -world_pos.x;
            }
            if(is_fieldmap_uncropped())
                field_uncropped_height_clip_with_camera_range(&world_pos);
        }

        if(is_position_valid(field_curr_delta_world_pos))
        {
            last_valid_scripted_field_delta_world_pos = field_curr_delta_world_pos;
        }
    }

    void set_world_and_background_positions(vector2<float> delta_position, bool use_camdat_pan)
    {
        field_trigger_header* field_triggers_header_ptr = *ff7_externals.field_triggers_header;
        int field_bg_multiplier = *ff7_externals.field_bg_multiplier;

        field_3d_world_pos.x = ff7_externals.modules_global_object->shake_bg_x.shake_curr_value + ff7_externals.field_bg_offset->x - delta_position.x - 160;
        field_3d_world_pos.x += (use_camdat_pan) ? -(*ff7_externals.field_camera_data)->pan_x : 0;
        field_3d_world_pos.x *= field_bg_multiplier;
        field_3d_world_pos.y = ff7_externals.modules_global_object->shake_bg_y.shake_curr_value + ff7_externals.field_bg_offset->y - delta_position.y - 120;
        field_3d_world_pos.y += (use_camdat_pan) ? (*ff7_externals.field_camera_data)->pan_y : 0;
        field_3d_world_pos.y *= field_bg_multiplier;
        bg_main_layer_pos.x = delta_position.x + 320 - ff7_externals.field_bg_offset->x - ff7_externals.modules_global_object->shake_bg_x.shake_curr_value;
        bg_main_layer_pos.y = delta_position.y + 232 - ff7_externals.field_bg_offset->y - ff7_externals.modules_global_object->shake_bg_y.shake_curr_value;
        bg_layer3_pos.x = (field_triggers_header_ptr->bg3_pos_x / 16.f) + ((field_triggers_header_ptr->bg3_speed_x * delta_position.x) / 256.f);
        bg_layer3_pos.x = remainder(bg_layer3_pos.x, field_triggers_header_ptr->bg3_width);
        bg_layer3_pos.x = bg_layer3_pos.x + 320 - ff7_externals.field_bg_offset->x - ff7_externals.modules_global_object->shake_bg_x.shake_curr_value;
        bg_layer3_pos.y = (field_triggers_header_ptr->bg3_pos_y / 16.f) + ((field_triggers_header_ptr->bg3_speed_y * delta_position.y) / 256.f);
        bg_layer3_pos.y = remainder(bg_layer3_pos.y, field_triggers_header_ptr->bg3_height);
        bg_layer3_pos.y = bg_layer3_pos.y + 232 - ff7_externals.field_bg_offset->y - ff7_externals.modules_global_object->shake_bg_y.shake_curr_value;
        bg_layer4_pos.x = (field_triggers_header_ptr->bg4_pos_x / 16.f) + ((field_triggers_header_ptr->bg4_speed_x * delta_position.x) / 256.f);
        bg_layer4_pos.x = remainder(bg_layer4_pos.x, field_triggers_header_ptr->bg4_width);
        bg_layer4_pos.x = bg_layer4_pos.x + 320 - ff7_externals.field_bg_offset->x - ff7_externals.modules_global_object->shake_bg_x.shake_curr_value;
        bg_layer4_pos.y = (field_triggers_header_ptr->bg4_pos_y / 16.f) + ((field_triggers_header_ptr->bg4_speed_y * delta_position.y) / 256.f);
        bg_layer4_pos.y = remainder(bg_layer4_pos.y, field_triggers_header_ptr->bg4_height);
        bg_layer4_pos.y = bg_layer4_pos.y + 232 - ff7_externals.field_bg_offset->y - ff7_externals.modules_global_object->shake_bg_y.shake_curr_value;

        // Round the position to steps of 1/MIN_STEP_INVERSE due to visual glitches between tiles
        field_3d_world_pos.x = round(field_3d_world_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
        field_3d_world_pos.y = round(field_3d_world_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
        bg_main_layer_pos.x = round(bg_main_layer_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
        bg_main_layer_pos.y = round(bg_main_layer_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
        bg_layer3_pos.x = round(bg_layer3_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
        bg_layer3_pos.y = round(bg_layer3_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
        bg_layer4_pos.x = round(bg_layer4_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
        bg_layer4_pos.y = round(bg_layer4_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
    }

    void compute_pointer_hand_position(vector2<float> field_3d_world_coord, int model_id)
    {
        int view_multiplier = *ff7_externals.field_bg_multiplier;
        field_event_data* event_data_ptr = *ff7_externals.field_event_data_ptr;
        vector3<float> position;
        vector2<float> cursor_delta_pos;

        position.x = event_data_ptr[model_id].model_pos.x / 4096.f + event_data_ptr[model_id].offset_position_x;
        position.y = event_data_ptr[model_id].model_pos.y / 4096.f + event_data_ptr[model_id].offset_position_y;
        position.z = event_data_ptr[model_id].model_pos.z / 4096.f + event_data_ptr[model_id].offset_position_z + (ff7_externals.modules_global_object->field_10 << 7 >> 9);
        field_apply_2D_translation_float_64314F(&position, &cursor_delta_pos);
        cursor_position.x = field_3d_world_coord.x + view_multiplier * cursor_delta_pos.x + ff7_externals.field_curr_half_viewport_width_height_CFF1FC->x;
        cursor_position.y = field_3d_world_coord.y + view_multiplier * (cursor_delta_pos.y - 8) + ff7_externals.field_curr_half_viewport_width_height_CFF1FC->y;


        int viewport_x = is_fieldmap_wide() ? wide_viewport_x : ff7_externals.field_viewport_xy_CFF204->x;
        int viewport_width = is_fieldmap_wide() ? wide_viewport_width / 2 : 320;
        if(cursor_position.x > viewport_x + viewport_width * view_multiplier)
            cursor_position.x = viewport_x + viewport_width * view_multiplier;
        if(cursor_position.x < viewport_x)
            cursor_position.x = viewport_x;
        if(cursor_position.y > ff7_externals.field_viewport_xy_CFF204->y + 224 * view_multiplier)
            cursor_position.y = ff7_externals.field_viewport_xy_CFF204->y + 224 * view_multiplier;
        if(cursor_position.y < ff7_externals.field_viewport_xy_CFF204->y - 32)
            cursor_position.y = ff7_externals.field_viewport_xy_CFF204->y - 32;
    }

    void ff7_field_update_background()
    {
        ff7_externals.field_update_background_positions();

        int player_model_id = *ff7_externals.field_player_model_id;
        field_3d_world_pos = {INVALID_VALUE, INVALID_VALUE};
        bg_main_layer_pos = {INVALID_VALUE, INVALID_VALUE};
        bg_layer3_pos = {INVALID_VALUE, INVALID_VALUE};
        bg_layer4_pos = {INVALID_VALUE, INVALID_VALUE};
        cursor_position = {INVALID_VALUE, INVALID_VALUE};
        if ( *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag)
        {
            if(ff7_externals.modules_global_object->MVCAM_flag == 1 && is_position_valid(field_curr_delta_world_pos))
            {
                int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
                field_3d_world_pos.x = (field_curr_delta_world_pos.x + ff7_externals.field_bg_offset->x - 160) * field_bg_multiplier;
                field_3d_world_pos.y = (field_curr_delta_world_pos.y + ff7_externals.field_bg_offset->y - 120) * field_bg_multiplier;
                field_3d_world_pos.x = round(field_3d_world_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
                field_3d_world_pos.y = round(field_3d_world_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
            }
        }
        else if(*ff7_externals.field_bg_flag_CC15E4)
        {
            if (enable_analogue_controls)
            {
                vector2<float> bg_delta_position = {0.0f, 0.0f};
                bool use_camdat_pan = true;
                if(is_position_valid(field_curr_delta_world_pos))
                {
                    bg_delta_position.x = -field_curr_delta_world_pos.x;
                    bg_delta_position.y = -field_curr_delta_world_pos.y;
                    use_camdat_pan = true;
                    set_world_and_background_positions(bg_delta_position, true);
                }
                else if(is_position_valid(last_valid_scripted_field_delta_world_pos))
                {
                    bg_delta_position.x = -last_valid_scripted_field_delta_world_pos.x;
                    bg_delta_position.y = -last_valid_scripted_field_delta_world_pos.y;

                    field_clip_with_camera_range_float(&bg_delta_position);
                    field_curr_delta_world_pos.x = -bg_delta_position.x;
                    field_curr_delta_world_pos.y = -bg_delta_position.y;

                    set_world_and_background_positions(bg_delta_position, true);
                }
            }
            else
            {
                if(is_position_valid(field_curr_delta_world_pos))
                    set_world_and_background_positions({-field_curr_delta_world_pos.x, -field_curr_delta_world_pos.y}, true);
            }


            if((*ff7_externals.field_event_data_ptr)[player_model_id].field_62)
                compute_pointer_hand_position(field_3d_world_pos, player_model_id);
        }
        else
        {
            vector2<float> bg_delta_position;
            field_apply_player_position_2D_translation_float(&bg_delta_position, player_model_id);
            field_clip_with_camera_range_float(&bg_delta_position);
            float_sub_643628(*ff7_externals.field_triggers_header, &bg_delta_position);
            field_curr_delta_world_pos.x = -bg_delta_position.x;
            field_curr_delta_world_pos.y = -bg_delta_position.y;
            set_world_and_background_positions(bg_delta_position, false);

            compute_pointer_hand_position(field_3d_world_pos, player_model_id);
        }
    }

    // This function should be called at each frame after drawing backgrounds and 3d models
    void draw_gray_quads_sub_644E90()
    {
        ff7_externals.field_draw_gray_quads_644E90();

        if (widescreen_enabled) widescreen.zoomBackground();

        newRenderer.setTimeFilterEnabled(false);
    }
}
````

## File: src/ff7/field/background.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "../../ff7.h"

namespace ff7::field
{
    constexpr float INVALID_VALUE = -1000000;

    vector2<float>
        field_curr_delta_world_pos,
        last_valid_scripted_field_delta_world_pos,
        field_3d_world_pos,
        bg_main_layer_pos,
        bg_layer3_pos,
        bg_layer4_pos,
        cursor_position;

    void ff7_field_update_background();
    void ff7_field_set_world_coordinate_640EB7();
    void ff7_field_submit_draw_arrow(field_arrow_graphics_data* arrow_data);
    void ff7_field_submit_draw_cursor(field_arrow_graphics_data* arrow_data);
    void draw_gray_quads_sub_644E90();
    inline bool is_position_valid(vector2<float> position) {
        return position.x != INVALID_VALUE && position.y != INVALID_VALUE;
    }

}
````

## File: src/ff7/field/camera.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2022 Tang-Tang Zhou                                     //
//    Copyright (C) 2022 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/
#include "camera.h"

namespace ff7::field
{
    Camera camera;

    void Camera::setScrollingDir(float x, float y)
    {
        scrollingDir.x = x;
        scrollingDir.y = y;
    }

    void Camera::setScrollingOffset(float x, float y)
    {
        scrollingOffset.x = x;
        scrollingOffset.y = y;
    }
}
````

## File: src/ff7/field/camera.h
````
/****************************************************************************/
//    Copyright (C) 2022 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "matrix.h"

namespace ff7::field
{
    class Camera
    {
        public:
            Camera() = default;
            ~Camera() = default;

            void setScrollingDir(float x, float y);
            float getScrollingDirX();
            float getScrollingDirY();

            void setScrollingOffset(float x, float y);
            float getScrollingOffsetX();
            float getScrollingOffsetY();

        private:
            vector2<float> scrollingDir = { 0.0, 0.0 };
            vector2<float> scrollingOffset = { 0.0, 0.0 };
    };

    inline float Camera::getScrollingDirX()
    {
        return scrollingDir.x;
    }

    inline float Camera::getScrollingDirY()
    {
        return scrollingDir.y;
    }

    inline float Camera::getScrollingOffsetX()
    {
        return scrollingOffset.x;
    }

    inline float Camera::getScrollingOffsetY()
    {
        return scrollingOffset.y;
    }

    extern Camera camera;
}
````

## File: src/ff7/field/defs.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "ff7.h"

namespace ff7::field
{
    void ff7_field_hook_init();
    void field_load_textures(struct ff7_game_obj *game_object, struct struc_3 *struc_3);
    void field_layer1_pick_tiles(short x_offset, short y_offset);
    void field_layer2_pick_tiles(short x_offset, short y_offset);
    void field_layer3_pick_tiles(short x_offset, short y_offset);
    void field_layer4_pick_tiles(short x_offset, short y_offset);
    void ff7_field_clip_with_camera_range(vector2<short>* point);
    void ff7_field_layer3_clip_with_camera_range(field_trigger_header* trigger_header, vector2<short>* point);
    uint32_t field_open_flevel_siz();
    void field_init_scripted_bg_movement();
    void field_update_scripted_bg_movement();
    bool ff7_field_do_draw_3d_model(short x, short y);
    void ff7_field_set_fade_quad_size(int x, int y, int width, int height);
    int ff7_field_models_eye_to_model(char* model_name);
    int ff7_field_blink_eye_sub_649B50(field_animation_data *field_anim_data, field_model_blink_data *blink_data);
    void ff7_field_handle_blink_reset();
}
````

## File: src/ff7/field/enter.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "model.h"
#include "background.h"
#include "../widescreen.h"

namespace ff7::field
{
    inline void ff7_field_initialize_variables()
    {
        ((void(*)())ff7_externals.field_initialize_variables)();

        field_3d_world_pos = {INVALID_VALUE, INVALID_VALUE};
        bg_main_layer_pos = {INVALID_VALUE, INVALID_VALUE};
        bg_layer3_pos = {INVALID_VALUE, INVALID_VALUE};
        bg_layer4_pos = {INVALID_VALUE, INVALID_VALUE};
        field_curr_delta_world_pos = {INVALID_VALUE, INVALID_VALUE};
        cursor_position = {INVALID_VALUE, INVALID_VALUE};

        // reset movement frame index for all models
        for(auto &external_data : external_model_data){
            external_data.moveFrameIndex = 0;
            external_data.rotationMoveFrameIndex = 0;
            external_data.prevCollisionRadius = 0;

            external_data.blinkFrameIndex = BLINKING_FRAMES;
        }

        if(widescreen_enabled || enable_uncrop) widescreen.initParamsFromConfig();
    }
}
````

## File: src/ff7/field/field.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

/*
 * This file contains the changes necessary to support subtractive and 25%
 * blending modes in field backgrounds. Texture pages where these blending
 * modes are used are duplicated and the tile data modified to point to these
 * new pages which have the correct blending mode set.
 */

#include "../../log.h"
#include "../../patch.h"
#include "../../common.h"
#include "../widescreen.h"
#include "../defs.h"

#include "opcode.h"
#include "background.h"
#include "defs.h"
#include "enter.h"
#include "model.h"

namespace ff7::field
{
    // helper function initializes page dst, copies texture from src and applies
    // blend_mode
    void field_load_textures_helper(struct ff7_game_obj *game_object, struct struc_3 *struc_3, uint32_t src, uint32_t dst, uint32_t blend_mode)
    {
        struct ff7_tex_header *tex_header;

        ff7_externals.make_struc3(blend_mode, struc_3);

        tex_header = (struct ff7_tex_header *)common_externals.create_tex_header();

        ff7_externals.field_layers[dst]->tex_header = tex_header;

        if(ff7_externals.field_layers[src]->type == 1) ff7_externals.make_field_tex_header_pal(tex_header);
        if(ff7_externals.field_layers[src]->type == 2) {
            ff7_externals.make_field_tex_header(tex_header);
            tex_header->color_key = 3;
        }

        struc_3->tex_header = tex_header;

        if(src != dst)
        {
            ff7_externals.field_layers[dst]->image_data = external_malloc(256 * 256);
            memcpy(ff7_externals.field_layers[dst]->image_data, ff7_externals.field_layers[src]->image_data, 256 * 256);
        }

        tex_header->image_data = (unsigned char*)ff7_externals.field_layers[dst]->image_data;

        tex_header->file.pc_name = (char*)external_malloc(1024);
        sprintf(tex_header->file.pc_name, "field/%s/%s_%02i", strchr(ff7_externals.field_file_name, '\\') + 1, strchr(ff7_externals.field_file_name, '\\') + 1, src);

        ff7_externals.field_layers[dst]->graphics_object = ff7_externals._load_texture(1, PT_S2D, struc_3, 0, game_object->dx_sfx_something);
        ff7_externals.field_layers[dst]->present = true;
    }

    void field_load_textures(struct ff7_game_obj *game_object, struct struc_3 *struc_3)
    {
        uint32_t i;

        ff7_externals.field_convert_type2_layers();

        for(i = 0; i < 29; i++)
        {
            uint32_t blend_mode = 4;

            if(!ff7_externals.field_layers[i]->present) continue;

            if(ff7_externals.field_layers[i]->type == 1)
            {
                if(i >= 24) blend_mode = 0;
                else if(i >= 15) blend_mode = 1;
            }
            else if(ff7_externals.field_layers[i]->type == 2)
            {
                if(i >= 40) blend_mode = 0;
                else if(i >= 33) blend_mode = 1;
            }
            else ffnx_glitch("unknown field layer type %i\n", ff7_externals.field_layers[i]->type);

            field_load_textures_helper(game_object, struc_3, i, i, blend_mode);

            // these magic numbers have been gleaned from original source data
            // the missing blend modes in question are used in exactly these pages
            // and copying them in this manner does not risk overwriting any other
            // data
            if(i >= 15 && i <= 18 && ff7_externals.field_layers[i]->type == 1) field_load_textures_helper(game_object, struc_3, i, i + 14, 2);
            if(i >= 15 && i <= 20 && ff7_externals.field_layers[i]->type == 1) field_load_textures_helper(game_object, struc_3, i, i + 18, 3);
        }

        *ff7_externals.layer2_end_page += 18;
    }

    uint32_t field_open_flevel_siz()
    {
        struct lgp_file *f = lgp_open_file("flevel.siz", 1);

        if (0 == f) {
            return 0;
        }

        uint32_t size = lgp_get_filesize(f, 1);
        char* buffer = new char[size];

        lgp_read_file(f, 1, buffer, size);

        // Increase from 787 (field map count) to 1200
        const uint32_t max_map_count = 1200;
        uint32_t* uncompressed_sizes = reinterpret_cast<uint32_t*>(buffer);
        uint32_t count = size / sizeof(uint32_t);
        uint32_t* flevel_sizes = reinterpret_cast<uint32_t*>(ff7_externals.field_map_infos + 0xBC);

        if (count > max_map_count) {
            count = max_map_count;
        }

        for (uint32_t i = 0; i < count; ++i) {
            flevel_sizes[i * 0x34] = uncompressed_sizes[i] + 4000000; // +2 MB compared to the original implementation
        }

        // Force a value if not specified by the flevel.siz
        for (uint32_t i = count; i < max_map_count; ++i) {
            flevel_sizes[i * 0x34] = 4000000;
        }

        delete[] buffer;

        return 1;
    }

    void ff7_field_set_fade_quad_size(int x, int y, int width, int height)
    {
        if(widescreen_enabled)
        {
            x -= abs(wide_viewport_x);
            width += (wide_viewport_width - game_width);
        }
        if(enable_uncrop)
        {
            y -= ff7_field_center ? 16 : 0;
            height += 32;
        }
        ff7_externals.field_sub_63AC3F(x, y, width, height);
    }

    void ff7_field_evaluate_encounter_rate()
    {
        field_event_data* field_event_data_array = (*ff7_externals.field_event_data_ptr);
        int original_movement_speed = field_event_data_array[*ff7_externals.field_player_model_id].movement_speed;
        field_event_data_array[*ff7_externals.field_player_model_id].movement_speed = original_movement_speed / common_frame_multiplier;
        ff7_externals.field_evaluate_encounter_rate_60B2C6();
        field_event_data_array[*ff7_externals.field_player_model_id].movement_speed = original_movement_speed;
    }

    int ff7_field_load_map_trigger_data()
    {
        // Do not override current trigger data for woa_* fields
        if (
            *ff7_externals.field_resuming_from_battle_CFF268 &&
            (
                (*common_externals.current_field_id == 709) ||
                (*common_externals.current_field_id == 710) ||
                (*common_externals.current_field_id == 711)
            )
        )
            return 1;

        return ff7_externals.field_load_map_trigger_data_sub_6211C3();
    }

    void ff7_field_hook_init()
    {
        std::copy(common_externals.execute_opcode_table, &common_externals.execute_opcode_table[OPCODE_COUNT - 1], &original_opcode_table[0]);
        // Init stuff
        replace_call_function(ff7_externals.field_sub_60DCED + 0x178, ff7_field_initialize_variables);

        // Model movement (walk, run) fps fix + allow footstep sfx
        replace_call_function(ff7_externals.field_loop_sub_63C17F + 0x5DD, ff7_field_update_models_position);
        replace_call_function(ff7_externals.field_update_models_positions + 0x8BC, ff7_field_update_player_model_position);
        replace_call_function(ff7_externals.field_update_models_positions + 0x9E8, ff7_field_update_single_model_position);
        replace_call_function(ff7_externals.field_update_models_positions + 0x9AA, ff7_field_check_collision_with_target);
        replace_call_function(common_externals.execute_opcode_table[OFST] + 0x46, ff7_opcode_multiply_get_bank_value);

        // Model rotation
        byte jump_to_OFST_update[] = {0xE9, 0xE6, 0x01, 0x00, 0x00};
        replace_call_function(ff7_externals.field_update_models_positions + 0x7C, ff7_field_update_models_rotation_new);
        memcpy_code(ff7_externals.field_update_models_positions + 0x81, jump_to_OFST_update, sizeof(jump_to_OFST_update));

        if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
        {
            if(ff7_fps_limiter == FPS_LIMITER_60FPS)
            {
                // Partial animation fps fix
                patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANMX1], (DWORD)&opcode_script_partial_animation_wrapper);
                patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANMX2], (DWORD)&opcode_script_partial_animation_wrapper);
                patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANIM1], (DWORD)&opcode_script_partial_animation_wrapper);
                patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANIM2], (DWORD)&opcode_script_partial_animation_wrapper);

                // Model movement fps fix for ladder and jump
                patch_code_byte(ff7_externals.field_update_models_positions + 0x1041, 0x2 - common_frame_multiplier / 2);
                patch_code_byte(ff7_externals.field_update_models_positions + 0x189A, 0x2 - common_frame_multiplier / 2);
                replace_call_function(common_externals.execute_opcode_table[JUMP] + 0x1F1, ff7_opcode_multiply_get_bank_value);
                patch_divide_code<int>(ff7_externals.field_update_models_positions + 0xC89, common_frame_multiplier * 2);
                patch_divide_code<int>(ff7_externals.field_update_models_positions + 0xE48, common_frame_multiplier * 2);

                // Encounter rate fix
                replace_call_function(ff7_externals.field_update_models_positions + 0x90F, ff7_field_evaluate_encounter_rate);

                // Text box message fix
                patch_code_byte(ff7_externals.field_text_box_window_paging_631945 + 0xFD, 0x5 + common_frame_multiplier / 2);
                patch_divide_code<byte>(ff7_externals.field_text_box_window_paging_631945 + 0x100, common_frame_multiplier);
                patch_divide_code<WORD>(ff7_externals.field_text_box_window_paging_631945 + 0x111, common_frame_multiplier);
                patch_code_byte(ff7_externals.field_text_box_window_paging_631945 + 0x141, 0x4 + common_frame_multiplier / 2);
                patch_code_byte(ff7_externals.field_text_box_window_opening_6317A9 + 0x3D, 0x2 + common_frame_multiplier / 2);
                patch_code_byte(ff7_externals.field_text_box_window_opening_6317A9 + 0xD2, 0x2 + common_frame_multiplier / 2);
                patch_code_byte(ff7_externals.field_text_box_window_closing_632EB8 + 0x64, 0x2 + common_frame_multiplier / 2);
                patch_code_byte(ff7_externals.field_text_box_window_closing_632EB8 + 0xBF, 0x2 + common_frame_multiplier / 2);
                patch_divide_code<short>(ff7_externals.field_text_box_window_reverse_paging_632CAA + 0x42, common_frame_multiplier);
                patch_divide_code<short>(ff7_externals.field_opcode_message_update_loop_630D50 + 0x1AC, common_frame_multiplier);
                patch_divide_code<short>(ff7_externals.field_opcode_message_update_loop_630D50 + 0x2CF, common_frame_multiplier);
                patch_divide_code<short>((uint32_t)ff7_externals.field_opcode_ask_update_loop_6310A1 + 0x1AC, common_frame_multiplier);
                patch_divide_code<byte>((uint32_t)ff7_externals.field_opcode_ask_update_loop_6310A1 + 0x3CC, common_frame_multiplier);

                // Fade in and fade out screen transitions
                patch_divide_code<short>(ff7_externals.field_initialize_variables + 0x123, common_frame_multiplier);
                patch_code_byte(ff7_externals.field_handle_screen_fading + 0x210, 25 * common_frame_multiplier);
                patch_code_int(ff7_externals.field_handle_screen_fading + 0x240, 25 * common_frame_multiplier - 1);
            }

            // Smooth background movement for both 30 fps mode and 60 fps mode
            replace_call_function(ff7_externals.field_draw_everything + 0x34, ff7_field_set_world_coordinate_640EB7);
            replace_call_function(ff7_externals.field_loop_sub_63C17F + 0x1A6, ff7_field_update_background);
            replace_call_function(ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B + 0x357, ff7_field_submit_draw_arrow);
            replace_call_function(ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B + 0x63C, ff7_field_submit_draw_arrow);
            replace_call_function(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x284, ff7_field_submit_draw_cursor);
        }

        // Movie model animation fps fix
        replace_call_function(ff7_externals.field_update_models_positions + 0x68D, ff7_field_update_model_animation_frame);
        replace_call_function(ff7_externals.field_update_models_positions + 0x919, ff7_field_update_model_animation_frame);
        replace_call_function(ff7_externals.field_update_models_positions + 0xA2B, ff7_field_update_model_animation_frame);
        replace_call_function(ff7_externals.field_update_models_positions + 0xE8C, ff7_field_update_model_animation_frame);

        // Background scroll fps fix
        replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x34, ff7_opcode_divide_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x4D, ff7_opcode_divide_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x68, ff7_opcode_divide_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x81, ff7_opcode_divide_get_bank_value);
        replace_function(ff7_externals.opcode_shake, opcode_script_SHAKE);

        // Camera fps fix
        replace_call_function(common_externals.execute_opcode_table[SCRLC] + 0x3B, ff7_opcode_multiply_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[SCRLA] + 0x72, ff7_opcode_multiply_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[SCR2DC] + 0x3C, ff7_opcode_multiply_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[SCR2DL] + 0x3C, ff7_opcode_multiply_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[SCRLP] + 0xA7, ff7_opcode_multiply_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[NFADE] + 0x89, ff7_opcode_divide_get_bank_value);
        replace_call_function(common_externals.execute_opcode_table[VWOFT] + 0xCC, ff7_opcode_multiply_get_bank_value);
        patch_code_dword((uint32_t)&common_externals.execute_opcode_table[FADE], (DWORD)&opcode_script_FADE);

        // Movie fps fix
        patch_code_dword((uint32_t)&common_externals.execute_opcode_table[MVIEF], (DWORD)&opcode_script_MVIEF);
        patch_code_dword((uint32_t)&common_externals.execute_opcode_table[BGMOVIE], (DWORD)&opcode_script_BGMOVIE);

        // Others fps fix
        patch_code_dword((uint32_t)&common_externals.execute_opcode_table[WAIT], (DWORD)&opcode_script_WAIT);
        replace_function(ff7_externals.sub_611BAE, opcode_IFSW_compare_sub);

        // Fix wind wall animation for woa_* fields
        replace_call_function(ff7_externals.sub_62120E + 0x3AA, ff7_field_load_map_trigger_data);

        // Fix run emulation when using the analogue key for NPCs
        patch_code_dword((uint32_t)&common_externals.execute_opcode_table[IFKEY], (DWORD)&opcode_script_IFKEY);
    }
}
````

## File: src/ff7/field/model.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../../globals.h"
#include "../../sfx.h"
#include "../../movies.h"
#include "../../utils.h"
#include "../../log.h"
#include "../widescreen.h"

#include "utils.h"
#include "model.h"

namespace ff7::field
{
    bool ff7_field_do_draw_3d_model(short x, short y)
    {
        if(*ff7_externals.field_bg_flag_CC15E4)
            return 1;
        int left_offset_x = 40 + (widescreen_enabled ? abs(wide_viewport_x) - 50 : 0);
        int right_offset_x = 400 + (widescreen_enabled ? abs(wide_viewport_x) - 50 : 0);
        return x > ff7_externals.field_viewport_xy_CFF204->x - left_offset_x && x < ff7_externals.field_viewport_xy_CFF204->x + right_offset_x &&
            y > ff7_externals.field_viewport_xy_CFF204->y - 120 && y < ff7_externals.field_viewport_xy_CFF204->y + 460;
    }

    void ff7_field_update_models_position(int key_input_status)
    {
        bool emulate_run = !(ff7_externals.modules_global_object->current_key_input_status & 0x40) && gamepad_analogue_intent == INTENT_RUN;

        if (emulate_run)
        {
            key_input_status |= 0x40;
            ff7_externals.modules_global_object->current_key_input_status |= 0x40;
        }

        ((void(*)(int))ff7_externals.field_update_models_positions)(key_input_status);

        if (emulate_run)
        {
            key_input_status &= ~0x40;
            ff7_externals.modules_global_object->current_key_input_status &= ~0x40;
        }

        for(int model_idx = 0; model_idx < (int)(*ff7_externals.field_n_models); model_idx++)
        {
            // Reset movement frame index for all models if they are not walking/running
            if((*ff7_externals.field_event_data_ptr)[model_idx].movement_type != 1)
            {
                external_model_data[model_idx].moveFrameIndex = 0;
            }

            // Reset rotation movement frame index for all models if they are not rotating
            byte rotation_type = (*ff7_externals.field_event_data_ptr)[model_idx].rotation_steps_type;
            if(rotation_type == 0 || rotation_type == 3)
            {
                external_model_data[model_idx].rotationMoveFrameIndex = 0;
            }
        }
    }

    int ff7_field_update_player_model_position(short model_id)
    {
        field_event_data* field_event_data_array = (*ff7_externals.field_event_data_ptr);
        int original_movement_speed = field_event_data_array[model_id].movement_speed;
        int frame_multiplier = get_frame_multiplier();
        if(is_fps_running_more_than_original())
        {
            field_event_data_array[model_id].movement_speed = original_movement_speed / frame_multiplier;
        }

        int is_player_moving = ff7_externals.field_update_single_model_position(model_id);
        field_event_data_array[model_id].movement_speed = original_movement_speed;

        // Allow footsteps to be detected correctly
        if(ff7_footsteps)
            sfx_process_footstep(is_player_moving);

        return is_player_moving;
    }

    int ff7_field_update_single_model_position(short model_id)
    {
        int ret;
        int frame_multiplier = get_frame_multiplier();
        field_event_data* field_event_data_array = (*ff7_externals.field_event_data_ptr);

        if(is_fps_running_more_than_original() && *ff7_externals.field_id == 748)
        {
            // Fix softlock related to this discussion https://github.com/julianxhokaxhiu/FFNx/discussions/569. 
            // The issue is due to the fact that when Cloud climb up, there is a mini auto movement which triggers a line making Cloud jump below.
            // This script that makes Cloud jump below does not end well, which makes the next script overlapping with this.
            // If the next script is to climb back up, there is a sort of race condition where the player movability is activated.
            // Then if the player taps the DOWN button, it will go into a softlock.
            // 
            // This logic is very fragile (might cause other softlock), so, the solution is to write another logic only for this map
            int interpolationStep = external_model_data[model_id].moveFrameIndex + 1;
            if(external_model_data[model_id].moveFrameIndex == 0)
            {
                external_model_data[model_id].initialPosition = field_event_data_array[model_id].model_pos;
                ret = ff7_externals.field_update_single_model_position(model_id);
                external_model_data[model_id].updateMovementReturnValue = ret;
                external_model_data[model_id].finalPosition = field_event_data_array[model_id].model_pos;
                external_model_data[model_id].prevCollisionRadius = field_event_data_array[model_id].collision_radius;
                field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].collision_radius = 0;
            }
            else
            {
                ret = external_model_data[model_id].updateMovementReturnValue;
                field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
            }

            if((external_model_data[model_id].moveFrameIndex + 1) % frame_multiplier == 0)
            {
                field_event_data_array[model_id].collision_radius = external_model_data[model_id].prevCollisionRadius;
            }

            external_model_data[model_id].moveFrameIndex = (external_model_data[model_id].moveFrameIndex + 1) % frame_multiplier;
        }
        else if(is_fps_running_more_than_original())
        {
            int interpolationStep = external_model_data[model_id].moveFrameIndex + 1;
            if(external_model_data[model_id].moveFrameIndex == 0)
            {
                external_model_data[model_id].initialPosition = field_event_data_array[model_id].model_pos;
                ret = ff7_externals.field_update_single_model_position(model_id);
                external_model_data[model_id].updateMovementReturnValue = ret;
                external_model_data[model_id].finalPosition = field_event_data_array[model_id].model_pos;
                field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
            }
            else
            {
                ret = external_model_data[model_id].updateMovementReturnValue;
                field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
                field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
            }
            external_model_data[model_id].moveFrameIndex = (external_model_data[model_id].moveFrameIndex + 1) % frame_multiplier;
        }
        else
        {
            ret = ff7_externals.field_update_single_model_position(model_id);
        }

        return ret;
    }

    int ff7_field_check_collision_with_target(field_event_data* field_event_model, short target_collision_radius)
    {
        int ret;
        int frame_multiplier = get_frame_multiplier();
        int model_id = std::distance(*ff7_externals.field_event_data_ptr, field_event_model);

        if(is_fps_running_more_than_original())
        {
            if(external_model_data[model_id].moveFrameIndex == 0)
            {
                ret = ff7_externals.field_check_collision_with_target(field_event_model, target_collision_radius);
                external_model_data[model_id].wasNotCollidingWithTarget = ret;
            }
            else
            {
                ret = external_model_data[model_id].wasNotCollidingWithTarget;
            }
        }
        else
        {
            ret = ff7_externals.field_check_collision_with_target(field_event_model, target_collision_radius);
        }

        return ret;
    }

    void ff7_field_update_models_rotation_new()
    {
        for(int model_idx = 0; model_idx < *ff7_externals.field_n_models; model_idx++)
        {
            auto &field_event_data = (*ff7_externals.field_event_data_ptr)[model_idx];
            byte rotation_type = field_event_data.rotation_steps_type;
            if(rotation_type)
            {
                // Legacy code still works, but when in 60FPS, the steps index and number of steps are modified
                uint32_t rotation_n_steps = field_event_data.rotation_n_steps;
                uint32_t rotation_steps_idx = field_event_data.rotation_step_idx;

                if(is_fps_running_more_than_original())
                {
                    rotation_n_steps *= get_frame_multiplier();
                    rotation_steps_idx = rotation_steps_idx * get_frame_multiplier() + external_model_data[model_idx].rotationMoveFrameIndex;
                }

                if(rotation_type == 1)
                {
                    field_event_data.rotation_curr_value = ff7_externals.field_get_linear_interpolated_value(
                        field_event_data.rotation_initial,
                        field_event_data.rotation_final,
                        rotation_n_steps,
                        rotation_steps_idx
                    );

                    if(field_event_data.rotation_step_idx == field_event_data.rotation_n_steps)
                        field_event_data.rotation_steps_type = 3;
                    else
                    {
                        if(is_fps_running_more_than_original())
                        {
                            external_model_data[model_idx].rotationMoveFrameIndex = (external_model_data[model_idx].rotationMoveFrameIndex + 1) % get_frame_multiplier();
                            if(external_model_data[model_idx].rotationMoveFrameIndex == 0)
                                field_event_data.rotation_step_idx++;
                        }
                        else
                        {
                            field_event_data.rotation_step_idx++;
                        }
                    }
                }
                else if(rotation_type == 2)
                {
                    field_event_data.rotation_curr_value = ff7_externals.field_get_smooth_interpolated_value(
                        field_event_data.rotation_initial,
                        field_event_data.rotation_final,
                        rotation_n_steps,
                        rotation_steps_idx
                    );

                    if(field_event_data.rotation_step_idx == field_event_data.rotation_n_steps)
                        field_event_data.rotation_steps_type = 3;
                    else
                    {
                        if(is_fps_running_more_than_original())
                        {
                            external_model_data[model_idx].rotationMoveFrameIndex = (external_model_data[model_idx].rotationMoveFrameIndex + 1) % get_frame_multiplier();
                            if(external_model_data[model_idx].rotationMoveFrameIndex == 0)
                                field_event_data.rotation_step_idx++;
                        }
                        else
                        {
                            field_event_data.rotation_step_idx++;
                        }
                    }
                }
            }
        }
    }

    void ff7_field_handle_blink_reset()
    {
        static WORD last_field_id = 0;

        if (last_field_id != *common_externals.current_field_id)
        {
            last_field_id = *common_externals.current_field_id;

            // Reset eyes blinking
            ff7_externals.field_model_blink_data_D000C8->blink_left_eye_mode = 0;
            ff7_externals.field_model_blink_data_D000C8->blink_right_eye_mode = 0;

            // Reset mouths
            for(int i = 0; i < FF7_MAX_NUM_MODEL_ENTITIES; i++)
            {
                ff7_model_data[i].current_mouth_idx = 0;
                if (ff7_model_data[i].mouth_tex) ff7_externals.field_unload_model_tex(ff7_model_data[i].mouth_tex);
                ff7_model_data[i].mouth_tex = NULL;
            }
        }
    }

    int ff7_internal_blink_eye(field_animation_data *field_anim_data, field_model_blink_data *blink_data)
    {
        int i;
        ff7_polygon_set *polygon_set = nullptr;
        struct hrc_bone *bones;
        hrc_data *hrc_data;
        int blink_left_eye_mode;
        int blink_right_eye_mode;

        if ( field_anim_data->anim_frame_object )
        {
            hrc_data = field_anim_data->anim_frame_object->hrc_data;
            if ( hrc_data )
            {
                int bone_idx = 0;
                bones = field_anim_data->anim_frame_object->hrc_data->bones;
                if ( (char)field_anim_data->eye_texture_idx >= 33 )
                    return 1;
                while ( bone_idx < (signed int)hrc_data->num_bones && _strcmpi(bones->bone_name, "head") )
                {
                    ++bone_idx;
                    ++bones;
                }
                if ( bone_idx == hrc_data->num_bones ) return 0;
                polygon_set = bones->rsd_array->rsd_data->polygon_set;
                ff7_externals.field_sub_6A2736(polygon_set);
                // Mouth replacement logic
                if (ff7_advanced_blinking && polygon_set && ff7_model_data[blink_data->model_id].mouth_tex)
                {
                    if (polygon_set->hundred_data_group_array[3] != NULL)
                    {
                        polygon_set->hundred_data_group_array[3] = ff7_model_data[blink_data->model_id].mouth_tex;
                        polygon_set->per_group_hundreds = 1;
                    }
                }
                blink_left_eye_mode = blink_data->blink_left_eye_mode;
                for ( i = 0; i < (signed int)polygon_set->numgroups && !polygon_set->hundred_data[i].texture_set; ++i );
                if ( i == polygon_set->numgroups )return 0;
                if ( blink_left_eye_mode == 1 )
                {
                    if (ff7_advanced_blinking && ff7_model_data[blink_data->model_id].left_eye_tex) polygon_set->hundred_data_group_array[1] = ff7_model_data[blink_data->model_id].left_eye_tex;
                    ff7_externals.field_sub_6A2782(i, &polygon_set->hundred_data[i], polygon_set);
                }
                else
                {
                    if ( blink_left_eye_mode != 2 )
                    {
                        if (ff7_advanced_blinking && !ff7_model_data[blink_data->model_id].has_mouth) polygon_set->per_group_hundreds = 0;
                        return 0;
                    }
                    polygon_set->per_group_hundreds = 1;
                    if ( !field_anim_data->static_left_eye_tex )
                    goto LABEL_22;
                    ff7_externals.field_sub_6A2782(i, (p_hundred *)field_anim_data->static_left_eye_tex, polygon_set);
                }
                blink_right_eye_mode = blink_data->blink_right_eye_mode;
                if ( ++i == polygon_set->numgroups ) return 0;
                if ( blink_right_eye_mode == 1 )
                {
                    if (ff7_advanced_blinking && ff7_model_data[blink_data->model_id].right_eye_tex) polygon_set->hundred_data_group_array[2] = ff7_model_data[blink_data->model_id].right_eye_tex;
                    ff7_externals.field_sub_6A2782(i, &polygon_set->hundred_data[i], polygon_set);
                    return 1;
                }
                if ( blink_right_eye_mode != 2 )
                {
                    if (ff7_advanced_blinking && !ff7_model_data[blink_data->model_id].has_mouth) polygon_set->per_group_hundreds = 0;
                    return 0;
                }
                polygon_set->per_group_hundreds = 1;
                if ( field_anim_data->static_right_eye_tex )
                {
                    ff7_externals.field_sub_6A2782(i, (p_hundred *)field_anim_data->static_right_eye_tex, polygon_set);
                    return 1;
                }
            LABEL_22:
                ff7_externals.field_sub_6A2782(i, &polygon_set->hundred_data[i], polygon_set);
                return 0;
            }
        }

        return 0;
    }

    int ff7_field_blink_eye_sub_649B50(field_animation_data *field_anim_data, field_model_blink_data *blink_data)
    {
        int ret = 0;

        // Custom eyes + mouth fetching
        byte curr_entity_id = *ff7_externals.current_entity_id;
        byte curr_model_id = blink_data->model_id;
        byte curr_eye_index = MAXBYTE;
        static char curr_model_name[10]{0};
        bool is_npc = false;

        if (ff7_advanced_blinking && curr_model_id != MAXBYTE)
        {
            byte left_eye_index = blink_data->blink_left_eye_mode;
            byte right_eye_index = blink_data->blink_right_eye_mode;
            byte mouth_index = ff7_model_data[curr_model_id].current_mouth_idx;
            curr_eye_index = field_anim_data->eye_texture_idx;

            _splitpath((const char*)(*ff7_externals.field_models_data + (10380 * curr_model_id) + 512), NULL, NULL, curr_model_name, NULL);

            if (trace_all || trace_opcodes) ffnx_trace("field_blink_eye_sub: curr_entity_id=%u,curr_model_id=%u,curr_eye_index=%u,curr_mouth_index=%u,curr_model_name=%s\n", curr_entity_id, curr_model_id, curr_eye_index, mouth_index, curr_model_name);

            if (curr_eye_index < 10)
            {
                char directpath[MAX_PATH + sizeof(basedir)];
                char filename[10];
                char ext[4];
                bool ext_left_eye_found = false, ext_right_eye_found = false;

                // NPCs always default on Cloud eyes/mouth
                if (curr_eye_index == 9)
                {
                    curr_eye_index = 0;
                    is_npc = true;
                }

                if (ff7_externals.field_models_eye_blink_buffer[curr_eye_index].has_eyes)
                {
                    // LEFT EYE
                    _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_left_eye_filename, NULL, NULL, filename, ext);

                    _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/eye_%s_%d.TEX", basedir, direct_mode_path.c_str(), curr_model_name, left_eye_index);
                    if (ext_left_eye_found = fileExists(directpath))
                        _snprintf(ff7_model_data[curr_model_id].left_eye_tex_filename, 1024, "eye_%s_%d%s", curr_model_name, left_eye_index, ext);
                    else
                    {
                        if (left_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom left eye texture not found: %s\n", directpath);

                        // If it is an NPC use the generic NPC name instead of Cloud
                        if (is_npc) _snprintf(filename, sizeof(filename), "npc_eye2");

                        _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/%s_%d.TEX", basedir, direct_mode_path.c_str(), filename, left_eye_index);
                        if (ext_left_eye_found = fileExists(directpath))
                            _snprintf(ff7_model_data[curr_model_id].left_eye_tex_filename, 1024, "%s_%d%s", filename, left_eye_index, ext);
                        else
                        {
                            if (left_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom left eye texture not found: %s\n", directpath);

                            // If it is an NPC, and nothing was found so far, switch back to Cloud eye
                            if (is_npc) _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_left_eye_filename, NULL, NULL, filename, ext);
                            _snprintf(ff7_model_data[curr_model_id].left_eye_tex_filename, 1024, "%s%s", filename, ext);
                        }
                    }

                    // RIGHT EYE
                    _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_right_eye_filename, NULL, NULL, filename, ext);

                    _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/eye_%sr_%d.TEX", basedir, direct_mode_path.c_str(), curr_model_name, right_eye_index);
                    if (ext_right_eye_found = fileExists(directpath))
                        _snprintf(ff7_model_data[curr_model_id].right_eye_tex_filename, 1024, "eye_%sr_%d%s", curr_model_name, right_eye_index, ext);
                    else
                    {
                        if (right_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom right eye texture not found: %s\n", directpath);

                        // If it is an NPC use the generic NPC name instead of Cloud
                        if (is_npc) _snprintf(filename, sizeof(filename), "npc_eye2r");

                        _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/%s_%d.TEX", basedir, direct_mode_path.c_str(), filename, right_eye_index);
                        if (ext_right_eye_found = fileExists(directpath))
                            _snprintf(ff7_model_data[curr_model_id].right_eye_tex_filename, 1024, "%s_%d%s", filename, right_eye_index, ext);
                        else
                        {
                            if (right_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom right eye texture not found: %s\n", directpath);

                            // If it is an NPC, and nothing was found so far, switch back to Cloud eye
                            if (is_npc) _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_right_eye_filename, NULL, NULL, filename, ext);
                            _snprintf(ff7_model_data[curr_model_id].right_eye_tex_filename, 1024, "%s%s", filename, ext);
                        }
                    }

                    // Reload TEX data in memory
                    if(field_anim_data->static_left_eye_tex) ff7_externals.field_unload_model_tex(field_anim_data->static_left_eye_tex);
                    if(field_anim_data->static_right_eye_tex) ff7_externals.field_unload_model_tex(field_anim_data->static_right_eye_tex);
                    curr_model_data.has_eyes = 1;
                    curr_model_data.static_left_eye_filename = ff7_model_data[curr_model_id].left_eye_tex_filename;
                    curr_model_data.static_right_eye_filename = ff7_model_data[curr_model_id].right_eye_tex_filename;
                    ff7_externals.field_load_model_eye_tex(&curr_model_data, field_anim_data);
                    ff7_model_data[curr_model_id].left_eye_tex = field_anim_data->static_left_eye_tex;
                    ff7_model_data[curr_model_id].right_eye_tex = field_anim_data->static_right_eye_tex;

                    // Restore original curr_eye_index
                    curr_eye_index = field_anim_data->eye_texture_idx;
                }

                // MOUTH
                char* char_name = strtok(filename, "_");

                _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/mouth_%s_%d.TEX", basedir, direct_mode_path.c_str(), curr_model_name, mouth_index);
                if (ff7_model_data[curr_model_id].has_mouth = fileExists(directpath))
                    _snprintf(ff7_model_data[curr_model_id].mouth_tex_filename, 1024, "mouth_%s_%d%s", curr_model_name, mouth_index, ext);
                else
                {
                    if (mouth_index > 0 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom mouth texture not found: %s\n", directpath);

                    // NPC only
                    if (is_npc)
                    {
                        _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/npc_mouth_%d.TEX", basedir, direct_mode_path.c_str(), mouth_index);
                        if (ff7_model_data[curr_model_id].has_mouth = fileExists(directpath))
                            _snprintf(ff7_model_data[curr_model_id].mouth_tex_filename, 1024, "npc_mouth_%d%s", mouth_index, ext);
                        else if (mouth_index > 0 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom mouth texture not found: %s\n", directpath);
                    }
                    else
                    {
                        _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/%s_mouth_%d.TEX", basedir, direct_mode_path.c_str(), filename, mouth_index);
                        if (ff7_model_data[curr_model_id].has_mouth = fileExists(directpath))
                            _snprintf(ff7_model_data[curr_model_id].mouth_tex_filename, 1024, "%s_mouth_%d%s", char_name, mouth_index, ext);
                        else if (mouth_index > 0 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom mouth texture not found: %s\n", directpath);
                    }
                }

                // Prepare mouth tex object
                if (ff7_model_data[curr_model_id].has_mouth)
                {
                    struc_3 tex_mouth_info;
                    ff7_externals.create_struc_3_info_sub_67455E(&tex_mouth_info);
                    tex_mouth_info.base_directory = (uint32_t)ff7_externals.field_unk_909288;
                    tex_mouth_info.file_context.use_lgp = 1;
                    tex_mouth_info.file_context.lgp_num = 1;
                    tex_mouth_info.file_context.name_mangler = 0;
                    ff7_model_data[curr_model_id].mouth_tex = ff7_externals.field_load_model_tex(0, 0, ff7_model_data[curr_model_id].mouth_tex_filename, &tex_mouth_info, common_externals.get_game_object());
                }
                else
                {
                    if (ff7_model_data[curr_model_id].mouth_tex) ff7_externals.field_unload_model_tex(ff7_model_data[curr_model_id].mouth_tex);
                    ff7_model_data[curr_model_id].mouth_tex = NULL;
                }

                // Index is also treated as blink mode, if higher than 2 then "fake a closed eyes" in order to reload textures
                if (left_eye_index <= 2 || right_eye_index <= 2)
                {
                    blink_data->blink_left_eye_mode = left_eye_index;
                    blink_data->blink_right_eye_mode = right_eye_index;
                }
                else if (ext_left_eye_found || ext_right_eye_found)
                {
                    blink_data->blink_left_eye_mode = 2;
                    blink_data->blink_right_eye_mode = 2;
                }
                blink_data->model_id = curr_model_id;
            }
        }

        // Original code
        ret = ff7_internal_blink_eye(field_anim_data, blink_data);

        // 60FPS patch: wait time and blink time
        if(ff7_fps_limiter == FPS_LIMITER_60FPS)
        {
            if(blink_data->blink_left_eye_mode == 2 && blink_data->blink_right_eye_mode == 2)
            {
                auto &field_event_data = (*ff7_externals.field_event_data_ptr)[blink_data->model_id];
                if(external_model_data[blink_data->model_id].blinkFrameIndex > 0)
                {
                    field_event_data.blink_wait_frames = 0;
                    external_model_data[blink_data->model_id].blinkFrameIndex--;
                }
                else
                {
                    field_event_data.blink_wait_frames = 64 * common_frame_multiplier + getRandomInt(0, 32 * common_frame_multiplier);
                    external_model_data[blink_data->model_id].blinkFrameIndex = BLINKING_FRAMES;
                }
            }
        }

        return ret;
    }

    void ff7_field_update_model_animation_frame(short model_id)
    {
        field_event_data &model_event_data = (*ff7_externals.field_event_data_ptr)[model_id];
        const int original_animation_speed = model_event_data.animation_speed;
        if (is_overlapping_movie_playing())
        {
            if(movie_fps_ratio == 1 && ff7_fps_limiter == FPS_LIMITER_60FPS)
                model_event_data.animation_speed *= common_frame_multiplier;
            else if(movie_fps_ratio > 1 && ff7_fps_limiter < FPS_LIMITER_60FPS)
                model_event_data.animation_speed /= movie_fps_ratio;
            else if(movie_fps_ratio > 2 && ff7_fps_limiter == FPS_LIMITER_60FPS)
                model_event_data.animation_speed /= (movie_fps_ratio / 2);
        }

        ff7_externals.field_update_model_animation_frame(model_id);

        model_event_data.animation_speed = original_animation_speed;
    }

    int ff7_field_models_eye_to_model(char* model_name)
    {
        // Cloud
        if ( !_strcmpi(model_name, "AAAA") )
            return 0;
        if ( !_strcmpi(model_name, "AFIE") )
            return 0;
        if ( !_strcmpi(model_name, "BHFF") )
            return 0;
        if ( !_strcmpi(model_name, "BUGE") )
            return 0;
        if ( !_strcmpi(model_name, "DLFB") )
            return 0;
        if ( !_strcmpi(model_name, "EIHD") )
            return 0;
        if ( !_strcmpi(model_name, "EKBF") )
            return 0;
        if ( !_strcmpi(model_name, "ENAB") )
            return 0;
        if ( !_strcmpi(model_name, "HTJE") )
            return 0;

        // Tifa
        if ( !_strcmpi(model_name, "AAGB") )
            return 1;
        if ( !_strcmpi(model_name, "AXJA") )
            return 1;
        if ( !_strcmpi(model_name, "EQIB") )
            return 1;
        if ( !_strcmpi(model_name, "BIDB") )
            return 1;
        if ( !_strcmpi(model_name, "AGGB") )
            return 1;
        if ( !_strcmpi(model_name, "BUAC") )
            return 1;

        // Aerith
        if ( !_strcmpi(model_name, "AUFF") )
            return 2;
        if ( !_strcmpi(model_name, "CAHC") )
            return 2;
        if ( !_strcmpi(model_name, "AZBB") )
            return 2;
        if ( !_strcmpi(model_name, "CQGA") )
            return 2;
        if ( !_strcmpi(model_name, "DIFF") )
            return 2;
        if ( !_strcmpi(model_name, "CPJF") ) // Ifalna - shares the same eyes
            return 2;

        // Barret
        if ( !_strcmpi(model_name, "ACGD") )
            return 3;
        if ( !_strcmpi(model_name, "FQCB") )
            return 3;
        if ( !_strcmpi(model_name, "AYFB") )
            return 3;
        if ( !_strcmpi(model_name, "AIBA") )
            return 3;

        // Red XIII
        if ( !_strcmpi(model_name, "ADDA") )
            return 4;
        if ( !_strcmpi(model_name, "HVJF") )
            return 4;

        // Cid
        if ( !_strcmpi(model_name, "ABDA") )
            return 5;
        if ( !_strcmpi(model_name, "AIHB") )
            return 5;

        // Vincent
        if ( !_strcmpi(model_name, "AEHD") )
            return 6;
        if ( !_strcmpi(model_name, "BIJD") )
            return 6;

        // Yuffie
        if ( !_strcmpi(model_name, "ABJB") )
            return 7;
        if ( !_strcmpi(model_name, "FEEA") )
            return 7;
        if ( !_strcmpi(model_name, "AHDF") )
            return 7;

        // Cait Sith
        if ( !_strcmpi(model_name, "AEBC") )
            return 8;

        return 9; // Defaults to Cloud eye
    }
}
````

## File: src/ff7/field/model.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "ff7.h"

#include <array>

namespace ff7::field
{
    struct external_field_model_data
    {
        int moveFrameIndex;
        vector3<int> initialPosition;
        vector3<int> finalPosition;
        int wasNotCollidingWithTarget;
        int updateMovementReturnValue;
        int prevCollisionRadius;

        int rotationMoveFrameIndex;

        int blinkFrameIndex;
    };

    constexpr int MAX_FIELD_MODELS = 32;
    constexpr int BLINKING_FRAMES = 4;

    std::array<external_field_model_data, MAX_FIELD_MODELS> external_model_data;
    ff7_model_eye_texture_data curr_model_data;
    ff7_model_custom_data ff7_model_data[FF7_MAX_NUM_MODEL_ENTITIES];

    bool ff7_field_do_draw_3d_model(short x, short y);
    void ff7_field_update_models_position(int key_input_status);
    int ff7_field_update_player_model_position(short model_id);
    int ff7_field_update_single_model_position(short model_id);
    int ff7_field_check_collision_with_target(field_event_data* field_event_model, short target_collision_radius);
    void ff7_field_update_models_rotation_new();
    int ff7_field_blink_eye_sub_649B50(field_animation_data *field_anim_data, field_model_blink_data *blink_data);
    void ff7_field_handle_blink_reset();
    void ff7_field_update_model_animation_frame(short model_id);
    int ff7_field_models_eye_to_model(char* model_name);
}
````

## File: src/ff7/field/opcode.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../../log.h"
#include "../../globals.h"
#include "../../ff7.h"
#include "../../field.h"
#include "opcode.h"
#include "utils.h"

#include <set>

namespace ff7::field
{
    std::set<field_bank_address> field_bank_address_to_be_fixed = {{14, 6}};
    field_bank_address mvief_bank_address;

    int call_original_opcode_function(byte opcode)
    {
        if(original_opcode_table[opcode])
            return ((int(*)())original_opcode_table[opcode])();
        else
        {
            ffnx_error("Initialization error: original opcode table empty in position %d\n", opcode);
            return 0;
        }
    }

    short ff7_opcode_multiply_get_bank_value(short bank, short address)
    {
        int16_t ret = ff7_externals.get_bank_value(bank, address);
        if(is_fps_running_more_than_original())
            ret *= get_frame_multiplier();
        return ret;
    }

    short ff7_opcode_divide_get_bank_value(short bank, short address)
    {
        int16_t ret = ff7_externals.get_bank_value(bank, address);
        if(is_fps_running_more_than_original())
        {
            if(abs(ret) >= get_frame_multiplier())
                ret /= get_frame_multiplier();
        }
        return ret;
    }

    int opcode_script_partial_animation_wrapper()
    {
        field_event_data* event_data = *ff7_externals.field_event_data_ptr;
        field_animation_data* animation_data = *ff7_externals.field_animation_data_ptr;
        WORD total_number_of_frames = -1;
        int frame_multiplier = get_frame_multiplier();

        byte curr_opcode = get_field_parameter<byte>(-1);
        byte curr_model_id = ff7_externals.field_model_id_array[*ff7_externals.current_entity_id];
        byte previous_animation_id = event_data[curr_model_id].animation_id;
        byte speed = get_field_parameter<byte>(3);
        short previous_current_frame = event_data[curr_model_id].currentFrame;
        short first_frame = 16 * get_field_parameter<byte>(1) * frame_multiplier / ((curr_opcode == CANIM1 || curr_opcode == CANIM2) ? speed : 1);
        short last_frame = (get_field_parameter<byte>(2) * frame_multiplier + 1) / speed;
        char animation_type = ff7_externals.animation_type_array[curr_model_id];

        int ret = call_original_opcode_function(curr_opcode);

        if(curr_model_id != 255)
        {
            switch(animation_type)
            {
            case 0:
            case 1:
            case 3:
                if(animation_data)
                    total_number_of_frames = animation_data[curr_model_id].anim_frame_object->number_of_frames - 1;

                if(last_frame > total_number_of_frames)
                    last_frame = total_number_of_frames;

                // Since last frame is increased by 1, there might be cases where first frame is greater than previous current frame
                if(previous_animation_id == event_data[curr_model_id].animation_id && previous_current_frame == first_frame + event_data[curr_model_id].animation_speed)
                    first_frame = previous_current_frame;

                event_data[curr_model_id].currentFrame = first_frame;
                event_data[curr_model_id].lastFrame = last_frame;
                break;
            default:
                break;
            }
        }

        return ret;
    }

    int opcode_script_SHAKE()
    {
        byte type = get_field_parameter<byte>(2);
        auto *field_global_data_ptr = *ff7_externals.field_global_object_ptr;
        if ( (type & 1) != 0 )
        {
            field_global_data_ptr->shake_bg_x.do_shake = 1;
            field_global_data_ptr->shake_bg_x.shake_amplitude = ff7_externals.get_char_bank_value(1, 4);
            field_global_data_ptr->shake_bg_x.shake_n_steps = ff7_externals.get_char_bank_value(2, 5);

            if(is_fps_running_more_than_original())
                field_global_data_ptr->shake_bg_x.shake_n_steps *= get_frame_multiplier();
        }
        else
        {
            field_global_data_ptr->shake_bg_x.do_shake = 0;
        }
        if ( (type & 2) != 0 )
        {
            field_global_data_ptr->shake_bg_y.do_shake = 1;
            field_global_data_ptr->shake_bg_y.shake_amplitude = ff7_externals.get_char_bank_value(3, 6);
            field_global_data_ptr->shake_bg_y.shake_n_steps = ff7_externals.get_char_bank_value(4, 7);

            if(is_fps_running_more_than_original())
                field_global_data_ptr->shake_bg_y.shake_n_steps *= get_frame_multiplier();
        }
        else
        {
            field_global_data_ptr->shake_bg_y.do_shake = 0;
        }
        ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] += 8;
        return 0;
    }

    int opcode_script_WAIT()
    {
        int result = 0;

        WORD frames_left = ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id];
        if (frames_left)
        {
            if (frames_left == 1)
            {
                ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id] = 0;
                ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] += 3;
                result = 0;
            }
            else
            {
                --ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id];
                result = 1;
            }
        }
        else
        {
            ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id] = get_field_parameter<WORD>(0);

            if(is_fps_running_more_than_original())
                ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id] *= get_frame_multiplier();

            if (!ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id])
                ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] += 3;
            result = 1;
        }

        return result;
    }

    int opcode_script_MVIEF()
    {
        mvief_bank_address = {get_field_parameter<byte>(0), get_field_parameter<byte>(1)};

        return call_original_opcode_function(MVIEF);
    }

    int opcode_script_BGMOVIE()
    {
        is_movie_bgfield = get_field_parameter<byte>(0);

        return call_original_opcode_function(BGMOVIE);
    }

    uint8_t opcode_IFSW_compare_sub()
    {
        int16_t left_value = ff7_externals.get_bank_value(1, 2);
        int16_t right_value = ff7_externals.get_bank_value(2, 4);
        byte compare_type = get_field_parameter<byte>(5);

        field_bank_address current_mvief_bank_address = {get_field_bank_value(0), (byte)get_field_parameter<WORD>(1)};

        // Movie fix
        if (is_overlapping_movie_playing() && movie_fps_ratio > 1)
        {
            if (current_mvief_bank_address == mvief_bank_address)
                right_value *= movie_fps_ratio;
        }
        else
        {
            if(ff7_fps_limiter == FPS_LIMITER_60FPS)
            {
                if(field_bank_address_to_be_fixed.contains(current_mvief_bank_address))
                    right_value *= common_frame_multiplier;
            }
        }

        switch(compare_type)
        {
        case 0:
            return (left_value == right_value);
        case 1:
            return (left_value != right_value);
        case 2:
            return (left_value > right_value);
        case 3:
            return (left_value < right_value);
        case 4:
            return (left_value >= right_value);
        case 5:
            return (left_value <= right_value);
        case 6:
            return (right_value & left_value);
        case 7:
            return (right_value ^ left_value);
        case 8:
            return (right_value | left_value);
        case 9:
            return ((1 << right_value) & left_value);
        case 10:
            return ((uint8_t)((1 << right_value) & left_value) == 0);
        default:
            return 0;
        }
    }

    int opcode_script_FADE()
    {
        int ret = ((int(*)())ff7_externals.opcode_fade)();

        if(is_fps_running_more_than_original())
        {
            if((*ff7_externals.field_global_object_ptr)->fade_speed >= get_frame_multiplier())
                (*ff7_externals.field_global_object_ptr)->fade_speed /= get_frame_multiplier();
        }

        return ret;
    }

    int opcode_script_IFKEY()
    {
        uint16_t key = get_field_parameter<uint16_t>(0);
        bool emulate_run = (key & 0x40) == 0x40 && gamepad_analogue_intent == INTENT_RUN;

        if (emulate_run)
        {
            ff7_externals.modules_global_object->current_key_input_status |= 0x40;
            ff7_externals.modules_global_object->field_78 |= 0x40;
        }

        int ret = call_original_opcode_function(IFKEY);

        if (emulate_run)
        {
            ff7_externals.modules_global_object->current_key_input_status &= ~0x40;
            ff7_externals.modules_global_object->field_78 &= ~0x40;
        }

        return ret;
    }
}
````

## File: src/ff7/field/opcode.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <array>
#include <windows.h>

namespace ff7::field
{
    struct field_bank_address
    {
        byte bank;
        byte address;

        uint32_t getID() const
        {
            return bank * 256 + address;
        }

        bool operator< (const field_bank_address& f) const
        {
            return this->getID() < f.getID();
        }

        bool operator== (const field_bank_address& f) const
        {
            return this->getID() == f.getID();
        }
    };

    std::array<uint32_t, 256> original_opcode_table {0};

    short ff7_opcode_multiply_get_bank_value(short bank, short address);
    short ff7_opcode_divide_get_bank_value(short bank, short address);
    int opcode_script_partial_animation_wrapper();
    int opcode_script_SHAKE();
    int opcode_script_WAIT();
    int opcode_script_MVIEF();
    int opcode_script_BGMOVIE();
    uint8_t opcode_IFSW_compare_sub();
    int opcode_script_FADE();
    int opcode_script_IFKEY();

    // Thanks for myst6re https://github.com/myst6re/makoureactor/blob/5231723307901043941356ad1e42d26725305edf/core/field/Opcode.h#L71
    enum FieldOpcode {
        RET=0, REQ, REQSW, REQEW,
        PREQ, PRQSW, PRQEW, RETTO,
        JOIN, SPLIT, SPTYE, GTPYE,
        Unknown1, Unknown2, DSKCG, SPECIAL,

        JMPF, JMPFL, JMPB, JMPBL,
        IFUB, IFUBL, IFSW, IFSWL,
        IFUW, IFUWL, Unknown3, Unknown4,
        Unknown5, Unknown6, Unknown7, Unknown8,

        MINIGAME, TUTOR, BTMD2, BTRLD,
        WAIT, NFADE, BLINK, BGMOVIE,
        KAWAI, KAWIW, PMOVA, SLIP,
        BGPDH, BGSCR, WCLS, WSIZW,

        IFKEY, IFKEYON, IFKEYOFF, UC,
        PDIRA, PTURA, WSPCL, WNUMB,
        STTIM, GOLDu, GOLDd, CHGLD,
        HMPMAX1, HMPMAX2, MHMMX, HMPMAX3,

        MESSAGE, MPARA, MPRA2, MPNAM,
        Unknown9, MPu, Unknown10, MPd,
        ASK, MENU, MENU2, BTLTB,
        Unknown11, HPu, Unknown12, HPd,

        WINDOW, WMOVE, WMODE, WREST,
        WCLSE, WROW, GWCOL, SWCOL,
        STITM, DLITM, CKITM, SMTRA,
        DMTRA, CMTRA, SHAKE, NOP,

        MAPJUMP, SCRLO, SCRLC, SCRLA,
        SCR2D, SCRCC, SCR2DC, SCRLW,
        SCR2DL, MPDSP, VWOFT, FADE,
        FADEW, IDLCK, LSTMP, SCRLP,

        BATTLE, BTLON, BTLMD, PGTDR,
        GETPC, PXYZI, PLUSX, PLUS2X,
        MINUSX, MINUS2X, INCX, INC2X,
        DECX, DEC2X, TLKON, RDMSD,

        SETBYTE, SETWORD, BITON, BITOFF,
        BITXOR, PLUS, PLUS2, MINUS,
        MINUS2, MUL, MUL2, DIV,
        DIV2, MOD, MOD2, AND,

        AND2, OR, OR2, XOR,
        XOR2, INC, INC2, DEC,
        DEC2, RANDOM, LBYTE, HBYTE,
        TOBYTE, SETX, GETX, SEARCHX,

        PC, CHAR, DFANM, ANIME1,
        VISI, XYZI, XYI, XYZ,
        MOVE, CMOVE, MOVA, TURA,
        ANIMW, FMOVE, ANIME2, ANIMX1,

        CANIM1, CANMX1, MSPED, DIR,
        TURNGEN, TURN, DIRA, GETDIR,
        GETAXY, GETAI, ANIMX2, CANIM2,
        CANMX2, ASPED, Unknown13, CC,

        JUMP, AXYZI, LADER, OFST,
        OFSTW, TALKR, SLIDR, SOLID,
        PRTYP, PRTYM, PRTYE, IFPRTYQ,
        IFMEMBQ, MMBud, MMBLK, MMBUK,

        LINE, LINON, MPJPO, SLINE,
        SIN, COS, TLKR2, SLDR2,
        PMJMP, PMJMP2, AKAO2, FCFIX,
        CCANM, ANIMB, TURNW, MPPAL,

        BGON, BGOFF, BGROL, BGROL2,
        BGCLR, STPAL, LDPAL, CPPAL,
        RTPAL, ADPAL, MPPAL2, STPLS,
        LDPLS, CPPAL2, RTPAL2, ADPAL2,

        MUSIC, SOUND, AKAO, MUSVT,
        MUSVM, MULCK, BMUSC, CHMPH,
        PMVIE, MOVIE, MVIEF, MVCAM,
        FMUSC, CMUSC, CHMST, GAMEOVER,
        OPCODE_COUNT
    };
}
````

## File: src/ff7/field/utils.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "../../movies.h"
#include "../../cfg.h"
#include "../../globals.h"
#include "../widescreen.h"

namespace ff7::field
{
    inline bool is_fps_running_more_than_original()
    {
        if(is_overlapping_movie_playing())
            return movie_fps_ratio > 1;
        else
            return ff7_fps_limiter == FPS_LIMITER_60FPS;
    }

    inline int get_frame_multiplier()
    {
        if(is_overlapping_movie_playing())
            return movie_fps_ratio;
        else
            return common_frame_multiplier;
    }

    inline bool is_fieldmap_wide()
    {
        return widescreen_enabled && widescreen.getMode() != WM_DISABLED;
    }

    inline bool is_fieldmap_uncropped()
    {
        return enable_uncrop && widescreen.getMode() != WM_DISABLED;
    }

    inline float field_get_linear_interpolated_value_float(float initial_value, float final_value, int n_steps, int step_idx)
    {
        return std::lerp(initial_value, final_value, step_idx / (float)n_steps);
    }

    inline float field_get_smooth_interpolated_value_float(float initial_value, float final_value, int n_steps, int step_idx)
    {
        float delta = final_value - initial_value;
        return initial_value + delta * (0.5f + sin(-M_PI/2.f + M_PI * (step_idx / (float)n_steps)) / 2.f);
    }

    inline int engine_apply_matrix_product_float_66307D(vector3<float> *input_vector, vector2<float> *output_vector, int *dummy1, int *dummy2)
    {
        int ret;
        float matrix[16];
        vector3<float> output_temp, vector_temp;
        vector3<float> input_vector_copy = *input_vector;
        ff7_game_engine_data* global_game_data = *ff7_externals.global_game_engine_data;

        ff7_externals.engine_convert_psx_matrix_to_float_matrix_row_version_661465(&global_game_data->rot_matrix, matrix);
        ff7_externals.engine_apply_matrix_product_to_vector_66CF7E(matrix, &input_vector_copy, &output_temp);
        vector_temp.x = (double)global_game_data->rot_matrix.position[0] + output_temp.x;
        vector_temp.y = (double)global_game_data->rot_matrix.position[1] + output_temp.y;
        vector_temp.z = (double)global_game_data->rot_matrix.position[2] + output_temp.z;
        if (vector_temp.z == 0.f)
        {
            ret = 0;
        }
        else
        {
            output_vector->x = vector_temp.x * global_game_data->scale / vector_temp.z + global_game_data->float_delta_x;
            output_vector->y = vector_temp.y * global_game_data->scale / vector_temp.z + global_game_data->float_delta_y;
            ret = (vector_temp.z * 0.25f);
        }
        *dummy1 = 0;
        *dummy2 = 0;
        return ret;
    }

    inline int field_apply_2D_translation_float_64314F(vector3<float> *input_vector, vector2<float> *output_vector)
    {
        int dummy_1, dummy_2;
        int ret;

        ff7_externals.engine_set_game_engine_rot_matrix_663673(ff7_externals.field_camera_rotation_matrix_CFF3D8);
        ff7_externals.engine_set_game_engine_position_663707(ff7_externals.field_camera_rotation_matrix_CFF3D8);
        ff7_externals.engine_set_game_engine_delta_values_661976(ff7_externals.field_viewport_xy_CFF204->x, ff7_externals.field_viewport_xy_CFF204->y);
        ret = engine_apply_matrix_product_float_66307D(input_vector, output_vector, &dummy_1, &dummy_2);
        ff7_externals.engine_set_game_engine_delta_values_661976(ff7_externals.field_max_half_viewport_width_height_CFF1F4->x, ff7_externals.field_max_half_viewport_width_height_CFF1F4->y);
        return ret;
    }
}
````

## File: src/ff7/world/camera.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2022 Cosmos                                             //
//    Copyright (C) 2022 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../../globals.h"
#include "camera.h"
#include "world.h"
#include "utils.h"
#include "defs.h"

namespace ff7::world
{
    WorldCamera camera;

    void update_world_camera_front(int current_key_input, int prev_key_input)
    {
        const int player_model_id = ff7_externals.world_get_player_model_id();
        int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
        int world_map_type = *ff7_externals.world_map_type_E045E8;
        int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;

        if (world_map_type == SNOWSTORM)
        {
            auto flag = current_key_input & ANY_DIRECTIONAL_KEY;
            int delta_camera_step = ff7_externals.world_snowstorm_get_camera_movement_758B12(flag,
                                    !((current_key_input & CIRCLE) == 0 || (prev_key_input & CIRCLE) != 0));
            *ff7_externals.world_camera_front_DFC484 += delta_camera_step;
        }
        else
        {

            auto rotationSpeed = camera.getRotationSpeed();

            int current_key_input = ff7_externals.world_get_current_key_input_status();
            float playerDeltaMovement = static_cast<float>(*ff7_externals.world_special_delta_movement_DE6A18);
            int movement_speed = get_player_movement_speed(player_model_id);
            float speedCoeff = std::abs(playerDeltaMovement) / (movement_speed);

            if (camera_view_type == HIGHWIND_VIEW || world_map_type == UNDERWATER || player_model_id == TINY_BRONCO || player_model_id == BUGGY || player_model_id == SUBMARINE)
                rotationSpeed.y = rotationSpeed.y + rotationSpeed.y * speedCoeff;

            camera.localTargetRotation.x = std::min(std::max(camera.localTargetRotation.x - rotationSpeed.x, -175.0f), -95.0f);
            camera.localTargetRotation.y = std::remainder(camera.localTargetRotation.y - rotationSpeed.y, 360.0f);

            auto last_valid_player_direction = (*ff7_externals.world_event_current_entity_ptr_E39AD8)->direction;
            if(last_valid_player_direction > 2048)
                last_valid_player_direction -= 4096;
            if(last_valid_player_direction < -2048)
                last_valid_player_direction += 4096;
            float player_direction = 360.0f * static_cast<float>(4096 - last_valid_player_direction - 2048) / 4096;
            auto joyDir = ff7::world::world.GetJoystickDirection();
            if (camera_view_type == HIGHWIND_VIEW || world_map_type == UNDERWATER || player_model_id == TINY_BRONCO || player_model_id == BUGGY || player_model_id == SUBMARINE)
            {
                if(camera.isResetCameraRotationRequested())
                {
                    camera.localTargetRotation.y = player_direction;
                    ff7::world::camera.requestResetCameraRotation(false);
                }
                else
                {
                    float t = 0.02 * movement_multiplier;

                    bool isMovementButtonPressed = is_key_pressed(current_key_input, CIRCLE | R1 | SQUARE | L1 );

                    if (abs(joyDir.x) == 0.0f && !isMovementButtonPressed) t = 0.0f;

                    if (player_model_id == BUGGY) t *= speedCoeff;
                    else t *= isMovementButtonPressed ? std::max(0.1f, speedCoeff) : abs(joyDir.x);

                    float diff = player_direction - camera.localTargetRotation.y;
                    if (diff > 180) camera.localTargetRotation.y += 360;
                    else if (diff < - 180)  camera.localTargetRotation.y -= 360;
                    camera.localTargetRotation.y = (1.0f - t) * camera.localTargetRotation.y + t * player_direction;
                }
                camera.targetRotation.y = camera.localTargetRotation.y;
                camera.targetRotation.x = camera.localTargetRotation.x;
            }
            else
            {
                if (camera.isResetCameraRotationRequested())
                {
                    camera.targetRotation.x = camera.localTargetRotation.x;
                    camera.localTargetRotation.y = player_direction;
                    camera.targetRotation.y = player_direction;
                    ff7::world::camera.requestResetCameraRotation(false);
                }
                else
                {
                    camera.targetRotation.x = camera.localTargetRotation.x;
                    camera.targetRotation.y = camera.localTargetRotation.y;
                }
            }

            *ff7_externals.world_camera_front_DFC484 = camera.targetRotation.y * 4096 / 360.0f;
        }
    }

    void update_world_camera_rotation_y()
    {
        int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
        int world_map_type = *ff7_externals.world_map_type_E045E8;
        int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;
        if (world_map_type != SNOWSTORM)
        {
            float targetRotationY = *ff7_externals.world_camera_front_DFC484 * 360.0f / 4096.0f;

            int world_map_type = *ff7_externals.world_map_type_E045E8;

            float diff = targetRotationY - camera.rotationOffset.y;
            if (diff > 180)
                camera.rotationOffset.y += 360;
            else if (diff < - 180)  camera.rotationOffset.y -= 360;

            const float t = 0.05f * movement_multiplier;
            camera.rotationOffset.y = (1.0f - t) * camera.rotationOffset.y + t * targetRotationY;

            *ff7_externals.world_camera_rotation_y_DFC474 = camera.rotationOffset.y * 4096.0f / 360.0f;
        }
        else
        {
            int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;
            int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;

            if (camera_view_type != HIGHWIND_VIEW)
                *ff7_externals.world_camera_var2_DE6B4C = (*ff7_externals.world_camera_var1_DF542C + 3 * (*ff7_externals.world_camera_var2_DE6B4C)) >> 2;

            if (*ff7_externals.world_camera_rotation_y_DFC474 >= *ff7_externals.world_camera_front_DFC484 - 2048)
            {
                if (*ff7_externals.world_camera_rotation_y_DFC474 > *ff7_externals.world_camera_front_DFC484 + 2048)
                    *ff7_externals.world_camera_rotation_y_DFC474 -= 4096;
            }
            else
                *ff7_externals.world_camera_rotation_y_DFC474 += 4096;

            if (movement_multiplier == 1)
                *ff7_externals.world_camera_rotation_y_DFC474 = (*ff7_externals.world_camera_front_DFC484 + 31 * (*ff7_externals.world_camera_rotation_y_DFC474)) >> 5;
            else
                *ff7_externals.world_camera_rotation_y_DFC474 = (*ff7_externals.world_camera_front_DFC484 + 15 * (*ff7_externals.world_camera_rotation_y_DFC474)) >> 4;
        }
    }

    void update_world_camera(short world_camera_rotation_y)
    {
        int world_map_type = *ff7_externals.world_map_type_E045E8;
        int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
        float targetRotationX = -ff7_externals.world_get_camera_rotation_x_74F916() * 360.0f / 4096.0f;
        //ff7_externals.world_get_camera_rotation_x_74F916();

        static float zoomTarget = 10000.0f;
        static int cameraStatusCounter = 0;
        float maxZoomDist = camera.getMaxZoomDist();

        if(world_map_type != SNOWSTORM && ff7_externals.world_get_unknown_flag_75335C())
        {
            targetRotationX = camera.targetRotation.x;
            zoomTarget = std::min(maxZoomDist, std::max(camera.minZoomDist, zoomTarget - camera.getZoomSpeed()));
            cameraStatusCounter = 0;
        } else
        {
            if (cameraStatusCounter > 0) zoomTarget = 10000.0f;
            cameraStatusCounter++;
        }

        const float t = 0.05f * movement_multiplier;
        camera.rotationOffset.x = (1.0f - t) * camera.rotationOffset.x + t * targetRotationX;

        bx::Vec3 up = { 0, 1, 0 };
        bx::Vec3 right = { 1, 0, 0 };

        float rotationY = 360.0f * static_cast<float>(*ff7_externals.world_camera_rotation_y_DFC474) / 4096.0f;
        auto quaternionH = bx::fromAxisAngle(up, M_PI * rotationY / 180.0f);
        auto quaternionV = bx::fromAxisAngle(right, M_PI * camera.rotationOffset.x / 180.0f);

        *ff7_externals.world_current_camera_rotation_x_DE7418 = 4096 + static_cast<short>(4096.0f * camera.rotationOffset.x / 360.0f);

        auto quaternion = bx::mul(quaternionV, quaternionH);
        quaternion = bx::normalize(quaternion);

        float rotMat[16];
        bx::mtxFromQuaternion(rotMat, quaternion);


        camera.zoomOffset = (1.0f - t) * camera.zoomOffset + t * zoomTarget;

        camera.zoomOffset = std::min(maxZoomDist, std::max(camera.minZoomDist, camera.zoomOffset));

        if (world_map_type == SNOWSTORM) camera.zoomOffset = 10000.0;

        auto rot_matrix = ff7_externals.world_camera_direction_matrix_DFC448;
        rot_matrix->r3_sub_matrix[0][0] = rotMat[0] * 4096;
        rot_matrix->r3_sub_matrix[0][1] = rotMat[1] * 4096;
        rot_matrix->r3_sub_matrix[0][2] = rotMat[2] * 4096;

        rot_matrix->r3_sub_matrix[1][0] = rotMat[4] * 4096;
        rot_matrix->r3_sub_matrix[1][1] = rotMat[5] * 4096;
        rot_matrix->r3_sub_matrix[1][2] = rotMat[6] * 4096;

        rot_matrix->r3_sub_matrix[2][0] = rotMat[8] * 4096;
        rot_matrix->r3_sub_matrix[2][1] = rotMat[9] * 4096;
        rot_matrix->r3_sub_matrix[2][2] = rotMat[10] * 4096;

        auto translation_matrix = ff7_externals.world_camera_position_matrix_DE6A20;
        translation_matrix->position[0] = 0;
        translation_matrix->position[1] = 0;
        translation_matrix->position[2] = camera.zoomOffset;

        *ff7_externals.world_camera_delta_y_DE6A04 = ff7_externals.world_player_pos_E04918->y + 500;
    }

    void WorldCamera::setRotationSpeed(float rotX, float rotY, float rotZ)
    {
        rotationSpeed.x = 0.5f * rotX / common_frame_multiplier;
        rotationSpeed.y = 0.5f * rotY / common_frame_multiplier;
        rotationSpeed.z = 0.5f * rotZ / common_frame_multiplier;
    }

    void WorldCamera::setZoomSpeed(float speed)
    {
        zoomSpeed = 0.5f * speed / common_frame_multiplier;
    }

    void WorldCamera::reset()
    {
        targetRotation.x = 0.0f;
        targetRotation.y = 0.0f;
        zoomOffset = 0.0f;
    }

    float WorldCamera::getMaxZoomDist()
    {
        const int player_model_id = ff7_externals.world_get_player_model_id();
        switch(player_model_id)
        {
            case SUBMARINE:
                return 5000;
            default:
                return 35000;
        }
    }
}
````

## File: src/ff7/world/camera.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2022 Cosmos                                             //
//    Copyright (C) 2022 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/
#pragma once

#include "matrix.h"

#include <bx/math.h>
#include <bx/bx.h>

namespace ff7::world
{
    enum world_camera_viewtype
    {
        TOP_DOWN_VIEW = 0,
        FRONT_VIEW = 2,
        HIGHWIND_VIEW = 3
    };

    void update_world_camera_front(int current_key_input, int prev_key_input);
    void update_world_camera_rotation_y();

    class WorldCamera
    {
        public:
            WorldCamera() = default;
            ~WorldCamera() = default;

            void setRotationSpeed(float rotX, float rotY, float rotZ);
            vector3<float> getRotationSpeed();
            void setZoomSpeed(float speed);
            float getZoomSpeed();
            float getMaxZoomDist();
            void reset();
            float getRotationOffsetX();
            float getRotationOffsetY();
            void requestResetCameraRotation(bool value);
            bool isResetCameraRotationRequested();
        public:
            vector3<float> targetRotation = { -135.0f, 0.0, 0.0 };
            vector3<float> localTargetRotation = { -135.0f, 0.0, 0.0 };
            vector3<float> rotationOffset = { -135.0f, 0.0, 0.0 };
            float zoomOffset = 10000.0f;
            const float minZoomDist = 2000.0f;
        private:
            vector3<float> rotationSpeed = { 0.0, 0.0, 0.0 };
            float zoomSpeed = 0.0f;

            const float minVerticalAngle = 5.0f;
            const float maxVerticalAngle = 85.0f;

            bool isResetCameraRotation = false;
    };

    inline vector3<float> WorldCamera::getRotationSpeed()
    {
        return rotationSpeed;
    }

    inline float WorldCamera::getZoomSpeed()
    {
        return zoomSpeed;
    }

    inline float  WorldCamera::getRotationOffsetX()
    {
        return rotationOffset.x;
    }

    inline float  WorldCamera::getRotationOffsetY()
    {
        return rotationOffset.y;
    }

    inline void WorldCamera::requestResetCameraRotation(bool value)
    {
        isResetCameraRotation = value;
    }

    inline bool WorldCamera::isResetCameraRotationRequested()
    {
        return isResetCameraRotation;
    }

    extern WorldCamera camera;
}
````

## File: src/ff7/world/defs.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

namespace ff7::world
{
    void world_hook_init();
    void world_update_model_movement(int delta_position_x, int delta_position_z);

    void update_world_camera(short world_camera_rotation_y);
    void update_player_and_handle_input();
}
````

## File: src/ff7/world/player.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2022 Cosmos                                             //
//    Copyright (C) 2022 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "globals.h"
#include "world.h"
#include "camera.h"
#include "cfg.h"
#include "utils.h"

#include <math.h>
#include "ff7/world/defs.h"

namespace ff7::world {

    int get_player_movement_speed(int model_id)
    {
        int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
        switch(model_id)
        {
            case HIGHWIND: // Highwind
                return 120 * movement_multiplier;
            case SUBMARINE:
                return 45 * movement_multiplier;
            case WILD_CHOCOBO:
            case TINY_BRONCO:
            case CHOCOBO:
            case 41:
            case 42:
                // Chocobos and Tiny Bronco
                return 60 * movement_multiplier;
            case BUGGY: // Buggy
                return 45 * movement_multiplier;
            default:
                return 30 * movement_multiplier;
        }
    }

    short get_player_direction_on_key_input(int current_key_status)
    {
        short direction = INVALID_DIRECTION;

        auto joyDir = ff7::world::world.GetJoystickDirection();
        float inputDirLength = vector_length(&joyDir);
	    if(inputDirLength > 0.0f)
        {
            float angle = atan2( joyDir.x, - joyDir.y);
            if (angle < 0) { angle += 2 * M_PI; }
            direction = static_cast<short>(std::max(0.0, std::min(4096.0, 4096.0 * angle / (2.0* M_PI))));
        }
        else
        {
            if(is_key_pressed(current_key_status, LEFT))
                direction = -1024;
            if(is_key_pressed(current_key_status, RIGHT))
                direction = 1024;
            if(is_key_pressed(current_key_status, UP))
            {
                if(direction == INVALID_DIRECTION)
                    direction = 2048;
                else
                    direction += direction / 2;
            }
            if(is_key_pressed(current_key_status, DOWN))
            {
                if(direction == INVALID_DIRECTION)
                    direction = 0;
                else
                    direction -= direction / 2;
            }
        }

        return direction;
    }

    void update_player_and_handle_input()
    {
        static float rotationSpeedInterp = 0.0f;

        const int worldmap_type = *ff7_externals.world_map_type_E045E8;
        const int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;

        vector3<int> delta_movement = {0, 0, 0};
        ff7_externals.world_set_current_entity_to_player_entity();
        const int player_model_id = ff7_externals.world_get_player_model_id();

        if(*ff7_externals.world_is_control_enabled_DE6B5C && ff7_externals.world_get_unknown_flag_75335C())
        {
            int current_key_input = ff7_externals.world_get_current_key_input_status();
            int prev_key_input = *ff7_externals.world_prev_key_input_status_DFC470;

            // Limit key input
            if(player_model_id == TINY_BRONCO && is_key_pressed(current_key_input, CROSS))
                current_key_input &= SELECT | UNK1 | UNK2;

            int movement_speed = get_player_movement_speed(player_model_id);
            short player_direction = get_player_direction_on_key_input(current_key_input);
            if(player_direction != INVALID_DIRECTION)
            {
                delta_movement.x = cos((player_direction / 2048.f) * M_PI - M_PI / 2) * movement_speed;
                delta_movement.z = -sin((player_direction / 2048.f) * M_PI - M_PI / 2) * movement_speed;
            }

            int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;
            if(enable_analogue_controls || camera_view_type == FRONT_VIEW || camera_view_type == HIGHWIND_VIEW || worldmap_type == SNOWSTORM)
            {
                update_world_camera_front(current_key_input, prev_key_input);

                auto joyDir = ff7::world::world.GetJoystickDirection();

                static float deltaMovement = 0.0f;
                static int horizontalDeltaInterp = 0;

                bool highwind_view_and_square_pressed = camera_view_type == HIGHWIND_VIEW && is_key_pressed(current_key_input, SQUARE | L1);

                int horizontal_delta = 0;
                if(!highwind_view_and_square_pressed)
                {
                if(std::abs(joyDir.x) > 0.0f)
                    horizontal_delta = -2048 * joyDir.x;
                else if(is_key_pressed(current_key_input, LEFT))
                    horizontal_delta = 2048;
                else if(is_key_pressed(current_key_input, RIGHT))
                    horizontal_delta = -2048;
                }

                horizontalDeltaInterp = (15 * horizontalDeltaInterp + horizontal_delta) / 16;
                if(camera_view_type == HIGHWIND_VIEW || worldmap_type == UNDERWATER || player_model_id == TINY_BRONCO || player_model_id == BUGGY || player_model_id == SUBMARINE)
                {
                    bool is_movement_key_pressed = is_key_pressed(current_key_input, highwind_view_and_square_pressed ? ANY_DIRECTIONAL_KEY: CIRCLE | R1);
                    bool is_back_movement_key_pressed = is_key_pressed(current_key_input, SQUARE | L1);

                    if(is_back_movement_key_pressed && (player_model_id == BUGGY || player_model_id == SUBMARINE))
                    {
                        if(!is_movement_key_pressed)
                        {
                            movement_speed = -movement_speed * 0.75f;
                        } else movement_speed = 0;

                        is_movement_key_pressed = true;
                    }

                    if (!is_movement_key_pressed || highwind_view_and_square_pressed) movement_speed = 0;

                    deltaMovement = (deltaMovement * 31.0f + movement_speed) / 32.0f;

                    if(!is_movement_key_pressed && std::abs(deltaMovement) < 10.0f) deltaMovement = 0.0f;
                    *ff7_externals.world_special_delta_movement_DE6A18 = deltaMovement;

                    short last_valid_player_direction = (*ff7_externals.world_event_current_entity_ptr_E39AD8)->direction;
                    if(highwind_view_and_square_pressed && std::abs(deltaMovement) < 10)
                    {
                        auto hightwindSpeed = get_player_movement_speed(player_model_id);
                        if(std::abs(joyDir.x) > 0.0f)
                            delta_movement.x = joyDir.x * hightwindSpeed;
                        else if(is_key_pressed(current_key_input, LEFT))
                            delta_movement.x = -hightwindSpeed;
                        else if(is_key_pressed(current_key_input, RIGHT))
                            delta_movement.x = hightwindSpeed;

                        if(std::abs(joyDir.y) > 0.0f)
                            delta_movement.z = -joyDir.y * hightwindSpeed;
                        else if(is_key_pressed(current_key_input, UP))
                            delta_movement.z = -hightwindSpeed;
                        else if(is_key_pressed(current_key_input, DOWN))
                            delta_movement.z = hightwindSpeed;

                        delta_movement.x *= 0.25f;
                        delta_movement.z *= 0.25f;
                    }
                    else
                    {
                        const float rotSpeedXMax = worldmap_type == UNDERWATER || player_model_id == SUBMARINE ? 24.0f : player_model_id == BUGGY ? 64.0f : 32.0f;
                        float rotSpeedX = 0.0f;
                        if (std::abs(joyDir.x) > 0.0)
                            rotSpeedX = rotSpeedXMax * joyDir.x / common_frame_multiplier;
                        else if(is_key_pressed(current_key_input, LEFT))
                            rotSpeedX = -rotSpeedXMax / common_frame_multiplier;
                        else if(is_key_pressed(current_key_input, RIGHT))
                            rotSpeedX = rotSpeedXMax / common_frame_multiplier;

                        if ( player_model_id == BUGGY )
                        {
                            rotationSpeedInterp = rotSpeedX;
                        }
                        else
                        {
                            rotationSpeedInterp = (rotationSpeedInterp * 15 + rotSpeedX) / 16.0f;
                        }
                        short delta = -static_cast<short>(rotationSpeedInterp);

                        if (player_model_id == BUGGY )
                        {
                            auto maxSpeed = static_cast<float>(get_player_movement_speed(player_model_id));
                            if (is_back_movement_key_pressed) maxSpeed *= 0.5f;
                            delta *= std::abs(deltaMovement) / maxSpeed;
                        }

                        last_valid_player_direction += delta;


                        if(last_valid_player_direction > 2048)
                            last_valid_player_direction -= 4096;
                        if(last_valid_player_direction < -2048)
                            last_valid_player_direction += 4096;

                        player_direction = last_valid_player_direction + *ff7_externals.world_camera_front_DFC484 - 4096;

                        delta_movement.x = cos((player_direction / 2048.f) * M_PI - M_PI / 2) * (deltaMovement);
                        delta_movement.z = -sin((player_direction / 2048.f) * M_PI - M_PI / 2) * (deltaMovement);
                    }
                }
                else if(player_direction != INVALID_DIRECTION)
                    ff7_externals.world_set_facing_and_direction_to_current_entity(player_direction - *ff7_externals.world_camera_front_DFC484);

                // Deflect delta movement with camera front direction
                vector3<short> copy_delta_movement = {(short)delta_movement.x, 0, (short)delta_movement.z};
                vector3<short> rotation = {0, (short)-*ff7_externals.world_camera_front_DFC484, 0};
                vector3<int> output_delta = {0, 0, 0};
                int dummy;
                rotation_matrix matrix;
                ff7_externals.engine_apply_rotation_to_transform_matrix_6628DE(&rotation, &matrix);
                matrix.position[0] = 0;
                matrix.position[1] = 0;
                matrix.position[2] = 0;
                ff7_externals.engine_set_game_engine_rot_matrix_663673(&matrix);
                ff7_externals.engine_set_game_engine_position_663707(&matrix);
                ff7_externals.engine_apply_translation_with_delta_662ECC(&copy_delta_movement, &output_delta, &dummy);
                delta_movement.x = output_delta.x;
                delta_movement.z = output_delta.z;

                static float verticalDeltaInterp = 0.0;
                int vertical_delta = 0;
                static float verticalSpeedinterp = 0.0;
                float verticalSpeed = 0.0;
                if(camera_view_type == HIGHWIND_VIEW && !highwind_view_and_square_pressed)
                {
                    vector4<int> player_highwind_position;
                    ff7_externals.world_copy_player_pos_to_param_762798(&player_highwind_position);

                    auto joyDir = ff7::world::world.GetJoystickDirection();
                    if((joyDir.y > 0 || is_key_pressed(current_key_input, UP)) && player_highwind_position.y > 500 && *ff7_externals.world_y_player_pos_flag_DE6A14 &&
                       ff7_externals.world_get_player_walkmap_type() != 27)
                    {
                        if(joyDir.y > 0)
                        {
                            verticalSpeed = -joyDir.y * 50 * movement_multiplier;
                            vertical_delta = joyDir.y * 10.0;
                        }
                        else
                        {
                            verticalSpeed = -50 * movement_multiplier;
                            vertical_delta = 10;
                        }
                    }
                    else if((joyDir.y < 0 || is_key_pressed(current_key_input, DOWN)) && player_highwind_position.y < UINT16_MAX / 2 - 50 * movement_multiplier - 2000)
                    {
                        if (joyDir.y < 0)
                        {
                            verticalSpeed =-joyDir.y * 50 * movement_multiplier;
                            vertical_delta = joyDir.y * 10.0;
                        }
                        else
                        {
                            verticalSpeed = 50 * movement_multiplier;
                            vertical_delta = -10;
                        }
                    }
                    verticalSpeedinterp = (verticalSpeedinterp * 7.0f + verticalSpeed) / 8.0f;
                    ff7_externals.world_add_y_pos_to_current_entity_761F22(verticalSpeedinterp);
                }

                if(worldmap_type == UNDERWATER)
                {
                    vector4<int> player_submarine_position;
                    ff7_externals.world_copy_player_pos_to_param_762798(&player_submarine_position);

                    if((joyDir.y > 0 || is_key_pressed(current_key_input, UP)) && player_submarine_position.y > -5000 && *ff7_externals.world_y_player_pos_flag_DE6A14)
                    {
                        if (joyDir.y > 0)
                        {
                            verticalSpeed = -joyDir.y * 15 * movement_multiplier;
                            vertical_delta = joyDir.y * 10.0;
                        }
                        else
                        {
                            verticalSpeed = -15 * movement_multiplier;
                            vertical_delta = 10;
                        }
                    }

                    if((joyDir.y < 0 || is_key_pressed(current_key_input, DOWN)) && player_submarine_position.y <-1000)
                    {
                        if (joyDir.y > 0)
                        {
                            verticalSpeed = -joyDir.y * 15 * movement_multiplier;
                            vertical_delta = joyDir.y * 10.0;
                        }
                        else
                        {
                            verticalSpeed = 15 * movement_multiplier;
                            vertical_delta = -10;
                        }
                    }

                    verticalSpeedinterp = (verticalSpeedinterp * 7.0f + verticalSpeed) / 8.0f;
                    ff7_externals.world_add_y_pos_to_current_entity_761F22(verticalSpeedinterp);
                }

                verticalDeltaInterp = (verticalDeltaInterp * 15.0f + vertical_delta) / 16.0f;

                if(camera_view_type == HIGHWIND_VIEW)
                {
                    int is_player_moving = ff7_externals.world_is_current_entity_animated_761F44() &&
                                           abs(*ff7_externals.world_camera_rotation_z_DE6B70) >= 16 || horizontalDeltaInterp;
                    delta_movement.y = ((movement_multiplier == 1) | (2 * is_player_moving)) + 3;
                    *ff7_externals.world_camera_rotation_z_DE6B70 = ((1 << (delta_movement.y - 1)) + horizontalDeltaInterp
                                                                    + *ff7_externals.world_camera_rotation_z_DE6B70 * (1 << delta_movement.y - 1)) >> delta_movement.y;
                    *ff7_externals.world_unk_rotation_value_E045E0 = (verticalDeltaInterp);
                    ff7_externals.world_sub_762F75(*ff7_externals.world_unk_rotation_value_E045E0 + 4, *ff7_externals.world_camera_rotation_z_DE6B70 * 4, *ff7_externals.world_camera_rotation_z_DE6B70 * -2);
                }

                // Reset world camera rotation Z
                if(!horizontalDeltaInterp && abs(*ff7_externals.world_camera_rotation_z_DE6B70) <= 4)
                    *ff7_externals.world_camera_rotation_z_DE6B70 = 0;

                if(worldmap_type != SNOWSTORM)
                {
                    if(player_direction == INVALID_DIRECTION)
                        player_direction = *ff7_externals.previous_player_direction_DF5434;

                    if(player_direction != INVALID_DIRECTION)
                        *ff7_externals.previous_player_direction_DF5434 = player_direction;

                    player_direction += 2048;
                    if(player_direction > 2048)
                        player_direction -= 4096;

                    if(camera_view_type != HIGHWIND_VIEW && worldmap_type != UNDERWATER && player_model_id != SUBMARINE && player_model_id != TINY_BRONCO)
                    {
                        if(delta_movement.x != 0 || delta_movement.z != 0.0f)
                        {
                            int current_direction = player_direction;
                            ff7_externals.world_set_facing_and_direction_to_current_entity(current_direction + 2048 - *ff7_externals.world_camera_front_DFC484);
                        }
                    }
                    else
                    {
                        if(!highwind_view_and_square_pressed)
                        {
                            int current_direction = player_direction;
                            ff7_externals.world_set_facing_and_direction_to_current_entity(current_direction + 2048 - *ff7_externals.world_camera_front_DFC484);
                        }
                    }
                }
            }
            else
            {
                *ff7_externals.world_camera_rotation_z_DE6B70 /= 2;
                if(player_direction != INVALID_DIRECTION)
                    ff7_externals.world_set_facing_and_direction_to_current_entity(player_direction);
            }

            if(player_model_id == BUGGY) {
                if(is_key_pressed_first_time(current_key_input, prev_key_input, ANY_DIRECTIONAL_KEY))
                    ff7_externals.world_music_set_frequency_all_channels_75E6A8(8u, 32);

                if(is_key_released(current_key_input, prev_key_input, ANY_DIRECTIONAL_KEY))
                    ff7_externals.world_music_set_frequency_all_channels_75E6A8(8u, 0);
            }

            if(player_model_id == SUBMARINE && is_key_pressed_first_time(current_key_input, prev_key_input, CROSS))
            {
                if(worldmap_type == UNDERWATER && ff7_externals.world_get_player_walkmap_type() == 3)
                    ff7_externals.world_sub_74D6BB();
                else if(ff7_externals.world_get_player_walkmap_type() == 3)
                    ff7_externals.world_sub_74D6F6();
            }

            if(is_key_pressed_first_time(current_key_input, prev_key_input, START) ||
               is_key_pressed_first_time(current_key_input, prev_key_input, SELECT))
            {
                if(*ff7_externals.world_map_type_E045E8 == OVERWORLD)
                    ff7_externals.world_set_minimap_mask((ff7_externals.world_get_minimap_mask() + 1) % 3);
                else
                    ff7_externals.world_set_minimap_mask(ff7_externals.world_get_minimap_mask() == 0 ? 2 : 0);
            }

            if(is_key_pressed_first_time(current_key_input, prev_key_input, TRIANGLE) && *ff7_externals.world_mode_E045E4 == 1)
            {
                if(player_model_id == HIGHWIND)
                    ff7_externals.world_run_special_opcode_7640BC(6);
                else if((player_model_id ==  CLOUD || player_model_id ==  TIFA || player_model_id ==  CID || player_model_id == BUGGY) && ff7_externals.world_get_player_walkmap_type() != 14)
                {
                    ff7_externals.world_set_camera_fade_speed_755B97(16);
                    ff7_externals.world_set_world_control_lock_74D438(0, 1);
                    *ff7_externals.world_mode_E045E4 = 2;
                    ff7_externals.world_sub_74C980(0);
                }
            }

            *ff7_externals.world_prev_key_input_status_DFC470 = current_key_input;
            if(ff7_externals.world_get_player_walkmap_type() == 14)
                ff7_externals.world_add_delta_movement_due_to_bridge_7591C2(&delta_movement.x, &delta_movement.z);
            if(player_model_id == TINY_BRONCO)
                ff7_externals.world_sfx_play_or_stop_75E6CC((delta_movement.z | delta_movement.x) != 0 ? 493 : -493);

            if(ff7_footsteps)
                world_update_model_movement(delta_movement.x, delta_movement.z);
            else
                ff7_externals.world_update_model_movement_762E87(delta_movement.x, delta_movement.z);
            ff7_externals.world_current_entity_model_collision_detection_with_other_models_76296E();
        }

        if(!ff7_externals.world_is_control_enabled_DE6B5C && ff7_externals.world_get_player_walkmap_type() == 14)
        {
            ff7_externals.world_add_delta_movement_due_to_bridge_7591C2(&delta_movement.x, &delta_movement.z);
            world_update_model_movement(delta_movement.x, delta_movement.z);
            ff7_externals.world_current_entity_model_collision_detection_with_other_models_76296E();
        }

        update_world_camera_rotation_y();
    }

}
````

## File: src/ff7/world/renderer.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "ff7/world/renderer.h"
#include "camera.h"
#include "cfg.h"
#include "gl.h"
#include "globals.h"

#include "../defs.h"
#include "../../lighting.h"

namespace ff7::world {

    void init_load_wm_bot_blocks() {
        ff7_externals.world_init_load_wm_bot_block_7533AF();

        worldRenderer.loadWorldMapExternalMesh();
        worldRenderer.loadCloudsExternalMesh();
        worldRenderer.loadMeteorExternalMesh();
    }

    void destroy_graphics_objects() {
        ff7_externals.world_exit_destroy_graphics_objects_75A921();
        worldRenderer.unloadExternalMeshes();
    }

    void wm0_overworld_draw_all() {
       auto game_object = (struct ff7_game_obj *)common_externals.get_game_object();
        if (game_object) update_view_matrix (game_object);
        worldRenderer.drawWorldMapExternalMesh();
        ff7_externals.world_wm0_overworld_draw_all_74C179();
    }

    void wm0_overworld_draw_clouds()
    {
        worldRenderer.drawCloudsAndMeteorExternalMesh(*ff7_externals.is_meteor_flag_on_E2AAE4);
    }

    void wm0_overworld_draw_meteor()
    {
    }

    void wm2_underwater_draw_all() {
        auto game_object = (struct ff7_game_obj *)common_externals.get_game_object();
        if (game_object) update_view_matrix (game_object);
        		const int worldmap_type = *ff7_externals.world_map_type_E045E8;
		newRenderer.setFogEnabled(true);
        worldRenderer.drawWorldMapExternalMesh();
        ff7_externals.world_wm2_underwater_draw_all_74C3F0();
        newRenderer.setFogEnabled(false);
    }

    void wm3_snowstorm_draw_all() {
        auto game_object = (struct ff7_game_obj *)common_externals.get_game_object();
        if (game_object) update_view_matrix (game_object);
        worldRenderer.drawWorldMapExternalMesh();
        ff7_externals.world_wm3_snowstorm_draw_all_74C589();
    }

    // This draw call is the first UI call that marks the start of the first UI draw section
    void wm0_draw_minimap_quad_graphics_object(ff7_graphics_object* quad_graphics_object, ff7_game_obj* game_object) {
        newRenderer.setTimeFilterEnabled(false);
        ff7_externals.engine_draw_graphics_object(quad_graphics_object, game_object);
    }

    // This draw call is the first call related to world effects. It marks the end of the first UI draw section
    void wm0_draw_world_effects_1_graphics_object(ff7_graphics_object* world_effects_1_graphics_object, ff7_game_obj* game_object) {
        newRenderer.setTimeFilterEnabled(true);
        ff7_externals.engine_draw_graphics_object(world_effects_1_graphics_object, game_object);
    }

    // This draw call is the UI call that marks the second UI draw section
    void wm0_draw_minimap_points_graphics_object(ff7_graphics_object* minimap_points_graphics_object, ff7_game_obj* game_object) {
        newRenderer.setTimeFilterEnabled(false);
        ff7_externals.engine_draw_graphics_object(minimap_points_graphics_object, game_object);
    }


    int get_camera_rotation_z()
    {
        return 0;
    }

    void world_copy_position(vector4<int> *a1)
    {
        if ( a1 )
            *a1 = *ff7_externals.world_player_pos_E04918;
    }

    vector3<float> calcSphericalWorldPos(vector3<float> worldPos)
    {
        struct matrix viewMatrix;
        ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));

        vector3<float> viewPos = {0.0f, 0.0f, 0.0f};
        transform_point(&viewMatrix, &worldPos, &viewPos);

        struct matrix invViewMatrix;
        ::memcpy(&invViewMatrix.m[0][0], newRenderer.getInvViewMatrix(), sizeof(invViewMatrix.m));

        float rp = -250000;

        vector2<float> planedir = { viewPos.x, viewPos.z};
        float planeDirLength = sqrtf(planedir.x * planedir.x + planedir.y * planedir.y);
        planedir.x /= planeDirLength;
        planedir.y /= planeDirLength;

        vector2<float> plane = {viewPos.y, sqrtf((viewPos.x) * (viewPos.x) + (viewPos.z) * (viewPos.z))};
        vector2<float> planeScaled = {plane.x / rp, plane.y / rp};
        vector2<float> planeScaledExp = {exp(planeScaled.x) * cos(planeScaled.y), exp(planeScaled.x) * sin(planeScaled.y)};
        vector2<float> circle = { rp * planeScaledExp.x - rp, rp * planeScaledExp.y};

        vector3<float> newViewPos = {circle.y * planedir.x, circle.x, circle.y * planedir.y};

        vector3<float> newWorldPos = {0.0f, 0.0f, 0.0f};
        transform_point(&invViewMatrix, &newViewPos, &newWorldPos);

        return newWorldPos;
    }

    void world_draw_effects()
    {
        short v0;
        transform_matrix rot_matrix_0;
        transform_matrix rot_matrix_1;
        int v3;
        transform_matrix rot_matrix_2;
        int v5;
        int v6;
        vector3<short> delta_point;
        vector4<short> camera_direction;
        vector4<int> a1;

        camera_direction.x = 0;
        camera_direction.y = -(short)ff7_externals.get_world_camera_front_rot_74D298();
        camera_direction.z = 0;
        ff7_externals.engine_apply_rotation_to_rot_matrix_662AD8((vector3<short>*)&camera_direction, &rot_matrix_1);
        camera_direction.x = -ff7_externals.world_get_world_current_camera_rotation_x_74D3C6();
        ff7_externals.engine_apply_rotation_to_rot_matrix_662AD8((vector3<short>*)&camera_direction, &rot_matrix_2);
        ff7_externals.world_copy_position_75042B(&a1);

        world_effect_2d_list_node* eff_node = *ff7_externals.dword_E35648;
        world_effect_2d_list_node* next_node = nullptr;
        while (eff_node)
        {
            vector3<float> worldPos = {static_cast<float>(eff_node->x), static_cast<float>(eff_node->y), static_cast<float>(eff_node->z)};
            vector3<float> newWorldPos = calcSphericalWorldPos(worldPos);

            vector3<float> refPos = {static_cast<float>(a1.x), static_cast<float>(*ff7_externals.world_camera_delta_y_DE6A04), static_cast<float>(a1.z)};

            v6 = newWorldPos.x - refPos.x;
            v5 = newWorldPos.y - refPos.y;
            v3 = newWorldPos.z - refPos.z;

            // Save the next node first because world_submit_draw_effects_75C283 might modify the eff_node variable since it mutates the ESI register
            next_node = eff_node->next;
            if ( v6 > -30000 && v6 < 30000 && v3 > -30000 && v3 < 30000 )
            {
                delta_point.x = v6;
                v0 = 0;
                delta_point.y = v5 - v0;
                delta_point.z = v3;
                if ( eff_node->apply_rotation_y )
                {
                    camera_direction.z = 0;
                    camera_direction.x = 0;
                    camera_direction.y = eff_node->rotation_y;
                    ff7_externals.engine_apply_rotation_to_transform_matrix_6628DE((vector3<short>*)&camera_direction, (rotation_matrix*)&rot_matrix_0);
                    ff7_externals.engine_set_game_engine_rot_matrix_663673((rotation_matrix*)&rot_matrix_0);
                }
                else
                {
                    ff7_externals.engine_set_game_engine_rot_matrix_663673((rotation_matrix*)&rot_matrix_2);
                }

                ff7_externals.world_submit_draw_effects_75C283(
                    &eff_node->texture_data,
                    (int)&ff7_externals.byte_96D6A8[12 * eff_node->unknown_idx],
                    &delta_point,
                    eff_node->apply_rotation_y);
            }
            eff_node = next_node;
        }
    }

    vector4<short>* previous_position_backup = nullptr;
    void animate_world_snake()
    {
        __int16 unknown;
        __int16 v1;
        __int16 v2;
        int delta_x;
        int delta_y;
        world_snake_graphics_data *snake_data;
        vector4<short>* previous_position;
        vector4<int> v7;

        ff7_externals.sub_74C9A5();
        ff7_externals.world_copy_position_75042B(&v7);
        previous_position = *ff7_externals.world_snake_data_position_ptr_E2A18C - 1;
        if ( previous_position < ff7_externals.world_snake_data_position_E29F80 )
            previous_position = &(ff7_externals.world_snake_data_position_E29F80[47]);


        for ( snake_data = ff7_externals.world_snake_graphics_data_E2A490;
                snake_data < ff7_externals.world_snake_graphics_data_end_E2A6D0;
                ++snake_data )
        {
            previous_position += 4;
            if ( previous_position >= ff7_externals.snake_position_size_of_array_E2A100 )
            previous_position -= 48;

            if ( ff7_externals.sub_753366(((int)previous_position->x >> 13) + 26, ((int)previous_position->y >> 13) + 16) )
            {
                vector3<float> prevPos = { static_cast<float>(previous_position->x + 212992),
                                           static_cast<float>(0),
                                           static_cast<float>(previous_position->y + 0x20000)};
                vector3<float> newPrevWorldPos = calcSphericalWorldPos(prevPos);

                delta_x = newPrevWorldPos.x - v7.x;
                if ( delta_x >= -30000 && delta_x <= 30000 )
                {
                    snake_data->delta_x = delta_x;
                    delta_y = newPrevWorldPos.z - v7.z;
                    if ( delta_y >= -30000 && delta_y <= 30000 )
                    {
                        snake_data->delta_y = newPrevWorldPos.z - LOWORD(v7.z);
                        v2 = previous_position->z + 2048;
                        unknown = previous_position->w;
                        v1 = newPrevWorldPos.y;//sub_762F9A(snake_data->delta_x, snake_data->delta_y);
                        previous_position_backup = previous_position;
                        ff7_externals.world_draw_snake_texture_75D544(300, 300, unknown + v1, v2, snake_data, 0);// first two parameters = width and height of one block of the snake
                        previous_position = previous_position_backup;
                    }
                }
            }


        }
    }

    int world_sub_762F9A(int x, int z)
    {
        return 0;
    }

    void draw_shadow(ff7_graphics_object *, ff7_game_obj *)
    {
    }

    void engine_apply_4x4_matrix_product_between_matrices(matrix *a1, matrix *a2, matrix *a3)
    {
        struct game_mode* mode = getmode_cached();

        struct matrix projection_matrix;
        ::memcpy(&projection_matrix.m[0][0], &a2->m[0][0], sizeof(projection_matrix.m));

        if (mode->driver_mode == MODE_WORLDMAP)
        {
            float f_offset = 0.0035f;
            float n_offset = 0.0f;

            float a = projection_matrix._33;
            float b = projection_matrix._43;


            float f = b / (a + 1.0f) + f_offset;
            float n = b / (a - 1.0f) + n_offset;


            projection_matrix._33 = -(f + n) / (f -n);
            projection_matrix._43 = -(2*f*n) / (f - n);
        }

        ff7_externals.engine_apply_4x4_matrix_product_between_matrices_66C6CD(a1, &projection_matrix, a3);
    }

    void Renderer::loadWorldMapExternalMesh()
    {
        externalWorldMapModel.unloadExternalMesh();

        const int worldmap_type = *ff7_externals.world_map_type_E045E8;
        const int world_progress = *ff7_externals.world_progress_E28CB4;

        std::string wmStr = "wm" + std::to_string(worldmap_type);
        std::vector<std::string> files;

        files.push_back("wm" + std::to_string(worldmap_type));
        if(worldmap_type == 0)
        {
            files.push_back("wm0_0_" + std::to_string(world_progress > 0));
            files.push_back("wm0_1_" + std::to_string(world_progress > 1));
            files.push_back("wm0_2_" + std::to_string(world_progress > 2));
            files.push_back("wm0_3_" + std::to_string(world_progress > 3));
        }

        auto numFiles = files.size();
        for (int i = 0; i < numFiles; ++i)
        {
            char file_path_gltf[MAX_PATH];
            sprintf(file_path_gltf, "%s/%s/world/%s.gltf", basedir, external_mesh_path.data(), files[i].data());

            char tex_path[MAX_PATH];
            sprintf(tex_path, "%s/%s/world/textures/", basedir, external_mesh_path.data());

            externalWorldMapModel.importExternalMeshGltfFile(file_path_gltf, tex_path);
        }
    }

    void Renderer::loadCloudsExternalMesh()
    {
        externalCloudsModel.unloadExternalMesh();

        char file_path_gltf[MAX_PATH];
        sprintf(file_path_gltf, "%s/%s/world/clouds.gltf", basedir, external_mesh_path.data());

        char tex_path[MAX_PATH];
        sprintf(tex_path, "%s/%s/world/textures/", basedir, external_mesh_path.data());

        externalCloudsModel.importExternalMeshGltfFile(file_path_gltf, tex_path);
    }

    void Renderer::loadMeteorExternalMesh()
    {
        externalMeteorModel.unloadExternalMesh();

        char file_path_gltf[MAX_PATH];
        sprintf(file_path_gltf, "%s/%s/world/meteo.gltf", basedir, external_mesh_path.data());

        char tex_path[MAX_PATH];
        sprintf(tex_path, "%s/%s/world/textures/", basedir, external_mesh_path.data());

        externalMeteorModel.importExternalMeshGltfFile(file_path_gltf, tex_path);
    }

    void Renderer::unloadExternalMeshes()
    {
        externalWorldMapModel.unloadExternalMesh();
        externalCloudsModel.unloadExternalMesh();
        externalMeteorModel.unloadExternalMesh();
    }

    bool Renderer::drawWorldMapExternalMesh()
    {
        if(gl_defer_world_external_mesh()) return false;

        auto shapeCount = externalWorldMapModel.shapes.size();
        int vertexOffset = 0;
        int indexOffset = 0;

        int world_pos_x = ff7_externals.world_player_pos_E04918->x;
        int world_pos_y = ff7_externals.world_player_pos_E04918->y;
        int world_pos_z = ff7_externals.world_player_pos_E04918->z;

        struct matrix viewMatrix;
        ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));

        // Create a world matrix
        struct matrix worldViewMatrix[9];
        for (int gridX = -1; gridX <= 1; gridX++)
        {
            for (int gridZ = -1; gridZ <= 1; gridZ++)
            {
                struct matrix worldMatrix;
                identity_matrix(&worldMatrix);
                worldMatrix._41 = gridX * 294912;
                worldMatrix._42 = -500;
                worldMatrix._43 = gridZ * 229376;
                multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix[3 * (gridX + 1) + gridZ + 1]);
            }
        }

        newRenderer.setInterpolationQualifier(SMOOTH);
        newRenderer.setPrimitiveType();
        newRenderer.isTLVertex(false);
        newRenderer.setBlendMode(RendererBlendMode::BLEND_NONE);
        newRenderer.doTextureFiltering(true);
        newRenderer.doMirrorTextureWrap(true);
        newRenderer.isExternalTexture(true);
        newRenderer.isTexture(true);
        newRenderer.doDepthTest(true);
        newRenderer.doDepthWrite(true);
        newRenderer.setSphericalWorldRate(1.0f);

        if(enable_lighting)
        {
            // Light view frustum pointing to player position
            vector3<float> center = {
                static_cast<float>(world_pos_x),
                static_cast<float>(world_pos_y),
                static_cast<float>(world_pos_z)};

            vector3<float> centerViewSpace;
                    transform_point(&viewMatrix, &center, &centerViewSpace);
            lighting.updateLightMatrices(centerViewSpace);
        }

        struct matrix* pProjMatrix = nullptr;
        if(!ff8)
        {
            struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
            if (game_object)
            {
                auto polygon_set = (ff7_polygon_set*)game_object->polygon_set_2EC;
                if(polygon_set)
                {
                    auto matrix_set = polygon_set->matrix_set;
                    pProjMatrix = matrix_set->matrix_projection;
                }

            }

            if(pProjMatrix != nullptr)
            {
                newRenderer.setD3DProjection(pProjMatrix);
                newRenderer.setD3DViweport(&d3dviewport_matrix);
            }
        }

        for (auto& iter : externalWorldMapModel.materials)
        {
            int texCount = iter.second.baseColorTexHandles.size();
            int frameInterval = iter.second.frameInterval * common_frame_multiplier;
            if(texCount == 1 || frameInterval == 0) continue;
            if(frame_counter % frameInterval == 0)
            {
                iter.second.texIndex++;
                if(iter.second.texIndex >= texCount) iter.second.texIndex = 0;
            }
        }

        const float maxDist = 275000.0f * 275000.0f;

        bool isFirstBinding = true;
        for (int i = 0; i < shapeCount; ++i)
        {
            auto& shape = externalWorldMapModel.shapes[i];

            newRenderer.setCullMode(shape.isDoubleSided ? RendererCullMode::DISABLED : RendererCullMode::BACK);

            vector3<float> center;
            center.x = 0.5f * (shape.max.x + shape.min.x);
            center.y = 0.5f * (shape.max.y + shape.min.y);
            center.z = 0.5f * (shape.max.z + shape.min.z);

            float radius = std::max(shape.max.x - shape.min.x, std::max(shape.max.y - shape.min.y, shape.max.z - shape.min.z));

            bool commonBindingSet = false;
            for (int gridX = -1; gridX <= 1; ++gridX)
            {
                for (int gridZ = -1; gridZ <= 1; ++gridZ)
                {
                    vector3<float> centerShifted;
                    centerShifted.x = center.x + gridX * 294912;
                    centerShifted.y = center.z;
                    centerShifted.z = center.y + gridZ * 229376;

                    vector2<float> diff;
                    diff.x = world_pos_x - centerShifted.x;
                    diff.y = world_pos_z - centerShifted.z;

                    float sqrDist = diff.x * diff.x + diff.y * diff.y;
                    if (sqrDist > maxDist)
                    {
                        continue;
                    }

                    vector3<float> centerShiftedViewSpace;
                    transform_point(&viewMatrix, &centerShifted, &centerShiftedViewSpace);

                    if (centerShiftedViewSpace.z + radius < 0.0f)
                    {
                        continue;
                    }

                    if (std::abs(centerShiftedViewSpace.x) - radius >  175000.0f)
                    {
                        continue;
                    }

                    if (std::abs(centerShiftedViewSpace.y) - radius >  175000.0f)
                    {
                        continue;
                    }

                    if (isFirstBinding)
                    {
                        newRenderer.setWorldViewMatrix(&worldViewMatrix[3 * (gridX + 1) + gridZ + 1]);
                        newRenderer.setCommonUniforms();
                        if (enable_lighting) newRenderer.setLightingUniforms();
                        isFirstBinding = false;
                    }
                    else
                    {
                        newRenderer.setWorldViewMatrix(&worldViewMatrix[3 * (gridX + 1) + gridZ + 1], false);
                        newRenderer.setUniform(RendererUniform::WORLD_VIEW, newRenderer.getWorldViewMatrix());
                    }

                    if(!commonBindingSet)
                    {
                        externalWorldMapModel.bindField3dVertexBuffer(vertexOffset, shape.vertices.size());
                        externalWorldMapModel.bindField3dIndexBuffer(indexOffset, shape.indices.size());

                        if(shape.pMaterial != nullptr)
                        {
                            if(shape.pMaterial->baseColorTexHandles.size() > 0)
                            {
                                auto baseColorTexHandle = shape.pMaterial->baseColorTexHandles[shape.pMaterial->texIndex];
                                if(bgfx::isValid(baseColorTexHandle))
                                    newRenderer.useTexture(baseColorTexHandle.idx, RendererTextureSlot::TEX_Y);
                                else newRenderer.useTexture(0, RendererTextureSlot::TEX_Y);
                            }

                            if(shape.pMaterial->normalTexHandles.size() > 0)
                            {
                                auto normalTexHandle = shape.pMaterial->normalTexHandles[0];
                                if(bgfx::isValid(normalTexHandle))
                                    newRenderer.useTexture(normalTexHandle.idx, RendererTextureSlot::TEX_NML);
                                else newRenderer.useTexture(0, RendererTextureSlot::TEX_NML);
                            }

                            if(shape.pMaterial->pbrTexHandles.size() > 0)
                            {
                                auto pbrTexHandle = shape.pMaterial->pbrTexHandles[0];
                                if(bgfx::isValid(pbrTexHandle))
                                    newRenderer.useTexture(pbrTexHandle.idx, RendererTextureSlot::TEX_PBR);
                                else newRenderer.useTexture(0, RendererTextureSlot::TEX_PBR);
                            }

                            newRenderer.bindTextures();

                            commonBindingSet = true;
                        }
                    }

                    if (enable_lighting)
                    {
                        newRenderer.drawToShadowMap(true, true);
                        newRenderer.drawWithLighting(true, true, true);
                    }
                    else newRenderer.draw(true, true, true);
                }
            }

            vertexOffset += shape.vertices.size();
            indexOffset += shape.indices.size();
        }

        newRenderer.discardAllBindings();

        newRenderer.doMirrorTextureWrap(false);

        if(shapeCount > 0) return true;
        else return false;
    }

    bool Renderer::drawCloudsExternalMesh()
    {
        int world_pos_x = ff7_externals.world_player_pos_E04918->x;
        int world_pos_y = ff7_externals.world_player_pos_E04918->y;
        int world_pos_z = ff7_externals.world_player_pos_E04918->z;

        struct matrix viewMatrix;
        ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));

        struct matrix inverseViewMatrix;
        ::memcpy(&inverseViewMatrix.m[0][0], newRenderer.getInvViewMatrix(), sizeof(inverseViewMatrix.m));

        vector3<float> cameraPosViewSpace = {0.0f, 0.0f, 0.0f};
        vector3<float> cameraPos = {0.0f, 0.0f, 0.0f};
        transform_point(&inverseViewMatrix, &cameraPosViewSpace, &cameraPos);

        vector3<float> forward = {0.0f, 0.0f, 0.0f};
        vector3<float> focusPos = {static_cast<float>(world_pos_x), static_cast<float>(world_pos_y), static_cast<float>(world_pos_z)};
        subtract_vector(&focusPos, &cameraPos, &forward);
        forward.y = 0;
        normalize_vector(&forward);

        vector3<float> up = {0.0, 1.0, 0.0 };
        vector3<float> right = {0.0, 0.0, 0.0};
        cross_product(&forward, &up, &right);

        static const int numQuads = 5;

        static float frameCount = 0;
        frameCount++;

        // Create a world matrix
        struct matrix worldViewMatrix[numQuads];

        const float scaleX = 150000;
        const float scaleY = scaleX / 4;
        for(int i = 0; i < numQuads; ++i)
        {
            identity_matrix(&worldViewMatrix[i]);

            float offset = 2.0f * scaleX * (i- numQuads / 2);
            float cameraOffset = -4.0f * scaleX * (std::remainder(ff7::world::camera.getRotationOffsetY(), 360.0f) / 360.0f);
            float totalOffset = offset + cameraOffset;

            struct matrix worldMatrix;
            identity_matrix(&worldMatrix);
            worldMatrix._11 = (i % 2 == 0 ? 1 : -1) *  scaleX * right.x;
            worldMatrix._12 = (i % 2 == 0 ? 1 : -1) *  scaleX * right.y;
            worldMatrix._13 = (i % 2 == 0 ? 1 : -1) * scaleX * right.z;
            worldMatrix._21 = -scaleY * up.x;
            worldMatrix._22 = -scaleY * up.y;
            worldMatrix._23 = -scaleY * up.z;
            worldMatrix._31 = forward.x;
            worldMatrix._32 = forward.y;
            worldMatrix._33 = forward.z;
            worldMatrix._41 = focusPos.x + forward.x * 100000 + totalOffset * right.x;
            worldMatrix._42 = 20000;
            worldMatrix._43 = focusPos.z + forward.z * 100000 + totalOffset * right.z;

            multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix[i]);

        }

        newRenderer.setInterpolationQualifier(SMOOTH);
        newRenderer.setPrimitiveType();
        newRenderer.isTLVertex(false);
        newRenderer.setBlendMode(RendererBlendMode::BLEND_ADD);
        newRenderer.doTextureFiltering(true);
        newRenderer.isExternalTexture(true);
        newRenderer.isTexture(true);
        newRenderer.doDepthTest(true);
        newRenderer.doDepthWrite(false);
        newRenderer.setSphericalWorldRate(1.5f);

        struct matrix* pProjMatrix = nullptr;
        if(!ff8)
        {
            struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
            if (game_object)
            {
                auto polygon_set = (ff7_polygon_set*)game_object->polygon_set_2EC;
                if(polygon_set)
                {
                    auto matrix_set = polygon_set->matrix_set;
                    pProjMatrix = matrix_set->matrix_projection;
                }

            }

            if(pProjMatrix != nullptr)
            {
                newRenderer.setD3DProjection(pProjMatrix);
                newRenderer.setD3DViweport(&d3dviewport_matrix);
            }
        }

        newRenderer.setWorldViewMatrix(&worldViewMatrix[0]);
        newRenderer.setCommonUniforms();

        auto shapeCount = externalCloudsModel.shapes.size();
        for (int i = 0; i < shapeCount; ++i)
        {
            auto& shape = externalCloudsModel.shapes[i];

            newRenderer.setCullMode(shape.isDoubleSided ? RendererCullMode::DISABLED : RendererCullMode::BACK);

            externalCloudsModel.bindField3dVertexBuffer(0, shape.vertices.size());
            externalCloudsModel.bindField3dIndexBuffer(0, shape.indices.size());

            if(shape.pMaterial != nullptr)
            {
                if(shape.pMaterial->baseColorTexHandles.size() > 0)
                {
                    auto baseColorTexHandle = shape.pMaterial->baseColorTexHandles[shape.pMaterial->texIndex];
                    if(bgfx::isValid(baseColorTexHandle))
                        newRenderer.useTexture(baseColorTexHandle.idx, RendererTextureSlot::TEX_Y);
                    else newRenderer.useTexture(0, RendererTextureSlot::TEX_Y);
                }

                if(shape.pMaterial->normalTexHandles.size() > 0)
                {
                    auto normalTexHandle = shape.pMaterial->normalTexHandles[0];
                    if(bgfx::isValid(normalTexHandle))
                        newRenderer.useTexture(normalTexHandle.idx, RendererTextureSlot::TEX_NML);
                    else newRenderer.useTexture(0, RendererTextureSlot::TEX_NML);
                }

                if(shape.pMaterial->pbrTexHandles.size() > 0)
                {
                    auto pbrTexHandle = shape.pMaterial->pbrTexHandles[0];
                    if(bgfx::isValid(pbrTexHandle))
                        newRenderer.useTexture(pbrTexHandle.idx, RendererTextureSlot::TEX_PBR);
                    else newRenderer.useTexture(0, RendererTextureSlot::TEX_PBR);
                }

                newRenderer.bindTextures();
            }

            for(int i = 0; i < numQuads; ++i)
            {
                if(i != 0)
                {
                    newRenderer.setWorldViewMatrix(&worldViewMatrix[i]);
                    newRenderer.setUniform(RendererUniform::WORLD_VIEW, newRenderer.getWorldViewMatrix());
                }

                newRenderer.draw(true, true, true);
            }
        }

        newRenderer.discardAllBindings();

        newRenderer.setSphericalWorldRate(1.0f);

        return true;
    }

    bool Renderer::drawMeteorExternalMesh()
    {
        int world_pos_x = ff7_externals.world_player_pos_E04918->x;
        int world_pos_y = ff7_externals.world_player_pos_E04918->y;
        int world_pos_z = ff7_externals.world_player_pos_E04918->z;

        struct matrix viewMatrix;
        ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));

        struct matrix inverseViewMatrix;
        ::memcpy(&inverseViewMatrix.m[0][0], newRenderer.getInvViewMatrix(), sizeof(inverseViewMatrix.m));

        vector3<float> cameraPosViewSpace = {0.0f, 0.0f, 0.0f};
        vector3<float> cameraPos = {0.0f, 0.0f, 0.0f};
        transform_point(&inverseViewMatrix, &cameraPosViewSpace, &cameraPos);

        vector3<float> forward = {0.0f, 0.0f, 0.0f};
        vector3<float> focusPos = {static_cast<float>(world_pos_x), static_cast<float>(world_pos_y), static_cast<float>(world_pos_z)};
        subtract_vector(&focusPos, &cameraPos, &forward);
        forward.y = 0;
        normalize_vector(&forward);

        vector3<float> up = {0.0, 1.0, 0.0 };
        vector3<float> right = {0.0, 0.0, 0.0};
        cross_product(&forward, &up, &right);

        // Create a world matrix
        struct matrix worldViewMatrix;

        identity_matrix(&worldViewMatrix);

        const float scaleX = 100000;
        const float scaleY = scaleX / 2;

        float cameraOffset = -8.0f * scaleX * (std::remainder(ff7::world::camera.getRotationOffsetY(), 360.0f) / 360.0f);

        struct matrix worldMatrix;
        identity_matrix(&worldMatrix);
        worldMatrix._11 = scaleX * right.x;
        worldMatrix._12 = scaleX * right.y;
        worldMatrix._13 = scaleX * right.z;
        worldMatrix._21 = scaleY * up.x;
        worldMatrix._22 = scaleY * up.y;
        worldMatrix._23 = scaleY * up.z;
        worldMatrix._31 = forward.x;
        worldMatrix._32 = forward.y;
        worldMatrix._33 = forward.z;
        worldMatrix._41 = focusPos.x + forward.x * 150000 + cameraOffset * right.x;
        worldMatrix._42 = 40000;
        worldMatrix._43 = focusPos.z + forward.z * 150000 + cameraOffset * right.z;

        multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix);

        newRenderer.setInterpolationQualifier(SMOOTH);
        newRenderer.setPrimitiveType();
        newRenderer.isTLVertex(false);
        newRenderer.setBlendMode(RendererBlendMode::BLEND_ADD);
        newRenderer.doTextureFiltering(true);
        newRenderer.isExternalTexture(true);
        newRenderer.isTexture(true);
        newRenderer.doDepthTest(true);
        newRenderer.doDepthWrite(false);
        newRenderer.setSphericalWorldRate(4.0f);

        struct matrix* pProjMatrix = nullptr;
        if(!ff8)
        {
            struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
            if (game_object)
            {
                auto polygon_set = (ff7_polygon_set*)game_object->polygon_set_2EC;
                if(polygon_set)
                {
                    auto matrix_set = polygon_set->matrix_set;
                    pProjMatrix = matrix_set->matrix_projection;
                }

            }

            if(pProjMatrix != nullptr)
            {
                newRenderer.setD3DProjection(pProjMatrix);
                newRenderer.setD3DViweport(&d3dviewport_matrix);
            }
        }

        newRenderer.setWorldViewMatrix(&worldViewMatrix);
        newRenderer.setCommonUniforms();

        auto shapeCount = externalMeteorModel.shapes.size();
        for (int i = 0; i < shapeCount; ++i)
        {
            auto& shape = externalMeteorModel.shapes[i];

            newRenderer.setCullMode(shape.isDoubleSided ? RendererCullMode::DISABLED : RendererCullMode::BACK);

            externalMeteorModel.bindField3dVertexBuffer(0, shape.vertices.size());
            externalMeteorModel.bindField3dIndexBuffer(0, shape.indices.size());

            if(shape.pMaterial != nullptr)
            {
                if(shape.pMaterial->baseColorTexHandles.size() > 0)
                {
                    auto baseColorTexHandle = shape.pMaterial->baseColorTexHandles[shape.pMaterial->texIndex];
                    if(bgfx::isValid(baseColorTexHandle))
                        newRenderer.useTexture(baseColorTexHandle.idx, RendererTextureSlot::TEX_Y);
                    else newRenderer.useTexture(0, RendererTextureSlot::TEX_Y);
                }

                if(shape.pMaterial->normalTexHandles.size() > 0)
                {
                    auto normalTexHandle = shape.pMaterial->normalTexHandles[0];
                    if(bgfx::isValid(normalTexHandle))
                        newRenderer.useTexture(normalTexHandle.idx, RendererTextureSlot::TEX_NML);
                    else newRenderer.useTexture(0, RendererTextureSlot::TEX_NML);
                }

                if(shape.pMaterial->pbrTexHandles.size() > 0)
                {
                    auto pbrTexHandle = shape.pMaterial->pbrTexHandles[0];
                    if(bgfx::isValid(pbrTexHandle))
                        newRenderer.useTexture(pbrTexHandle.idx, RendererTextureSlot::TEX_PBR);
                    else newRenderer.useTexture(0, RendererTextureSlot::TEX_PBR);
                }

                newRenderer.bindTextures();
            }

            newRenderer.draw(true, true, true);
        }

        newRenderer.discardAllBindings();

        newRenderer.setSphericalWorldRate(1.0f);

        return true;
    }

    bool Renderer::drawCloudsAndMeteorExternalMesh(bool isDrawMeteor)
    {
        if(gl_defer_cloud_external_mesh()) return false;

        if (isDrawMeteor) drawMeteorExternalMesh();
        drawCloudsExternalMesh();

        return true;
    }
}
````

## File: src/ff7/world/renderer.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "external_mesh.h"
#include "ff7.h"

namespace ff7::world {

    void init_load_wm_bot_blocks();
    void destroy_graphics_objects();

    void wm0_overworld_draw_all();
    void wm0_overworld_draw_clouds();
    void wm0_overworld_draw_meteor();
    void wm2_underwater_draw_all();
    void wm3_snowstorm_draw_all();

    void wm0_draw_minimap_quad_graphics_object(ff7_graphics_object* quad_graphics_object, ff7_game_obj* game_object);
    void wm0_draw_world_effects_1_graphics_object(ff7_graphics_object* world_effects_1_graphics_object, ff7_game_obj* game_object);
    void wm0_draw_minimap_points_graphics_object(ff7_graphics_object* minimap_points_graphics_object, ff7_game_obj* game_object);

    int get_camera_rotation_z();

    void world_copy_position(vector4<int> *a1);
    void world_draw_effects();
    void animate_world_snake();
    int world_sub_762F9A(int a1, int arg4);

    void draw_shadow(ff7_graphics_object *, ff7_game_obj *);

    void engine_apply_4x4_matrix_product_between_matrices(matrix *a1, matrix *a2, matrix *a3);

    class Renderer
    {
    public:
        void loadWorldMapExternalMesh();
        bool drawWorldMapExternalMesh();
        void loadCloudsExternalMesh();
        void loadMeteorExternalMesh();
        void unloadExternalMeshes();
        bool drawCloudsExternalMesh();
        bool drawMeteorExternalMesh();
        bool drawCloudsAndMeteorExternalMesh(bool isDrawMeteor);

    private:
        ExternalMesh externalWorldMapModel;
        ExternalMesh externalSnakeModel;
        ExternalMesh externalCloudsModel;
        ExternalMesh externalMeteorModel;
    };

    Renderer worldRenderer;
}
````

## File: src/ff7/world/utils.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2022 Cosmos                                             //
//    Copyright (C) 2022 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

namespace ff7::world
{
    bool is_key_pressed(int current_key_status, int key)
    {
        return (current_key_status & key) != 0;
    }

    bool is_key_pressed_first_time(int current_key_status, int prev_key_status, int key)
    {
        return (current_key_status & key) != 0 && (prev_key_status & key) == 0;
    }

    bool is_key_released(int current_key_status, int prev_key_status, int key)
    {
        return (current_key_status & key) == 0 && (prev_key_status & key) != 0;
    }
}
````

## File: src/ff7/world/world.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <math.h>

#include "../../globals.h"
#include "../../patch.h"
#include "../../sfx.h"

#include "cfg.h"
#include "defs.h"
#include "world.h"
#include "utils.h"
#include "renderer.h"

namespace ff7::world
{
    World world;

    std::map<uint32_t, bool> do_decrease_wait_frames;

    bool world_has_old_highwind()
    {
        return (*ff7_externals.insertedCD) <= 2;
    }

    void world_update_model_movement(int delta_position_x, int delta_position_z)
    {
        int player_model_id = ff7_externals.world_get_player_model_id();
        constexpr float distance_threshold = 10.0f;
        float distance = std::sqrt(std::pow(delta_position_x, 2) + std::pow(delta_position_z, 2));

        // For Highwind sound
        if(player_model_id == 3)
        {
            int key_input_status = ff7_externals.world_get_current_key_input_status();
            bool is_highwind_moving = is_key_pressed(key_input_status, enable_analogue_controls ? CIRCLE | R1 : CIRCLE);
            sfx_process_wm_highwind(world_has_old_highwind(), is_highwind_moving);
        }
        // For worldmap footsteps
        else if((player_model_id >= 0 && player_model_id <= 2) || player_model_id == 4 || player_model_id == 19) // Cloud, Tifa, Cid, and Chocobo
        {
            // TODO: Fix footsteps when player is not moving at all. Here delta position is not clipped by collision detection (Need to find collision detection)
            if(distance > distance_threshold)
            {
                sfx_process_wm_footstep(player_model_id, ff7_externals.world_get_player_walkmap_type());
            }
        }

        ff7_externals.world_update_model_movement_762E87(delta_position_x, delta_position_z);
    }

    void world_init_variables(short param_1)
    {
        do_decrease_wait_frames.clear();

        ((void(*)(short))ff7_externals.world_init_variables_74E1E9)(param_1);
    }

    void world_snake_compute_delta_position(vector3<short>* delta_position, short z_value)
    {
        ff7_externals.world_sub_753D00(delta_position, z_value);
        if(delta_position)
        {
            delta_position->x /= common_frame_multiplier;
            delta_position->y /= common_frame_multiplier;
            delta_position->z /= common_frame_multiplier;
        }
    }

    int run_world_script_system_operations(WORD opcode)
    {
        int ret = 0;
        if (opcode == 0x306)
        {
            vector3<short> delta_position;
            if (*ff7_externals.is_wait_frames_zero_E39BC0)
            {
                --(*ff7_externals.world_event_current_entity_ptr_E3A7CC)->curr_script_position;
                return 1;
            }
            else
            {
                if(do_decrease_wait_frames[(uint32_t)*ff7_externals.world_event_current_entity_ptr_E3A7CC])
                    (*ff7_externals.world_event_current_entity_ptr_E3A7CC)->wait_frames--;
                do_decrease_wait_frames[(uint32_t)*ff7_externals.world_event_current_entity_ptr_E3A7CC] = !do_decrease_wait_frames[(uint32_t)*ff7_externals.world_event_current_entity_ptr_E3A7CC];

                if ((*ff7_externals.world_event_current_entity_ptr_E3A7CC)->wait_frames)
                    (*ff7_externals.world_event_current_entity_ptr_E3A7CC)->curr_script_position--;
                else
                    *ff7_externals.is_wait_frames_zero_E39BC0 = 1;
                delta_position.x = 0;
                delta_position.y = 0;
                delta_position.z = (*ff7_externals.world_event_current_entity_ptr_E39AD8)->movement_speed << (4 * (((*ff7_externals.world_event_current_entity_ptr_E39AD8)->animation_is_loop_mask & 0x40) != 0));
                ff7_externals.world_sub_753D00(&delta_position, (*ff7_externals.world_event_current_entity_ptr_E39AD8)->direction);
                ff7_externals.world_update_model_movement_762E87(delta_position.x, delta_position.z);
                (*ff7_externals.world_event_current_entity_ptr_E39AD8)->offset_y -= (*ff7_externals.world_event_current_entity_ptr_E39AD8)->vertical_speed;
                (*ff7_externals.world_event_current_entity_ptr_E39AD8)->position.y += (*ff7_externals.world_event_current_entity_ptr_E39AD8)->vertical_speed_2;
                return (*ff7_externals.world_event_current_entity_ptr_E3A7CC)->wait_frames != 0;
            }
        }
        else
        {
            ret = ((int (*)(WORD))ff7_externals.run_world_event_scripts_system_operations)(opcode);
        }
        return ret;
    }

    int pop_world_stack_multiply_wrapper()
    {
        int ret = ff7_externals.pop_world_script_stack();
        return ret * common_frame_multiplier;
    }

    int pop_world_stack_divide_wrapper()
    {
        int ret = ff7_externals.pop_world_script_stack();
        return ret / common_frame_multiplier;
    }

    int get_world_encounter_rate()
    {
        int encounter_rate = ff7_externals.get_world_encounter_rate();
        return encounter_rate / common_frame_multiplier;
    }

    void world_hook_init()
    {
        if(ff7_fps_limiter == FPS_LIMITER_60FPS)
        {
            // World init
            replace_call_function(ff7_externals.world_mode_loop_sub_74DB8C + 0x108, world_init_variables);

            // Movement related fix
            patch_divide_code<DWORD>(ff7_externals.world_init_variables_74E1E9 + 0x15D, common_frame_multiplier);
            replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x172, pop_world_stack_divide_wrapper);
            replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x14B, pop_world_stack_divide_wrapper);
            replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x55D, pop_world_stack_divide_wrapper);
            replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x584, pop_world_stack_divide_wrapper);

            // Camera related fix
            replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x7DC, pop_world_stack_divide_wrapper);

            // Midgar zolom (snake) movement fix
            replace_call_function(ff7_externals.update_world_snake_position_7564CD + 0x26, world_snake_compute_delta_position);
            replace_call_function(ff7_externals.update_world_snake_position_7564CD + 0x195, world_snake_compute_delta_position);
            replace_call_function(ff7_externals.update_world_snake_position_7564CD + 0x2B4, world_snake_compute_delta_position);

            // World Encounter rate fix
            replace_call_function(ff7_externals.world_sub_767641 + 0x110, get_world_encounter_rate);

            // Text box message fix
            patch_code_byte(ff7_externals.world_text_box_window_paging_769C02 + 0xF6, 0x5 + common_frame_multiplier / 2);
            patch_divide_code<byte>(ff7_externals.world_text_box_window_paging_769C02 + 0xF9, common_frame_multiplier);
            patch_divide_code<WORD>(ff7_externals.world_text_box_window_paging_769C02 + 0x10A, common_frame_multiplier);
            patch_code_byte(ff7_externals.world_text_box_window_paging_769C02 + 0x13A, 0x4 + common_frame_multiplier / 2);
            patch_code_byte(ff7_externals.world_text_box_window_opening_769A66 + 0x3D, 0x2 + common_frame_multiplier / 2);
            patch_code_byte(ff7_externals.world_text_box_window_opening_769A66 + 0xD2, 0x2 + common_frame_multiplier / 2);
            patch_code_byte(ff7_externals.world_text_box_window_closing_76ADF7 + 0x67, 0x2 + common_frame_multiplier / 2);
            patch_code_byte(ff7_externals.world_text_box_window_closing_76ADF7 + 0xC2, 0x2 + common_frame_multiplier / 2);
            patch_divide_code<short>(ff7_externals.world_text_box_reverse_paging_76ABE9 + 0x42, common_frame_multiplier);
            patch_divide_code<short>(ff7_externals.world_opcode_message + 0x1AC, common_frame_multiplier);
            patch_divide_code<short>(ff7_externals.world_opcode_message + 0x2CF, common_frame_multiplier);
            patch_divide_code<short>(ff7_externals.world_opcode_ask + 0x1AC, common_frame_multiplier);
            patch_divide_code<byte>(ff7_externals.world_opcode_ask + 0x3CC, common_frame_multiplier);

            // Wait frames decrease delayed
            replace_call_function(ff7_externals.run_world_event_scripts + 0xC7, run_world_script_system_operations);
        }

        if (enable_time_cycle)
        {
            replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x175, ff7::world::wm0_draw_minimap_quad_graphics_object);
            replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x1BE, ff7::world::wm0_draw_world_effects_1_graphics_object);
            replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x208, ff7::world::wm0_draw_minimap_points_graphics_object);
        }

        if (enable_worldmap_external_mesh)
        {
            // Replace player and camera update functions
            if (enable_analogue_controls)
            {
                replace_function(ff7_externals.world_update_camera_74E8CE, ff7::world::update_world_camera);
                replace_function(ff7_externals.world_update_player_74EA48, ff7::world::update_player_and_handle_input);

                // Disable Z-axis camera rotation
                replace_function(ff7_externals.world_sub_74D319, ff7::world::get_camera_rotation_z);
            }            
           
            replace_call_function(ff7_externals.world_mode_loop_sub_74DB8C + 0x296, ff7::world::init_load_wm_bot_blocks);
            replace_call_function(ff7_externals.world_exit_74BD77 + 0x11, ff7::world::destroy_graphics_objects);

            // Expand meteor quad size to render the top part
            patch_code_char(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x205, 0x7F);
            patch_code_char(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x217, 0x0);

            // Replace original world rendering
            patch_code_dword(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 + 0xA7, (DWORD)&ff7::world::wm0_overworld_draw_all);
            replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0xF8, ff7::world::wm0_overworld_draw_clouds);
            replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x10A, ff7::world::wm0_overworld_draw_meteor);
            patch_code_dword(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 + 0xDF, (DWORD)&ff7::world::wm2_underwater_draw_all);
            patch_code_dword(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 + 0x117, (DWORD)&ff7::world::wm3_snowstorm_draw_all);

            // Disable original world spherical transformation
            memset_code(ff7_externals.world_sub_75F0AD + 0xFA, 0x90, 3);
            memset_code(ff7_externals.world_sub_75F0AD + 0x187, 0x90, 3);
            memset_code(ff7_externals.world_sub_75F0AD + 0x1A5, 0x90, 3);

            // Disable world models vertical movement
            replace_function(ff7_externals.world_sub_762F9A, ff7::world::world_sub_762F9A);

            // Draw snake with new spherical world transformation		
            replace_function(ff7_externals.animate_world_snake_75692A, ff7::world::animate_world_snake);	

            // Modify projection matrix to increase view frustrum far plane
            replace_call_function((uint32_t)ff7_externals.engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF + 0x16, ff7::world::engine_apply_4x4_matrix_product_between_matrices);
            
            // Add same spherical world transformation as done in the shader to particles too
            replace_function(ff7_externals.world_sub_75C0FD, ff7::world::world_draw_effects);		

            // Remove world meshes draw calls by jumping to end of loop
            patch_code_byte((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x32, 0x76);
            patch_code_byte((uint32_t)ff7_externals.world_wm2_underwater_draw_all_74C3F0 + 0x32, 0x2D);
            patch_code_byte((uint32_t)ff7_externals.world_wm3_snowstorm_draw_all_74C589 + 0x32, 0x2D);

            // Disable model culling
            // TODO: try to find a way to make to game update models even when player is far away
            //memset_code(ff7_externals.world_draw_all_3d_model_74C6B0 + 0x84, 0x90, 6);
           
            // Disable shadow draw call
            // TODO: fix shadow rendering when lighting not enabled
            //if (enable_lighting)
            {
                replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x13B, ff7::world::draw_shadow);
                replace_call_function((uint32_t)ff7_externals.world_wm3_snowstorm_draw_all_74C589 + 0xB8, ff7::world::draw_shadow);
            }
        }
    }    
}
````

## File: src/ff7/world/world.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2022 Cosmos                                             //
//    Copyright (C) 2022 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "matrix.h"

namespace ff7::world
{
    enum input_key
    {
        L2 = 1,
        R2 = 2,
        L1 = 4,
        R1 = 8,
        TRIANGLE = 16,
        CIRCLE = 32,
        CROSS = 64,
        SQUARE = 128,
        SELECT = 256,
        UNK1 = 512,
        UNK2 = 1024,
        START = 2048,
        UP = 4096,
        RIGHT = 8192,
        DOWN = 16384,
        LEFT = 32768,
        ANY_DIRECTIONAL_KEY = UP | RIGHT | DOWN | LEFT
    };

    enum map_type {
        OVERWORLD = 0,
        UNDERWATER = 2,
        SNOWSTORM = 3
    };

    enum model_type {
        CLOUD = 0,
        TIFA,
        CID,
        HIGHWIND,
        WILD_CHOCOBO,
        TINY_BRONCO ,
        BUGGY,
        JUNON_CANNON,
        CARGO_SHIP,
        HIGHWIND_PROPELLERS,
        DIAMOND_WEAPON,
        ULTIMATE_WEAPON,
        FORT_CONDOR,
        SUBMARINE,
        GOLD_SAUCER,
        ROCKET_TOWN_ROCKET,
        ROCKET_TOWN_LAUNCH_PAD,
        SUNKEN_GELNIKA,
        UNDERWATER_REACTOR,
        CHOCOBO,
        MIDGAR_CANNON,
        MODEL_UNK1,
        MODEL_UNK2,
        MODEL_UNK3,
        NORTH_CRATER_BARRIER,
        ANCIENT_FOREST,
        KEY_ANCIENTS,
        MODEL_UNK4,
        RED_SUBMARINE,
        RUBY_WEAPON,
        EMERALD_WEAPON
    };

    constexpr int INVALID_DIRECTION = 9999;

    class World
    {
    public:
        const vector3<float>& GetJoystickDirection();
        void SetJoystickDirection(const vector3<float>& dir);

        float GetRightTrigger();
        void SetRightTrigger(float value);

        float GetLeftTrigger();
        void SetLeftTrigger(float value);

    private:
        vector3<float> joyDir = {0.0f, 0.0f, 0.0f};
        float rightTrigger = 0.0f;
        float leftTrigger = 0.0f;
    };

    inline const vector3<float>& World::GetJoystickDirection()
    {
        return joyDir;
    }

    inline void World::SetJoystickDirection(const vector3<float>& dir)
    {
        joyDir = dir;
    }

    inline float World::GetRightTrigger()
    {
        return rightTrigger;
    }

    inline void World::SetRightTrigger(float value)
    {
        rightTrigger = value;
    }

    inline float World::GetLeftTrigger()
    {
        return leftTrigger;
    }

    inline void World::SetLeftTrigger(float value)
    {
        leftTrigger = value;
    }

    extern World world;

    int get_player_movement_speed(int model_id);
}
````

## File: src/ff7/defs.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "ff7.h"
#include <windows.h>
#include <stdint.h>

// kernel
void kernel2_reset_counters();
char *kernel2_add_section(uint32_t size);
char *kernel2_get_text(uint32_t section_base, uint32_t string_id, uint32_t section_offset);
void ff7_load_kernel2_wrapper(char *filename);

// menu
void ff7_menu_battle_end_sub_6C9543();
void ff7_menu_sub_71AAA3(int param_1);
int ff7_get_materia_gil(uint32_t materia);
void ff7_opcode_increase_gil_call(int param_1);
byte ff7_menu_sub_6CBCF3(uint32_t materia_id);
void ff7_menu_sub_6CC17F(uint32_t materia);
uint32_t ff7_menu_decrease_item_quantity(uint32_t item_data);
void ff7_menu_sub_6CDC09(DWORD param_1);
void ff7_battle_menu_sub_6DB0EE();
void ff7_set_battle_menu_state_data_at_full_atb(short param_1, short param_2, short menu_state);

// misc
void ff7_core_game_loop();
uint32_t get_equipment_stats(uint32_t party_index, uint32_t type);
void ff7_wm_activateapp(bool hasFocus);
int ff7_get_gamepad();
struct ff7_gamepad_status* ff7_update_gamepad_status();
void* ff7_engine_exit_game_mode(ff7_game_obj* game_object);
void ff7_on_gameover_enter();
void ff7_on_gameover_exit();
BYTE ff7_toggle_battle_field();
BYTE ff7_toggle_battle_worldmap();
bool ff7_skip_movies();
void *ff7_menu_sub_6F5C0C(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5);
void *ff7_menu_sub_6FAC38(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5);
void ff7_limit_fps();
void ff7_handle_ambient_playback();
void ff7_handle_voice_playback();
BOOL ff7_write_save_file(char slot);
int ff7_field_load_models_atoi(const char* str);
void ff7_chocobo_field_entity_60FA7D(WORD param1, short param2, short param3);
void ff7_character_regularly_field_entity_60FA7D(WORD param1, short param2, short param3);
int ff7_load_save_file(int param_1);

// file
FILE *open_lgp_file(char *filename, uint32_t mode);
void close_lgp_file(FILE *fd);
extern char lgp_names[18][256];
uint32_t lgp_chdir(char *path);
struct lgp_file *lgp_open_file(char *filename, uint32_t lgp_num);
uint32_t lgp_seek_file(uint32_t offset, uint32_t lgp_num);
uint32_t lgp_read(uint32_t lgp_num, char *dest, uint32_t size);
uint32_t lgp_read_file(struct lgp_file *file, uint32_t lgp_num, char *dest, uint32_t size);
uint32_t lgp_get_filesize(struct lgp_file *file, uint32_t lgp_num);
void close_file(struct ff7_file *file);
struct ff7_file *open_file(struct file_context *file_context, char *filename);
uint32_t __read_file(uint32_t count, void *buffer, struct ff7_file *file);
uint32_t read_file(uint32_t count, void *buffer, struct ff7_file *file);
uint32_t __read(FILE *file, char *buffer, uint32_t count);
uint32_t write_file(uint32_t count, void *buffer, struct ff7_file *file);
uint32_t get_filesize(struct ff7_file *file);
uint32_t tell_file(struct ff7_file *file);
void seek_file(struct ff7_file *file, uint32_t offset);
char *make_pc_name(struct file_context *file_context, struct ff7_file *file, char *filename);
int ff7_read_field_file(char* path);

// graphics
void destroy_d3d2_indexed_primitive(struct indexed_primitive *ip);
uint32_t ff7gl_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *_hundred_data, struct p_group *_group_data, struct polygon_data *polygon_data, struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object);
struct tex_header *sub_673F5C(struct struc_91 *struc91);
void draw_single_triangle(struct nvertex *vertices);
void sub_6B2720(struct indexed_primitive *ip);
void draw_3d_model(uint32_t current_frame, struct anim_header *anim_header, struct struc_110 *struc_110, struct hrc_data *hrc_data, struct ff7_game_obj *game_object);
void fill_light_data(struct light_data* pOutLightData, struct ff7_polygon_set *polygon_set);
void update_view_matrix(struct ff7_game_obj *game_object);

// loaders
struct anim_header *load_animation(struct file_context *file_context, char *filename);
struct battle_hrc_header *read_battle_hrc(uint32_t use_file_context, struct file_context *file_context, char *filename);
struct polygon_data *load_p_file(struct file_context *file_context, uint32_t create_lists, char *filename);
void destroy_tex_header(struct ff7_tex_header *tex_header);
struct ff7_tex_header *load_tex_file(struct file_context *file_context, char *filename);

// dsound
int ff7_dsound_create(HWND hwnd, LPGUID guid);
void ff7_dsound_release();
int ff7_dsound_createsoundbuffer(const WAVEFORMATEX *waveFormatEx);

// minigames
void ff7_condor_fix_unit_texture_load(uint32_t unk, struc_3 *struc_3);
void __fastcall ff7_snowboard_parse_model_vertices(snowboard_this* _this, void* edx, const matrix *matrix, int current_obj, int obj_type, int unk);
````

## File: src/ff7/dsound.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <windows.h>

int ff7_dsound_create(HWND hwnd, LPGUID guid)
{
  return 1; // Allow the engine to think everything went well
}

void ff7_dsound_release()
{
  // Just do nothing
}

int ff7_dsound_createsoundbuffer(const WAVEFORMATEX *waveFormatEx)
{
  return 1; // Allow the engine to think everything went well
}
````

## File: src/ff7/file.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <string.h>
#include <sys/stat.h>
#include <io.h>

#include "../ff7.h"
#include "../log.h"
#include "../redirect.h"

FILE *open_lgp_file(char *filename, uint32_t mode)
{
	char _filename[260]{ 0 };
	if(trace_all || trace_files) ffnx_trace("opening lgp file %s\n", filename);

	int redirect_status = attempt_redirection(filename, _filename, sizeof(_filename));

	if (redirect_status == -1)
	{
		strcpy(_filename, filename);
	}

	return fopen(_filename, "rb");
}

void close_lgp_file(FILE *fd)
{
	if(!fd) return;

	if(trace_all || trace_files) ffnx_trace("closing lgp file\n");

	fclose(fd);
}

// LGP names used for modpath lookup
char lgp_names[18][256] = {
	"char",
	"flevel",
	"battle",
	"magic",
	"menu",
	"world",
	"condor",
	"chocobo",
	"high",
	"coaster",
	"snowboard",
	"midi",
	"",
	"",
	"moviecam",
	"cr",
	"disc",
	"sub",
};

struct lgp_file
{
	uint32_t is_lgp_offset;
	union
	{
		uint32_t offset;
		FILE *fd;
	};
	uint32_t resolved_conflict;
};

#define NUM_LGP_FILES 64

struct lgp_file *lgp_files[NUM_LGP_FILES];
uint32_t lgp_files_index = 0;

struct lgp_file *last;

char lgp_current_dir[256];

uint32_t use_files_array = true;

int lgp_lookup_value(unsigned char c)
{
	c = tolower(c);

	if(c == '.') return -1;

	if(c < 'a' && c >= '0' && c <= '9') c += 'a' - '0';

	if(c == '_') c = 'k';
	if(c == '-') c = 'l';

	return c - 'a';
}

uint32_t lgp_chdir(char *path)
{
	uint32_t len = strlen(path);

	while(path[0] == '/' || path[0] == '\\') path++;

	memcpy(lgp_current_dir, path, len + 1);

	while(lgp_current_dir[len - 1] == '/' || lgp_current_dir[len - 1] == '\\') len--;
	lgp_current_dir[len] = 0;

	return true;
}

// original LGP open file logic, unchanged except for the LGP Tools safety net
uint32_t original_lgp_open_file(char *filename, uint32_t lgp_num, struct lgp_file *ret)
{
	uint32_t lookup_value1 = lgp_lookup_value(filename[0]);
	uint32_t lookup_value2 = lgp_lookup_value(filename[1]) + 1;
	struct lookup_table_entry *lookup_table = ff7_externals.lgp_lookup_tables[lgp_num];
	uint32_t toc_offset = lookup_table[lookup_value1 * 30 + lookup_value2].toc_offset;
	uint32_t i;

	// did we find anything in the lookup table?
	if(toc_offset)
	{
		uint32_t num_files = lookup_table[lookup_value1 * 30 + lookup_value2].num_files;

		// look for our file
		for(i = 0; i < num_files; i++)
		{
			struct lgp_toc_entry *toc_entry = &ff7_externals.lgp_tocs[lgp_num * 2][toc_offset + i - 1];

			if(!_stricmp(toc_entry->name, filename))
			{
				if(!toc_entry->conflict)
				{
					// this is the only file with this name, we're done here
					ret->is_lgp_offset = true;
					ret->offset = toc_entry->offset;
					return true;
				}
				else
				{
					struct conflict_list *conflict = &ff7_externals.lgp_folders[lgp_num].conflicts[toc_entry->conflict - 1];
					struct conflict_entry *conflict_entries = conflict->conflict_entries;
					uint32_t num_conflicts = conflict->num_conflicts;

					// there are multiple files with this name, look for our
					// current directory in the conflict table
					for(i = 0; i < num_conflicts; i++)
					{
						if(!_stricmp(conflict_entries[i].name, lgp_current_dir))
						{
							struct lgp_toc_entry *toc_entry = &ff7_externals.lgp_tocs[lgp_num * 2][conflict_entries[i].toc_index];

							// file name and directory matches, this is our file
							ret->is_lgp_offset = true;
							ret->offset = toc_entry->offset;
							ret->resolved_conflict = true;
							return true;
						}
					}

					break;
				}
			}
		}
	}

	// one last chance, the lookup table might have been broken by LGP Tools,
	// search through the entire archive
	for(i = 0; i < ((uint32_t *)ff7_externals.lgp_tocs)[lgp_num * 2 + 1]; i++)
	{
		struct lgp_toc_entry *toc_entry = &ff7_externals.lgp_tocs[lgp_num * 2][i];

		if(!_stricmp(toc_entry->name, filename))
		{
			ffnx_glitch("broken LGP file (%s), don't use LGP Tools!\n", lgp_names[lgp_num]);

			if(!toc_entry->conflict)
			{
				ret->is_lgp_offset = true;
				ret->offset = toc_entry->offset;
				return true;
			}
		}
	}

	return false;
}

// new LGP open file logic with modpath and direct mode support
struct lgp_file *lgp_open_file(char *filename, uint32_t lgp_num)
{
	struct lgp_file *ret = (lgp_file*)external_calloc(sizeof(*ret), 1);
	char tmp[512 + sizeof(basedir)];
	char _fname[_MAX_FNAME];
	char *fname = _fname;
	char ext[_MAX_EXT];
	char name[_MAX_FNAME + _MAX_EXT];

	_splitpath(filename, 0, 0, fname, ext);

	if(!direct_mode_path.empty())
	{
		_snprintf(tmp, sizeof(tmp), "%s/%s/%s/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
		ret->fd = fopen(tmp, "rb");

		if(!ret->fd)
		{
			_snprintf(tmp, sizeof(tmp), "%s/%s/%s.lgp/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
			ret->fd = fopen(tmp, "rb");
		}

		// Try to load special language named lgp files
		if(!ret->fd)
		{
			switch (lgp_num) {
				case 4: // menu
				case 5: // world
				case 15: // cr
				case 16: // disc
					_snprintf(tmp, sizeof(tmp), "%s/%s/%s_us.lgp/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
					break;
				case 8: // high
				case 10: // snowboard
					_snprintf(tmp, sizeof(tmp), "%s/%s/%s-us.lgp/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
					break;
			}
			ret->fd = fopen(tmp, "rb");
		}

		if(!ret->fd)
		{
			_snprintf(tmp, sizeof(tmp), "%s/%s/%s/%s/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], lgp_current_dir, fname, ext);
			ret->fd = fopen(tmp, "rb");
			if(ret->fd) ret->resolved_conflict = true;
		}

		if(ret->fd && (trace_all || trace_direct)) ffnx_trace("lgp_open_file: %i, %s (%s) [%s] = 0x%x\n", lgp_num, filename, lgp_current_dir, tmp, ret);
	}

	if(!ret->fd)
	{
		sprintf(name, "%s%s", fname, ext);

		if(!original_lgp_open_file(name, lgp_num, ret))
		{
			if(!direct_mode_path.empty()) ffnx_error("failed to find file %s; tried %s/%s/%s, %s/%s/%s/%s, %s/%s (LGP) (path: %s)\n", filename, direct_mode_path.c_str(), lgp_names[lgp_num], name, direct_mode_path.c_str(), lgp_names[lgp_num], lgp_current_dir, name, lgp_names[lgp_num], name, lgp_current_dir);
			else ffnx_error("failed to find file %s/%s (LGP) (path: %s)\n", lgp_names[lgp_num], name, lgp_current_dir);
			external_free(ret);
			return 0;
		}

		if(trace_all || trace_direct) ffnx_trace("lgp_open_file: %i, %s (%s) [ORIGINAL] = 0x%x\n", lgp_num, filename, lgp_current_dir, ret);
	}

	last = ret;

	if(use_files_array && !ret->is_lgp_offset)
	{
		if(lgp_files[lgp_files_index])
		{
			fclose(lgp_files[lgp_files_index]->fd);
			external_free(lgp_files[lgp_files_index]);
		}

		lgp_files[lgp_files_index] = ret;
		lgp_files_index = (lgp_files_index + 1) % NUM_LGP_FILES;
	}

	return ret;
}

/*
 * Direct LGP file access routines are used all over the place despite the nice
 * generic file interface found below in this file. Therefore we must implement
 * these in a way that works with the original code.
 */

// seek to given offset in LGP file
uint32_t lgp_seek_file(uint32_t offset, uint32_t lgp_num)
{
	if(!ff7_externals.lgp_fds[lgp_num]) return false;

	fseek(ff7_externals.lgp_fds[lgp_num], offset, SEEK_SET);

	return true;
}

// read straight from LGP file
uint32_t lgp_read(uint32_t lgp_num, char *dest, uint32_t size)
{
	if(!ff7_externals.lgp_fds[lgp_num]) return 0;

	if(last->is_lgp_offset) return fread(dest, 1, size, ff7_externals.lgp_fds[lgp_num]);

	return fread(dest, 1, size, last->fd);
}

// read from LGP file by LGP file descriptor
uint32_t lgp_read_file(struct lgp_file *file, uint32_t lgp_num, char *dest, uint32_t size)
{
	if(!ff7_externals.lgp_fds[lgp_num]) return 0;

	if(file->is_lgp_offset)
	{
		lgp_seek_file(file->offset + 24, lgp_num);
		return fread(dest, 1, size, ff7_externals.lgp_fds[lgp_num]);
	}

	return fread(dest, 1, size, file->fd);
}

// retrieve the size of a file within the LGP archive
uint32_t lgp_get_filesize(struct lgp_file *file, uint32_t lgp_num)
{
	if(file->is_lgp_offset)
	{
		uint32_t size;

		lgp_seek_file(file->offset + 20, lgp_num);
		fread(&size, 4, 1, ff7_externals.lgp_fds[lgp_num]);
		return size;
	}
	else
	{
		struct stat s;

		fstat(_fileno(file->fd), &s);

		return s.st_size;
	}
}

// close a file handle
void close_file(struct ff7_file *file)
{
	if(!file) return;

	if(file->fd)
	{
		if(!file->fd->is_lgp_offset && file->fd->fd) fclose(file->fd->fd);
		external_free(file->fd);
	}

	external_free(file->name);
	external_free(file);
}

// open file handle, target could be a file within an LGP archive or a regular
// file on disk
struct ff7_file *open_file(struct file_context *file_context, char *filename)
{
	char mangled_name[200];
	struct ff7_file *ret = (ff7_file*)external_calloc(sizeof(*ret), 1);
	char _filename[260]{ 0 };
	int redirect_status = 0;

	if (!ret) return 0;

	if(trace_all || trace_files)
	{
		if(file_context->use_lgp) ffnx_trace("open %s (LGP:%s)\n", filename, lgp_names[file_context->lgp_num]);
		else ffnx_trace("open %s (mode %i)\n", filename, file_context->mode);
	}

	if (!file_context->use_lgp)
	{
		// File was not found, but was required
		if (redirect_path_with_override(filename, _filename, sizeof(_filename)) == 1)
		{
			strcpy(_filename, filename);

			goto error;
		}
	}
	else
		// LGP files can be loaded safely from data, as Steam/eStore does not override them
		strcpy(_filename, filename);

	ret->name = (char*)external_malloc(strlen(_filename) + 1);
	strcpy(ret->name, _filename);
	memcpy(&ret->context, file_context, sizeof(*file_context));

	// file name mangler used mainly by battle module to convert PSX file names
	// to LGP-friendly PC names
	if(file_context->name_mangler)
	{
		file_context->name_mangler(_filename, mangled_name);
		strcpy(_filename, mangled_name);

		if(trace_all || trace_files) ffnx_trace("mangled name: %s\n", mangled_name);
	}

	if(file_context->use_lgp)
	{
		use_files_array = false;
		ret->fd = lgp_open_file(_filename, ret->context.lgp_num);
		use_files_array = true;
		if(!ret->fd)
		{
			if(file_context->name_mangler) ffnx_error("offset error: %s %s\n", _filename, mangled_name);
			else ffnx_error("offset error: %s\n", _filename);
			goto error;
		}

		if(!lgp_seek_file(ret->fd->offset + 24, ret->context.lgp_num))
		{
			ffnx_error("seek error: %s\n", _filename);
			goto error;
		}
	}
	else
	{
		ret->fd = (lgp_file*)external_calloc(sizeof(*ret->fd), 1);

		if(ret->context.mode == FF7_FMODE_READ) ret->fd->fd = fopen(_filename, "rb");
		else if(ret->context.mode == FF7_FMODE_READ_TEXT) ret->fd->fd = fopen(_filename, "r");
		else if(ret->context.mode == FF7_FMODE_WRITE) ret->fd->fd = fopen(_filename, "wb");
		else if(ret->context.mode == FF7_FMODE_CREATE) ret->fd->fd = fopen(_filename, "w+b");
		else ret->fd->fd = fopen(_filename, "r+b");

		if(!ret->fd->fd) goto error;
	}

	return ret;

error:
	// it's normal for save files to be missing, anything else is probably
	// going to cause trouble
	if(file_context->use_lgp || _stricmp(&_filename[strlen(_filename) - 4], ".ff7")) ffnx_error("could not open file %s\n", _filename);
	close_file(ret);
	return 0;
}

// read from file handle, returns how many bytes were actually read
uint32_t __read_file(uint32_t count, void *buffer, struct ff7_file *file)
{
	uint32_t ret = 0;

	if(!file || !count) return false;

	if(trace_all || trace_files) ffnx_trace("reading %i bytes from %s (ALT)\n", count, file->name);

	if(file->context.use_lgp) return lgp_read(file->context.lgp_num, (char*)buffer, count);

	ret = fread(buffer, 1, count, file->fd->fd);

	if(ferror(file->fd->fd))
	{
		ffnx_error("could not read from file %s (%i)\n", file->name, ret);
		return -1;
	}

	return ret;
}

// read from file handle, returns true if the read succeeds
uint32_t read_file(uint32_t count, void *buffer, struct ff7_file *file)
{
	uint32_t ret = 0;

	if(!file || !count) return false;

	if(trace_all || trace_files) ffnx_trace("reading %i bytes from %s\n", count, file->name);

	if(file->context.use_lgp) return lgp_read(file->context.lgp_num, (char*)buffer, count);

	ret = fread(buffer, 1, count, file->fd->fd);

	if(ret != count)
	{
		ffnx_error("could not read from file %s (%i)\n", file->name, ret);
		return false;
	}

	return true;
}

// read directly from a file descriptor returned by the open_file function
uint32_t __read(FILE *file, char *buffer, uint32_t count)
{
	return fread(buffer, 1, count, file);
}

// write to file handle, returns true if the write succeeds
uint32_t write_file(uint32_t count, void *buffer, struct ff7_file *file)
{
	uint32_t ret = 0;
	void *tmp = 0;

	if(!file || !count) return false;

	if(file->context.use_lgp) return false;

	if(trace_all || trace_files) ffnx_trace("writing %i bytes to %s\n", count, file->name);

	// hack to emulate win95 style writes, a NULL buffer means we should write
	// all zeroes
	if(!buffer)
	{
		tmp = driver_calloc(count, 1);
		buffer = tmp;
	}

	ret = fwrite(buffer, 1, count, file->fd->fd);

	if(tmp) driver_free(tmp);

	if(ret != count)
	{
		ffnx_error("could not write to file %s\n", file->name);
		return false;
	}

	return true;
}

// retrieve the size of a file from file handle
uint32_t get_filesize(struct ff7_file *file)
{
	if(!file) return 0;

	if(trace_all || trace_files) ffnx_trace("get_filesize %s\n", file->name);

	if(file->context.use_lgp) return lgp_get_filesize(file->fd, file->context.lgp_num);
	else
	{
		struct stat s;
		fstat(_fileno(file->fd->fd), &s);

		return s.st_size;
	}
}

// retrieve the current seek position from file handle
uint32_t tell_file(struct ff7_file *file)
{
	if(!file) return 0;

	if(trace_all || trace_files) ffnx_trace("tell %s\n", file->name);

	if(file->context.use_lgp) return 0;

	return ftell(file->fd->fd);
}

// seek to position in file
void seek_file(struct ff7_file *file, uint32_t offset)
{
	if(!file) return;

	if(trace_all || trace_files) ffnx_trace("seek %s to %i\n", file->name, offset);

	// it's not possible to seek within LGP archives
	if(file->context.use_lgp) return;

	if(fseek(file->fd->fd, offset, SEEK_SET)) ffnx_error("could not seek file %s\n", file->name);
}

// construct modpath name from file context, file handle and filename
char *make_pc_name(struct file_context *file_context, struct ff7_file *file, char *filename)
{
	uint32_t i, len;
	char *backslash;
	char* ret = (char*)external_malloc(1024);

	if(file_context->use_lgp)
	{
		if(file->fd->resolved_conflict) len = _snprintf(ret, 1024, "%s/%s/%s", lgp_names[file_context->lgp_num], lgp_current_dir, filename);
		else len = _snprintf(ret, 1024, "%s/%s", lgp_names[file_context->lgp_num], filename);
	}
	else len = _snprintf(ret, 1024, "%s", filename);

	for(i = 0; i < len; i++)
	{
		if(ret[i] == '.')
		{
			if(!_stricmp(&ret[i], ".tex")) ret[i] = 0;
			else if(!_stricmp(&ret[i], ".p")) ret[i] = 0;
			else ret[i] = '_';
		}
	}

	while(backslash = strchr(ret, '\\')) *backslash = '/';

	return ret;
}

/*###########################################################
	FF7 CHUNKED FIELD FILES
###########################################################*/

#define FF7_FIELD_NUM_SECTIONS 9
#define FF7_FIELD_OFFSET 0x2A

struct {
	uint32_t size = 0;
	byte* data;
} ff7_field_file_chunked[FF7_FIELD_NUM_SECTIONS];

int ff7_read_field_file(char* path)
{
	char filepath[256];

	if ( *ff7_externals.field_resuming_from_battle_CFF268 ) return 1;

  _splitpath(path, NULL, NULL, filepath, NULL);

  lgp_file* lgp_file = lgp_open_file(filepath, 1);
  if ( !lgp_file ) return 0;

  uint32_t size = lgp_get_filesize(lgp_file, 1);
  char* dest = (char*)driver_malloc(size);
  char* original_field_data = (char*)driver_malloc(*ff7_externals.known_field_buffer_size);
	if ( !ff7_externals.field_file_buffer )
	{
		driver_free(original_field_data);
		return 0;
	}

  lgp_read_file(lgp_file, 1, dest, size);
  ff7_externals.lzss_decode(dest, original_field_data);
	if ( dest )
  {
    driver_free(dest);
    dest = 0;
  }

	// Attempt to override part of the current field file with chunk files
	char chunk_file[1024]{0};
	uint32_t data_ptr = 0, data_len = 0, next_data_ptr = 0;
	FILE* fd;

	for (int n = 0; n < FF7_FIELD_NUM_SECTIONS; n++)
	{
		_snprintf(chunk_file, sizeof(chunk_file), "%s/%s/%s.lgp/%s.chunk.%i", basedir, direct_mode_path.c_str(), lgp_names[1], filepath, n+1);

		if ((fd = fopen(chunk_file, "rb")) != NULL)
		{
			fseek(fd, 0L, SEEK_END);
			ff7_field_file_chunked[n].size = ftell(fd);
			ff7_field_file_chunked[n].data = new byte[ff7_field_file_chunked[n].size];

			fseek(fd, 0L, SEEK_SET);
			fread(ff7_field_file_chunked[n].data, sizeof(byte), ff7_field_file_chunked[n].size, fd);

			fclose(fd);
		}
		else
		{
			data_ptr = *(uint32_t*)(original_field_data + 0x6 + 0x4 * n);

			// if this isn't the last section
			if (n < (FF7_FIELD_NUM_SECTIONS-1))
			{
				next_data_ptr = *(uint32_t*)(original_field_data + 0x6 + 0x4 * (n + 1));

				// the lgp might be lying about the length of the section! recalculate it.
				data_len = next_data_ptr - data_ptr - 0x4;
			}
			else
			{
				// there is no section after, so we have to trust it.
				data_len = *(uint32_t*)(original_field_data + data_ptr);
			}

			ff7_field_file_chunked[n].size = data_len;
			ff7_field_file_chunked[n].data = new byte[ff7_field_file_chunked[n].size];

			memcpy(ff7_field_file_chunked[n].data, original_field_data + data_ptr + 0x4, ff7_field_file_chunked[n].size);
		}
	}

	// Allocate the new field file
	driver_free(original_field_data);
	*ff7_externals.field_file_buffer = (char*)external_malloc(*ff7_externals.known_field_buffer_size);

	// Build the new field file
	*(short*)(*ff7_externals.field_file_buffer) = 0x0; // 0x0
	*(int*)(*ff7_externals.field_file_buffer + 0x2) = FF7_FIELD_NUM_SECTIONS; // 0x2
	uint32_t offset = FF7_FIELD_OFFSET;
	for (int n = 0; n < FF7_FIELD_NUM_SECTIONS; n++)
	{
		// Pointer to data section
		ff7_externals.field_file_section_ptrs[n] = offset;
		*(int*)(*ff7_externals.field_file_buffer + 0x6 + (0x4 * n)) = ff7_externals.field_file_section_ptrs[n];

		// Length of data section
		*(int*)(*ff7_externals.field_file_buffer + offset) = ff7_field_file_chunked[n].size;

		// The data
		offset += 0x4;
		memcpy(*ff7_externals.field_file_buffer + offset, ff7_field_file_chunked[n].data, ff7_field_file_chunked[n].size);
		offset += ff7_field_file_chunked[n].size;

		// Cleanup
		delete ff7_field_file_chunked[n].data;
	}

  return 1;
}
````

## File: src/ff7/graphics.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#define _USE_MATH_DEFINES
#include <math.h>
#include "../renderer.h"

#include "../ff7.h"
#include "../macro.h"
#include "../log.h"
#include "../gl.h"
#include "defs.h"

/*
 * Most of these functions are lifted from the game with only minor changes to
 * replace Direct3D calls. Modifying or even attempting to understand most of
 * this code is not recommended.
 */

void destroy_d3d2_indexed_primitive(struct indexed_primitive *ip)
{
	if(!ip) return;

	if(ip->vertices) external_free(ip->vertices);
	if(ip->indices) external_free(ip->indices);

	external_free(ip);
}

uint32_t ff7gl_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *_hundred_data, struct p_group *_group_data, struct polygon_data *polygon_data, struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object)
{
	struct indexed_primitive *ip;
	struct p_hundred *hundred_data;
	struct p_group *group_data;
	uint32_t numvert;
	uint32_t numpoly;
	uint32_t offvert;
	uint32_t offpoly;
	uint32_t offtex;
	uint32_t i;

	if(!polygon_data) return false;
	if(!polygon_set->indexed_primitives) return false;
	if(group_num >= polygon_data->numgroups) return false;

	ip = (indexed_primitive*)external_calloc(sizeof(*ip), 1);

	ip->primitivetype = RendererPrimitiveType::PT_TRIANGLES;
	ip->vertex_size = sizeof(struct nvertex);

	group_data = &polygon_data->groupdata[group_num];
	hundred_data = &polygon_data->hundredsdata[group_num];
	numvert = group_data->numvert;
	numpoly = group_data->numpoly;
	offvert = group_data->offvert;
	offpoly = group_data->offpoly;
	offtex = group_data->offtex;

	ip->vertexcount = numvert;
	ip->indexcount = numpoly * 3;
	ip->vertices = (nvertex*)external_calloc(sizeof(*ip->vertices), ip->vertexcount);
	ip->indices = (WORD*)external_calloc(sizeof(*ip->indices), ip->indexcount);

	if(polygon_data->vertextype == 0) ip->vertextype = VERTEX;
	else if(polygon_data->vertextype == 1) ip->vertextype = LVERTEX;
	else if(polygon_data->vertextype == 2) ip->vertextype = TLVERTEX;

	for(i = 0; i < numvert; i++)
	{
		if(polygon_data->vertdata) memcpy(&ip->vertices[i]._, &polygon_data->vertdata[offvert + i], sizeof(ip->vertices[i]._));
		if(polygon_data->vertexcolordata) memcpy(&ip->vertices[i].color.color, &polygon_data->vertexcolordata[offvert + i], sizeof(ip->vertices[i].color.color));
		if(group_data->textured && polygon_data->texcoorddata) memcpy(&ip->vertices[i].u, &polygon_data->texcoorddata[offtex + i], sizeof(polygon_data->texcoorddata[i]));

		if(hundred_data && (hundred_data->field_4 & BIT(V_ALPHABLEND))) ip->vertices[i].color.a = hundred_data->vertex_alpha;
	}

	for(i = 0; i < numpoly; i++)
	{
		if(polygon_data->polydata)
		{
			struct p_polygon *poly_data = &polygon_data->polydata[offpoly + i];

			ip->indices[i * 3] = poly_data->vertex1;
			ip->indices[i * 3 + 1] = poly_data->vertex2;
			ip->indices[i * 3 + 2] = poly_data->vertex3;
		}
	}

	polygon_set->indexed_primitives[group_num] = ip;

	return true;
}

void ff7gl_field_78(struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object)
{
	struct matrix_set *matrix_set;
	struct struc_49 *struc_49;
	struct p_hundred *hundred_data = NULL;
	struct p_group *group_data = NULL;
	struct matrix *matrix = NULL;
	struct struc_77 *struc_77;
	struct indexed_primitive *ip = NULL;
	struct nvertex *vertices = NULL;
	struct struc_84 *struc_84;
	struct struc_186 *struc_186;
	uint32_t instance_type = -1;
	uint32_t group_counter = 0;
	uint32_t instanced = false;
	uint32_t correct_frame = false;
	uint32_t instance_transform_mode;
	struct matrix tmp_matrix;
	struct matrix *model_matrix = 0;

	if(trace_all) ffnx_trace("dll_gfx: field_78 0x%x\n", polygon_set);

	if(!game_object->in_scene) return;

	if(!polygon_set) return;

	if(!polygon_set->field_0) return;

	if(trace_all) ffnx_trace("field_78: %s (%i groups) (0x%x)\n", polygon_set->polygon_data ? polygon_set->polygon_data->pc_name : "unknown", polygon_set->numgroups, polygon_set);

	matrix_set = polygon_set->matrix_set;

	if(matrix_set) model_matrix = matrix_set->matrix_view;

	struc_49 = &polygon_set->field_14;

	if(struc_49->field_0)
	{
		instanced = true;

		correct_frame = (struc_49->graphics_instance->frame_counter == struc_49->frame_counter);

		instance_transform_mode = struc_49->field_8;
		struc_84 = struc_49->struc_84;

		if(struc_84) instance_type = struc_84->field_4;

		if(trace_all) ffnx_trace("instanced, %s, type %i, transform %i\n", correct_frame ? "correct frame" : "wrong frame", instance_type, instance_transform_mode);
	}

	if(polygon_set->field_2C) hundred_data = polygon_set->hundred_data;
	if(polygon_set->polygon_data) group_data = polygon_set->polygon_data->groupdata;

	while(group_counter < polygon_set->numgroups)
	{
		uint32_t defer = false;
		uint32_t zsort = false;

		struc_84 = struc_49->struc_84;

		if(polygon_set->indexed_primitives) ip = polygon_set->indexed_primitives[group_counter];

		if(ip) vertices = ip->vertices;

		if(polygon_set->per_group_hundreds) hundred_data = polygon_set->hundred_data_group_array[group_counter];

		if(hundred_data)
		{
			if(game_object->field_91C && hundred_data->zsort) zsort = true;
			else if(!game_object->field_928) defer = (hundred_data->options & (BIT(V_ALPHABLEND) | BIT(V_TMAPBLEND)));
		}

		if(trace_all) ffnx_trace("group %i: %s, %s\n", group_counter, zsort ? "zsort" : "no zsort", defer ? "deferred" : "not deferred");

		if(!defer) common_setrenderstate(hundred_data, (struct game_obj *)game_object);

		if(matrix_set && matrix_set->matrix_projection) gl_set_d3dprojection_matrix(matrix_set->matrix_projection);

		if(instanced)
		{
			if(correct_frame)
			{
				while(struc_84)
				{
					if(trace_all) ffnx_trace("drawing instance 0x%x\n", struc_84);

					if(instance_type == 2)
					{
						if(instance_transform_mode == 1) matrix = &struc_84->matrix;
						else if(instance_transform_mode == 2)
						{
							multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &tmp_matrix);
							matrix = &tmp_matrix;
						}

						if(matrix && matrix_set && !zsort) gl_set_worldview_matrix(matrix);

						struc_186 = struc_84->struc_186;

						if(struc_186->polytype == 0x11) vertices = struc_186->nvertex_pointer;
						else ff7_externals.sub_671742(zsort, hundred_data, struc_186);

						if(zsort) ff7_externals.sub_665D9A(matrix, vertices, ip, hundred_data, struc_186, game_object);
						else gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, vertices, 0, ip->vertexcount, ip->indices, ip->indexcount, 0, 0, 0, polygon_set->field_4, true);
					}
					else if(defer)
					{
						struc_77 = (struct struc_77*)ff7_externals.sub_6A2865(game_object->_3dobject_pool);

						if(struc_77)
						{
							struc_77->current_group = group_counter;
							struc_77->polygon_set = (struct polygon_set *)polygon_set;
							struc_77->hundred_data = hundred_data;

							if(polygon_set->has_struc_173) memcpy(&struc_77->struc_173, polygon_set->struc_173, sizeof(*polygon_set->struc_173));

							struc_77->use_matrix = 0;
							struc_77->use_matrix_pointer = 0;

							if(instance_transform_mode == 1)
							{
								struc_77->use_matrix_pointer = 1;
								struc_77->matrix_pointer = &struc_84->matrix;
							}

							else if(instance_transform_mode == 2)
							{
								struc_77->use_matrix = 1;
								multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &struc_77->matrix);
								ff7_externals.matrix3x4(&struc_77->matrix);
							}
						}
					}
					else if(instance_type == 0)
					{
						if(instance_transform_mode == 1) matrix = &struc_84->matrix;
						else if(instance_transform_mode == 2)
						{
							multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &tmp_matrix);
							matrix = &tmp_matrix;
						}

						if(ip)
						{
							if(zsort) ff7_externals.sub_665793(matrix, 0, ip, polygon_set, hundred_data, group_data, game_object);
							else
							{
								if(matrix && matrix_set) gl_set_worldview_matrix(matrix);
								gl_draw_without_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);
							}
						}
					}
					else if(instance_type == 1)
					{
						if(instance_transform_mode == 1) matrix = &struc_84->matrix;
						else if(instance_transform_mode == 2)
						{
							multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &tmp_matrix);
							matrix = &tmp_matrix;
						}

						if(ip)
						{
							if(struc_84->struc_173.add_offsets || struc_84->struc_173.field_7)
							{
								ff7_externals.sub_68D2B8(group_counter, polygon_set, &struc_84->struc_173);
								ff7_externals.sub_6B27A9(matrix, ip, polygon_set, hundred_data, group_data, &struc_84->struc_173, game_object);
							}
							else
							{
								if(zsort) ff7_externals.sub_665793(matrix, 0, ip, polygon_set, hundred_data, group_data, game_object);
								else
								{
									ff7_externals.sub_68D2B8(group_counter, polygon_set, &struc_84->struc_173);

									if(matrix && matrix_set) gl_set_worldview_matrix(matrix);
									gl_draw_without_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);
								}
							}
						}
					}

					struc_84 = struc_84->next;
				}
			}
		}
		else
		{
			if(trace_all) ffnx_trace("drawing single\n");

			if(defer)
			{
				struc_77 = (struct struc_77*)ff7_externals.sub_6A2865(game_object->_3dobject_pool);

				struc_77->current_group = group_counter;
				struc_77->polygon_set = (struct polygon_set *)polygon_set;
				struc_77->hundred_data = hundred_data;

				if(polygon_set->has_struc_173) memcpy(&struc_77->struc_173, polygon_set->struc_173, sizeof(*polygon_set->struc_173));

				struc_77->use_matrix = 0;
				struc_77->use_matrix_pointer = 0;

				if(matrix_set && matrix_set->matrix_world)
				{
					struc_77->use_matrix = 1;
					memcpy(&struc_77->matrix, matrix_set->matrix_world, sizeof(*matrix_set->matrix_world));
				}
			}
			else
			{
				if(ip)
				{
					if(zsort) ff7_externals.sub_665793(matrix_set->matrix_world, 0, ip, polygon_set, hundred_data, group_data, game_object);
					else
					{
						if (matrix_set)	gl_set_worldview_matrix(matrix_set->matrix_world);
						if (enable_lighting)
						{					
							update_view_matrix(game_object);		
							if(polygon_set->light != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
							{
								struct light_data lightData;
								fill_light_data(&lightData, polygon_set);
								gl_draw_with_lighting(ip, polygon_set->polygon_data, &lightData, polygon_set->field_4);
							} else 	gl_draw_with_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);						
						} else 
						{
							if(polygon_set->light != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
							{
								struct light_data lightData;
								fill_light_data(&lightData, polygon_set);
								update_view_matrix(game_object);
								gl_draw_without_lighting(ip, polygon_set->polygon_data, &lightData, polygon_set->field_4);
							} else gl_draw_without_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);
						}
					}
				}
			}
		}

		if(hundred_data) hundred_data = &hundred_data[1];
		if(group_data) group_data = &group_data[1];

		group_counter++;
	}
}

struct tex_header *sub_673F5C(struct struc_91 *struc91)
{
	if(trace_all) ffnx_trace("sub_673F5C: 0x%x\n", struc91);

	if(struc91->field_0 == 2) ffnx_glitch_once("unsupported framebuffer operation\n");

	return make_framebuffer_tex(struc91->width, struc91->height, struc91->x_offset, struc91->y_offset, struc91->width * struc91->xscale, struc91->height * struc91->yscale, struc91->color_key);
}

void draw_single_triangle(struct nvertex *vertices)
{
	WORD indices[] = {0, 1, 2};

	newRenderer.bindVertexBuffer(vertices, 0, 3);
	newRenderer.bindIndexBuffer(indices, 3);

	newRenderer.isTLVertex(true);

	newRenderer.draw();
}

void sub_6B2720(struct indexed_primitive *ip)
{
	gl_draw_indexed_primitive(ip->primitivetype, TLVERTEX, ip->vertices, 0, ip->vertexcount, ip->indices, ip->indexcount, 0, 0, 0, true, true);
}

void draw_3d_model(uint32_t current_frame, struct anim_header *anim_header, struct struc_110 *struc_110, struct hrc_data *hrc_data, struct ff7_game_obj *game_object)
{
	struct anim_frame *anim_frame;
	struct stack *matrix_stack;
	struct matrix *root_matrix;
	void (*root_animation_sub)(struct matrix *, struct anim_frame *, struct anim_header *, struct hrc_data *);
	void (*frame_animation_sub)(uint32_t, struct matrix *, vector3<float> *, struct anim_frame *, struct anim_header *, struct hrc_bone *, struct hrc_data *);

	if(!anim_header) return;
	if(!hrc_data) return;
	if(current_frame >= anim_header->num_frames) return;

	anim_frame = &anim_header->anim_frames[current_frame];

	if(anim_header->use_matrix_array)
	{
		anim_header->current_matrix_array = &anim_header->matrix_array[(anim_header->num_bones + 1) * current_frame];
	}

	matrix_stack = game_object->matrix_stack1;

	ff7_externals.stack_push(matrix_stack);

	root_matrix = (matrix*)ff7_externals.stack_top(matrix_stack);

	if(hrc_data->field_A4 && *hrc_data->field_A4)
	{
		root_animation_sub = ff7_externals._root_animation;
		frame_animation_sub = ff7_externals._frame_animation;
	}
	else
	{
		root_animation_sub = ff7_externals.root_animation;
		frame_animation_sub = ff7_externals.frame_animation;
	}

	root_animation_sub(root_matrix, anim_frame, anim_header, hrc_data);

	if(hrc_data->flags & 0x400) memcpy(&hrc_data->field_24, root_matrix, sizeof(*root_matrix));

	if(struc_110)
	{
		struct matrix scale_matrix;

		if(struc_110->scale_factor != 1.0f)
		{
			float scale_factor = struc_110->scale_factor;

			root_matrix->_41 *= scale_factor;
			root_matrix->_42 *= scale_factor;
			root_matrix->_43 *= scale_factor;

			uniform_scaling_matrix(scale_factor, &scale_matrix);
			multiply_matrix_unary(root_matrix, &scale_matrix);
		}

		if(struc_110->scale.x != 1.0f || struc_110->scale.y != 1.0f || struc_110->scale.z != 1.0f)
		{
			scaling_matrix(&struc_110->scale, &scale_matrix);
			multiply_matrix_unary(root_matrix, &scale_matrix);

			root_matrix->_41 *= struc_110->scale.x;
			root_matrix->_42 *= struc_110->scale.y;
			root_matrix->_43 *= struc_110->scale.z;
		}

		if(*ff7_externals.model_mode & MDL_USE_STRUC110_MATRIX) multiply_matrix_unary(root_matrix, &struc_110->matrix);

		if(struc_110->rotation.y != 0.0) rotate_matrix_y(DEG2RAD(struc_110->rotation.y), root_matrix);
		if(struc_110->rotation.x != 0.0) rotate_matrix_x(DEG2RAD(struc_110->rotation.x), root_matrix);
		if(struc_110->rotation.z != 0.0) rotate_matrix_z(DEG2RAD(struc_110->rotation.z), root_matrix);

		root_matrix->_41 += struc_110->position.x;
		root_matrix->_42 += struc_110->position.y;
		root_matrix->_43 += struc_110->position.z;
	}

	if(hrc_data->flags & 0x800) memcpy(&hrc_data->field_64, root_matrix, sizeof(*root_matrix));

	if(hrc_data->flags & 0x2000 && struc_110->bone_positions)
	{
		struc_110->bone_positions[0].x = root_matrix->_41;
		struc_110->bone_positions[0].y = root_matrix->_42;
		struc_110->bone_positions[0].z = root_matrix->_43;
	}

	if(hrc_data->bone_list)
	{
		struct list_node *bone_list_node;

		LIST_FOR_EACH(bone_list_node, hrc_data->bone_list)
		{
			struct bone_list_member *bone_list_member = (struct bone_list_member *)&bone_list_node->object;

			if(bone_list_member->bone_type == 1)
			{
				uint32_t bone_index = bone_list_member->bone_index;
				struct hrc_bone *bone = &hrc_data->bones[bone_index];
				struct matrix *parent_matrix;
				struct matrix *bone_matrix;
				vector3<float> *frame_rotation;
				struct matrix local_matrix;
				struct matrix eye_matrix;
				struct matrix *matrix;
				vector3<float> dummy_point = {0.0f, 0.0f, 0.0f};

				parent_matrix = (struct matrix*)ff7_externals.stack_top(matrix_stack);
				ff7_externals.stack_push(matrix_stack);
				bone_matrix = (struct matrix*)ff7_externals.stack_top(matrix_stack);

				if(anim_header->num_bones <= bone_index) frame_rotation = &dummy_point;
				else frame_rotation = &anim_frame->data[bone_index];

				frame_animation_sub(bone_index, &local_matrix, frame_rotation, anim_frame, anim_header, bone, hrc_data);

				multiply_matrix(&local_matrix, parent_matrix, bone_matrix);

				if(*ff7_externals.model_mode & MDL_USE_CAMERA_MATRIX)
				{
					if(hrc_data->flags & 0x4000 && struc_110->bone_matrices) matrix = &struc_110->bone_matrices[bone_index + 1];
					else matrix = &eye_matrix;

					multiply_matrix(bone_matrix, game_object->camera_matrix, matrix);

					matrix->_14 = 0.0f;
					matrix->_24 = 0.0f;
					matrix->_34 = 0.0f;
					matrix->_44 = 1.0f;

					if(hrc_data->flags & 0x2000 && struc_110->bone_positions)
					{
						struc_110->bone_positions[bone_index + 1].x = bone_matrix->_41;
						struc_110->bone_positions[bone_index + 1].y = bone_matrix->_42;
						struc_110->bone_positions[bone_index + 1].z = bone_matrix->_43;
					}
				}
				else matrix = bone_matrix;

				if(bone->rsd_array)
				{
					uint32_t i;
					struct rsd_array_member *rsd_array_member;

					for(i = 0, rsd_array_member = bone->rsd_array; i < bone->num_rsd; i++, rsd_array_member++)
					{
						struct ff7_polygon_set *polygon_set;

						if(!rsd_array_member->rsd_data) continue;

						polygon_set = rsd_array_member->rsd_data->polygon_set;

						if(!polygon_set) continue;

						common_setmatrix(0, matrix, polygon_set->matrix_set, (struct game_obj *)game_object);
						if(polygon_set->matrix_set) polygon_set->matrix_set->matrix_view = (struct matrix*)external_calloc(sizeof(struct matrix), 1);
						common_setmatrix(1, bone_matrix, polygon_set->matrix_set, (struct game_obj *)game_object);

						if(hrc_data->flags & 0x2000000)
						{
							struct ff7_light *light = polygon_set->light;

							if(light)
							{
								if(polygon_set->matrix_set) light->matrix_pointer = polygon_set->matrix_set->matrix_world;
								else light->matrix_pointer = 0;

								if(light->field_138)
								{
									struct matrix tmp;

									multiply_matrix(bone_matrix, &light->normal_matrix, &tmp);

									ff7_externals.sub_69C69F(&tmp, light);
								}
								else ff7_externals.sub_69C69F(bone_matrix, light);

								common_externals.generic_light_polygon_set((struct polygon_set *)polygon_set, (struct light *)light);
							}
						}

						if(hrc_data->field_4 && hrc_data->flags & 0x100000) ff7gl_field_78(polygon_set, game_object);
					}
				}
			}
			if(bone_list_member->bone_type == 2) ff7_externals.stack_pop(matrix_stack);
		}
	}

	ff7_externals.stack_pop(matrix_stack);
}

void fill_light_data(struct light_data* lightData, struct ff7_polygon_set *polygon_set)
{
	lightData->global_light_color = polygon_set->light->global_light_color_abgr_norm;
	lightData->light_dir_1 = polygon_set->light->color_1->point;
	lightData->light_color_1 = polygon_set->light->color_1->d3dcol;
	lightData->light_dir_2 = polygon_set->light->color_2->point;
	lightData->light_color_2 = polygon_set->light->color_2->d3dcol;
	lightData->light_dir_3 = polygon_set->light->color_3->point;
	lightData->light_color_3 = polygon_set->light->color_3->d3dcol;

	lightData->scripted_light_color = {1.0, 1.0, 1.0, 1.0};

	if ((polygon_set->light->flags & 4) != 0)
	{
		lightData->scripted_light_color.r = polygon_set->light->color.r / 255.0f;
		lightData->scripted_light_color.g = polygon_set->light->color.g / 255.0f;
		lightData->scripted_light_color.b = polygon_set->light->color.b / 255.0f;
	}
}

void ff7_get_field_view_matrix(struct matrix *outViewMatrix)
{
	struct matrix viewMatrix;
	identity_matrix(&viewMatrix);

	byte *level_data = *ff7_externals.field_level_data_pointer;
	if (!level_data)
	{
		return;
	}

	ff7_camdata *field_camera_data = *ff7_externals.field_camera_data;
	if (!field_camera_data)
	{
		return;
	}

	vector3<float> vx = {(float)(field_camera_data->eye.x), (float)(field_camera_data->eye.y), (float)(field_camera_data->eye.z)};
	vector3<float> vy = {(float)(field_camera_data->target.x), (float)(field_camera_data->target.y), (float)(field_camera_data->target.z)};
	vector3<float> vz = {(float)(field_camera_data->up.x), (float)(field_camera_data->up.y), (float)(field_camera_data->up.z)};

	divide_vector(&vx, 4096.0f, &vx);
	divide_vector(&vy, 4096.0f, &vy);
	divide_vector(&vz, 4096.0f, &vz);

	float ox = static_cast<float>(field_camera_data->position.x);
	float oy = static_cast<float>(field_camera_data->position.y);
	float oz = static_cast<float>(field_camera_data->position.z);

	float tx = ox;
	float ty = oy;
	float tz = oz;

	viewMatrix._11 = vx.x;
	viewMatrix._21 = vx.y;
	viewMatrix._31 = vx.z;
	viewMatrix._12 = vy.x;
	viewMatrix._22 = vy.y;
	viewMatrix._32 = vy.z;
	viewMatrix._13 = vz.x;
	viewMatrix._23 = vz.y;
	viewMatrix._33 = vz.z;
	viewMatrix._41 = tx;
	viewMatrix._42 = ty;
	viewMatrix._43 = tz;
	viewMatrix._44 = 1.0;

	memcpy(outViewMatrix, &viewMatrix, sizeof(matrix));
}

void update_view_matrix(struct ff7_game_obj *game_object)
{
	if (newRenderer.isViewMatrixSet()) return;

	struct game_mode *mode = getmode_cached();

	struct matrix viewMatrix;
	struct matrix *pViewMatrix = &viewMatrix;

	switch(mode->driver_mode)
	{
		case MODE_FIELD:
			// Get Field view matrix
			ff7_get_field_view_matrix(&viewMatrix);
			newRenderer.setViewMatrix(&viewMatrix);
			break;
		case MODE_WORLDMAP:
		{
			if (enable_worldmap_external_mesh)
			{
				int world_pos_x = ff7_externals.world_player_pos_E04918->x;
				int world_pos_y = ff7_externals.world_player_pos_E04918->y;
				int world_pos_z = ff7_externals.world_player_pos_E04918->z;

				auto rot_matrix = ff7_externals.world_camera_direction_matrix_DFC448;
				auto tr_matrix = ff7_externals.world_camera_position_matrix_DE6A20;

				float cameraRotationMatrixFloat[16];

				cameraRotationMatrixFloat[0] = rot_matrix->r3_sub_matrix[0][0] / 4096.0f;
				cameraRotationMatrixFloat[1] = rot_matrix->r3_sub_matrix[0][1] / 4096.0f;
				cameraRotationMatrixFloat[2] = rot_matrix->r3_sub_matrix[0][2] / 4096.0f;
				cameraRotationMatrixFloat[3] = 0.0f;

				cameraRotationMatrixFloat[4] = rot_matrix->r3_sub_matrix[1][0] / 4096.0f;
				cameraRotationMatrixFloat[5] = rot_matrix->r3_sub_matrix[1][1] / 4096.0f;
				cameraRotationMatrixFloat[6] = rot_matrix->r3_sub_matrix[1][2] / 4096.0f;
				cameraRotationMatrixFloat[7] = 0.0f;

				cameraRotationMatrixFloat[8] = rot_matrix->r3_sub_matrix[2][0] / 4096.0f;
				cameraRotationMatrixFloat[9] = rot_matrix->r3_sub_matrix[2][1] / 4096.0f;
				cameraRotationMatrixFloat[10] = rot_matrix->r3_sub_matrix[2][2] / 4096.0f;
				cameraRotationMatrixFloat[11] = 0.0f;

				cameraRotationMatrixFloat[12] = 0.0f;
				cameraRotationMatrixFloat[13] = 0.0f;
				cameraRotationMatrixFloat[14] = 0.0f;
				cameraRotationMatrixFloat[15] = 1.0f;

				float cameraTranslationMatrixFloat[16];
				bx::mtxTranslate(cameraTranslationMatrixFloat, 0, 0, -tr_matrix->position[2]);

				float cameraTranslationMatrixFloat2[16];
				bx::mtxTranslate(cameraTranslationMatrixFloat2, world_pos_x, world_pos_y, world_pos_z);

				float tmp[16];
				bx::mtxMul(tmp, cameraTranslationMatrixFloat, cameraRotationMatrixFloat);

				float cameraMatrixFloat[16];
				bx::mtxMul(cameraMatrixFloat, tmp, cameraTranslationMatrixFloat2);

				float viewMatrixFloat[16];
				bx::mtxInverse(viewMatrixFloat, cameraMatrixFloat);

				struct matrix viewMatrix;
				::memcpy(&viewMatrix.m[0][0], viewMatrixFloat, sizeof(viewMatrix.m));

				newRenderer.setViewMatrix(&viewMatrix);
			}
			else
			{
				pViewMatrix = game_object->camera_matrix;
				if (pViewMatrix)
				{
					newRenderer.setViewMatrix(pViewMatrix);
				}
			}
		}
			break;
		default:
			pViewMatrix = game_object->camera_matrix;
			if (pViewMatrix)
			{
				newRenderer.setViewMatrix(pViewMatrix);
			}
			break;
	}
};
````

## File: src/ff7/kernel.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../ff7.h"
#include "../log.h"

#define FF7_KERNEL_NUM_SECTIONS 27

// KERNEL2
char *kernel2_sections[20];
uint32_t kernel2_section_counter;

void kernel2_reset_counters()
{
	uint32_t i;

	if(trace_all) ffnx_trace("kernel2 reset\n");

	for(i = 0; i < kernel2_section_counter; i++) external_free(kernel2_sections[i]);

	kernel2_section_counter = 0;
}

char *kernel2_add_section(uint32_t size)
{
	char *ret = (char*)external_malloc(size);

	if(trace_all) ffnx_trace("kernel2 add section %i (%i)\n", kernel2_section_counter, size);

	kernel2_sections[kernel2_section_counter++] = ret;

	return ret;
}

char *kernel2_get_text(uint32_t section_base, uint32_t string_id, uint32_t section_offset)
{
	char *section = kernel2_sections[section_base + section_offset];

	if(trace_all) ffnx_trace("kernel2 get text (%i+%i:%i)\n", section_base, section_offset, string_id);

	return &section[((WORD *)section)[string_id]];
}

// ENGINE

void ff7_load_kernel2_wrapper(char *filename)
{
  ff7_externals.kernel_load_kernel2(filename);

	char chunk_file[1024]{0};
	uint32_t chunk_size = 0;
	FILE* fd;

	for (int n = 0; n < FF7_KERNEL_NUM_SECTIONS; n++)
	{
		_snprintf(chunk_file, sizeof(chunk_file), "%s/%s/kernel/kernel.bin.chunk.%i", basedir, direct_mode_path.c_str(), n+1);

		if ((fd = fopen(chunk_file, "rb")) != NULL)
		{
			fseek(fd, 0L, SEEK_END);
			chunk_size = ftell(fd);
			fseek(fd, 0L, SEEK_SET);

			if (0 <= n && n <= 8)
				fread(ff7_externals.kernel_1to9_sections[n], sizeof(byte), chunk_size, fd);
			else
				fread(kernel2_sections[n-9], sizeof(byte), chunk_size, fd);

			ffnx_trace("%s: kernel section %i overridden with %s\n", __func__, n+1, chunk_file);
			fclose(fd);
		}
		else if (trace_direct)
			ffnx_trace("%s: could not find %s\n", __func__, chunk_file);
	}
}
````

## File: src/ff7/loaders.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../ff7.h"
#include "../log.h"

#include "defs.h"

uint32_t get_frame_data_size(struct anim_header *anim_header)
{
	if(!anim_header) return 0;

	return (anim_header->num_bones * sizeof(vector3<float>) + sizeof(struct anim_frame_header)) * anim_header->num_frames;
}

// load .a file, save modpath name somewhere we can retrieve it later
struct anim_header *load_animation(struct file_context *file_context, char *filename)
{
	struct ff7_file *file = open_file(file_context, filename);
	struct anim_header *ret = NULL;
	uint32_t size;
	uint32_t i;
	uint32_t data_pointer;

	if(trace_all || trace_loaders)
	{
		if(file_context->use_lgp) ffnx_trace("reading animation file: %s/%s\n", lgp_names[file_context->lgp_num], filename);
		else ffnx_trace("reading animation file: %s\n", filename);
	}

	if(!file) goto error;

	ret = (anim_header*)common_externals.alloc_read_file(sizeof(*ret), 1, (struct file *)file);

	if(!ret) goto error;
	if(ret->version.version != 1) goto error;

	ret->use_matrix_array = false;
	ret->matrix_array = 0;
	ret->current_matrix_array = 0;

	size = get_frame_data_size(ret);
	if(!size) goto error;

	ret->frame_data = common_externals.alloc_read_file(size, 1, (struct file *)file);
	if(!ret->frame_data) goto error;

	ret->anim_frames = (anim_frame*)external_calloc(sizeof(struct anim_frame), ret->num_frames);

	data_pointer = (uint32_t)ret->frame_data;

	for(i = 0; i < ret->num_frames; i++)
	{
		ret->anim_frames[i].header = (anim_frame_header *)data_pointer;
		data_pointer += sizeof(struct anim_frame_header);
		ret->anim_frames[i].data = (vector3<float> *)data_pointer;
		data_pointer += sizeof(vector3<float>) * ret->num_bones;
	}

	ret->file.pc_name = make_pc_name(file_context, file, filename);

	close_file(file);
	return ret;

error:
	ff7_externals.destroy_animation(ret);
	close_file(file);
	return 0;
};

// load battle HRC file (does not save modpath name)
struct battle_hrc_header *read_battle_hrc(uint32_t use_file_context, struct file_context *file_context, char *filename)
{
	struct battle_hrc_header *ret;
	struct battle_chdir_struc olddir;
	char hrc_filename[200];
	uint32_t size;

	if(use_file_context) ff7_externals.battle_context_chdir(file_context, &olddir);
	else ff7_externals.battle_regular_chdir(&olddir);

	ff7_externals.swap_extension("D", filename, hrc_filename);

	if(trace_all || trace_loaders)
	{
		if(file_context->use_lgp) ffnx_trace("reading battle hrc file: %s/%s\n", lgp_names[file_context->lgp_num], hrc_filename);
		else ffnx_trace("reading battle hrc file: %s\n", hrc_filename);
	}

	ret = (battle_hrc_header*)common_externals.alloc_get_file(file_context, &size, hrc_filename);

	if(size < sizeof(*ret))
	{
		ff7_externals.destroy_battle_hrc(false, ret);
		return 0;
	}

	ret->bone_data = 0;

	if(ret->bones > 0) ret->bone_data = (struct battle_hrc_bone *)&ret[1];

	if(use_file_context) ff7_externals.battle_context_olddir(file_context, &olddir);
	else ff7_externals.battle_regular_olddir(&olddir);

	return ret;
}

// load .p file, save modpath name somewhere we can retrieve it later
struct polygon_data *load_p_file(struct file_context *file_context, uint32_t create_lists, char *filename)
{
	struct polygon_data *ret = ff7_externals.create_polygon_data(false, 0);
	struct ff7_file *file = open_file(file_context, filename);

	if(trace_all || trace_loaders)
	{
		if(file_context->use_lgp) ffnx_trace("reading p file: %s/%s\n", lgp_names[file_context->lgp_num], filename);
		else ffnx_trace("reading p file: %s\n", filename);
	}

	if(!file) goto error;
	if(!read_file(sizeof(*ret), ret, file)) goto error;

	ret->vertdata = 0;
	ret->normaldata = 0;
	ret->field_48 = 0;
	ret->texcoorddata = 0;
	ret->vertexcolordata = 0;
	ret->polycolordata = 0;
	ret->edgedata = 0;
	ret->polydata = 0;
	ret->pc_name = make_pc_name(file_context, file, filename);
	ret->field_64 = 0;
	ret->hundredsdata = 0;
	ret->groupdata = 0;
	ret->lists = 0;
	ret->boundingboxdata = 0;
	ret->normindextabledata = 0;

	if(ret->version != 1)
	{
		ffnx_error("invalid version in polygon file %s\n", filename);
		goto error;
	}

	if(ret->field_2C) ffnx_unexpected("oops, missed some .p data\n");

	ret->vertdata = (vector3<float>*)common_externals.alloc_read_file(sizeof(*ret->vertdata), ret->numverts, (struct file *)file);
	ret->normaldata = (vector3<float>*)common_externals.alloc_read_file(sizeof(*ret->normaldata), ret->numnormals, (struct file *)file);
	ret->field_48 = (vector3<float>*)common_externals.alloc_read_file(sizeof(*ret->field_48), ret->field_14, (struct file *)file);
	ret->texcoorddata = (struct texcoords*)common_externals.alloc_read_file(sizeof(*ret->texcoorddata), ret->numtexcoords, (struct file *)file);
	ret->vertexcolordata = (uint32_t*)common_externals.alloc_read_file(sizeof(*ret->vertexcolordata), ret->numvertcolors, (struct file *)file);
	ret->polycolordata = (uint32_t*)common_externals.alloc_read_file(sizeof(*ret->polycolordata), ret->numpolys, (struct file *)file);
	ret->edgedata = (struct p_edge*)common_externals.alloc_read_file(sizeof(*ret->edgedata), ret->numedges, (struct file *)file);
	ret->polydata = (struct p_polygon*)common_externals.alloc_read_file(sizeof(*ret->polydata), ret->numpolys, (struct file *)file);
	external_free(common_externals.alloc_read_file(sizeof(struct p_polygon), ret->field_28, (struct file *)file));
	ret->field_64 = common_externals.alloc_read_file(3, ret->field_2C, (struct file *)file);
	ret->hundredsdata = (struct p_hundred*)common_externals.alloc_read_file(sizeof(*ret->hundredsdata), ret->numhundreds, (struct file *)file);
	ret->groupdata = (struct p_group*)common_externals.alloc_read_file(sizeof(*ret->groupdata), ret->numgroups, (struct file *)file);
	ret->boundingboxdata = (struct boundingbox*)common_externals.alloc_read_file(sizeof(*ret->boundingboxdata), ret->numboundingboxes, (struct file *)file);
	if(ret->has_normindextable) ret->normindextabledata = (uint32_t*)common_externals.alloc_read_file(sizeof(*ret->normindextabledata), ret->numverts, (struct file *)file);

	if(create_lists) ff7_externals.create_polygon_lists(ret);

	close_file(file);
	return ret;

error:
	ff7_externals.free_polygon_data(ret);
	close_file(file);
	return 0;
}

void destroy_tex_header(struct ff7_tex_header *tex_header)
{
	if(!tex_header) return;

	if((uint32_t)tex_header->file.pc_name > 32) external_free(tex_header->file.pc_name);

	external_free(tex_header->old_palette_data);
	external_free(tex_header->palette_colorkey);
	external_free(tex_header->tex_format.palette_data);
	external_free(tex_header->image_data);

	external_free(tex_header);
}

// load .tex file, save modpath name somewhere we can retrieve it later
struct ff7_tex_header *load_tex_file(struct file_context *file_context, char *filename)
{
	struct ff7_tex_header *ret = (struct ff7_tex_header *)common_externals.create_tex_header();
	struct ff7_file *file = open_file(file_context, filename);

	if(!file) goto error;
	if(!read_file(sizeof(*ret), ret, file)) goto error;

	ret->image_data = 0;
	ret->old_palette_data = 0;
	ret->palette_colorkey = 0;
	ret->tex_format.palette_data = 0;

	if(ret->version != 1) goto error;
	else
	{
		if(ret->tex_format.use_palette)
		{
			ret->tex_format.palette_data = (uint32_t*)common_externals.alloc_read_file(4, ret->tex_format.palette_size, (struct file *)file);
			if(!ret->tex_format.palette_data) goto error;
		}

		ret->image_data = (unsigned char*)common_externals.alloc_read_file(ret->tex_format.bytesperpixel, ret->tex_format.width * ret->tex_format.height, (struct file *)file);
		if(!ret->image_data) goto error;

		if(ret->use_palette_colorkey)
		{
			ret->palette_colorkey = (char*)common_externals.alloc_read_file(1, ret->palettes, (struct file *)file);
			if(!ret->palette_colorkey) goto error;
		}
	}

	ret->file.pc_name = make_pc_name(file_context, file, filename);

	close_file(file);
	return ret;

error:
	destroy_tex_header(ret);
	close_file(file);
	return 0;
}
````

## File: src/ff7/menu.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../ff7.h"
#include "../log.h"
#include "../achievement.h"
#include "../gamehacks.h"

void ff7_menu_battle_end_sub_6C9543()
{
    ((void (*)())ff7_externals.menu_battle_end_sub_6C9543)();

    if(*ff7_externals.menu_battle_end_mode == 0){
        if (trace_all || trace_achievement)
            ffnx_trace("%s - trying to unlock achievement for battle won and weapons\n", __func__);
        g_FF7SteamAchievements->unlockBattleWonAchievement(*ff7_externals.battle_formation_id);
    }

    if(*ff7_externals.menu_battle_end_mode == 1){
        if (trace_all || trace_achievement)
            ffnx_trace("%s - trying to unlock achievement for first limit, cait sith, character level, and master materia\n", __func__);

        g_FF7SteamAchievements->unlockCaitSithLastLimitBreakAchievement(ff7_externals.savemap->chars);
        g_FF7SteamAchievements->unlockCharacterLevelAchievement(ff7_externals.savemap->chars);
        g_FF7SteamAchievements->unlockMasterMateriaAchievement(ff7_externals.savemap->chars);
    }
    if(*ff7_externals.menu_battle_end_mode == 3){
        if (trace_all || trace_achievement)
            ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);
        g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil);
    }
}

int ff7_get_materia_gil(uint32_t materia)
{
    int materiaGil = ((int (*)(uint32_t))ff7_externals.get_materia_gil)(materia);

    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);

    g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil + materiaGil);
    return materiaGil;
}

// called when selling an item
void ff7_opcode_increase_gil_call(int gilObtained)
{
    if (ff7_externals.savemap->gil + gilObtained < ff7_externals.savemap->gil)
        ff7_externals.savemap->gil = -1;
    else
        ff7_externals.savemap->gil = ff7_externals.savemap->gil + gilObtained;

    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);

    g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil);
};

byte ff7_menu_sub_6CBCF3(uint32_t materia_id)
{
    byte returnValue = ((byte(*)(uint32_t))ff7_externals.menu_sub_6CBCF3)(materia_id);

    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for getting materia\n", __func__);

    g_FF7SteamAchievements->unlockGotMateriaAchievement(materia_id);

    return returnValue;
}

void ff7_menu_sub_6CC17F(uint32_t materia)
{
    ((void (*)(uint32_t))ff7_externals.menu_sub_6CC17F)(materia);

    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for getting materia\n", __func__);

    g_FF7SteamAchievements->unlockGotMateriaAchievement(materia & 0xFF);
}

uint32_t ff7_menu_decrease_item_quantity(uint32_t item_used)
{
    uint32_t item_id;
    uint32_t prevIndex;
    uint32_t item_quantity;
    WORD local_c;
    int index=0;

    WORD *party_item_slots = ff7_externals.savemap->items;
    item_id = item_used & 0x1FF;
    item_quantity = (item_used & 0xFFFF) >> 9;
    prevIndex = item_id;

    while (!(((WORD)party_item_slots[index] != -1) &&
            (prevIndex = (WORD)party_item_slots[index] & 0x1ff, item_id == prevIndex)))
    {
        if (index >= 320)
            return prevIndex & 0xFFFF0000 | 0xFFFF;

        prevIndex = index;
        index = index + 1;
    }
    if (item_quantity < (party_item_slots[index] >> 9))
    {
        local_c = (WORD)(item_used | (item_quantity << 9));
        item_id = ((party_item_slots[index] >> 9) - item_quantity) * 512 | item_id;
        party_item_slots[index] = (WORD)item_id;
    }
    else
    {
        local_c = party_item_slots[index];
        item_id = 0;
        party_item_slots[index] = 0xFFFF;
    }
    g_FF7SteamAchievements->unlockLastLimitBreakAchievement(item_used & 0x1FF);
    return item_id & 0xFFFF0000 | (uint32_t)local_c;
}

void dispatchAttackCommand(){
    char* character = (char*)ff7_externals.menu_objects + 0x2CBC; //Character attacking
    char* attack = (char*)ff7_externals.gamepad_status + 0xCA8 + (*character * 6); //Their equipped attack
    *ff7_externals.issued_command_id = *attack;
    *ff7_externals.issued_action_target_type = 0;
    *ff7_externals.issued_action_target_index = 4;
    ((void(*)())ff7_externals.dispatch_chosen_battle_action)();
}

void ff7_battle_menu_sub_6DB0EE(){
    ((void(*)())ff7_externals.battle_sub_6DB0EE)();
    if(gamehacks.isAutoAttack() && (*ff7_externals.battle_menu_state >= 0 && *ff7_externals.battle_menu_state < 19)){
        dispatchAttackCommand();
    }
}

void ff7_set_battle_menu_state_data_at_full_atb(short param_1, short param_2, short menu_state){
    if(gamehacks.isAutoAttack())
    {
        dispatchAttackCommand();
    }
    else{
        ((void(*)(short, short, short))ff7_externals.set_battle_menu_state_data)(param_1, param_2, menu_state);
    }
}
````

## File: src/ff7/minigames.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <stdint.h>

#include "../ff7.h"
#include "../globals.h"

void ff7_condor_fix_unit_texture_load(uint32_t unk, struc_3 *struc_3)
{
  ff7_externals.make_struc3(unk, struc_3);

  // tell the game engine the files live inside the lgp file
  if ( *ff7_externals.condor_uses_lgp )
  {
    struc_3->file_context.use_lgp = 1;
    struc_3->file_context.lgp_num = 6;
    struc_3->file_context.name_mangler = 0;
  }
}

void __fastcall ff7_snowboard_parse_model_vertices(snowboard_this* _this, void* edx, const matrix *matrix, int current_obj, int obj_type, int unk)
{
  vector3<float> vertex;
  point4d *point;
  tmd_object *tmd_obj;

  if ( current_obj >= 0 && current_obj < _this->num_objects )
  {
    point = (point4d *)ff7_externals.battle_sub_661000(0);
    tmd_obj = (tmd_object *)(&_this->model_data->tmdobjectlist + 7 * current_obj);
    ff7_externals.sub_733479((void*)*((DWORD*)*ff7_externals.snowboard_global_object_off_926290 + 0x9D), matrix);

    for (int32_t i = 0; i < tmd_obj->nverts; ++i )
    {
      if (_this->model_data->tmdheader.version == 0xFF)
      {
        vertex.x = ((tmd_vertex_float*)tmd_obj->offsetverts)[i].vx;
        vertex.y = ((tmd_vertex_float*)tmd_obj->offsetverts)[i].vy;
        vertex.z = ((tmd_vertex_float*)tmd_obj->offsetverts)[i].vz;
      }
      else
      {
        vertex.x = (float)((tmd_vertex*)tmd_obj->offsetverts)[i].vx;
        vertex.y = (float)((tmd_vertex*)tmd_obj->offsetverts)[i].vy;
        vertex.z = (float)((tmd_vertex*)tmd_obj->offsetverts)[i].vz;
      }

      ff7_externals.sub_733564((void*)*((DWORD*)*ff7_externals.snowboard_global_object_off_926290 + 0x9D), &vertex, &point[i + 1]);
    }

    switch ( obj_type )
    {
      case 0:
        ff7_externals.sub_7322D6((tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
        break;
      case 1:
        ff7_externals.sub_732429((tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
        break;
      case 2:
        ff7_externals.sub_732BB9((tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
        break;
      case 3:
        ff7_externals.sub_732546(_this, (tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
        break;
      default:
        return;
    }
  }
}
````

## File: src/ff7/misc.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <stdint.h>

#include "defs.h"
#include "battle/camera.h"
#include "field/camera.h"
#include "world/camera.h"
#include "world/world.h"

#include "../audio.h"
#include "../gamepad.h"
#include "../gamehacks.h"
#include "../joystick.h"
#include "../music.h"
#include "../ff7.h"
#include "../log.h"
#include "../metadata.h"
#include "../achievement.h"

#include <bx/math.h>

// CORE GAME LOOP
void ff7_core_game_loop()
{
	struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
	uint64_t start_t, end_t;

	common_externals.get_time(&start_t);

	*(double *)&game_object->field_28 = *(double *)&game_object->field_28 + 1.0;
	ff7_engine_exit_game_mode(game_object);

	if ( !game_object->window_minimized && game_object->engine_loop_obj.main_loop )
	{
		game_object->engine_loop_obj.main_loop((game_obj*)game_object);
		*(double *)&game_object->field_44 = *(double *)&game_object->field_44 + 1.0;
	}

	if ( !game_object->window_minimized )
		common_flip((game_obj*)game_object);

	if ( game_object->field_950 || game_object->window_minimized )
		WaitMessage();

	common_externals.get_time(&end_t);
	if ( game_object->field_794 ) common_externals.diff_time(&end_t, &start_t, (uint64_t*)(game_object->field_794 + 0x98));
}

// MDEF fix
uint32_t get_equipment_stats(uint32_t party_index, uint32_t type)
{
	uint32_t character = ff7_externals.party_member_to_char_map[ff7_externals.savemap->party_members[party_index]];

	switch(type)
	{
		case 0:
			return ff7_externals.weapon_data_array[ff7_externals.savemap->chars[character].equipped_weapon].attack_stat;
			break;
		case 1:
			return ff7_externals.armor_data_array[ff7_externals.savemap->chars[character].equipped_armor].defense_stat;
			break;
		case 2:
			return 0;
			break;
		case 3:
			return mdef_fix ? ff7_externals.armor_data_array[ff7_externals.savemap->chars[character].equipped_armor].mdef_stat : 0;
			break;

		default: return 0;
	}
}

// WM_ACTIVATEAPP
void ff7_wm_activateapp(bool hasFocus)
{

}

// Analogue controls
int ff7_get_control_direction()
{
	byte* level_data = *ff7_externals.field_level_data_pointer;

	if (level_data != nullptr)
	{
		uint32_t triggers_offset = *(uint32_t*)(level_data + 0x22);
		signed short* control_direction_data = (signed short*)(level_data + triggers_offset + 4 + 9);

		return static_cast<int>(*control_direction_data);
	}

	return 0;
}

void ff7_set_control_direction(int x)
{
	byte* level_data = *ff7_externals.field_level_data_pointer;

	if (level_data != nullptr)
	{
		uint32_t triggers_offset = *(uint32_t*)(level_data + 0x22);
		signed short* control_direction_data = (signed short*)(level_data + triggers_offset + 4 + 9);

		*control_direction_data = static_cast<signed short>(x);
	}
}

void ff7_use_analogue_controls(float analog_threshold)
{
	static WORD last_field_id = 0;
	static int base_control_direction = 0;
	static bool isCameraReset = false;
	if (last_field_id != *ff7_externals.field_id)
	{
		last_field_id = *ff7_externals.field_id;
		base_control_direction = ff7_get_control_direction();
	}

	vector3<float> joyDir = {0.0f, 0.0f, 0.0f};
	vector3<float> inputDir = {0.0f, 0.0f, 0.0f};
	float horizontalScroll = 0.0f;
	float verticalScroll = 0.0f;
	const float rotSpeedMax = 4.0f;
	float verticalRotSpeed = 0.0f;
	float horizontalRotSpeed = 0.0f;
	const float zoomSpeedMax = 1000.0f;
	float zoomSpeed = 0.0f;

	float invertedVerticalCameraScale = -1.0;
	if(enable_inverted_vertical_camera_controls) invertedVerticalCameraScale = 1.0;

	float invertedHorizontalCameraScale = -1.0;
	if(enable_inverted_horizontal_camera_controls) invertedHorizontalCameraScale = 1.0;

	if(xinput_connected)
	{
		if (gamepad.Refresh())
		{
			if(std::abs(gamepad.leftStickX) > left_analog_stick_deadzone ||
			   std::abs(gamepad.leftStickY) > left_analog_stick_deadzone)
				joyDir = {gamepad.leftStickX, gamepad.leftStickY, 0.0f};
			else
				joyDir = {0.0f, 0.0, 0.0};


			if(gamepad.leftStickY > analog_threshold && !(gamepad.leftStickX < -analog_threshold || gamepad.leftStickX > analog_threshold))
				inputDir = {0.0f, 1.0f, 0.0f};
			else if(gamepad.leftStickY > analog_threshold && gamepad.leftStickX < -analog_threshold)
				inputDir = {-0.707f, 0.707f, 0.0f};
			else if(gamepad.leftStickY > analog_threshold && gamepad.leftStickX > analog_threshold)
				inputDir = {0.707f, 0.707f, 0.0f};
			else if(gamepad.leftStickX < -analog_threshold &&!(gamepad.leftStickY > analog_threshold || gamepad.leftStickY < -analog_threshold))
				inputDir = {-1.0f, 0.0f, 0.0f};
			else if(gamepad.leftStickX > analog_threshold && !(gamepad.leftStickY > analog_threshold || gamepad.leftStickY < -analog_threshold))
				inputDir = {1.0f, 0.0f, 0.0f};
			else if(gamepad.leftStickY < -analog_threshold && gamepad.leftStickX < -analog_threshold)
				inputDir = {-0.707f, -0.707f, 0.0f};
			else if(gamepad.leftStickY < -analog_threshold && gamepad.leftStickX > analog_threshold)
				inputDir = {0.707f, -0.707f, 0.0f};
			else if(gamepad.leftStickY < -analog_threshold && !(gamepad.leftStickX < -analog_threshold || gamepad.leftStickX > analog_threshold))
				inputDir = {0.0f, -1.0f, 0.0f};

			if (gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_THUMB)
			    && std::abs(gamepad.rightStickX) < right_analog_stick_deadzone
				&& std::abs(gamepad.rightStickY) < right_analog_stick_deadzone)
			{
				if(!isCameraReset)
				{
					ff7::world::camera.requestResetCameraRotation(true);
					ff7::battle::camera.reset();
					isCameraReset = true;
				}
			} else
			{
				isCameraReset = false;

				if(gamepad.rightTrigger > right_analog_trigger_deadzone)
					zoomSpeed += zoomSpeedMax * (0.5f * gamepad.rightTrigger);
				if(gamepad.leftTrigger > left_analog_trigger_deadzone)
					zoomSpeed -= zoomSpeedMax * (0.5f * gamepad.leftTrigger);

				bx::Vec3 rightAnalogDir(gamepad.rightStickX, gamepad.rightStickY, 0.0f);
				float length = std::min(bx::length(rightAnalogDir), 1.0f);
				if(length > right_analog_stick_deadzone)
				{
					rightAnalogDir = bx::normalize(rightAnalogDir);
					float scale = (length - right_analog_stick_deadzone) / (1.0 - right_analog_stick_deadzone);
					rightAnalogDir.x *= scale;
					rightAnalogDir.y *= scale;
					verticalRotSpeed = invertedVerticalCameraScale * -rotSpeedMax * rightAnalogDir.y;
					horizontalRotSpeed = invertedHorizontalCameraScale * rotSpeedMax * rightAnalogDir.x;
					horizontalScroll = rightAnalogDir.x;
					verticalScroll = -rightAnalogDir.y;
				}
			}
		}
	}
	else
	{
		if (joystick.Refresh())
		{
			if(std::abs(joystick.GetState()->lX) > joystick.GetDeadZone(left_analog_trigger_deadzone) ||
			   std::abs(joystick.GetState()->lY) > joystick.GetDeadZone(left_analog_trigger_deadzone))
				joyDir = {static_cast<float>(joystick.GetState()->lX) / static_cast<float>(SHRT_MAX),
				         -static_cast<float>(joystick.GetState()->lY) / static_cast<float>(SHRT_MAX), 0.0f};
			else
				joyDir = {0.0f, 0.0, 0.0};

			if(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) &&
			!(joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold)))
				inputDir = {0.0f, 1.0f, 0.0f};
			else if(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) && joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold))
				inputDir = {-0.707f, 0.707f, 0.0f};
			else if(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) && joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold))
				inputDir = {0.707f, 0.707f, 0.0f};
			else if(joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold) &&
			!(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold)))
				inputDir = {-1.0f, 0.0f, 0.0f};
			else if(joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold) &&
				!(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold)))
				inputDir = {1.0f, 0.0f, 0.0f};
			else if(joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold) && joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold))
				inputDir = {-0.707f, -0.707f, 0.0f};
			else if(joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold) && joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold))
				inputDir = {0.707f, -0.707f, 0.0f};
			else if(joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold) &&
				!(joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold)))
				inputDir = {0.0f, -1.0f, 0.0f};

			if ((joystick.GetState()->rgbButtons[11] & 0x80)
			    && std::abs(joystick.GetState()->lRz) < joystick.GetDeadZone(right_analog_stick_deadzone)
				&& std::abs(joystick.GetState()->lZ) < joystick.GetDeadZone(right_analog_stick_deadzone))
			{
				if(!isCameraReset)
				{
					ff7::world::camera.requestResetCameraRotation(true);
					ff7::battle::camera.reset();
					isCameraReset = true;
				}
			} else
			{
				isCameraReset = false;

				bx::Vec3 rightAnalogDir(
					static_cast<float>(joystick.GetState()->lZ) / static_cast<float>(SHRT_MAX),
					static_cast<float>(joystick.GetState()->lRz) / static_cast<float>(SHRT_MAX), 0.0f);
				float length = std::min(bx::length(rightAnalogDir), 1.0f);
				if(length > right_analog_stick_deadzone)
				{
					rightAnalogDir = bx::normalize(rightAnalogDir);
					float scale = (length - right_analog_stick_deadzone) / (1.0 - right_analog_stick_deadzone);
					rightAnalogDir.x *=  scale;
					rightAnalogDir.y *=  scale;
					verticalRotSpeed = invertedVerticalCameraScale * rotSpeedMax * rightAnalogDir.y;
					horizontalRotSpeed = invertedHorizontalCameraScale * rotSpeedMax * rightAnalogDir.x;
					horizontalScroll = rightAnalogDir.x;
					verticalScroll = rightAnalogDir.y;
				}

				if(joystick.HasAnalogTriggers())
				{
					if(joystick.GetState()->lRy > -static_cast<float>(SHRT_MAX) + joystick.GetDeadZone(right_analog_trigger_deadzone))
						zoomSpeed += zoomSpeedMax * (0.5f + 0.5f * static_cast<float>(joystick.GetState()->lRy) / static_cast<float>(SHRT_MAX));
					if(joystick.GetState()->lRx > -static_cast<float>(SHRT_MAX) + joystick.GetDeadZone(left_analog_trigger_deadzone))
						zoomSpeed -= zoomSpeedMax * (0.5f + 0.5f * static_cast<float>(joystick.GetState()->lRx) / static_cast<float>(SHRT_MAX));
				}
				else
				{
					if(joystick.GetState()->rgbButtons[7] & 0x80) zoomSpeed += zoomSpeedMax;
					if(joystick.GetState()->rgbButtons[6] & 0x80) zoomSpeed -= zoomSpeedMax;
				}
			}
		}
	}

	ff7::world::world.SetJoystickDirection(joyDir);

	float inputDirLength = vector_length(&inputDir);
	if(inputDirLength > 0.0f)
	{
		normalize_vector(&joyDir);
		float angle = atan2( inputDir.x*joyDir.y - inputDir.y*joyDir.x, inputDir.x*joyDir.x + inputDir.y*joyDir.y );
		int offset = std::max(-128, std::min(128, static_cast<int>(128.0f * angle / M_PI)));
		ff7_set_control_direction(base_control_direction + offset);
	}
	else
	{
		ff7_set_control_direction(base_control_direction);
	}

	ff7::battle::camera.setRotationSpeed(verticalRotSpeed, horizontalRotSpeed, 0.0f);
	ff7::battle::camera.setZoomSpeed(zoomSpeed);
	ff7::field::camera.setScrollingDir(horizontalScroll, verticalScroll);
	ff7::world::camera.setRotationSpeed(verticalRotSpeed, horizontalRotSpeed, 0.0f);
	ff7::world::camera.setZoomSpeed(zoomSpeed);
}

int ff7_get_gamepad()
{
	if (simulate_OK_button)
	{
		return TRUE;
	}
	else if (xinput_connected)
	{
		if (gamepad.Refresh())
			return TRUE;
	}
	else
	{
		if (joystick.Refresh())
    	return TRUE;
	}

	return FALSE;
}

struct ff7_gamepad_status* ff7_update_gamepad_status()
{
	float analog_threshold = enable_auto_run ? left_analog_stick_deadzone + 0.25f * (1.0f - left_analog_stick_deadzone) : 0.5f;
	float run_threshold = left_analog_stick_deadzone + 0.75f * (1.0f - left_analog_stick_deadzone);

	// Reset
	ZeroMemory(ff7_externals.gamepad_status, sizeof(ff7_gamepad_status));
	gamepad_analogue_intent = INTENT_NONE;

	if (simulate_OK_button)
	{
		// Flag the button OK ( no matter to what is mapped in the controller ) as pressed
		*ff7_externals.input_ok_button_status = 1;

		// End simulation right here before we press this button by mistake in other windows
		simulate_OK_button = false;
	}
	else if (xinput_connected && gamehacks.canInputBeProcessed())
	{
		if (gamepad.Refresh())
		{
			ff7_externals.gamepad_status->pos_x = gamepad.leftStickX;
			ff7_externals.gamepad_status->pos_y = gamepad.leftStickY;
			ff7_externals.gamepad_status->dpad_up = (gamepad.leftStickY > analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_UP); // UP
			ff7_externals.gamepad_status->dpad_down = (gamepad.leftStickY < -analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_DOWN); // DOWN
			ff7_externals.gamepad_status->dpad_left = (gamepad.leftStickX < -analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_LEFT); // LEFT
			ff7_externals.gamepad_status->dpad_right = (gamepad.leftStickX > analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_RIGHT); // RIGHT
			ff7_externals.gamepad_status->button1 = gamepad.IsPressed(XINPUT_GAMEPAD_X); // Square
			ff7_externals.gamepad_status->button2 = gamepad.IsPressed(XINPUT_GAMEPAD_A); // Cross
			ff7_externals.gamepad_status->button3 = gamepad.IsPressed(XINPUT_GAMEPAD_B); // Circle
			ff7_externals.gamepad_status->button4 = gamepad.IsPressed(XINPUT_GAMEPAD_Y); // Triangle
			ff7_externals.gamepad_status->button5 = gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_SHOULDER); // L1
			ff7_externals.gamepad_status->button6 = gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1
			ff7_externals.gamepad_status->button7 = gamepad.leftTrigger > 0.85f; // L2
			ff7_externals.gamepad_status->button8 = gamepad.rightTrigger > 0.85f; // R2

			ff7_externals.gamepad_status->button9 = gamepad.IsPressed(XINPUT_GAMEPAD_BACK); // SELECT
			ff7_externals.gamepad_status->button10 = gamepad.IsPressed(XINPUT_GAMEPAD_START); // START
			ff7_externals.gamepad_status->button11 = gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_THUMB); // L3
			ff7_externals.gamepad_status->button12 = gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_THUMB); // R3
			ff7_externals.gamepad_status->button13 = gamepad.IsPressed(0x400); // PS Button

			// Update the player intent based on the analogue movement
			if (enable_auto_run)
			{
				bx::Vec3 joyDir = {gamepad.leftStickX, gamepad.leftStickY, 0.0f};
				auto joyLength = std::min(bx::length(joyDir), 1.0f);
				if (joyLength > run_threshold) gamepad_analogue_intent = INTENT_RUN;
				else if(joyLength > analog_threshold) gamepad_analogue_intent = INTENT_WALK;
			}
		}
	}
	else if (gamehacks.canInputBeProcessed())
	{
		if (joystick.Refresh())
		{
			ff7_externals.gamepad_status->pos_x = joystick.GetState()->lX;
			ff7_externals.gamepad_status->pos_y = joystick.GetState()->lY;
			ff7_externals.gamepad_status->dpad_up = (joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 0
			                                         || joystick.GetState()->rgdwPOV[0] == 4500 || joystick.GetState()->rgdwPOV[0] == 31500; // UP
			ff7_externals.gamepad_status->dpad_down = (joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 18000
			                                         || joystick.GetState()->rgdwPOV[0] == 13500 || joystick.GetState()->rgdwPOV[0] == 22500; // DOWN
			ff7_externals.gamepad_status->dpad_left = (joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 27000
			                                         || joystick.GetState()->rgdwPOV[0] == 22500 || joystick.GetState()->rgdwPOV[0] == 31500; // LEFT
			ff7_externals.gamepad_status->dpad_right = (joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 9000
			                                         || joystick.GetState()->rgdwPOV[0] == 4500 || joystick.GetState()->rgdwPOV[0] == 13500; // RIGHT
			ff7_externals.gamepad_status->button1 = joystick.GetState()->rgbButtons[0] & 0x80; // Square
			ff7_externals.gamepad_status->button2 = joystick.GetState()->rgbButtons[1] & 0x80; // Cross
			ff7_externals.gamepad_status->button3 = joystick.GetState()->rgbButtons[2] & 0x80; // Circle
			ff7_externals.gamepad_status->button4 = joystick.GetState()->rgbButtons[3] & 0x80; // Triangle
			ff7_externals.gamepad_status->button5 = joystick.GetState()->rgbButtons[4] & 0x80; // L1
			ff7_externals.gamepad_status->button6 = joystick.GetState()->rgbButtons[5] & 0x80; // R1
			ff7_externals.gamepad_status->button7 = joystick.GetState()->rgbButtons[6] & 0x80; // L2
			ff7_externals.gamepad_status->button8 = joystick.GetState()->rgbButtons[7] & 0x80; // R2

			ff7_externals.gamepad_status->button9 = joystick.GetState()->rgbButtons[8] & 0x80; // SELECT
			ff7_externals.gamepad_status->button10 = joystick.GetState()->rgbButtons[9] & 0x80; // START
			ff7_externals.gamepad_status->button11 = joystick.GetState()->rgbButtons[10] & 0x80; // L3
			ff7_externals.gamepad_status->button12 = joystick.GetState()->rgbButtons[11] & 0x80; // R3
			ff7_externals.gamepad_status->button13 = joystick.GetState()->rgbButtons[12] & 0x80; // PS Button

			// Update the player intent based on the analogue movement
			if (enable_auto_run)
			{
				bx::Vec3 joyDir = {static_cast<float>(joystick.GetState()->lX) / static_cast<float>(joystick.GetDeadZone(1.0f)),
				static_cast<float>(joystick.GetState()->lY) / static_cast<float>(joystick.GetDeadZone(1.0f)), 0.0f};
				auto joyLength = std::min(bx::length(joyDir), 1.0f);
				if (joyLength > run_threshold) gamepad_analogue_intent = INTENT_RUN;
				else if(joyLength > analog_threshold) gamepad_analogue_intent = INTENT_WALK;
			}
		}
	}

	if(enable_analogue_controls) ff7_use_analogue_controls(analog_threshold);

	return ff7_externals.gamepad_status;
}

void* ff7_engine_exit_game_mode(ff7_game_obj* game_object)
{
	void* result;

	if (game_object)
	{
		result = game_object;
		if (game_object->field_924)
		{
			if (game_object->engine_loop_obj.exit_main)
				game_object->engine_loop_obj.exit_main((struct game_obj*)game_object);

			ff7_externals.sub_666C13((struct game_obj*)game_object);
			result = ff7_externals.sub_670F9B(game_object->dx_sfx_something);

			if (ff7_do_reset)
			{
				// Trigger game over and ensure battle mode can be retriggered
				*ff7_externals.word_CC0828 = 0;
				*ff7_externals.byte_CC0D89 = 26;
				*ff7_externals.word_DB958A = 0;
				*ff7_externals.byte_CC164C = 0;
				*ff7_externals.word_CC0DC6 = 0;

				// Fix possible weird 3D issues that may happens in movies if resetted after some of those
				ff7_externals.modules_global_object->MVCAM_flag = 0;

				ff7_do_reset = false;
			}

			if (game_object->engine_loop_obj.enter_main)
				result = game_object->engine_loop_obj.enter_main((struct game_obj*)game_object);

			game_object->field_924 = 0;
		}
	}
	return result;
}

void ff7_on_gameover_enter()
{
	// Stop current music
	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF0, 0, 0, 0, 0, 0);
	// Stop current sound
	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF1, 0, 0, 0, 0, 0);
	// Play the gameover music
	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* play_music */ 0x14, /* midi_id */ 0x3A, 0, 0, 0, 0);

	ff7_externals.start_gameover();
}

void ff7_on_gameover_exit()
{
	// Stop current music
	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF0, 0, 0, 0, 0, 0);
	// Stop current sound
	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF1, 0, 0, 0, 0, 0);

	ff7_externals.gameover_sub_6C12B1();
}

BYTE ff7_toggle_battle_field()
{
	BYTE ret = ff7_externals.sub_60B260();

	if (!gamehacks.wantsBattle()) ret = 255;

	return ret;
}

BYTE ff7_toggle_battle_worldmap()
{
	BYTE ret = ff7_externals.sub_767C55();

	if (!gamehacks.wantsBattle()) ret = 0;

	return ret;
}

bool ff7_skip_movies()
{
	uint32_t mode = getmode_cached()->driver_mode;

	// Prevent game acting weird or wrong if movie is skipped
	if (
		*ff7_externals.field_id == 399 ||
		*ff7_externals.field_id == 489 ||
		*ff7_externals.field_id == 490 ||
		*ff7_externals.field_id == 543
	)
	{
		return false;
	}

	if (ff7_externals.movie_object->is_playing)
	{
		ff7_externals.movie_object->movie_end = 1;

		if (mode == MODE_ENDINGMOVIE)
		{
			ff7_externals.movie_object->is_playing = 0;
		}

		if (mode == MODE_FIELD)
		{
			*ff7_externals.word_CC0DD4 = 5;
			*ff7_externals.word_CC1638 = 0;
		}

		if (*ff7_externals.field_id == 116)
		{
			if (use_external_music)
				ff7_play_midi(2);
			else
				ff7_externals.play_midi(2);
		}

		return true;
	}

	return false;
}

void* ff7_menu_sub_6FAC38(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5)
{
	return ff7_externals.menu_sub_6FAC38(param1, param2, param3, *ff7_externals.millisecond_counter < 0x8000 ? 7 : 0, param5);
}

void* ff7_menu_sub_6F5C0C(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5)
{
	return ff7_externals.menu_sub_6F5C0C(param1, param2, param3, *ff7_externals.millisecond_counter < 0x8000 ? 7 : 0, param5);
}

void ff7_limit_fps()
{
	static time_t last_gametime;
	time_t gametime;
	double framerate = 30.0f;

	struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
	struct game_mode *mode = getmode_cached();

	switch(mode->driver_mode)
	{
	case MODE_FIELD:
		if (ff7_externals.movie_object->is_playing && !*ff7_externals.field_limit_fps)
		{
			// Some movies do not expect to be frame limited
			qpc_get_time(&last_gametime);
			return;
		}
		break;
	case MODE_GAMEOVER:
		// Gameover screen has nothing to limit
		qpc_get_time(&last_gametime);
		return;
	case MODE_SUBMARINE:
		last_gametime = *ff7_externals.submarine_last_gametime;
		break;
	}

	if (ff7_fps_limiter < FPS_LIMITER_60FPS)
	{
		switch (mode->driver_mode)
		{
		case MODE_BATTLE:
			if (ff7_fps_limiter < FPS_LIMITER_30FPS) framerate = 15.0f;
			break;
		case MODE_SNOWBOARD:
		case MODE_COASTER:
		case MODE_CONDOR:
		case MODE_MENU:
		case MODE_MAIN_MENU:
			framerate = 60.0f;
			break;
		case MODE_CREDITS:
			framerate = 39.0f;
			break;
		}
	}
	else
	{
		switch (mode->driver_mode)
		{
		case MODE_FIELD:
		case MODE_WORLDMAP:
		case MODE_BATTLE:
		case MODE_SWIRL:
		case MODE_SNOWBOARD:
		case MODE_SUBMARINE:
		case MODE_COASTER:
		case MODE_CONDOR:
		case MODE_MENU:
		case MODE_MAIN_MENU:
			framerate = 60.0f;
			break;
		case MODE_CREDITS:
			framerate = 39.0f;
			break;
		}
	}

	switch(mode->driver_mode)
	{
	case MODE_SUBMARINE:
		if (*ff7_externals.submarine_minigame_status)
			*ff7_externals.submarine_minigame_status = 0;
		else
			*ff7_externals.submarine_minigame_status = 1;
		break;
	}

	framerate *= gamehacks.getCurrentSpeedhack();
	double frame_time = game_object->countspersecond / framerate;

	do qpc_get_time(&gametime);
	while (gametime > last_gametime && qpc_diff_time(&gametime, &last_gametime, nullptr) < frame_time);

	last_gametime = gametime;
}

void ff7_handle_ambient_playback()
{
	struct game_mode *mode = getmode_cached();
	static char filename[64]{0};
	static WORD last_field_id = 0, last_triangle_id = 0, last_battle_id = 0;
	bool playing = false;

	switch (mode->driver_mode)
	{
	case MODE_BATTLE:
		if (last_battle_id != ff7_externals.modules_global_object->battle_id)
		{
			last_battle_id = ff7_externals.modules_global_object->battle_id;

			sprintf(filename, "bat_%d", last_battle_id);
			nxAudioEngine.playAmbient(filename);
		}
		if (*ff7_externals.is_battle_paused && nxAudioEngine.isAmbientPlaying())
			nxAudioEngine.pauseAmbient();
		else if (!(*ff7_externals.is_battle_paused) && !(nxAudioEngine.isAmbientPlaying()))
			nxAudioEngine.resumeAmbient();
		break;
	case MODE_FIELD:
		if (last_field_id != *common_externals.current_field_id)
		{
			last_field_id = *common_externals.current_field_id;
			last_triangle_id = *common_externals.current_triangle_id;

			sprintf(filename, "field_%d_%d", last_field_id, *common_externals.current_triangle_id);
			playing = nxAudioEngine.playAmbient(filename);

			if (!playing)
			{
				sprintf(filename, "field_%d", last_field_id);
				playing = nxAudioEngine.playAmbient(filename);
			}
		}
		else if (common_externals.current_triangle_id != 0 && last_field_id == *common_externals.current_field_id && last_triangle_id != *common_externals.current_triangle_id)
		{
			last_triangle_id = *common_externals.current_triangle_id;

			sprintf(filename, "field_%d_%d", last_field_id, *common_externals.current_triangle_id);
			playing = nxAudioEngine.playAmbient(filename);
		}
		break;
	default:
		if (last_field_id != 0 || last_battle_id != 0)
		{
			nxAudioEngine.stopAmbient();
			last_field_id = 0;
			last_battle_id = 0;
		}
		break;
	}
}

void ff7_handle_voice_playback()
{
	switch (getmode_cached()->driver_mode)
	{
	case MODE_BATTLE:
		if (*ff7_externals.g_is_battle_paused && nxAudioEngine.isVoicePlaying())
			nxAudioEngine.pauseVoice();
		else if (!*ff7_externals.g_is_battle_paused && !nxAudioEngine.isVoicePlaying())
			nxAudioEngine.resumeVoice();
		break;
	default:
		break;
	}
}

BOOL ff7_write_save_file(char slot)
{
	BOOL ret = ff7_externals.write_save_file(slot);

	uint8_t savefile_num = ((slot & 0xF0) >> 4);
	ffnx_trace("Save: user saved in save%02i\n", savefile_num);
	metadataPatcher.updateFF7(savefile_num);

	return ret;
}

// The function that load the model size sometimes gets a buffer that is non-null terminated, returning weird values.
// Replace the native `atoi` call with a custom function that always uses the first 4 bytes to convert the buffer to int
int ff7_field_load_models_atoi(const char* str)
{
	std::string buf(str, 4);

	return std::stol(buf);
}

//#########################
// steam achievement hooks
//#########################

int ff7_load_save_file(int param_1){
	int returnValue = ((int(*)(int))ff7_externals.load_save_file)(param_1);
	g_FF7SteamAchievements->initStatsFromSaveFile(*ff7_externals.savemap);
	return returnValue;
}

void ff7_chocobo_field_entity_60FA7D(WORD param1, short param2, short param3){
	((void(*)(WORD, short, short)) ff7_externals.sub_60FA7D)(param1, param2, param3);

	if(param3 == 0x04)
		g_FF7SteamAchievements->unlockGoldChocoboAchievement(ff7_externals.savemap->chocobo_slots_first, ff7_externals.savemap->chocobo_slots_last);
}

void ff7_character_regularly_field_entity_60FA7D(WORD param1, short param2, short param3){
	((void(*)(WORD, short, short)) ff7_externals.sub_60FA7D)(param1, param2, param3);

	if(param3 & (1 << 0) || param3 & (1 << 2))
		g_FF7SteamAchievements->unlockYuffieAndVincentAchievement(ff7_externals.savemap->yuffie_reg_mask, ff7_externals.savemap->vincent_reg_mask);
}
````

## File: src/ff7/time.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../renderer.h"
#include "../globals.h"
#include "../patch.h"
#include "../cfg.h"

#include "time.h"
#include "field/background.h"

namespace ff7
{
    Time time;

    void Time::init()
    {
        loadConfig();
        initParamsFromConfig();
    }

    void Time::loadConfig()
    {
        char _fullpath[MAX_PATH];
        sprintf(_fullpath, "%s/%s/config.toml", basedir, external_time_cycle_path.c_str());

        try
        {
            config = toml::parse_file(_fullpath);
        }
        catch (const toml::parse_error &err)
        {
            config = toml::parse("");
        }
    }

    void Time::initParamsFromConfig()
    {
        toml::array* morningColorArray = config["morning_color"].as_array();
        if(morningColorArray != nullptr && morningColorArray->size() == 3)
        {
            morningColor.x = morningColorArray->get(0)->value<float>().value_or(1.0);
            morningColor.y = morningColorArray->get(1)->value<float>().value_or(1.0);
            morningColor.z  = morningColorArray->get(2)->value<float>().value_or(1.0);
        }
        toml::array* middayColorArray = config["midday_color"].as_array();
        if(middayColorArray != nullptr && middayColorArray->size() == 3)
        {
            middayColor.x = middayColorArray->get(0)->value<float>().value_or(1.0);
            middayColor.y = middayColorArray->get(1)->value<float>().value_or(1.0);
            middayColor.z  = middayColorArray->get(2)->value<float>().value_or(1.0);
        }
        toml::array* afternoonColorArray = config["afternoon_color"].as_array();
        if(afternoonColorArray != nullptr && afternoonColorArray->size() == 3)
        {
            afternoonColor.x = afternoonColorArray->get(0)->value<float>().value_or(1.0);
            afternoonColor.y = afternoonColorArray->get(1)->value<float>().value_or(1.0);
            afternoonColor.z  = afternoonColorArray->get(2)->value<float>().value_or(1.0);
        }
        toml::array* nightColorArray = config["night_color"].as_array();
        if(nightColorArray != nullptr && nightColorArray->size() == 3)
        {
            nightColor.x = nightColorArray->get(0)->value<float>().value_or(1.0);
            nightColor.y = nightColorArray->get(1)->value<float>().value_or(1.0);
            nightColor.z  = nightColorArray->get(2)->value<float>().value_or(1.0);
        }

        sunriseTime = config["sunrise_time"].value_or(6.0) / 24.0;
        morningTime = config["morning_time"].value_or(7.0) / 24.0;
        middayTime = config["midday_time"].value_or(15.0) / 24.0;
        afternoonTime = config["afternoon_time"].value_or(19.0) / 24.0;
        nightTime = config["night_time"].value_or(20.0) / 24.0;

        framesPerMinute = config["frames_per_minute"].value_or(15);

        auto optionAddressStr = config["options_address"].value<std::string>();
        if(optionAddressStr.has_value())
        {
            auto str = optionAddressStr.value();
            pOptions = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        auto minutesAddressStr = config["minutes_address"].value<std::string>();
        if(minutesAddressStr.has_value())
        {
            auto str = minutesAddressStr.value();
            pMinutes = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        auto hoursAddressStr = config["hours_address"].value<std::string>();
        if(hoursAddressStr.has_value())
        {
            auto str = hoursAddressStr.value();
            pHours = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        auto daysAddressStr = config["days_address"].value<std::string>();
        if(daysAddressStr.has_value())
        {
            auto str = daysAddressStr.value();
            pDays = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        auto monthsAddressStr = config["months_address"].value<std::string>();
        if(monthsAddressStr.has_value())
        {
            auto str = monthsAddressStr.value();
            pMonths = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        auto monthChar0AddressStr = config["month_char_0_address"].value<std::string>();
        if(monthChar0AddressStr.has_value())
        {
            auto str = monthChar0AddressStr.value();
            pMonthChar0 = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        auto monthChar1AddressStr = config["month_char_1_address"].value<std::string>();
        if(monthChar1AddressStr.has_value())
        {
            auto str = monthChar1AddressStr.value();
            pMonthChar1 = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        auto monthChar2AddressStr = config["month_char_2_address"].value<std::string>();
        if(monthChar2AddressStr.has_value())
        {
            auto str = monthChar2AddressStr.value();
            pMonthChar2 = (byte*)(std::strtol(str.data(), nullptr, 16));
        }

        for (int i = 0; i < 12; ++i)
        {
            monthChar0[i] = config["month_" + std::to_string(i) + "_char_0"].value_or(0);
            monthChar1[i] = config["month_" + std::to_string(i) + "_char_1"].value_or(0);
            monthChar2[i] = config["month_" + std::to_string(i) + "_char_2"].value_or(0);
        }
    }

    void time_hook_init()
    {
        replace_call_function(ff7_externals.field_draw_everything + 0x360, ff7::field::draw_gray_quads_sub_644E90);
    }

    bx::Vec3 Time::mixColor(float time, float timeMin, float timeMax, bx::Vec3 color0, bx::Vec3 color1)
    {
        bx::Vec3 color = bx::Vec3(0.0, 0.0, 0.0);
        float t = (time - timeMin) / (timeMax - timeMin);
        color.x = std::lerp(color0.x, color1.x, t);
        color.y = std::lerp(color0.y, color1.y, t);
        color.z = std::lerp(color0.z, color1.z, t);
        return color;
    }

    void Time::update()
    {
        newRenderer.setTimeEnabled(false);
        newRenderer.setTimeFilterEnabled(false);

        if(pOptions == nullptr || pMinutes == nullptr || pHours == nullptr || pDays == nullptr || pMonths == nullptr)
        {
            return;
        }

        // Early return if bit 0 of options variable is not set (global disable)
        if((*pOptions & (1 << 0)) == 0) return;

        struct game_mode* mode = getmode_cached();
        if(mode->driver_mode != MODE_FIELD &&
           mode->driver_mode != MODE_BATTLE &&
           mode->driver_mode != MODE_WORLDMAP)
        {
            return;
        }

        // Progress time if bit 1 of options variable is set
        if(*pOptions & (1 << 1)) frame_count++;

        int modeFramesPerMinute = framesPerMinute;
        if(mode->driver_mode == MODE_BATTLE)
            modeFramesPerMinute *= battle_frame_multiplier;
        else
            modeFramesPerMinute *= 2 * common_frame_multiplier;

        if(frame_count >= modeFramesPerMinute)
        {
            (*pMinutes) = (*pMinutes) + 1;
            frame_count = 0;
        }
        if(*pMinutes >= 60 )
        {
            (*pHours) = (*pHours) + 1;
            *pMinutes = 0;
            frame_count = 0;
        }
        if(*pHours >= 24)
        {
            (*pDays) = (*pDays) + 1;
            *pHours = 0;
        }
        if((*pDays) >= 32)
        {
            (*pMonths) = (*pMonths) + 1;
            *pDays = 1;
        }
        if((*pMonths) >= 12)
        {
            (*pMonths) = 0;
        }

        if(pMonthChar0 != nullptr && pMonthChar1 != nullptr && pMonthChar2 != nullptr)
        {
            *pMonthChar0 = monthChar0[*pMonths];
            *pMonthChar1 = monthChar1[*pMonths];
            *pMonthChar2 = monthChar2[*pMonths];
        }

        if(mode->driver_mode == MODE_FIELD ||
           mode->driver_mode == MODE_BATTLE)
        {
            // Disable filter if bit 2 of options variable is not set (e.g. when indoor fields)
            if((*pOptions & (1 << 2)) == 0)
            {
                newRenderer.setTimeEnabled(false);
                newRenderer.setTimeFilterEnabled(false);
                return;
            }
        }

        float time = (*pHours * 60.0f * modeFramesPerMinute + *pMinutes * modeFramesPerMinute + frame_count);
        time /= (1440.0f * modeFramesPerMinute);

        bx::Vec3 color = bx::Vec3(0.0, 0.0, 0.0);
        if(time < sunriseTime) color = nightColor;
        else if(time < morningTime) color = mixColor(time, sunriseTime, morningTime, nightColor, morningColor);
        else if(time < middayTime) color = mixColor(time, morningTime, middayTime, morningColor, middayColor);
        else if(time < afternoonTime) color = mixColor(time, middayTime, afternoonTime, middayColor, afternoonColor);
        else if(time < nightTime) color = mixColor(time, afternoonTime, nightTime, afternoonColor, nightColor);
        else color = nightColor;

        newRenderer.setTimeEnabled(true);
        newRenderer.setTimeFilterEnabled(true);
        newRenderer.setTimeColor(color);
    }
}
````

## File: src/ff7/time.h
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <toml++/toml.h>
#include <windows.h>
#include "bx/math.h"

namespace ff7
{
    void time_hook_init();

    class Time
    {
        public:
            void init();
            void update();

        private:
            void loadConfig();
            void initParamsFromConfig();
            bx::Vec3 mixColor(float time, float timeMin, float timeMax, bx::Vec3 color0, bx::Vec3 color1);

        private:
            // Config
            toml::parse_result config;

            bx::Vec3 morningColor  = bx::Vec3(1.0, 1.0, 1.0);
            bx::Vec3 middayColor  = bx::Vec3(1.0, 1.0, 1.0);
            bx::Vec3 afternoonColor  = bx::Vec3(1.0, 1.0, 1.0);
            bx::Vec3 nightColor  = bx::Vec3(1.0, 1.0, 1.0);

            float sunriseTime = 1.0;
            float morningTime = 1.0;
            float middayTime = 1.0;
            float afternoonTime = 1.0;
            float nightTime = 1.0;

            int frame_count = 0;

            int framesPerMinute = 0;

            byte* pOptions = nullptr;
            byte* pMinutes = nullptr;
            byte* pHours = nullptr;
            byte* pDays = nullptr;
            byte* pMonths = nullptr;

            byte* pMonthChar0 = nullptr;
            byte* pMonthChar1 = nullptr;
            byte* pMonthChar2 = nullptr;

            byte monthChar0[12];
            byte monthChar1[12];
            byte monthChar2[12];
    };

    extern Time time;
}
````

## File: src/ff7/widescreen.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "cmath"

#include "../ff7.h"
#include "../cfg.h"
#include "../renderer.h"
#include "../video/movies.h"
#include "../movies.h"
#include "../gl.h"
#include "../globals.h"
#include "../patch.h"

#include "widescreen.h"
#include "field/defs.h"
#include "field/background.h"

int viewport_width_plus_x_widescreen_fix = 750;
int swirl_framebuffer_offset_x_widescreen_fix = 106;
int swirl_framebuffer_offset_y_widescreen_fix = 64;

Widescreen widescreen;

// This function should be called at each frame after drawing backgrounds and 3d models
void Widescreen::zoomBackground()
{
    if(gl_defer_zoom()) return;

    bool is_movie_playing = *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag;
    int width = 0;
    if(is_movie_playing )
    {
        if(widescreen.getMovieMode() == WM_ZOOM) width = 640;
    }
    else if(widescreen.getMode() == WM_ZOOM)
    {
        auto camera_range = widescreen.getCameraRange();
        width = 2 * (camera_range.right - camera_range.left);
    }

    if(width == 0) return;

    int zoomed_x = (wide_viewport_width - width) / 2;
    float vOffset = (480 - 9 * width / 16) / 2;

    uint16_t newX = newRenderer.getInternalCoordX(zoomed_x);
    uint16_t newWidth = newRenderer.getInternalCoordX(width);
    uint16_t newY = newRenderer.getInternalCoordY(vOffset);
    uint16_t newHeight = newRenderer.getInternalCoordY(game_height - 2 * vOffset);

    if(is_movie_playing)
    {
        int frame = ffmpeg_get_movie_frame();
        auto keyPair = widescreen.getMovieKeyPair(frame);

        uint16_t newY1 = newRenderer.getInternalCoordY(vOffset + keyPair.first.v_offset);
        uint16_t newY2 = newRenderer.getInternalCoordY(vOffset + keyPair.second.v_offset);

        float t = 0.0;
        auto seqFrameCount = static_cast<float>(keyPair.second.frame - keyPair.first.frame);
        if(seqFrameCount > 0)
            t =  static_cast<float>(frame - keyPair.first.frame) / static_cast<float>(keyPair.second.frame - keyPair.first.frame);
        t = std::max(std::min(t, 1.0f), 0.0f);
        int newVOffset = std::round(std::lerp(newY1, newY2, t));
        newY = newVOffset;
    }

    newRenderer.zoomBackendFrameBuffer(newX, newY, newWidth, newHeight);
}

void ifrit_first_wave_effect_widescreen_fix_sub_66A47E(int wave_data_pointer) {
	int viewport_width_1_fix = ceil(255.f / game_width * wide_viewport_width) - 255;
	*(short*)(wave_data_pointer + 8) += wide_viewport_x;
	*(short*)(wave_data_pointer + 16) += wide_viewport_x + viewport_width_1_fix * 2;
	*(short*)(wave_data_pointer + 24) += wide_viewport_x;
	*(short*)(wave_data_pointer + 32) += wide_viewport_x + viewport_width_1_fix * 2;

    ff7_externals.engine_draw_sub_66A47E(wave_data_pointer);
}

void ifrit_second_third_wave_effect_widescreen_fix_sub_66A47E(int wave_data_pointer) {
	int viewport_width_1_fix = ceil(255.f / game_width * wide_viewport_width) - 255;
	int viewport_width_2_fix = ceil(65.f / game_width * wide_viewport_width) - 65;
	*(short*)(wave_data_pointer + 8) += wide_viewport_x + viewport_width_1_fix * 2;
	*(short*)(wave_data_pointer + 16) += wide_viewport_x + (viewport_width_1_fix + viewport_width_2_fix) * 2;
	*(short*)(wave_data_pointer + 24) += wide_viewport_x + viewport_width_1_fix * 2;
	*(short*)(wave_data_pointer + 32) += wide_viewport_x + (viewport_width_1_fix + viewport_width_2_fix) * 2;

    ff7_externals.engine_draw_sub_66A47E(wave_data_pointer);
}

void pollensalta_cold_breath_atk_white_dot_effect()
{
    effect100_data* effect_data = &ff7_externals.effect100_array_data[*ff7_externals.effect100_array_idx];
    ff7_externals.pollensalta_cold_breath_atk_draw_white_dots_547E75(*ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar);
    if (!*ff7_externals.g_is_battle_paused)
    {
        for (int i = 0; i < 400; i++)
        {
            short offset = 2 * (i % 2) + 2;
            ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x = (offset + ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x);
            if (ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x < wide_viewport_x)
                ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x = ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x + wide_viewport_width;
            if (ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x > wide_viewport_width + wide_viewport_x)
                ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x = ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x - wide_viewport_width;

            ff7_externals.pollensalta_cold_breath_white_dots_pos[i].y = (offset + ff7_externals.pollensalta_cold_breath_white_dots_pos[i].y) % wide_viewport_height;
        }

        if (effect_data->field_2 < 8)
            *ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar += 1;
        if (effect_data->field_2 > 42)
            *ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar -= 1;
        if (++effect_data->field_2 == 50)
            effect_data->field_0 = 0xFFFF;

    }
}

void ff7_widescreen_fix_chocobo_submit_quad_graphics_object(int x, int y, int width, int height, int color, int unknown, float z_value, DWORD* pointer)
{
	if(width == 640) // Replace only quad related to water effect
	{
		x = wide_viewport_x;
		width = wide_viewport_width;
		height = wide_viewport_height;
	}
	ff7_externals.generic_submit_quad_graphics_object_671D2A(x, y, width, height, color, unknown, z_value, pointer);
}

void ff7_widescreen_hook_init() {
    // Field fix
    replace_function((uint32_t)ff7_externals.field_clip_with_camera_range_6438F6, ff7::field::ff7_field_clip_with_camera_range);
    replace_function(ff7_externals.field_layer3_clip_with_camera_range_643628, ff7::field::ff7_field_layer3_clip_with_camera_range);
    replace_function(ff7_externals.field_culling_model_639252, ff7::field::ff7_field_do_draw_3d_model);
    replace_call_function(ff7_externals.field_sub_63AC66 + 0xD5, ff7::field::ff7_field_set_fade_quad_size);
    patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x6A, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x80, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x94, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x9C, (uint32_t)&wide_viewport_x);
    patch_code_int(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x64, wide_viewport_width / 2);
    patch_code_int(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x7A, wide_viewport_width / 2);
    memset_code(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x39, 0x90, 12); // Remove useless culling cursor
    patch_code_int(ff7_externals.field_init_viewport_values + 0xBE, wide_viewport_width + wide_viewport_x - 60);
    patch_code_int(ff7_externals.field_init_viewport_values + 0xC8, 18);
    // For zoom field maps
    replace_call_function(ff7_externals.field_draw_everything + 0x360, ff7::field::draw_gray_quads_sub_644E90);

    // Swirl fix
    patch_code_dword(ff7_externals.swirl_loop_sub_4026D4 + 0x335, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.swirl_enter_sub_401810 + 0x21, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.swirl_enter_40164E + 0xEE, (uint32_t)&swirl_framebuffer_offset_x_widescreen_fix);
    patch_code_dword(ff7_externals.swirl_enter_40164E + 0x112, (uint32_t)&swirl_framebuffer_offset_x_widescreen_fix);
    patch_code_dword(ff7_externals.swirl_enter_40164E + 0xFB, (uint32_t)&swirl_framebuffer_offset_y_widescreen_fix);
    patch_code_dword(ff7_externals.swirl_enter_40164E + 0x11F, (uint32_t)&swirl_framebuffer_offset_y_widescreen_fix);
    patch_code_int(ff7_externals.swirl_enter_40164E + 0xE8, 85);

    // Battle fix
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x4B, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x68, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x8B, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0xB4, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x105, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x122, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x141, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x16A, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x19F, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x1BB, (uint32_t)&wide_viewport_x);
    patch_code_int(ff7_externals.battle_enter + 0x1E8, wide_viewport_y);
    patch_code_int(ff7_externals.battle_enter + 0x21A, wide_viewport_height);
    patch_code_dword(ff7_externals.battle_enter + 0x229, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.battle_enter + 0x22F, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_draw_quad_5BD473 + 0xDA, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_draw_quad_5BD473 + 0x112, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_sub_58ACB9 + 0x55, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.battle_sub_58ACB9 + 0x65, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x23F, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x24C, (uint32_t)&wide_viewport_x);
    patch_code_int(ff7_externals.shadow_flare_draw_white_bg_57747E + 0x18, wide_viewport_x);
    patch_code_int(ff7_externals.shadow_flare_draw_white_bg_57747E + 0x1F, wide_viewport_width / 2);
    patch_code_int(ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0 + 0x83, wide_viewport_width);
    patch_code_int(ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0 + 0x8D, wide_viewport_height);
    patch_code_short(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0 + 0x191, wide_viewport_x - 200);
    patch_code_dword(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0 + 0x39, (uint32_t)&pollensalta_cold_breath_atk_white_dot_effect);
    patch_code_int(ff7_externals.pandora_box_skill_draw_bg_flash_effect_568371 + 0x3D, wide_viewport_x - 170);

    // Battle summon fix
    replace_call_function(ff7_externals.ifrit_sub_595A05 + 0x930, ifrit_first_wave_effect_widescreen_fix_sub_66A47E);
    replace_call_function(ff7_externals.ifrit_sub_595A05 + 0xAEC, ifrit_second_third_wave_effect_widescreen_fix_sub_66A47E);
    replace_call_function(ff7_externals.ifrit_sub_595A05 + 0xCC0, ifrit_second_third_wave_effect_widescreen_fix_sub_66A47E);
    patch_code_int(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x58, wide_viewport_width / 4);
    patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x5D, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x6A, (uint32_t)&wide_viewport_x);
    patch_code_int(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x88, wide_viewport_width / 4);
    patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x1A2, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x1AF, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x140, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x15B, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x19B, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x1D1, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x20E, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x243, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x28A, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x2C0, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x2FC, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x332, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A3A2E + 0x38, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A3A2E + 0x53, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A4BE6 + 0x36, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A4BE6 + 0x51, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.typhoon_effect_sub_4D7044 + 0x1B, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.typhoon_effect_sub_4D7044 + 0x36, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.typhoon_effect_sub_4DB15F + 0x22, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.typhoon_effect_sub_4DB15F + 0x3D, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.barret_limit_3_1_sub_4700F7 + 0x1B, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.barret_limit_3_1_sub_4700F7 + 0x36, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.fat_chocobo_sub_5096F3 + 0x4A, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.fat_chocobo_sub_5096F3 + 0x5F, (uint32_t)&wide_viewport_width);
    // Makes bahamut small stars background to 512x512 quad size and a different positioning of the 6 image patches
    patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x20F, -512);
    patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x23F, 1024);
    patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x26F, 512);
    patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x29E, 512);
    patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x2CE, 512);
    patch_code_short(ff7_externals.bahamut_zero_bg_star_graphics_data_7F6748 + 0x8, 512);
    patch_code_short(ff7_externals.bahamut_zero_bg_star_graphics_data_7F6748 + 0xA, 512);

    // Battle fading animation fix
    patch_code_short(ff7_externals.battle_sub_5BCF9D + 0x3A, 30);
    patch_code_byte(ff7_externals.battle_sub_5BCF9D + 0x69, 120);
    patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x46, 72);
    patch_code_byte(ff7_externals.battle_sub_5BD050 + 0xA5, 72);
    patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x87, 48);
    patch_code_byte(ff7_externals.battle_sub_5BD050 + 0xDC, 48);
    patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x100, 48);
    patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x15C, 48);
    patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x186, 48);

    // Worldmap fix
    patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x12, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x1A3, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x2BE, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x331, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x4E8, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x54A, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.world_culling_bg_meshes_75F263 + 0xE, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.world_culling_bg_meshes_75F263 + 0x20, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.world_culling_bg_meshes_75F263 + 0x26, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.world_submit_draw_bg_meshes_75F68C + 0xAE, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.world_submit_draw_bg_meshes_75F68C + 0xB6, (uint32_t)&wide_viewport_x);
    memset_code(ff7_externals.world_sub_751EFC + 0xC89, 0x90, 6);

    patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x174, -wide_viewport_width / 4 - 20);
    patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x1D1, wide_viewport_width / 4 + 20);
    patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x22E, -wide_viewport_width / 4 - 20);
    patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x282, wide_viewport_width / 4 + 20);
    patch_code_byte(ff7_externals.world_compute_skybox_data_754100 + 0x180, 44);
    patch_code_byte(ff7_externals.world_compute_skybox_data_754100 + 0x1DD, 44);
    patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x237, 20);
    patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x28B, 20);
    patch_code_short(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x132, -256);
    patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x144, 256);
    patch_code_byte(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x15C, 0);
    patch_code_short(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x16D, 256);
    patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x2DC, 0);
    patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x40F, 0);
    patch_code_dword(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x5A5, (uint32_t)&wide_viewport_x); // Meteor avoid culling
    patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x5B5, wide_viewport_width / 2); // Meteor avoid culling

    // Gameover fix
    patch_code_int(ff7_externals.enter_gameover + 0xA4, wide_viewport_x);
    patch_code_int(ff7_externals.enter_gameover + 0xB8, wide_viewport_width);

    // CDCheck fix
    patch_code_int(ff7_externals.cdcheck_enter_sub + 0xB9, wide_viewport_x);
    patch_code_int(ff7_externals.cdcheck_enter_sub + 0xCD, wide_viewport_width);

    // Credits fix
    patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0x99, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0xE6, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0x133, (uint32_t)&viewport_width_plus_x_widescreen_fix);
    patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0x180, (uint32_t)&viewport_width_plus_x_widescreen_fix);

    // Highway fix
    patch_code_int(ff7_externals.highway_submit_fade_quad_659532 + 0x5F, wide_viewport_width);
    patch_code_char(ff7_externals.highway_submit_fade_quad_659532 + 0x66, wide_viewport_x);

    // Chocobo fix
    patch_code_int(ff7_externals.chocobo_init_viewport_values_76D320 + 0x1F, wide_viewport_height);
    patch_code_char(ff7_externals.chocobo_init_viewport_values_76D320 + 0x29, wide_viewport_y);
    patch_code_int(ff7_externals.chocobo_init_viewport_values_76D320 + 0x62, wide_viewport_y);
    patch_code_dword((uint32_t)ff7_externals.chocobo_submit_draw_fade_quad_77B1CE + 0x99, (uint32_t)&wide_viewport_x);
    patch_code_int((uint32_t)ff7_externals.chocobo_fade_quad_data_97A498 + 0x28, wide_viewport_width / 2);
    replace_call_function(ff7_externals.chocobo_submit_draw_water_quad_77A7D0 + 0x9F, ff7_widescreen_fix_chocobo_submit_quad_graphics_object);

    // Snowboard fix
    patch_code_int(ff7_externals.snowboard_draw_sky_and_mountains_72DAF0 + 0xCC, ceil(wide_viewport_width / 4));
    patch_code_int(ff7_externals.snowboard_draw_sky_and_mountains_72DAF0 + 0x140, ceil(wide_viewport_width / 4));
    patch_code_float((uint32_t)ff7_externals.snowboard_sky_quad_pos_x_7B7DB8, wide_viewport_x);
    patch_code_int(ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F + 0x173, wide_viewport_width + wide_viewport_x);
    patch_code_int(ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F + 0x225, wide_viewport_width + wide_viewport_x);
    patch_code_int(ff7_externals.snowboard_submit_draw_black_quad_graphics_object_72DD94 + 0x27, wide_viewport_width);
    patch_code_char(ff7_externals.snowboard_submit_draw_black_quad_graphics_object_72DD94 + 0x2E, wide_viewport_x);
    patch_code_int(ff7_externals.snowboard_submit_draw_white_fade_quad_graphics_object_72DD53 + 0x27, wide_viewport_width);
    patch_code_char(ff7_externals.snowboard_submit_draw_white_fade_quad_graphics_object_72DD53 + 0x2E, wide_viewport_x);
    patch_code_int(ff7_externals.snowboard_submit_draw_opaque_quad_graphics_object_72DDD5 + 0x1F, wide_viewport_width);
    patch_code_char(ff7_externals.snowboard_submit_draw_opaque_quad_graphics_object_72DDD5 + 0x26, wide_viewport_x);

    // Menu, endbattle menu, ... fixes
    patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x50, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0xA8, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x105, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x163, (uint32_t)&wide_viewport_x);
    patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x111, (uint32_t)&wide_viewport_width);
    patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x16F, (uint32_t)&wide_viewport_width);
}

void Widescreen::loadConfig()
{
    char _fullpath[MAX_PATH];
    sprintf(_fullpath, "%s/%s/config.toml", basedir, external_widescreen_path.c_str());

    try
    {
        config = toml::parse_file(_fullpath);
    }
    catch (const toml::parse_error &err)
    {
        config = toml::parse("");
    }
}

void Widescreen::loadMovieConfig()
{
    char _fullpath[MAX_PATH];
    sprintf(_fullpath, "%s/%s/movie_config.toml", basedir, external_widescreen_path.c_str());

    try
    {
        movie_config = toml::parse_file(_fullpath);
    }
    catch (const toml::parse_error &err)
    {
        movie_config = toml::parse("");
    }
}

void Widescreen::init()
{
    loadConfig();
    loadMovieConfig();
    if (aspect_ratio == AR_WIDESCREEN_16X10)
    {
        wide_viewport_x = -64;
        wide_viewport_width = 768;
        wide_game_width = 768;
        viewport_width_plus_x_widescreen_fix = 704;
        swirl_framebuffer_offset_x_widescreen_fix = 64;
    }
}

void Widescreen::initParamsFromConfig()
{
    field_trigger_header* field_triggers_header_ptr = *ff7_externals.field_triggers_header;
    camera_range.left = field_triggers_header_ptr->camera_range.left;
    camera_range.right = field_triggers_header_ptr->camera_range.right;
    camera_range.bottom = field_triggers_header_ptr->camera_range.bottom;
    camera_range.top = field_triggers_header_ptr->camera_range.top;
    if(camera_range.right - camera_range.left >= game_width / 2 + abs(wide_viewport_x))
        widescreen_mode = WM_EXTEND_WIDE;
    else
        widescreen_mode = WM_DISABLED;
    h_offset = 0;
    v_offset = 0;
    is_reset_vertical_pos = false;
    is_scripted_clip_enabled = true;
    is_scripted_vertical_clip_enabled = false;
    movie_v_offset.clear();

    auto pName = get_current_field_name();
    if(pName == 0) return;

    std::string _name(pName);
    auto node = config[_name];
    if(node)
    {
        if(auto leftNode = node["left"]) camera_range.left = leftNode.value_or(0);
        if(auto rightNode = node["right"]) camera_range.right = rightNode.value_or(0);
        if(auto bottomNode = node["bottom"])camera_range.bottom = bottomNode.value_or(0);
        if(auto topNode = node["top"]) camera_range.top = topNode.value_or(0);
        if(auto hOffsetNode = node["h_offset"]) h_offset = hOffsetNode.value_or(0);
        if(auto vOffsetNode = node["v_offset"]) v_offset = vOffsetNode.value_or(0);
        if(auto vResetVerticalPosNode = node["reset_vertical_pos"]) is_reset_vertical_pos = vResetVerticalPosNode.value_or(false);
        if(auto vScriptedClipNode = node["scripted_clip"]) is_scripted_clip_enabled = vScriptedClipNode.value_or(true);
        if(auto vScriptedVerticalClipNode = node["scripted_vertical_clip"]) is_scripted_vertical_clip_enabled = vScriptedVerticalClipNode.value_or(false);

        if(auto modeNode = node["mode"]) widescreen_mode = static_cast<WIDESCREEN_MODE>(modeNode.value_or(0));

        if(widescreen_mode == WM_ZOOM)
        {
            int verticalRangeOffset = 9 * (camera_range.right - camera_range.left) / 16 - 240;
            camera_range.bottom -= verticalRangeOffset / 2;
            camera_range.top += verticalRangeOffset / 2;
        }
    }
}

void Widescreen::initMovieParamsFromConfig(char *name)
{
    widescreen_movie_mode = WM_DISABLED;
    movie_v_offset.clear();

    if(name == 0) return;

    std::string _name(name);
    auto node = movie_config[_name];
    if(node)
    {
        if(auto modeNode = node["mode"]) widescreen_movie_mode = static_cast<WIDESCREEN_MODE>(modeNode.value_or(0));

        if(auto movie_v_offset_node = node["movie_v_offset"])
        {
            auto array = movie_v_offset_node.as_array();
            auto size = array->size();
            movie_v_offset.resize(size);
            for (int i = 0; i < size; ++i)
            {
                auto keyframeArray = array->get(i)->as_array();
                movie_v_offset[i].frame = keyframeArray->get(0)->value<int>().value_or(0);
                movie_v_offset[i].v_offset = keyframeArray->get(1)->value<int>().value_or(0);
            }
        }
    }
}

KeyPair Widescreen::getMovieKeyPair(int frame)
{
    KeyPair ret;

    int keyCount = movie_v_offset.size();
    for(int keyIndex = 0; keyIndex < keyCount; ++keyIndex)
    {
        auto key = movie_v_offset[keyIndex];
        if(keyIndex == keyCount-1)
        {
            ret.first.frame = key.frame * movie_fps_ratio;
            ret.first.v_offset = key.v_offset;
            ret.second.frame = key.frame * movie_fps_ratio;
            ret.second.v_offset = key.v_offset;
            break;
        }

        auto nextKey = movie_v_offset[keyIndex + 1];
        auto keyFrame = key.frame * movie_fps_ratio;
        auto nextkeyFrame = nextKey.frame * movie_fps_ratio;
        if(frame >= keyFrame && frame < nextkeyFrame)
        {
            auto nextKey = movie_v_offset[keyIndex + 1];
            ret.first.frame = keyFrame;
            ret.first.v_offset = key.v_offset;
            ret.second.frame = nextkeyFrame;
            ret.second.v_offset = nextKey.v_offset;
            break;
        }
    }

    return ret;
}
````

## File: src/ff7/widescreen.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <vector>
#include <toml++/toml.h>

#include "common.h"
#include "ff7.h"
#include "../widescreen.h"

void ff7_widescreen_hook_init();

enum WIDESCREEN_MODE
{
    WM_DISABLED,
    WM_EXTEND_ONLY,
    WM_ZOOM,
    WM_EXTEND_WIDE,
    WM_FILL
};

struct Keyframe
{
    int frame = 0;
    int v_offset = 0;
};

struct KeyPair
{
    Keyframe first;
    Keyframe second;
};

class Widescreen
{
public:
    void init();
    void initParamsFromConfig();
    void initMovieParamsFromConfig(char *name);

    const field_camera_range& getCameraRange();
    int getHorizontalOffset();
    int getVerticalOffset();
    bool isResetVerticalPos();
    bool isScriptedClipEnabled();
    bool isScriptedVerticalClipEnabled();
    WIDESCREEN_MODE getMode();

    KeyPair getMovieKeyPair(int frame);
    WIDESCREEN_MODE getMovieMode();

    void zoomBackground();

private:
    void loadConfig();
    void loadMovieConfig();

private:
    // Config
    toml::parse_result config;
    toml::parse_result movie_config;

    field_camera_range camera_range;
    int h_offset = 0;
    int v_offset = 0;
    bool is_reset_vertical_pos = false;
    bool is_scripted_clip_enabled = true;
    bool is_scripted_vertical_clip_enabled = false;
    WIDESCREEN_MODE widescreen_mode = WM_DISABLED;

    std::vector<Keyframe> movie_v_offset;
    WIDESCREEN_MODE widescreen_movie_mode = WM_DISABLED;
};

inline const field_camera_range& Widescreen::getCameraRange()
{
    return camera_range;
}

inline int Widescreen::getHorizontalOffset()
{
    return h_offset;
}

inline int Widescreen::getVerticalOffset()
{
    return v_offset;
}

inline bool Widescreen::isResetVerticalPos()
{
    return is_reset_vertical_pos;
}

inline bool Widescreen::isScriptedClipEnabled()
{
    return is_scripted_clip_enabled;
}

inline bool Widescreen::isScriptedVerticalClipEnabled()
{
    return is_scripted_vertical_clip_enabled;
}

inline WIDESCREEN_MODE Widescreen::getMode()
{
    struct game_mode* mode = getmode_cached();
    if (mode->driver_mode != MODE_FIELD) return WM_DISABLED;

    return widescreen_mode;
}

inline WIDESCREEN_MODE Widescreen::getMovieMode()
{
    return widescreen_movie_mode;
}

extern Widescreen widescreen;
````

## File: src/gl/deferred.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../renderer.h"

#include "../gl.h"
#include "../macro.h"
#include "../log.h"
#include "../common.h"
#include "../video/movies.h"
#include "../ff7/battle/menu.h"
#include "../ff7/widescreen.h"

#include "ff7/world/renderer.h"

uint32_t nodefer = false;

#define DEFERRED_MAX 1024

struct deferred_draw *deferred_draws;
uint32_t num_deferred;

struct deferred_sorted_draw *deferred_sorted_draws;
uint32_t num_sorted_deferred;

int lastBlitDrawCallIndex = -1;

// save a draw call for later processing
uint32_t gl_defer_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex* vertices, struct vector3<float>* normals, uint32_t vertexcount, WORD* indices, uint32_t count, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap)
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_draw: call with primitivetype: %u - vertextype: %u - vertexcount: %u - count: %u - clip: %d - mipmap: %d\n", primitivetype, vertextype, vertexcount, count, clip, mipmap);

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_draw: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_draw: deferred draw queue overflow - num_deferred: %u - count: %u - DEFERRED_MAX: %u\n", num_deferred, count, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].count = count;
	deferred_draws[defer].clip = clip;
	deferred_draws[defer].mipmap = mipmap;
	deferred_draws[defer].primitivetype = primitivetype;
	deferred_draws[defer].vertextype = vertextype;
	deferred_draws[defer].vertexcount = vertexcount;
	deferred_draws[defer].indices = (WORD*)driver_malloc(sizeof(*indices) * count);
	deferred_draws[defer].vertices = (nvertex*)driver_malloc(sizeof(*vertices) * vertexcount);
	deferred_draws[defer].draw_call_type = DCT_DRAW;
	if(enable_time_cycle)
		deferred_draws[defer].is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
	if(enable_worldmap_external_mesh)
		deferred_draws[defer].is_fog_enabled = newRenderer.isFogEnabled();
	gl_save_state(&deferred_draws[defer].state);

	memcpy(deferred_draws[defer].indices, indices, sizeof(*indices) * count);
	memcpy(deferred_draws[defer].vertices, vertices, sizeof(*vertices) * vertexcount);

	if (boundingbox)
	{
		deferred_draws[defer].boundingbox = (struct boundingbox*)driver_malloc(sizeof(struct boundingbox));

		deferred_draws[defer].boundingbox->min_x = boundingbox->min_x;
		deferred_draws[defer].boundingbox->min_y = boundingbox->min_y;
		deferred_draws[defer].boundingbox->min_z = boundingbox->min_z;

		deferred_draws[defer].boundingbox->max_x = boundingbox->max_x;
		deferred_draws[defer].boundingbox->max_y = boundingbox->max_y;
		deferred_draws[defer].boundingbox->max_z = boundingbox->max_z;
	}
	else // calculate AABB if no bounding box found
	{
		deferred_draws[defer].boundingbox = (struct boundingbox*)driver_malloc(sizeof(struct boundingbox));

		deferred_draws[defer].boundingbox->min_x = FLT_MAX;
		deferred_draws[defer].boundingbox->min_y = FLT_MAX;
		deferred_draws[defer].boundingbox->min_z = FLT_MAX;

		deferred_draws[defer].boundingbox->max_x = FLT_MIN;
		deferred_draws[defer].boundingbox->max_y = FLT_MIN;
		deferred_draws[defer].boundingbox->max_z = FLT_MIN;

		for (int i = 0; i < vertexcount; ++i)
		{
			float vx = vertices[i]._.x;
			float vy = vertices[i]._.y;
			float vz = vertices[i]._.z;

			deferred_draws[defer].boundingbox->min_x = std::min(deferred_draws[defer].boundingbox->min_x, vx);
			deferred_draws[defer].boundingbox->min_y = std::min(deferred_draws[defer].boundingbox->min_y, vy);
			deferred_draws[defer].boundingbox->min_z = std::min(deferred_draws[defer].boundingbox->min_z, vz);

			deferred_draws[defer].boundingbox->max_x = std::max(deferred_draws[defer].boundingbox->max_x, vx);
			deferred_draws[defer].boundingbox->max_y = std::max(deferred_draws[defer].boundingbox->max_y, vy);
			deferred_draws[defer].boundingbox->max_z = std::max(deferred_draws[defer].boundingbox->max_z, vz);
		}
	}

	if (normals)
	{
		deferred_draws[defer].normals = (vector3<float>*)driver_malloc(sizeof(*normals) * vertexcount);
		memcpy(deferred_draws[defer].normals, normals, sizeof(*normals) * vertexcount);
	}

	if(lightdata)
	{
		deferred_draws[defer].lightdata = (struct light_data*)driver_malloc(sizeof(struct light_data));
		memcpy(deferred_draws[defer].lightdata, lightdata, sizeof(struct light_data));
	}

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_draw: return true\n");

	return true;
}

uint32_t gl_defer_blit_framebuffer(struct texture_set *texture_set, struct tex_header *tex_header)
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_blit_framebuffer_buffer");

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_draw: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_blit_framebuffer_buffer: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].fb_texture_set = texture_set;
	deferred_draws[defer].fb_tex_header = tex_header;
	deferred_draws[defer].draw_call_type = DCT_BLIT;
	lastBlitDrawCallIndex = defer;

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_blit_framebuffer_buffer: return true\n");

	return true;
}

uint32_t gl_defer_clear_buffer(uint32_t clear_color, uint32_t clear_depth, struct game_obj *game_object)
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_clear_buffer");

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_clear_buffer: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_clear_buffer: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].clear_color = clear_color;
	deferred_draws[defer].clear_depth = clear_depth;
	deferred_draws[defer].game_object = game_object;
	deferred_draws[defer].draw_call_type = DCT_CLEAR;

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_clear_buffer: return true\n");

	return true;
}

uint32_t gl_defer_yuv_frame(uint32_t buffer_index)
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_yuv_frame");

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_yuv_frame: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_yuv_frame: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].movie_buffer_index = buffer_index;
	deferred_draws[defer].draw_call_type = DCT_DRAW_MOVIE;

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_yuv_frame: return true\n");

	return true;
}

uint32_t gl_defer_zoom()
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_zoom");

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_zoom: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_zoom: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].draw_call_type = DCT_ZOOM;

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_zoom: return true\n");

	return true;
}

uint32_t gl_defer_world_external_mesh()
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_world_external_mesh");

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_world_external_mesh: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_world_external_mesh: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].draw_call_type = DCT_WORLD_EXTERNAL_MESH;
	deferred_draws[defer].is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
	deferred_draws[defer].is_fog_enabled = newRenderer.isFogEnabled();

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_world_external_mesh: return true\n");

	return true;
}

uint32_t gl_defer_cloud_external_mesh()
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh");

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].draw_call_type = DCT_CLOUD_EXTERNAL_MESH;
	deferred_draws[defer].is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
	deferred_draws[defer].is_fog_enabled = newRenderer.isFogEnabled();

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh: return true\n");

	return true;
}

uint32_t gl_defer_battle_depth_clear()
{
	if (ff8 || !enable_lighting)
	{
		return false;
	}

	if (trace_all) ffnx_trace("gl_defer_battle_depth_clear");

	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_battle_depth_clear: nodefer true\n");
		return false;
	}

	if (num_deferred + 1 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_battle_depth_clear: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
		return false;
	}

	uint32_t defer = num_deferred;

	deferred_draws[defer].draw_call_type = DCT_BATTLE_DEPTH_CLEAR;

	num_deferred++;

	if (trace_all) ffnx_trace("gl_defer_battle_depth_clear: return true\n");

	return true;
}

// re-order and save a draw call for later processing
uint32_t gl_defer_sorted_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, uint32_t clip, uint32_t mipmap, uint32_t force_defer)
{
	uint32_t tri;
	uint32_t mode = getmode_cached()->driver_mode;
	uint32_t *tri_deferred;
	float *tri_z;
	uint32_t defer_index = 0;

	if (trace_all) ffnx_trace("gl_defer_sorted_draw: call with primitivetype: %u - vertextype: %u - vertexcount: %u - count: %u - clip: %d - mipmap: %d\n", primitivetype, vertextype, vertexcount, count, clip, mipmap);

	if(!deferred_sorted_draws) deferred_sorted_draws = (deferred_sorted_draw*)driver_calloc(sizeof(*deferred_sorted_draws), DEFERRED_MAX);

	// global disable
	if (nodefer) {
		if (trace_all) ffnx_trace("gl_defer_sorted_draw: nodefer true\n");
		return false;
	}

	if (!force_defer)
	{
		// output will not be consistent if depth testing is disabled, this call
		// cannot be re-ordered
		if(!current_state.depthtest)
		{
			if (trace_all) ffnx_trace("gl_defer_sorted_draw: depthtest false\n");
			return false;
		}

		// framebuffer textures should not be re-ordered
		if(current_state.fb_texture)
		{
			if (trace_all) ffnx_trace("gl_defer_sorted_draw: fb_texture true\n");
			return false;
		}

		if(current_state.blend_mode != BLEND_NONE)
		{
			if (trace_all) ffnx_trace("gl_defer_sorted_draw: blend_mode != BLEND_NONE - blend_mode: %u\n", current_state.blend_mode);
			if(current_state.blend_mode != BLEND_AVG)
			{
				if (trace_all) ffnx_trace("gl_defer_sorted_draw: blend_mode != BLEND_AVG - blend_mode: %u\n", current_state.blend_mode);
				// be conservative with non-standard blending modes
				if (mode != MODE_MENU && mode != MODE_MAIN_MENU && mode != MODE_BATTLE) {
					if (trace_all) ffnx_trace("gl_defer_sorted_draw: mode != MODE_MENU && mode != MODE_BATTLE - mode: %u\n", mode);
					return false;
				}
			}
		}
		else
		{
			if (!current_state.texture_set)
			{
				if (trace_all) ffnx_trace("gl_defer_sorted_draw: texture_set false\n");
				return false;
			}
			else
			{
				VOBJ(texture_set, texture_set, current_state.texture_set);
				VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));

				if (trace_all) ffnx_trace("gl_defer_sorted_draw: texture_set true for texture %s%d\n", VREF(tex_header, file.pc_name), VREF(tex_header, palette_index));

				// texture format does not support alpha, re-order is not necessary
				if (!VREF(texture_set, ogl.external) && VREF(tex_header, tex_format.alpha_bits) < 2) {
					if (trace_all) ffnx_trace("gl_defer_sorted_draw: texture format does not support alpha, re-order is not necessary\n");
					return false;
				}
			}
		}

		// quads are used for some GUI elements, we do not need to re-order these
		if (primitivetype != RendererPrimitiveType::PT_TRIANGLES) {
			if (trace_all) ffnx_trace("gl_defer_sorted_draw: primitivetype != TRIANGLES\n");
			return false;
		}
	}

	if(num_sorted_deferred + count / 3 > DEFERRED_MAX)
	{
		if (trace_all) ffnx_trace("gl_defer_sorted_draw: deferred draw queue overflow - num_sorted_deferred: %u - count: %u - DEFERRED_MAX: %u\n", num_sorted_deferred, count, DEFERRED_MAX);
		return false;
	}

	tri_deferred = (uint32_t*)driver_calloc(sizeof(*tri_deferred), count / 3);
	tri_z = (float*)driver_calloc(sizeof(*tri_z), count / 3);

	// calculate screen space average Z coordinate for each triangle
	for(tri = 0; tri < count / 3; tri++)
	{
		uint32_t i;

		for(i = 0; i < 3; i++)
		{
			if(vertextype == TLVERTEX) tri_z[tri] += vertices[indices[tri * 3 + i]]._.z;
			else
			{
				struct point4d world;
				struct point4d proj;
				struct point4d view;
				transform_point_w(&current_state.world_view_matrix, &vertices[indices[tri * 3 + i]]._, &world);
				transform_point4d(&current_state.d3dprojection_matrix, &world, &proj);
				transform_point4d(&d3dviewport_matrix, &proj, &view);
				tri_z[tri] += view.z / view.w;
			}
		}

		tri_z[tri] /= 3.0f;
	}

	// arrange triangles into layers based on Z coordinates calculated above
	// each layer will be drawn separately
	while(defer_index < count / 3)
	{
		float z = tri_z[defer_index];
		uint32_t tri_num = 0;
		uint32_t defer = num_sorted_deferred;
		uint32_t vert_index = 0;

		for(tri = 0; tri < count / 3; tri++) if(tri_z[tri] == z) tri_num++;

		deferred_sorted_draws[defer].deferred_draw.count = tri_num * 3;
		deferred_sorted_draws[defer].deferred_draw.clip = clip;
		deferred_sorted_draws[defer].deferred_draw.mipmap = mipmap;
		deferred_sorted_draws[defer].deferred_draw.primitivetype = primitivetype;
		deferred_sorted_draws[defer].deferred_draw.vertextype = vertextype;
		deferred_sorted_draws[defer].deferred_draw.vertexcount = tri_num * 3;
		deferred_sorted_draws[defer].deferred_draw.indices = (WORD*)driver_malloc(sizeof(*indices) * tri_num * 3);
		deferred_sorted_draws[defer].deferred_draw.vertices = (nvertex*)driver_malloc(sizeof(*vertices) * tri_num * 3);
		gl_save_state(&deferred_sorted_draws[defer].deferred_draw.state);
		deferred_sorted_draws[defer].drawn = false;
		deferred_sorted_draws[defer].z = z;
		if(enable_time_cycle)
				deferred_sorted_draws[defer].deferred_draw.is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
		deferred_sorted_draws[defer].deferred_draw.is_fog_enabled = false;

		for(tri = 0; tri < count / 3 && vert_index < tri_num * 3; tri++)
		{
			if(tri_z[tri] == z)
			{
				memcpy(&deferred_sorted_draws[defer].deferred_draw.vertices[vert_index + 0], &vertices[indices[tri * 3 + 0]], sizeof(*vertices));
				memcpy(&deferred_sorted_draws[defer].deferred_draw.vertices[vert_index + 1], &vertices[indices[tri * 3 + 1]], sizeof(*vertices));
				memcpy(&deferred_sorted_draws[defer].deferred_draw.vertices[vert_index + 2], &vertices[indices[tri * 3 + 2]], sizeof(*vertices));
				deferred_sorted_draws[defer].deferred_draw.indices[vert_index + 0] = vert_index + 0;
				deferred_sorted_draws[defer].deferred_draw.indices[vert_index + 1] = vert_index + 1;
				deferred_sorted_draws[defer].deferred_draw.indices[vert_index + 2] = vert_index + 2;

				vert_index += 3;

				tri_deferred[tri] = true;
			}
		}

		if(vert_index < tri_num * 3) ffnx_error("deferred draw z mismatch\n");

		num_sorted_deferred++;

		while(defer_index < count / 3 && tri_deferred[defer_index]) defer_index++;
	}

	driver_free(tri_deferred);
	driver_free(tri_z);

	if (trace_all) ffnx_trace("gl_defer_sorted_draw: return true\n");

	return true;
}

// draw deferred models
void gl_draw_deferred(draw_field_shadow_callback shadow_callback)
{
	struct driver_state saved_state;

	bool isFieldShadowDrawn = false;

	if (num_deferred == 0) {
		if (trace_all) ffnx_trace("gl_draw_deferred: num_deferred == 0\n");
		return;
	}

	gl_save_state(&saved_state);

	nodefer = true;

	for (int i = 0; i < num_deferred; ++i)
	{
		if(enable_time_cycle)
			newRenderer.setTimeFilterEnabled(deferred_draws[i].is_time_filter_enabled);

		if(enable_worldmap_external_mesh)
			newRenderer.setFogEnabled(deferred_draws[i].is_fog_enabled);

		if(deferred_draws[i].draw_call_type == DCT_CLEAR)
		{
			common_clear(deferred_draws[i].clear_color, deferred_draws[i].clear_depth, true, deferred_draws[i].game_object);
			continue;
		} else if(deferred_draws[i].draw_call_type == DCT_BLIT)
		{
			blit_framebuffer_texture(deferred_draws[i].fb_texture_set, deferred_draws[i].fb_tex_header);
			continue;
		}
		else if(deferred_draws[i].draw_call_type == DCT_DRAW_MOVIE)
		{
			draw_yuv_frame(deferred_draws[i].movie_buffer_index);
			continue;
		}
		else if(deferred_draws[i].draw_call_type == DCT_ZOOM)
		{
			widescreen.zoomBackground();
			continue;
		}
		else if(deferred_draws[i].draw_call_type == DCT_BATTLE_DEPTH_CLEAR)
		{
			ff7::battle::battle_depth_clear();
			continue;
		}
		else if(deferred_draws[i].draw_call_type == DCT_WORLD_EXTERNAL_MESH)
		{
			ff7::world::worldRenderer.drawWorldMapExternalMesh();
			continue;
		}
		else if(deferred_draws[i].draw_call_type == DCT_CLOUD_EXTERNAL_MESH)
		{
			ff7::world::worldRenderer.drawCloudsAndMeteorExternalMesh(*ff7_externals.is_meteor_flag_on_E2AAE4);
			continue;
		}

		if (deferred_draws[i].vertices == nullptr)
		{
			continue;
		}

		if (shadow_callback != nullptr && !isFieldShadowDrawn && deferred_draws[i].vertextype != TLVERTEX)
		{
			newRenderer.setD3DProjection(&deferred_draws[i].state.d3dprojection_matrix);
			newRenderer.setD3DViweport(&d3dviewport_matrix);

			(*shadow_callback)();
			isFieldShadowDrawn = true;
		}

		gl_load_state(&deferred_draws[i].state);

		gl_draw_indexed_primitive(deferred_draws[i].primitivetype,
			deferred_draws[i].vertextype,
			deferred_draws[i].vertices,
			i > lastBlitDrawCallIndex ? deferred_draws[i].normals : 0,
			deferred_draws[i].vertexcount,
			deferred_draws[i].indices,
			deferred_draws[i].count,
			0,
			deferred_draws[i].boundingbox,
			deferred_draws[i].lightdata,
			deferred_draws[i].clip,
			deferred_draws[i].mipmap
		);

		++stats.deferred;

		driver_free(deferred_draws[i].vertices);
		deferred_draws[i].vertices = nullptr;
		driver_free(deferred_draws[i].indices);
		deferred_draws[i].indices = nullptr;
		driver_free(deferred_draws[i].normals);
		deferred_draws[i].normals = nullptr;
		driver_free(deferred_draws[i].boundingbox);
		deferred_draws[i].boundingbox = nullptr;
		driver_free(deferred_draws[i].lightdata);
		deferred_draws[i].lightdata = nullptr;
	}

	num_deferred = 0;
	lastBlitDrawCallIndex = -1;

	nodefer = false;

	gl_load_state(&saved_state);
}

struct boundingbox calculateSceneAabb()
{
	struct boundingbox sceneAabb;
	sceneAabb.min_x = FLT_MAX;
	sceneAabb.min_y = FLT_MAX;
	sceneAabb.min_z = FLT_MAX;
	sceneAabb.max_x = FLT_MIN;
	sceneAabb.max_y = FLT_MIN;
	sceneAabb.max_z = FLT_MIN;
	for (int i = 0; i < num_deferred; ++i)
	{
		if (deferred_draws[i].vertextype == TLVERTEX)
		{
			continue;
		}
		if (deferred_draws[i].normals == nullptr || deferred_draws[i].count == 3)
		{
			continue;
		}

		struct boundingbox* bb = deferred_draws[i].boundingbox;
		if (bb)
		{
			vector3<float> corners[8] = { {bb->min_x, bb->min_y, bb->min_z},
									   {bb->min_x, bb->min_y, bb->max_z},
			                           {bb->min_x, bb->max_y, bb->min_z},
			                           {bb->min_x, bb->max_y, bb->max_z},
			                           {bb->max_x, bb->min_y, bb->min_z},
			                           {bb->max_x, bb->min_y, bb->max_z},
			                           {bb->max_x, bb->max_y, bb->min_z},
			                           {bb->max_x, bb->max_y, bb->max_z} };

			struct matrix worldViewMatrix = deferred_draws[i].state.world_view_matrix;
			for (int j = 0; j < 8; ++j)
			{
				vector3<float> cornerViewSpace;
				transform_point(&worldViewMatrix, &corners[j], &cornerViewSpace);

				sceneAabb.min_x = std::min(sceneAabb.min_x, cornerViewSpace.x);
				sceneAabb.min_y = std::min(sceneAabb.min_y, cornerViewSpace.y);
				sceneAabb.min_z = std::min(sceneAabb.min_z, cornerViewSpace.z);

				sceneAabb.max_x = std::max(sceneAabb.max_x, cornerViewSpace.x);
				sceneAabb.max_y = std::max(sceneAabb.max_y, cornerViewSpace.y);
				sceneAabb.max_z = std::max(sceneAabb.max_z, cornerViewSpace.z);
			}
		}
	}

	return sceneAabb;
}

// draw all the layers we've accumulated in the correct order and reset queue
void gl_draw_sorted_deferred()
{
	struct driver_state saved_state;

	if (num_sorted_deferred == 0) {
		if (trace_all) ffnx_trace("gl_draw_sorted_deferred: num_sorted_deferred == 0\n");
		return;
	}

	gl_save_state(&saved_state);

	nodefer = true;

	stats.deferred += num_sorted_deferred;

	while(true)
	{
		uint32_t i;
		double z = -1.0;
		uint32_t next = -1;

		for(i = 0; i < num_sorted_deferred; i++)
		{
			if(deferred_sorted_draws[i].z > z && !deferred_sorted_draws[i].drawn)
			{
				next = i;
				z = deferred_sorted_draws[i].z;
			}
		}

		if(next == -1) break;

		gl_load_state(&deferred_sorted_draws[next].deferred_draw.state);
		internal_set_renderstate(V_DEPTHTEST, 1, 0);
		internal_set_renderstate(V_DEPTHMASK, 1, 0);

		if(enable_time_cycle)
			newRenderer.setTimeFilterEnabled(deferred_sorted_draws[next].deferred_draw.is_time_filter_enabled);

		gl_draw_indexed_primitive(deferred_sorted_draws[next].deferred_draw.primitivetype,
								  deferred_sorted_draws[next].deferred_draw.vertextype,
								  deferred_sorted_draws[next].deferred_draw.vertices,
								  0,
								  deferred_sorted_draws[next].deferred_draw.vertexcount,
								  deferred_sorted_draws[next].deferred_draw.indices,
								  deferred_sorted_draws[next].deferred_draw.count,
								  0,
								  0,
								  0,
								  deferred_sorted_draws[next].deferred_draw.clip,
								  deferred_sorted_draws[next].deferred_draw.mipmap
								  );

		driver_free(deferred_sorted_draws[next].deferred_draw.vertices);
		driver_free(deferred_sorted_draws[next].deferred_draw.indices);
		deferred_sorted_draws[next].drawn = true;
	}

	num_sorted_deferred = 0;

	nodefer = false;

	gl_load_state(&saved_state);
}

// a texture is being unloaded, invalidate any pending draw calls associated
// with it and perform the necessary cleanup
void gl_check_deferred(struct texture_set *texture_set)
{
	uint32_t i;

	for (i = 0; i < num_deferred; i++)
	{
		if (deferred_draws[i].state.texture_set == texture_set)
		{
			driver_free(deferred_draws[i].vertices);
			deferred_draws[i].vertices = nullptr;
			driver_free(deferred_draws[i].indices);
			deferred_draws[i].indices = nullptr;
			driver_free(deferred_draws[i].normals);
			deferred_draws[i].normals = nullptr;
			driver_free(deferred_draws[i].boundingbox);
			deferred_draws[i].boundingbox = nullptr;
			driver_free(deferred_draws[i].lightdata);
			deferred_draws[i].lightdata = nullptr;
		}
	}

	for(i = 0; i < num_sorted_deferred; i++)
	{
		if(deferred_sorted_draws[i].deferred_draw.state.texture_set == texture_set)
		{
			driver_free(deferred_sorted_draws[i].deferred_draw.vertices);
			driver_free(deferred_sorted_draws[i].deferred_draw.indices);
			deferred_sorted_draws[i].drawn = true;
		}
	}
}

void gl_cleanup_deferred()
{
	driver_free(deferred_draws);
	deferred_draws = nullptr;
	driver_free(deferred_sorted_draws);
	deferred_sorted_draws = nullptr;
}
````

## File: src/gl/gl.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <stdio.h>
#include <math.h>
#include <algorithm>

#include "../renderer.h"
#include "../cfg.h"
#include "../gl.h"
#include "../macro.h"
#include "../log.h"
#include "../matrix.h"

#include "../ff7/widescreen.h"

struct matrix d3dviewport_matrix = {
	1.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 1.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 1.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 1.0f
};

struct driver_state current_state;

int max_texture_size;

extern uint32_t nodefer;

// draw a fullscreen quad, respect aspect ratio of source image
void gl_draw_movie_quad_common(uint32_t width, uint32_t height)
{
	struct game_obj *game_object = common_externals.get_game_object();
	uint32_t cur_game_width = game_width;
	if (!ff8)
	{
		if (widescreen.getMovieMode() == WM_EXTEND_ONLY)
		{
			cur_game_width = wide_game_width;
		}
	}

	float ratio = cur_game_width / (float)width;
	float movieHeight = ratio * height;
	float movieWidth = ratio * width;
	float movieOffsetY = (game_height - movieHeight) / 2.0f;

	if (!ff8 && enable_time_cycle) newRenderer.setTimeFilterEnabled(true);

	if (!ff8 && !ff7_field_center) movieOffsetY = 0.0f;

	float movie_quad_x = 0.0f;
	float movie_quad_y = movieOffsetY;
	float movie_quad_height = movieHeight + movieOffsetY;
	float movie_quad_width = movieWidth;
	if (!ff8)
	{
		if (widescreen.getMovieMode() == WM_FILL)
		{
			movie_quad_x = wide_viewport_x;
			movie_quad_y = 0.0f;
			movie_quad_height = movieHeight + 2 * movieOffsetY;
			movie_quad_width = wide_game_width;
		} else if (widescreen.getMovieMode() == WM_EXTEND_ONLY)
		{
			movie_quad_x = (game_width - movieWidth) / 2.0f;
		}
	}

	/*  y0    y2
	 x0 +-----+ x2
		|    /|
		|   / |
		|  /  |
		| /   |
		|/    |
	 x1 +-----+ x3
		y1    y3
	*/

	// 0
	float x0 = movie_quad_x;
	float y0 = movie_quad_y;
	float u0 = 0.0f;
	float v0 = 0.0f;
	// 1
	float x1 = x0;
	float y1 = movie_quad_height;
	float u1 = u0;
	float v1 = 1.0f;
	// 2
	float x2 = x0 + movie_quad_width;
	float y2 = y0;
	float u2 = 1.0f;
	float v2 = v0;
	// 3
	float x3 = x2;
	float y3 = y1;
	float u3 = u2;
	float v3 = v1;

	struct nvertex vertices[] = {
		{x0, y0, 1.0f, 1.0f, 0xffffffff, 0, u0, v0},
		{x1, y1, 1.0f, 1.0f, 0xffffffff, 0, u1, v1},
		{x2, y2, 1.0f, 1.0f, 0xffffffff, 0, u2, v2},
		{x3, y3, 1.0f, 1.0f, 0xffffffff, 0, u3, v3},
	};
	WORD indices[] = {
		0, 1, 2,
		1, 3, 2
	};

	current_state.texture_filter = true;

	internal_set_renderstate(V_NOCULL, 1, game_object);
	internal_set_renderstate(V_DEPTHTEST, 0, game_object);
	internal_set_renderstate(V_DEPTHMASK, 0, game_object);

	newRenderer.setInterpolationQualifier(RendererInterpolationQualifier::SMOOTH);
	newRenderer.bindVertexBuffer(vertices, 0, 4);
	newRenderer.bindIndexBuffer(indices, 6);

	newRenderer.isTLVertex(true);
	newRenderer.doTextureFiltering(current_state.texture_filter);

	newRenderer.draw();
}

// draw movie frame
void gl_draw_movie_quad(uint32_t width, uint32_t height)
{
	struct driver_state saved_state;

	gl_save_state(&saved_state);

	gl_draw_movie_quad_common(width, height);

	gl_load_state(&saved_state);
}

// save complete rendering state to memory
void gl_save_state(struct driver_state *dest)
{
	memcpy(dest, &current_state, sizeof(current_state));
}

// restore complete rendering state from memory
void gl_load_state(struct driver_state *src)
{
	VOBJ(texture_set, texture_set, src->texture_set);

	memcpy(&current_state, src, sizeof(current_state));

	gl_bind_texture_set(src->texture_set);
	gl_set_texture(src->texture_handle, src->texture_set ? VREF(texture_set, ogl.gl_set) : NULL);
	current_state.texture_set = src->texture_set;
	common_setviewport(src->viewport[0], src->viewport[1], src->viewport[2], src->viewport[3], 0);
	gl_set_blend_func(src->blend_mode);
	internal_set_renderstate(V_WIREFRAME, src->wireframe, 0);
	// setting V_LINEARFILTER has no side effects
	internal_set_renderstate(V_CULLFACE, src->cullface, 0);
	internal_set_renderstate(V_NOCULL, src->nocull, 0);
	internal_set_renderstate(V_DEPTHTEST, src->depthtest, 0);
	internal_set_renderstate(V_DEPTHMASK, src->depthmask, 0);
	internal_set_renderstate(V_ALPHATEST, src->alphatest, 0);
	internal_set_renderstate(V_ALPHAFUNC, src->alphafunc, 0);
	internal_set_renderstate(V_ALPHAREF, src->alpharef, 0);
	internal_set_renderstate(V_SHADEMODE, src->shademode, 0);
	gl_set_worldview_matrix(&src->world_view_matrix);
	gl_set_d3dprojection_matrix(&src->d3dprojection_matrix);
}

void gl_calculate_normals(std::vector<vector3<float>>* pNormals, struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata)
{
	bool has_model_data = false;
	static vector3<float> zero = { 0.0f, 0.0f, 0.0f };
	auto& normals = *pNormals;

	normals.resize(ip->vertexcount);
	std::fill(normals.begin(), normals.end(), zero);

	// User wants to attempt to load model data
	if (!prefer_lighting_cpu_calculations)
	{
		// If models do provide normal data, use it
		if (polydata->normaldata != NULL)
		{
			for (uint32_t idx = 0; idx < ip->vertexcount; idx++)
			{
				normals[idx] = polydata->has_normindextable ? polydata->normaldata[polydata->normindextabledata[idx]] : polydata->normaldata[idx];
			}

			has_model_data = true;
		}
	}

	// If the previous code was not able to fetch the model normal data, we have to calculate it on the CPU
	if (!has_model_data)
	{
		vector3<float> e12, e13, triNormal;

		// Calculate vertex normals by averaging adjacent triangle normals
		// Vertex normals are calculated here because battle models dont seem to include normals
		for (uint32_t idx = 0; idx < ip->indexcount; idx+=3)
		{
			e12 = e13 = triNormal = zero;

			int vId0 = ip->indices[idx];
			int vId1 = ip->indices[idx + 1];
			int vId2 = ip->indices[idx + 2];

			auto v1 = &ip->vertices[vId0]._;
			auto v2 = &ip->vertices[vId1]._;
			auto v3 = &ip->vertices[vId2]._;

			subtract_vector(v2, v1, &e12);
			subtract_vector(v3, v1, &e13);
			cross_product(&e13, &e12, &triNormal);

			add_vector(&normals[vId0], &triNormal, &normals[vId0]);
			add_vector(&normals[vId1], &triNormal, &normals[vId1]);
			add_vector(&normals[vId2], &triNormal, &normals[vId2]);
		}

		for (uint32_t idx = 0; idx < ip->vertexcount; idx++)
		{
			normalize_vector(&normals[idx]);
		}
	}
}

void gl_draw_without_lighting(struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip)
{
	static std::vector<vector3<float>> normals;
	if (!ff8 && lightdata != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
	{
		gl_calculate_normals(&normals, ip, polydata, lightdata);
		gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, normals.data(), ip->vertexcount, ip->indices, ip->indexcount, 0, 0, lightdata, clip, true);
	} else gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, nullptr, ip->vertexcount, ip->indices, ip->indexcount, 0, 0, lightdata, clip, true);
}

// draw a set of primitives with lighting
void gl_draw_with_lighting(struct indexed_primitive *ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip)
{
	static std::vector<vector3<float>> normals;
	if (!ff8)
	{
		gl_calculate_normals(&normals, ip, polydata, lightdata);
		gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, normals.data(), ip->vertexcount, ip->indices, ip->indexcount, 0, polydata->boundingboxdata, lightdata, clip, true);
	}
	else gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, nullptr, ip->vertexcount, ip->indices, ip->indexcount, 0, polydata->boundingboxdata, lightdata, clip, true);
}

// main rendering routine, draws a set of primitives according to the current render state
void gl_draw_indexed_primitive(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, struct vector3<float>* normals, uint32_t vertexcount, WORD *indices, uint32_t count, struct graphics_object *graphics_object, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap)
{
	FILE *log;
	uint32_t i;
	uint32_t mode = getmode_cached()->driver_mode;
	// filter setting can change inside this function, we don't want that to
	// affect the global rendering state so save & restore it
	uint32_t saved_texture_filter = current_state.texture_filter;

	// should never happen, broken 3rd-party models cause this
	if(!count) return;

	// scissor test is used to emulate D3D viewports
	if (clip) newRenderer.doScissorTest(true);
	else newRenderer.doScissorTest(false);

	if(vertextype > TLVERTEX)
	{
		ffnx_unexpected_once("vertextype > TLVERTEX\n");
		return;
	}

	newRenderer.setInterpolationQualifier(current_state.shademode ? RendererInterpolationQualifier::SMOOTH : RendererInterpolationQualifier::FLAT);

	// handle some special cases, see special_case.c
	if(gl_special_case(primitivetype, vertextype, vertices, vertexcount, indices, count, graphics_object, clip, mipmap))
	{
		// special cases can signal back to this function that the draw call has
		// been handled in some other manner
		current_state.texture_filter = saved_texture_filter;
		return;
	}
	else if(gl_defer_draw(primitivetype, vertextype, vertices, normals, vertexcount, indices, count, boundingbox, lightdata, clip, mipmap))
	{
		current_state.texture_filter = saved_texture_filter;
		return;
	}

	bool isLightingEnabledTexture = true;

	// If we're attaching a texture, and it is an external one, then use a better blending that considers the alpha channel
	if (current_state.texture_set)
	{
		VOBJ(texture_set, texture_set, current_state.texture_set);

		if (VREF(texture_set, ogl.external)) newRenderer.isExternalTexture(true);

		if(enable_lighting && VREF(texture_set, ogl.gl_set->disable_lighting))
		{
			isLightingEnabledTexture = false;
		}
	}

	// OpenGL treats texture filtering as a per-texture parameter, we need it
	// to be consistent with our global render state
	newRenderer.doTextureFiltering(current_state.texture_filter);

	if(vertextype != TLVERTEX)
	{
		newRenderer.setD3DProjection(&current_state.d3dprojection_matrix);
		newRenderer.setD3DViweport(&d3dviewport_matrix);
	}

	newRenderer.isTLVertex(vertextype == TLVERTEX);
	newRenderer.isFBTexture(current_state.fb_texture);

	newRenderer.doModulateAlpha(true);

	//// upload vertex data
	newRenderer.bindVertexBuffer(vertices, normals, vertexcount);
	newRenderer.bindIndexBuffer(indices, count);
	newRenderer.setPrimitiveType(RendererPrimitiveType(primitivetype));

	if(!ff8 && lightdata != nullptr && normals != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
	{
		newRenderer.setGameLightData(lightdata);
	} else newRenderer.setGameLightData(nullptr);

	if (!ff8 && enable_lighting && normals != nullptr && isLightingEnabledTexture)
	{
		newRenderer.drawToShadowMap();
		newRenderer.drawWithLighting(true, true);
	}
	else newRenderer.draw();

	stats.vertex_count += count;

	current_state.texture_filter = saved_texture_filter;
}

void gl_set_worldview_matrix(struct matrix *matrix)
{
	newRenderer.setWorldViewMatrix(matrix);
	memcpy(&current_state.world_view_matrix, matrix, sizeof(struct matrix));
}

void gl_set_d3dprojection_matrix(struct matrix *matrix)
{
	memcpy(&current_state.d3dprojection_matrix, matrix, sizeof(struct matrix));
}

// apply blend mode to OpenGL state
void gl_set_blend_func(uint32_t blend_mode)
{
	if(trace_all) ffnx_trace("set blend mode %i\n", blend_mode);

	current_state.blend_mode = blend_mode;

	newRenderer.setBlendMode(RendererBlendMode(blend_mode));
}

// draw text on screen using the game font
uint32_t gl_draw_text(uint32_t x, uint32_t y, uint32_t color, uint32_t alpha, char *fmt, ...)
{
	char text[4096];
	va_list args;

	va_start(args, fmt);
	vsnprintf(text, 4096, fmt, args);
	newRenderer.printText(x, y, color, text);
	va_end(args);

	return true;
}
````

## File: src/gl/special_case.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#define _USE_MATH_DEFINES
#include <math.h>

#include "../gl.h"
#include "../cfg.h"
#include "../macro.h"
#include "../globals.h"

#include "../ff7/widescreen.h"

#define SAFE_GFXOBJ_CHECK(X, Y) ((X) && (X) == (struct graphics_object *)(Y))

// rendering special cases, returns true if the draw call has been handled in
// some way and should not be rendered normally
// it is generally not safe to modify source data directly, a copy should be
// made and rendered separately
uint32_t gl_special_case(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, struct graphics_object *graphics_object, uint32_t clip, uint32_t mipmap)
{
	uint32_t mode = getmode_cached()->driver_mode;
	VOBJ(texture_set, texture_set, current_state.texture_set);
	uint32_t defer = false, force_defer = false;

	// modpath textures rendered in 3D should always be filtered
	if(vertextype != TLVERTEX && current_state.texture_set && VREF(texture_set, ogl.external)) current_state.texture_filter = true;

	// modpath textures in menu should always be filtered
	if((mode == MODE_MENU || mode == MODE_MAIN_MENU) && current_state.texture_set && VREF(texture_set, ogl.external)) current_state.texture_filter = true;

	// some modpath textures have filtering forced on
	if(current_state.texture_set && VREF(texture_set, ogl.gl_set->force_filter) && VREF(texture_set, ogl.external)) current_state.texture_filter = true;

	// Texture filtering mostly does not work well in FF8
	if(ff8) current_state.texture_filter = enable_bilinear && vertextype != TLVERTEX && current_state.texture_set;
	else if (enable_bilinear && (vertextype != TLVERTEX || mode == MODE_MENU || mode == MODE_MAIN_MENU || (current_state.texture_set && VREF(texture_set, ogl.gl_set->force_filter)))) current_state.texture_filter = true;

	// some modpath textures have z-sort forced on
	if(current_state.texture_set && VREF(texture_set, ogl.gl_set->force_zsort) && VREF(texture_set, ogl.external)) defer = true;

	// z-sort by default in menu, unnecessary sorting will be avoided by defer logic
	if(mode == MODE_MENU || mode == MODE_MAIN_MENU) defer = true;

	if(!ff8)
	{
		if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->buster_tex))
		{
			// stretch main menu to fullscreen if it is a modpath texture
			if(VREF(texture_set, ogl.external) && vertexcount == 4)
			{
				float texture_ratio = VREF(texture_set, ogl.width) / (float)VREF(texture_set, ogl.height);
				bool use_wide_vertices = abs(texture_ratio - 16 / (aspect_ratio == AR_WIDESCREEN_16X10 ? 10.f : 9.f)) <= 0.01 && widescreen_enabled;
				float x = use_wide_vertices ? wide_viewport_x : 0.0f;
				float y = 0.0f;
				float width = use_wide_vertices ? wide_viewport_width : game_width;
				float height = game_height;
				vertices[0]._.x = x;
				vertices[0]._.y = y;
				vertices[0]._.z = 1.0f;
				vertices[1]._.x = x;
				vertices[1]._.y = y + height;
				vertices[1]._.z = 1.0f;
				vertices[2]._.x = x + width;
				vertices[2]._.y = y;
				vertices[2]._.z = 1.0f;
				vertices[3]._.x = x + width;
				vertices[3]._.y = y + height;
				vertices[3]._.z = 1.0f;
				vertices[0].u = 0.0f;
				vertices[0].v = 0.0f;
				vertices[1].u = 0.0f;
				vertices[1].v = 1.0f;
				vertices[2].u = 1.0f;
				vertices[2].v = 0.0f;
				vertices[3].u = 1.0f;
				vertices[3].v = 1.0f;
			}
		}

		if(current_state.texture_set && VREF(texture_set, tex_header))
		{
			VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));

			if((uint32_t)VREF(tex_header, file.pc_name) > 32)
			{
				// avoid filtering window borders
				if(!_strnicmp(VREF(tex_header, file.pc_name), "menu/btl_win_c_", strlen("menu/btl_win_c_") - 1) && VREF(texture_set, palette_index) == 0) current_state.texture_filter = false;
			}
		}

		// z-sort select menu elements everywhere
		if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->menu_fade)) defer = true;
		if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->blend_window_bg)) defer = true;

		if(mode == MODE_FIELD)
		{
			// always z-sort vanilla messages
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->window_bg)) force_defer = true;

			// fix timer messages when window is normal
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->_btl_win)) force_defer = true;
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_a)) force_defer = true;
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_b)) force_defer = true;
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_c)) force_defer = true;
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_d)) force_defer = true;
		}

		if(mode == MODE_BATTLE)
		{
			// z-sort some GUI elements in battle
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->unknown2)) defer = true; // Limit and barrier bar (necessary for ESUI)
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->unknown3)) defer = true; // Limit and barrier bar (necessary for ESUI)
			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->unknown5)) defer = true; // Limit box (necessary for ESUI)
		}
	}

	if((defer || force_defer) && !ff8) return gl_defer_sorted_draw(primitivetype, vertextype, vertices, vertexcount, indices, count, clip, mipmap, force_defer);

	return false;
}
````

## File: src/gl/texture.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../renderer.h"

#include "../log.h"
#include "../gl.h"
#include "../macro.h"

// check to make sure we can actually load a given texture
bool gl_check_texture_dimensions(uint32_t width, uint32_t height, char *source)
{
	if (width > max_texture_size || height > max_texture_size) {
		ffnx_error("Texture dimensions exceed max texture size, will not be able to load %s\n", source);
		return false;
	}
	else
		return true;
}

// apply OpenGL texture for a certain palette in a texture set, possibly
// replacing an existing texture which will then be unloaded
void gl_replace_texture(struct texture_set *texture_set, uint32_t palette_index, uint32_t new_texture)
{
	VOBJ(texture_set, texture_set, texture_set);

	if(VREF(texture_set, texturehandle[palette_index]))
	{
		if (VREF(texture_set, ogl.external) && !VREF(texture_set, ogl.gl_set->is_animated)) ffnx_glitch("oops, may have messed up an external texture\n");
		if (!VREF(texture_set, ogl.external) || !VREF(texture_set, ogl.gl_set->is_animated)) newRenderer.deleteTexture(VREF(texture_set, texturehandle[palette_index]));
	}

	VRASS(texture_set, texturehandle[palette_index], new_texture);
}

// upload texture for a texture set from raw pixel data
void gl_upload_texture(struct texture_set *texture_set, uint32_t palette_index, void *image_data, uint32_t format)
{
	uint32_t w, h;
	VOBJ(texture_set, texture_set, texture_set);
	VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));

	if(VREF(texture_set, ogl.external))
	{
		w = VREF(texture_set, ogl.width);
		h = VREF(texture_set, ogl.height);
	}
	else
	{
		w = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.w) : VREF(tex_header, tex_format.width);
		h = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.h) : VREF(tex_header, tex_format.height);
	}

	gl_check_texture_dimensions(w, h, "unknown");

	uint32_t newTexture = newRenderer.createTexture(
		(uint8_t*)image_data,
		w,
		h,
		0,
		RendererTextureType(format)
	);

	gl_replace_texture(
		texture_set,
		palette_index,
		newTexture
	);

	if (trace_all) ffnx_trace("Created internal texture: %u\n", newTexture);
}

// prepare texture set for rendering
void gl_bind_texture_set(struct texture_set *_texture_set)
{
	VOBJ(texture_set, texture_set, _texture_set);

	if(VPTR(texture_set))
	{
		VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));

		struct gl_texture_set* gl_set = VREF(texture_set, ogl.gl_set);

		gl_set_texture(VREF(texture_set, texturehandle[VREF(tex_header, palette_index)]), gl_set);

		if(VREF(tex_header, version) == FB_TEX_VERSION) current_state.fb_texture = true;
		else current_state.fb_texture = false;
	}
	else gl_set_texture(0, NULL);

	current_state.texture_set = _texture_set;
}

// prepare an OpenGL texture for rendering, passing zero to this function will
// disable texturing entirely
void gl_set_texture(uint32_t texture, struct gl_texture_set* gl_set)
{
	if(trace_all) ffnx_trace("gl_set_texture: set texture %i\n", texture);

	newRenderer.useTexture(texture);

	// Attach additional textures only for non-paletted static textures
	if (gl_set && !gl_set->is_animated)
	{
		for (short slot = RendererTextureSlot::TEX_NML; slot < RendererTextureSlot::COUNT; slot++)
			newRenderer.useTexture(texture > 0 ? gl_set->additional_textures[slot] : 0, slot);
	}

	current_state.texture_handle = texture;
	current_state.texture_set = 0;
}
````

## File: src/image/image.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <stdio.h>
#include <libpng16/png.h>

#include "image.h"
#include "../common.h"
#include "../renderer.h"
#include "log.h"

static void LibPngErrorCb(png_structp png_ptr, const char* error)
{
    ffnx_error("libpng error: %s\n", error);
}

static void LibPngWarningCb(png_structp png_ptr, const char* warning)
{
    ffnx_info("libpng warning: %s\n", warning);
}

bool loadPng(const char *filename, bimg::ImageMip &mip, bimg::TextureFormat::Enum targetFormat)
{
    FILE* file = fopen(filename, "rb");

    if (!file)
    {
        return false;
    }

    png_infop info_ptr = nullptr;
    png_structp png_ptr = nullptr;

    png_uint_32 _width = 0, _height = 0;
    png_byte color_type = 0, bit_depth = 0;

    png_bytepp rowptrs = nullptr;
    size_t rowbytes = 0;

    uint8_t* data = nullptr;
    size_t datasize = 0;

    fseek(file, 0, SEEK_END);
    datasize = ftell(file);
    fseek(file, 0, SEEK_SET);

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, (png_voidp)0, LibPngErrorCb, LibPngWarningCb);

    if (!png_ptr)
    {
        fclose(file);

        return false;
    }

    info_ptr = png_create_info_struct(png_ptr);

    if (!info_ptr)
    {
        png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);

        fclose(file);

        return false;
    }

    if (setjmp(png_jmpbuf(png_ptr)))
    {
        png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);

        fclose(file);

        return false;
    }

    png_init_io(png_ptr, file);

    png_set_filter(png_ptr, 0, PNG_FILTER_NONE);

    if (!Renderer::doesItFitInMemory(datasize))
    {
        png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);

        fclose(file);

        return false;
    }

    int transforms = PNG_TRANSFORM_EXPAND;

    if (targetFormat == bimg::TextureFormat::BGRA8) {
        transforms |= PNG_TRANSFORM_STRIP_16 | PNG_TRANSFORM_GRAY_TO_RGB | PNG_TRANSFORM_BGR;
    } else if (targetFormat == bimg::TextureFormat::RGBA8) {
        transforms |= PNG_TRANSFORM_STRIP_16 | PNG_TRANSFORM_GRAY_TO_RGB;
    }

    png_read_png(png_ptr, info_ptr, transforms, NULL);

    color_type = png_get_color_type(png_ptr, info_ptr);
    bit_depth = png_get_bit_depth(png_ptr, info_ptr);
    _width = png_get_image_width(png_ptr, info_ptr);
    _height = png_get_image_height(png_ptr, info_ptr);

    if (color_type == PNG_COLOR_TYPE_RGB && (targetFormat == bimg::TextureFormat::BGRA8 || targetFormat == bimg::TextureFormat::RGBA8)) {
        ffnx_warning("%s: PNG files without alpha is not supported, please convert it to RGBA for improved performance\n", __func__);

        return false;
    }

    rowptrs = png_get_rows(png_ptr, info_ptr);
    rowbytes = png_get_rowbytes(png_ptr, info_ptr);

    datasize = rowbytes * _height;

    if (trace_all || trace_loaders) ffnx_trace("%s: data_size=%d width=%d height=%d bit_depth=%d color_type=%X\n", __func__, datasize, _width, _height, bit_depth, color_type);

    if (!Renderer::doesItFitInMemory(datasize))
    {
        png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);

        fclose(file);

        return false;
    }

    data = (uint8_t*)driver_calloc(datasize, sizeof(uint8_t));

    for (png_uint_32 y = 0; y < _height; y++) memcpy(data + (rowbytes * y), rowptrs[y], rowbytes);

    png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);

    fclose(file);

    // ------------------------------------------------------------

    bimg::TextureFormat::Enum texFmt = bimg::TextureFormat::Unknown;

    switch (bit_depth)
    {
    case 8:
    {
        switch (color_type)
        {
        case PNG_COLOR_TYPE_GRAY:
            texFmt = bimg::TextureFormat::R8;
            break;
        case PNG_COLOR_TYPE_GRAY_ALPHA:
            texFmt = bimg::TextureFormat::RG8;
            break;
        case PNG_COLOR_TYPE_RGB:
            texFmt = bimg::TextureFormat::RGB8;
            break;
        case PNG_COLOR_TYPE_RGBA:
        case PNG_COLOR_TYPE_PALETTE:
            texFmt = bimg::TextureFormat::RGBA8;
            break;
        }
        break;
    }
    case 16:
    {
        switch (color_type)
        {
        case PNG_COLOR_TYPE_GRAY:
            texFmt = bimg::TextureFormat::R16;
            break;
        case PNG_COLOR_TYPE_GRAY_ALPHA:
            texFmt = bimg::TextureFormat::RG16;
            break;
        case PNG_COLOR_TYPE_RGB:
        case PNG_COLOR_TYPE_RGBA:
            texFmt = bimg::TextureFormat::RGBA16;
            break;
        case PNG_COLOR_TYPE_PALETTE:
            break;
        }
        break;
    }
    default:
        break;
    }

    if (texFmt != bimg::TextureFormat::Unknown)
    {
        mip.m_blockSize = 0;
        mip.m_bpp = 0;
        mip.m_data = data;
        mip.m_depth = 0;
        mip.m_format = texFmt;
        mip.m_hasAlpha = true;
        mip.m_size = datasize;
        mip.m_width = _width;
        mip.m_height = _height;

        return true;
    }
    else
    {
        driver_free(data);
    }

    return false;
}

bool parseDds(const char *filename, DirectX::ScratchImage &image, DirectX::TexMetadata &metadata)
{
    wchar_t filenameW[MAX_PATH];

    mbstowcs(filenameW, filename, MAX_PATH);

    HRESULT hr = DirectX::LoadFromDDSFile(
        filenameW,
        DirectX::DDS_FLAGS_NONE, &metadata, image
    );
    if (FAILED(hr) || image.GetImageCount() == 0)
    {
        ffnx_error("%s: Load DDS from file error (%d)\n", __func__, HRESULT_CODE(hr));

        return false;
    }

    return true;
}

bimg::ImageContainer *convertDds(bx::AllocatorI *allocator, DirectX::ScratchImage &image, const DirectX::TexMetadata &metadata, bimg::TextureFormat::Enum targetFormat, int lod)
{
    if (lod >= image.GetImageCount())
    {
        lod = image.GetImageCount() - 1;
    }

    const DirectX::Image &mainImage = image.GetImages()[lod];
    DXGI_FORMAT format = DXGI_FORMAT_R8G8B8A8_UNORM;

    if (targetFormat == bimg::TextureFormat::BGRA8) {
        format = DXGI_FORMAT_B8G8R8A8_UNORM;
    } else {
        targetFormat = bimg::TextureFormat::RGBA8;
    }

    DirectX::ScratchImage out;
    HRESULT hr;
    if (DirectX::IsCompressed(image.GetMetadata().format))
    {
        hr = DirectX::Decompress(mainImage, format, out);
        image.Release();
    }
    else if (image.GetMetadata().format != format)
    {
        hr = DirectX::Convert(mainImage, format, DirectX::TEX_FILTER_DEFAULT, DirectX::TEX_THRESHOLD_DEFAULT, out);
        image.Release();
    }
    else
    {
        if (!Renderer::doesItFitInMemory(mainImage.rowPitch * mainImage.height + 1)) {
            return nullptr;
        }

        return bimg::imageAlloc(allocator, targetFormat, mainImage.width, mainImage.height, 0, 1, false, false, mainImage.pixels);
    }

    if (FAILED(hr) || out.GetImageCount() == 0)
    {
        ffnx_error("%s: Convert DDS error (%d)\n", __func__, HRESULT_CODE(hr));

        return nullptr;
    }

    const DirectX::Image &mainImage2 = out.GetImages()[0];

    if (!Renderer::doesItFitInMemory(mainImage2.rowPitch * mainImage2.height + 1)) {
        return nullptr;
    }

    return bimg::imageAlloc(allocator, targetFormat, mainImage2.width, mainImage2.height, 0, 1, false, false, mainImage2.pixels);
}

bimg::ImageContainer *loadImageContainer(bx::AllocatorI *allocator, const char *filename, bimg::TextureFormat::Enum targetFormat)
{
    FILE* file = fopen(filename, "rb");

    if (!file)
    {
        return nullptr;
    }

    size_t filesize = 0;
    char* buffer = nullptr;

    fseek(file, 0, SEEK_END);
    filesize = ftell(file);

    if (Renderer::doesItFitInMemory(filesize + 1))
    {
        buffer = (char*)driver_malloc(filesize + 1);
        fseek(file, 0, SEEK_SET);
        fread(buffer, filesize, 1, file);
    }

    fclose(file);

    if (buffer == nullptr)
    {
        return nullptr;
    }

    bimg::ImageContainer* img = bimg::imageParse(allocator, buffer, filesize + 1, targetFormat);

    driver_free(buffer);

    return img;
}
````

## File: src/image/image.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>
#include <bimg/bimg.h>
#include <DirectXTex.h>

bimg::ImageContainer *loadImageContainer(bx::AllocatorI *allocator, const char *filename, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Count);
// Fast PNG opening, you need to deallocate mip.m_data yourself
bool loadPng(const char *filename, bimg::ImageMip &mip, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Count);
// Fast DDS opening
bool parseDds(const char *filename, DirectX::ScratchImage &image, DirectX::TexMetadata &metadata);
bimg::ImageContainer *convertDds(bx::AllocatorI *allocator, DirectX::ScratchImage &image, const DirectX::TexMetadata &metadata, bimg::TextureFormat::Enum targetFormat, int lod);
````

## File: src/image/tim.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "tim.h"

#include "../common.h"
#include "../log.h"
#include "../saveload.h"

TimRect::TimRect() :
	palIndex(0), x1(0), y1(0), x2(0), y2(0)
{
}

TimRect::TimRect(uint32_t palIndex, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2) :
	palIndex(palIndex), x1(x1), y1(y1), x2(x2), y2(y2)
{
}

bool TimRect::match(uint32_t x, uint32_t y) const
{
	return x >= x1 && x <= x2 && y >= y1 && y <= y2;
}

bool TimRect::isValid() const
{
	return x1 != x2 || y1 != y2;
}

int operator==(const TimRect &rect, const TimRect &other)
{
	return rect.palIndex == other.palIndex
		&& rect.x1 == other.x1
		&& rect.y1 == other.y1
		&& rect.x2 == other.x2
		&& rect.y2 == other.y2;
}

bool operator<(const TimRect &rect, const TimRect &other)
{
	return ((uint64_t(rect.palIndex) << 56) | (uint64_t(rect.x1) << 28) | uint64_t(rect.y1)) < ((uint64_t(other.palIndex) << 56) | (uint64_t(other.x1) << 28) | uint64_t(other.y1));
}

Tim::Tim(Bpp bpp, const ff8_tim &tim, int lineSkip) :
	_bpp(bpp), _tim(tim), _lineSkip(lineSkip)
{
	_tim.img_w *= 4 >> int(bpp);
}

uint32_t PaletteDetectionStrategyFixed::palOffset(uint16_t, uint16_t) const
{
	return _palX + _palY * _tim->_tim.pal_w;
}

uint32_t PaletteDetectionStrategyFixed::palIndex() const
{
	if (_tim->bpp() == Tim::Bpp16)
	{
		return 0;
	}

	if (_tim->bpp() == Tim::Bpp8 || _tim->paletteWidth() == 16)
	{
		return _palY;
	}

	int palPerLine = _tim->paletteWidth() / 16;

	return _palY * palPerLine + _palX / 16;
}

bool Tim::save(const char *fileName, bool withAlpha) const
{
	PaletteDetectionStrategyFixed fixed(this, 0, 0);
	return fixed.isValid() && save(fileName, &fixed, withAlpha);
}

bool Tim::save(const char *fileName, uint8_t paletteId, bool withAlpha) const
{
	PaletteDetectionStrategyFixed fixed(this, 0, 0);
	return fixed.isValid() && save(fileName, &fixed, withAlpha, paletteId);
}

bool Tim::save(const char *fileName, uint8_t palX, uint8_t palY, bool withAlpha) const
{
	PaletteDetectionStrategyFixed fixed(this, palX, palY);
	return fixed.isValid() && save(fileName, &fixed, withAlpha);
}

bool Tim::toRGBA32(uint32_t *target, uint8_t palX, uint8_t palY, bool withAlpha) const
{
	PaletteDetectionStrategyFixed fixed(this, palX, palY);
	return fixed.isValid() && toRGBA32(target, &fixed, withAlpha);
}

PaletteDetectionStrategyGrid::PaletteDetectionStrategyGrid(const Tim *const tim, uint8_t cellCols, uint8_t cellRows, uint16_t colorsPerPal, uint8_t palColsPerRow) :
	PaletteDetectionStrategy(tim), _cellCols(cellCols), _cellRows(cellRows), _colorsPerPal(colorsPerPal), _palColsPerRow(palColsPerRow)
{
	if (_colorsPerPal == 0)
	{
		_colorsPerPal = tim->bpp() == Tim::Bpp4 ? 16 : 256;
	}
	_palCols = tim->_tim.pal_w / _colorsPerPal;
	_cellWidth = tim->_tim.img_w / _cellCols;
	_cellHeight = tim->_tim.img_h / _cellRows;
}

bool PaletteDetectionStrategyGrid::isValid() const
{
	if (_tim->_bpp == Tim::Bpp16)
	{
		ffnx_error("PaletteDetectionStrategyGrid::%s bpp should not be 2\n", __func__);
		return false;
	}

	if (_tim->_tim.img_w % _cellCols != 0)
	{
		ffnx_error("PaletteDetectionStrategyGrid::%s img_w=%d mod cellCols=%d != 0\n", __func__, _tim->_tim.img_w, _cellCols);
		return false;
	}

	if (_tim->_tim.pal_h * _palCols != _cellCols * _cellRows)
	{
		ffnx_error("PaletteDetectionStrategyGrid::%s not enough palette for this image %d (%d * %d)\n", __func__, _palCols, _tim->_tim.pal_w, _tim->_tim.pal_h);
		return false;
	}

	return true;
}

uint32_t PaletteDetectionStrategyGrid::palOffset(uint16_t imgX, uint16_t imgY) const
{
	// Direction: top to bottom then left to right
	uint16_t cellX = imgX / _cellWidth, cellY = imgY / _cellHeight;
	int palId = (cellX % _palColsPerRow) + cellY * _palColsPerRow + (cellX / _palColsPerRow) * (_cellRows * _palColsPerRow);
	uint16_t palX = (palId % _palCols) * _colorsPerPal, palY = palId / _palCols;

	return palX + palY * _tim->_tim.pal_w;
}

uint32_t PaletteDetectionStrategyGrid::palIndex() const
{
	return 0;
}

bool Tim::saveMultiPaletteGrid(const char *fileName, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal, uint8_t palColsPerRow, bool withAlpha) const
{
	PaletteDetectionStrategyGrid grid(this, cellCols, cellRows, colorsPerPal, palColsPerRow);
	return grid.isValid() && save(fileName, &grid, withAlpha);
}

bool Tim::toRGBA32MultiPaletteGrid(uint32_t *target, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal, uint8_t palColsPerRow, bool withAlpha) const
{
	PaletteDetectionStrategyGrid grid(this, cellCols, cellRows, colorsPerPal, palColsPerRow);
	return grid.isValid() && toRGBA32(target, &grid, withAlpha);
}



PaletteDetectionStrategyTrianglesAndQuads::PaletteDetectionStrategyTrianglesAndQuads(const Tim *const tim, const std::vector<TimRect> &rectangles) :
	PaletteDetectionStrategy(tim), _rectangles(rectangles)
{
}

uint32_t PaletteDetectionStrategyTrianglesAndQuads::palOffset(uint16_t imgX, uint16_t imgY) const
{
	for (const TimRect &rectangle: _rectangles) {
		if (rectangle.match(imgX, imgY)) {
			return rectangle.palIndex * _tim->_tim.pal_w;
		}
	}

	return 0;
}

uint32_t PaletteDetectionStrategyTrianglesAndQuads::palIndex() const
{
	return 0;
}

bool Tim::saveMultiPaletteTrianglesAndQuads(const char *fileName, const std::vector<TimRect> &rectangles, bool withAlpha) const
{
	PaletteDetectionStrategyTrianglesAndQuads strategy(this, rectangles);
	return strategy.isValid() && save(fileName, &strategy, withAlpha);
}

bool Tim::toRGBA32MultiPaletteTrianglesAndQuads(uint32_t *target, const std::vector<TimRect> &rectangles, bool withAlpha) const
{
	PaletteDetectionStrategyTrianglesAndQuads strategy(this, rectangles);
	return strategy.isValid() && toRGBA32(target, &strategy, withAlpha);
}

bool Tim::toRGBA32(uint32_t *target, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha) const
{
	if (_tim.img_data == nullptr)
	{
		ffnx_error("%s img_data is null\n", __func__);

		return false;
	}

	if (_bpp == Bpp4)
	{
		if (_tim.pal_data == nullptr || paletteDetectionStrategy == nullptr)
		{
			uint8_t *img_data8 = _tim.img_data;

			for (int y = 0; y < _tim.img_h; ++y)
			{
				for (int x = 0; x < _tim.img_w / 2; ++x)
				{
					// Grey color
					uint8_t color = (*img_data8 & 0xF) * 16;

					*target = ((color == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
						(color << 16) | (color << 8) | color;

					++target;

					color = (*img_data8 >> 4) * 16;

					*target = ((color == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
						(color << 16) | (color << 8) | color;

					++target;
					++img_data8;
				}

				img_data8 += _lineSkip / 2;
			}
		}
		else
		{
			uint8_t *img_data = _tim.img_data;

			for (int y = 0; y < _tim.img_h; ++y)
			{
				for (int x = 0; x < _tim.img_w / 2; ++x)
				{
					*target = fromR5G5B5Color((_tim.pal_data + paletteDetectionStrategy->palOffset(x * 2, y))[*img_data & 0xF], withAlpha);

					++target;

					*target = fromR5G5B5Color((_tim.pal_data + paletteDetectionStrategy->palOffset(x * 2 + 1, y))[*img_data >> 4], withAlpha);

					++target;
					++img_data;
				}

				img_data += _lineSkip / 2;
			}
		}
	}
	else if (_bpp == Bpp8)
	{
		if (_tim.pal_data == nullptr || paletteDetectionStrategy == nullptr)
		{
			uint8_t *img_data8 = _tim.img_data;

			for (int y = 0; y < _tim.img_h; ++y)
			{
				for (int x = 0; x < _tim.img_w; ++x)
				{
					// Grey color
					*target = ((*img_data8 == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
						(*img_data8 << 16) | (*img_data8 << 8) | *img_data8;

					++target;
					++img_data8;
				}

				img_data8 += _lineSkip;
			}
		}
		else
		{
			uint8_t *img_data = _tim.img_data;

			for (int y = 0; y < _tim.img_h; ++y)
			{
				for (int x = 0; x < _tim.img_w; ++x)
				{
					*target = fromR5G5B5Color((_tim.pal_data + paletteDetectionStrategy->palOffset(x, y))[*img_data], withAlpha);

					++target;
					++img_data;
				}

				img_data += _lineSkip;
			}
		}
	}
	else if (_bpp == Bpp16)
	{
		uint16_t *img_data16 = (uint16_t *)_tim.img_data;

		for (int y = 0; y < _tim.img_h; ++y)
		{
			for (int x = 0; x < _tim.img_w; ++x)
			{
				*target = fromR5G5B5Color(*img_data16, withAlpha);

				++target;
				++img_data16;
			}

			img_data16 += _lineSkip;
		}
	}
	else
	{
		ffnx_error("%s unknown bpp %d\n", __func__, _bpp);

		return false;
	}

	return true;
}

Tim Tim::chunk(int x, int y, int w, int h)
{
	ff8_tim infos = ff8_tim();
	infos.img_data = _tim.img_data + (x + y * imageWidth()) * 2;
	infos.img_x = _tim.img_x + x;
	infos.img_y = _tim.img_y + y;
	infos.img_w = w;
	infos.img_h = h;
	infos.pal_data = _tim.pal_data;
	infos.pal_x = _tim.pal_x;
	infos.pal_y = _tim.pal_y;
	infos.pal_w = _tim.pal_w;
	infos.pal_h = _tim.pal_h;

	return Tim(_bpp, infos, _tim.img_w - w * (4 >> int(_bpp)));
}

bool Tim::save(const char *fileName, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha, int forcePaletteId) const
{
	// allocate PBO
	uint32_t image_data_size = _tim.img_w * _tim.img_h * 4;
	uint32_t *image_data = (uint32_t*)driver_malloc(image_data_size);

	// convert source data
	if (image_data != nullptr)
	{
		if (toRGBA32(image_data, paletteDetectionStrategy, withAlpha))
		{
			save_texture(image_data, image_data_size, _tim.img_w, _tim.img_h, forcePaletteId >= 0 ? forcePaletteId : (paletteDetectionStrategy != nullptr ? paletteDetectionStrategy->palIndex() : 0), fileName, false);
		}

		driver_free(image_data);
	}

	return true;
}

Tim Tim::fromLzsData(const uint8_t *uncompressed_data)
{
	const uint16_t *header = (const uint16_t *)uncompressed_data;
	ff8_tim tim_infos = ff8_tim();
	tim_infos.img_w = header[2];
	tim_infos.img_h = header[3];
	tim_infos.img_data = (uint8_t *)uncompressed_data + 8;

	return Tim(Bpp::Bpp16, tim_infos);
}

struct TimDataHeader {
	uint32_t size;
	uint16_t x, y;
	uint16_t w, h;
};

Tim Tim::fromTimData(const uint8_t *data)
{
	Bpp bpp = Bpp(data[4] & 3);
	bool hasPal = (data[4] & 8) != 0;
	TimDataHeader palHeader = TimDataHeader();
	ff8_tim tim_infos = ff8_tim();

	if (hasPal)
	{
		memcpy(&palHeader, data + 8, sizeof(palHeader));

		tim_infos.pal_data = (uint16_t *)(data + 8 + sizeof(palHeader));
		tim_infos.pal_x = palHeader.x;
		tim_infos.pal_y = palHeader.y;
		tim_infos.pal_w = palHeader.w;
		tim_infos.pal_h = palHeader.h;
	}

	TimDataHeader imgHeader = TimDataHeader();
	memcpy(&imgHeader, data + 8 + palHeader.size, sizeof(imgHeader));

	tim_infos.img_data = (uint8_t *)data + 8 + palHeader.size + sizeof(imgHeader);
	tim_infos.img_x = imgHeader.x;
	tim_infos.img_y = imgHeader.y;
	tim_infos.img_w = imgHeader.w;
	tim_infos.img_h = imgHeader.h;

	return Tim(bpp, tim_infos);
}

uint16_t Tim::colorsPerPal() const
{
	if (_bpp == Bpp8)
	{
		return 256;
	}
	else if (_bpp == Bpp4)
	{
		return 16;
	}

	return 0;
}
````

## File: src/image/tim.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>
#include <vector>
#include "../ff8.h"

struct TimRect {
	TimRect();
	TimRect(uint32_t palIndex, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2);
	bool match(uint32_t x, uint32_t y) const;
	bool isValid() const;
	uint32_t palIndex;
	uint32_t x1, y1;
	uint32_t x2, y2;
};

int operator==(const TimRect &rectangle, const TimRect &other);
bool operator<(const TimRect &rectangle, const TimRect &other);

inline uint32_t fromR5G5B5Color(uint16_t color, bool withAlpha = false)
{
	uint8_t r = color & 0x1F,
		g = (color >> 5) & 0x1F,
		b = (color >> 10) & 0x1F;

	return ((color == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
		((((r << 3) + (r >> 2)) & 0xffu) << 16) |
		((((g << 3) + (g >> 2)) & 0xffu) << 8) |
		(((b << 3) + (b >> 2)) & 0xffu);
}

class Tim;

class PaletteDetectionStrategy {
public:
	PaletteDetectionStrategy(const Tim *const tim) : _tim(tim) {};
	virtual bool isValid() const {
		return true;
	}
	virtual uint32_t palOffset(uint16_t x, uint16_t y) const = 0;
	virtual uint32_t palIndex() const = 0;
protected:
	const Tim *const _tim;
};

// One palette at (x, y)
class PaletteDetectionStrategyFixed : public PaletteDetectionStrategy {
public:
	PaletteDetectionStrategyFixed(const Tim *const tim, uint16_t palX, uint16_t palY) :
		PaletteDetectionStrategy(tim), _palX(palX), _palY(palY) {}
	virtual uint32_t palOffset(uint16_t imgX, uint16_t imgY) const override;
	virtual uint32_t palIndex() const override;
private:
	uint16_t _palX, _palY;
};

// A grid of fixed size cells, with one palette per cell
class PaletteDetectionStrategyGrid : public PaletteDetectionStrategy {
public:
	enum Direction {
		TopBottomLeftRight,
		LeftRightTopBottom
	};
	PaletteDetectionStrategyGrid(const Tim *const tim, uint8_t cellCols, uint8_t cellRows, uint16_t colorsPerPal, uint8_t palColsPerRow);
	virtual bool isValid() const override;
	virtual uint32_t palOffset(uint16_t imgX, uint16_t imgY) const override;
	virtual uint32_t palIndex() const override;
private:
	uint8_t _cellCols, _cellRows;
	uint16_t _cellWidth, _cellHeight;
	uint16_t _colorsPerPal;
	uint8_t _palColsPerRow;
	uint8_t _palCols;
};

class PaletteDetectionStrategyTrianglesAndQuads : public PaletteDetectionStrategy {
public:
	PaletteDetectionStrategyTrianglesAndQuads(const Tim *const tim, const std::vector<TimRect> &rectangles);
	virtual uint32_t palOffset(uint16_t imgX, uint16_t imgY) const override;
	virtual uint32_t palIndex() const override;
private:
	const std::vector<TimRect> &_rectangles;
};

class Tim {
	friend class PaletteDetectionStrategyFixed;
	friend class PaletteDetectionStrategyGrid;
	friend class PaletteDetectionStrategyTrianglesAndQuads;
public:
	enum Bpp {
		Bpp4 = 0,
		Bpp8 = 1,
		Bpp16 = 2
	};

	Tim(Bpp bpp, const ff8_tim &tim, int lineSkip = 0);
	uint16_t colorsPerPal() const;
	inline Bpp bpp() const {
		return _bpp;
	}
	inline uint16_t imageX() const {
		return _tim.img_x;
	}
	inline uint16_t imageY() const {
		return _tim.img_y;
	}
	inline uint16_t imageWidth() const {
		return _tim.img_w / (4 >> int(_bpp));
	}
	inline uint16_t imageHeight() const {
		return _tim.img_h;
	}
	inline uint8_t *imageData() const {
		return _tim.img_data;
	}
	inline uint16_t paletteX() const {
		return _tim.pal_x;
	}
	inline uint16_t paletteY() const {
		return _tim.pal_y;
	}
	inline uint16_t paletteWidth() const {
		return _tim.pal_w;
	}
	inline uint16_t paletteHeight() const {
		return _tim.pal_h;
	}
	inline uint16_t *paletteData() const {
		return _tim.pal_data;
	}
	bool save(const char *fileName, bool withAlpha = false) const;
	bool save(const char *fileName, uint8_t paletteId, bool withAlpha = false) const;
	bool save(const char *fileName, uint8_t palX, uint8_t palY, bool withAlpha = false) const;
	bool saveMultiPaletteGrid(
		const char *fileName, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal = 0, uint8_t palColsPerRow = 1,
		bool withAlpha = false
	) const;
	bool saveMultiPaletteTrianglesAndQuads(
		const char *fileName, const std::vector<TimRect> &rectangles,
		bool withAlpha = false
	) const;
	bool toRGBA32(uint32_t *target, uint8_t palX = 0, uint8_t palY = 0, bool withAlpha = false) const;
	bool toRGBA32MultiPaletteGrid(
		uint32_t *target, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal = 0, uint8_t palColsPerRow = 1,
		bool withAlpha = false
	) const;
	bool toRGBA32MultiPaletteTrianglesAndQuads(
		uint32_t *target, const std::vector<TimRect> &rectangles,
		bool withAlpha = false
	) const;
	Tim chunk(int x, int y, int w, int h);
	static Tim fromLzsData(const uint8_t *uncompressed_data);
	static Tim fromTimData(const uint8_t *data);
private:
	bool save(const char *fileName, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha, int forcePaletteId = -1) const;
	bool toRGBA32(uint32_t *target, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha) const;
	ff8_tim _tim;
	Bpp _bpp;
	int _lineSkip;
};
````

## File: src/imgui_club/imgui_memory_editor.h
````
// Mini memory editor for Dear ImGui (to embed in your game/tools)
// Get latest version at http://www.github.com/ocornut/imgui_club
// Licensed under The MIT License (MIT)

// Right-click anywhere to access the Options menu!
// You can adjust the keyboard repeat delay/rate in ImGuiIO.
// The code assume a mono-space font for simplicity!
// If you don't use the default font, use ImGui::PushFont()/PopFont() to switch to a mono-space font before calling this.
//
// Usage:
//   // Create a window and draw memory editor inside it:
//   static MemoryEditor mem_edit_1;
//   static char data[0x10000];
//   size_t data_size = 0x10000;
//   mem_edit_1.DrawWindow("Memory Editor", data, data_size);
//
// Usage:
//   // If you already have a window, use DrawContents() instead:
//   static MemoryEditor mem_edit_2;
//   ImGui::Begin("MyWindow")
//   mem_edit_2.DrawContents(this, sizeof(*this), (size_t)this);
//   ImGui::End();
//
// Changelog:
// - v0.10: initial version
// - v0.23 (2017/08/17): added to github. fixed right-arrow triggering a byte write.
// - v0.24 (2018/06/02): changed DragInt("Rows" to use a %d data format (which is desirable since imgui 1.61).
// - v0.25 (2018/07/11): fixed wording: all occurrences of "Rows" renamed to "Columns".
// - v0.26 (2018/08/02): fixed clicking on hex region
// - v0.30 (2018/08/02): added data preview for common data types
// - v0.31 (2018/10/10): added OptUpperCaseHex option to select lower/upper casing display [@samhocevar]
// - v0.32 (2018/10/10): changed signatures to use void* instead of unsigned char*
// - v0.33 (2018/10/10): added OptShowOptions option to hide all the interactive option setting.
// - v0.34 (2019/05/07): binary preview now applies endianness setting [@nicolasnoble]
// - v0.35 (2020/01/29): using ImGuiDataType available since Dear ImGui 1.69.
// - v0.36 (2020/05/05): minor tweaks, minor refactor.
// - v0.40 (2020/10/04): fix misuse of ImGuiListClipper API, broke with Dear ImGui 1.79. made cursor position appears on left-side of edit box. option popup appears on mouse release. fix MSVC warnings where _CRT_SECURE_NO_WARNINGS wasn't working in recent versions.
// - v0.41 (2020/10/05): fix when using with keyboard/gamepad navigation enabled.
// - v0.42 (2020/10/14): fix for . character in ASCII view always being greyed out.
// - v0.43 (2021/03/12): added OptFooterExtraHeight to allow for custom drawing at the bottom of the editor [@leiradel]
// - v0.44 (2021/03/12): use ImGuiInputTextFlags_AlwaysOverwrite in 1.82 + fix hardcoded width.
// - v0.50 (2021/11/12): various fixes for recent dear imgui versions (fixed misuse of clipper, relying on SetKeyboardFocusHere() handling scrolling from 1.85). added default size.
// - v0.51 (2024/02/22): fix for layout change in 1.89 when using IMGUI_DISABLE_OBSOLETE_FUNCTIONS. (#34)
// - v0.52 (2024/03/08): removed unnecessary GetKeyIndex() calls, they are a no-op since 1.87.
// - v0.53 (2024/05/27): fixed right-click popup from not appearing when using DrawContents(). warning fixes. (#35)
// - v0.54 (2024/07/29): allow ReadOnly mode to still select and preview data. (#46) [@DeltaGW2])
// - v0.55 (2024/08/19): added BgColorFn to allow setting background colors independently from highlighted selection. (#27) [@StrikerX3]
//                       added MouseHoveredAddr public readable field. (#47, #27) [@StrikerX3]
//                       fixed a data preview crash with 1.91.0 WIP. fixed contiguous highlight color when using data preview.
//                       *BREAKING* added UserData field passed to all optional function handlers: ReadFn, WriteFn, HighlightFn, BgColorFn. (#50) [@silverweed]
// - v0.56 (2024/11/04): fixed MouseHovered, MouseHoveredAddr not being set when hovering a byte being edited. (#54)
//
// TODO:
// - This is generally old/crappy code, it should work but isn't very good.. to be rewritten some day.
// - PageUp/PageDown are not supported because we use _NoNav. This is a good test scenario for working out idioms of how to mix natural nav and our own...
// - Arrows are being sent to the InputText() about to disappear which for LeftArrow makes the text cursor appear at position 1 for one frame.
// - Using InputText() is awkward and maybe overkill here, consider implementing something custom.

#pragma once

#include <stdio.h>      // sprintf, scanf
#include <stdint.h>     // uint8_t, etc.

#if defined(_MSC_VER) || defined(_UCRT)
#define _PRISizeT   "I"
#define ImSnprintf  _snprintf
#else
#define _PRISizeT   "z"
#define ImSnprintf  snprintf
#endif

#if defined(_MSC_VER) || defined(_UCRT)
#pragma warning (push)
#pragma warning (disable: 4996) // warning C4996: 'sprintf': This function or variable may be unsafe.
#endif

struct MemoryEditor
{
    enum DataFormat
    {
        DataFormat_Bin = 0,
        DataFormat_Dec = 1,
        DataFormat_Hex = 2,
        DataFormat_COUNT
    };

    // Settings
    bool            Open;                                       // = true   // set to false when DrawWindow() was closed. ignore if not using DrawWindow().
    bool            ReadOnly;                                   // = false  // disable any editing.
    int             Cols;                                       // = 16     // number of columns to display.
    bool            OptShowOptions;                             // = true   // display options button/context menu. when disabled, options will be locked unless you provide your own UI for them.
    bool            OptShowDataPreview;                         // = false  // display a footer previewing the decimal/binary/hex/float representation of the currently selected bytes.
    bool            OptShowHexII;                               // = false  // display values in HexII representation instead of regular hexadecimal: hide null/zero bytes, ascii values as ".X".
    bool            OptShowAscii;                               // = true   // display ASCII representation on the right side.
    bool            OptGreyOutZeroes;                           // = true   // display null/zero bytes using the TextDisabled color.
    bool            OptUpperCaseHex;                            // = true   // display hexadecimal values as "FF" instead of "ff".
    int             OptMidColsCount;                            // = 8      // set to 0 to disable extra spacing between every mid-cols.
    int             OptAddrDigitsCount;                         // = 0      // number of addr digits to display (default calculated based on maximum displayed addr).
    float           OptFooterExtraHeight;                       // = 0      // space to reserve at the bottom of the widget to add custom widgets
    ImU32           HighlightColor;                             //          // background color of highlighted bytes.

    // Function handlers
    ImU8            (*ReadFn)(const ImU8* mem, size_t off, void* user_data);      // = 0      // optional handler to read bytes.
    void            (*WriteFn)(ImU8* mem, size_t off, ImU8 d, void* user_data);   // = 0      // optional handler to write bytes.
    bool            (*HighlightFn)(const ImU8* mem, size_t off, void* user_data); // = 0      // optional handler to return Highlight property (to support non-contiguous highlighting).
    ImU32           (*BgColorFn)(const ImU8* mem, size_t off, void* user_data);   // = 0      // optional handler to return custom background color of individual bytes.
    void*           UserData;                                                     // = NULL   // user data forwarded to the function handlers

    // Public read-only data
    bool            MouseHovered;                               // set when mouse is hovering a value.
    size_t          MouseHoveredAddr;                           // the address currently being hovered if MouseHovered is set.

    // [Internal State]
    bool            ContentsWidthChanged;
    size_t          DataPreviewAddr;
    size_t          DataEditingAddr;
    bool            DataEditingTakeFocus;
    char            DataInputBuf[32];
    char            AddrInputBuf[32];
    size_t          GotoAddr;
    size_t          HighlightMin, HighlightMax;
    int             PreviewEndianness;
    ImGuiDataType   PreviewDataType;

    MemoryEditor()
    {
        // Settings
        Open = true;
        ReadOnly = false;
        Cols = 16;
        OptShowOptions = true;
        OptShowDataPreview = false;
        OptShowHexII = false;
        OptShowAscii = true;
        OptGreyOutZeroes = true;
        OptUpperCaseHex = true;
        OptMidColsCount = 8;
        OptAddrDigitsCount = 0;
        OptFooterExtraHeight = 0.0f;
        HighlightColor = IM_COL32(255, 255, 255, 50);
        ReadFn = nullptr;
        WriteFn = nullptr;
        HighlightFn = nullptr;
        BgColorFn = nullptr;
        UserData = nullptr;

        // State/Internals
        ContentsWidthChanged = false;
        DataPreviewAddr = DataEditingAddr = (size_t)-1;
        DataEditingTakeFocus = false;
        memset(DataInputBuf, 0, sizeof(DataInputBuf));
        memset(AddrInputBuf, 0, sizeof(AddrInputBuf));
        GotoAddr = (size_t)-1;
        MouseHovered = false;
        MouseHoveredAddr = 0;
        HighlightMin = HighlightMax = (size_t)-1;
        PreviewEndianness = 0;
        PreviewDataType = ImGuiDataType_S32;
    }

    void GotoAddrAndHighlight(size_t addr_min, size_t addr_max)
    {
        GotoAddr = addr_min;
        HighlightMin = addr_min;
        HighlightMax = addr_max;
    }

    struct Sizes
    {
        int     AddrDigitsCount;
        float   LineHeight;
        float   GlyphWidth;
        float   HexCellWidth;
        float   SpacingBetweenMidCols;
        float   PosHexStart;
        float   PosHexEnd;
        float   PosAsciiStart;
        float   PosAsciiEnd;
        float   WindowWidth;

        Sizes() { memset(this, 0, sizeof(*this)); }
    };

    void CalcSizes(Sizes& s, size_t mem_size, size_t base_display_addr)
    {
        ImGuiStyle& style = ImGui::GetStyle();
        s.AddrDigitsCount = OptAddrDigitsCount;
        if (s.AddrDigitsCount == 0)
            for (size_t n = base_display_addr + mem_size - 1; n > 0; n >>= 4)
                s.AddrDigitsCount++;
        s.LineHeight = ImGui::GetTextLineHeight();
        s.GlyphWidth = ImGui::CalcTextSize("F").x + 1;                  // We assume the font is mono-space
        s.HexCellWidth = (float)(int)(s.GlyphWidth * 2.5f);             // "FF " we include trailing space in the width to easily catch clicks everywhere
        s.SpacingBetweenMidCols = (float)(int)(s.HexCellWidth * 0.25f); // Every OptMidColsCount columns we add a bit of extra spacing
        s.PosHexStart = (s.AddrDigitsCount + 2) * s.GlyphWidth;
        s.PosHexEnd = s.PosHexStart + (s.HexCellWidth * Cols);
        s.PosAsciiStart = s.PosAsciiEnd = s.PosHexEnd;
        if (OptShowAscii)
        {
            s.PosAsciiStart = s.PosHexEnd + s.GlyphWidth * 1;
            if (OptMidColsCount > 0)
                s.PosAsciiStart += (float)((Cols + OptMidColsCount - 1) / OptMidColsCount) * s.SpacingBetweenMidCols;
            s.PosAsciiEnd = s.PosAsciiStart + Cols * s.GlyphWidth;
        }
        s.WindowWidth = s.PosAsciiEnd + style.ScrollbarSize + style.WindowPadding.x * 2 + s.GlyphWidth;
    }

    // Standalone Memory Editor window
    void DrawWindow(const char* title, void* mem_data, size_t mem_size, size_t base_display_addr = 0x0000)
    {
        Sizes s;
        CalcSizes(s, mem_size, base_display_addr);
        ImGui::SetNextWindowSize(ImVec2(s.WindowWidth, s.WindowWidth * 0.60f), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, 0.0f), ImVec2(s.WindowWidth, FLT_MAX));

        Open = true;
        if (ImGui::Begin(title, &Open, ImGuiWindowFlags_NoScrollbar))
        {
            DrawContents(mem_data, mem_size, base_display_addr);
            if (ContentsWidthChanged)
            {
                CalcSizes(s, mem_size, base_display_addr);
                ImGui::SetWindowSize(ImVec2(s.WindowWidth, ImGui::GetWindowSize().y));
            }
        }
        ImGui::End();
    }

    // Memory Editor contents only
    void DrawContents(void* mem_data_void, size_t mem_size, size_t base_display_addr = 0x0000)
    {
        if (Cols < 1)
            Cols = 1;

        ImU8* mem_data = (ImU8*)mem_data_void;
        Sizes s;
        CalcSizes(s, mem_size, base_display_addr);
        ImGuiStyle& style = ImGui::GetStyle();

        const ImVec2 contents_pos_start = ImGui::GetCursorScreenPos();

        // We begin into our scrolling region with the 'ImGuiWindowFlags_NoMove' in order to prevent click from moving the window.
        // This is used as a facility since our main click detection code doesn't assign an ActiveId so the click would normally be caught as a window-move.
        const float height_separator = style.ItemSpacing.y;
        float footer_height = OptFooterExtraHeight;
        if (OptShowOptions)
            footer_height += height_separator + ImGui::GetFrameHeightWithSpacing() * 1;
        if (OptShowDataPreview)
            footer_height += height_separator + ImGui::GetFrameHeightWithSpacing() * 1 + ImGui::GetTextLineHeightWithSpacing() * 3;
        ImGui::BeginChild("##scrolling", ImVec2(-FLT_MIN, -footer_height), ImGuiChildFlags_None, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNav);
        ImDrawList* draw_list = ImGui::GetWindowDrawList();

        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));

        // We are not really using the clipper API correctly here, because we rely on visible_start_addr/visible_end_addr for our scrolling function.
        const int line_total_count = (int)((mem_size + Cols - 1) / Cols);
        ImGuiListClipper clipper;
        clipper.Begin(line_total_count, s.LineHeight);

        bool data_next = false;

        if (DataEditingAddr >= mem_size)
            DataEditingAddr = (size_t)-1;
        if (DataPreviewAddr >= mem_size)
            DataPreviewAddr = (size_t)-1;

        size_t preview_data_type_size = OptShowDataPreview ? DataTypeGetSize(PreviewDataType) : 0;

        size_t data_editing_addr_next = (size_t)-1;
        if (DataEditingAddr != (size_t)-1)
        {
            // Move cursor but only apply on next frame so scrolling with be synchronized (because currently we can't change the scrolling while the window is being rendered)
            if (ImGui::IsKeyPressed(ImGuiKey_UpArrow) && (ptrdiff_t)DataEditingAddr >= (ptrdiff_t)Cols)                 { data_editing_addr_next = DataEditingAddr - Cols; }
            else if (ImGui::IsKeyPressed(ImGuiKey_DownArrow) && (ptrdiff_t)DataEditingAddr < (ptrdiff_t)mem_size - Cols){ data_editing_addr_next = DataEditingAddr + Cols; }
            else if (ImGui::IsKeyPressed(ImGuiKey_LeftArrow) && (ptrdiff_t)DataEditingAddr > (ptrdiff_t)0)              { data_editing_addr_next = DataEditingAddr - 1; }
            else if (ImGui::IsKeyPressed(ImGuiKey_RightArrow) && (ptrdiff_t)DataEditingAddr < (ptrdiff_t)mem_size - 1)  { data_editing_addr_next = DataEditingAddr + 1; }
        }

        // Draw vertical separator
        ImVec2 window_pos = ImGui::GetWindowPos();
        if (OptShowAscii)
            draw_list->AddLine(ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y), ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y + 9999), ImGui::GetColorU32(ImGuiCol_Border));

        const ImU32 color_text = ImGui::GetColorU32(ImGuiCol_Text);
        const ImU32 color_disabled = OptGreyOutZeroes ? ImGui::GetColorU32(ImGuiCol_TextDisabled) : color_text;

        const char* format_address = OptUpperCaseHex ? "%0*" _PRISizeT "X: " : "%0*" _PRISizeT "x: ";
        const char* format_data = OptUpperCaseHex ? "%0*" _PRISizeT "X" : "%0*" _PRISizeT "x";
        const char* format_byte = OptUpperCaseHex ? "%02X" : "%02x";
        const char* format_byte_space = OptUpperCaseHex ? "%02X " : "%02x ";

        MouseHovered = false;
        MouseHoveredAddr = 0;

        while (clipper.Step())
            for (int line_i = clipper.DisplayStart; line_i < clipper.DisplayEnd; line_i++) // display only visible lines
            {
                size_t addr = (size_t)line_i * Cols;
                ImGui::Text(format_address, s.AddrDigitsCount, base_display_addr + addr);

                // Draw Hexadecimal
                for (int n = 0; n < Cols && addr < mem_size; n++, addr++)
                {
                    float byte_pos_x = s.PosHexStart + s.HexCellWidth * n;
                    if (OptMidColsCount > 0)
                        byte_pos_x += (float)(n / OptMidColsCount) * s.SpacingBetweenMidCols;
                    ImGui::SameLine(byte_pos_x);

                    // Draw highlight or custom background color
                    const bool is_highlight_from_user_range = (addr >= HighlightMin && addr < HighlightMax);
                    const bool is_highlight_from_user_func = (HighlightFn && HighlightFn(mem_data, addr, UserData));
                    const bool is_highlight_from_preview = (addr >= DataPreviewAddr && addr < DataPreviewAddr + preview_data_type_size);

                    ImU32 bg_color = 0;
                    bool is_next_byte_highlighted = false;
                    if (is_highlight_from_user_range || is_highlight_from_user_func || is_highlight_from_preview)
                    {
                        is_next_byte_highlighted = (addr + 1 < mem_size) && ((HighlightMax != (size_t)-1 && addr + 1 < HighlightMax) || (HighlightFn && HighlightFn(mem_data, addr + 1, UserData)) || (addr + 1 < DataPreviewAddr + preview_data_type_size));
                        bg_color = HighlightColor;
                    }
                    else if (BgColorFn != nullptr)
                    {
                        is_next_byte_highlighted = (addr + 1 < mem_size) && ((BgColorFn(mem_data, addr + 1, UserData) & IM_COL32_A_MASK) != 0);
                        bg_color = BgColorFn(mem_data, addr, UserData);
                    }
                    if (bg_color != 0)
                    {
                        float bg_width = s.GlyphWidth * 2;
                        if (is_next_byte_highlighted || (n + 1 == Cols))
                        {
                            bg_width = s.HexCellWidth;
                            if (OptMidColsCount > 0 && n > 0 && (n + 1) < Cols && ((n + 1) % OptMidColsCount) == 0)
                                bg_width += s.SpacingBetweenMidCols;
                        }
                        ImVec2 pos = ImGui::GetCursorScreenPos();
                        draw_list->AddRectFilled(pos, ImVec2(pos.x + bg_width, pos.y + s.LineHeight), bg_color);
                    }

                    if (DataEditingAddr == addr)
                    {
                        // Display text input on current byte
                        bool data_write = false;
                        ImGui::PushID((void*)addr);
                        if (DataEditingTakeFocus)
                        {
                            ImGui::SetKeyboardFocusHere(0);
                            ImSnprintf(AddrInputBuf, 32, format_data, s.AddrDigitsCount, base_display_addr + addr);
                            ImSnprintf(DataInputBuf, 32, format_byte, ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr]);
                        }
                        struct InputTextUserData
                        {
                            // FIXME: We should have a way to retrieve the text edit cursor position more easily in the API, this is rather tedious. This is such a ugly mess we may be better off not using InputText() at all here.
                            static int Callback(ImGuiInputTextCallbackData* data)
                            {
                                InputTextUserData* user_data = (InputTextUserData*)data->UserData;
                                if (!data->HasSelection())
                                    user_data->CursorPos = data->CursorPos;
#if IMGUI_VERSION_NUM < 19102
                                if (data->Flags & ImGuiInputTextFlags_ReadOnly)
                                    return 0;
#endif
                                if (data->SelectionStart == 0 && data->SelectionEnd == data->BufTextLen)
                                {
                                    // When not editing a byte, always refresh its InputText content pulled from underlying memory data
                                    // (this is a bit tricky, since InputText technically "owns" the master copy of the buffer we edit it in there)
                                    data->DeleteChars(0, data->BufTextLen);
                                    data->InsertChars(0, user_data->CurrentBufOverwrite);
                                    data->SelectionStart = 0;
                                    data->SelectionEnd = 2;
                                    data->CursorPos = 0;
                                }
                                return 0;
                            }
                            char   CurrentBufOverwrite[3];  // Input
                            int    CursorPos;               // Output
                        };
                        InputTextUserData input_text_user_data;
                        input_text_user_data.CursorPos = -1;
                        ImSnprintf(input_text_user_data.CurrentBufOverwrite, 3, format_byte, ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr]);
                        ImGuiInputTextFlags flags = ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoHorizontalScroll | ImGuiInputTextFlags_CallbackAlways;
                        if (ReadOnly)
                            flags |= ImGuiInputTextFlags_ReadOnly;
                        flags |= ImGuiInputTextFlags_AlwaysOverwrite; // was ImGuiInputTextFlags_AlwaysInsertMode
                        ImGui::SetNextItemWidth(s.GlyphWidth * 2);
                        if (ImGui::InputText("##data", DataInputBuf, IM_ARRAYSIZE(DataInputBuf), flags, InputTextUserData::Callback, &input_text_user_data))
                            data_write = data_next = true;
                        else if (!DataEditingTakeFocus && !ImGui::IsItemActive())
                            DataEditingAddr = data_editing_addr_next = (size_t)-1;
                        DataEditingTakeFocus = false;
                        if (input_text_user_data.CursorPos >= 2)
                            data_write = data_next = true;
                        if (data_editing_addr_next != (size_t)-1)
                            data_write = data_next = false;
                        unsigned int data_input_value = 0;
                        if (!ReadOnly && data_write && sscanf(DataInputBuf, "%X", &data_input_value) == 1)
                        {
                            if (WriteFn)
                                WriteFn(mem_data, addr, (ImU8)data_input_value, UserData);
                            else
                                mem_data[addr] = (ImU8)data_input_value;
                        }
                        if (ImGui::IsItemHovered())
                        {
                            MouseHovered = true;
                            MouseHoveredAddr = addr;
                        }
                        ImGui::PopID();
                    }
                    else
                    {
                        // NB: The trailing space is not visible but ensure there's no gap that the mouse cannot click on.
                        ImU8 b = ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr];

                        if (OptShowHexII)
                        {
                            if ((b >= 32 && b < 128))
                                ImGui::Text(".%c ", b);
                            else if (b == 0xFF && OptGreyOutZeroes)
                                ImGui::TextDisabled("## ");
                            else if (b == 0x00)
                                ImGui::Text("   ");
                            else
                                ImGui::Text(format_byte_space, b);
                        }
                        else
                        {
                            if (b == 0 && OptGreyOutZeroes)
                                ImGui::TextDisabled("00 ");
                            else
                                ImGui::Text(format_byte_space, b);
                        }
                        if (ImGui::IsItemHovered())
                        {
                            MouseHovered = true;
                            MouseHoveredAddr = addr;
                            if (ImGui::IsMouseClicked(0))
                            {
                                DataEditingTakeFocus = true;
                                data_editing_addr_next = addr;
                            }
                        }
                    }
                }

                if (OptShowAscii)
                {
                    // Draw ASCII values
                    ImGui::SameLine(s.PosAsciiStart);
                    ImVec2 pos = ImGui::GetCursorScreenPos();
                    addr = (size_t)line_i * Cols;

                    const float mouse_off_x = ImGui::GetIO().MousePos.x - pos.x;
                    const size_t mouse_addr = (mouse_off_x >= 0.0f && mouse_off_x < s.PosAsciiEnd - s.PosAsciiStart) ? addr + (size_t)(mouse_off_x / s.GlyphWidth) : (size_t)-1;

                    ImGui::PushID(line_i);
                    if (ImGui::InvisibleButton("ascii", ImVec2(s.PosAsciiEnd - s.PosAsciiStart, s.LineHeight)))
                    {
                        DataEditingAddr = DataPreviewAddr = mouse_addr;
                        DataEditingTakeFocus = true;
                    }
                    if (ImGui::IsItemHovered())
                    {
                        MouseHovered = true;
                        MouseHoveredAddr = mouse_addr;
                    }
                    ImGui::PopID();
                    for (int n = 0; n < Cols && addr < mem_size; n++, addr++)
                    {
                        if (addr == DataEditingAddr)
                        {
                            draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), ImGui::GetColorU32(ImGuiCol_FrameBg));
                            draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), ImGui::GetColorU32(ImGuiCol_TextSelectedBg));
                        }
                        else if (BgColorFn)
                        {
                            draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), BgColorFn(mem_data, addr, UserData));
                        }
                        unsigned char c = ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr];
                        char display_c = (c < 32 || c >= 128) ? '.' : c;
                        draw_list->AddText(pos, (display_c == c) ? color_text : color_disabled, &display_c, &display_c + 1);
                        pos.x += s.GlyphWidth;
                    }
                }
            }
        ImGui::PopStyleVar(2);
        const float child_width = ImGui::GetWindowSize().x;
        ImGui::EndChild();

        // Notify the main window of our ideal child content size (FIXME: we are missing an API to get the contents size from the child)
        ImGui::SetCursorPosX(s.WindowWidth);
        ImGui::Dummy(ImVec2(0.0f, 0.0f));

        if (data_next && DataEditingAddr + 1 < mem_size)
        {
            DataEditingAddr = DataPreviewAddr = DataEditingAddr + 1;
            DataEditingTakeFocus = true;
        }
        else if (data_editing_addr_next != (size_t)-1)
        {
            DataEditingAddr = DataPreviewAddr = data_editing_addr_next;
            DataEditingTakeFocus = true;
        }

        const bool lock_show_data_preview = OptShowDataPreview;
        if (OptShowOptions)
        {
            ImGui::Separator();
            DrawOptionsLine(s, mem_data, mem_size, base_display_addr);
        }

        if (lock_show_data_preview)
        {
            ImGui::Separator();
            DrawPreviewLine(s, mem_data, mem_size, base_display_addr);
        }

        const ImVec2 contents_pos_end(contents_pos_start.x + child_width, ImGui::GetCursorScreenPos().y);
        //ImGui::GetForegroundDrawList()->AddRect(contents_pos_start, contents_pos_end, IM_COL32(255, 0, 0, 255));
        if (OptShowOptions)
            if (ImGui::IsMouseHoveringRect(contents_pos_start, contents_pos_end))
                if (ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows) && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
                    ImGui::OpenPopup("OptionsPopup");

        if (ImGui::BeginPopup("OptionsPopup"))
        {
            ImGui::SetNextItemWidth(s.GlyphWidth * 7 + style.FramePadding.x * 2.0f);
            if (ImGui::DragInt("##cols", &Cols, 0.2f, 4, 32, "%d cols")) { ContentsWidthChanged = true; if (Cols < 1) Cols = 1; }
            ImGui::Checkbox("Show Data Preview", &OptShowDataPreview);
            ImGui::Checkbox("Show HexII", &OptShowHexII);
            if (ImGui::Checkbox("Show Ascii", &OptShowAscii)) { ContentsWidthChanged = true; }
            ImGui::Checkbox("Grey out zeroes", &OptGreyOutZeroes);
            ImGui::Checkbox("Uppercase Hex", &OptUpperCaseHex);

            ImGui::EndPopup();
        }
    }

    void DrawOptionsLine(const Sizes& s, void* mem_data, size_t mem_size, size_t base_display_addr)
    {
        IM_UNUSED(mem_data);
        ImGuiStyle& style = ImGui::GetStyle();
        const char* format_range = OptUpperCaseHex ? "Range %0*" _PRISizeT "X..%0*" _PRISizeT "X" : "Range %0*" _PRISizeT "x..%0*" _PRISizeT "x";

        // Options menu
        if (ImGui::Button("Options"))
            ImGui::OpenPopup("OptionsPopup");

        ImGui::SameLine();
        ImGui::Text(format_range, s.AddrDigitsCount, base_display_addr, s.AddrDigitsCount, base_display_addr + mem_size - 1);
        ImGui::SameLine();
        ImGui::SetNextItemWidth((s.AddrDigitsCount + 1) * s.GlyphWidth + style.FramePadding.x * 2.0f);
        if (ImGui::InputText("##addr", AddrInputBuf, IM_ARRAYSIZE(AddrInputBuf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue))
        {
            size_t goto_addr;
            if (sscanf(AddrInputBuf, "%" _PRISizeT "X", &goto_addr) == 1)
            {
                GotoAddr = goto_addr - base_display_addr;
                HighlightMin = HighlightMax = (size_t)-1;
            }
        }

        if (GotoAddr != (size_t)-1)
        {
            if (GotoAddr < mem_size)
            {
                ImGui::BeginChild("##scrolling");
                ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + (GotoAddr / Cols) * ImGui::GetTextLineHeight());
                ImGui::EndChild();
                DataEditingAddr = DataPreviewAddr = GotoAddr;
                DataEditingTakeFocus = true;
            }
            GotoAddr = (size_t)-1;
        }

        //if (MouseHovered)
        //{
        //    ImGui::SameLine();
        //    ImGui::Text("Hovered: %p", MouseHoveredAddr);
        //}
    }

    void DrawPreviewLine(const Sizes& s, void* mem_data_void, size_t mem_size, size_t base_display_addr)
    {
        IM_UNUSED(base_display_addr);
        ImU8* mem_data = (ImU8*)mem_data_void;
        ImGuiStyle& style = ImGui::GetStyle();
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Preview as:");
        ImGui::SameLine();
        ImGui::SetNextItemWidth((s.GlyphWidth * 10.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);

        static const ImGuiDataType supported_data_types[] = { ImGuiDataType_S8, ImGuiDataType_U8, ImGuiDataType_S16, ImGuiDataType_U16, ImGuiDataType_S32, ImGuiDataType_U32, ImGuiDataType_S64, ImGuiDataType_U64, ImGuiDataType_Float, ImGuiDataType_Double };
        if (ImGui::BeginCombo("##combo_type", DataTypeGetDesc(PreviewDataType), ImGuiComboFlags_HeightLargest))
        {
            for (int n = 0; n < IM_ARRAYSIZE(supported_data_types); n++)
            {
                ImGuiDataType data_type = supported_data_types[n];
                if (ImGui::Selectable(DataTypeGetDesc(data_type), PreviewDataType == data_type))
                    PreviewDataType = data_type;
            }
            ImGui::EndCombo();
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth((s.GlyphWidth * 6.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);
        ImGui::Combo("##combo_endianness", &PreviewEndianness, "LE\0BE\0\0");

        char buf[128] = "";
        float x = s.GlyphWidth * 6.0f;
        bool has_value = DataPreviewAddr != (size_t)-1;
        if (has_value)
            DrawPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Dec, buf, (size_t)IM_ARRAYSIZE(buf));
        ImGui::Text("Dec"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
        if (has_value)
            DrawPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Hex, buf, (size_t)IM_ARRAYSIZE(buf));
        ImGui::Text("Hex"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
        if (has_value)
            DrawPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Bin, buf, (size_t)IM_ARRAYSIZE(buf));
        buf[IM_ARRAYSIZE(buf) - 1] = 0;
        ImGui::Text("Bin"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
    }

    // Utilities for Data Preview (since we don't access imgui_internal.h)
    // FIXME: This technically depends on ImGuiDataType order.
    const char* DataTypeGetDesc(ImGuiDataType data_type) const
    {
        const char* descs[] = { "Int8", "Uint8", "Int16", "Uint16", "Int32", "Uint32", "Int64", "Uint64", "Float", "Double" };
        IM_ASSERT(data_type >= 0 && data_type < IM_ARRAYSIZE(descs));
        return descs[data_type];
    }

    size_t DataTypeGetSize(ImGuiDataType data_type) const
    {
        const size_t sizes[] = { 1, 1, 2, 2, 4, 4, 8, 8, sizeof(float), sizeof(double) };
        IM_ASSERT(data_type >= 0 && data_type < IM_ARRAYSIZE(sizes));
        return sizes[data_type];
    }

    const char* DataFormatGetDesc(DataFormat data_format) const
    {
        const char* descs[] = { "Bin", "Dec", "Hex" };
        IM_ASSERT(data_format >= 0 && data_format < DataFormat_COUNT);
        return descs[data_format];
    }

    bool IsBigEndian() const
    {
        uint16_t x = 1;
        char c[2];
        memcpy(c, &x, 2);
        return c[0] != 0;
    }

    static void* EndiannessCopyBigEndian(void* _dst, void* _src, size_t s, int is_little_endian)
    {
        if (is_little_endian)
        {
            uint8_t* dst = (uint8_t*)_dst;
            uint8_t* src = (uint8_t*)_src + s - 1;
            for (int i = 0, n = (int)s; i < n; ++i)
                memcpy(dst++, src--, 1);
            return _dst;
        }
        else
        {
            return memcpy(_dst, _src, s);
        }
    }

    static void* EndiannessCopyLittleEndian(void* _dst, void* _src, size_t s, int is_little_endian)
    {
        if (is_little_endian)
        {
            return memcpy(_dst, _src, s);
        }
        else
        {
            uint8_t* dst = (uint8_t*)_dst;
            uint8_t* src = (uint8_t*)_src + s - 1;
            for (int i = 0, n = (int)s; i < n; ++i)
                memcpy(dst++, src--, 1);
            return _dst;
        }
    }

    void* EndiannessCopy(void* dst, void* src, size_t size) const
    {
        static void* (*fp)(void*, void*, size_t, int) = nullptr;
        if (fp == nullptr)
            fp = IsBigEndian() ? EndiannessCopyBigEndian : EndiannessCopyLittleEndian;
        return fp(dst, src, size, PreviewEndianness);
    }

    const char* FormatBinary(const uint8_t* buf, int width) const
    {
        IM_ASSERT(width <= 64);
        size_t out_n = 0;
        static char out_buf[64 + 8 + 1];
        int n = width / 8;
        for (int j = n - 1; j >= 0; --j)
        {
            for (int i = 0; i < 8; ++i)
                out_buf[out_n++] = (buf[j] & (1 << (7 - i))) ? '1' : '0';
            out_buf[out_n++] = ' ';
        }
        IM_ASSERT(out_n < IM_ARRAYSIZE(out_buf));
        out_buf[out_n] = 0;
        return out_buf;
    }

    // [Internal]
    void DrawPreviewData(size_t addr, const ImU8* mem_data, size_t mem_size, ImGuiDataType data_type, DataFormat data_format, char* out_buf, size_t out_buf_size) const
    {
        uint8_t buf[8];
        size_t elem_size = DataTypeGetSize(data_type);
        size_t size = addr + elem_size > mem_size ? mem_size - addr : elem_size;
        if (ReadFn)
            for (int i = 0, n = (int)size; i < n; ++i)
                buf[i] = ReadFn(mem_data, addr + i, UserData);
        else
            memcpy(buf, mem_data + addr, size);

        if (data_format == DataFormat_Bin)
        {
            uint8_t binbuf[8];
            EndiannessCopy(binbuf, buf, size);
            ImSnprintf(out_buf, out_buf_size, "%s", FormatBinary(binbuf, (int)size * 8));
            return;
        }

        out_buf[0] = 0;
        switch (data_type)
        {
        case ImGuiDataType_S8:
        {
            int8_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hhd", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%02x", data & 0xFF); return; }
            break;
        }
        case ImGuiDataType_U8:
        {
            uint8_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hhu", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%02x", data & 0XFF); return; }
            break;
        }
        case ImGuiDataType_S16:
        {
            int16_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hd", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%04x", data & 0xFFFF); return; }
            break;
        }
        case ImGuiDataType_U16:
        {
            uint16_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hu", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%04x", data & 0xFFFF); return; }
            break;
        }
        case ImGuiDataType_S32:
        {
            int32_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%d", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%08x", data); return; }
            break;
        }
        case ImGuiDataType_U32:
        {
            uint32_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%u", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%08x", data); return; }
            break;
        }
        case ImGuiDataType_S64:
        {
            int64_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%lld", (long long)data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%016llx", (long long)data); return; }
            break;
        }
        case ImGuiDataType_U64:
        {
            uint64_t data = 0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%llu", (long long)data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%016llx", (long long)data); return; }
            break;
        }
        case ImGuiDataType_Float:
        {
            float data = 0.0f;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%f", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%a", data); return; }
            break;
        }
        case ImGuiDataType_Double:
        {
            double data = 0.0;
            EndiannessCopy(&data, buf, size);
            if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%f", data); return; }
            if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%a", data); return; }
            break;
        }
        default:
        case ImGuiDataType_COUNT:
            break;
        } // Switch
        IM_ASSERT(0); // Shouldn't reach
    }
};

#undef _PRISizeT
#undef ImSnprintf

#ifdef _MSC_VER
#pragma warning (pop)
#endif
````

## File: src/video/movies.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "../audio.h"
#include "../renderer.h"
#include "../gl.h"

#include "movies.h"

#include <cctype>

// 10 frames
#define VIDEO_BUFFER_SIZE 10

#define LAG (((now - start_time) - (timer_freq / movie_fps) * movie_frame_counter) / (timer_freq / 1000))

uint32_t audio_must_be_converted = false;

AVFormatContext *format_ctx = 0;
AVCodecContext *codec_ctx = 0;
const AVCodec *codec = 0;
AVCodecContext *acodec_ctx = 0;
const AVCodec *acodec = 0;
AVFrame *movie_frame = 0;
struct SwsContext *sws_ctx = 0;
SwrContext* swr_ctx = NULL;

int videostream;
int audiostream;

struct video_frame
{
	uint32_t yuv_textures[3] = { 0 };
};

struct video_frame video_buffer[VIDEO_BUFFER_SIZE];
uint32_t vbuffer_read = 0;
uint32_t vbuffer_write = 0;

uint32_t movie_frame_counter = 0;
uint32_t movie_frames;
uint32_t movie_width, movie_height;
double movie_fps;
double movie_duration;
bool fullrange_input = false;
ColorMatrixType colormatrix = COLORMATRIX_BT601;
ColorGamutType colorgamut = COLORGAMUT_SRGB;
InverseGammaFunctionType gammatype = GAMMAFUNCTION_SRGB;
AVPixelFormat targetpixelformat = AV_PIX_FMT_YUV444P;

bool first_audio_packet;

time_t timer_freq;
time_t start_time;

void ffmpeg_movie_init()
{
	ffnx_info("FFMpeg movie player plugin loaded\n");

	QueryPerformanceFrequency((LARGE_INTEGER *)&timer_freq);
}

// clean up anything we have allocated
void ffmpeg_release_movie_objects()
{
	uint32_t i;

	if (movie_frame) av_frame_free(&movie_frame);
	if (codec_ctx) avcodec_free_context(&codec_ctx);
	if (acodec_ctx) avcodec_free_context(&acodec_ctx);
	if (format_ctx) avformat_close_input(&format_ctx);
	if (swr_ctx) {
		swr_close(swr_ctx);
		swr_free(&swr_ctx);
	}

	codec_ctx = 0;
	acodec_ctx = 0;
	format_ctx = 0;

	audio_must_be_converted = false;

	for(i = 0; i < VIDEO_BUFFER_SIZE; i++)
	{
		// Cleanup YUV textures
		for (uint32_t idx = 0; idx < 3; idx++)
		{
			newRenderer.deleteTexture(video_buffer[i].yuv_textures[idx]);
			video_buffer[i].yuv_textures[idx] = 0;
		}
	}

	// Unset slot U and V as they are used only for YUV textures
	newRenderer.useTexture(0, RendererTextureSlot::TEX_U);
	newRenderer.useTexture(0, RendererTextureSlot::TEX_V);
}

// prepare a movie for playback
uint32_t ffmpeg_prepare_movie(const char *name, bool with_audio)
{
	uint32_t i;
	WAVEFORMATEX sound_format;
	DSBUFFERDESC1 sbdesc;
	bool okpixelformat = false;
	bool okcolorspace = false;
	bool yuvjfixneeded = false;
	bool islogomovie = false;
	bool isff8steammovie = false;
	int lastbackslashindex = -1;
	int bytessincebackslash = 0;
	int scanoffset = 0;

	movie_frames = 0;

	if(avformat_open_input(&format_ctx, name, NULL, NULL))
	{
		ffnx_error("prepare_movie: couldn't open movie file: %s\n", name);
		ffmpeg_release_movie_objects();
		goto exit;
	}

	if(avformat_find_stream_info(format_ctx, NULL) < 0)
	{
		ffnx_error("prepare_movie: couldn't find stream info\n");
		ffmpeg_release_movie_objects();
		goto exit;
	}

	videostream = av_find_best_stream(format_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, &codec, 0);
	if (videostream < 0) {
		ffnx_error("prepare_movie: no video stream found\n");
		ffmpeg_release_movie_objects();
		goto exit;
	}

	if (with_audio)
	{
		audiostream = av_find_best_stream(format_ctx, AVMEDIA_TYPE_AUDIO, -1, -1, &acodec, 0);
		if(audiostream < 0 && (trace_movies || trace_all)) ffnx_trace("prepare_movie: no audio stream found\n");
	}
	else
		audiostream = -1;

	codec_ctx = avcodec_alloc_context3(codec);
	if (!codec_ctx) {
		ffnx_error("prepare_movie: could not allocate video codec context\n");
		codec_ctx = 0;
		ffmpeg_release_movie_objects();
		goto exit;
	}
	avcodec_parameters_to_context(codec_ctx, format_ctx->streams[videostream]->codecpar);

	if(avcodec_open2(codec_ctx, codec, NULL) < 0)
	{
		ffnx_error("prepare_movie: couldn't open video codec\n");
		ffmpeg_release_movie_objects();
		goto exit;
	}

	if(audiostream >= 0)
	{
		acodec_ctx = avcodec_alloc_context3(acodec);
		if (!acodec_ctx) {
			ffnx_error("prepare_movie: could not allocate audio codec context\n");
			codec_ctx = 0;
			ffmpeg_release_movie_objects();
			goto exit;
		}
		avcodec_parameters_to_context(acodec_ctx, format_ctx->streams[audiostream]->codecpar);

		if(avcodec_open2(acodec_ctx, acodec, NULL) < 0)
		{
			ffnx_error("prepare_movie: couldn't open audio codec\n");
			ffmpeg_release_movie_objects();
			goto exit;
		}
	}

	// figure out if this is the eidos logo or square logo; they need special treatment
	// scan till we hit 0 terminator
	while (true){
		bytessincebackslash++;
		// note the index of the last backslash, and how far the string continues after that
		if (name[scanoffset] == 92){
			lastbackslashindex = scanoffset;
			bytessincebackslash = 0;
		}
		else if (name[scanoffset] == 0){
			break;
		}
		scanoffset++;
	}
	char upperbuffer[128];
	memset(upperbuffer, 0, 128);
	if ((lastbackslashindex > -1) && (bytessincebackslash > 1) && (bytessincebackslash <= 128)){
		memcpy(&upperbuffer, &name[lastbackslashindex+1], bytessincebackslash);
		// convert to uppercase
		for (int i=0; i<bytessincebackslash; i++){
			upperbuffer[i] = toupper(upperbuffer[i]);
		}
		// strip the file extension
		for (int i=bytessincebackslash-1; i>=0; i--){
			char backchar = upperbuffer[i];
			upperbuffer[i] = 0;
			if (backchar == 46){
				break;
			}
		}
		if (	(strcmp(upperbuffer, "EIDOSLOGO") == 0) ||
			(strcmp(upperbuffer, "SQLOGO") == 0)
		){
			islogomovie = true;
			if (trace_movies  || trace_all) ffnx_trace("prepare_movie: %s detected as logo movie; NTSC-J conversion will be supressed.\n", name);
		}
	}

	// Movie files from the ff8 Steam release appear to be bt709, tv-range, with gamut conversion already done, and no metadata
	// (Not completely sure about bt709; it's hard to tell under the circumstances.)
	if (    ff8 &&
			((codec_ctx->height >= 720) || (codec_ctx->width >= 1280)) && // the samples I examined were 1280 x 896, but I didn't check them all to rule out some of them being cropped
			(codec_ctx->pix_fmt == AV_PIX_FMT_YUV420P) &&
			(codec_ctx->color_range == AVCOL_RANGE_UNSPECIFIED) &&
			(codec_ctx->colorspace == AVCOL_SPC_UNSPECIFIED) &&
			(codec_ctx->color_trc == AVCOL_TRC_UNSPECIFIED) &&
			(codec_ctx->color_primaries == AVCOL_PRI_UNSPECIFIED)
	){
		isff8steammovie = true;
		if (trace_movies  || trace_all) ffnx_trace("prepare_movie: File %s appears to be from the FF8 Steam release. Missing metadata will be guessed accordingly.\n", name);
	}

	movie_width = codec_ctx->width;
	movie_height = codec_ctx->height;
	movie_fps = av_q2d(av_guess_frame_rate(format_ctx, format_ctx->streams[videostream], NULL));
	movie_duration = (double)format_ctx->duration / (double)AV_TIME_BASE;
	movie_frames = (uint32_t)::round(movie_fps * movie_duration);
	fullrange_input = (codec_ctx->color_range == AVCOL_RANGE_JPEG);

	// some pixel formats are inherently full-range
	// so we should treat them as such, even if the color range metadata is missing
	// some of these formats also trigger an automatic color range conversion that we must suppress
	switch (codec_ctx->pix_fmt){
		case AV_PIX_FMT_YUVJ420P:
		case AV_PIX_FMT_YUVJ411P:
		case AV_PIX_FMT_YUVJ422P:
		case AV_PIX_FMT_YUVJ444P:
		case AV_PIX_FMT_YUVJ440P:
			fullrange_input = true;
			yuvjfixneeded = true;
			break;
		case AV_PIX_FMT_GRAY8:
		case AV_PIX_FMT_YA8:
		case AV_PIX_FMT_GRAY16LE:
		case AV_PIX_FMT_GRAY16BE:
		case AV_PIX_FMT_YA16BE:
		case AV_PIX_FMT_YA16LE:
		case AV_PIX_FMT_BGR24:
			fullrange_input = true;
			yuvjfixneeded = false;
			break;
		default:
			yuvjfixneeded = false;
	}

	if (isff8steammovie){
		fullrange_input = false;
		yuvjfixneeded = false;
	}

	if (trace_movies  || trace_all) ffnx_trace("prepare_movie: color range detected as %i (0=tv, 1=pc).\n", fullrange_input);

	// will we need to convert the colorspace?
	switch(codec_ctx->colorspace){
		// these are all the same (bt601)
		case AVCOL_SPC_UNSPECIFIED: // ffmpeg guesses and treats this as bt601
		case AVCOL_SPC_RESERVED: // ffmpeg guesses and treats this as bt601
			if (codec_ctx->pix_fmt == AV_PIX_FMT_BGR24){
				if (trace_movies  || trace_all) ffnx_trace("prepare_movie: BGR24 detected.\n");
				colormatrix = COLORMATRIX_BGR24;
				okcolorspace = true;
				break;
			}
			else if (isff8steammovie){
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: assuming bt709 color matrix because this is a FF8 Steam release movie.\n");
				colormatrix = COLORMATRIX_BT709;
				okcolorspace = true;
				break;
			}
			// fall through to next case if we didn't already break
		case AVCOL_SPC_BT470BG:
		case AVCOL_SPC_SMPTE170M:
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: bt601 color matrix detected or defaulted to.\n");
			colormatrix = COLORMATRIX_BT601;
			okcolorspace = true;
			break;
		case AVCOL_SPC_BT709:
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: bt709 color matrix detected.\n");
			colormatrix = COLORMATRIX_BT709;
			okcolorspace = true;
		case AVCOL_SPC_RGB:
			if (codec_ctx->pix_fmt == AV_PIX_FMT_BGR24){
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: BGR24 detected.\n");
				colormatrix = COLORMATRIX_BGR24;
				okcolorspace = true;
			}
			else {
				okcolorspace = false;
			}
			break;
		default:
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: unhandled color matrix detected; will use swscale to convert. Expect incorrect gamut.\n");
			okcolorspace = false;
	}

	// what gamma should we use?
	switch(codec_ctx->color_trc){
		case AVCOL_TRC_UNSPECIFIED:
		case AVCOL_TRC_RESERVED:
		case AVCOL_TRC_RESERVED0:
			if (colormatrix == COLORMATRIX_BT709){
				gammatype = GAMMAFUNCTION_SMPTE170M;
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing gamma metadata, but bt709 color matrix, so assuming SMPTE170M transfer function.\n");
			}
			else if (codec_ctx->color_primaries == AVCOL_PRI_BT470BG){
				gammatype = GAMMAFUNCTION_TWO_PT_EIGHT;
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing gamma metadata, but EBU color gamut (PAL), so assuming 2.8 gamma (PAL).\n");
			}
			else {
				gammatype = GAMMAFUNCTION_TOELESS_SRGB;
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing gamma metadata, assuming Playstation-derived video, using \"toeless sRGB\" gamma curve.\n");
			}
			break;
		case AVCOL_TRC_IEC61966_2_1: //srgb
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: srgb gamma transfer function detected\n");
			gammatype = GAMMAFUNCTION_SRGB;
			break;
		case AVCOL_TRC_GAMMA22:
			gammatype = GAMMAFUNCTION_TWO_PT_TWO;
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: 2.2 gamma transfer function detected\n");
			break;
		case AVCOL_TRC_SMPTE170M:
		case AVCOL_TRC_BT709: // same as SMPTE170M
		case AVCOL_TRC_BT2020_10: // same as SMPTE170M
		case AVCOL_TRC_BT2020_12: // same as SMPTE170M
		case AVCOL_TRC_IEC61966_2_4: // same as SMPTE170M, but is defined for negative numbers too (which we ignore)
		case AVCOL_TRC_BT1361_ECG: // same as SMPTE170M, but is defined for negative numbers too (which we ignore)
			gammatype = GAMMAFUNCTION_SMPTE170M;
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: SMPTE170M transfer function detected\n");
			break;
		case AVCOL_TRC_GAMMA28:
			gammatype = GAMMAFUNCTION_TWO_PT_EIGHT;
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: 2.8 gamma transfer function detected\n");
			break;
		default:
			ffnx_error("prepare_movie: unsupported transfer (inverse gamma) function\n");
			ffmpeg_release_movie_objects();
			goto exit;
	}

	if (codec_ctx->pix_fmt == AV_PIX_FMT_BGR24){
		targetpixelformat = AV_PIX_FMT_BGR24;
	}
	else{
		targetpixelformat = AV_PIX_FMT_YUV444P;
	}

	// will we need to convert the pixel format?
	// we're going to target YUV444 on the assumption that swscale does better subsampling than texture2D() in the shader
	// Also, we generally shouldn't target a YUVJ format because that triggers a bunch of automatic, sometimes wrong, color range conversions
	if (codec_ctx->pix_fmt == targetpixelformat){
		okpixelformat = true;
	}

	switch(codec_ctx->color_primaries){
		case AVCOL_PRI_BT709:
			colorgamut = COLORGAMUT_SRGB;
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: srgb/bt709 color gamut detected.\n");
			break;
		case AVCOL_PRI_BT470M:
			// Since 470m (NTSC1953) was deprecated in 1979, material in this gamut is rare and likely irrelevant to FF7/8.
			// Assume user meant SMPTE-C (which replaced NTSC1953 in 1979).
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: NTSC1953 color gamut detected. Assuming user error and using SMPTE-C instead.\n");
			// fall through to next case
		case AVCOL_PRI_SMPTE170M:
		case AVCOL_PRI_SMPTE240M:

			colorgamut = COLORGAMUT_SMPTEC;
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: SMPTE-C color gamut detected.\n");
			break;
		case AVCOL_PRI_UNSPECIFIED:
		case AVCOL_PRI_RESERVED0:
		case AVCOL_PRI_RESERVED:
			if (isff8steammovie){
				colorgamut = COLORGAMUT_SRGB;
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming srgb/bt709 because this is a FF8 Steam release video. (Steam already did NTSC-J to SRGB gamut conversion.)\n");
			}
			else if (colormatrix == COLORMATRIX_BT709){
				colorgamut = COLORGAMUT_SRGB;
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming srgb/bt709 because bt709 color matrix.\n");
			}
			else if (islogomovie){
				colorgamut = COLORGAMUT_SRGB;
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming srgb/bt709 because this is a logo movie.\n");
			}
			else {
				colorgamut = COLORGAMUT_NTSCJ;
				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming NTSC-J.\n");
			}
			break;
		case AVCOL_PRI_BT470BG:
			colorgamut = COLORGAMUT_EBU;
			if (trace_movies || trace_all) ffnx_trace("prepare_movie: EBU(PAL) color gamut detected.\n");
			break;
		default:
			ffnx_error("prepare_movie: unsupported color gamut\n");
			ffmpeg_release_movie_objects();
			goto exit;
	}

	if (trace_movies || trace_all)
	{
		if (movie_fps < 100.0) ffnx_info("prepare_movie: %s; %s/%s %ix%i, %f FPS, duration: %f, frames: %i, color_range: %d\n", name, codec->name, acodec_ctx ? acodec->name : "null", movie_width, movie_height, movie_fps, movie_duration, movie_frames, codec_ctx->color_range);
		// bogus FPS value, assume the codec provides frame limiting
		else ffnx_info("prepare_movie: %s; %s/%s %ix%i, duration: %f, color_range: %d\n", name, codec->name, acodec_ctx ? acodec->name : "null", movie_width, movie_height, movie_duration, codec_ctx->color_range);
	}

	if(movie_width > max_texture_size || movie_height > max_texture_size)
	{
		ffnx_error("prepare_movie: movie dimensions exceed max texture size, skipping\n");
		ffmpeg_release_movie_objects();
		goto exit;
	}

	if(!movie_frame) movie_frame = av_frame_alloc();

	if(sws_ctx) sws_freeContext(sws_ctx);

	vbuffer_read = 0;
	vbuffer_write = 0;

	if(!okpixelformat || !okcolorspace || yuvjfixneeded)
		// Don't check for !fullrange_input here because swscale won't always do color range conversions on request, so we can't rely on it and must instead do it ourselves in the shader
	{
		if (trace_movies || trace_all)
		{
			ffnx_trace("prepare_movie: Video must be converted: IN codec_ctx->colorspace: %s\n", av_color_space_name(codec_ctx->colorspace));
			ffnx_trace("prepare_movie: Video must be converted: IN codec_ctx->pix_fmt: %s\n", av_pix_fmt_desc_get(codec_ctx->pix_fmt)->name);
		}

		sws_ctx = sws_getContext(
			movie_width,
			movie_height,
			codec_ctx->pix_fmt,
			movie_width,
			movie_height,
			targetpixelformat,
			SWS_LANCZOS | SWS_ACCURATE_RND | SWS_FULL_CHR_H_INT,
			NULL,
			NULL,
			NULL
		);

		// if we need a colorspace conversion, set it up here
		// this would also be the place to set up color range conversion, if it worked -- which it doens't
		if (!okcolorspace || yuvjfixneeded){
			int *coefs_in;
			int *coefs_out;
			int srcRange, dstRange;
			int brightness, contrast, saturation;
			sws_getColorspaceDetails(sws_ctx, &coefs_in, &srcRange, &coefs_out, &dstRange, &brightness, &contrast, &saturation);

			coefs_in = const_cast<int*>(sws_getCoefficients(codec_ctx->colorspace)); // const sucks
			// use the same colorspace
			if (okcolorspace){
				coefs_out = coefs_in;
			}
			// convert
			else {
				coefs_out = const_cast<int*>(sws_getCoefficients(SWS_CS_ITU601)); // const sucks
			}

			// Surprisingly, these parameters don't appear to **do** anything in most cases.
			// It appears that whether swscale does a range conversion is controlled by pixformat and range metadata.
			// And it will do one regardless of whether you want it.
			// Except, when the input format is YUVJ, these parameters can be used to **prevent** an un-asked-for PC->TV conversion
			// (They are totally ignored with 10-bit input formats, however.)
			// Gawd... swscale is a buggy mess...
			if (yuvjfixneeded){
				srcRange = fullrange_input ? 1 : 0; // use the input color range
				dstRange = srcRange; // no conversion!
			}

			sws_setColorspaceDetails(sws_ctx, coefs_in, srcRange, coefs_out, dstRange, brightness, contrast, saturation);
		}

	}
	else {
		sws_ctx = nullptr;
	}

	if(audiostream >= 0)
	{
		if (acodec_ctx->sample_fmt != AV_SAMPLE_FMT_FLT) {
			audio_must_be_converted = true;
			if (trace_movies || trace_all)
			{
				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->sample_fmt: %s\n", av_get_sample_fmt_name(acodec_ctx->sample_fmt));
				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->sample_rate: %d\n", acodec_ctx->sample_rate);
				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->ch_layout.u.mask: %u\n", acodec_ctx->ch_layout.u.mask);
				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->ch_layout.nb_channels: %u\n", acodec_ctx->ch_layout.nb_channels);
			}

			// Prepare software conversion context
			swr_alloc_set_opts2(
				// Create a new context
				&swr_ctx,
				// OUT
				&acodec_ctx->ch_layout,
				AV_SAMPLE_FMT_FLT,
				acodec_ctx->sample_rate,
				// IN
				&acodec_ctx->ch_layout,
				acodec_ctx->sample_fmt,
				acodec_ctx->sample_rate,
				// LOG
				0,
				NULL
			);

			swr_init(swr_ctx);
		}

		nxAudioEngine.initStream(
			movie_duration,
			acodec_ctx->sample_rate,
			acodec_ctx->ch_layout.nb_channels
		);

		first_audio_packet = true;
	}

	exit:
	movie_frame_counter = 0;

	return movie_frames;
}

// stop movie playback, no video updates will be requested after this so all we have to do is stop the audio
void ffmpeg_stop_movie()
{
	nxAudioEngine.stopStream();
}

void upload_yuv_texture(uint8_t **planes, int *strides, uint32_t num, uint32_t buffer_index)
{
	uint32_t upload_width = strides[num];
	// Use full dimensions for chroma planes in yuv444. If yuv420, use half width and half height instead.
	uint32_t tex_width = movie_width;
	uint32_t tex_height = movie_height;

	if (upload_width > tex_width) tex_width = upload_width;

	if (video_buffer[buffer_index].yuv_textures[num])
		newRenderer.deleteTexture(video_buffer[buffer_index].yuv_textures[num]);

	video_buffer[buffer_index].yuv_textures[num] = newRenderer.createTexture(
		planes[num],
		tex_width,
		tex_height,
		upload_width,
		RendererTextureType::YUV,
		false
	);
}

void buffer_yuv_frame(uint8_t **planes, int *strides)
{
	// Special case for BGR24. Make it planar RGB so we can pass it through the YUV plumbing
	// Not very efficient, but it's not worth making everything else more complex for the sake of this one case.
	if (targetpixelformat == AV_PIX_FMT_BGR24){
		if (strides[0] % 3 != 0){
			ffnx_error("buffer_yuv_frame: movie file claims to be bgr24, but stride isn't divisible by 3!\n");
			ffmpeg_release_movie_objects();
			movie_frame_counter = 0;
			return;
		}
		const int planarstride = strides[0]/3;
		int fakestrides[3] = {planarstride, planarstride, planarstride};
		uint8_t* realbuffer = planes[0];
		uint8_t* redbuffer = (uint8_t*)malloc(planarstride * movie_height * sizeof(uint8_t));
		uint8_t* greenbuffer = (uint8_t*)malloc(planarstride * movie_height * sizeof(uint8_t));
		uint8_t* bluebuffer = (uint8_t*)malloc(planarstride * movie_height * sizeof(uint8_t));
		uint8_t* fakeplanes[3] = {redbuffer, greenbuffer, bluebuffer};
		int smallindex = 0;
		int rgbindex = 0;
		int maxindex = strides[0] * movie_height;
		for (int i=0; i<maxindex; i++){
			uint8_t nextbyte = realbuffer[i];
			if (rgbindex == 0){
				bluebuffer[smallindex] = nextbyte;
			}
			else if (rgbindex == 1){
				greenbuffer[smallindex] = nextbyte;
			}
			else {
				redbuffer[smallindex] = nextbyte;
				smallindex++;
			}
			rgbindex++;
			if (rgbindex > 2){
				rgbindex = 0;
			}
		}
		upload_yuv_texture(fakeplanes, fakestrides, 0, vbuffer_write); // R as Y
		upload_yuv_texture(fakeplanes, fakestrides, 1, vbuffer_write); // G as U
		upload_yuv_texture(fakeplanes, fakestrides, 2, vbuffer_write); // B as V
		free(redbuffer);
		redbuffer = nullptr;
		free(greenbuffer);
		greenbuffer = nullptr;
		free(bluebuffer);
		bluebuffer = nullptr;
	}
	// normal case
	else {
		upload_yuv_texture(planes, strides, 0, vbuffer_write); // Y
		upload_yuv_texture(planes, strides, 1, vbuffer_write); // U
		upload_yuv_texture(planes, strides, 2, vbuffer_write); // V
	}

	vbuffer_write = (vbuffer_write + 1) % VIDEO_BUFFER_SIZE;
}

void draw_yuv_frame(uint32_t buffer_index)
{
	if(gl_defer_yuv_frame(buffer_index)) return;

	for (uint32_t idx = 0; idx < 3; idx++)
		newRenderer.useTexture(video_buffer[buffer_index].yuv_textures[idx], idx);

	newRenderer.isMovie(true);
	newRenderer.isYUV(true);
	newRenderer.isFullRange(fullrange_input);
	newRenderer.setColorMatrix(colormatrix);
	newRenderer.setColorGamut(colorgamut);
	newRenderer.setGammaType(gammatype);
	gl_draw_movie_quad(movie_width, movie_height);
	newRenderer.isFullRange(false);
	newRenderer.isYUV(false);
	newRenderer.isMovie(false);
	newRenderer.setColorMatrix(COLORMATRIX_BT601);
	newRenderer.setColorGamut(COLORGAMUT_SRGB);
	newRenderer.setGammaType(GAMMAFUNCTION_SRGB);
}

// display the next frame
uint32_t ffmpeg_update_movie_sample(bool use_movie_fps)
{
	AVPacket packet;
	int ret;
	time_t now;
	DWORD DSStatus;

	// no playable movie loaded, skip it
	if(!format_ctx) return false;

	// keep track of when we started playing this movie
	if(movie_frame_counter == 0) QueryPerformanceCounter((LARGE_INTEGER *)&start_time);

	while((ret = av_read_frame(format_ctx, &packet)) >= 0)
	{
		if(packet.stream_index == videostream)
		{
			ret = avcodec_send_packet(codec_ctx, &packet);

			if (ret < 0)
			{
				ffnx_trace("%s: avcodec_send_packet -> %d\n", __func__, ret);
				av_packet_unref(&packet);
				break;
			}

			ret = avcodec_receive_frame(codec_ctx, movie_frame);

			if (ret == AVERROR_EOF)
			{
				ffnx_trace("%s: avcodec_receive_frame -> %d\n", __func__, ret);
				av_packet_unref(&packet);
				break;
			}

			if (ret >= 0)
			{
				QueryPerformanceCounter((LARGE_INTEGER *)&now);

				if(sws_ctx)
				{
					AVFrame* frame = av_frame_alloc();
					frame->width = movie_width;
					frame->height = movie_height;
					frame->format = targetpixelformat;

					av_image_alloc(frame->data, frame->linesize, frame->width, frame->height, AVPixelFormat(frame->format), 1);

					sws_scale(sws_ctx, movie_frame->extended_data, movie_frame->linesize, 0, frame->height, frame->data, frame->linesize);
					buffer_yuv_frame(frame->data, frame->linesize);

					av_freep(&frame->data[0]);
					av_frame_free(&frame);
				}
				else buffer_yuv_frame(movie_frame->extended_data, movie_frame->linesize);

				if(vbuffer_write == vbuffer_read)
				{
					draw_yuv_frame(vbuffer_read);

					vbuffer_read = (vbuffer_read + 1) % VIDEO_BUFFER_SIZE;

					av_packet_unref(&packet);

					break;
				}
			}
		}

		if(packet.stream_index == audiostream)
		{
			QueryPerformanceCounter((LARGE_INTEGER *)&now);

			ret = avcodec_send_packet(acodec_ctx, &packet);

			if (ret < 0)
			{
				ffnx_trace("%s: avcodec_send_packet -> %d\n", __func__, ret);
				av_packet_unref(&packet);
				break;
			}

			ret = avcodec_receive_frame(acodec_ctx, movie_frame);

			if (ret == AVERROR_EOF)
			{
				ffnx_trace("%s: avcodec_receive_frame -> %d\n", __func__, ret);
				av_packet_unref(&packet);
				break;
			}

			if (ret >= 0)
			{
				uint32_t bytesperpacket = audio_must_be_converted ? av_get_bytes_per_sample(AV_SAMPLE_FMT_FLT) : av_get_bytes_per_sample(acodec_ctx->sample_fmt);
				uint32_t _size = bytesperpacket * movie_frame->nb_samples * acodec_ctx->ch_layout.nb_channels;

				// Sometimes the captured frame may have no sound samples. Just skip and move forward
				if (_size)
				{
					uint8_t *buffer;

					av_samples_alloc(&buffer, movie_frame->linesize, acodec_ctx->ch_layout.nb_channels, movie_frame->nb_samples, (audio_must_be_converted ? AV_SAMPLE_FMT_FLT : acodec_ctx->sample_fmt), 0);
					if (audio_must_be_converted) swr_convert(swr_ctx, &buffer, movie_frame->nb_samples, (const uint8_t**)movie_frame->extended_data, movie_frame->nb_samples);
					else av_samples_copy(&buffer, movie_frame->extended_data, 0, 0, movie_frame->nb_samples, acodec_ctx->ch_layout.nb_channels, acodec_ctx->sample_fmt);

					nxAudioEngine.pushStreamData(buffer, _size);

					av_freep(&buffer);
				}
			}
		}

		av_packet_unref(&packet);
	}

	if (first_audio_packet)
	{
		first_audio_packet = false;

		// reset start time so video syncs up properly
		QueryPerformanceCounter((LARGE_INTEGER *)&start_time);

		nxAudioEngine.playStream();
	}

	movie_frame_counter++;

	// could not read any more frames, exhaust video buffer then end movie
	if(ret < 0)
	{
		if(vbuffer_write != vbuffer_read)
		{
			draw_yuv_frame(vbuffer_read);

			vbuffer_read = (vbuffer_read + 1) % VIDEO_BUFFER_SIZE;
		}

		if(vbuffer_write == vbuffer_read) return false;
	}

	// Pure movie playback has no frame limiter, although it is not always required. Use it only when necessary
	if (use_movie_fps)
	{
		// wait for the next frame
		do
		{
			QueryPerformanceCounter((LARGE_INTEGER *)&now);
		} while(LAG < 0.0);
	}

	// keep going
	return true;
}

// draw the current frame, don't update anything
void ffmpeg_draw_current_frame()
{
	draw_yuv_frame((vbuffer_read - 1) % VIDEO_BUFFER_SIZE);
}

// loop back to the beginning of the movie
void ffmpeg_loop()
{
	if(format_ctx) avformat_seek_file(format_ctx, -1, 0, 0, 0, 0);
}

// get the current frame number
uint32_t ffmpeg_get_movie_frame()
{
	return movie_frame_counter;
}

short ffmpeg_get_fps_ratio()
{
	return ceil(movie_fps / 15.0f);
}
````

## File: src/video/movies.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <windows.h>
#include <math.h>
#include <sys/timeb.h>
#include <dbghelp.h>
#include <stdint.h>

void ffmpeg_movie_init();
void ffmpeg_release_movie_objects();
uint32_t ffmpeg_prepare_movie(const char* name, bool with_audio = true);
void ffmpeg_stop_movie();
uint32_t ffmpeg_update_movie_sample(bool use_movie_fps = true);
void ffmpeg_draw_current_frame();
void ffmpeg_loop();
uint32_t ffmpeg_get_movie_frame();

short ffmpeg_get_fps_ratio();

void draw_yuv_frame(uint32_t buffer_index);
````

## File: src/achievement.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <steamworkssdk/isteamutils.h>
#include <steamworkssdk/isteamuserstats.h>
#include <steamworkssdk/isteamuser.h>

#include <numeric>
#include <algorithm>
#include <unordered_set>

#include "achievement.h"
#include "log.h"
#include "cfg.h"

#define ach_trace(x, ...) if (trace_all || trace_achievement) ffnx_trace((x), ##__VA_ARGS__)

using std::string;

std::unique_ptr<SteamAchievementsFF7> g_FF7SteamAchievements = nullptr;
std::unique_ptr<SteamAchievementsFF8> g_FF8SteamAchievements = nullptr;

SteamManager::SteamManager(const achievement *achievements, int nAchievements, std::vector<std::string> statsNameVec):
  isInitialized(false),
  callbackUserStatsReceived(this, &SteamManager::OnUserStatsReceived),
  callbackUserStatsStored(this, &SteamManager::OnUserStatsStored),
  callbackAchievementStored(this, &SteamManager::OnAchievementStored)
{
    this->appID = SteamUtils()->GetAppID();
    this->nAchievements = nAchievements;
    for (std::string statName : statsNameVec) {
        this->stats.insert({statName, 0});
    }
    this->achievementList.insert(this->achievementList.end(), &achievements[0], &achievements[nAchievements]);
    this->requestStats();
    if (trace_all || trace_achievement)
        ffnx_trace("%s - Init steam achievements with appID: %d\n", __func__, this->appID);
}

bool SteamManager::requestStats()
{
    // Is Steam loaded?
    if (NULL == SteamUserStats() || NULL == SteamUser())
    {
        return false;
    }
    // Is the user logged on?
    if (!SteamUser()->BLoggedOn())
    {
        return false;
    }
    if (trace_all || trace_achievement)
        ffnx_trace("%s - Request user stats sent\n", __func__);

    return SteamUserStats()->RequestCurrentStats();
}

bool SteamManager::setAchievement(int achID)
{
    if (this->isInitialized)
    {
        if (trace_all || trace_achievement)
            ffnx_trace("%s - Achievement %s set, Store request sent to Steam\n", __func__, this->getStringAchievementID(achID));

        this->achievementList[achID].isAchieved = true;
        if (steam_achievements_debug_mode)
        {
            return SteamUserStats()->IndicateAchievementProgress(this->getStringAchievementID(achID), 99, 100);
        }
        else
        {
            SteamUserStats()->SetAchievement(this->getStringAchievementID(achID));
            return SteamUserStats()->StoreStats();
        }
    }

    if (trace_all || trace_achievement)
        ffnx_error("%s - Have not received a callback from Steam, thus, cannot send achievement\n", __func__);

    return false;
}

bool SteamManager::showAchievementProgress(int achID, int progressValue, int maxValue)
{
    if (this->isInitialized)
    {
        if (trace_all || trace_achievement)
            ffnx_trace("%s - Show achievement progress for achievement %s (%d/%d)\n", __func__, this->getStringAchievementID(achID), progressValue, maxValue);

        return SteamUserStats()->IndicateAchievementProgress(this->getStringAchievementID(achID), progressValue, maxValue);
    }

    if (trace_all || trace_achievement)
        ffnx_error("%s - Have not received a callback from Steam, thus, cannot show progress achievement\n", __func__);

    return false;
}

bool SteamManager::isAchieved(int achID)
{
    return this->achievementList[achID].isAchieved;
}

const char *SteamManager::getStringAchievementID(int achID)
{
    return this->achievementList[achID].chAchID;
}

std::optional<int> SteamManager::getUserStat(const std::string &statName) {
    if (!this->stats.contains(statName)) {
       return {};
    }
    return {this->stats.at(statName)};
}

bool SteamManager::updateUserStat(const std::string &statName, int value) {
    if (!this->stats.contains(statName)) {
       return false;
    }
    ach_trace("%s - Updating steam user stat '%s' to %d\n", __func__, statName.c_str(), value);
    this->stats.insert_or_assign(statName, value);
    SteamUserStats()->SetStat(statName.c_str(), value);
    return SteamUserStats()->StoreStats();
}

void SteamManager::OnUserStatsReceived(UserStatsReceived_t *pCallback)
{
    if (this->appID == pCallback->m_nGameID)
    {
        if (k_EResultOK == pCallback->m_eResult)
        {
            if (trace_all || trace_achievement)
                ffnx_trace("%s - received stats and achievements from Steam\n", __func__);
            this->isInitialized = true;
 
            // load stats (assume all stats to be integers)
            for (auto statName: this->stats) {
                int statValue;
                if (SteamUserStats()->GetStat(statName.first.c_str(), &statValue)) {
                    this->stats.insert_or_assign(statName.first, statValue);
                }

                ach_trace("%s - user stat(%s, %d)\n", __func__, statName.first.c_str(), statValue);
            }

            // load achievements
            for (int i = 0; i < this->nAchievements; ++i)
            {
                achievement &ach = this->achievementList[i];

                SteamUserStats()->GetAchievement(ach.chAchID, &ach.isAchieved);
                _snprintf(ach.achName, sizeof(ach.achName), "%s",
                          SteamUserStats()->GetAchievementDisplayAttribute(ach.chAchID,
                                                                           "name"));
                _snprintf(ach.achDescription, sizeof(ach.achDescription), "%s",
                          SteamUserStats()->GetAchievementDisplayAttribute(ach.chAchID,
                                                                           "desc"));

                if (trace_all || trace_achievement)
                    ffnx_trace("%s - achievement data(%s, %s, %s)\n", __func__, ach.chAchID, ach.achDescription, ach.isAchieved ? "true" : "false");
            }
        }
        else
        {
            if (trace_all || trace_achievement)
                ffnx_trace("%s - RequestStats - failed, %d\n", __func__, pCallback->m_eResult);
        }
    }
}

void SteamManager::OnUserStatsStored(UserStatsStored_t *pCallback)
{
    if (this->appID == pCallback->m_nGameID)
    {
        if (k_EResultOK == pCallback->m_eResult)
        {
            if (trace_all || trace_achievement)
                ffnx_info("%s - success\n", __func__);
        }
        else
        {
            if (trace_all || trace_achievement)
                ffnx_trace("%s - failed, %d\n", __func__, pCallback->m_eResult);
        }
    }
}

void SteamManager::OnAchievementStored(UserAchievementStored_t *pCallback)
{
    if (this->appID == pCallback->m_nGameID)
    {
        if (trace_all || trace_achievement)
            ffnx_trace("%s - Stored Achievement %s for Steam\n", __func__, pCallback->m_rgchAchievementName);
    }
}

// -------------------------- STEAM ACHIEVEMENTS OF FF7 ---------------------------

SteamAchievementsFF7::SteamAchievementsFF7()
{
    this->steamManager = std::make_unique<SteamManager>(SteamAchievementsFF7::ACHIEVEMENTS, FF7_N_ACHIEVEMENTS);
    this->lastSeenMovieName = INVALID_MOVIE_NAME;
}

void SteamAchievementsFF7::initStatsFromSaveFile(const savemap &savemap)
{
    this->yuffieUnlocked = this->isYuffieUnlocked(savemap.yuffie_reg_mask);
    this->vincentUnlocked = this->isVincentUnlocked(savemap.vincent_reg_mask);
    for (int i = 0; i < N_GOLD_CHOCOBO_FIRST_SLOTS + N_GOLD_CHOCOBO_LAST_SLOTS; i++)
    {
        const chocobo_slot slot = (i < N_GOLD_CHOCOBO_FIRST_SLOTS) ? savemap.chocobo_slots_first[i] : savemap.chocobo_slots_last[i - N_GOLD_CHOCOBO_FIRST_SLOTS];
        this->isGoldChocoboSlot[i] = slot.type == GOLD_CHOCOBO_TYPE;
    }

    this->lastSeenMovieName = INVALID_MOVIE_NAME;
    this->initMateriaMastered(savemap);

    if (trace_all || trace_achievement)
    {
        ffnx_trace("%s - init stats from save file\n", __func__);
        ffnx_trace("yuffie unlocked: %s\n", this->yuffieUnlocked ? "true" : "false");
        ffnx_trace("vincent unlocked: %s\n", this->vincentUnlocked ? "true" : "false");
    }
}

void SteamAchievementsFF7::initCharStatsBeforeBattle(const savemap_char characters[])
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - initialization of character stats before battle\n", __func__);

    for (int i = 0; i < N_CHARACTERS; i++)
    {
        this->previousUsedLimitNumber[i] = characters[i].used_n_limit_1_1;
        for (int j = 0; j < N_EQUIP_MATERIA_PER_CHARACTER; j++)
        {
            uint32_t materia = characters[i].equipped_materia[j];
            this->equipMasteredMateriaCharacter[i][j] = isMateriaMastered(materia);
        }

        if (i == CAIT_SITH_INDEX)
            this->caitsithNumKills = characters[i].num_kills;
    }
}

void SteamAchievementsFF7::initMovieStats(const string movieName)
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - the movie name initialized is: %s\n", __func__, movieName.c_str());

    this->lastSeenMovieName = std::move(movieName);
}

void SteamAchievementsFF7::initMateriaMastered(const savemap &savemap)
{
    // Called only when loading a save file
    // Assumption: there is no mastered materia obtained through new character joining the team

    if (trace_all || trace_achievement)
        ffnx_trace("%s - init materia mastered\n", __func__);

    std::fill_n(this->masteredMateria.data(), N_TYPE_MATERIA, false);

    for (int i = 0; i < N_UNKNOWN_MATERIA; i++)
    {
        this->masteredMateria[this->unknownMateriaList[i]] = true;
    }

    for (int i = 0; i < N_MATERIA_SLOT; i++)
    {
        uint32_t materia = savemap.materia[i];
        if (this->isMateriaMastered(materia))
        {
            masteredMateria[materia & 0xFF] = true;
        }
    }
    if (this->isYuffieUnlocked(savemap.yuffie_reg_mask))
    {
        for (int i = 0; i < N_STOLEN_MATERIA_SLOT; i++)
        {
            uint32_t materia = savemap.stolen_materia[i];
            if (this->isMateriaMastered(materia))
            {
                masteredMateria[materia & 0xFF] = true;
            }
        }
    }

    for (int i = 0; i < N_CHARACTERS; i++)
    {
        for (int j = 0; j < N_EQUIP_MATERIA_PER_CHARACTER; j++)
        {
            uint32_t materia = savemap.chars[i].equipped_materia[j];
            if (this->isMateriaMastered(materia))
            {
                masteredMateria[materia & 0xFF] = true;
            }
        }
    }
}

bool SteamAchievementsFF7::isMateriaMastered(uint32_t materia)
{
    byte materiaId = materia & 0xFF;
    uint32_t materiaAp = materia >> 8;
    if (std::find(unmasterableMateriaList.begin(), unmasterableMateriaList.end(), materiaId) != unmasterableMateriaList.end())
        return true;
    return materiaId != MATERIA_EMPTY_SLOT && materiaAp == MATERIA_AP_MASTERED;
}

bool SteamAchievementsFF7::isAllMateriaMastered(const std::array<bool, N_TYPE_MATERIA> masteredMateriaList)
{
    bool allMastered = true;
    for (int i = 0; i < N_TYPE_MATERIA; i++)
    {
        if (!masteredMateriaList[i])
            return false;
    }
    return allMastered;
}

bool SteamAchievementsFF7::isYuffieUnlocked(char yuffieRegular)
{
    // took from https://github.com/sithlord48/ff7tk/blob/master/src/data/FF7Save.cpp#L4777
    return yuffieRegular & (1 << 0);
}

bool SteamAchievementsFF7::isVincentUnlocked(char vincentRegular)
{
    // took from https://github.com/sithlord48/ff7tk/blob/master/src/data/FF7Save.cpp#L4799
    return vincentRegular & (1 << 2);
}

bool SteamAchievementsFF7::isEndingMovie()
{
    return this->lastSeenMovieName == END_OF_GAME_MOVIE_NAME;
}

void SteamAchievementsFF7::unlockBattleWonAchievement(WORD formationID)
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - unlock achievement for winning battle (formation ID: %d)\n", __func__, formationID);

    if (!this->steamManager->isAchieved(WON_1ST_BATTLE))
        this->steamManager->setAchievement(WON_1ST_BATTLE);

    if (!this->steamManager->isAchieved(BEAT_DIAMOND_WEAPON) && formationID == DIAMOND_WEAPON_FORMATION_ID)
    {
        this->steamManager->setAchievement(BEAT_DIAMOND_WEAPON);
    }

    if (!this->steamManager->isAchieved(BEAT_RUBY_WEAPON)
        && find(begin(RUBY_WEAPON_FORMATION_ID), end(RUBY_WEAPON_FORMATION_ID), formationID) != end(RUBY_WEAPON_FORMATION_ID))
    {
        this->steamManager->setAchievement(BEAT_RUBY_WEAPON);
    }

    if (!this->steamManager->isAchieved(BEAT_EMERALD_WEAPON)
        && find(begin(EMERALD_WEAPON_FORMATION_ID), end(EMERALD_WEAPON_FORMATION_ID), formationID) != end(EMERALD_WEAPON_FORMATION_ID))
    {
        this->steamManager->setAchievement(BEAT_EMERALD_WEAPON);
    }

    if (!this->steamManager->isAchieved(BEAT_ULTIMATE_WEAPON) && formationID == ULTIMATE_WEAPON_FORMATION_ID)
    {
        this->steamManager->setAchievement(BEAT_ULTIMATE_WEAPON);
    }
}

void SteamAchievementsFF7::unlockGilAchievement(uint32_t gilAmount)
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for gil (amount: %d)\n", __func__, gilAmount);

    if (!this->steamManager->isAchieved(GET_99999999_GILS) && gilAmount >= GIL_ACHIEVEMENT_VALUE)
        this->steamManager->setAchievement(GET_99999999_GILS);
}

void SteamAchievementsFF7::unlockCharacterLevelAchievement(const savemap_char characters[])
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for character level\n", __func__);

    if (this->steamManager->isAchieved(GET_LEVEL_99_WITH_A_CHAR))
        return;

    for (int i = 0; i < N_CHARACTERS; i++)
    {
        if (characters[i].level == TOP_LEVEL_CHARACTER)
        {
            this->steamManager->setAchievement(GET_LEVEL_99_WITH_A_CHAR);
            return;
        }
    }
}

void SteamAchievementsFF7::unlockBattleSquareAchievement(WORD battleLocationID)
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for fighting in battle square (battle location id: 0x%04x)\n", __func__, battleLocationID);

    if (!this->steamManager->isAchieved(FIGHT_IN_BATTLE_SQUARE) && battleLocationID == BATTLE_SQUARE_LOCATION_ID)
    {
        this->steamManager->setAchievement(FIGHT_IN_BATTLE_SQUARE);
    }
}

void SteamAchievementsFF7::unlockGotMateriaAchievement(byte materiaID)
{
    using namespace std;
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for getting materia (got materia ID: 0x%02x)\n", __func__, materiaID);

    if (find(begin(unmasterableMateriaList), end(unmasterableMateriaList), materiaID) != end(unmasterableMateriaList))
    {
        int nMateriaMastered = accumulate(begin(masteredMateria), end(masteredMateria), 0);
        if (!this->masteredMateria[materiaID])
            this->steamManager->showAchievementProgress(MASTER_ALL_MATERIA, nMateriaMastered + 1 - sizeof(unknownMateriaList),
                                                        N_TYPE_MATERIA - sizeof(unknownMateriaList));
        this->masteredMateria[materiaID] = true;

        if (!this->steamManager->isAchieved(LEVEL_UP_MATERIA_LVL5))
            this->steamManager->setAchievement(LEVEL_UP_MATERIA_LVL5);

        if (!this->steamManager->isAchieved(MASTER_ALL_MATERIA) && this->isAllMateriaMastered(masteredMateria))
            this->steamManager->setAchievement(MASTER_ALL_MATERIA);
    }

    if (materiaID == BAHAMUT_ZERO_MATERIA_ID)
    {
        this->steamManager->setAchievement(GET_MATERIA_BAHAMUT_ZERO);
    }
    else if (materiaID == KOTR_MATERIA_ID)
    {
        this->steamManager->setAchievement(GET_MATERIA_KOTR);
    }
}

void SteamAchievementsFF7::unlockMasterMateriaAchievement(const savemap_char characters[])
{
    using namespace std;
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for mastering materia\n", __func__);

    int nMateriaMastered = accumulate(begin(masteredMateria), end(masteredMateria), 0);
    int nNewMateriaMastered = 0;
    for (int i = 0; i < N_CHARACTERS; i++)
    {
        if (characters[i].id == SEPHIROTH_ID || characters[i].id == YOUNG_CLOUD_ID)
            continue;

        for (int j = 0; j < N_EQUIP_MATERIA_PER_CHARACTER; j++)
        {
            uint32_t materia = characters[i].equipped_materia[j];
            if (this->isMateriaMastered(materia) && !this->equipMasteredMateriaCharacter[i][j])
            {
                if (trace_all || trace_achievement)
                    ffnx_trace("%s - trying to unlock achievement for mastering materia (materia id: 0x%02x)\n", __func__, materia & 0xFF);

                nNewMateriaMastered += (!this->masteredMateria[materia & 0xFF]) ? 1 : 0;
                this->masteredMateria[materia & 0xFF] = true;
                this->equipMasteredMateriaCharacter[i][j] = true;
                if (!this->steamManager->isAchieved(LEVEL_UP_MATERIA_LVL5))
                    this->steamManager->setAchievement(LEVEL_UP_MATERIA_LVL5);
            }
        }
    }
    if (nNewMateriaMastered > 0)
    {
        this->steamManager->showAchievementProgress(MASTER_ALL_MATERIA, nMateriaMastered + nNewMateriaMastered - sizeof(unknownMateriaList),
                                                    N_TYPE_MATERIA - sizeof(unknownMateriaList));
        if (!this->steamManager->isAchieved(MASTER_ALL_MATERIA) && this->isAllMateriaMastered(masteredMateria))
            this->steamManager->setAchievement(MASTER_ALL_MATERIA);
    }
}

void SteamAchievementsFF7::unlockFirstLimitBreakAchievement(short commandID, short actionID)
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for first limit break achievement(command_id: 0x%02x, action_id: 0x%02x)\n", __func__, commandID, actionID);

    if (commandID == LIMIT_COMMAND_INDEX)
    {
        auto item = find(firstLimitBreakActionID.begin(), firstLimitBreakActionID.end(), actionID);
        if (item != firstLimitBreakActionID.end())
        {
            if (!this->steamManager->isAchieved(USE_1ST_LIMIT_CLOUD + distance(firstLimitBreakActionID.cbegin(), item)))
            {
                this->steamManager->setAchievement(USE_1ST_LIMIT_CLOUD + distance(firstLimitBreakActionID.cbegin(), item));
            }
        }
    }
}

void SteamAchievementsFF7::unlockCaitSithLastLimitBreakAchievement(const savemap_char characters[])
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for cait sith last limit break achievement (num_kills: %d)\n", __func__, characters[CAIT_SITH_INDEX].num_kills);

    if (!this->steamManager->isAchieved(GET_FOURTH_CAITSITH_LAST_LIMIT) && this->caitsithNumKills >= 0 && this->caitsithNumKills < 40
        && characters[CAIT_SITH_INDEX].num_kills >= 40)
    {
        this->steamManager->setAchievement(GET_FOURTH_CAITSITH_LAST_LIMIT);
    }
    this->caitsithNumKills = -1;
}

void SteamAchievementsFF7::unlockLastLimitBreakAchievement(WORD usedItemID)
{
    using namespace std;
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock achievement for last limit break achievement (used item: 0x%07x)\n", __func__, usedItemID);

    auto item = find(limitBreakItemsID.begin(), limitBreakItemsID.end(), usedItemID);
    if (item != limitBreakItemsID.end())
    {
        if (!this->steamManager->isAchieved(GET_FOURTH_CLOUD_LAST_LIMIT + distance(limitBreakItemsID.cbegin(), item)))
        {
            this->steamManager->setAchievement(GET_FOURTH_CLOUD_LAST_LIMIT + distance(limitBreakItemsID.cbegin(), item));
        }
    }
}

void SteamAchievementsFF7::unlockGoldChocoboAchievement(const chocobo_slot firstFourSlots[], const chocobo_slot lastTwoSlots[])
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock gold chocobo achievement\n", __func__);

    if (this->steamManager->isAchieved(GET_GOLD_CHOCOBO))
        return;

    for (int i = 0; i < N_GOLD_CHOCOBO_FIRST_SLOTS + N_GOLD_CHOCOBO_LAST_SLOTS; i++)
    {
        const chocobo_slot slot = (i < N_GOLD_CHOCOBO_FIRST_SLOTS) ? firstFourSlots[i] : lastTwoSlots[i - N_GOLD_CHOCOBO_FIRST_SLOTS];
        if (!this->isGoldChocoboSlot[i] && slot.type == GOLD_CHOCOBO_TYPE)
        {
            this->steamManager->setAchievement(GET_GOLD_CHOCOBO);
        }
    }
}

void SteamAchievementsFF7::unlockGameProgressAchievement()
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock game progress achievement (movieName: %s)\n", __func__, this->lastSeenMovieName.c_str());

    if (!(this->steamManager->isAchieved(DEATH_OF_AERITH)) && this->lastSeenMovieName == DEATH_OF_AERITH_MOVIE_NAME)
        this->steamManager->setAchievement(DEATH_OF_AERITH);

    if (!(this->steamManager->isAchieved(SHINRA_ANNIHILATED)) && this->lastSeenMovieName == SHINRA_ANNIHILATED_MOVIE_NAME)
        this->steamManager->setAchievement(SHINRA_ANNIHILATED);

    if (!(this->steamManager->isAchieved(END_OF_GAME)) && this->lastSeenMovieName == END_OF_GAME_MOVIE_NAME)
        this->steamManager->setAchievement(END_OF_GAME);
}

void SteamAchievementsFF7::unlockYuffieAndVincentAchievement(unsigned char yuffieRegMask, unsigned char vincentRegMask)
{
    if (trace_all || trace_achievement)
        ffnx_trace("%s - trying to unlock yuffie and vincent achievement (yuffie_reg: 0x%02x, vincent_reg: 0x%02x)\n",
                   __func__, yuffieRegMask, vincentRegMask);

    if (!this->steamManager->isAchieved(GET_YUFFIE_IN_TEAM) && !this->yuffieUnlocked && this->isYuffieUnlocked(yuffieRegMask))
    {
        this->steamManager->setAchievement(GET_YUFFIE_IN_TEAM);
    }

    if (!this->steamManager->isAchieved(GET_VINCENT_IN_TEAM) && !this->vincentUnlocked && this->isVincentUnlocked(vincentRegMask))
    {
        this->steamManager->setAchievement(GET_VINCENT_IN_TEAM);
    }
}

// -------------------------- STEAM ACHIEVEMENTS OF FF8 ---------------------------

SteamAchievementsFF8::SteamAchievementsFF8()
{
    std::vector<std::string> statsNameVec = { ENEMY_KILLED_STAT_NAME, DRAW_MAGIC_STAT_NAME, STOCK_MAGIC_STAT_NAME, WON_CARDGAME_STAT_NAME };
    this->steamManager = std::make_unique<SteamManager>(SteamAchievementsFF8::ACHIEVEMENTS, FF8_N_ACHIEVEMENTS, statsNameVec);
}

void SteamAchievementsFF8::initOwnedTripleTriadRareCards(const savemap_ff8_triple_triad &tt_data)
{
    ach_trace("%s - init owned triple triad rare cards\n", __func__);

    for (int i = 0; i < this->prevOwnedRareCards.size(); i++) {
        bool owned = tt_data.card_locations[i] == SQUALL_CARD_LOCATION && (tt_data.cards_rare[i / 8] & (1 << i % 8)) > 0;
        this->prevOwnedRareCards[i] = owned;
    }
}

void SteamAchievementsFF8::initPreviousWeaponIdBeforeUpgrade(byte charId, byte weaponId)
{
    ach_trace("%s - init previous weapon id before upgrade (char id: %d, weapon id: %d)\n", __func__, charId, weaponId);
    this->prevWeaponUpgradeData.char_id = charId;
    this->prevWeaponUpgradeData.prev_weapon_id = weaponId;
}

void SteamAchievementsFF8::initStatCharIdUnderStatCompute(byte statCharId) {
    ach_trace("%s - init stat char id before max hp computation (char id: %d)\n", __func__, statCharId);
    this->statCharId = statCharId;
}

byte SteamAchievementsFF8::getStatCharIdUnderStatCompute() {
    return this->statCharId;
}

void SteamAchievementsFF8::unlockPlayTripleTriadAchievement()
{
    ach_trace("%s - trying to unlock play card game first time achievement\n", __func__);

    if (!(this->steamManager->isAchieved(CARDGAME_FIRST_TIME)))
        this->steamManager->setAchievement(CARDGAME_FIRST_TIME);
}

void SteamAchievementsFF8::unlockLoserTripleTriadAchievement(const savemap_ff8_triple_triad &tt_data)
{
    ach_trace("%s - trying to unlock loser card game achievement\n", __func__);

    for (int i = 0; i < this->prevOwnedRareCards.size(); i++) {
        bool owned = tt_data.card_locations[i] == SQUALL_CARD_LOCATION && (tt_data.cards_rare[i / 8] & (1 << i % 8)) > 0;
        if (!owned && this->prevOwnedRareCards[i]) {
            ach_trace("%s - LOSER achievement unlocked due to card id '%d' lost\n", __func__, i);

            if (!(this->steamManager->isAchieved(LOSER)))
                this->steamManager->setAchievement(LOSER);
        }
    }
}

void SteamAchievementsFF8::increaseCardWinsAndUnlockProfessionalAchievement()
{
    this->increaseUserStatAndTryUnlockAchievement(PROFESSIONAL, WON_CARDGAME_STAT_NAME, 100);
}

void SteamAchievementsFF8::unlockCollectorTripleTriadAchievement(const savemap_ff8_triple_triad &tt_data)
{
    ach_trace("%s - trying to unlock collector card game achievement\n", __func__);
    if (this->steamManager->isAchieved(COLLECT_ALL_CARDS)) {
      return;
    }

    int ownedNormalCards = 0;
    for (int i = 0; i < N_CARDS; i++) {
        bool owned = tt_data.cards[i] > 0x80;
        ownedNormalCards += owned;
    }

    int ownedRareCards = 0;
    for (int i = 0; i < N_RARE_CARDS; i++) {
        bool owned = tt_data.card_locations[i] == SQUALL_CARD_LOCATION && (tt_data.cards_rare[i / 8] & (1 << i % 8)) > 0;
        ownedRareCards += owned;
    }

    ach_trace("%s - collector report: normal cards %d/%d, rare cards %d/%d\n", __func__,
              ownedNormalCards, N_CARDS, ownedRareCards, N_RARE_CARDS);

    if (ownedNormalCards + ownedRareCards == N_CARDS + N_RARE_CARDS) {
        this->steamManager->setAchievement(COLLECT_ALL_CARDS);
    }
}

void SteamAchievementsFF8::unlockGuardianForceAchievement(int gf_idx)
{
    if (gf_idx < 0 || gf_idx > 15) {
      ach_trace("%s - invalid guardian force idx (gf id: %d)\n", __func__, gf_idx);
      return;
    }

    ach_trace("%s - trying to unlock guardian force achievement (gf id: %d)\n", __func__, gf_idx);
    if (!(this->steamManager->isAchieved(gfIndexToAchMap[gf_idx])))
        this->steamManager->setAchievement(gfIndexToAchMap[gf_idx]);
}

void SteamAchievementsFF8::unlockTopSeedRankAchievement(WORD seed_exp)
{
    ach_trace("%s - trying to unlock seed rank A achivement (seed exp: %d)\n", __func__, seed_exp);
    if (seed_exp >= MAX_SEED_EXP) {
        if (!(this->steamManager->isAchieved(REACH_SEED_RANK_A)))
            this->steamManager->setAchievement(REACH_SEED_RANK_A);
    }
}

void SteamAchievementsFF8::unlockUpgradeWeaponAchievement(const savemap_ff8 &savemap)
{
    if (this->prevWeaponUpgradeData.char_id == 0xFF || this->prevWeaponUpgradeData.prev_weapon_id == 0xFF) {
        ach_trace("%s - invalid previous weapon id before upgrade (char id: %d, weapon id: %d)\n",
                  __func__, this->prevWeaponUpgradeData.char_id, this->prevWeaponUpgradeData.prev_weapon_id);
    }

    byte weaponId = savemap.chars[this->prevWeaponUpgradeData.char_id].weapon_id;
    ach_trace("%s - trying to unlock handyman achivement (new weapon id: %d, old weapon id: %d)\n",
              __func__, weaponId, this->prevWeaponUpgradeData.prev_weapon_id);
    if (weaponId > this->prevWeaponUpgradeData.prev_weapon_id) {
        if (!(this->steamManager->isAchieved(UPGRADE_WEAPON_FIRST_TIME)))
            this->steamManager->setAchievement(UPGRADE_WEAPON_FIRST_TIME);
    }

    this->prevWeaponUpgradeData.char_id = 0xFF;
    this->prevWeaponUpgradeData.prev_weapon_id = 0xFF;
}

void SteamAchievementsFF8::unlockMaxHpAchievement(int max_hp)
{
    ach_trace("%s - trying to unlock maximum HP achivement (max hp: %d)\n", __func__, max_hp);

    if (max_hp >= MAX_HP)
    {
        if (!(this->steamManager->isAchieved(REACH_MAX_HP)))
            this->steamManager->setAchievement(REACH_MAX_HP);
    }
    this->statCharId = 0xFF;
}

void SteamAchievementsFF8::unlockMaxGilAchievement(uint32_t gil)
{
    ach_trace("%s - trying to unlock maximum gil achivement (gil: %d)\n", __func__, gil);

    if (gil >= MAX_GIL)
    {
        if (!(this->steamManager->isAchieved(REACH_MAX_GIL)))
            this->steamManager->setAchievement(REACH_MAX_GIL);
    }
}

void SteamAchievementsFF8::unlockTopLevelAchievement(int level)
{
    ach_trace("%s - trying to unlock top level achivement (level: %d)\n", __func__, level);

    if (level == MAX_LEVEL)
    {
        if (!(this->steamManager->isAchieved(REACH_LEVEL_100)))
            this->steamManager->setAchievement(REACH_LEVEL_100);
    }
}

void SteamAchievementsFF8::increaseKillsAndTryUnlockAchievement()
{
    if (this->steamManager->isAchieved(TOTAL_KILLS_10000))
    {
        return;
    }

    auto opt_kills = this->steamManager->getUserStat(ENEMY_KILLED_STAT_NAME);
    if (!opt_kills.has_value()) {
        ffnx_error("%s - failed to get %s stat\n", __func__, ENEMY_KILLED_STAT_NAME.c_str());
        return;
    }

    int new_kills = opt_kills.value() + 1;
    ach_trace("%s - trying to unlock kills achivements (kills: %d)\n", __func__, new_kills);
    this->steamManager->updateUserStat(ENEMY_KILLED_STAT_NAME, new_kills);

    if (new_kills >= 100)
    {
        if (!(this->steamManager->isAchieved(TOTAL_KILLS_100)))
            this->steamManager->setAchievement(TOTAL_KILLS_100);
    }
    else if (new_kills % 10 == 0) {
        this->steamManager->showAchievementProgress(TOTAL_KILLS_100, new_kills, 100);
    }

    if (new_kills >= 1000)
    {
        if (!(this->steamManager->isAchieved(TOTAL_KILLS_1000)))
            this->steamManager->setAchievement(TOTAL_KILLS_1000);
    }
    else if (new_kills > 100 && new_kills % 100 == 0) {
        this->steamManager->showAchievementProgress(TOTAL_KILLS_1000, new_kills, 1000);
    }

    if (new_kills >= 10000)
    {
        this->steamManager->setAchievement(TOTAL_KILLS_10000);
    }
}

void SteamAchievementsFF8::increaseMagicStockAndTryUnlockAchievement()
{
    this->increaseUserStatAndTryUnlockAchievement(DRAW_100_MAGIC, STOCK_MAGIC_STAT_NAME, 100, true);
}

void SteamAchievementsFF8::increaseMagicDrawsAndTryUnlockAchievement()
{
    this->increaseUserStatAndTryUnlockAchievement(MAGIC_FINDER, DRAW_MAGIC_STAT_NAME, 100, true);
}

void SteamAchievementsFF8::unlockTimberManiacsAchievement(WORD timber_maniacs_bitmap)
{
    ach_trace("%s - trying to unlock timber maniacs achivement (timber maniacs: 0x%x)\n", __func__, timber_maniacs_bitmap);
    if ((timber_maniacs_bitmap & 0x3FFF) == 0x3FFE || (timber_maniacs_bitmap & 0x3FFF) == 0x3FFD) {
        if (!(this->steamManager->isAchieved(TIMBER_MANIACS)))
            this->steamManager->setAchievement(TIMBER_MANIACS);
    }
}

void SteamAchievementsFF8::unlockFirstSalaryAchievement()
{
    ach_trace("%s - trying to unlock first salary achivement\n", __func__);

    if (!(this->steamManager->isAchieved(SEED_FIRST_SALARY)))
        this->steamManager->setAchievement(SEED_FIRST_SALARY);
}

void SteamAchievementsFF8::unlockQuistisLimitBreaksAchievement(WORD quistis_lb_bitmap)
{
    ach_trace("%s - trying to unlock quistis limit breaks achivement (quistis lb: 0x%x)\n", __func__, quistis_lb_bitmap);

    if (quistis_lb_bitmap == 0xFFFF)
    {
        if (!(this->steamManager->isAchieved(BLUE_MAGICS)))
            this->steamManager->setAchievement(BLUE_MAGICS);
    }
}

void SteamAchievementsFF8::unlockRinoaLimitBreaksAchievement(byte rinoa_completed_lb)
{
    ach_trace("%s - trying to unlock rinoa limit breaks achivement (completed lb: 0x%x)\n", __func__, rinoa_completed_lb);

    if (rinoa_completed_lb == 0xFF)
    {
        if (!(this->steamManager->isAchieved(DOG_TRICKS)))
            this->steamManager->setAchievement(DOG_TRICKS);
    }
}

void SteamAchievementsFF8::unlockOmegaDestroyedAchievement()
{
    ach_trace("%s - trying to unlock omega destroyed achivement\n", __func__);

    if (!(this->steamManager->isAchieved(BEAT_OMEGA_WEAPON)))
        this->steamManager->setAchievement(BEAT_OMEGA_WEAPON);
}

void SteamAchievementsFF8::unlockPupuQuestAchievement(byte pupu_encounter_bitmap)
{
    ach_trace("%s - trying to unlock UFO achivement (pupu encounter var: 0x%x)\n", __func__, pupu_encounter_bitmap);

    if ((pupu_encounter_bitmap & 0xFC) == 0xFC)
    {
        if (!(this->steamManager->isAchieved(UFO)))
            this->steamManager->setAchievement(UFO);
    }
}

void SteamAchievementsFF8::unlockChocoLootAchievement()
{
    ach_trace("%s - trying to unlock choco loot achivement\n", __func__);

    if (!(this->steamManager->isAchieved(CHOCORPG_FIRST_ITEM)))
        this->steamManager->setAchievement(CHOCORPG_FIRST_ITEM);
}

void SteamAchievementsFF8::unlockTopLevelBokoAchievement(byte boko_lvl)
{
    ach_trace("%s - trying to unlock top level boko achivement (boko lvl: %d)\n", __func__, boko_lvl);

    if (boko_lvl >= 100) {
        if (!(this->steamManager->isAchieved(CHICOBO_TOP_LEVEL)))
            this->steamManager->setAchievement(CHICOBO_TOP_LEVEL);
    }
}

void SteamAchievementsFF8::unlockChocoboAchievement()
{
    ach_trace("%s - trying to unlock chocobo achivement\n", __func__);

    if (!(this->steamManager->isAchieved(CAPTURE_CHOCOBO_FIRST_TIME)))
        this->steamManager->setAchievement(CAPTURE_CHOCOBO_FIRST_TIME);
}

void SteamAchievementsFF8::unlockCardClubMasterAchievement(const savemap_ff8_field &savemap_field)
{
    bool cc_king_unlocked = savemap_field.tt_cc_quest_1 & 0b10000;
    ach_trace("%s - trying to unlock card club master achivement (cc king unlocked: %d)\n", __func__, cc_king_unlocked);

    if (cc_king_unlocked) {
        if (!(this->steamManager->isAchieved(CARDS_CLUB_MASTER)))
            this->steamManager->setAchievement(CARDS_CLUB_MASTER);
    }
}

void SteamAchievementsFF8::unlockObelLakeQuestAchievement()
{
    ach_trace("%s - trying to unlock obel lake quest achivement\n", __func__);

    if (!(this->steamManager->isAchieved(OBEL_LAKE_SECRET)))
        this->steamManager->setAchievement(OBEL_LAKE_SECRET);
}

void SteamAchievementsFF8::unlockRagnarokAchievement()
{
    ach_trace("%s - trying to unlock ragnarok achivement\n", __func__);

    if (!(this->steamManager->isAchieved(FOUND_RAGNAROK)))
        this->steamManager->setAchievement(FOUND_RAGNAROK);
}

void SteamAchievementsFF8::unlockEndOfGameAchievement(int squall_lvl)
{
    ach_trace("%s - trying to unlock end of game achivement (squall_lvl: %d)\n", __func__, squall_lvl);

    if (!(this->steamManager->isAchieved(FINISH_THE_GAME)))
        this->steamManager->setAchievement(FINISH_THE_GAME);

    if (squall_lvl == 7) {
        if (!(this->steamManager->isAchieved(FINISH_THE_GAME_INITIAL_LEVEL)))
            this->steamManager->setAchievement(FINISH_THE_GAME_INITIAL_LEVEL);
    }
}

void SteamAchievementsFF8::unlockMagazineAddictAchievement(const savemap_ff8_items &items)
{
    std::unordered_set<uint8_t> magazines_found = {};
    for (int i = 0; i < ITEM_SLOTS; i++) {
        if (itemIsMagazine(items.items[i].item_id) && items.items[i].item_quantity > 0) {
            magazines_found.insert(items.items[i].item_id);
        }
    }
    ach_trace("%s - trying to unlock magazine addict achivement (magazines found: %d)\n", __func__, magazines_found.size());
 
    if (magazines_found.size() >= MAGAZINES_TO_COLLECT) {
        if (!(this->steamManager->isAchieved(MAGAZINES_ADDICT)))
            this->steamManager->setAchievement(MAGAZINES_ADDICT);
    }
}

bool SteamAchievementsFF8::itemIsMagazine(uint8_t item_id) {
    return item_id >= 0xB1 && item_id <= 0xC6;
}

// Private methods
void SteamAchievementsFF8::increaseUserStatAndTryUnlockAchievement(Achievements achId, const std::string &statName, int achValue, bool showAchievementProgress)
{
    if (this->steamManager->isAchieved(achId))
    {
        return;
    }

    auto opt_stat_value = this->steamManager->getUserStat(statName);
    if (!opt_stat_value.has_value()) {
        ffnx_error("%s - failed to get %s stat\n", __func__, statName.c_str());
        return;
    }

    int new_stat_value = opt_stat_value.value() + 1;
    ach_trace("%s - trying to unlock %s achivement (stat value: %d)\n", __func__, this->ACHIEVEMENTS[achId].chAchID, new_stat_value);
    this->steamManager->updateUserStat(statName, new_stat_value);

    if (new_stat_value >= achValue)
    {
        this->steamManager->setAchievement(achId);
    }
    else if (showAchievementProgress && new_stat_value % (achValue / 10) == 0)
    {
        this->steamManager->showAchievementProgress(achId, new_stat_value, achValue);
    }
}
````

## File: src/achievement.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <memory>
#include <optional>
#include <steamworkssdk/steam_api.h>
#include <array>
#include <unordered_map>
#include <vector>
#include <string>
#include <windows.h>

#include "ff7.h"
#include "ff8/save_data.h"

#define _ACH_ID(id)           \
    {                         \
        id, #id, "", "", 0, 0 \
    }

struct achievement
{
    int achID;
    const char *chAchID;
    char achName[128];
    char achDescription[256];
    bool isAchieved;
    int iconImage;
};

class SteamManager
{
private:
    int appID;                                          // Our current AppID
    std::vector<achievement> achievementList;           // Achievements data
    int nAchievements;                                  // The number of Achievements
    bool isInitialized;                                 // Have we called Request stats and received the callback?
    std::unordered_map<std::string, int> stats;         // Steam stats used by the game

public:
    SteamManager(const achievement *achievements, int nAchievements, std::vector<std::string> statsNameVec = {});
    ~SteamManager() = default;

    bool requestStats();
    bool showAchievementProgress(int achID, int progressValue, int maxValue);
    bool setAchievement(int achID);
    bool isAchieved(int achID);
    const char *getStringAchievementID(int achID);
    std::optional<int> getUserStat(const std::string &statName);
    bool updateUserStat(const std::string &statName, int value);

    STEAM_CALLBACK(SteamManager, OnUserStatsReceived, UserStatsReceived_t, callbackUserStatsReceived);
    STEAM_CALLBACK(SteamManager, OnUserStatsStored, UserStatsStored_t, callbackUserStatsStored);
    STEAM_CALLBACK(SteamManager, OnAchievementStored, UserAchievementStored_t, callbackAchievementStored);
};

class SteamAchievementsFF7
{
private:
    enum Achievements
    {
        DEATH_OF_AERITH = 0,
        SHINRA_ANNIHILATED = 1,
        END_OF_GAME = 2,
        GET_99999999_GILS = 3,
        GET_LEVEL_99_WITH_A_CHAR = 4,
        GET_FOURTH_CLOUD_LAST_LIMIT = 5,
        GET_FOURTH_BARRET_LAST_LIMIT = 6,
        GET_FOURTH_TIFA_LAST_LIMIT = 7,
        GET_FOURTH_AERITH_LAST_LIMIT = 8,
        GET_FOURTH_REDXIII_LAST_LIMIT = 9,
        GET_FOURTH_YUFFIE_LAST_LIMIT = 10,
        GET_FOURTH_CAITSITH_LAST_LIMIT = 11,
        GET_FOURTH_VINCENT_LAST_LIMIT = 12,
        GET_FOURTH_CID_LAST_LIMIT = 13,
        GET_MATERIA_KOTR = 14,
        LEVEL_UP_MATERIA_LVL5 = 15,
        GET_MATERIA_BAHAMUT_ZERO = 16,
        BEAT_ULTIMATE_WEAPON = 17,
        BEAT_DIAMOND_WEAPON = 18,
        BEAT_RUBY_WEAPON = 19,
        BEAT_EMERALD_WEAPON = 20,
        GET_VINCENT_IN_TEAM = 21,
        GET_YUFFIE_IN_TEAM = 22,
        MASTER_ALL_MATERIA = 23,
        GET_GOLD_CHOCOBO = 24,
        WON_1ST_BATTLE = 25,
        USE_1ST_LIMIT_CLOUD = 26,
        USE_1ST_LIMIT_BARRET = 27,
        USE_1ST_LIMIT_TIFA = 28,
        USE_1ST_LIMIT_AERITH = 29,
        USE_1ST_LIMIT_REDXIII = 30,
        USE_1ST_LIMIT_YUFFIE = 31,
        USE_1ST_LIMIT_CAITSITH = 32,
        USE_1ST_LIMIT_VINCENT = 33,
        USE_1ST_LIMIT_CID = 34,
        FIGHT_IN_BATTLE_SQUARE = 35
    };

    static inline const achievement ACHIEVEMENTS[] = {
        _ACH_ID(DEATH_OF_AERITH),
        _ACH_ID(SHINRA_ANNIHILATED),
        _ACH_ID(END_OF_GAME),
        _ACH_ID(GET_99999999_GILS),
        _ACH_ID(GET_LEVEL_99_WITH_A_CHAR),
        _ACH_ID(GET_FOURTH_CLOUD_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_BARRET_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_TIFA_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_AERITH_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_REDXIII_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_YUFFIE_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_CAITSITH_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_VINCENT_LAST_LIMIT),
        _ACH_ID(GET_FOURTH_CID_LAST_LIMIT),
        _ACH_ID(GET_MATERIA_KOTR),
        _ACH_ID(LEVEL_UP_MATERIA_LVL5),
        _ACH_ID(GET_MATERIA_BAHAMUT_ZERO),
        _ACH_ID(BEAT_ULTIMATE_WEAPON),
        _ACH_ID(BEAT_DIAMOND_WEAPON),
        _ACH_ID(BEAT_RUBY_WEAPON),
        _ACH_ID(BEAT_EMERALD_WEAPON),
        _ACH_ID(GET_VINCENT_IN_TEAM),
        _ACH_ID(GET_YUFFIE_IN_TEAM),
        _ACH_ID(MASTER_ALL_MATERIA),
        _ACH_ID(GET_GOLD_CHOCOBO),
        _ACH_ID(WON_1ST_BATTLE),
        _ACH_ID(USE_1ST_LIMIT_CLOUD),
        _ACH_ID(USE_1ST_LIMIT_BARRET),
        _ACH_ID(USE_1ST_LIMIT_TIFA),
        _ACH_ID(USE_1ST_LIMIT_AERITH),
        _ACH_ID(USE_1ST_LIMIT_REDXIII),
        _ACH_ID(USE_1ST_LIMIT_YUFFIE),
        _ACH_ID(USE_1ST_LIMIT_CAITSITH),
        _ACH_ID(USE_1ST_LIMIT_VINCENT),
        _ACH_ID(USE_1ST_LIMIT_CID),
        _ACH_ID(FIGHT_IN_BATTLE_SQUARE),
    };

    static inline constexpr int FF7_N_ACHIEVEMENTS = 36;

    static inline constexpr int N_CHARACTERS = 9;
    static inline constexpr int N_TYPE_MATERIA = 91;
    static inline constexpr int N_UNKNOWN_MATERIA = 8;

    static inline constexpr int N_MATERIA_SLOT = 200;
    static inline constexpr int N_STOLEN_MATERIA_SLOT = 48;
    static inline constexpr int N_EQUIP_MATERIA_PER_CHARACTER = 16;
    static inline constexpr int GIL_ACHIEVEMENT_VALUE = 99999999;
    static inline constexpr int TOP_LEVEL_CHARACTER = 99;

    static inline constexpr int YUFFIE_INDEX = 5;
    static inline constexpr int CAIT_SITH_INDEX = 6;
    static inline constexpr int VINCENT_INDEX = 7;
    static inline constexpr byte YOUNG_CLOUD_ID = 0x09;
    static inline constexpr byte SEPHIROTH_ID = 0x0A;

    static inline constexpr byte MATERIA_EMPTY_SLOT = 0xFF;
    static inline constexpr int MATERIA_AP_MASTERED = 0xFFFFFF;
    static inline constexpr byte BAHAMUT_ZERO_MATERIA_ID = 0x58;
    static inline constexpr byte KOTR_MATERIA_ID = 0x59;

    // took from here https://finalfantasy.fandom.com/wiki/Diamond_Weapon_(Final_Fantasy_VII_boss)#Formations
    static inline constexpr WORD DIAMOND_WEAPON_FORMATION_ID = 980;
    static inline constexpr std::array<WORD, 2> RUBY_WEAPON_FORMATION_ID = {982, 983};
    static inline constexpr std::array<WORD, 3> EMERALD_WEAPON_FORMATION_ID = {984, 985, 986};
    static inline constexpr WORD ULTIMATE_WEAPON_FORMATION_ID = 287;
    static inline constexpr WORD BATTLE_SQUARE_LOCATION_ID = 0x0025;

    static inline constexpr byte GOLD_CHOCOBO_TYPE = 0x04;
    static inline constexpr int N_GOLD_CHOCOBO_FIRST_SLOTS = 4;
    static inline constexpr int N_GOLD_CHOCOBO_LAST_SLOTS = 2;

    static inline const std::string DEATH_OF_AERITH_MOVIE_NAME = "funeral";
    static inline const std::string SHINRA_ANNIHILATED_MOVIE_NAME = "hwindjet";
    static inline const std::string END_OF_GAME_MOVIE_NAME = "ending2";
    static inline const std::string INVALID_MOVIE_NAME = "";

    static inline constexpr std::array<byte, N_UNKNOWN_MATERIA> unknownMateriaList = {0x16, 0x26, 0x2D, 0x2E, 0x2F, 0x3F, 0x42, 0x43};
    static inline constexpr std::array<byte, 4> unmasterableMateriaList = {0x11, 0x30, 0x49, 0x5A};

    static inline constexpr byte LIMIT_COMMAND_INDEX = 0x14;
    static inline constexpr std::array<byte, N_CHARACTERS> firstLimitBreakActionID = {0x00, 0x07, 0x62, 0x0E, 0x23, 0x31, 0x2A, 0x2D, 0x1C};
    static inline constexpr std::array<WORD, N_CHARACTERS> limitBreakItemsID = {0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0xFFFF, 0x5D, 0x5E};

    std::unique_ptr<SteamManager> steamManager;

    std::array<WORD, N_CHARACTERS> previousUsedLimitNumber;
    std::array<std::array<bool, N_EQUIP_MATERIA_PER_CHARACTER>, N_CHARACTERS> equipMasteredMateriaCharacter;
    std::array<bool, N_TYPE_MATERIA> masteredMateria;
    std::array<bool, N_GOLD_CHOCOBO_FIRST_SLOTS + N_GOLD_CHOCOBO_LAST_SLOTS> isGoldChocoboSlot;
    bool yuffieUnlocked;
    bool vincentUnlocked;
    int caitsithNumKills;
    std::string lastSeenMovieName;

    bool isYuffieUnlocked(char yuffieRegular);
    bool isVincentUnlocked(char vincentRegular);
    void initMateriaMastered(const savemap &savemap);
    bool isMateriaMastered(uint32_t materia);
    bool isAllMateriaMastered(const std::array<bool, N_TYPE_MATERIA> masteredMateriaList);

public:
    SteamAchievementsFF7();
    ~SteamAchievementsFF7() = default;

    void initStatsFromSaveFile(const savemap &savemap);
    void initCharStatsBeforeBattle(const savemap_char characters[]);
    void initMovieStats(const std::string movieName);

    bool isEndingMovie();

    void unlockBattleWonAchievement(WORD formationID);
    void unlockGilAchievement(uint32_t gilAmount);
    void unlockCharacterLevelAchievement(const savemap_char characters[]);
    void unlockBattleSquareAchievement(WORD battleLocationID);
    void unlockGotMateriaAchievement(byte materiaID);
    void unlockMasterMateriaAchievement(const savemap_char characters[]);
    void unlockFirstLimitBreakAchievement(short characterIndex, short actionIndex);
    void unlockLastLimitBreakAchievement(WORD itemID);
    void unlockCaitSithLastLimitBreakAchievement(const savemap_char characters[]);
    void unlockGoldChocoboAchievement(const chocobo_slot firstFourSlots[], const chocobo_slot lastTwoSlots[]);
    void unlockGameProgressAchievement();
    void unlockYuffieAndVincentAchievement(unsigned char yuffieRegMask, unsigned char vincentRegMask);
};

class SteamAchievementsFF8
{
private:
    enum Achievements
    {
        UNLOCK_GF_QUEZACOTL = 0,
        UNLOCK_GF_SHIVA = 1,
        UNLOCK_GF_IFRIT = 2,
        UNLOCK_GF_SIREN = 3,
        UNLOCK_GF_BROTHERS = 4,
        UNLOCK_GF_DIABLOS = 5,
        UNLOCK_GF_CARBUNCLE = 6,
        UNLOCK_GF_LEVIATHAN = 7,
        UNLOCK_GF_PANDEMONA = 8,
        UNLOCK_GF_CERBERUS = 9,
        UNLOCK_GF_ALEXANDER = 10,
        UNLOCK_GF_DOOMTRAIN = 11,
        UNLOCK_GF_BAHAMUT = 12,
        UNLOCK_GF_CACTUAR = 13,
        UNLOCK_GF_TONBERRY = 14,
        UNLOCK_GF_EDEN = 15,
        DRAW_100_MAGIC = 16,
        REACH_SEED_RANK_A = 17,
        CARDGAME_FIRST_TIME = 18,
        COLLECT_ALL_CARDS = 19,
        UPGRADE_WEAPON_FIRST_TIME = 20,
        REACH_MAX_HP = 21,
        REACH_MAX_GIL = 22,
        REACH_LEVEL_100 = 23,
        FINISH_THE_GAME = 24,
        FINISH_THE_GAME_INITIAL_LEVEL = 25,
        CAPTURE_CHOCOBO_FIRST_TIME = 26,
        FOUND_RAGNAROK = 27,
        SEED_FIRST_SALARY = 28,
        CHOCORPG_FIRST_ITEM = 29,
        BEAT_OMEGA_WEAPON = 30,
        OBEL_LAKE_SECRET = 31,
        UFO = 32,
        CARDS_CLUB_MASTER = 33,
        LOSER = 34,
        PROFESSIONAL = 35,
        TIMBER_MANIACS = 36,
        MAGAZINES_ADDICT = 37,
        MAGIC_FINDER = 38,
        CHICOBO_TOP_LEVEL = 39,
        BLUE_MAGICS = 40,
        DOG_TRICKS = 41,
        TOTAL_KILLS_100 = 42,
        TOTAL_KILLS_1000 = 43,
        TOTAL_KILLS_10000 = 44
    };

    static inline const achievement ACHIEVEMENTS[] = {
        _ACH_ID(UNLOCK_GF_QUEZACOTL),
        _ACH_ID(UNLOCK_GF_SHIVA),
        _ACH_ID(UNLOCK_GF_IFRIT),
        _ACH_ID(UNLOCK_GF_SIREN),
        _ACH_ID(UNLOCK_GF_BROTHERS),
        _ACH_ID(UNLOCK_GF_DIABLOS),
        _ACH_ID(UNLOCK_GF_CARBUNCLE),
        _ACH_ID(UNLOCK_GF_LEVIATHAN),
        _ACH_ID(UNLOCK_GF_PANDEMONA),
        _ACH_ID(UNLOCK_GF_CERBERUS),
        _ACH_ID(UNLOCK_GF_ALEXANDER),
        _ACH_ID(UNLOCK_GF_DOOMTRAIN),
        _ACH_ID(UNLOCK_GF_BAHAMUT),
        _ACH_ID(UNLOCK_GF_CACTUAR),
        _ACH_ID(UNLOCK_GF_TONBERRY),
        _ACH_ID(UNLOCK_GF_EDEN),
        _ACH_ID(DRAW_100_MAGIC),
        _ACH_ID(REACH_SEED_RANK_A),
        _ACH_ID(CARDGAME_FIRST_TIME),
        _ACH_ID(COLLECT_ALL_CARDS),
        _ACH_ID(UPGRADE_WEAPON_FIRST_TIME),
        _ACH_ID(REACH_MAX_HP),
        _ACH_ID(REACH_MAX_GIL),
        _ACH_ID(REACH_LEVEL_100),
        _ACH_ID(FINISH_THE_GAME),
        _ACH_ID(FINISH_THE_GAME_INITIAL_LEVEL),
        _ACH_ID(CAPTURE_CHOCOBO_FIRST_TIME),
        _ACH_ID(FOUND_RAGNAROK),
        _ACH_ID(SEED_FIRST_SALARY),
        _ACH_ID(CHOCORPG_FIRST_ITEM),
        _ACH_ID(BEAT_OMEGA_WEAPON),
        _ACH_ID(OBEL_LAKE_SECRET),
        _ACH_ID(UFO),
        _ACH_ID(CARDS_CLUB_MASTER),
        _ACH_ID(LOSER),
        _ACH_ID(PROFESSIONAL),
        _ACH_ID(TIMBER_MANIACS),
        _ACH_ID(MAGAZINES_ADDICT),
        _ACH_ID(MAGIC_FINDER),
        _ACH_ID(CHICOBO_TOP_LEVEL),
        _ACH_ID(BLUE_MAGICS),
        _ACH_ID(DOG_TRICKS),
        _ACH_ID(TOTAL_KILLS_100),
        _ACH_ID(TOTAL_KILLS_1000),
        _ACH_ID(TOTAL_KILLS_10000),
    };

    struct upgrade_data {
        byte char_id = 0xFF;
        byte prev_weapon_id = 0xFF;
    };

    static inline const Achievements gfIndexToAchMap[16] = {
        UNLOCK_GF_QUEZACOTL,
        UNLOCK_GF_SHIVA,
        UNLOCK_GF_IFRIT,
        UNLOCK_GF_SIREN,
        UNLOCK_GF_BROTHERS,
        UNLOCK_GF_DIABLOS,
        UNLOCK_GF_CARBUNCLE,
        UNLOCK_GF_LEVIATHAN,
        UNLOCK_GF_PANDEMONA,
        UNLOCK_GF_CERBERUS,
        UNLOCK_GF_ALEXANDER,
        UNLOCK_GF_DOOMTRAIN,
        UNLOCK_GF_BAHAMUT,
        UNLOCK_GF_CACTUAR,
        UNLOCK_GF_TONBERRY,
        UNLOCK_GF_EDEN,
    };

    static inline constexpr int FF8_N_ACHIEVEMENTS = 45;

    static inline const std::string ENEMY_KILLED_STAT_NAME = "nmy_kill";
    static inline const std::string DRAW_MAGIC_STAT_NAME = "mag_draw";
    static inline const std::string STOCK_MAGIC_STAT_NAME = "mag_stck";
    static inline const std::string WON_CARDGAME_STAT_NAME = "won_card";

    static inline constexpr int N_CARDS = 77;
    static inline constexpr int N_RARE_CARDS = 33;
    static inline constexpr byte SQUALL_CARD_LOCATION = 0xF0;

    static inline constexpr WORD MAX_SEED_EXP = 3100;
    static inline constexpr int MAX_HP = 9999;
    static inline constexpr uint32_t MAX_GIL = 99999999;
    static inline constexpr int MAX_LEVEL = 100;
    static inline constexpr int ITEM_SLOTS = 198;
    static inline constexpr int MAGAZINES_TO_COLLECT = 22;

    std::unique_ptr<SteamManager> steamManager;
    std::array<bool, N_RARE_CARDS> prevOwnedRareCards;
    upgrade_data prevWeaponUpgradeData;
    byte statCharId = 0xFF;

    void increaseUserStatAndTryUnlockAchievement(Achievements achId, const std::string &statName, int achValue, bool showAchievementProgress = false);

public:
    static inline constexpr byte DIABLOS_GF_IDX = 5;
    static inline constexpr WORD DIABLOS_ENCOUNTER_ID = 811;

    SteamAchievementsFF8();
    ~SteamAchievementsFF8() = default;

    void initOwnedTripleTriadRareCards(const savemap_ff8_triple_triad &triple_triad);
    void initPreviousWeaponIdBeforeUpgrade(byte charId, byte weaponId);
    void initStatCharIdUnderStatCompute(byte statCharId);

    byte getStatCharIdUnderStatCompute();

    void unlockPlayTripleTriadAchievement();
    void unlockLoserTripleTriadAchievement(const savemap_ff8_triple_triad &triple_triad);
    void unlockCollectorTripleTriadAchievement(const savemap_ff8_triple_triad &triple_triad);
    void increaseCardWinsAndUnlockProfessionalAchievement();
    void unlockGuardianForceAchievement(int gf_idx);
    void unlockTopSeedRankAchievement(WORD seed_exp);
    void unlockUpgradeWeaponAchievement(const savemap_ff8 &savemap);
    void unlockMaxHpAchievement(int max_hp);
    void unlockMaxGilAchievement(uint32_t gil);
    void unlockTopLevelAchievement(int level);
    void increaseKillsAndTryUnlockAchievement();
    void increaseMagicStockAndTryUnlockAchievement();
    void increaseMagicDrawsAndTryUnlockAchievement();
    void unlockTimberManiacsAchievement(WORD timber_maniacs_bitmap);
    void unlockFirstSalaryAchievement();
    void unlockQuistisLimitBreaksAchievement(WORD quistis_lb_bitmap);
    void unlockOmegaDestroyedAchievement();
    void unlockPupuQuestAchievement(byte pupu_encounter_bitmap);
    void unlockChocoLootAchievement();
    void unlockTopLevelBokoAchievement(byte boko_lvl);
    void unlockRinoaLimitBreaksAchievement(byte rinoa_completed_lb);
    void unlockCardClubMasterAchievement(const savemap_ff8_field &savemap_field);
    void unlockChocoboAchievement();
    void unlockObelLakeQuestAchievement();
    void unlockRagnarokAchievement();
    void unlockEndOfGameAchievement(int squall_lvl);
    void unlockMagazineAddictAchievement(const savemap_ff8_items &items);

    static bool itemIsMagazine(uint8_t item_id);

};

// Global, access to Achievements object
extern std::unique_ptr<SteamAchievementsFF7> g_FF7SteamAchievements;
extern std::unique_ptr<SteamAchievementsFF8> g_FF8SteamAchievements;
````

## File: src/api.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "api.h"

FFNX_API void __stdcall nxRegisterMouseListener(MouseListener* listener)
{
    mouseListeners.push_back(listener);
}

FFNX_API void __stdcall nxRegisterKeyListener(KeyListener* listener)
{
    keyListeners.push_back(listener);
}
````

## File: src/api.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "globals.h"
#include "input.h"

FFNX_API void __stdcall nxRegisterMouseListener(MouseListener* listener);
FFNX_API void __stdcall nxRegisterKeyListener(KeyListener* listener);
````

## File: src/audio.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "audio/openpsf/openpsf.h"

#include "audio.h"

#include "log.h"
#include "gamehacks.h"
#include "utils.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include <libvgmstream/util/log.h>

#if defined(__cplusplus)
}
#endif

NxAudioEngine nxAudioEngine;

// PRIVATE

void NxAudioEngine::loadConfig()
{
	char _fullpath[MAX_PATH];

	for (int idx = NxAudioEngineLayer::NXAUDIOENGINE_SFX; idx <= NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT; idx++)
	{
		NxAudioEngineLayer type = NxAudioEngineLayer(idx);

		switch (type)
		{
		case NxAudioEngineLayer::NXAUDIOENGINE_SFX:
			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_sfx_path.c_str());
			if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_MUSIC:
			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_music_path.c_str());
			if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_VOICE:
			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_voice_path.c_str());
			if (trace_all || trace_voice) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT:
			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_ambient_path.c_str());
			if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
			break;
		}

		try
		{
			nxAudioEngineConfig[type] = toml::parse_file(_fullpath);
		}
		catch (const toml::parse_error &err)
		{
			ffnx_warning("Parse error while opening the file %s. Will continue with the default settings.\n", _fullpath);
			ffnx_warning("%s (Line %u Column %u)\n", err.what(), err.source().begin.line, err.source().begin.column);

			nxAudioEngineConfig[type] = toml::parse("");
		}
	}
}

bool NxAudioEngine::getFilenameFullPath(char *_out, const char* _key, NxAudioEngineLayer _type)
{
	std::vector<std::string> extensions;

	switch(_type)
	{
		case NxAudioEngineLayer::NXAUDIOENGINE_SFX:
			extensions = external_sfx_ext;
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_MUSIC:
			extensions = external_music_ext;
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_VOICE:
			extensions = external_voice_ext;
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT:
			extensions = external_ambient_ext;
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO:
			extensions = external_movie_audio_ext;
			break;
	}

	for (const std::string &extension: extensions) {
		switch (_type)
		{
		case NxAudioEngineLayer::NXAUDIOENGINE_SFX:
			sprintf(_out, "%s/%s/%s.%s", basedir, external_sfx_path.c_str(), _key, extension.c_str());
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_MUSIC:
			sprintf(_out, "%s/%s/%s.%s", basedir, external_music_path.c_str(), _key, extension.c_str());
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_VOICE:
			sprintf(_out, "%s/%s/%s.%s", basedir, external_voice_path.c_str(), _key, extension.c_str());
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT:
			sprintf(_out, "%s/%s/%s.%s", basedir, external_ambient_path.c_str(), _key, extension.c_str());
			break;
		case NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO:
			sprintf(_out, "%s.%s", _key, extension.c_str());
			break;
		}

		if (fileExists(_out)) {
			return true;
		}
	}

	return false;
}

bool NxAudioEngine::fileExists(const char* filename)
{
	bool ret = ::fileExists(filename);

	if (!ret && (trace_all || trace_music || trace_sfx || trace_voice || trace_ambient))
		ffnx_warning("NxAudioEngine::%s: Could not find file %s\n", __func__, filename);

	return ret;
}

// PUBLIC

bool NxAudioEngine::init()
{
	if (_engine.init(SoLoud::Soloud::CLIP_ROUNDOFF, SoLoud::Soloud::AUTO, external_audio_sample_rate, SoLoud::Soloud::AUTO, external_audio_number_of_channels) == 0)
	{
		_engineInitialized = true;

		ffnx_info("NxAudioEngine initialized: channels=%u,sample_rate=%u\n", _engine.getBackendChannels(), _engine.getBackendSamplerate());

		// 100 -> LOG_LEVEL_ALL: https://github.com/vgmstream/vgmstream/blob/4cda04d02595b381dc8cf98ec39e771c80987d18/src/util/log.c#L20
		if (trace_all || trace_ambient || trace_sfx || trace_music || trace_voice) vgm_log_set_callback(NULL, 100, 0, NxAudioEngineVgmstreamCallback);

		loadConfig();

		if (!he_bios_path.empty()) {
			char fullHeBiosPath[MAX_PATH];
			sprintf(fullHeBiosPath, "%s/%s", basedir, he_bios_path.c_str());

			if (!Psf::initialize_psx_core(fullHeBiosPath)) {
				ffnx_error("NxAudioEngine::%s couldn't load %s, please verify 'he_bios_path' or comment it\n", __func__, he_bios_path.c_str());
			}
			else {
				_openpsf_loaded = true;
				ffnx_info("NxAudioEngine::%s OpenPSF music plugin loaded using %s\n", __func__, he_bios_path.c_str());
			}
		}

		for (int channel = 0; channel < _sfxTotalChannels; channel++) _sfxChannels[channel] = NxAudioEngineSFX();

		return true;
	}

	return false;
}

void NxAudioEngine::flush()
{
	_engine.stopAll();

	for (int channel = 0; channel < 2; channel++)
	{
		_musics[channel] = NxAudioEngineMusic();
	}
	_musicStack = std::stack<NxAudioEngineMusic>();

	for (int channel = 0; channel < _sfxTotalChannels; channel++)
	{
		_sfxChannels[channel] = NxAudioEngineSFX();
	}

	for (int slot = 0; slot < _voiceMaxSlots; slot++)
	{
		_currentVoice[slot] = NxAudioEngineVoice();
	}

	_currentAmbient = NxAudioEngineAmbient();

	for (int slot = 0; slot < _movieAudioMaxSlots; slot++)
	{
		_currentMovieAudio[slot] = NxAudioEngineMovieAudio();
	}

	_currentStream = NxAudioEngineStreamAudio();
}

void NxAudioEngine::cleanup()
{
	_engine.deinit();
}

// SFX
SoLoud::VGMStream* NxAudioEngine::loadSFX(std::string id, bool loop)
{
	if (_engineInitialized)
	{
		char filename[MAX_PATH];

		bool exists = getFilenameFullPath(filename, id.c_str(), NxAudioEngineLayer::NXAUDIOENGINE_SFX);

		if (exists)
		{
			auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_SFX][id];

			if (node)
			{
				int shouldLoop = node["loop"].value_or(-1);

				// Force loop if requested in the config
				if (shouldLoop != -1) loop = shouldLoop;
			}

			if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: filename=%s,loop=%d\n", __func__, filename, loop);

			SoLoud::VGMStream* sfx = new SoLoud::VGMStream();

			sfx->setLooping(loop);

			SoLoud::result res = sfx->load(filename);
			if (res != SoLoud::SO_NO_ERROR) {
				ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
				delete sfx;
				return nullptr;
			}

			return sfx;
		}
	}

	return nullptr;
}

int NxAudioEngine::getSFXIdFromChannel(int channel)
{
	return _sfxChannels[channel].game_id;
}

void NxAudioEngine::unloadSFX(int id)
{
	if (_sfxEffectsHandler.count(id) > 0)
	{
		if (_sfxEffectsHandler[id] != nullptr)
		{
			delete _sfxEffectsHandler[id];

			_sfxEffectsHandler.erase(id);
		}
	}
}

void NxAudioEngine::unloadSFXChannel(int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: channel=%d\n", __func__, channel);

	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	if (options->stream != nullptr)
	{
		delete options->stream;

		options->stream = nullptr;
	}
}

bool NxAudioEngine::playSFX(const char* name, int id, int channel, float panning, bool loop, float volume)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
	int _curId = id;
	bool skipPlay = false;
	std::string _id(name);

	// If channel is known to be reusable
	if (channel <= _sfxReusableChannels)
	{
		// Stop the current channel is already used and the track to be played is different that the one currently playing
		if (options->stream != nullptr && options->id != id)
		{
			stopSFX(channel);
			unloadSFXChannel(channel);
		}
		// If the engine is asking us to play again the same id on the same channel, and is a looping effect...
		else if (options->stream != nullptr && options->id == id && loop)
		{
			// ...simply skip it since it's already playing
			skipPlay = true;
		}
	}
	// If channel is known to lazy unload what is currently playing, save the handler for later
	else if (std::find(_sfxLazyUnloadChannels.begin(), _sfxLazyUnloadChannels.end(), channel) != _sfxLazyUnloadChannels.end())
	{
		_sfxEffectsHandler[options->game_id] = options->stream;

		// invalidate the old channel stream in order to continue loading this new ID
		options->stream = nullptr;
	}
	// Otherwise just unload the channel and allow to load a new track immediately
	else if (channel <= _sfxTotalChannels)
	{
		unloadSFXChannel(channel);
	}

	// Reset state
	options->volume = volume;

	auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_SFX][name];
	if (node)
	{
		// Shuffle SFX playback, if any entry found for the current id
		toml::array *shuffleIds = node["shuffle"].as_array();
		if (shuffleIds && !shuffleIds->empty() && shuffleIds->is_homogeneous(toml::node_type::integer))
		{
			auto _newId = shuffleIds->get(getRandomInt(0, shuffleIds->size() - 1));

			_curId = _newId->value_or(id);
			_id = std::to_string(_curId);
		}

		// Sequentially playback new SFX ids, if any entry found for the current id
		toml::array *sequentialIds = node["sequential"].as_array();
		if (sequentialIds && !sequentialIds->empty() && sequentialIds->is_homogeneous(toml::node_type::integer))
		{
			if (_sfxSequentialIndexes.find(name) == _sfxSequentialIndexes.end() || _sfxSequentialIndexes[name] >= sequentialIds->size())
				_sfxSequentialIndexes[name] = 0;

			auto _newId = sequentialIds->get(_sfxSequentialIndexes[name]);

			_sfxSequentialIndexes[name]++;

			_curId = _newId->value_or(id);
			_id = std::to_string(_curId);
		}

		// Should we skip playing the track?
		toml::node *shouldSkip = node["skip"].as_boolean();
		if (shouldSkip && shouldSkip->is_boolean()) {
			skipPlay = shouldSkip->value_or(false);
		}
	}

	// Try to load the new ID if it's not already cached
	if (options->stream == nullptr)
	{
		options->game_id = id;
		options->id = _curId;
		// Avoid loading a stream if it is meant to be skipped
		options->stream = skipPlay ? nullptr : loadSFX(_id, loop);
	}

	if (skipPlay)
	{
		// Make the game think everything went fine but instead just be silent
		return true;
	}

	if (external_sfx_always_centered)
	{
		panning = 0.0f;

		if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: panning overridden because of external_sfx_always_centered\n", __func__);
	}

	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: name=%s,id=%d,channel=%d,panning=%f,volume=%f\n", __func__, name, options->id, channel, panning, options->volume);

	if (options->stream != nullptr)
	{
		options->handle = _engine.play(
			*options->stream,
			options->volume * getSFXMasterVolume(),
			panning
		);

		options->loop = _engine.getLooping(options->handle);

		return true;
	}

	return false;
}

void NxAudioEngine::stopSFX(int channel, double time)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s channel=%d\n", __func__, channel);

	if (time > 0.0)
	{
		_engine.fadeVolume(options->handle, 0.0f, time);
		_engine.scheduleStop(options->handle, time);
	}
	else
	{
		_engine.stop(options->handle);
	}

	options->id = 0;
	options->loop = false;
	options->volume = 1.0f;
}

void NxAudioEngine::pauseSFX(int channel)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s channel=%d\n", __func__, channel);

	_engine.setPause(options->handle, true);
}

void NxAudioEngine::resumeSFX(int channel)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s channel=%d\n", __func__, channel);

	_engine.setPause(options->handle, false);
}

bool NxAudioEngine::isSFXPlaying(int channel)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	return _engine.isValidVoiceHandle(options->handle) && !_engine.getPause(options->handle);
}

float NxAudioEngine::getSFXMasterVolume()
{
	return _sfxMasterVolume < 0.0f ? 1.0f : _sfxMasterVolume;
}

void NxAudioEngine::setSFXMasterVolume(float volume, double time)
{
	_sfxMasterVolume = volume;
}

void NxAudioEngine::setSFXVolume(int channel, float volume, double time)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	options->volume = volume;

	ffnx_trace("NxAudioEngine::%s: channel=%d,volume=%f\n", __func__, channel, volume);

	if (time > 0.0) {
		time /= gamehacks.getCurrentSpeedhack();
		_engine.fadeVolume(options->handle, volume * getSFXMasterVolume(), time);
	}
	else {
		_engine.setVolume(options->handle, volume * getSFXMasterVolume());
	}
}

void NxAudioEngine::setSFXSpeed(int channel, float speed, double time)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	if (time > 0.0) {
		time /= gamehacks.getCurrentSpeedhack();
		_engine.fadeRelativePlaySpeed(options->handle, speed, time);
	}
	else {
		_engine.setRelativePlaySpeed(options->handle, speed);
	}
}

void NxAudioEngine::setSFXPanning(int channel, float panning, double time)
{
	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];

	if (external_sfx_always_centered)
	{
		panning = 0.0f;

		if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: panning overridden because of external_sfx_always_centered\n", __func__);
	}

	if (time > 0.0) {
		time /= gamehacks.getCurrentSpeedhack();
		_engine.fadePan(options->handle, panning, time);
	}
	else {
		_engine.setPan(options->handle, panning);
	}
}

void NxAudioEngine::setSFXReusableChannels(short num)
{
	_sfxReusableChannels = num;
}

void NxAudioEngine::setSFXTotalChannels(short num)
{
	_sfxTotalChannels = num;
}

void NxAudioEngine::addSFXLazyUnloadChannel(int channel)
{
	_sfxLazyUnloadChannels.push_back(channel);
}

// Music
bool NxAudioEngine::canPlayMusic(const char* name)
{
	char filename[MAX_PATH];

	return getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_MUSIC);
}

bool NxAudioEngine::isMusicDisabled(const char* name)
{
	char lowercaseName[MAX_PATH];

	// Name to lower case
	for (int i = 0; name[i]; i++) {
		lowercaseName[i] = tolower(name[i]);
	}

	toml::table config = nxAudioEngineConfig[NXAUDIOENGINE_MUSIC];
	std::optional<bool> disabled = config[lowercaseName]["disabled"].value<bool>();

	return disabled.has_value() && disabled;
}

void NxAudioEngine::cleanOldAudioSources()
{
	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %d elements in the list before cleaning\n", __func__, _audioSourcesToDeleteLater.size());

	std::list<NxAudioEngineMusicAudioSource>::iterator it = _audioSourcesToDeleteLater.begin();
	while (it != _audioSourcesToDeleteLater.end()) {
		if (!_engine.isValidVoiceHandle((*it).handle) && !_engine.isVoiceGroup((*it).handle)) {
			delete (*it).audioSource;
			it = _audioSourcesToDeleteLater.erase(it);
		}
		else {
			++it;
		}
	}

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %d elements in the list after cleaning\n", __func__, _audioSourcesToDeleteLater.size());
}

SoLoud::AudioSource* NxAudioEngine::loadMusic(const char* name, bool isFullPath, const char* format, bool suppressOpeningSilence)
{
	SoLoud::AudioSource* music = nullptr;
	char filename[MAX_PATH];
	bool exists = false;

	if (isFullPath)
	{
		exists = fileExists(name);
		strcpy(filename, name);
	}

	if (!exists)
	{
		exists = getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_MUSIC);
	}

	if (exists)
	{
		if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, filename);

		cleanOldAudioSources();

		if (_openpsf_loaded && SoLoud::OpenPsf::is_our_path(filename)) {
			SoLoud::OpenPsf* openpsf = new SoLoud::OpenPsf();
			music = openpsf;

			SoLoud::result res = openpsf->load(filename, suppressOpeningSilence);
			if (res != SoLoud::SO_NO_ERROR) {
				ffnx_error("NxAudioEngine::%s: Cannot load %s with openpsf ( SoLoud error: %u )\n", __func__, filename, res);
				delete openpsf;
				music = nullptr;
			}
		}

		if (music == nullptr) {
			SoLoud::VGMStream* vgmstream = new SoLoud::VGMStream();
			music = vgmstream;

			SoLoud::result res = vgmstream->load(filename, format);
			if (res != SoLoud::SO_NO_ERROR) {
				ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
				delete vgmstream;
				music = nullptr;
			}
		}
	}

	return music;
}

void NxAudioEngine::overloadPlayArgumentsFromConfig(char* name, uint32_t* id, MusicOptions* musicOptions)
{
	// Name to lower case
	for (int i = 0; name[i]; i++) {
		name[i] = tolower(name[i]);
	}

	toml::table config = nxAudioEngineConfig[NXAUDIOENGINE_MUSIC];
	std::optional<SoLoud::time> offset_seconds_opt = config[name]["offset_seconds"].value<SoLoud::time>();
	std::optional<std::string> no_intro_track_opt = config[name]["no_intro_track"].value<std::string>();
	std::optional<SoLoud::time> intro_seconds_opt = config[name]["intro_seconds"].value<SoLoud::time>();
	std::optional<float> relative_speed_opt = config[name]["relative_speed"].value<float>();

	if (offset_seconds_opt.has_value()) {
		musicOptions->offsetSeconds = *offset_seconds_opt;
	} else {
		std::optional<std::string> offset_special_opt = config[name]["offset_seconds"].value<std::string>();

		if (offset_special_opt.has_value() && offset_special_opt->compare("sync") == 0) {
			musicOptions->sync = true;
		}
	}

	if (musicOptions->noIntro) {
		if (no_intro_track_opt.has_value()) {
			std::string no_intro_track = *no_intro_track_opt;
			if (trace_all || trace_music) ffnx_info("%s: replaced by no intro track %s\n", __func__, no_intro_track.c_str());

			if (!no_intro_track.empty()) {
				memcpy(name, no_intro_track.c_str(), no_intro_track.size());
				name[no_intro_track.size()] = '\0';
			}
		}
		else if (intro_seconds_opt.has_value()) {
			musicOptions->offsetSeconds = *intro_seconds_opt;
		}
		else {
			ffnx_info("%s: cannot play no intro track, please configure it in %s/config.toml\n", __func__, external_music_path.c_str());
		}
	}

	if (relative_speed_opt.has_value() && *relative_speed_opt > 0.0f) {
		musicOptions->relativeSpeed = *relative_speed_opt;
	}

	// Shuffle Music playback, if any entry found for the current music name
	toml::array* shuffleNames = config[name]["shuffle"].as_array();
	if (shuffleNames && !shuffleNames->empty() && shuffleNames->is_homogeneous(toml::node_type::string)) {
		std::optional<std::string> _newName = shuffleNames->get(getRandomInt(0, shuffleNames->size() - 1))->value<std::string>();
		if (_newName.has_value()) {
			memcpy(name, (*_newName).c_str(), (*_newName).size());
			name[(*_newName).size()] = '\0';

			if (trace_all || trace_music) ffnx_info("%s: replaced by shuffle with %s\n", __func__, (*_newName).c_str());
		}
	}
}

bool NxAudioEngine::playMusic(const char* name, uint32_t id, int channel, MusicOptions options)
{
	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s (%d) on channel #%d\n", __func__, name, id, channel);

	char overloadedName[MAX_PATH];

	strncpy(overloadedName, name, MAX_PATH);

	if (!options.useNameAsFullPath) {
		overloadPlayArgumentsFromConfig(overloadedName, &id, &options);
	}
	// Same music is already playing on this channel
	if (isMusicPlaying(channel) && currentMusicId(channel) == id) {
		if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s is already playing on channel %d\n", __func__, overloadedName, channel);

		return false;
	}
	// Same music is paused on this channel or in backup channel
	bool restore = !_musicStack.empty() && _musicStack.top().id == id;
	if ((isChannelValid(channel) && currentMusicId(channel) == id) || restore) {
		resumeMusic(channel, options.fadetime == 0.0 ? 1.0 : options.fadetime, restore); // Slight fade

		return true;
	}

	SoLoud::AudioSource* audioSource = loadMusic(overloadedName, options.useNameAsFullPath, options.format, options.suppressOpeningSilence);

	if (audioSource != nullptr) {
		// Different music is playing on this channel
		if (isChannelValid(channel)) {
			stopMusic(channel, options.fadetime == 0.0 ? 0.2 : options.fadetime);
		}

		NxAudioEngineMusic& music = _musics[channel];
		SoLoud::time offsetSeconds = options.sync ? _musics[!channel].lastMusicOffset : options.offsetSeconds;

		if (options.targetVolume >= 0.0f) {
			music.wantedMusicVolume = options.targetVolume;
		}
		const float initialVolume = options.fadetime > 0.0 || offsetSeconds > 0.0 ? 0.0f : music.wantedMusicVolume * _musicMasterVolume;
		music.handle = _engine.playBackground(*audioSource, initialVolume, offsetSeconds > 0.0);
		music.id = id;
		music.sync = options.sync;

		// Keep audioSource pointer somewhere to delete it after musicHandle is stopped
		_audioSourcesToDeleteLater.push_back(NxAudioEngineMusicAudioSource(music.handle, audioSource));

		if (offsetSeconds > 0.0) {
			if (trace_all || trace_music) ffnx_info("NxAudioEngine::%s: seek to time %fs\n", __func__, offsetSeconds);
			_engine.seek(music.handle, offsetSeconds);
			resumeMusic(channel, options.fadetime == 0.0 ? 1.0 : options.fadetime); // Slight fade
		}
		else if (options.fadetime > 0.0) {
			setMusicVolume(music.wantedMusicVolume, channel, options.fadetime);
		}

		if (options.relativeSpeed > 0.0f && options.relativeSpeed != 1.0f) {
			setMusicSpeed(options.relativeSpeed, channel);
		}

		return true;
	}

	return false;
}

void NxAudioEngine::playSynchronizedMusics(const std::vector<std::string>& names, uint32_t id, MusicOptions options)
{
	const int channel = 0;

	if (_musics[channel].id == id) {
		if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: id %d is already playing\n", __func__, id);
		return; // Already playing
	}

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: id %d\n", __func__, id);

	stopMusic(options.fadetime);

	SoLoud::handle groupHandle = _engine.createVoiceGroup();

	if (groupHandle == 0) {
		ffnx_error("NxAudioEngine::%s: cannot allocate voice group\n", __func__);
		return;
	}

	for (const std::string &name: names) {
		SoLoud::AudioSource* audioSource = loadMusic(name.c_str());

		if (audioSource != nullptr) {
			SoLoud::handle musicHandle = _engine.playBackground(*audioSource, _musicMasterVolume, true);
			_engine.addVoiceToGroup(groupHandle, musicHandle);
			// Keep audioSource pointer somewhere to delete it after musicHandle is stopped
			_audioSourcesToDeleteLater.push_back(NxAudioEngineMusicAudioSource(musicHandle, audioSource));
		}
	}

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: handle=%X\n", __func__, groupHandle);

	if (!_engine.isVoiceGroupEmpty(groupHandle)) {
		_musics[channel].handle = groupHandle;
		_musics[channel].id = id;
		// Play synchronously
		_engine.setPause(groupHandle, false);
	}
	else {
		_engine.destroyVoiceGroup(groupHandle);
	}
}

void NxAudioEngine::swapChannels()
{
	NxAudioEngineMusic music1 = _musics[0];
	_musics[0] = _musics[1];
	_musics[1] = music1;
}

void NxAudioEngine::stopMusic(double time)
{
	for (int channel = 0; channel < 2; ++channel) {
		stopMusic(channel, time);
	}
}

void NxAudioEngine::stopMusic(int channel, double time)
{
	NxAudioEngineMusic& music = _musics[channel];

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: channel %d, midi %d, time %f\n", __func__, channel, music.id, time);

	if (external_music_sync) {
		music.lastMusicOffset = _engine.getStreamTime(_musics[channel].handle);
	}

	if (time > 0.0)
	{
		time /= gamehacks.getCurrentSpeedhack();
		_engine.fadeVolume(music.handle, 0.0f, time);
		_engine.scheduleStop(music.handle, time);
		_lastVolumeFadeEndTime = _engine.mStreamTime + time;
	}
	else
	{
		_engine.stop(music.handle);
	}

	if (_engine.isVoiceGroup(music.handle)) {
		_engine.destroyVoiceGroup(music.handle);
	}

	music.invalidate();
}

void NxAudioEngine::pauseMusic(double time)
{
	for (int channel = 0; channel < 2; ++channel) {
		pauseMusic(channel, time);
	}
}

void NxAudioEngine::pauseMusic(int channel, double time, bool backup)
{
	NxAudioEngineMusic& music = _musics[channel];
	bool syncMusic = external_music_sync && backup && music.sync;

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: midi %d, time %f, sync %d\n", __func__, music.id, time, syncMusic);

	if (external_music_sync) {
		music.lastMusicOffset = _engine.getStreamTime(_musics[channel].handle);
	}

	if (time > 0.0)
	{
		time /= gamehacks.getCurrentSpeedhack();
		_engine.fadeVolume(music.handle, 0.0f, time);
		if (!syncMusic) {
			_engine.schedulePause(music.handle, time);
		}
		_lastVolumeFadeEndTime = _engine.mStreamTime + time;
	}
	else if (syncMusic)
	{
		_engine.setVolume(music.handle, 0.0f);
	}
	else
	{
		_engine.setPause(music.handle, true);
	}

	if (backup) {
		backupMusic(channel);
	}
}

void NxAudioEngine::backupMusic(int channelSource)
{
	if (!isChannelValid(channelSource)) {
		return;
	}

	NxAudioEngineMusic& music = _musics[channelSource];

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: backup music %d for later usage\n", __func__, music.id);

	NxAudioEngineMusic backup = NxAudioEngineMusic();
	// Save for later usage
	backup.id = music.id;
	backup.handle = music.handle;
	backup.sync = music.sync;

	_musicStack.push(backup);

	// Invalidate the current handle
	music.invalidate();
}

void NxAudioEngine::restoreMusic(int channelDest, double stopTime)
{
	NxAudioEngineMusic& music = _musics[channelDest];

	if (_musicStack.empty()) {
		return;
	}

	stopMusic(channelDest, stopTime);

	const NxAudioEngineMusic &backup = _musicStack.top();

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: restore music %d\n", __func__, backup.id);

	// Restore
	music.id = backup.id;
	music.handle = backup.handle;
	music.sync = backup.sync;

	_musicStack.pop();
}

void NxAudioEngine::resumeMusic(double time)
{
	for (int channel = 0; channel < 2; ++channel) {
		resumeMusic(channel, time);
	}
}

void NxAudioEngine::resumeMusic(int channel, double time, bool restore)
{
	if (restore) {
		restoreMusic(channel, time);
	}

	NxAudioEngineMusic& music = _musics[channel];

	time /= gamehacks.getCurrentSpeedhack();

	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: midi %d, time %f\n", __func__, music.id, time);

	// Play it again from where it was left off
	if (time > 0.0) {
		_engine.setVolume(music.handle, 0.0);
	}
	resetMusicVolume(channel, time);
	_engine.setPause(music.handle, false);
}

bool NxAudioEngine::isChannelValid(int channel)
{
	const NxAudioEngineMusic& music = _musics[channel];

	return (_engine.isValidVoiceHandle(music.handle)
		|| _engine.isVoiceGroup(music.handle));
}

bool NxAudioEngine::isMusicPlaying()
{
	for (int channel = 0; channel < 2; ++channel) {
		if (isMusicPlaying(channel)) return true;
	}

	return false;
}

bool NxAudioEngine::isMusicPlaying(int channel)
{
	const NxAudioEngineMusic& music = _musics[channel];

	return isChannelValid(channel) && !_engine.getPause(music.handle);
}

uint32_t NxAudioEngine::currentMusicId(int channel)
{
	return isMusicPlaying(channel) ? _musics[channel].id : 0;
}

void NxAudioEngine::setMusicMasterVolume(float volume, double time)
{
	_previousMusicMasterVolume = _musicMasterVolume;

	_musicMasterVolume = volume;

	resetMusicVolume(time);
}

void NxAudioEngine::restoreMusicMasterVolume(double time)
{
	if (_previousMusicMasterVolume != _musicMasterVolume && _previousMusicMasterVolume >= 0.0f)
	{
		_musicMasterVolume = _previousMusicMasterVolume;

		// Set them equally so if this API is called again, nothing will happen
		_previousMusicMasterVolume = _musicMasterVolume;

		resetMusicVolume(time);
	}
}

float NxAudioEngine::getMusicVolume(int channel)
{
	return _musics[channel].wantedMusicVolume;
}

bool NxAudioEngine::isMusicVolumeFadeFinished()
{
	return _engine.mStreamTime >= _lastVolumeFadeEndTime;
}

float NxAudioEngine::getMusicMasterVolume()
{
	return _musicMasterVolume < 0.0f ? 1.0f : _musicMasterVolume;
}

void NxAudioEngine::setMusicVolume(float volume, int channel, double time)
{
	_musics[channel].wantedMusicVolume = volume;

	resetMusicVolume(channel, time);
}

void NxAudioEngine::resetMusicVolume(double time)
{
	for (int channel = 0; channel < 2; ++channel) {
		resetMusicVolume(channel, time);
	}
}

void NxAudioEngine::resetMusicVolume(int channel, double time)
{
	const NxAudioEngineMusic& music = _musics[channel];
	const float volume = music.wantedMusicVolume * getMusicMasterVolume();

	if (time > 0.0) {
		time /= gamehacks.getCurrentSpeedhack();
		_engine.fadeVolume(music.handle, volume, time);
		_lastVolumeFadeEndTime = _engine.mStreamTime + time;
	}
	else {
		_engine.setVolume(music.handle, volume);
	}
}

void NxAudioEngine::setMusicSpeed(float speed, int channel)
{
	_engine.setRelativePlaySpeed(_musics[channel].handle, speed);
}

void NxAudioEngine::setMusicLooping(bool looping, int channel)
{
	_engine.setLooping(_musics[channel].handle, looping);
}

// Voice
bool NxAudioEngine::canPlayVoice(const char* name)
{
	char filename[MAX_PATH];

	return getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
}

bool NxAudioEngine::playVoice(const char* name, int slot, float volume, int game_moment)
{
	char filename[MAX_PATH];

	bool exists = false;

	_currentVoice[slot].volume = volume * getVoiceMasterVolume();

	std::string _name(name);

	// TOML doesn't like the / char as key, replace it with - ( one of the valid accepted chars )
	replaceAll(_name, '/', '-');

	auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_VOICE][_name];

  // Attempt to load a subnode based on the current game moment
  if (game_moment > -1)
  {
    std::string _gamemoment("gm-" + std::to_string(game_moment));
    auto subnode = node[_gamemoment];
    if (subnode) node = subnode;
  }

	if (node)
	{
		// Set volume for the current track
		toml::node *trackVolume = node["volume"].as_integer();
		if (trackVolume)
		{
			_currentVoice[slot].volume = (trackVolume->value_or(100) / 100.0f) * getVoiceMasterVolume();
		}

		// Shuffle Voice playback, if any entry found for the current id
		toml::array *shuffleNames = node["shuffle"].as_array();
		if (shuffleNames && !shuffleNames->empty() && shuffleNames->is_homogeneous(toml::node_type::string))
		{
			auto _newName = shuffleNames->get(getRandomInt(0, shuffleNames->size() - 1));

			exists = getFilenameFullPath(filename, _newName->value_or(name), NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
		}

		// Sequentially playback new voice items, if any entry found for the current id
		toml::array *sequentialNames = node["sequential"].as_array();
		if (sequentialNames && !sequentialNames->empty() && sequentialNames->is_homogeneous(toml::node_type::string))
		{
			if (_voiceSequentialIndexes.find(name) == _voiceSequentialIndexes.end() || _voiceSequentialIndexes[name] >= sequentialNames->size())
				_voiceSequentialIndexes[name] = 0;

			auto _newName = sequentialNames->get(_voiceSequentialIndexes[name]);

			_voiceSequentialIndexes[name]++;

			exists = getFilenameFullPath(filename, _newName->value_or(name), NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
		}
	}

	// If none of the previous configurations worked, load the default one as last tentative
	if (!exists) {
		exists = getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
	}

	if (trace_all || trace_voice) ffnx_trace("NxAudioEngine::%s: slot[%d] %s exists=%d\n", __func__, slot, filename, exists);

	if (exists)
	{
		// Stop any previously playing voice
		if (_engine.isValidVoiceHandle(_currentVoice[slot].handle))
		{
			_engine.stop(_currentVoice[slot].handle);

			delete _currentVoice[slot].stream;

			_currentVoice[slot].handle = NXAUDIOENGINE_INVALID_HANDLE;
		}

		_currentVoice[slot].stream = new SoLoud::VGMStream();

		SoLoud::result res = _currentVoice[slot].stream->load(filename);
		if (res != SoLoud::SO_NO_ERROR) {
			ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
			delete _currentVoice[slot].stream;
			return false;
		}

		_currentVoice[slot].handle = _engine.play(*_currentVoice[slot].stream, _currentVoice[slot].volume);

		return _engine.isValidVoiceHandle(_currentVoice[slot].handle);
	}
	else
		return false;
}

void NxAudioEngine::stopVoice(int slot, double time)
{
	SoLoud::handle handle = _currentVoice[slot].handle;

	if (trace_all || trace_voice) ffnx_trace("NxAudioEngine::%s: slot=%d time=%lf handle=%X\n", __func__, slot, time, handle);

	if (!_engine.isValidVoiceHandle(handle))
	{
		return;
	}

	if (time > 0.0)
	{
		_engine.fadeVolume(handle, 0, time);
		_engine.scheduleStop(handle, time);
	}
	else
	{
		_engine.stop(handle);
	}
}

void NxAudioEngine::pauseVoice(int slot, double time)
{
	if (time > 0.0)
	{
		_engine.fadeVolume(_currentVoice[slot].handle, 0, time);
		_engine.schedulePause(_currentVoice[slot].handle, time);
	}
	else
	{
		_engine.setPause(_currentVoice[slot].handle, true);
	}
}

void NxAudioEngine::resumeVoice(int slot, double time)
{
	if (time > 0.0)
	{
		_engine.setPause(_currentVoice[slot].handle, false);
		_engine.fadeVolume(_currentVoice[slot].handle, _currentVoice[slot].volume, time);
	}
	else
	{
		_engine.setVolume(_currentVoice[slot].handle, _currentVoice[slot].volume);
		_engine.setPause(_currentVoice[slot].handle, false);
	}
}

bool NxAudioEngine::isVoicePlaying(int slot)
{
	return _engine.isValidVoiceHandle(_currentVoice[slot].handle) && !_engine.getPause(_currentVoice[slot].handle);
}

void NxAudioEngine::setVoiceMaxSlots(int slot)
{
	_voiceMaxSlots = slot;
}

float NxAudioEngine::getVoiceMasterVolume()
{
	return _voiceMasterVolume < 0.0f ? 1.0f : _voiceMasterVolume;
}

void NxAudioEngine::setVoiceMasterVolume(float volume, double time)
{
	_voiceMasterVolume = volume;
}

// Ambient
bool NxAudioEngine::canPlayAmbient(const char* name)
{
	char filename[MAX_PATH];

	return getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
}

bool NxAudioEngine::playAmbient(const char* name, float volume, double time)
{
	char filename[MAX_PATH];
	bool exists = false;

	// Reset state
	_currentAmbient.fade_in = 0.0f;
	_currentAmbient.fade_out = 0.0f;
	_currentAmbient.volume = volume * getAmbientMasterVolume();

	auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT][name];
	if (node)
	{
		// Shuffle Ambient playback, if any entry found for the current id
		toml::array *shuffleIds = node["shuffle"].as_array();
		if (shuffleIds && !shuffleIds->empty() && shuffleIds->is_homogeneous(toml::node_type::string))
		{
			auto _newName = shuffleIds->get(getRandomInt(0, shuffleIds->size() - 1));

			exists = getFilenameFullPath(filename, _newName->value_or(""), NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
		}

		// Sequentially playback new Ambient ids, if any entry found for the current id
		toml::array *sequentialIds = node["sequential"].as_array();
		if (sequentialIds && !sequentialIds->empty() && sequentialIds->is_homogeneous(toml::node_type::string))
		{
			// If the key doesn't exist already, add it
			if (_ambientSequentialIndexes.count(name) == 0) _ambientSequentialIndexes[name] = NULL;

			if (_ambientSequentialIndexes.find(name) == _ambientSequentialIndexes.end() || _ambientSequentialIndexes[name] >= sequentialIds->size())
				_ambientSequentialIndexes[name] = 0;

			auto _newName = sequentialIds->get(_ambientSequentialIndexes[name]);

			_ambientSequentialIndexes[name]++;

			exists = getFilenameFullPath(filename, _newName->value_or(""), NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
		}

		// Fade In time for this track, if configured
		toml::node *fadeInTime = node["fade_in"].as_floating_point();
		if (fadeInTime)
		{
			_currentAmbient.fade_in = fadeInTime->value_or(0.0f);

			time = _currentAmbient.fade_in;
		}

		// Fade Out time for this track, if configured
		toml::node *fadeOutTime = node["fade_out"].as_floating_point();
		if (fadeOutTime)
		{
			_currentAmbient.fade_out = fadeOutTime->value_or(0.0f);
		}

		// Set volume for the current ambient
		toml::node *ambientVolume = node["volume"].as_integer();
		if (ambientVolume)
		{
			_currentAmbient.volume = (ambientVolume->value_or(100) / 100.0f) * getAmbientMasterVolume();
		}
	}

	// If none of the previous configurations worked, load the default one as last tentative
	if (!exists) {
		exists = getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
	}

	if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: %s exists=%d handle=%X\n", __func__, filename, exists, _currentAmbient.handle);

	if (exists)
	{
		// Stop any previously playing ambient
		if (_engine.isValidVoiceHandle(_currentAmbient.handle))
		{
			_engine.stop(_currentAmbient.handle);

			delete _currentAmbient.stream;

			_currentAmbient.handle = NXAUDIOENGINE_INVALID_HANDLE;
		}

		_currentAmbient.stream = new SoLoud::VGMStream();

		SoLoud::result res = _currentAmbient.stream->load(filename);
		if (res != SoLoud::SO_NO_ERROR) {
			ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
			delete _currentAmbient.stream;
			return false;
		}

		_currentAmbient.handle = _engine.play(*_currentAmbient.stream, time > 0.0f ? 0.0f : _currentAmbient.volume, 0.0f, time > 0.0f);

		if (time > 0.0f) resumeAmbient(time);

		return _engine.isValidVoiceHandle(_currentAmbient.handle);
	}
	else
		return false;
}

void NxAudioEngine::stopAmbient(double time)
{
	if (_currentAmbient.fade_out > 0.0f)
	{
		time = _currentAmbient.fade_out;

		if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f ( overridden through config.toml )\n", __func__, time);
	}
	else if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f\n", __func__, time);

	if (time > 0.0)
	{
		_engine.fadeVolume(_currentAmbient.handle, 0, time);
		_engine.scheduleStop(_currentAmbient.handle, time);
	}
	else
	{
		_engine.stop(_currentAmbient.handle);
	}
}

void NxAudioEngine::pauseAmbient(double time)
{
	if (_currentAmbient.fade_out > 0.0f)
	{
		time = _currentAmbient.fade_out;

		if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f ( overridden through config.toml )\n", __func__, time);
	}
	else if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f\n", __func__, time);

	if (time > 0.0)
	{
		_engine.fadeVolume(_currentAmbient.handle, 0, time);
		_engine.schedulePause(_currentAmbient.handle, time);
	}
	else
	{
		_engine.setPause(_currentAmbient.handle, true);
	}
}

void NxAudioEngine::resumeAmbient(double time)
{
	if (_currentAmbient.fade_in > 0.0f)
	{
		time = _currentAmbient.fade_in;

		if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f ( overridden through config.toml )\n", __func__, time);
	}
	else if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f\n", __func__, time);

	if (time > 0.0)
	{
		_engine.setPause(_currentAmbient.handle, false);
		_engine.fadeVolume(_currentAmbient.handle, _currentAmbient.volume, time);
	}
	else
	{
		_engine.setVolume(_currentAmbient.handle, _currentAmbient.volume);
		_engine.setPause(_currentAmbient.handle, false);
	}
}

bool NxAudioEngine::isAmbientPlaying()
{
	return _engine.isValidVoiceHandle(_currentAmbient.handle) && !_engine.getPause(_currentAmbient.handle);
}

float NxAudioEngine::getAmbientMasterVolume()
{
	return _ambientMasterVolume < 0.0f ? 1.0f : _ambientMasterVolume;
}

void NxAudioEngine::setAmbientMasterVolume(float volume, double time)
{
	_ambientMasterVolume = volume;
}

// Movie Audio
bool NxAudioEngine::canPlayMovieAudio(const char* nameWithPath)
{
	char filename[MAX_PATH];

	return getFilenameFullPath(filename, nameWithPath, NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO);
}

bool NxAudioEngine::playMovieAudio(const char* nameWithPath, int slot, float volume)
{
	char filename[MAX_PATH];
	bool exists = getFilenameFullPath(filename, nameWithPath, NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO);

	if (trace_all || trace_movies) ffnx_trace("NxAudioEngine::%s: %s exists=%d\n", __func__, filename, exists);

	// Stop any previously playing movie audio
	if (_engine.isValidVoiceHandle(_currentMovieAudio[slot].handle))
	{
		_engine.stop(_currentMovieAudio[slot].handle);

		delete _currentMovieAudio[slot].stream;

		_currentMovieAudio[slot].handle = NXAUDIOENGINE_INVALID_HANDLE;
	}

	if (exists)
	{
		_currentMovieAudio[slot].stream = new SoLoud::VGMStream();

		SoLoud::result res = _currentMovieAudio[slot].stream->load(filename);
		if (res != SoLoud::SO_NO_ERROR) {
			ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
			delete _currentMovieAudio[slot].stream;
			return false;
		}

		_currentMovieAudio[slot].handle = _engine.play(*_currentMovieAudio[slot].stream, volume * getMovieMasterVolume());

		return _engine.isValidVoiceHandle(_currentMovieAudio[slot].handle);
	}
	else
		return false;
}

void NxAudioEngine::stopMovieAudio(int slot)
{
	_engine.stop(_currentMovieAudio[slot].handle);
}

bool NxAudioEngine::isMovieAudioPlaying(int slot)
{
	return _engine.isValidVoiceHandle(_currentMovieAudio[slot].handle);
}

void NxAudioEngine::setMovieAudioMaxSlots(int slot)
{
	_movieAudioMaxSlots = slot;
}

float NxAudioEngine::getMovieMasterVolume()
{
	return _movieMasterVolume < 0.0f ? 1.0f : _movieMasterVolume;
}

void NxAudioEngine::setMovieMasterVolume(float volume, double time)
{
	_movieMasterVolume = volume;
}

// Stream Audio
void NxAudioEngine::initStream(float duration, float sample_rate, uint32_t channels)
{
	if (_currentStream.stream) delete _currentStream.stream;

	_currentStream.stream = new SoLoud::MemoryStream(sample_rate, ::ceil(duration) * sample_rate * channels, channels);
}

void NxAudioEngine::pushStreamData(uint8_t* data, uint32_t size)
{
	if (_currentStream.stream)
	{
		_currentStream.stream->push(data, size);
	}
}

bool NxAudioEngine::playStream(float volume)
{
	_currentStream.volume = volume * getStreamMasterVolume();
	_currentStream.handle = _engine.play(*_currentStream.stream, _currentStream.volume);

	return _engine.isValidVoiceHandle(_currentStream.handle);
}

void NxAudioEngine::stopStream(double time)
{
	if (time > 0.0)
	{
		_engine.fadeVolume(_currentStream.handle, 0, time);
		_engine.schedulePause(_currentStream.handle, time);
	}
	else
	{
		_engine.setPause(_currentStream.handle, true);
	}

	_currentStream.handle = NXAUDIOENGINE_INVALID_HANDLE;
}

bool NxAudioEngine::isStreamPlaying()
{
	return _engine.isValidVoiceHandle(_currentStream.handle);
}

void NxAudioEngine::pauseStream(double time)
{
	if (time > 0.0)
	{
		_engine.fadeVolume(_currentStream.handle, 0, time);
		_engine.schedulePause(_currentStream.handle, time);
	}
	else
	{
		_engine.setPause(_currentStream.handle, true);
	}
}

void NxAudioEngine::resumeStream(double time)
{
	if (time > 0.0)
	{
		_engine.setPause(_currentStream.handle, false);
		_engine.fadeVolume(_currentStream.handle, _currentStream.volume, time);
	}
	else
	{
		_engine.setVolume(_currentStream.handle, _currentStream.volume);
		_engine.setPause(_currentStream.handle, false);
	}
}

float NxAudioEngine::getStreamMasterVolume()
{
	return _streamMasterVolume < 0.0f ? 1.0f : _streamMasterVolume;
}

void NxAudioEngine::setStreamMasterVolume(float volume, double time)
{
	_streamMasterVolume = volume;
}
````

## File: src/audio.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stack>
#include <string>
#include <vector>
#include <unordered_map>
#include <soloud.h>
#include "audio/memorystream/memorystream.h"
#include "audio/vgmstream/vgmstream.h"

#include "log.h"

#define NXAUDIOENGINE_INVALID_HANDLE 0xfffff000

static void NxAudioEngineVgmstreamCallback(int level, const char* str)
{
  ffnx_info("VGMStream [L%d]: %s", level, str);
}

class NxAudioEngine
{
public:
	struct MusicOptions
	{
		MusicOptions() :
			offsetSeconds(0.0),
			fadetime(0.0),
			targetVolume(-1.0f),
			relativeSpeed(1.0f),
			format(""),
			noIntro(false),
			sync(false),
			useNameAsFullPath(false),
			suppressOpeningSilence(false)
		{}
		SoLoud::time offsetSeconds;
		SoLoud::time fadetime;
		float targetVolume;
		float relativeSpeed;
		char format[12];
		bool noIntro, sync, useNameAsFullPath, suppressOpeningSilence;
	};

	struct NxAudioEngineSFX
	{
		NxAudioEngineSFX() :
			game_id(0),
			id(0),
			stream(nullptr),
			handle(NXAUDIOENGINE_INVALID_HANDLE),
			volume(1.0f),
			loop(false)
		{}
		int game_id;
		int id;
		SoLoud::VGMStream *stream;
		SoLoud::handle handle;
		float volume;
		bool loop;
	};

	struct NxAudioEngineMusic
	{
		NxAudioEngineMusic() :
			handle(NXAUDIOENGINE_INVALID_HANDLE),
			id(-1),
			wantedMusicVolume(1.0f),
			lastMusicOffset(-1.0f),
			sync(false) {}
		void invalidate() {
			handle = NXAUDIOENGINE_INVALID_HANDLE;
			id = -1;
		}
		SoLoud::handle handle;
		int32_t id;
		float wantedMusicVolume;
		SoLoud::time lastMusicOffset;
		bool sync;
	};

	struct NxAudioEngineMusicAudioSource
	{
		NxAudioEngineMusicAudioSource(SoLoud::handle handle, SoLoud::AudioSource* audioSource) :
			handle(handle),
			audioSource(audioSource) {}
		SoLoud::handle handle;
		SoLoud::AudioSource* audioSource;
	};

	struct NxAudioEngineVoice
	{
		NxAudioEngineVoice() :
			handle(NXAUDIOENGINE_INVALID_HANDLE),
			stream(nullptr),
			volume(1.0f) {}
		SoLoud::handle handle;
		SoLoud::VGMStream* stream;
		float volume;
	};

	struct NxAudioEngineAmbient
	{
		NxAudioEngineAmbient() :
			handle(NXAUDIOENGINE_INVALID_HANDLE),
			stream(nullptr),
			volume(1.0f),
			fade_in(0.0f),
			fade_out(0.0f) {}
		SoLoud::handle handle;
		SoLoud::VGMStream* stream;
		float volume;
		double fade_in;
		double fade_out;
	};

	struct NxAudioEngineMovieAudio
	{
		NxAudioEngineMovieAudio() :
			handle(NXAUDIOENGINE_INVALID_HANDLE),
			stream(nullptr) {}
		SoLoud::handle handle;
		SoLoud::VGMStream* stream;
	};

	struct NxAudioEngineStreamAudio
	{
		NxAudioEngineStreamAudio() :
			handle(NXAUDIOENGINE_INVALID_HANDLE),
			stream(nullptr),
			volume(1.0f) {}
		SoLoud::handle handle;
		SoLoud::MemoryStream* stream;
		float volume;
	};

private:
	enum NxAudioEngineLayer
	{
		NXAUDIOENGINE_SFX,
		NXAUDIOENGINE_MUSIC,
		NXAUDIOENGINE_VOICE,
		NXAUDIOENGINE_AMBIENT,
		NXAUDIOENGINE_MOVIE_AUDIO,
	};

	bool _engineInitialized = false;
	SoLoud::Soloud _engine;
	bool _openpsf_loaded = false;

	// SFX
	short _sfxReusableChannels = 0;
	short _sfxTotalChannels = 0;
	float _sfxMasterVolume = -1.0f;
	std::map<int, NxAudioEngineSFX> _sfxChannels;
	std::map<std::string, int> _sfxSequentialIndexes;
	std::map<int, SoLoud::VGMStream*> _sfxEffectsHandler;
	std::vector<short> _sfxLazyUnloadChannels;

	SoLoud::VGMStream* loadSFX(std::string id, bool loop = false);
	void unloadSFXChannel(int channel);

	// MUSIC
	NxAudioEngineMusic _musics[2];
	std::stack<NxAudioEngineMusic> _musicStack; // For resuming
	std::list<NxAudioEngineMusicAudioSource> _audioSourcesToDeleteLater;

	float _previousMusicMasterVolume = -1.0f;
	float _musicMasterVolume = -1.0f;
	SoLoud::time _lastVolumeFadeEndTime = 0.0;

	void cleanOldAudioSources();
	SoLoud::AudioSource* loadMusic(const char* name, bool isFullPath = false, const char* format = nullptr, bool suppressOpeningSilence = false);
	void overloadPlayArgumentsFromConfig(char* name, uint32_t *id, MusicOptions *MusicOptions);
	void backupMusic(int channelSource);
	void restoreMusic(int channelDest, double stopTime = 0);
	void resetMusicVolume(double time = 0);
	void resetMusicVolume(int channel, double time = 0);

	// VOICE
	short _voiceMaxSlots = 0;
	float _voiceMasterVolume = -1.0f;
	std::map<int, NxAudioEngineVoice> _currentVoice;
	std::map<std::string, int> _voiceSequentialIndexes;

	// AMBIENT
	float _ambientMasterVolume = -1.0f;
	std::map<std::string, int> _ambientSequentialIndexes;
	NxAudioEngineAmbient _currentAmbient;

	// MOVIE AUDIO
	float _movieMasterVolume = -1.0f;
	short _movieAudioMaxSlots = 0;
	std::map<int, NxAudioEngineMovieAudio> _currentMovieAudio;

	// STREAM
	float _streamMasterVolume = -1.0f;
	NxAudioEngineStreamAudio _currentStream;

	// MISC
	// Returns false if the file does not exist
	bool getFilenameFullPath(char *_out, const char* _key, NxAudioEngineLayer _type);

	bool fileExists(const char* filename);

	// CFG
	std::unordered_map<NxAudioEngineLayer,toml::parse_result> nxAudioEngineConfig;

	void loadConfig();

public:

	bool init();
	void flush();
	void cleanup();

	// SFX
	int getSFXIdFromChannel(int channel);
	void unloadSFX(int id);
	bool playSFX(const char* name, int id, int channel, float panning, bool loop = false, float volume = 1.0f);
	void stopSFX(int channel, double time = 0);
	void pauseSFX(int channel);
	void resumeSFX(int channel);
	bool isSFXPlaying(int channel);
	float getSFXMasterVolume();
	void setSFXMasterVolume(float volume, double time = 0);
	void setSFXVolume(int channel, float volume, double time = 0);
	void setSFXSpeed(int channel, float speed, double time = 0);
	void setSFXPanning(int channel, float panning, double time = 0);
	void setSFXReusableChannels(short num);
	void setSFXTotalChannels(short num);
	void addSFXLazyUnloadChannel(int channel);

	// Music
	bool canPlayMusic(const char* name);
	bool isMusicDisabled(const char* name);
	bool playMusic(const char* name, uint32_t id, int channel, MusicOptions options = MusicOptions());
	void playSynchronizedMusics(const std::vector<std::string>& names, uint32_t id, MusicOptions options = MusicOptions());
	void swapChannels();
	void stopMusic(double time = 0);
	void stopMusic(int channel, double time = 0);
	void pauseMusic(double time = 0);
	void pauseMusic(int channel, double time = 0, bool backup = false);
	void resumeMusic(double time = 0);
	void resumeMusic(int channel, double time = 0, bool restore = false);
	bool isChannelValid(int channel);
	bool isMusicPlaying();
	bool isMusicPlaying(int channel);
	uint32_t currentMusicId(int channel);
	void setMusicMasterVolume(float volume, double time = 0);
	void restoreMusicMasterVolume(double time = 0);
	float getMusicVolume(int channel);
	bool isMusicVolumeFadeFinished();
	float getMusicMasterVolume();
	void setMusicVolume(float volume, int channel, double time = 0);
	void setMusicSpeed(float speed, int channel);
	void setMusicLooping(bool looping, int channel);

	// Voice
	bool canPlayVoice(const char* name);
	bool playVoice(const char* name, int slot = 0, float volume = 1.0f, int game_moment = -1);
	void stopVoice(int slot = 0, double time = 0);
	void pauseVoice(int slot = 0, double time = 0);
	void resumeVoice(int slot = 0, double time = 0);
	bool isVoicePlaying(int slot = 0);
	void setVoiceMaxSlots(int slot);
	float getVoiceMasterVolume();
	void setVoiceMasterVolume(float volume, double time = 0);

	// Ambient
	bool canPlayAmbient(const char* name);
	bool playAmbient(const char* name, float volume = 1.0f, double time = 0);
	void stopAmbient(double time = 0);
	void pauseAmbient(double time = 0);
	void resumeAmbient(double time = 0);
	bool isAmbientPlaying();
	float getAmbientMasterVolume();
	void setAmbientMasterVolume(float volume, double time = 0);

	// Movie Audio
	bool canPlayMovieAudio(const char* filename);
	bool playMovieAudio(const char* filename, int slot = 0, float volume = 1.0f);
	void stopMovieAudio(int slot = 0);
	bool isMovieAudioPlaying(int slot = 0);
	void setMovieAudioMaxSlots(int slot);
	float getMovieMasterVolume();
	void setMovieMasterVolume(float volume, double time = 0);

	// Stream Audio
	void initStream(float duration, float sample_rate, uint32_t channels);
	void pushStreamData(uint8_t* data, uint32_t size);
	bool playStream(float volume = 1.0f);
	void stopStream(double time = 0.0f);
	void pauseStream(double time = 0.0f);
	void resumeStream(double time = 0.0f);
	bool isStreamPlaying();
	float getStreamMasterVolume();
	void setStreamMasterVolume(float volume, double time = 0);
};

extern NxAudioEngine nxAudioEngine;
````

## File: src/cfg.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <toml++/toml.h>

#include "cfg.h"
#include "common.h"
#include "globals.h"
#include "log.h"

#define FFNX_CFG_FILE "FFNx.toml"

// configuration variables with their default values
std::string mod_path;
std::vector<std::string> mod_ext;
long enable_ffmpeg_videos;
std::string ffmpeg_video_ext;
std::vector<std::string> external_movie_audio_ext;
bool use_external_sfx;
std::string external_sfx_path;
std::vector<std::string> external_sfx_ext;
bool external_sfx_always_centered;
bool use_external_music;
bool external_music_resume;
bool external_music_sync;
std::string external_music_path;
std::vector<std::string> external_music_ext;
std::string he_bios_path;
std::string external_voice_path;
std::vector<std::string> external_voice_ext;
std::string external_ambient_path;
std::vector<std::string> external_ambient_ext;
std::string external_lighting_path;
std::string external_widescreen_path;
std::string external_time_cycle_path;
std::string external_mesh_path;
bool enable_voice_music_fade;
long external_voice_music_fade_volume;
bool enable_voice_auto_text;
bool enable_auto_run;
bool save_textures;
bool save_textures_legacy;
bool save_exe_data;
bool trace_all;
bool trace_renderer;
bool trace_movies;
bool trace_music;
bool trace_sfx;
bool trace_fake_dx;
bool trace_direct;
bool trace_files;
bool trace_loaders;
bool trace_vram;
bool trace_lights;
bool trace_opcodes;
bool trace_voice;
bool trace_ambient;
bool trace_gamepad;
bool trace_achievement;
bool trace_battle_animation;
bool trace_battle_text;
bool vertex_log;
bool uniform_log;
bool show_renderer_backend;
bool show_fps;
bool show_stats;
bool show_version;
long window_size_x;
long window_size_y;
long internal_resolution_scale;
long aspect_ratio;
bool enable_uncrop;
bool fullscreen;
bool borderless;
long refresh_rate;
bool enable_vsync;
bool mdef_fix;
long enable_antialiasing;
bool enable_anisotropic;
bool enable_bilinear;
bool enable_lighting;
bool prefer_lighting_cpu_calculations;
long game_lighting;
bool enable_time_cycle;
bool enable_worldmap_external_mesh;
bool ff7_external_opening_music;
bool more_debug;
bool ff8_ssigpu_debug;
bool show_applog;
bool show_missing_textures;
bool show_error_popup;
long renderer_backend;
bool renderer_debug;
bool create_crash_dump;
std::string steam_game_userdata;
std::string hext_patching_path;
std::string override_path;
std::string override_mod_path;
std::string direct_mode_path;
std::string save_path;
bool enable_devtools;
long devtools_hotkey;
double speedhack_step;
double speedhack_max;
double speedhack_min;
bool enable_animated_textures;
std::vector<std::string> disable_animated_textures_on_field;
long ff7_fps_limiter;
bool ff7_footsteps;
bool ff7_field_center;
bool enable_analogue_controls;
bool enable_inverted_vertical_camera_controls;
bool enable_inverted_horizontal_camera_controls;
double left_analog_stick_deadzone;
double right_analog_stick_deadzone;
double left_analog_trigger_deadzone;
double right_analog_trigger_deadzone;
std::string external_vibrate_path;
bool enable_steam_achievements;
bool steam_achievements_debug_mode;
double hdr_max_nits;
long external_audio_number_of_channels;
long external_audio_sample_rate;
bool ff8_worldmap_internal_highres_textures;
bool ff8_fix_uv_coords_precision;
bool ff8_external_music_force_original_filenames;
bool ff8_use_gamepad_icons;
bool ff8_always_capture_input;
long ff8_fps_limiter;
std::string app_path;
std::string data_drive;
bool enable_ntscj_gamut_mode;
long external_music_volume;
long external_sfx_volume;
long external_voice_volume;
long external_ambient_volume;
long ffmpeg_video_volume;
bool ff7_advanced_blinking;
long display_index;

std::vector<std::string> get_string_or_array_of_strings(const toml::node_view<toml::node> &node)
{
	if (node.is_array()) {
		toml::array* a = node.as_array();
		if (a && a->is_homogeneous(toml::node_type::string)) {
			std::vector<std::string> ret;
			ret.reserve(a->size());
			for (toml::node &elem: *a) {
				ret.push_back(elem.value_or(""));
			}
			return ret;
		}
	}

	return std::vector<std::string>(1, node.value_or(""));
}

void read_cfg()
{
	toml::parse_result config;

	try
	{
		config = toml::parse_file(FFNX_CFG_FILE);
	}
	catch (const toml::parse_error &err)
	{
		ffnx_warning("Parse error while opening the file " FFNX_CFG_FILE ". Will continue with the default settings.\n");
		ffnx_warning("%s (Line %u Column %u)\n", err.what(), err.source().begin.line, err.source().begin.column);

		char tmp[1024]{0};
		sprintf(tmp, "%s (Line %u Column %u)\n\nWill continue with safe default settings.", err.what(), err.source().begin.line, err.source().begin.column);
		MessageBoxA(gameHwnd, tmp, "Configuration issue detected!", MB_ICONWARNING | MB_OK);

		config = toml::parse("");
	}

	// Read config values
	mod_path = config["mod_path"].value_or("");
	mod_ext = get_string_or_array_of_strings(config["mod_ext"]);
	enable_ffmpeg_videos = config["enable_ffmpeg_videos"].value_or(-1);
	ffmpeg_video_ext = config["ffmpeg_video_ext"].value_or("");
	external_movie_audio_ext = get_string_or_array_of_strings(config["external_movie_audio_ext"]);
	use_external_sfx = config["use_external_sfx"].value_or(false);
	external_sfx_path = config["external_sfx_path"].value_or("");
	external_sfx_ext = get_string_or_array_of_strings(config["external_sfx_ext"]);
	external_sfx_always_centered = config["external_sfx_always_centered"].value_or(false);
	use_external_music = config["use_external_music"].value_or(false);
	external_music_resume = config["external_music_resume"].value_or(true);
	external_music_sync = config["external_music_sync"].value_or(false);
	external_music_path = config["external_music_path"].value_or("");
	external_music_ext = get_string_or_array_of_strings(config["external_music_ext"]);
	he_bios_path = config["he_bios_path"].value_or("");
	external_voice_path = config["external_voice_path"].value_or("");
	external_voice_ext = get_string_or_array_of_strings(config["external_voice_ext"]);
	enable_voice_music_fade = config["enable_voice_music_fade"].value_or(false);
	external_voice_music_fade_volume = config["external_voice_music_fade_volume"].value_or(25);
	enable_voice_auto_text = config["enable_voice_auto_text"].value_or(true);
	external_ambient_path = config["external_ambient_path"].value_or("");
	external_ambient_ext = get_string_or_array_of_strings(config["external_ambient_ext"]);
	external_lighting_path = config["external_lighting_path"].value_or("");
	external_widescreen_path = config["external_widescreen_path"].value_or("");
	external_time_cycle_path = config["external_time_cycle_path"].value_or("");
	external_mesh_path = config["external_mesh_path"].value_or("");
	save_textures = config["save_textures"].value_or(false);
	save_textures_legacy = config["save_textures_legacy"].value_or(false);
	save_exe_data = config["save_exe_data"].value_or(false);
	trace_all = config["trace_all"].value_or(false);
	trace_renderer = config["trace_renderer"].value_or(false);
	trace_movies = config["trace_movies"].value_or(false);
	trace_music = config["trace_music"].value_or(false);
	trace_sfx = config["trace_sfx"].value_or(false);
	trace_fake_dx = config["trace_fake_dx"].value_or(false);
	trace_direct = config["trace_direct"].value_or(false);
	trace_files = config["trace_files"].value_or(false);
	trace_loaders = config["trace_loaders"].value_or(false);
	trace_vram = config["trace_vram"].value_or(false);
	trace_lights = config["trace_lights"].value_or(false);
	trace_opcodes = config["trace_opcodes"].value_or(false);
	trace_voice = config["trace_voice"].value_or(false);
	trace_ambient = config["trace_ambient"].value_or(false);
	trace_gamepad = config["trace_gamepad"].value_or(false);
	trace_achievement = config["trace_achievement"].value_or(false);
	trace_battle_animation = config["trace_battle_animation"].value_or(false);
	trace_battle_text = config["trace_battle_text"].value_or(false);
	vertex_log = config["vertex_log"].value_or(false);
	uniform_log = config["uniform_log"].value_or(false);
	show_renderer_backend = config["show_renderer_backend"].value_or(true);
	show_fps = config["show_fps"].value_or(false);
	show_stats = config["show_stats"].value_or(false);
	show_version = config["show_version"].value_or(true);
	window_size_x = config["window_size_x"].value_or(0);
	window_size_y = config["window_size_y"].value_or(0);
	internal_resolution_scale = config["internal_resolution_scale"].value_or(0);
	aspect_ratio = config["aspect_ratio"].value_or(0);
	enable_uncrop = config["enable_uncrop"].value_or(false);
	fullscreen = config["fullscreen"].value_or(false);
	borderless = config["borderless"].value_or(false);
	refresh_rate = config["refresh_rate"].value_or(0);
	enable_vsync = config["enable_vsync"].value_or(true);
	mdef_fix = config["mdef_fix"].value_or(true);
	enable_antialiasing = config["enable_antialiasing"].value_or(0);
	enable_anisotropic = config["enable_anisotropic"].value_or(true);
	enable_bilinear = config["enable_bilinear"].value_or(false);
	enable_lighting = config["enable_lighting"].value_or(false);
	prefer_lighting_cpu_calculations = config["prefer_lighting_cpu_calculations"].value_or(true);
	game_lighting = config["game_lighting"].value_or(GAME_LIGHTING_PER_VERTEX);
	enable_time_cycle = config["enable_time_cycle"].value_or(false);
	enable_worldmap_external_mesh = config["enable_worldmap_external_mesh"].value_or(false);
	ff7_external_opening_music = config["ff7_external_opening_music"].value_or(false);
	more_debug = config["more_debug"].value_or(false);
	ff8_ssigpu_debug = config["ff8_ssigpu_debug"].value_or(false);
	show_applog = config["show_applog"].value_or(true);
	show_missing_textures = config["show_missing_textures"].value_or(false);
	show_error_popup = config["show_error_popup"].value_or(false);
	renderer_backend = config["renderer_backend"].value_or(RENDERER_BACKEND_AUTO);
	renderer_debug = config["renderer_debug"].value_or(false);
	create_crash_dump = config["create_crash_dump"].value_or(false);
	steam_game_userdata = config["steam_game_userdata"].value_or("");
	hext_patching_path = config["hext_patching_path"].value_or("");
	override_path = config["override_path"].value_or("");
	override_mod_path = config["override_mod_path"].value_or("");
	direct_mode_path = config["direct_mode_path"].value_or("");
	save_path = config["save_path"].value_or("");
	enable_devtools = config["enable_devtools"].value_or(false);
	devtools_hotkey = config["devtools_hotkey"].value_or(VK_F12);
	speedhack_step = config["speedhack_step"].value_or(0.5);
	speedhack_max = config["speedhack_max"].value_or(8.0);
	speedhack_min = config["speedhack_min"].value_or(1.0);
	enable_animated_textures = config["enable_animated_textures"].value_or(false);
	disable_animated_textures_on_field = get_string_or_array_of_strings(config["disable_animated_textures_on_field"]);
	ff7_fps_limiter = config["ff7_fps_limiter"].value_or(FPS_LIMITER_DEFAULT);
	ff7_footsteps = config["ff7_footsteps"].value_or(false);
	ff7_field_center = config["ff7_field_center"].value_or(true);
	enable_analogue_controls = config["enable_analogue_controls"].value_or(false);
	enable_inverted_vertical_camera_controls = config["enable_inverted_vertical_camera_controls"].value_or(false);
	enable_inverted_horizontal_camera_controls = config["enable_inverted_horizontal_camera_controls"].value_or(false);
	left_analog_stick_deadzone = config["left_analog_stick_deadzone"].value_or(0.1);
	right_analog_stick_deadzone = config["right_analog_stick_deadzone"].value_or(0.1);
	left_analog_trigger_deadzone = config["left_analog_trigger_deadzone"].value_or(0.1);
	right_analog_trigger_deadzone = config["right_analog_trigger_deadzone"].value_or(0.1);
	enable_auto_run = config["enable_auto_run"].value_or(false);
	external_vibrate_path = config["external_vibrate_path"].value_or("");
	enable_steam_achievements = config["enable_steam_achievements"].value_or(false);
	steam_achievements_debug_mode = config["steam_achievements_debug_mode"].value_or(false);
	hdr_max_nits = config["hdr_max_nits"].value_or(0);
	external_audio_number_of_channels = config["external_audio_number_of_channels"].value_or(2);
	external_audio_sample_rate = config["external_audio_sample_rate"].value_or(44100);
	ff8_worldmap_internal_highres_textures = config["ff8_worldmap_internal_highres_textures"].value_or(true);
	ff8_fix_uv_coords_precision = config["ff8_fix_uv_coords_precision"].value_or(true);
	ff8_external_music_force_original_filenames = config["ff8_external_music_force_original_filenames"].value_or(false);
	ff8_use_gamepad_icons = config["ff8_use_gamepad_icons"].value_or(false);
	ff8_always_capture_input = config["ff8_always_capture_input"].value_or(false);
	ff8_fps_limiter = config["ff8_fps_limiter"].value_or(FPS_LIMITER_DEFAULT);
	app_path = config["app_path"].value_or("");
	data_drive = config["data_drive"].value_or("");
	enable_ntscj_gamut_mode = config["enable_ntscj_gamut_mode"].value_or(false);
	external_music_volume = config["external_music_volume"].value_or(-1);
	external_sfx_volume = config["external_sfx_volume"].value_or(-1);
	external_voice_volume = config["external_voice_volume"].value_or(-1);
	external_ambient_volume = config["external_ambient_volume"].value_or(-1);
	ffmpeg_video_volume = config["ffmpeg_video_volume"].value_or(-1);
	ff7_advanced_blinking = config["ff7_advanced_blinking"].value_or(false);
	display_index = config["display_index"].value_or(-1);

	// Windows x or y size can't be less then 0
	if (window_size_x < 0) window_size_x = 0;
	if (window_size_y < 0) window_size_y = 0;

	// Normalize voice music fade volume
	if (external_voice_music_fade_volume < 0) external_voice_music_fade_volume = 0;
	if (external_voice_music_fade_volume > 100) external_voice_music_fade_volume = 100;


	// #############
	// SAFE DEFAULTS
	// #############

	if (ff7_fps_limiter < FPS_LIMITER_ORIGINAL) ff7_fps_limiter = FPS_LIMITER_ORIGINAL;
	else if (ff7_fps_limiter > FPS_LIMITER_60FPS) ff7_fps_limiter = FPS_LIMITER_60FPS;

	if (ff8_fps_limiter < FPS_LIMITER_ORIGINAL) ff8_fps_limiter = FPS_LIMITER_ORIGINAL;
	else if (ff8_fps_limiter > FPS_LIMITER_60FPS) ff8_fps_limiter = FPS_LIMITER_60FPS;

	if (hext_patching_path.empty())
	{
		hext_patching_path = "hext";
	}

	if (ff8)
		hext_patching_path += "/ff8";
	else
		hext_patching_path += "/ff7";

	switch (version)
	{
	case VERSION_FF7_102_US:
		if (ff7_japanese_edition)
		{
			hext_patching_path += "/ja";
		}
		else
		{
			hext_patching_path += "/en";
		}
		break;
	case VERSION_FF7_102_FR:
		hext_patching_path += "/fr";
		break;
	case VERSION_FF7_102_DE:
		hext_patching_path += "/de";
		break;
	case VERSION_FF7_102_SP:
		hext_patching_path += "/es";
		break;
	case VERSION_FF8_12_US:
		hext_patching_path += "/en";
		break;
	case VERSION_FF8_12_US_NV:
		hext_patching_path += "/en_nv";
		break;
	case VERSION_FF8_12_FR:
		hext_patching_path += "/fr";
		break;
	case VERSION_FF8_12_FR_NV:
		hext_patching_path += "/fr_nv";
		break;
	case VERSION_FF8_12_DE:
		hext_patching_path += "/de";
		break;
	case VERSION_FF8_12_DE_NV:
		hext_patching_path += "/de_nv";
		break;
	case VERSION_FF8_12_SP:
		hext_patching_path += "/es";
		break;
	case VERSION_FF8_12_SP_NV:
		hext_patching_path += "/es_nv";
		break;
	case VERSION_FF8_12_IT:
		hext_patching_path += "/it";
		break;
	case VERSION_FF8_12_IT_NV:
		hext_patching_path += "/it_nv";
		break;
	case VERSION_FF8_12_US_EIDOS:
		hext_patching_path += "/en_eidos";
		break;
	case VERSION_FF8_12_US_EIDOS_NV:
		hext_patching_path += "/en_eidos_nv";
		break;
	case VERSION_FF8_12_JP:
		hext_patching_path += "/jp";
		break;
	case VERSION_FF8_12_JP_NV:
		hext_patching_path += "/jp_nv";
		break;
	}

	//OVERRIDE PATH
	if (override_path.empty())
		override_path = "override";

	// DIRECT MODE PATH
	if (direct_mode_path.empty())
		direct_mode_path = "direct";

	// EXTERNAL MOVIE FLAG
	if (enable_ffmpeg_videos < 0)
		enable_ffmpeg_videos = !ff8;

	// EXTERNAL MOVIE EXTENSION
	if (ffmpeg_video_ext.empty())
		ffmpeg_video_ext = "avi";

	// EXTERNAL MOVIE AUDIO EXTENSION
	if (external_movie_audio_ext.empty() || external_movie_audio_ext.front().empty())
		external_movie_audio_ext = std::vector<std::string>(1, "ogg");

	// EXTERNAL SFX PATH
	if (external_sfx_path.empty())
		external_sfx_path = "sfx";

	// EXTERNAL SFX EXTENSION
	if (external_sfx_ext.empty() || external_sfx_ext.front().empty())
		external_sfx_ext = std::vector<std::string>(1, "ogg");

	// EXTERNAL MUSIC EXTENSION
	if (external_music_ext.empty() || external_music_ext.front().empty())
		external_music_ext = std::vector<std::string>(1, "ogg");

	// EXTERNAL VOICE PATH
	if (external_voice_path.empty())
		external_voice_path = "voice";

	// EXTERNAL VOICE EXTENSION
	if (external_voice_ext.empty() || external_voice_ext.front().empty())
		external_voice_ext = std::vector<std::string>(1, "ogg");

	// EXTERNAL AMBIENT PATH
	if (external_ambient_path.empty())
		external_ambient_path = "ambient";

	// EXTERNAL AMBIENT EXTENSION
	if (external_ambient_ext.empty() || external_ambient_ext.front().empty())
		external_ambient_ext = std::vector<std::string>(1, "ogg");

	// EXTERNAL LIGHTING PATH
	if (external_lighting_path.empty())
		external_lighting_path = "lighting";

	// EXTERNAL WIDESCREEN PATH
	if (external_widescreen_path.empty())
		external_widescreen_path = "widescreen";

	// EXTERNAL TIME CYCLE
	if (external_time_cycle_path.empty())
		external_time_cycle_path = "time";

	// EXTERNAL MESH
	if (external_mesh_path.empty())
		external_mesh_path = "mesh";

	// MOD PATH
	if (mod_path.empty())
		mod_path = "mods/Textures";

	// MOD EXTENSION
	if (mod_ext.empty() || mod_ext.front().empty())
		mod_ext = {"dds", "png"};

	// AUDIO NUMBER OF CHANNELS
	if (external_audio_number_of_channels < 0)
		external_audio_number_of_channels = 0;
	else if (external_audio_number_of_channels % 2 != 0)
		// Round to the previous even number
		external_audio_number_of_channels--;

	// AUDIO SAMPLE RATE
	if (external_audio_sample_rate < 0)
		external_audio_sample_rate = 0;

	// EXTERNAL VIBRATE PATH
	if (external_vibrate_path.empty())
		external_vibrate_path = "vibrate";

	if (ff8)
		external_vibrate_path += "/ff8";
	else
		external_vibrate_path += "/ff7";

	// VOLUME
	if (external_music_volume > 100) external_music_volume = 100;
	if (external_sfx_volume > 100) external_sfx_volume = 100;
	if (external_voice_volume > 100) external_voice_volume = 100;
	if (external_ambient_volume > 100) external_ambient_volume = 100;
	if (ffmpeg_video_volume > 100) ffmpeg_video_volume = 100;

	// GAME LIGHTING
	if (ff8) game_lighting = GAME_LIGHTING_ORIGINAL;
	else if (enable_lighting) game_lighting = GAME_LIGHTING_PER_PIXEL;

	// DISPLAY INDEX
	if (display_index < 1) display_index = -1;
}
````

## File: src/cfg.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <string>
#include <vector>

#define RENDERER_BACKEND_AUTO 0
#define RENDERER_BACKEND_OPENGL 1
// Slot 2 used to be used for DIRECT3D9 but is not more officially supported by bgfx.
// Preserve the slot numbers as they are to ensure compatibility with existing installations and tooling.
#define RENDERER_BACKEND_DIRECT3D11 3
#define RENDERER_BACKEND_DIRECT3D12 4
#define RENDERER_BACKEND_VULKAN 5

#define FPS_LIMITER_ORIGINAL 0
#define FPS_LIMITER_DEFAULT 1
#define FPS_LIMITER_30FPS 2
#define FPS_LIMITER_60FPS 3

#define GAME_LIGHTING_ORIGINAL 0
#define GAME_LIGHTING_PER_VERTEX 1
#define GAME_LIGHTING_PER_PIXEL 2

extern std::string mod_path;
extern std::vector<std::string> mod_ext;
extern long enable_ffmpeg_videos;
extern std::string ffmpeg_video_ext;
extern std::vector<std::string> external_movie_audio_ext;
extern bool use_external_sfx;
extern std::string external_sfx_path;
extern std::vector<std::string> external_sfx_ext;
extern bool external_sfx_always_centered;
extern bool use_external_music;
extern bool external_music_resume;
extern bool external_music_sync;
extern std::string external_music_path;
extern std::vector<std::string> external_music_ext;
extern std::string he_bios_path;
extern std::string external_voice_path;
extern std::vector<std::string> external_voice_ext;
extern std::string external_ambient_path;
extern std::vector<std::string> external_ambient_ext;
extern std::string external_lighting_path;
extern std::string external_widescreen_path;
extern std::string external_time_cycle_path;
extern std::string external_mesh_path;
extern bool enable_voice_music_fade;
extern long external_voice_music_fade_volume;
extern bool enable_voice_auto_text;
extern bool save_textures;
extern bool save_textures_legacy;
extern bool save_exe_data;
extern bool trace_all;
extern bool trace_renderer;
extern bool trace_movies;
extern bool trace_music;
extern bool trace_sfx;
extern bool trace_fake_dx;
extern bool trace_direct;
extern bool trace_files;
extern bool trace_loaders;
extern bool trace_vram;
extern bool trace_lights;
extern bool trace_opcodes;
extern bool trace_voice;
extern bool trace_ambient;
extern bool trace_gamepad;
extern bool trace_achievement;
extern bool trace_battle_animation;
extern bool trace_battle_text;
extern bool vertex_log;
extern bool uniform_log;
extern bool show_renderer_backend;
extern bool show_fps;
extern bool show_stats;
extern bool show_version;
extern long window_size_x;
extern long window_size_y;
extern long internal_resolution_scale;
extern long aspect_ratio;
extern bool enable_uncrop;
extern bool fullscreen;
extern bool borderless;
extern long refresh_rate;
extern bool enable_vsync;
extern bool mdef_fix;
extern long enable_antialiasing;
extern bool enable_anisotropic;
extern bool enable_bilinear;
extern bool enable_lighting;
extern bool prefer_lighting_cpu_calculations;
extern long game_lighting;
extern bool enable_time_cycle;
extern bool enable_worldmap_external_mesh;
extern bool ff7_external_opening_music;
extern bool more_debug;
extern bool ff8_ssigpu_debug;
extern bool show_applog;
extern bool show_missing_textures;
extern bool show_error_popup;
extern long renderer_backend;
extern bool renderer_debug;
extern bool create_crash_dump;
extern std::string steam_game_userdata;
extern std::string hext_patching_path;
extern std::string override_path;
extern std::string override_mod_path;
extern std::string direct_mode_path;
extern std::string save_path;
extern bool enable_devtools;
extern long devtools_hotkey;
extern double speedhack_step;
extern double speedhack_max;
extern double speedhack_min;
extern bool enable_animated_textures;
extern std::vector<std::string> disable_animated_textures_on_field;
extern long ff7_fps_limiter;
extern bool ff7_footsteps;
extern bool ff7_field_center;
extern bool enable_analogue_controls;
extern bool enable_inverted_vertical_camera_controls;
extern bool enable_inverted_horizontal_camera_controls;
extern double left_analog_stick_deadzone;
extern double right_analog_stick_deadzone;
extern double left_analog_trigger_deadzone;
extern double right_analog_trigger_deadzone;
extern bool enable_auto_run;
extern std::string external_vibrate_path;
extern bool enable_steam_achievements;
extern bool steam_achievements_debug_mode;
extern double hdr_max_nits;
extern long external_audio_number_of_channels;
extern long external_audio_sample_rate;
extern bool ff8_worldmap_internal_highres_textures;
extern bool ff8_fix_uv_coords_precision;
extern bool ff8_external_music_force_original_filenames;
extern bool ff8_use_gamepad_icons;
extern bool ff8_always_capture_input;
extern long ff8_fps_limiter;
extern std::string app_path;
extern std::string data_drive;
extern bool enable_ntscj_gamut_mode;
extern long external_music_volume;
extern long external_sfx_volume;
extern long external_voice_volume;
extern long external_ambient_volume;
extern long ffmpeg_video_volume;
extern bool ff7_advanced_blinking;
extern long display_index;

void read_cfg();
````

## File: src/common_imports.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <windows.h>
#include <stdint.h>

#include "matrix.h"

/*
 * Render states supported by the graphics engine
 *
 * Not all of these were implemented in the original games, even fewer are
 * actually required. Named after corresponding Direct3D states.
 */
enum effects
{
	V_WIREFRAME,			      // 0x1
	V_TEXTURE,				      // 0x2
	V_LINEARFILTER,			    // 0x4
	V_PERSPECTIVE,			    // 0x8
	V_TMAPBLEND,			      // 0x10
	V_WRAP_U,				        // 0x20
	V_WRAP_V,				        // 0x40
	V_UNKNOWN80,			      // 0x80
	V_COLORKEY,				      // 0x100
	V_DITHER,				        // 0x200
	V_ALPHABLEND,			      // 0x400
	V_ALPHATEST,			      // 0x800
	V_ANTIALIAS,			      // 0x1000
	V_CULLFACE,				      // 0x2000
	V_NOCULL,				        // 0x4000
	V_DEPTHTEST,			      // 0x8000
	V_DEPTHMASK,			      // 0x10000
	V_SHADEMODE,			      // 0x20000
	V_SPECULAR,				      // 0x40000
	V_LIGHTSTATE,			      // 0x80000
	V_FOG,					        // 0x100000
	V_TEXADDR,				      // 0x200000
	V_UNKNOWN400000,        // 0x400000
	V_UNKNOWN800000,        // 0x800000
	V_ALPHAFUNC,            // 0x1000000
	V_ALPHAREF,             // 0x2000000
	V_UNKNOWNFFFDFBFD,      // 0xFFFDFBFD
	V_UNKNOWNFFFDFFFD,      // 0xFFFDFFFD
};

// helper definitions for all the different functions which should be provided by the graphics driver
typedef uint32_t (gfx_init)(struct game_obj *);
typedef void (gfx_cleanup)(struct game_obj *);
typedef uint32_t (gfx_lock)(uint32_t);
typedef uint32_t (gfx_unlock)(uint32_t);
typedef void (gfx_flip)(struct game_obj *);
typedef void (gfx_clear)(uint32_t, uint32_t, uint32_t, struct game_obj *);
typedef void (gfx_clear_all)(struct game_obj *);
typedef void (gfx_setviewport)(uint32_t, uint32_t, uint32_t, uint32_t, struct game_obj *);
typedef void (gfx_setbg)(struct bgra_color *, struct game_obj *);
typedef uint32_t (gfx_prepare_polygon_set)(struct polygon_set *);
typedef uint32_t (gfx_load_group)(uint32_t, struct matrix_set *, struct p_hundred *, struct p_group *, struct polygon_data *, struct polygon_set *, struct game_obj *);
typedef void (gfx_setmatrix)(uint32_t, struct matrix *, struct matrix_set *, struct game_obj *);
typedef void (gfx_unload_texture)(struct texture_set *);
typedef struct texture_set *(gfx_load_texture)(struct texture_set *, struct tex_header *, struct texture_format *);
typedef uint32_t (gfx_palette_changed)(uint32_t, uint32_t, uint32_t, struct palette *, struct texture_set *);
typedef uint32_t (gfx_write_palette)(uint32_t, uint32_t, void *, uint32_t, struct palette *, struct texture_set *);
typedef struct blend_mode *(gfx_blendmode)(uint32_t, struct game_obj *);
typedef void (gfx_light_polygon_set)(struct polygon_set *, struct light *);
typedef void (gfx_field_64)(uint32_t, uint32_t, struct game_obj *);
typedef void (gfx_setrenderstate)(struct p_hundred *, struct game_obj *);
typedef void (gfx_field_74)(uint32_t, struct game_obj *);
typedef void (gfx_field_78)(struct polygon_set *, struct game_obj *);
typedef void (gfx_draw_deferred)(struct struc_77 *, struct game_obj *);
typedef void (gfx_field_80)(struct graphics_object *, struct game_obj *);
typedef void (gfx_field_84)(uint32_t, struct game_obj *);
typedef uint32_t (gfx_begin_scene)(uint32_t, struct game_obj *);
typedef void (gfx_end_scene)(struct game_obj *);
typedef void (gfx_field_90)(uint32_t);
typedef void (gfx_polysetrenderstate)(struct polygon_set *, struct indexed_vertices *, struct game_obj *);
typedef void (gfx_draw_vertices)(struct polygon_set *, struct indexed_vertices *, struct game_obj *);
typedef void (gfx_field_EC)(struct game_obj *);

/*
 * This section defines some structures used internally by both game engines.
 *
 * Documentation for some of them can be found on the Qhimm wiki, a lot of
 * information can be gleaned from the source code to this program but in many
 * cases nothing is known except the size and general layout of the structure.
 *
 * Variable and structure names are mostly based on what they contain rather
 * than what they are for, a lot of names may be wrong, inappropriate or
 * downright misleading. Thread with caution!
 */

struct color_ui8
{
    byte r;
    byte g;
    byte b;
    byte a;
};

struct bgra_color_ui8
{
    byte b;
    byte g;
    byte r;
    byte a;
};

struct bgra_color
{
	float b;
	float g;
	float r;
	float a;
};

struct rgba_color
{
	float r;
	float g;
	float b;
	float a;
};

typedef struct {
	short x, y, z, res;		// short is a 2 byte signed integer
} vertex_3s;

struct struc_81
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t field_8;
	uint32_t field_C;
	uint32_t field_10;
	uint32_t field_14;
	uint32_t field_18;
	uint32_t field_1C;
	uint32_t blend_mode;
	uint32_t vertexcolor;
	struct texture_set *texture_set;
};

struct struc_173
{
	unsigned char color_op;
	unsigned char field_1;
	unsigned char scroll_uv;
	unsigned char scroll_v;
	unsigned char change_palette;
	unsigned char setrenderstate;
	unsigned char add_offsets;
	unsigned char field_7;
	color_ui8 color;
	uint32_t field_C;
	uint32_t field_10;
	uint32_t x_offset;
	uint32_t y_offset;
	uint32_t z_offset;
	uint32_t z_offset2;
	float u_offset;
	float v_offset;
	uint32_t palette_index;
	struct p_hundred *hundred_data;
	unsigned char field_34[16];
};

struct struc_77
{
	struct struc_77 *next;
	uint32_t current_group;
	struct polygon_set *polygon_set;
	struct p_hundred *hundred_data;
	uint32_t use_matrix;
	struct matrix matrix;
	uint32_t use_matrix_pointer;
	struct matrix *matrix_pointer;
	struct struc_173 struc_173;
};

struct heap
{
	struct heap *next;
	uint32_t size;					// ?
	struct heap *last;			// ?
	uint32_t field_C;
	uint32_t field_10;
	uint32_t field_14;
	int (*fn_something)(uint32_t, int);
	uint32_t field_1C;
	uint32_t field_20;
	uint32_t field_24;
	uint32_t field_28;
	uint32_t field_2C;
	uint32_t field_30;
	void *callback_data;
	void *callback;
};

struct graphics_instance
{
	uint32_t frame_counter;
	struct heap *heap;
};

struct p_edge
{
	WORD vertex1;
	WORD vertex2;
};

struct texcoords
{
	float u;
	float v;
};

struct p_polygon
{
	WORD field_0;
	WORD vertex1;
	WORD vertex2;
	WORD vertex3;
	WORD normals[3];
	WORD edges[3];
	uint32_t field_14;
};

struct p_group
{
	uint32_t polytype;
	uint32_t offpoly;
	uint32_t numpoly;
	uint32_t offvert;
	uint32_t numvert;
	uint32_t offedge;
	uint32_t numedge;
	uint32_t field_1C;
	uint32_t field_20;
	uint32_t field_24;
	uint32_t field_28;
	uint32_t offtex;
	uint32_t textured;
	uint32_t texid;
};

struct boundingbox
{
	uint32_t field_0;
	float max_x;
	float max_y;
	float max_z;
	float min_x;
	float min_y;
	float min_z;
};

struct nvertex
{
	vector3<float> _;

	union
	{
		struct
		{
			float w;
			union
			{
				uint32_t color;
				struct
				{
					unsigned char b;
					unsigned char g;
					unsigned char r;
					unsigned char a;
				};
			};
			uint32_t specular;
		} color;

		vector3<float> normal;
	};

	float u;
	float v;
};

struct struc_186
{
	struct graphics_object *graphics_object;
	uint32_t polytype;
	uint32_t field_8;
	vector3<float> vertices[4];
	struct texcoords texcoords[4];
	color_ui8 colors[4];
	float w[4];
	struct nvertex *nvertex_pointer;
	uint32_t palette_index;
};

struct struc_84
{
	struct struc_84 *next;
	uint32_t field_4;
	struct struc_186 *struc_186;
	struct matrix matrix;
	struct struc_173 struc_173;
};

struct struc_49
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t field_8;
	uint32_t frame_counter;
	struct struc_84 *struc_84;
	struct graphics_instance *graphics_instance;
};

struct indexed_primitive
{
	uint32_t field_0;
	uint32_t vertex_size;
	uint32_t primitivetype;
	uint32_t vertextype;
	struct nvertex *vertices;
	uint32_t vertexcount;
	WORD *indices;
	uint32_t indexcount;
	uint32_t flags;
	uint32_t field_24;
};

struct matrix_set
{
	uint32_t field_0;
	uint32_t size;
	uint32_t field_8;
	uint32_t field_C;
	struct matrix *matrix_array;
	struct matrix *matrix_world;
	struct matrix *matrix_view;
	struct matrix *matrix_projection;
	void *d3dmatrix_world;
	void *d3dmatrix_view;
	void *d3dmatrix_projection;
};

struct polygon_data
{
	uint32_t version;
	uint32_t field_4;
	uint32_t vertextype;
	uint32_t numverts;
	uint32_t numnormals;
	uint32_t field_14;
	uint32_t numtexcoords;
	uint32_t numvertcolors;
	uint32_t numedges;
	uint32_t numpolys;
	uint32_t field_28;
	uint32_t field_2C;
	uint32_t numhundreds;
	uint32_t numgroups;
	uint32_t numboundingboxes;
	uint32_t has_normindextable;
	vector3<float> *vertdata;
	vector3<float> *normaldata;
	vector3<float> *field_48;
	struct texcoords *texcoorddata;
	uint32_t *vertexcolordata;
	uint32_t *polycolordata;
	struct p_edge *edgedata;
	struct p_polygon *polydata;
	char *pc_name;
	void *field_64;
	struct p_hundred *hundredsdata;
	struct p_group *groupdata;
	struct boundingbox *boundingboxdata;
	uint32_t *normindextabledata;
	uint32_t field_78;
	struct polygon_lists *lists;
};

struct p_hundred
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t options;
	uint32_t features;
	uint32_t field_10;
	struct texture_set *texture_set;
	uint32_t field_18;
	uint32_t field_1C;
	uint32_t field_20;
	uint32_t shademode;
	uint32_t lightstate_ambient;
	uint32_t field_2C;
	void *lightstate_material_pointer;
	uint32_t srcblend;
	uint32_t destblend;
	uint32_t field_3C;
	uint32_t alpharef;
	uint32_t blend_mode;
	uint32_t zsort;
	uint32_t field_4C;
	uint32_t field_50;
	uint32_t field_54;
	uint32_t field_58;
	uint32_t vertex_alpha;
	uint32_t field_60;
};

struct texture_format
{
	uint32_t width;
	uint32_t height;
	uint32_t bytesperrow;
	void *field_C;
	uint32_t use_palette;
	uint32_t bitsperindex;
	uint32_t indexed_to_8bit;
	uint32_t palette_size;				// ?
	uint32_t palettes;					// ?
	uint32_t *palette_data;
	uint32_t bitsperpixel;
	uint32_t bytesperpixel;
	uint32_t red_bits;
	uint32_t green_bits;
	uint32_t blue_bits;
	uint32_t alpha_bits;
	uint32_t red_mask;
	uint32_t green_mask;
	uint32_t blue_mask;
	uint32_t alpha_mask;
	uint32_t red_shift;
	uint32_t green_shift;
	uint32_t blue_shift;
	uint32_t alpha_shift;
	uint32_t red_truecolor_bitdiff;		// 8 - red_bits
	uint32_t green_truecolor_bitdiff;	// 8 - green_bits
	uint32_t blue_truecolor_bitdiff;	// etc
	uint32_t alpha_truecolor_bitdiff;
	uint32_t red_max;
	uint32_t green_max;
	uint32_t blue_max;
	uint32_t alpha_max;
};

struct struc_91
{
	uint32_t field_0;
	uint32_t x_offset;
	uint32_t y_offset;
	uint32_t width;
	uint32_t height;
	uint32_t xscale;
	uint32_t yscale;
	uint32_t color_key;
	uint32_t width2;
	uint32_t height2;
	uint32_t pitch2;
	uint32_t bytesperpixel2;
	void *image_data2;
	struct texture_format tex_format;
	void *image_data;
};

struct palette
{
	uint32_t field_0;
	uint32_t palette_size;
	uint32_t bitsperpixel;
	uint32_t total_palettes;
	uint32_t palette_entries;
	uint32_t field_14;
	uint32_t field_18;
	uint32_t field_1C;
	uint32_t field_20;
	void *d3dcolorpal;
	void *rgbapal;
	void *palette_entry;
	uint32_t ddpalette;
	tex_header* tex_header;
	texture_set* texture_set;
	uint32_t field_3C;
};

struct blend_mode
{
	uint32_t field_0;
	uint32_t zsort;
	uint32_t vertex_alpha;
	uint32_t srcblendmode;
	uint32_t srcblendcaps;
	uint32_t destblendmode;
	uint32_t destblendcaps;
	uint32_t field_1C;
	uint32_t field_20;
};

typedef struct
{
	char dummy[0xCC];
} D3DDEVICEDESC;

typedef void* main_obj_fn(struct game_obj*);

struct main_obj
{
	main_obj_fn *init;
	main_obj_fn *cleanup;
	main_obj_fn *enter_main;
	main_obj_fn *exit_main;
	main_obj_fn *main_loop;
	main_obj_fn *field_14;
	main_obj_fn *field_18;
};
````

## File: src/common.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2020 Marcin Gomulak                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <dwmapi.h>
#include <stdio.h>
#include <sys/timeb.h>
#include <steamworkssdk/steam_api.h>
#include <hwinfo/hwinfo.h>
#include <regex>
#include <shlwapi.h>
#include <shlobj.h>
#include <psapi.h>
#include <mmsystem.h>
#include <malloc.h>
#include <ddraw.h>
#include <filesystem>
#include <fstream>

#include "renderer.h"
#include "hext.h"
#include "ff8_data.h"

#include "crashdump.h"
#include "macro.h"
#include "ff7.h"
#include "ff8.h"
#include "patch.h"
#include "gl.h"
#include "movies.h"
#include "music.h"
#include "sfx.h"
#include "saveload.h"
#include "gamepad.h"
#include "joystick.h"
#include "input.h"
#include "field.h"
#include "world.h"
#include "gamehacks.h"
#include "audio.h"
#include "voice.h"
#include "metadata.h"
#include "lighting.h"
#include "achievement.h"
#include "game_cfg.h"
#include "exe_data.h"
#include "utils.h"

#include "ff7/defs.h"
#include "ff7/widescreen.h"
#include "ff7/time.h"
#include "ff7/field/defs.h"

#include "ff8/vram.h"
#include "ff8/vibration.h"
#include "ff8/engine.h"
#include "ff8/uv_patch.h"
#include "ff8/ambient.h"
#include "ff8/file.h"

#include "wine.h"

bool proxyWndProc = false;

namespace GameWindowState {
	enum GameWindowState
	{
		CURRENT,
		PRE_FULLSCREEN,
		COUNT
	};
};

struct {
	uint32_t x;
	uint32_t y;
	uint32_t w;
	uint32_t h;
} gameWindow[GameWindowState::COUNT];

struct MonitorInfo {
	RECT rcMonitor;
	std::string deviceName;
};
std::vector<MonitorInfo> monitors;

// global game window handler
RECT gameWindowRect;
HINSTANCE gameHinstance;
HWND gameHwnd;
DEVMODE dmCurrentScreenSettings;
DEVMODE dmNewScreenSettings;
bool gameWindowWasMaximized = false;
bool gameWindowMoving = false;

// global RAM status
MEMORYSTATUSEX last_ram_state = { sizeof(last_ram_state) };

// global FF7/FF8 flag, available after version check
uint32_t ff8 = false;

uint32_t ff7_do_reset = false;

// global FF7/FF8 flag, check if is steam edition
uint32_t steam_edition = false;

// global FF7/FF8 flag, check if using the steam stock launcher
uint32_t steam_stock_launcher = false;

// global FF7 flag, check if is eStore edition
uint32_t estore_edition = false;

// global FF7 flag, check if is japanese edition ( detected as US )
uint32_t ff7_japanese_edition = false;

// window dimensions requested by the game, normally 640x480
uint32_t game_width;
uint32_t game_height;

// offset from screen edge to start of content, for aspect correction
uint32_t x_offset = 0;
uint32_t y_offset = 0;

// widescreen mode enabled
uint32_t widescreen_enabled = false;

// game-specific data, see ff7_data.h/ff8_data.h
uint32_t text_colors[NUM_TEXTCOLORS];
struct game_mode modes[64];
uint32_t num_modes;

// memory locations, replaced functions or patching offsets
// some addresses in FF7 are sourced from static tables in the
// externals_102_xx.h files but most of them are computed at runtime,
// see ff7_data.h/ff8_data.h
struct common_externals common_externals;
struct ff7_externals ff7_externals;
struct ff8_externals ff8_externals;

// various statistics, collected for display purposes only EXCEPT for the
// external cache size
struct driver_stats stats;

// on-screen popup messages
char popup_msg[1024];
uint32_t popup_ttl = 0;
uint32_t popup_color;

// scene stack used to save render state when the game calls begin/end scene
struct driver_state scene_stack[8];
uint32_t scene_stack_pointer = 0;

// global frame counter
uint32_t frame_counter = 0;
double frame_rate = 0;
int battle_frame_multiplier = 1;
int common_frame_multiplier = 1;

// default 32-bit BGRA texture format presented to the game
struct texture_format *texture_format;

// install directory for the current game
char basedir[BASEDIR_LENGTH];

uint32_t version;

bool xinput_connected = false;

bool simulate_OK_button = false;

GamepadAnalogueIntent gamepad_analogue_intent = INTENT_NONE;

uint32_t *image_data_cache = nullptr;
uint32_t image_data_size_cache = 0;

uint32_t noop() { return 0; }
uint32_t noop_a1(uint32_t a1) { return 0; }
uint32_t noop_a2(uint32_t a1, uint32_t a2) { return 0; }
uint32_t noop_a3(uint32_t a1, uint32_t a2, uint32_t a3) { return 0; }

// global data used for profiling macros
#ifdef PROFILE
time_t profile_start;
time_t profile_end;
time_t profile_total;
#endif PROFILE

// support code for the HEAP_DEBUG option
#ifdef HEAP_DEBUG
uint32_t allocs = 0;

void *driver_malloc(uint32_t size)
{
	void *tmp = malloc(size);
	ffnx_trace("%i: malloc(%i) = 0x%x\n", ++allocs, size, tmp);
	return tmp;
}

void *driver_calloc(uint32_t size, uint32_t num)
{
	void *tmp = calloc(size, num);
	ffnx_trace("%i: calloc(%i, %i) = 0x%x\n", ++allocs, size, num, tmp);
	return tmp;
}

void driver_free(void *ptr)
{
	if(!ptr) return;

	ffnx_trace("%i: free(0x%x)\n", --allocs, ptr);
	free(ptr);
}

void *driver_realloc(void *ptr, uint32_t size)
{
	void *tmp = realloc(ptr, size);
	ffnx_trace("%i: realloc(0x%x, %i) = 0x%x\n", allocs, ptr, size, tmp);
	return tmp;
}
#endif

// support code for the NO_EXT_HEAP option
#ifdef NO_EXT_HEAP

void ext_free(void *ptr, const char *file, uint32_t line)
{
	driver_free(ptr);
}

void *ext_malloc(uint32_t size, const char *file, uint32_t line)
{
	return driver_malloc(size);
}

void *ext_calloc(uint32_t size, uint32_t num, const char *file, uint32_t line)
{
	return driver_calloc(size, num);
}
#endif

void ffmpeg_log_callback(void* ptr, int level, const char* fmt, va_list vl)
{
	char msg[4 * 1024]; // 4K
	static int print_prefix = 1;

	av_log_format_line(ptr, level, fmt, vl, msg, sizeof(msg), &print_prefix);

	switch (level) {
	case AV_LOG_VERBOSE:
	case AV_LOG_DEBUG: if (trace_movies) ffnx_trace(msg); break;
	case AV_LOG_INFO:
	case AV_LOG_WARNING: if (trace_movies) ffnx_info(msg); break;
	case AV_LOG_ERROR:
	case AV_LOG_FATAL:
	case AV_LOG_PANIC: ffnx_error(msg); break;
	}

	if (level <= AV_LOG_ERROR) {
		FFNxStackWalker sw;
		sw.ShowCallstack();
	}
}

void ffnx_log_current_pc_specs()
{
	// Start report of PC specs
	ffnx_info("--- PC SPECS ---\n");

	// CPU
	auto cpus = hwinfo::getAllCPUs();
	for (const auto& cpu : cpus) {
		ffnx_info("   CPU: %s\n", cpu.modelName().c_str());
	}

	// GPU
	auto gpus = hwinfo::getAllGPUs();
	for (auto& gpu : gpus) {
		uint16_t vendorId = std::stoi(gpu.vendor_id(), 0, 16), deviceId = std::stoi(gpu.device_id(), 0, 16);
		if (
			(newRenderer.getCaps()->vendorId == vendorId && newRenderer.getCaps()->deviceId == deviceId) ||
			(newRenderer.getCaps()->vendorId == vendorId && renderer_backend == RENDERER_BACKEND_OPENGL)
		)
			ffnx_info("   GPU: %s (%dMB) - Driver: %s - Backend: %s\n", gpu.name().c_str(), (int)(gpu.memory_Bytes() / 1024.0 / 1024.0), gpu.driverVersion().c_str(), newRenderer.currentRenderer.c_str());
	}

	// RAM
	hwinfo::Memory memory;
	ffnx_info("   RAM: %dMB/%dMB (Free: %dMB)\n", (int)((memory.total_Bytes() - memory.free_Bytes()) / 1024.0 / 1024.0), (int)(memory.total_Bytes() / 1024.0 / 1024.0), (int)(memory.free_Bytes() / 1024.0 / 1024.0));

	// OS
	hwinfo::OS os;
	ffnx_info("    OS: %s %s (build %s)\n", os.name().c_str(), (os.is32bit() ? "32 bit" : "64 bit"), os.version().c_str());

	// WINE+PROTON
	const char* env_wineloader = std::getenv("WINELOADER");
	if (env_wineloader != NULL) // Are we running under Wine/Proton?
	{
		ffnx_info("  WINE: v%s\n", GetWineVersion());

		const std::regex proton_regex("([Pp]roton[\\s\\-\\w.()]+)");
		std::smatch base_match;
		std::string s_wineloader = std::string(env_wineloader);
		if (std::regex_search(s_wineloader, base_match, proton_regex))
			ffnx_info("PROTON: %s\n", base_match[1].str().c_str());
	}

	// End report of PC specs
	ffnx_info("----------------\n");
}

// figure out which game module is currently running by looking at the game's
// own mode variable and the address of the current main function
struct game_mode *getmode()
{
	static uint32_t last_mode = 0;
	VOBJ(game_obj, game_object, common_externals.get_game_object());
	uint32_t i;

	// find exact match, mode and main loop both match
	for(i = 0; i < num_modes; i++)
	{
		struct game_mode *m = &modes[i];

		if(m->main_loop == (uint32_t)VREF(game_object, game_loop_obj).main_loop && m->mode == *common_externals._mode)
		{
			if(last_mode != m->mode)
			{
				if(m->trace) ffnx_trace("%s\n", m->name);
				last_mode = m->mode;
			}

			if (trace_all) ffnx_trace("getmode: exact match - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);

			return m;
		}
	}

	// FF8 has BATTLE and CARDGAME baked inside the same module
	// Only for this case use a custom match logic
	if (ff8)
	{
		for(i = 0; i < num_modes; i++)
		{
			struct game_mode *m = &modes[i];

			if (*ff8_externals.is_card_game == 1 && *common_externals._mode == m->mode)
			{
				if (trace_all) ffnx_trace("getmode: exact match - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);

				return m;
			}
		}
	}

	// if there is no exact match, try to find a match by main loop only
	for(i = 0; i < num_modes; i++)
	{
		struct game_mode *m = &modes[i];

		if(m->main_loop && m->main_loop == (uint32_t)VREF(game_object, game_loop_obj).main_loop)
		{
			if(last_mode != m->mode)
			{
				if(m->mode != *common_externals._mode && m->trace)
				{
					uint32_t j;
					struct game_mode *_m = NULL;

					for(j = 0; j < num_modes - 1; j++)
					{
						_m = &modes[j];

						if(_m->mode == *common_externals._mode) break;
					}

					if (trace_all) ffnx_trace("getmode: mismatched mode, %s -> %s\n", _m->name, m->name);
				}
				if(m->trace) ffnx_trace("%s\n", m->name);
				last_mode = m->mode;
			}

			if (trace_all) ffnx_trace("getmode: no exact match, found by main loop - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);

			return m;
		}
	}

	// finally, ignore main loop and try to match by mode only
	for(i = 0; i < num_modes; i++)
	{
		struct game_mode *m = &modes[i];

		if(m->mode == *common_externals._mode)
		{
			if(last_mode != m->mode)
			{
				if(m->trace) ffnx_trace("%s\n", m->name);
				last_mode = m->mode;
			}

			if (trace_all) ffnx_trace("getmode: ignore main loop, match by mode only - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);

			return m;
		}
	}

	if(*common_externals._mode != last_mode)
	{
		ffnx_unexpected("unknown mode (%i, 0x%x)\n", *common_externals._mode, (uint32_t)VREF(game_object, game_loop_obj).main_loop);
		last_mode = *common_externals._mode;
	}

	if(!ff8) return &modes[4];
	else return &modes[11];
}

// game mode usually doesn't change in the middle of a frame and even if it
// does we usually don't care until the next frame so we can safely cache it to
// avoid constant lookups
struct game_mode *getmode_cached()
{
	static uint32_t last_frame = -1;
	static struct game_mode *last_mode;

	if(frame_counter != last_frame)
	{
		last_mode = getmode();
		last_frame = frame_counter;
	}

	return last_mode;
}

char* get_current_field_name()
{
	if (ff8) {
		return common_externals.current_field_name;
	}

	char *ret = strrchr(ff7_externals.field_file_name, 92);

	if (ret) ret += 1;

	return ret;
}

bool maximized(HWND hwnd) {
	WINDOWPLACEMENT placement;
	if (!GetWindowPlacement(hwnd, &placement)) {
				return false;
	}

	return placement.showCmd == SW_MAXIMIZE;
}

/* Adjust client rect to not spill over monitor edges when maximized.
* rect(in/out): in: proposed window rect, out: calculated client rect
* Does nothing if the window is not maximized.
*/
void adjust_maximized_client_rect(HWND window, RECT& rect) {
	if (!maximized(window)) {
			return;
	}

	auto monitor = MonitorFromWindow(window, MONITOR_DEFAULTTONULL);
	if (!monitor) {
			return;
	}

	MONITORINFO monitor_info{};
	monitor_info.cbSize = sizeof(monitor_info);
	if (!GetMonitorInfoW(monitor, &monitor_info)) {
			return;
	}

	// when maximized, make the client area fill just the monitor (without task bar) rect,
	// not the whole window rect which extends beyond the monitor.
	rect = monitor_info.rcWork;
}

bool composition_enabled() {
	BOOL composition_enabled = FALSE;
	bool success = DwmIsCompositionEnabled(&composition_enabled) == S_OK;
	return composition_enabled && success;
}

LRESULT window_hit_test(HWND hwnd, POINT cursor) {
	// identify borders and corners to allow resizing the window.
	// Note: On Windows 10, windows behave differently and
	// allow resizing outside the visible window frame.
	// This implementation does not replicate that behavior.
	const POINT border{
			::GetSystemMetrics(SM_CXFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER),
			::GetSystemMetrics(SM_CYFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER)
	};
	SetRectEmpty(&gameWindowRect);
	if (!::GetWindowRect(hwnd, &gameWindowRect)) {
			return HTNOWHERE;
	}

	enum region_mask {
			client = 0b0000,
			left   = 0b0001,
			right  = 0b0010,
			top    = 0b0100,
			bottom = 0b1000,
	};

	const auto result =
			left    * (cursor.x <  (gameWindowRect.left   + border.x)) |
			right   * (cursor.x >= (gameWindowRect.right  - border.x)) |
			top     * (cursor.y <  (gameWindowRect.top    + border.y)) |
			bottom  * (cursor.y >= (gameWindowRect.bottom - border.y));

	switch (result) {
			case left          : return HTLEFT;
			case right         : return HTRIGHT;
			case top           : return HTTOP;
			case bottom        : return HTBOTTOM;
			case top | left    : return HTTOPLEFT;
			case top | right   : return HTTOPRIGHT;
			case bottom | left : return HTBOTTOMLEFT;
			case bottom | right: return HTBOTTOMRIGHT;
			case client        : return HTCAPTION;
			default            : return HTNOWHERE;
	}
}

void set_window_shadow() {
	if (composition_enabled()) {
		static const MARGINS shadow_state{1,1,1,1};
		::DwmExtendFrameIntoClientArea(gameHwnd, &shadow_state);
	}
}

void toggle_borderless() {
	DWORD style = borderless ? WS_POPUP | WS_THICKFRAME | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX : WS_OVERLAPPEDWINDOW;

	SetWindowLongPtr(gameHwnd, GWL_STYLE, style | WS_VISIBLE);

	set_window_shadow();

	SetWindowPos(gameHwnd, HWND_TOP, 0, 0, borderless ? window_size_x : gameWindow[GameWindowState::CURRENT].w, borderless ? window_size_y : gameWindow[GameWindowState::CURRENT].h, SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
	ShowWindow(gameHwnd, SW_SHOW);
}

void calc_window_size(uint32_t width, uint32_t height) {
	SetRectEmpty(&gameWindowRect);

	gameWindowRect.right = width;
	gameWindowRect.bottom = height;

	AdjustWindowRect(&gameWindowRect, WS_OVERLAPPEDWINDOW, false);
	gameWindow[GameWindowState::CURRENT].w = gameWindowRect.right - gameWindowRect.left;
	gameWindow[GameWindowState::CURRENT].h = gameWindowRect.bottom - gameWindowRect.top;

	// Center the window on the screen
	gameWindow[GameWindowState::CURRENT].x = (dmCurrentScreenSettings.dmPelsWidth / 2) - (gameWindow[GameWindowState::CURRENT].w / 2);
	gameWindow[GameWindowState::CURRENT].y = (dmCurrentScreenSettings.dmPelsHeight / 2) - (gameWindow[GameWindowState::CURRENT].h / 2);
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (proxyWndProc)
	{
		switch (uMsg)
		{
		case WM_NCCALCSIZE:
			if (wParam == TRUE && borderless) {
					auto& params = *reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam);
					adjust_maximized_client_rect(hwnd, params.rgrc[0]);
					return 0;
			}
			break;
		case WM_NCHITTEST:
			// When we have no border or title bar, we need to perform our
			// own hit testing to allow resizing and moving.
			if (borderless) {
					return window_hit_test(gameHwnd, POINT{
							GET_X_LPARAM(lParam),
							GET_Y_LPARAM(lParam)
					});
			}
			break;
		case WM_NCACTIVATE:
			if (!composition_enabled()) {
					// Prevents window frame reappearing on window activation
					// in "basic" theme, where no aero shadow is present.
					return 1;
			}
			break;
		case WM_KEYDOWN:
			if ((::GetKeyState(VK_CONTROL) & 0x8000) != 0)
			{
				switch (LOWORD(wParam))
				{
				case VK_F11:
					newRenderer.toggleCaptureFrame();
					break;
				}
			}
			else if ((::GetKeyState(VK_SHIFT) & 0x8000) != 0)
			{
				switch (LOWORD(wParam))
				{
				case VK_LEFT:
					if (!widescreen_enabled)
					{
						aspect_ratio--;
						if (aspect_ratio < 0) aspect_ratio = AR_STRETCH;

						show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Aspect Ratio Mode: %u", aspect_ratio);

						newRenderer.reset();
					}
					break;
				case VK_RIGHT:
					if (!widescreen_enabled)
					{
						aspect_ratio++;
						if (aspect_ratio > AR_STRETCH) aspect_ratio = AR_ORIGINAL;

						show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Aspect Ratio Mode: %u", aspect_ratio);

						newRenderer.reset();
					}
					break;
				case VK_RETURN:
					if (!fullscreen)
					{
						borderless = !borderless;
						toggle_borderless();
						newRenderer.reset();
					}
					break;
				}
			}
			break;
		case WM_SIZE:
			window_size_x = (long)LOWORD(lParam);
			window_size_y = (long)HIWORD(lParam);

			calc_window_size(window_size_x, window_size_y);

			if (wParam != SIZE_MINIMIZED) newRenderer.reset();

			if (wParam == SIZE_MAXIMIZED) gameWindowWasMaximized = true;
			else if (wParam == SIZE_RESTORED && gameWindowWasMaximized) gameWindowWasMaximized = false;
			else break;
		case WM_ENTERSIZEMOVE:
			gameWindowMoving = true;
			break;
		case WM_MOVE:
			if (gameWindowMoving) {
				if (!ff8){
					if (ff7_externals.movie_object->is_playing) ff7_core_game_loop();
				}
			}
			break;
		case WM_EXITSIZEMOVE:
			gameWindowMoving = false;
			newRenderer.reset();
			break;
		case WM_MENUCHAR:
			if (LOWORD(wParam) == VK_RETURN)
			{
				const auto& targetMonitor = monitors[display_index-1];
				if (fullscreen)
				{
					// Bring back the original resolution
					ChangeDisplaySettingsExA(targetMonitor.deviceName.c_str(), &dmCurrentScreenSettings, 0, CDS_FULLSCREEN, 0);

					// Move to window
					SetWindowLongPtr(gameHwnd, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);
					MoveWindow(gameHwnd, gameWindow[GameWindowState::PRE_FULLSCREEN].x, gameWindow[GameWindowState::PRE_FULLSCREEN].y, gameWindow[GameWindowState::PRE_FULLSCREEN].w, gameWindow[GameWindowState::PRE_FULLSCREEN].h, true);

					// Show the cursor
					while (ShowCursor(true) < 0);

					fullscreen = false;
				}
				else
				{
					// Save current window state
					gameWindow[GameWindowState::PRE_FULLSCREEN] = gameWindow[GameWindowState::CURRENT];

					// Bring back the user resolution
					ChangeDisplaySettingsExA(targetMonitor.deviceName.c_str(), &dmNewScreenSettings, 0, CDS_FULLSCREEN, 0);

					// Move to fullscreen
					SetWindowLongPtr(gameHwnd, GWL_STYLE, WS_SYSMENU | WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE);
					MoveWindow(gameHwnd, 0, 0, dmNewScreenSettings.dmPelsWidth, dmNewScreenSettings.dmPelsHeight, true);

					// Hide the cursor
					if (!enable_devtools) while (ShowCursor(false) >= 0);

					fullscreen = true;
					borderless = false;
				}

				newRenderer.reset();

				return MAKELRESULT(0, MNC_CLOSE);
			}
			break;
		case WM_CLOSE:
		case WM_QUIT:
			if (ff8) ff8_release_movie_objects();
			else ff7_release_movie_objects();

			gl_cleanup_deferred();

			SetWindowLongA(gameHwnd, GWL_WNDPROC, (LONG)common_externals.engine_wndproc);
			break;
		}

		HandleInputEvents(uMsg, wParam, lParam);
	}

	gamehacks.processKeyboardInput(uMsg, wParam, lParam);

	return common_externals.engine_wndproc(hwnd, uMsg, wParam, lParam);
}

BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
	std::vector<MonitorInfo>* monitors = reinterpret_cast<std::vector<MonitorInfo>*>(dwData);

	MONITORINFOEX monitorInfoEx;
	monitorInfoEx.cbSize = sizeof(MONITORINFOEX);

	if (GetMonitorInfo(hMonitor, &monitorInfoEx)) {
		bool isPrimary = (monitorInfoEx.dwFlags & MONITORINFOF_PRIMARY) != 0;
		monitors->push_back({ monitorInfoEx.rcMonitor, monitorInfoEx.szDevice });
		if (isPrimary && display_index < 1) display_index = monitors->size();
	}

	return TRUE;
}

int common_create_window(HINSTANCE hInstance, struct game_obj* game_object)
{
	uint32_t ret = FALSE;

	VOBJ(game_obj, game_object, game_object);

	HWND hWnd;
	HDC hdc;
	WNDCLASSA WndClass;

	// Init Steam API
	if(steam_edition || enable_steam_achievements)
	{
		// generate automatically steam_appid.txt
		if(!steam_edition){
			std::ofstream steam_appid_file("steam_appid.txt");
			steam_appid_file << ((ff8) ? FF8_APPID : FF7_APPID);
			steam_appid_file.close();
		}

		if (SteamAPI_RestartAppIfNecessary((ff8) ? FF8_APPID : FF7_APPID))
		{
			MessageBoxA(gameHwnd, "Steam Error - Could not find steam_appid.txt containing the app ID of the game.\n", "Steam App ID Wrong", 0);
			ffnx_error( "Steam Error - Could not find steam_appid.txt containing the app ID of the game.\n" );
			return 1;
		}
		if (!SteamAPI_Init())
		{
			MessageBoxA(gameHwnd, "Steam Error - Steam must be running to play this game with achievements (SteamAPI_Init() failed).\n", "Steam not running error", 0);
			ffnx_error( "Steam Error - Steam must be running to play this game with achievements (SteamAPI_Init() failed).\n" );
			return 1;
		}
		if (ff8)
			g_FF8SteamAchievements = std::make_unique<SteamAchievementsFF8>();
		else
			g_FF7SteamAchievements = std::make_unique<SteamAchievementsFF7>();
	}

	// Enumerate available monitors
	EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc, reinterpret_cast<LPARAM>(&monitors));
	if (display_index > monitors.size()) display_index = monitors.size();

	// Get the target monitor
	auto& targetMonitor = monitors[display_index-1];

	// fetch current screen settings
	EnumDisplaySettingsA(targetMonitor.deviceName.c_str(), ENUM_CURRENT_SETTINGS, &dmCurrentScreenSettings);

	// store all settings so we can change only few parameters
	dmNewScreenSettings = dmCurrentScreenSettings;

	// read original resolution
	game_width = VREF(game_object, window_width);
	game_height = VREF(game_object, window_height);

	// Assign a legit name to the Window
	if (ff8)
	{
		VRASS(game_object, window_title, "Final Fantasy VIII");
	}
	else
	{
		VRASS(game_object, window_title, "Final Fantasy VII");
	}

	if (window_size_x == 0 || window_size_y == 0)
	{
		if (fullscreen)
		{
			window_size_x = dmCurrentScreenSettings.dmPelsWidth;
			window_size_y = dmCurrentScreenSettings.dmPelsHeight;
		}
		else
		{
			window_size_x = game_width;
			window_size_y = game_height;
		}
	}
	else
	{
		// custom resolution
		dmNewScreenSettings.dmSize = sizeof(dmNewScreenSettings);
		dmNewScreenSettings.dmPelsWidth = window_size_x;
		dmNewScreenSettings.dmPelsHeight = window_size_y;
		dmNewScreenSettings.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;

		if (refresh_rate)
		{
			dmNewScreenSettings.dmDisplayFrequency = refresh_rate;
			dmNewScreenSettings.dmFields |= DM_DISPLAYFREQUENCY;
		}

		if (fullscreen)
		{
			if (ChangeDisplaySettingsExA(targetMonitor.deviceName.c_str(), &dmNewScreenSettings, 0, CDS_FULLSCREEN, 0) != DISP_CHANGE_SUCCESSFUL)
			{
				MessageBoxA(gameHwnd, "Failed to set the requested fullscreen mode, reverting to the original resolution.\n", "Error", 0);
				ffnx_error("failed to set fullscreen mode\n");
				window_size_x = dmCurrentScreenSettings.dmPelsWidth;
				window_size_y = dmCurrentScreenSettings.dmPelsHeight;
			}
			else
			{
				// re-fetch current monitors
				monitors.clear();
				EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc, reinterpret_cast<LPARAM>(&monitors));
				// Get the target monitor
				targetMonitor = monitors[display_index-1];
				// update current screen settings
				dmCurrentScreenSettings = dmNewScreenSettings;
			}
		}
	}

	WndClass.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
	WndClass.lpfnWndProc = WindowProc;
	WndClass.cbClsExtra = 0;
	WndClass.cbWndExtra = 0;
	WndClass.hInstance = hInstance;
	WndClass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(101));
	WndClass.hCursor = LoadCursorA(0, (LPCSTR)IDC_ARROW);
	WndClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
	WndClass.lpszMenuName = 0;
	WndClass.lpszClassName = VREF(game_object, window_class);

	if (RegisterClassA(&WndClass))
	{
		// If fullscreen is the starting mode, use the native game resolution as a window size starting point
		if (fullscreen)
		{
			calc_window_size(game_width, game_height);

			// Save current window state
			gameWindow[GameWindowState::PRE_FULLSCREEN] = gameWindow[GameWindowState::CURRENT];
		}
		// Otherwise if windowed mode is requested on start, use the given resolution as a starting point
		else
			calc_window_size(window_size_x, window_size_y);

		const RECT& monitorRect = targetMonitor.rcMonitor;
		hWnd = CreateWindowExA(
			WS_EX_APPWINDOW,
			VREF(game_object, window_class),
			VREF(game_object, window_title),
			fullscreen ? WS_SYSMENU | WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS : WS_OVERLAPPEDWINDOW,
			monitorRect.left + (fullscreen ? 0 : gameWindow[GameWindowState::CURRENT].x),
			monitorRect.top + (fullscreen ? 0 : gameWindow[GameWindowState::CURRENT].y),
			fullscreen ? window_size_x : gameWindow[GameWindowState::CURRENT].w,
			fullscreen ? window_size_y : gameWindow[GameWindowState::CURRENT].h,
			0,
			0,
			hInstance,
			0
		);

		VRASS(game_object, hwnd, hWnd);

		gameHinstance = hInstance;
		gameHwnd = hWnd;

		if (hWnd)
		{
			ret = TRUE;

			ShowWindow(hWnd, SW_SHOWNORMAL);
			UpdateWindow(hWnd);
			hdc = GetDC(hWnd);
			if (hdc)
			{
				VRASS(game_object, dc_horzres, GetDeviceCaps(hdc, HORZRES));
				VRASS(game_object, dc_vertres, GetDeviceCaps(hdc, VERTRES));
				VRASS(game_object, dc_bitspixel, GetDeviceCaps(hdc, BITSPIXEL));
				if (!VREF(game_object, colordepth))
					VRASS(game_object, colordepth, VREF(game_object, dc_bitspixel));
				ReleaseDC(hWnd, hdc);
			}

			if (ret && VREF(game_object, engine_loop_obj.init))
			{
				if (ff8) ff8_init_hooks(game_object);
				else ff7_init_hooks(game_object);

				replace_function(common_externals.get_keyboard_state, &GetGameKeyState);
				// catch all applog messages
				replace_function(common_externals.debug_print, external_debug_print);
				if (more_debug)
				{
					replace_function(common_externals.debug_print2, external_debug_print2);
				}

#ifdef NO_EXT_HEAP
				replace_function((uint32_t)common_externals.assert_free, ext_free);
				replace_function((uint32_t)common_externals.assert_malloc, ext_malloc);
				replace_function((uint32_t)common_externals.assert_calloc, ext_calloc);
#endif

				if (widescreen_enabled || enable_uncrop) widescreen.init();

				// Init renderer
				newRenderer.init();

				// Init GameHacks
				gamehacks.init();

				max_texture_size = newRenderer.getCaps()->limits.maxTextureSize;
				ffnx_info("Max texture size: %ix%i\n", max_texture_size, max_texture_size);

				newRenderer.prepareFFNxLogo();

				newRenderer.prepareEnvBrdf();

				newRenderer.prepareGamutLUTs();

				// perform any additional initialization that requires the rendering environment to be set up
				field_init();
				world_init();
				music_init();
				sfx_init();
				voice_init();

				if (enable_ffmpeg_videos)
				{
					movie_init();
				}
				if (ff8)
				{
					vram_init();
					if (ff8_fix_uv_coords_precision) uv_patch_init();
					vibration_init();
					if (widescreen_enabled)
					{
						*ff8_externals.current_viewport_x_dword_1A7764C = wide_viewport_x;
						*ff8_externals.current_viewport_y_dword_1A77648 = wide_viewport_y;
						*ff8_externals.current_viewport_width_dword_1A77654 = wide_viewport_width;
						*ff8_externals.current_viewport_height_dword_1A77650 = wide_viewport_height;
					}
				}

				exe_data_init();

				// Init Day Night Cycle
				if (!ff8 && enable_time_cycle) ff7::time.init();

				// Init Lighting
				if (!ff8 && enable_lighting) lighting.init();

				ffnx_log_current_pc_specs();

				// enable verbose logging for FFMpeg
				av_log_set_level(AV_LOG_VERBOSE);
				av_log_set_callback(ffmpeg_log_callback);

				ffnx_inject_driver(game_object);

				if (VREF(game_object, engine_loop_obj.init)(game_object))
				{
					if (!fullscreen || enable_devtools)
					{
						// Show the cursor
						while (ShowCursor(true) < 0);
					}
					else if (fullscreen)
					{
						// Hide the cursor
						while (ShowCursor(false) >= 0);
					}

					nxAudioEngine.init();

					if (borderless) toggle_borderless();

					if (VREF(game_object, engine_loop_obj.enter_main))
						VREF(game_object, engine_loop_obj.enter_main)(game_object);
				}
				else
				{
					ret = FALSE;
				}
			}
		}
	}

	return ret;
}

// called by the game before rendering starts, after the driver object has been
// created, we use this opportunity to initialize our default OpenGL render
// state
uint32_t common_init(struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: init\n");

	newRenderer.setBlendMode(RendererBlendMode::BLEND_NONE);

	texture_format = common_externals.create_texture_format();
	common_externals.make_pixelformat(32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000, texture_format);
	common_externals.add_texture_format(texture_format, game_object);

	nxAudioEngine.setMusicMasterVolume(external_music_volume / 100.0f);
	nxAudioEngine.setSFXMasterVolume(external_sfx_volume / 100.0f);
	nxAudioEngine.setAmbientMasterVolume(external_ambient_volume / 100.0f);
	nxAudioEngine.setVoiceMasterVolume(external_voice_volume / 100.0f);

	proxyWndProc = true;

	return true;
}

// called by the game just before it exits, we need to make sure the game
// doesn't crash after we're gone
void common_cleanup(struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: cleanup\n");

	if (steam_edition)
	{
		if (!ff8)
		{
			// Write ff7sound.cfg
			char ff7soundPath[260]{0};
			get_userdata_path(ff7soundPath, sizeof(ff7soundPath), false);
			PathAppendA(ff7soundPath, "ff7sound.cfg");
			FILE *ff7sound = fopen(ff7soundPath, "wb");

			if (ff7sound)
			{
				fwrite(&external_sfx_volume, sizeof(DWORD), 1, ff7sound);
				fwrite(&external_music_volume, sizeof(DWORD), 1, ff7sound);
				fclose(ff7sound);
			}
		}
	}

	// Shutdown Steam API
	if(steam_edition || enable_steam_achievements)
		SteamAPI_Shutdown();

	nxAudioEngine.cleanup();
	newRenderer.shutdown();
}

// unused and unnecessary
uint32_t common_lock(uint32_t surface)
{
	if(trace_all) ffnx_trace("dll_gfx: lock %i\n", surface);

	return true;
}

// unused and unnecessary
uint32_t common_unlock(uint32_t surface)
{
	if(trace_all) ffnx_trace("dll_gfx: unlock %i\n", surface);

	return true;
}

// called by the game at the end of each frame to swap the front and back
// buffers
void common_flip(struct game_obj *game_object)
{
	if (trace_all) ffnx_trace("dll_gfx: flip (%i)\n", frame_counter);

	VOBJ(game_obj, game_object, game_object);
	static struct timeb last_frame;
	static uint32_t fps_counters[3] = {0, 0, 0};
	time_t last_seconds = last_frame.time;
	struct game_mode *mode = getmode_cached();

	// Update RAM usage info
	GlobalMemoryStatusEx(&last_ram_state);

	// Draw with lighting
	if (!ff8 && enable_lighting) lighting.draw(game_object);

	// draw any z-sorted content now that we're done drawing everything else
	gl_draw_sorted_deferred();

	newRenderer.drawOverlay();

	if (fullscreen || borderless)
	{
		static uint32_t col = 4;
		uint32_t row = 1;

		if (show_version)
		{
			gl_draw_text(col, row++, text_colors[TEXTCOLOR_GRAY], 255, "Version: " VERSION);
		}

		if (show_renderer_backend)
		{
			gl_draw_text(col, row++, text_colors[TEXTCOLOR_GREEN], 255, "Renderer: %s", newRenderer.currentRenderer.c_str());
		}

		if (show_fps)
		{
			// average last two seconds and round up for our FPS counter
			gl_draw_text(col, row++, text_colors[TEXTCOLOR_YELLOW], 255, "FPS: %2.1lf", frame_rate);
		}

		if (show_stats)
		{
			static uint32_t color = text_colors[TEXTCOLOR_PINK];

#ifdef HEAP_DEBUG
			gl_draw_text(col, row++, color, 255, "Allocations: %u", allocs);
#endif
#ifdef PROFILE
			gl_draw_text(col, row++, color, 255, "Profiling: %I64u us", (time_t)((profile_total * 1000000.0) / VREF(game_object, countspersecond)));
#endif
			gl_draw_text(col, row++, color, 255, "RAM usage: %llu MB / %llu MB", (last_ram_state.ullTotalVirtual - last_ram_state.ullAvailVirtual) / (1024 * 1024), last_ram_state.ullTotalVirtual / ( 1024 * 1024 ));
			gl_draw_text(col, row++, color, 255, "Textures: %u", stats.texture_count);
			gl_draw_text(col, row++, color, 255, "External textures: %u", stats.external_textures);
			gl_draw_text(col, row++, color, 255, "Texture reloads: %u", stats.texture_reloads);
			gl_draw_text(col, row++, color, 255, "Palette writes: %u", stats.palette_writes);
			gl_draw_text(col, row++, color, 255, "Palette changes: %u", stats.palette_changes);
			gl_draw_text(col, row++, color, 255, "Zsort layers: %u", stats.deferred);
			gl_draw_text(col, row++, color, 255, "Vertices: %u", stats.vertex_count);
			gl_draw_text(col, row++, color, 255, "Timer: %I64u", stats.timer);
		}
	}
	else
	{
		char newWindowTitle[1024];

		strcpy_s(newWindowTitle, 1024, VREF(game_object, window_title));

		// Append chosen rendering engine
		if (show_renderer_backend)
		{
			char tmp[64];
			sprintf_s(tmp, 64, " (%s)", newRenderer.currentRenderer.c_str());
			strcat_s(newWindowTitle, 1024, tmp);
		}

		if (show_version)
		{
			char tmp[16];
			sprintf_s(tmp, 16, " " VERSION);
			strcat_s(newWindowTitle, 1024, tmp);
		}

		if (show_stats)
		{
			char tmp[768];
			sprintf_s(tmp, 768, " | RAM: %llu MB / %llu MB | nTex: %u | nExt.Tex: %u", (last_ram_state.ullTotalVirtual - last_ram_state.ullAvailVirtual) / (1024 * 1024), last_ram_state.ullTotalVirtual / (1024 * 1024), stats.texture_count, stats.external_textures);
			strcat_s(newWindowTitle, 1024, tmp);
		}

		if (show_fps)
		{
			char tmp[64];
			sprintf_s(tmp, 64, " | FPS: %2.1lf", frame_rate);
			strcat_s(newWindowTitle, 1024, tmp);
		}

		SetWindowTextA(gameHwnd, newWindowTitle);
	}

	fps_counters[0]++;
	ftime(&last_frame);

	if (last_seconds != last_frame.time)
	{
		fps_counters[2] = fps_counters[1];
		fps_counters[1] = fps_counters[0];
		fps_counters[0] = 0;
	}

	frame_rate = (fps_counters[1] + fps_counters[2] + 1) / 2;

	VRASS(game_object, fps, frame_rate);

	// if there is an active popup message, display it
	if(popup_ttl > 0)
	{
		if(gl_draw_text(4, newRenderer.getStats()->textHeight - 2, popup_color, (popup_ttl * 255) / POPUP_TTL_MAX, popup_msg))
		{
			uint32_t diff = (POPUP_TTL_MAX - popup_ttl) / 10;

			if(diff == 0) popup_ttl--;
			else if(diff > popup_ttl) popup_ttl = 0;
			else popup_ttl -= diff;
		}
	}

	// reset per-frame stats
	stats.texture_reloads = 0;
	stats.palette_writes = 0;
	stats.palette_changes = 0;
	stats.vertex_count = 0;
	stats.deferred = 0;

	newRenderer.show();

	current_state.texture_filter = true;
	current_state.fb_texture = false;

	// fix unresponsive quit menu
	if(!ff8 && VREF(game_object, gfx_reset))
	{
		MSG msg;

		if(PeekMessageA(&msg, 0, 0, 0, 1))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	// Enable XInput if a compatible gamepad is detected while playing the game, otherwise continue with native DInput
	if (!xinput_connected && gamepad.CheckConnection())
	{
		if (trace_all || trace_gamepad) ffnx_trace("XInput controller: connected.\n");

		xinput_connected = true;

		// Release any previous DirectInput attached controller, if any
		joystick.Clean();
	}
	else if (xinput_connected && !gamepad.CheckConnection())
	{
		if (trace_all || trace_gamepad) ffnx_trace("XInput controller: disconnected.\n");

		xinput_connected = false;
	}

	frame_counter++;

	// We need to process Gamepad input on each frame
	gamehacks.processGamepadInput();

	// Update day night time cycle
	if (!ff8 && enable_time_cycle) ff7::time.update();

	// Handle main menu background music
	handle_mainmenu_playback();

	// FF8 does not clear the screen properly in the card game module
	if (ff8)
	{
		if (mode->driver_mode == MODE_CARDGAME) common_clear_all(0);

		if (ff8_ssigpu_debug) ff8_externals.refresh_vram_window();

		ff8_handle_ambient_playback();
	}
	else
	{
		if (ff7_do_reset)
		{
			if (ff7_externals.movie_object->is_playing)
			{
				ff7_do_reset = false;
			}
			else
			{
				switch(mode->driver_mode)
				{
					// Skip reset on these mode(s)
					case MODE_MENU:
					case MODE_MAIN_MENU:
					case MODE_GAMEOVER:
					case MODE_CREDITS:
						ff7_do_reset = false;
						break;
					case MODE_BATTLE:
						if (*ff7_externals.battle_mode < 6) break;
					default:
						ff7_externals.reset_game_obj_sub_5F4971(game_object);
						break;
				}
			}
		}

		*ff7_externals.swirl_limit_fps = 1;

		ff7_handle_ambient_playback();
		ff7_handle_voice_playback();
		ff7_handle_wmode_reset();
		ff7::field::ff7_field_handle_blink_reset();
	}

	// Steamworks SDK API run callbacks
	if(steam_edition || enable_steam_achievements)
		SteamAPI_RunCallbacks();

}

// called by the game to clear an aspect of the back buffer, mostly called from
// clear_all below
void common_clear(uint32_t clear_color, uint32_t clear_depth, uint32_t unknown, struct game_obj *game_object)
{
	if(gl_defer_clear_buffer(clear_color, clear_depth, game_object)) return;

	uint32_t mode = getmode_cached()->driver_mode;

	if(trace_all) ffnx_trace("dll_gfx: clear %i %i %i\n", clear_color, clear_depth, unknown);

	if (!ff8 && enable_lighting) newRenderer.clearShadowMap();

	newRenderer.setClearFlags(
		clear_color || mode == MODE_MENU || mode == MODE_MAIN_MENU || mode == MODE_CONDOR,
		clear_depth
	);
}

// called by the game to clear the entire back buffer
void common_clear_all(struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: clear_all\n");

	common_clear(true, true, true, game_object);
}

// called by the game to setup a viewport inside the game window, allowing it
// to clip drawing to the requested area
void common_setviewport(uint32_t _x, uint32_t _y, uint32_t _w, uint32_t _h, struct game_obj *game_object)
{
	uint32_t mode = getmode_cached()->driver_mode;

	if(trace_all) ffnx_trace("dll_gfx: setviewport %i %i %i %i\n", _x, _y, _w, _h);

	current_state.viewport[0] = _x;
	current_state.viewport[1] = _y;
	current_state.viewport[2] = _w;
	current_state.viewport[3] = _h;

	newRenderer.setScissor(
		_x,
		_y,
		_w,
		_h
	);

	// emulate the transformation applied by an equivalent Direct3D viewport
	d3dviewport_matrix._11 = (float)_w / (float)game_width;
	// no idea why this is necessary
	if(!ff8 && mode == MODE_BATTLE) d3dviewport_matrix._22 = 1.0f;
	else d3dviewport_matrix._22 = (float)_h / (float)game_height;
	d3dviewport_matrix._41 = (((float)_x + (float)_w / 2.0f) - (float)game_width / 2.0f) / ((float)game_width / 2.0f);
	d3dviewport_matrix._42 = -(((float)_y + (float)_h / 2.0f) - (float)game_height / 2.0f) / ((float)game_height / 2.0f);
}

// called by the game to set the background color which the back buffer will be
// cleared to
void common_setbg(struct bgra_color *color, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: setbg\n");

	newRenderer.setBackgroundColor(
		color->r,
		color->g,
		color->b,
		ff8 ? color->a : 0.0f
	);
}

// called by the game to initialize a polygon_set structure
// we don't really need to do anything special here
uint32_t common_prepare_polygon_set(struct polygon_set *polygon_set)
{
	VOBJ(polygon_set, polygon_set, polygon_set);

	if(VPTR(polygon_set)) VRASS(polygon_set, indexed_primitives, (indexed_primitive**)external_calloc(VREF(polygon_set, numgroups), 4));

	return true;
}

// called by the game to load a group from a .p file into a renderable format
uint32_t common_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *hundred_data, struct p_group *group_data, struct polygon_data *polygon_data, struct polygon_set *polygon_set, struct game_obj *game_object)
{
	if(!ff8) return ff7gl_load_group(group_num, matrix_set, hundred_data, group_data, polygon_data, (struct ff7_polygon_set *)polygon_set, (struct ff7_game_obj *)game_object);
	else return common_externals.generic_load_group(group_num, matrix_set, hundred_data, group_data, polygon_data, polygon_set, game_object);
}

// called by the game to update one of the matrices in a matrix_set structure
void common_setmatrix(uint32_t unknown, struct matrix *matrix, struct matrix_set *matrix_set, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: setmatrix\n");

	switch(unknown)
	{
		case 0:
			if(!matrix_set->matrix_world) matrix_set->matrix_world = matrix;
			else memcpy(matrix_set->matrix_world, matrix, sizeof(*matrix));
			break;

		case 1:
			if(!matrix_set->matrix_view) matrix_set->matrix_view = matrix;
			else memcpy(matrix_set->matrix_view, matrix, sizeof(*matrix));
			break;

		case 2:
			if(!matrix_set->matrix_projection) matrix_set->matrix_projection = matrix;
			else memcpy(matrix_set->matrix_projection, matrix, sizeof(*matrix));
			break;
	}
}

// called by the game to apply light information to the current polygon set
void common_light_polygon_set(struct polygon_set *polygon_set, struct light *light)
{
	if(ff8 || game_lighting == GAME_LIGHTING_ORIGINAL) common_externals.generic_light_polygon_set(polygon_set, light);
}

// called by the game to unload a texture
void common_unload_texture(struct texture_set *texture_set)
{
	uint32_t i;
	VOBJ(texture_set, texture_set, texture_set);

	if(trace_all) ffnx_trace("dll_gfx: unload_texture 0x%x\n", VPTR(texture_set));

	if(!VPTR(texture_set)) return;
	if(!VREF(texture_set, texturehandle)) return;
	if(!VREF(texture_set, ogl.gl_set)) return;

	struct gl_texture_set *gl_set = VREF(texture_set, ogl.gl_set);

	// Destroy original static textures
	for (uint32_t idx = 0; idx < VREF(texture_set, ogl.gl_set->textures); idx++)
	{
		newRenderer.deleteTexture(VREF(texture_set, texturehandle[idx]));
	}

	// Destroy animated textures
	if (gl_set->is_animated)
	{
		for(std::map<std::string,uint32_t>::iterator it = gl_set->animated_textures.begin(); it != gl_set->animated_textures.end(); ++it) {
			newRenderer.deleteTexture(it->second);
		}
		gl_set->animated_textures.clear();
	}

	// Destroy additional textures
	for (short slot = RendererTextureSlot::TEX_NML; slot < RendererTextureSlot::COUNT; slot++)
		newRenderer.deleteTexture(gl_set->additional_textures[slot]);

	external_free(VREF(texture_set, texturehandle));
	delete VREF(texture_set, ogl.gl_set);

	VRASS(texture_set, texturehandle, 0);
	VRASS(texture_set, ogl.gl_set, 0);

	stats.texture_count--;

	if(VREF(texture_set, ogl.external)) stats.external_textures--;
	VRASS(texture_set, ogl.external, false); // texture_set can be reused (FF8)

	// remove any other references to this texture
	gl_check_deferred(texture_set);

	for(i = 0; i < scene_stack_pointer; i++)
	{
		if(scene_stack[i].texture_set == VPTR(texture_set)) scene_stack[i].texture_set = NULL;
	}

	if(current_state.texture_set == VPTR(texture_set)) current_state.texture_set = NULL;

	if(ff8) ff8_unload_texture(VPTRCAST(ff8_texture_set, texture_set));
}

// create a texture from an area of the framebuffer, source rectangle is encoded into tex header
// with our fictional version FB_TEXT_VERSION
// return true to short-circuit texture loader
uint32_t create_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header)
{
	VOBJ(texture_set, texture_set, texture_set);
	VOBJ(tex_header, tex_header, tex_header);
	uint32_t texture;

	if(VREF(tex_header, version) != FB_TEX_VERSION) return false;

	if(trace_all) ffnx_trace("create_framebuffer_texture: XY(%u,%u) %ux%u\n", VREF(tex_header, fb_tex.x), VREF(tex_header, fb_tex.y), VREF(tex_header, fb_tex.w), VREF(tex_header, fb_tex.h));

	texture = newRenderer.createBlitTexture(
		VREF(tex_header, fb_tex.x),
		VREF(tex_header, fb_tex.y),
		VREF(tex_header, fb_tex.w),
		VREF(tex_header, fb_tex.h)
	);

	VRASS(texture_set, texturehandle[0], texture);

	return true;
}

void blit_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header)
{
	VOBJ(texture_set, texture_set, texture_set);
	VOBJ(tex_header, tex_header, tex_header);

	if(VREF(tex_header, version) != FB_TEX_VERSION) return;

	if(gl_defer_blit_framebuffer(texture_set, tex_header)) return;

	if(trace_all) ffnx_trace("load_framebuffer_texture: XY(%u,%u) %ux%u\n", VREF(tex_header, fb_tex.x), VREF(tex_header, fb_tex.y), VREF(tex_header, fb_tex.w), VREF(tex_header, fb_tex.h));

	newRenderer.blitTexture(
		VREF(texture_set, texturehandle[0]),
		VREF(tex_header, fb_tex.x),
		VREF(tex_header, fb_tex.y),
		VREF(tex_header, fb_tex.w),
		VREF(tex_header, fb_tex.h)
	);
}

// load modpath texture for tex file, returns true if successful
uint32_t load_external_texture(void* image_data, uint32_t dataSize, struct texture_set *texture_set, struct tex_header *tex_header, uint32_t originalWidth, uint32_t originalHeight, uint32_t saveload_palette_index)
{
	VOBJ(texture_set, texture_set, texture_set);
	VOBJ(tex_header, tex_header, tex_header);
	uint32_t texture = 0;
	struct gl_texture_set *gl_set = VREF(texture_set, ogl.gl_set);
	struct texture_format* tex_format = VREFP(tex_header, tex_format);

	if((uint32_t)VREF(tex_header, file.pc_name) > 32 && !save_textures)
	{
		if(trace_all || trace_loaders) ffnx_trace("texture file name: %s\n", VREF(tex_header, file.pc_name));

		// Don't use palette index on fallback (for keeping compatibility with Tonberry mods)
		if(ff8 && _strnicmp(VREF(tex_header, file.pc_name), "field/mapdata/", strlen("field/mapdata/") - 1) == 0) saveload_palette_index |= 0x80000000;

		texture = load_texture(image_data, dataSize, VREF(tex_header, file.pc_name), saveload_palette_index, VREFP(texture_set, ogl.width), VREFP(texture_set, ogl.height), gl_set);

		if (!ff8)
		{
			if (enable_lighting)
			{
				std::string path = VREF(tex_header, file.pc_name);
				std::string filename = path.substr(path.find_last_of("/") + 1);

				if(lighting.isDisabledLightingTexture(filename))
				{
					gl_set->disable_lighting = true;
				}
			}

			if(!_strnicmp(VREF(tex_header, file.pc_name), "world", strlen("world") - 1)) gl_set->force_filter = true;

			if(!_strnicmp(VREF(tex_header, file.pc_name), "menu/usfont", strlen("menu/usfont") - 1))
			{
				gl_set->force_filter = true;
				gl_set->force_zsort = true;
			}

			if(!_strnicmp(VREF(tex_header, file.pc_name), "menu/btl_win", strlen("menu/btl_win") - 1)) gl_set->force_zsort = true;

			if(!_strnicmp(VREF(tex_header, file.pc_name), "flevel/hand_1", strlen("flevel/hand_1") - 1)) gl_set->force_filter = true;
		}
	}

	if(ff8 && texture == 0)
	{
		bool external = true;
		texture = texturePacker.composeTextures(
			VREF(tex_header, image_data), reinterpret_cast<uint32_t *>(image_data), originalWidth, originalHeight,
			VREF(tex_header, palette_index) / 2,
			VREFP(texture_set, ogl.width), VREFP(texture_set, ogl.height), gl_set, &external
		);

		if (texture == uint32_t(-1))
		{
			return true; // Remove texture
		}

		if (texture == 0)
		{
			if(VREF(texture_set, ogl.external)) stats.external_textures--;
			VRASS(texture_set, ogl.external, false);
		}
		else if (external == false)
		{
			gl_replace_texture(texture_set, VREF(tex_header, palette_index), texture);

			return true;
		}
	}

	if(texture)
	{
		gl_replace_texture(texture_set, VREF(tex_header, palette_index), texture);

		if(!VREF(texture_set, ogl.external)) stats.external_textures++;
		VRASS(texture_set, ogl.external, true);

		return true;
	}

	return false;
}

// convert a single 8-bit paletted pixel to 32-bit BGRA format
_inline uint32_t pal2bgra(uint32_t pixel, uint32_t *palette, uint32_t palette_offset, uint32_t color_key, uint32_t reference_alpha)
{
	if(color_key && pixel == 0) return 0;

	else
	{
		uint32_t color = palette[palette_offset + pixel];
		// FF7 uses a form of alpha keying to emulate PSX blending
		if(BGRA_A(color) == 0xFE) color = (color & 0xFFFFFF) | reference_alpha;
		return color;
	}
}

// convert an entire image from its native format to 32-bit BGRA
void convert_image_data(const unsigned char *image_data, uint32_t *converted_image_data, uint32_t w, uint32_t h, struct texture_format *tex_format, uint32_t invert_alpha, uint32_t color_key, uint32_t palette_offset, uint32_t reference_alpha)
{
	uint32_t i, j, o = 0, c = 0;

	// invalid texture in FF8, do not attempt to convert
	if(ff8 && tex_format->bytesperpixel == 0) return;

	// paletted source data (4-bit palettes are expanded to 8-bit by the game)
	if(tex_format->bytesperpixel == 1)
	{
		if(!tex_format->use_palette)
		{
			ffnx_glitch("unsupported texture format\n");
			return;
		}

		for(i = 0; i < w; i++)
		{
			for(j = 0; j < h; j++)
			{
				if(image_data[o] > tex_format->palette_size)
				{
					ffnx_glitch("texture conversion error\n");
					return;
				}

				converted_image_data[c++] = pal2bgra(image_data[o++], tex_format->palette_data, palette_offset, color_key, reference_alpha);
			}
		}
	}
	// RGB(A) source data
	else
	{
		if(tex_format->use_palette)
		{
			ffnx_glitch("unsupported texture format\n");
			return;
		}

		for(i = 0; i < w; i++)
		{
			for(j = 0; j < h; j++)
			{
				uint32_t pixel = 0;
				uint32_t color = 0;

				switch(tex_format->bytesperpixel)
				{
					// 16-bit RGB(A)
					case 2:
						pixel = *((WORD *)(&image_data[o]));
						break;
					// 24-bit RGB
					case 3:
						pixel = image_data[o] | image_data[o + 1] << 8 | image_data[o + 2] << 16;
						break;
					// 32-bit RGBA or RGBX
					case 4:
						pixel = *((uint32_t *)(&image_data[o]));
						break;

					default:
						ffnx_glitch("unsupported texture format\n");
						return;
				}

				o += tex_format->bytesperpixel;

				// PSX style mask bit
				if((color_key == 1 && (pixel & ~tex_format->alpha_mask) == 0) || (color_key == 3 && pixel == 0))
				{
					converted_image_data[c++] = 0;
					continue;
				}

				// convert source data to 8 bits per channel
				color = tex_format->blue_max > 0 ? ((((pixel & tex_format->blue_mask) >> tex_format->blue_shift) * 255) / tex_format->blue_max) : 0;
				color |= (tex_format->green_max > 0 ? ((((pixel & tex_format->green_mask) >> tex_format->green_shift) * 255) / tex_format->green_max) : 0) << 8;
				color |= (tex_format->red_max > 0 ? ((((pixel & tex_format->red_mask) >> tex_format->red_shift) * 255) / tex_format->red_max) : 0) << 16;

				// special case to deal with poorly converted PSX images in FF7
				if(invert_alpha && pixel != 0x8000) color |= (tex_format->alpha_max > 0 ? (255 - ((((pixel & tex_format->alpha_mask) >> tex_format->alpha_shift) * 255) / tex_format->alpha_max)) : 255) << 24;
				else color |= (tex_format->alpha_max > 0 ? ((((pixel & tex_format->alpha_mask) >> tex_format->alpha_shift) * 255) / tex_format->alpha_max) : 255) << 24;

				converted_image_data[c++] = color;
			}
		}
	}
}

// called by the game to load a texture
// can be called under a wide variety of circumstances, we must figure out what the game wants
struct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)
{
	VOBJ(game_obj, game_object, common_externals.get_game_object());
	VOBJ(texture_set, texture_set, _texture_set);
	VOBJ(tex_header, tex_header, _tex_header);
	struct palette *palette = 0;
	uint32_t color_key = false;
	struct texture_format *tex_format = VREFP(tex_header, tex_format);

	if(trace_all && _texture_set != NULL) ffnx_trace("dll_gfx: load_texture 0x%x\n", _texture_set);

	// no existing texture set, create one
	if (!VPTR(texture_set))
	{
		_texture_set = common_externals.create_texture_set();
		VASS(texture_set, texture_set, _texture_set);
	}

	// allocate space for our private data
	if(!VREF(texture_set, ogl.gl_set))
	{
		VRASS(texture_set, ogl.gl_set, new gl_texture_set());
		for (short slot = RendererTextureSlot::TEX_NML; slot < RendererTextureSlot::COUNT; slot++)
			VRASS(texture_set, ogl.gl_set->additional_textures[slot], 0);
	}

	// texture handle array may not have been initialized
	if(!VREF(texture_set, texturehandle))
	{
		// allocate some more textures just in case, there could be more palettes we don't know about yet
		// FF8 likes to change its mind about just how many palettes a texture has
		VRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);
		VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(VREF(texture_set, ogl.gl_set->textures), sizeof(uint32_t)));

		if(ff8 && VREF(tex_header, version) != FB_TEX_VERSION)
		{
			external_free(VREF(tex_header, old_palette_data));
			VRASS(tex_header, old_palette_data, 0);
		}

		stats.texture_count++;
	}

	// number of palettes has changed, reload the texture completely
	if(VREF(texture_set, ogl.gl_set->textures) != VREF(tex_header, palettes) * 2 && !(VREF(tex_header, palettes) == 0 && VREF(texture_set, ogl.gl_set->textures) == 1))
	{
		common_unload_texture(_texture_set);

		return common_load_texture(_texture_set, _tex_header, texture_format);
	}

	// make sure the information in the texture set is consistent
	VRASS(texture_set, tex_header, _tex_header);
	VRASS(texture_set, texture_format, texture_format);

	// check if this is suppposed to be a framebuffer texture, we may not have to do anything
	if(create_framebuffer_texture(_texture_set, _tex_header))
	{
		blit_framebuffer_texture(_texture_set, _tex_header);
		return _texture_set;
	}

	// initialize palette index to a sane value if it hasn't been set
	if(VREF(tex_header, palettes) > 0)
	{
		if(VREF(texture_set, palette_index) == -1)
		{
			VRASS(tex_header, palette_index, 0);
		}
		else
		{
			VRASS(tex_header, palette_index, ff8 ? VREF(texture_set, palette_index) & 0x1FFF : VREF(texture_set, palette_index));
		}
	}
	else VRASS(tex_header, palette_index, 0);

	if(VREF(tex_header, palette_index) >= VREF(texture_set, ogl.gl_set->textures))
	{
		ffnx_unexpected("tried to use non-existent palette (%i, %i)\n", VREF(tex_header, palette_index), VREF(texture_set, ogl.gl_set->textures));
		VRASS(tex_header, palette_index, 0);
		return _texture_set;
	}

	// create palette structure if it doesn't exist already
	if(VREF(tex_header, palettes) > 1 && VREF(texture_set, palette) == 0) palette = common_externals.create_palette_for_tex(texture_format->bitsperpixel, _tex_header, _texture_set);

	if(tex_format->palettes == 0) tex_format->palettes = VREF(tex_header, palette_entries);

	// convert texture data from source format and load it
	if(texture_format != 0 && VREF(tex_header, image_data) != 0)
	{
		uint32_t saveload_palette_index = VREF(tex_header, palette_index);

		if (ff8)
		{
			// optimization to not upload textures with undefined VRAM palette
			TexturePacker::TiledTex tiledTex = texturePacker.getTiledTex(VREF(tex_header, image_data));

			if (tiledTex.isValid())
			{
				TexturePacker::TextureInfos pal = tiledTex.palette(VREF(tex_header, palette_index) / 2);

				if (tiledTex.bpp() != Tim::Bpp16 && !pal.isValid())
				{
					if(trace_all || trace_vram) ffnx_trace("dll_gfx: load_texture ignored texture_set=0x%X pointer=0x%X pos=(%d, %d) bpp=%d index=%d\n", _texture_set, VREF(tex_header, image_data), tiledTex.x(), tiledTex.y(), tiledTex.bpp(), VREF(tex_header, palette_index) / 2);

					return _texture_set;
				}

				if (pal.isValid()) {
					saveload_palette_index = uint32_t(0x40000000) | ((uint32_t(pal.y()) & 0x7FFF) << 15) | (uint32_t(pal.x()) & 0x7FFF);
				} else {
					saveload_palette_index = uint32_t(-1);
				}
			}
		}

		// detect changes in palette data for FF8, we can't trust it to notify us
		if(ff8 && VREF(tex_header, palettes) > 0 && VREF(tex_header, version) != FB_TEX_VERSION && tex_format->bytesperpixel == 1)
		{
			if(!VREF(tex_header, old_palette_data))
			{
				VRASS(tex_header, old_palette_data, (unsigned char*)external_malloc(4 * tex_format->palette_size));
				memcpy(VREF(tex_header, old_palette_data), tex_format->palette_data, 4 * tex_format->palette_size);
			}
			else if(memcmp(VREF(tex_header, old_palette_data), tex_format->palette_data, 4 * tex_format->palette_size) != 0)
			{
				for (uint32_t idx = 0; idx < VREF(texture_set, ogl.gl_set->textures); idx++)
					newRenderer.deleteTexture(VREF(texture_set, texturehandle[idx]));

				memset(VREF(texture_set, texturehandle), 0, VREF(texture_set, ogl.gl_set->textures) * sizeof(uint32_t));
				VREF(texture_set, ogl.gl_set->default_texture_id) = 0;

				memcpy(VREF(tex_header, old_palette_data), tex_format->palette_data, 4 * tex_format->palette_size);
			}
		}

		// the texture handle for the current palette is missing, convert & load it
		// if we are dealing with an animated palette, load it anyway even if already loaded
		if(!VREF(texture_set, texturehandle[VREF(tex_header, palette_index)]) || VREF(texture_set, ogl.gl_set->is_animated))
		{
			uint32_t c = 0;
			uint32_t w = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.w) : tex_format->width;
			uint32_t h = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.h) : tex_format->height;
			uint32_t invert_alpha = false;
			uint32_t *image_data;
			// pre-calculate some useful data for palette conversion
			uint32_t palette_offset = VREF(tex_header, palette_index) * VREF(tex_header, palette_entries);
			uint32_t reference_alpha = (VREF(tex_header, reference_alpha) & 0xFF) << 24;

			// detect 16-bit PSX 5551 format with mask bit
			if(tex_format->bitsperpixel == 16 && tex_format->alpha_mask == 0x8000)
			{
				// correct incomplete texture format in FF7
				if(!ff8)
				{
					tex_format->blue_mask =  0x001F;
					tex_format->green_mask = 0x03E0;
					tex_format->red_mask =   0x7C00;
					tex_format->blue_shift =  0;
					tex_format->green_shift = 5;
					tex_format->red_shift =  10;
					tex_format->blue_max =  31;
					tex_format->green_max = 31;
					tex_format->red_max =   31;
				}

				invert_alpha = true;
			}

			if(!ff8)
			{
				// find out if color keying is enabled for this texture
				color_key = VREF(tex_header, color_key);

				// find out if color keying is enabled for this particular palette
				if(VREF(tex_header, use_palette_colorkey)) color_key = VREF(tex_header, palette_colorkey[VREF(tex_header, palette_index)]);
			}

			// allocate PBO
			uint32_t image_data_size = w * h * 4;

			// Allocate with cache
			if (image_data_size_cache == 0 || image_data_size > image_data_size_cache) {
				if (image_data_cache != nullptr) {
					driver_free(image_data_cache);
				}
				image_data_cache = (uint32_t*)driver_malloc(image_data_size);
				image_data_size_cache = image_data_size;
			}

			image_data = image_data_cache;

			// convert source data
			if (image_data != NULL) convert_image_data(VREF(tex_header, image_data), image_data, w, h, tex_format, invert_alpha, color_key, palette_offset, reference_alpha);

			// save texture to modpath if save_textures is enabled
			if(save_textures && (uint32_t)VREF(tex_header, file.pc_name) > 32)
			{
				save_texture(image_data, image_data_size, w, h, saveload_palette_index, VREF(tex_header, file.pc_name), VREF(texture_set, ogl.gl_set->is_animated));
			}

			// check if this texture can be loaded from the modpath, we may not have to do any conversion
			if (!load_external_texture(image_data, image_data_size, _texture_set, _tex_header, w, h, saveload_palette_index))
			{
				// commit PBO and populate texture set
				gl_upload_texture(_texture_set, VREF(tex_header, palette_index), image_data, RendererTextureType::BGRA);
			}
		}
	}
	else ffnx_unexpected("no texture format specified or no source data\n");

	return _texture_set;
}

// called by the game to indicate when a texture has switched to using another palette
// Either palette_entry_mul_index1 or palette_entry_mul_index2 can be filled. Not both! If palette_entry_mul_index1 has a value, then palette_entry_mul_index2 is 0, for eg.
// If it is one or the other filled, means coming from two different points in the engine ( for FF8 at least )
uint32_t common_palette_changed(uint32_t palette_entry_mul_index1, uint32_t palette_entries, uint32_t palette_entry_mul_index2, struct palette *palette, struct texture_set *texture_set)
{
	VOBJ(texture_set, texture_set, texture_set);

	if(trace_all) ffnx_trace("dll_gfx: palette_changed 0x%x %i\n", texture_set, VREF(texture_set, palette_index));

	if(palette == 0 || texture_set == 0) return false;

	// unset current texture
	newRenderer.useTexture(0);

	// texture loader logic handles missing palettes, just make sure the new palette has been loaded
	texture_set = common_load_texture(texture_set, VREF(texture_set, tex_header), VREF(texture_set, texture_format));

	// re-bind texture set to make sure the new palette is active
	gl_bind_texture_set(texture_set);

	stats.palette_changes++;

	return true;
}

// called by the game to write new color data to a palette
// sometimes called just to indicate that the palette has already been changed
// return value?
uint32_t common_write_palette(uint32_t source_offset, uint32_t size, void *source, uint32_t dest_offset, struct palette *palette, struct texture_set *texture_set)
{
	struct game_mode *mode = getmode_cached();

	uint32_t palette_index;
	uint32_t palettes;
	VOBJ(texture_set, texture_set, texture_set);
	VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));

	if(trace_all) ffnx_trace("dll_gfx: write_palette texture_set=0x%x source_offset=%i dest_offset=%i size=%i source=0x%x palette_entry=0x%x image_data=0x%X\n", texture_set, source_offset, dest_offset, size, source, palette->palette_entry, VREF(tex_header, image_data));

	if(palette == 0) return false;

	// if the tex header and texture set are not consistent we shouldn't be touching
	// anything before the texture is reloaded
	if(VREF(texture_set, ogl.gl_set->textures) != VREF(tex_header, palettes) * 2 && !(VREF(tex_header, palettes) == 0 && VREF(texture_set, ogl.gl_set->textures) == 1)) return true;

	palette_index = dest_offset / VREF(tex_header, palette_entries);
	palettes = size / VREF(tex_header, palette_entries);

	if(!ff8)
	{
		// FF7 writes to one palette at a time
		if(palettes > 1) ffnx_unexpected("multipalette write\n");

		if(palette_index >= VREF(texture_set, ogl.gl_set->textures))
		{
			ffnx_unexpected("palette write outside valid palette area (%i, %i)\n", palette_index, VREF(texture_set, ogl.gl_set->textures));
			return false;
		}

		// make sure the palette actually changed to avoid redundant texture reloads
		if(memcmp(((uint32_t *)VREF(tex_header, tex_format.palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4))
		{
			memcpy(((uint32_t *)VREF(tex_header, tex_format.palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4);

			if(!VREF(texture_set, ogl.external))
			{
				newRenderer.deleteTexture(VREF(texture_set, texturehandle[palette_index]));

				VRASS(texture_set, texturehandle[palette_index], 0);
			}

			stats.texture_reloads++;
		}

		// this texture changes in time, flag this as animated
		VRASS(texture_set, ogl.gl_set->is_animated, enable_animated_textures && mode->driver_mode == MODE_FIELD && (std::find(disable_animated_textures_on_field.begin(), disable_animated_textures_on_field.end(), get_current_field_name()) == disable_animated_textures_on_field.end()));
	}
	else
	{
		// FF8 writes multiple palettes in one swath but it always writes whole palettes
		if(palettes > 1 && size % VREF(tex_header, palette_entries)) ffnx_unexpected("unaligned multipalette write\n");

		const TexturePacker::TextureInfos paletteInfos = texturePacker.getTiledTex(VREF(tex_header, image_data)).palette(palette_index / 2);

		if (paletteInfos.isValid())
		{
			if(!VREF(tex_header, vram_positions))
			{
				VRASS(tex_header, vram_positions, (uint32_t*)external_calloc(128, sizeof(uint32_t)));
			}

			const uint32_t pos = VREF(tex_header, vram_positions)[palette_index];
			const uint16_t x = uint16_t(pos & 0xFFFF), y = uint16_t(pos >> 16);

			// We have a texture for this index, but the coordinates do not match
			// In this case, we can search if indexes haven't just swaped
			if (VREF(tex_header, old_palette_data) && VREF(texture_set, texturehandle[palette_index]) && (x > 0 || y > 0) && (x != paletteInfos.x() || y != paletteInfos.y()))
			{
				for (uint32_t idx = 0; idx < VREF(texture_set, ogl.gl_set->textures); idx++)
				{
					if (idx == palette_index || VREF(texture_set, texturehandle[idx]) == 0)
					{
						continue;
					}

					const uint32_t pos2 = VREF(tex_header, vram_positions)[idx];
					const uint16_t x2 = uint16_t(pos2 & 0xFFFF), y2 = uint16_t(pos2 >> 16);

					// Found one texture using the same coordinates
					if ((x2 > 0 || y2 > 0) && paletteInfos.x() == x2 && paletteInfos.y() == y2)
					{
						// Swap handles
						uint32_t old_handle = VREF(texture_set, texturehandle[palette_index]);
						VRASS(texture_set, texturehandle[palette_index], VREF(texture_set, texturehandle[idx]));
						VRASS(texture_set, texturehandle[idx], old_handle);
						// Swap palette data
						uint32_t *tmp_palette = (uint32_t *)external_malloc(size * 4);
						memcpy(tmp_palette, ((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, size * 4);
						memcpy(((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, ((uint32_t *)VREF(tex_header, old_palette_data)) + idx * size, size * 4);
						memcpy(((uint32_t *)VREF(tex_header, old_palette_data)) + idx * size, tmp_palette, size * 4);
						external_free(tmp_palette);
						// Move vram position
						VREF(tex_header, vram_positions)[idx] = VREF(tex_header, vram_positions)[palette_index];

						break;
					}
				}
			}

			VREF(tex_header, vram_positions)[palette_index] = uint32_t(paletteInfos.x()) | (uint32_t(paletteInfos.y()) << 16);
		}

		if(!VREF(tex_header, old_palette_data)) return false;

		// since FF8 may have already modified the palette itself we need to compare the new data to our backup
		if(memcmp(((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4) != 0)
		{
			memcpy(((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4);
			memcpy(((uint32_t *)VREF(tex_header, tex_format.palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4);

			// limit write to the palettes that we are aware of
			if(palette_index >= VREF(texture_set, ogl.gl_set->textures)) palettes = 0;
			else if(palette_index + palettes > VREF(texture_set, ogl.gl_set->textures)) palettes = VREF(texture_set, ogl.gl_set->textures) - palette_index;

			if(dest_offset + size > VREF(tex_header, tex_format.palette_size))
			{
				ffnx_unexpected("palette write outside advertised palette area (0x%x + 0x%x, 0x%x)\n", dest_offset, size, VREF(tex_header, tex_format.palette_size));
			}

			// if there's anything left at this point, reload the affected textures
			if(palettes)
			{
				for (uint32_t idx = 0; idx < palettes; idx++)
					newRenderer.deleteTexture(VREF(texture_set, texturehandle[palette_index + idx]));

				memset(VREFP(texture_set, texturehandle[palette_index]), 0, palettes * sizeof(uint32_t));
				VREF(texture_set, ogl.gl_set->default_texture_id) = 0;
			}

			stats.texture_reloads++;
		}
	}

	stats.palette_writes++;

	return true;
}

// blend mode parameters, identical to Direct3D driver
struct blend_mode blend_modes[5] = {      // PSX blend mode:
	{1, 1, 0x80, 5, 0x10, 6, 0x20, 0, 0}, // average
	{1, 0, 0xFF, 2, 2,    2, 2,    0, 0}, // additive blending
	{1, 0, 0xFF, 4, 8,    2, 2,    0, 0}, // subtractive blending
	{1, 0, 0x40, 5, 0x10, 2, 2,    0, 0}, // 25%? incoming color
	{1, 0, 0xFF, 2, 2,    1, 1,    0, 0}, //
};

// called by the game to retrieve blend mode parameters
// only z-sort and vertex alpha are really relevant to us
struct blend_mode *common_blendmode(uint32_t blend_mode, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: blendmode %i\n", blend_mode);

	switch(blend_mode)
	{
		case 0:
			return &blend_modes[0];
		case 1:
			return &blend_modes[1];
		case 2:
			return &blend_modes[2];
		case 3:
			return &blend_modes[3];
		case 4:
			if(!ff8) ffnx_unexpected("blend mode 4 requested\n");
			return &blend_modes[4];
	}

	ffnx_unexpected("invalid blendmode: %u\n", blend_mode);

	return 0;
}

// helper function to set simple render states (single parameter)
void internal_set_renderstate(uint32_t state, uint32_t option, struct game_obj *game_object)
{
	VOBJ(game_obj, game_object, game_object);

	switch(state)
	{
		// wireframe rendering, not used?
		case V_WIREFRAME:
			if (option) newRenderer.setWireframeMode(true);
			else newRenderer.setWireframeMode(false);
			current_state.wireframe = option;
			break;

		// texture filtering, can be disabled globally via config file
		case V_LINEARFILTER:
			if((option && !VREF(game_object, field_988))) current_state.texture_filter = true;
			else current_state.texture_filter = false;
			break;

		// perspective correction should never be turned off
		case V_PERSPECTIVE:
			// noop
			break;

		// color keying is done when textures are converted, not when rendering
		case V_COLORKEY:
			// noop
			break;

		// no dithering necessary in 32-bit color mode
		case V_DITHER:
			// noop
			break;

		// alpha test is used in many places in FF8 instead of color keying
		case V_ALPHATEST:
			if (option) newRenderer.doAlphaTest(true);
			else newRenderer.doAlphaTest(false);
			current_state.alphatest = option;
			break;

		// cull face, does this ever change?
		case V_CULLFACE:
			if (!option) newRenderer.setCullMode(RendererCullMode::BACK);
			else newRenderer.setCullMode(RendererCullMode::FRONT);
			current_state.cullface = option;
			break;

		// turn off culling completely, once again unsure if its ever used
		case V_NOCULL:
			if (option) newRenderer.setCullMode(RendererCullMode::DISABLED);
			else newRenderer.setCullMode(RendererCullMode::BACK);
			current_state.nocull = option;
			break;

		// turn depth testing on/off
		case V_DEPTHTEST:
			if (option) newRenderer.doDepthTest(true);
			else newRenderer.doDepthTest(false);
			current_state.depthtest = option;
			break;

		// depth mask, enable/disable writing to the Z-buffer
		case V_DEPTHMASK:
			if (option) newRenderer.doDepthWrite(true);
			else newRenderer.doDepthWrite(false);
			current_state.depthmask = option;
			break;

		// no idea what this is supposed to do
		case V_TEXADDR:
			// noop
			break;

		// function and reference values for alpha test
		case V_ALPHAFUNC:
		case V_ALPHAREF:
			if(state == V_ALPHAFUNC) current_state.alphafunc = option;
			else current_state.alpharef = option;

			switch(current_state.alphafunc)
			{
			case 0: newRenderer.setAlphaRef(RendererAlphaFunc::NEVER, current_state.alpharef / 255.0f); break;
			case 1: newRenderer.setAlphaRef(RendererAlphaFunc::ALWAYS, current_state.alpharef / 255.0f); break;
			case 2: newRenderer.setAlphaRef(RendererAlphaFunc::LESS, current_state.alpharef / 255.0f); break;
			case 3: newRenderer.setAlphaRef(RendererAlphaFunc::LEQUAL, current_state.alpharef / 255.0f); break;
			case 4: newRenderer.setAlphaRef(RendererAlphaFunc::EQUAL, current_state.alpharef / 255.0f); break;
			case 5: newRenderer.setAlphaRef(RendererAlphaFunc::GEQUAL, current_state.alpharef / 255.0f); break;
			case 6: newRenderer.setAlphaRef(RendererAlphaFunc::GREATER, current_state.alpharef / 255.0f); break;
			case 7: newRenderer.setAlphaRef(RendererAlphaFunc::NOTEQUAL, current_state.alpharef / 255.0f); break;
			default: newRenderer.setAlphaRef(RendererAlphaFunc::LEQUAL, current_state.alpharef / 255.0f); break;
			}
			break;

		case V_SHADEMODE:
			current_state.shademode = option;

		default:
			break;
	}
}

// called by the game to set a simple render state
void common_field_64(uint32_t state, uint32_t option, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: field_64 %i %i\n", state, option);

	internal_set_renderstate(state, option, game_object);
}

// called by the game to apply a set of render states
void common_setrenderstate(struct p_hundred *hundred_data, struct game_obj *game_object)
{
	if(hundred_data == 0) return;

	VOBJ(game_obj, game_object, game_object);

	uint32_t features = hundred_data->features;
	uint32_t options = hundred_data->options;
	struct struc_81 *struc_81 = VREF(game_object, field_944);

	if(trace_all) ffnx_trace("dll_gfx: setrenderstate 0x%x 0x%x\n", features, options);

// helper macro to check if a bit is set
// to be able to tell which bits we haven't handled, this macro will also clear
// a bit after checking it, be extremely careful not to copy/paste any
// invocation of this macro, the second invocation will not work!
#define CHECK_BIT(X, Y) ((X) & BIT((Y))) && (((X &= ~BIT((Y))) || true))

	if(CHECK_BIT(features, V_WIREFRAME)) internal_set_renderstate(V_WIREFRAME, CHECK_BIT(options, V_WIREFRAME), game_object);
	if(CHECK_BIT(features, V_TEXTURE)) gl_bind_texture_set(hundred_data->texture_set);
	if(CHECK_BIT(features, V_LINEARFILTER)) internal_set_renderstate(V_LINEARFILTER, CHECK_BIT(options, V_LINEARFILTER), game_object);
	if(CHECK_BIT(features, V_PERSPECTIVE)) internal_set_renderstate(V_PERSPECTIVE, CHECK_BIT(options, V_PERSPECTIVE), game_object);
	if(CHECK_BIT(features, V_COLORKEY)) internal_set_renderstate(V_COLORKEY, CHECK_BIT(options, V_COLORKEY), game_object);
	if(CHECK_BIT(features, V_DITHER)) internal_set_renderstate(V_DITHER, CHECK_BIT(options, V_DITHER), game_object);
	if(CHECK_BIT(features, V_ALPHABLEND))
	{
		// Safe default
		struc_81->blend_mode = 4;

		if(CHECK_BIT(options, V_ALPHABLEND))
		{
			if(VREF(game_object, field_93C))
			{
				if(VREF(game_object, current_hundred))
					struc_81->blend_mode = VREF(game_object, current_hundred->blend_mode);
			}
			else
				struc_81->blend_mode = hundred_data->blend_mode;
		}

		gl_set_blend_func(struc_81->blend_mode);
	}
	if(CHECK_BIT(features, V_ALPHATEST)) internal_set_renderstate(V_ALPHATEST, CHECK_BIT(options, V_ALPHATEST), game_object);
	if(CHECK_BIT(features, V_CULLFACE)) internal_set_renderstate(V_CULLFACE, CHECK_BIT(options, V_CULLFACE), game_object);
	if(CHECK_BIT(features, V_NOCULL)) internal_set_renderstate(V_NOCULL, CHECK_BIT(options, V_NOCULL), game_object);
	if(CHECK_BIT(features, V_DEPTHTEST)) internal_set_renderstate(V_DEPTHTEST, CHECK_BIT(options, V_DEPTHTEST), game_object);
	if(CHECK_BIT(features, V_DEPTHMASK)) internal_set_renderstate(V_DEPTHMASK, CHECK_BIT(options, V_DEPTHMASK), game_object);
	if(CHECK_BIT(features, V_SHADEMODE)) internal_set_renderstate(V_SHADEMODE, CHECK_BIT(options, V_SHADEMODE) && !VREF(game_object, field_92C) && hundred_data->shademode > 0, game_object);
	if(CHECK_BIT(features, V_UNKNOWNFFFDFFFD))
	{
		// Safe default
		struc_81->blend_mode = 4;

		if(CHECK_BIT(options, V_ALPHABLEND))
		{
			if(VREF(game_object, field_93C))
			{
				if(VREF(game_object, current_hundred))
					struc_81->blend_mode = VREF(game_object, current_hundred->blend_mode);
			}
			else
				struc_81->blend_mode = hundred_data->blend_mode;
		}

		gl_set_blend_func(struc_81->blend_mode);
	}

	// any bits still set in the features and options variables at this point
	// are features that we do not currently handle
}

// called by the game to apply a predetermined set of render states
// one for each blend mode? not sure what this is used for exactly
void common_field_74(uint32_t unknown, struct game_obj *game_object)
{
	VOBJ(game_obj, game_object, game_object);

	if(trace_all) ffnx_trace("dll_gfx: field_74\n");

	if(unknown > 4) return;

	common_setrenderstate(VREF(game_object, hundred_array[unknown]), game_object);
}

// called by the game to render a polygon set
// in FF7 this is where most of the 3D rendering happens
// in FF8 this function doesn't do any rendering at all
void common_field_78(struct polygon_set *polygon_set, struct game_obj *game_object)
{
	if(!ff8) ff7gl_field_78((struct ff7_polygon_set *)polygon_set, (struct ff7_game_obj *)game_object);
	else ff8gl_field_78((struct ff8_polygon_set *)polygon_set, (struct ff8_game_obj *)game_object);
}

// called by the game to render an instance that has been deferred by the above
// function, this is a feature of the original game, not to be confused with
// our own deferred rendering!
void common_draw_deferred(struct struc_77 *struc_77, struct game_obj *game_object)
{
	VOBJ(polygon_set, polygon_set, struc_77->polygon_set);
	struct p_hundred *hundred_data = struc_77->hundred_data;
	struct indexed_primitive *ip;

	if(trace_all) ffnx_trace("dll_gfx: draw_deferred\n");

	if(!VREF(polygon_set, indexed_primitives)) return;

	ip = VREF(polygon_set, indexed_primitives[struc_77->current_group]);

	if(!ip) return;

	common_setrenderstate(hundred_data, game_object);

	if(struc_77->use_matrix) gl_set_worldview_matrix(&struc_77->matrix);
	if(struc_77->use_matrix_pointer) gl_set_worldview_matrix(struc_77->matrix_pointer);

	if (!ff8 && enable_lighting) gl_draw_with_lighting(ip, VREF(polygon_set, polygon_data), nullptr, VREF(polygon_set, field_4));
	else gl_draw_without_lighting(ip, VREF(polygon_set, polygon_data), nullptr, VREF(polygon_set, field_4));
}

// called by the game to render a graphics object, basically a wrapper for
// field_78
void common_field_80(struct graphics_object *graphics_object, struct game_obj *game_object)
{
	VOBJ(graphics_object, graphics_object, graphics_object);

	if(trace_all) ffnx_trace("dll_gfx: field_80\n");

	if(!VPTR(graphics_object)) return;

	common_field_78(VREF(graphics_object, polygon_set), game_object);
}

// called by the game to draw some predefined polygon sets, no idea what this
// is really used for
void common_field_84(uint32_t unknown, struct game_obj *game_object)
{
	VOBJ(game_obj, game_object, game_object);
	VOBJ(polygon_set, polygon_set_2EC, VREF(game_object, polygon_set_2EC));
	VOBJ(polygon_set, polygon_set_2F0, VREF(game_object, polygon_set_2F0));

	if(trace_all) ffnx_trace("dll_gfx: field_84\n");

	if(!VREF(game_object, in_scene)) return;

	VRASS(game_object, field_928, unknown);

	if(!unknown)
	{
		VRASS(polygon_set_2EC, field_0, true);
		VRASS(polygon_set_2F0, field_0, false);
		common_field_78(VREF(game_object, polygon_set_2EC), game_object);
	}

	else
	{
		VRASS(polygon_set_2EC, field_0, false);
		VRASS(polygon_set_2F0, field_0, true);
		common_field_78(VREF(game_object, polygon_set_2F0), game_object);
	}
}

// called by the game to setup a new scene for rendering
// scenes are not stacked in FF7
// FF8 relies on the ability to stack scenes, saving and later reverting to a previous render state
uint32_t common_begin_scene(uint32_t unknown, struct game_obj *game_object)
{
	VOBJ(game_obj, game_object, game_object);

	if(trace_all) ffnx_trace("dll_gfx: begin_scene\n");

	if(scene_stack_pointer == sizeof(scene_stack) / sizeof(scene_stack[0])) ffnx_glitch("scene stack overflow\n");
	else gl_save_state(&scene_stack[scene_stack_pointer++]);

	VRASS(game_object, in_scene, VREF(game_object, in_scene) + 1);

	common_field_84(unknown, game_object);

	return true;
}

// called by the game to end a scene previously setup by the above function
// render state will be restored to what it was before the scene was created
void common_end_scene(struct game_obj *game_object)
{
	VOBJ(game_obj, game_object, game_object);

	if(trace_all) ffnx_trace("dll_gfx: end_scene\n");

	if(!scene_stack_pointer) ffnx_glitch("scene stack underflow\n");
	else gl_load_state(&scene_stack[--scene_stack_pointer]);

	if(VREF(game_object, in_scene)) VRASS(game_object, in_scene, VREF(game_object, in_scene) - 1);
}

// noop
void common_field_90(uint32_t unknown)
{
	ffnx_glitch_once("dll_gfx: field_90 (not implemented)\n");
}

// helper function used to draw a set of triangles without palette data
void generic_draw(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object, uint32_t vertextype)
{
	VOBJ(polygon_set, polygon_set, polygon_set);
	VOBJ(indexed_vertices, iv, iv);

	gl_draw_indexed_primitive(RendererPrimitiveType::PT_TRIANGLES, vertextype, VREF(iv, vertices), 0,  VREF(iv, vertexcount), VREF(iv, indices), VREF(iv, indexcount), UNSAFE_VREF(graphics_object, iv, graphics_object), 0, 0, VREF(polygon_set, field_4), true);
}

// helper function used to draw a set of triangles with palette data
void generic_draw_paletted(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object, uint32_t vertextype)
{
	VOBJ(polygon_set, polygon_set, polygon_set);
	VOBJ(indexed_vertices, iv, iv);
	uint32_t count = VREF(iv, count);
	unsigned char *palettes = VREF(iv, palettes);
	struct p_hundred *hundred_data = VREF(polygon_set, hundred_data);
	struct nvertex *vertices;
	struct nvertex *_vertices = VREF(iv, vertices);
	WORD *indices = VREF(iv, indices);

	if(!VREF(polygon_set, field_2C)) return;

	while(count > 0)
	{
		VOBJ(graphics_object, graphics_object, UNSAFE_VREF(graphics_object, iv, graphics_object));
		VOBJ(texture_set, texture_set, hundred_data->texture_set);
		uint32_t palette_index = *palettes++;
		uint32_t var30 = 1;
		uint32_t vertexcount = VREF(graphics_object, vertices_per_shape);
		uint32_t indexcount = VREF(graphics_object, indices_per_shape);

		vertices = _vertices;

		VRASS(texture_set, palette_index, palette_index);

		common_palette_changed(0, 0, 0, VREF(texture_set, palette), hundred_data->texture_set);

		while(var30 < count)
		{
			if(*palettes != palette_index) break;

			palettes++;

			vertexcount += VREF(graphics_object, vertices_per_shape);
			indexcount += VREF(graphics_object, indices_per_shape);

			var30++;
		}

		_vertices = &_vertices[VREF(graphics_object, vertices_per_shape) * var30];

		count -= var30;

		gl_draw_indexed_primitive(RendererPrimitiveType::PT_TRIANGLES, vertextype, vertices, 0, vertexcount, VREF(iv, indices), indexcount, UNSAFE_VREF(graphics_object, iv, graphics_object), 0, 0, VREF(polygon_set, field_4), true);
	}
}

// called by the game to set the render state for a set of 2D triangles
void common_setrenderstate_2D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
{
	VOBJ(polygon_set, polygon_set, polygon_set);

	if(trace_all) ffnx_trace("dll_gfx: setrenderstate_2D\n");

	if(!VREF(polygon_set, field_2C)) return;

	common_setrenderstate(VREF(polygon_set, hundred_data), game_object);
}

// called by the game to draw a set of 2D triangles without palette data
void common_draw_2D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: draw_2D\n");

	generic_draw(polygon_set, iv, game_object, TLVERTEX);
}

// called by the game to draw a set of 2D triangles with palette data
void common_draw_paletted2D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: draw_paletted2D\n");

	generic_draw_paletted(polygon_set, iv, game_object, TLVERTEX);
}

// called by the game to set the render state for a set of 3D triangles
void common_setrenderstate_3D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
{
	VOBJ(polygon_set, polygon_set, polygon_set);
	VOBJ(indexed_vertices, iv, iv);
	VOBJ(graphics_object, graphics_object, UNSAFE_VREF(graphics_object, iv, graphics_object));

	if(trace_all) ffnx_trace("dll_gfx: setrenderstate_3D\n");

	if(!VREF(polygon_set, field_2C)) return;

	common_setrenderstate(VREF(polygon_set, hundred_data), game_object);

	if(VREF(graphics_object, use_matrix_pointer)) gl_set_worldview_matrix(VREF(graphics_object, matrix_pointer));
	else gl_set_worldview_matrix(VREFP(graphics_object, matrix));
}

// called by the game to draw a set of 3D triangles without palette data
void common_draw_3D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: draw_3D\n");

	generic_draw(polygon_set, iv, game_object, LVERTEX);
}

// called by the game to draw a set of 3D triangles with palette data
void common_draw_paletted3D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
{
	if(trace_all) ffnx_trace("dll_gfx: draw_paletted3D\n");

	generic_draw_paletted(polygon_set, iv, game_object, LVERTEX);
}

// called by the game to draw a set of lines
void common_draw_lines(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
{
	VOBJ(polygon_set, polygon_set, polygon_set);
	VOBJ(indexed_vertices, iv, iv);

	if(trace_all) ffnx_trace("dll_gfx: draw_lines\n");

	gl_draw_indexed_primitive(RendererPrimitiveType::PT_LINES, TLVERTEX, VREF(iv, vertices), 0, VREF(iv, vertexcount), VREF(iv, indices), VREF(iv, indexcount), UNSAFE_VREF(graphics_object, iv, graphics_object), 0, 0, VREF(polygon_set, field_4), true);
}

// noop
void common_field_EC(struct game_obj *game_object)
{
	ffnx_glitch_once("dll_gfx: field_EC (not implemented)\n");
}

// create a suitable tex header to be processed by the framebuffer texture loader
struct tex_header *make_framebuffer_tex(uint32_t tex_w, uint32_t tex_h, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color_key)
{
	struct tex_header* _header = common_externals.create_tex_header();

	VOBJ(tex_header, tex_header, _header);

	VRASS(tex_header, bpp, 32);
	VRASS(tex_header, color_key, color_key);
	memcpy(VREFP(tex_header, tex_format), texture_format, sizeof(struct texture_format));

	VRASS(tex_header, tex_format.alpha_max, 0);

	VRASS(tex_header, tex_format.width, tex_w);
	VRASS(tex_header, tex_format.height, tex_h);

	VRASS(tex_header, version, FB_TEX_VERSION);

	VRASS(tex_header, fb_tex.x, x);
	VRASS(tex_header, fb_tex.y, y);
	VRASS(tex_header, fb_tex.w, w);
	VRASS(tex_header, fb_tex.h, h);

	return _header;
}

time_t qpc_get_time(time_t *dest)
{
	QueryPerformanceCounter((LARGE_INTEGER *)dest);

	stats.timer = *dest;

	return *dest;
}

time_t qpc_diff_time(time_t* t1, time_t* t2, time_t* out)
{
	time_t ret = *t1 - *t2;

	if (out != nullptr) *out = ret;

	return ret;
}

// version check reads from a given offset in memory
uint32_t version_check(uint32_t offset)
{
	return (*(uint32_t *)(offset));
}

// figure out if we are running in FF7 or FF8 and detect which version
uint32_t get_version()
{
	uint32_t version_check1 = version_check(0x401004);
	uint32_t version_check2 = version_check(0x401404);

	ffnx_trace("v1: 0x%X, v2: 0x%X\n", version_check1, version_check2);

	if(version_check1 == 0x99CE0805)
	{
		ffnx_info("Auto-detected version: FF7 1.02 US English\n");
		return VERSION_FF7_102_US;
	}
	else if(version_check1 == 0x99EBF805)
	{
		ffnx_info("Auto-detected version: FF7 1.02 French\n");
		return VERSION_FF7_102_FR;
	}
	else if(version_check1 == 0x99DBC805)
	{
		ffnx_info("Auto-detected version: FF7 1.02 German\n");
		return VERSION_FF7_102_DE;
	}
	else if(version_check1 == 0x99F65805)
	{
		ffnx_info("Auto-detected version: FF7 1.02 Spanish\n");
		return VERSION_FF7_102_SP;
	}
	else if(version_check1 == 0x3885048D && version_check2 == 0x159618)
	{
		ffnx_info("Auto-detected version: FF8 1.2 US English\n");
		return VERSION_FF8_12_US;
	}
	else if(version_check1 == 0x3885048D && version_check2 == 0x1597C8)
	{
		ffnx_info("Auto-detected version: FF8 1.2 US English (Nvidia)\n");
		return VERSION_FF8_12_US_NV;
	}
	else if(version_check1 == 0x1085048D && version_check2 == 0x159B48)
	{
		ffnx_info("Auto-detected version: FF8 1.2 French\n");
		return VERSION_FF8_12_FR;
	}
	else if(version_check1 == 0x1085048D && version_check2 == 0x159CF8)
	{
		ffnx_info("Auto-detected version: FF8 1.2 French (Nvidia)\n");
		return VERSION_FF8_12_FR_NV;
	}
	else if(version_check1 == 0xA885048D && version_check2 == 0x159C48)
	{
		ffnx_info("Auto-detected version: FF8 1.2 German\n");
		return VERSION_FF8_12_DE;
	}
	else if(version_check1 == 0xA885048D && version_check2 == 0x159DF8)
	{
		ffnx_info("Auto-detected version: FF8 1.2 German (Nvidia)\n");
		return VERSION_FF8_12_DE_NV;
	}
	else if(version_check1 == 0x8085048D && version_check2 == 0x159C38)
	{
		ffnx_info("Auto-detected version: FF8 1.2 Spanish\n");
		return VERSION_FF8_12_SP;
	}
	else if(version_check1 == 0x8085048D && version_check2 == 0x159DE8)
	{
		ffnx_info("Auto-detected version: FF8 1.2 Spanish (Nvidia)\n");
		return VERSION_FF8_12_SP_NV;
	}
	else if(version_check1 == 0xB885048D && version_check2 == 0x159BC8)
	{
		ffnx_info("Auto-detected version: FF8 1.2 Italian\n");
		return VERSION_FF8_12_IT;
	}
	else if(version_check1 == 0xB885048D && version_check2 == 0x159D78)
	{
		ffnx_info("Auto-detected version: FF8 1.2 Italian (Nvidia)\n");
		return VERSION_FF8_12_IT_NV;
	}
	else if(version_check1 == 0x2885048D && version_check2 == 0x159598)
	{
		ffnx_info("Auto-detected version: FF8 1.2 US English (Eidos Patch)\n");
		return VERSION_FF8_12_US_EIDOS;
	}
	else if(version_check1 == 0x2885048D && version_check2 == 0x159748)
	{
		ffnx_info("Auto-detected version: FF8 1.2 US English (Eidos Patch) (Nvidia)\n");
		return VERSION_FF8_12_US_EIDOS_NV;
	}
	else if(version_check1 == 0x1B6E9CC && version_check2 == 0x7C8DFFC9)
	{
		uint32_t version_check3 = version_check(0x401010);

		if (version_check3 == 0x24AC)
		{
			ffnx_info("Auto-detected version: FF8 1.2 Japanese (Nvidia)\n");
			return VERSION_FF8_12_JP_NV;
		}

		ffnx_info("Auto-detected version: FF8 1.2 Japanese\n");
		return VERSION_FF8_12_JP;
	}

	return 0;
}

void get_data_lang_path(PCHAR buffer)
{
	strcpy(buffer, ff8 ? ff8_externals.app_path : basedir);
	PathAppendA(buffer, R"(data\lang-)");
	switch (version)
	{
	case VERSION_FF7_102_US:
	case VERSION_FF8_12_US_NV:
	case VERSION_FF8_12_US_EIDOS_NV:
		if (ff7_japanese_edition)
			strcat(buffer, "ja");
		else
			strcat(buffer, "en");
		break;
	case VERSION_FF7_102_FR:
	case VERSION_FF8_12_FR_NV:
		strcat(buffer, "fr");
		break;
	case VERSION_FF7_102_DE:
	case VERSION_FF8_12_DE_NV:
		strcat(buffer, "de");
		break;
	case VERSION_FF7_102_SP:
	case VERSION_FF8_12_SP_NV:
		strcat(buffer, "es");
		break;
	case VERSION_FF8_12_IT_NV:
		strcat(buffer, "it");
		break;
	case VERSION_FF8_12_JP:
		strcat(buffer, "jp");
		break;
	}
}

void get_userdata_path(PCHAR buffer, size_t bufSize, bool isSavegameFile)
{
	PWSTR outPath = NULL;

	HRESULT hr = SHGetKnownFolderPath(FOLDERID_Documents, KF_FLAG_DEFAULT, NULL, &outPath);

	if (SUCCEEDED(hr))
	{
		wcstombs(buffer, outPath, bufSize);

		CoTaskMemFree(outPath);

		if (ff8)
			PathAppendA(buffer, R"(Square Enix\FINAL FANTASY VIII Steam)");
		else
			PathAppendA(buffer, R"(Square Enix\FINAL FANTASY VII Steam)");

		if (isSavegameFile)
		{
			if (!steam_game_userdata.empty())
			{
				// Directly use the given userdata
				PathAppendA(buffer, steam_game_userdata.c_str());
			}
			else
			{
				// Search for the first "user_" match in the game path
				CHAR searchPath[MAX_PATH];
				WIN32_FIND_DATA pathFound;
				HANDLE hFind;

				strcpy(searchPath, buffer);
				strcat(searchPath, R"(\user_*)");
				if (hFind = FindFirstFileA(searchPath, &pathFound))
				{
					PathAppendA(buffer, pathFound.cFileName);
					FindClose(hFind);
				}
			}
		}
	}
}

// cd check
uint32_t ff7_get_inserted_cd(void) {
	int ret = 1;

	if(steam_edition || enable_steam_achievements){
		if (trace_all || trace_achievement)
			ffnx_trace("inserted CD: %d, requiredCD: %d\n", *ff7_externals.insertedCD, *ff7_externals.requiredCD);

		if(*ff7_externals.requiredCD == *ff7_externals.insertedCD + 1)
			g_FF7SteamAchievements->unlockGameProgressAchievement();
	}

	if (*ff7_externals.requiredCD > 0 && *ff7_externals.requiredCD <= 3) ret = *ff7_externals.requiredCD;

	*ff7_externals.insertedCD = ret;

	return ret;
}

MCIERROR __stdcall dotemuMciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
	DWORD mciStatusRet;

	switch (uMsg)
	{
	case MCI_OPEN:
		((LPDWORD)dwParam2)[2] = (DWORD)"waveaudio";
		dwParam1 = 8704;
		((LPDWORD)dwParam2)[3] = (DWORD)R"(Data\Music\eyes_on_me.wav)";
		return mciSendCommandA(mciId, uMsg, dwParam1, dwParam2);
	case MCI_SET:
		((LPDWORD)dwParam2)[1] = 0;
		break;
	case MCI_STATUS:
		mciStatusRet = 0;
		((LPDWORD)dwParam2)[1] = (DWORD)&mciStatusRet;
		return 0;
	case MCI_PLAY:
		((LPDWORD)dwParam2)[2] = 339000;
		break;
	}

	return mciSendCommandA(mciId, uMsg, dwParam1, dwParam2);
}

#if defined(__cplusplus)
extern "C" {
#endif

// main entry point, called by the game to create a graphics driver object
__declspec(dllexport) void *new_dll_graphics_driver(void *game_object)
{
	void *ret;

	// game-specific initialization
	if(!ff8)
		ret = ff7_load_driver(game_object);
	else
		ret = ff8_load_driver(game_object);

	return ret;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
	{
		// Enable the following block if you wish to use VS2019 ReAttach extension
		/*
		while (!IsDebuggerPresent())
		{
			Sleep(100);
		}
		__debugbreak();
		*/

		// Push the limit of how many files we can open at the same time to the maximum available on Windows
		// See https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setmaxstdio?view=msvc-160#remarks
		_setmaxstdio(8192);

		SetProcessDPIAware();

		GetCurrentDirectoryA(BASEDIR_LENGTH, basedir);

		// install crash handler
		open_applog("FFNx.log");
		SetUnhandledExceptionFilter(ExceptionHandler);

		// prevent screensavers
		SetThreadExecutionState(ES_CONTINUOUS | ES_DISPLAY_REQUIRED | ES_SYSTEM_REQUIRED);

		ffnx_info("FFNx driver version " VERSION "\n");
		version = get_version();
		if (version >= VERSION_FF8_12_US)
		{
			ff8 = true;
		}
		else if (version == VERSION_FF7_102_US)
		{
#include "externals_102_us.h"
		}
		else if (version == VERSION_FF7_102_FR)
		{
#include "externals_102_fr.h"
		}
		else if (version == VERSION_FF7_102_DE)
		{
#include "externals_102_de.h"
		}
		else if (version == VERSION_FF7_102_SP)
		{
#include "externals_102_sp.h"
		}

		if (!version)
		{
			ffnx_unexpected("no compatible version found\n");
			MessageBoxA(NULL, "Your ff7.exe or ff8.exe is incompatible with this driver and will exit after this message.\n"
				"Possible reasons for this error:\n"
				" - You have the faulty \"1.4 XP Patch\" for FF7.\n"
				" - You have FF7 retail 1.00 version (you need the 1.02 patch).\n"
				" - You have an unsupported translation of FF7. (US English, French, German and Spanish versions are currently supported)\n"
				" - You have FF8 retail 1.0 version (you need the 1.2 patch).\n"
				" - You have an unsupported translation of FF8. (US English, French, German, Spanish, Italian and Japanese versions are currently supported)\n"
				" - You have a conflicting patch applied.\n\n"
				, "Error", MB_ICONERROR | MB_OK);
			return FALSE;
		}

		bool is_genuine_steam_api = isFileSigned(L"steam_api.dll");
		if (!is_genuine_steam_api) is_genuine_steam_api = sha1_file("steam_api.dll") == "03bd9f3e352553a0af41f5fe006f6249a168c243";
		if (!is_genuine_steam_api)
		{
			ffnx_unexpected("Invalid steam_api.dll detected. Please ensure your FFNx installation is not corrupted or tampered by unauthorized software.\n");
			MessageBoxA(NULL, "Invalid steam_api.dll detected. Please ensure your FFNx installation is not corrupted or tampered by unauthorized software.", "Error", MB_ICONERROR | MB_OK);
			return FALSE;
		}

		read_cfg();

		// Did user choose to enable Widescreen?
		widescreen_enabled = (aspect_ratio == AR_WIDESCREEN_16X9 || aspect_ratio == AR_WIDESCREEN_16X10);

		// Get current process name
		CHAR parentName[1024];
		GetModuleFileNameA(NULL, parentName, sizeof(parentName));
		_strlwr(parentName);

		// Get our filesystem name
		CHAR dllName[1024];
		GetModuleFileNameA((HMODULE)hinstDLL, dllName, sizeof(dllName));
		_strlwr(dllName);

		if (!ff8)
		{
			common_externals.winmain = get_relative_call(common_externals.start, 0x14D);
			replace_function(ff7_externals.get_inserted_cd_sub, ff7_get_inserted_cd);
			replace_function(common_externals.create_window, common_create_window);

			if (strstr(dllName, "af3dn.p") != NULL)
			{
				ff7_japanese_edition = strstr(parentName, "ff7_ja.exe") != NULL;

				// Steam edition is usually installed in this path
				if (strstr(basedir, "steamapps") != NULL) {
					ffnx_trace("Detected Steam edition.\n");
					steam_edition = true;

					// Read ff7sound.cfg
					char ff7soundPath[260]{ 0 };
					get_userdata_path(ff7soundPath, sizeof(ff7soundPath), false);
					PathAppendA(ff7soundPath, "ff7sound.cfg");
					FILE* ff7sound = fopen(ff7soundPath, "rb");

					if (ff7sound)
					{
						if (external_sfx_volume < 0) fread(&external_sfx_volume, sizeof(DWORD), 1, ff7sound);
						if (external_music_volume < 0) fread(&external_music_volume, sizeof(DWORD), 1, ff7sound);
						fclose(ff7sound);
					}
				}
				// otherwise it's the eStore edition which has same exe names but installed somewhere else
				else
				{
					ffnx_trace("Detected eStore edition.\n");
					estore_edition = true;
				}

				if (external_voice_volume < 0) external_voice_volume = 100;
				if (external_ambient_volume < 0) external_ambient_volume = 100;
				if (ffmpeg_video_volume < 0) ffmpeg_video_volume = 100;

				use_external_music = true;
				if (external_music_path.empty()) external_music_path = "data/music_ogg";

			}
			else
			{
				HKEY ff7_regkey;
				DWORD regsize = sizeof(DWORD);

				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, R"(Software\Square Soft, Inc.\Final Fantasy VII\1.00\MIDI)", 0, KEY_QUERY_VALUE | KEY_WOW64_32KEY, &ff7_regkey) == ERROR_SUCCESS)
					if (external_music_volume < 0) RegQueryValueEx(ff7_regkey, "MusicVolume", NULL, NULL, (LPBYTE)&external_music_volume, &regsize);

				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, R"(Software\Square Soft, Inc.\Final Fantasy VII\1.00\Sound)", 0, KEY_QUERY_VALUE | KEY_WOW64_32KEY, &ff7_regkey) == ERROR_SUCCESS)
					if (external_sfx_volume < 0) RegQueryValueEx(ff7_regkey, "SFXVolume", NULL, NULL, (LPBYTE)&external_sfx_volume, &regsize);

				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, R"(Software\Square Soft, Inc.\Final Fantasy VII\1.00\FFNx)", 0, KEY_QUERY_VALUE | KEY_WOW64_32KEY, &ff7_regkey) == ERROR_SUCCESS)
				{
					if (external_ambient_volume < 0) RegQueryValueEx(ff7_regkey, "AmbientVolume", NULL, NULL, (LPBYTE)&external_ambient_volume, &regsize);
					if (ffmpeg_video_volume < 0) RegQueryValueEx(ff7_regkey, "MovieVolume", NULL, NULL, (LPBYTE)&ffmpeg_video_volume, &regsize);
					if (external_voice_volume < 0) RegQueryValueEx(ff7_regkey, "VoiceVolume", NULL, NULL, (LPBYTE)&external_voice_volume, &regsize);
				}

				if (external_music_path.empty()) external_music_path = "music/vgmstream";
			}
		}
		else if (ff8)
		{
			// Save start address for later
			switch (version)
			{
			case VERSION_FF8_12_US:
				ff8_externals.start = 0x55AC07;
				break;
			case VERSION_FF8_12_US_NV:
				ff8_externals.start = 0x55ADB7;
				break;
			case VERSION_FF8_12_FR:
				ff8_externals.start = 0x55B137;
				break;
			case VERSION_FF8_12_FR_NV:
				ff8_externals.start = 0x55B2E7;
				break;
			case VERSION_FF8_12_DE:
				ff8_externals.start = 0x55B237;
				break;
			case VERSION_FF8_12_DE_NV:
				ff8_externals.start = 0x55B3E7;
				break;
			case VERSION_FF8_12_SP:
				ff8_externals.start = 0x55B227;
				break;
			case VERSION_FF8_12_SP_NV:
				ff8_externals.start = 0x55B3D7;
				break;
			case VERSION_FF8_12_IT:
				ff8_externals.start = 0x55B1B7;
				break;
			case VERSION_FF8_12_IT_NV:
				ff8_externals.start = 0x55B367;
				break;
			case VERSION_FF8_12_US_EIDOS:
				ff8_externals.start = 0x55AB87;
				break;
			case VERSION_FF8_12_US_EIDOS_NV:
				ff8_externals.start = 0x55AD37;
				break;
			case VERSION_FF8_12_JP:
				ff8_externals.start = 0x55F487;
				break;
			case VERSION_FF8_12_JP_NV:
				ff8_externals.start = 0x55F6E7;
				break;
			}

			if (version == VERSION_FF8_12_US_EIDOS || version == VERSION_FF8_12_US_EIDOS_NV)
			{
				MessageBoxA(NULL, "Old Eidos patch detected, please update to the newer 1.2 patch from Square.\n"
					"The old patch may or may not work properly, it is not supported and has not been tested.",
					"Warning", 0);
			}

			ff8_data();

			replace_function(common_externals.create_window, common_create_window);
			replace_function(ff8_externals.manage_time_engine_sub_569971, ff8_manage_time_engine);

			game_cfg_init();

			if (strstr(dllName, "af3dn.p") != NULL)
			{
				ffnx_trace("Detected Steam edition.\n");

				steam_edition = true;

				// Detect if FF8 Stock Launcher
				if (contains(getCopyrightInfoFromExe("FF8_Launcher.exe"), "SQUARE ENIX CO., LTD"))
				{
					steam_stock_launcher = true;
					ffnx_trace("Detected Steam stock launcher.\n");
				}

				// Steam edition contains movies unpacked
				enable_ffmpeg_videos = true;

				// Eyes on me patch

				DWORD mciSendCommandA;

				switch (version)
				{
				case VERSION_FF8_12_US_NV:
				case VERSION_FF8_12_FR_NV:
				case VERSION_FF8_12_DE_NV:
				case VERSION_FF8_12_SP_NV:
				case VERSION_FF8_12_IT_NV:
					mciSendCommandA = 0xB69388;
					break;
				case VERSION_FF8_12_JP:
					mciSendCommandA = 0x2CA3DC8;
					break;
				}

				patch_code_dword(mciSendCommandA, (DWORD)dotemuMciSendCommandA);
			}

			if (external_music_path.empty()) external_music_path = "data/music/dmusic/ogg";
			if (external_music_volume < 0) external_music_volume = 100;
			if (external_sfx_volume < 0) external_sfx_volume = 100;
			if (external_voice_volume < 0) external_voice_volume = 100;
			if (external_ambient_volume < 0) external_ambient_volume = 100;
			if (ffmpeg_video_volume < 0) ffmpeg_video_volume = 100;
		}

		// Init metadata patcher
		if (steam_edition) metadataPatcher.init();

		// Apply hext patching
		hextPatcher.applyAll();
	}
	else if (fdwReason == DLL_PROCESS_DETACH)
	{
		unreplace_functions();
	}

	return TRUE;
}

// Steam compatibility
__declspec(dllexport) LSTATUS __stdcall dotemuRegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
	return ERROR_SUCCESS;
}

__declspec(dllexport) LSTATUS __stdcall dotemuRegCloseKey(HKEY hKey)
{
	return ERROR_SUCCESS;
}

__declspec(dllexport) LSTATUS __stdcall dotemuRegFlushKey(HKEY hKey)
{
	return ERROR_SUCCESS;
}

__declspec(dllexport) LSTATUS __stdcall dotemuRegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
{
	return ERROR_SUCCESS;
}

__declspec(dllexport) LSTATUS __stdcall dotemuRegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, LPBYTE lpData, DWORD cbData)
{
	if (ff8)
	{
		if (strcmp(lpValueName, "SFXVolume") == 0 || strcmp(lpValueName, "MusicVolume") == 0)
		{
			if (lpData[0] > 0x64)
				lpData[0] = 0x64;
		}
	}
	else
	{
		if (strcmp(lpValueName, "SFXVolume") == 0)
		{
			if (lpData[0] > 0x64)
				lpData[0] = 0x64;

			external_sfx_volume = lpData[0];
		}
		else if (strcmp(lpValueName, "MusicVolume") == 0)
		{
			if (lpData[0] > 0x64)
				lpData[0] = 0x64;

			external_music_volume = lpData[0];
		}
	}

	return ERROR_SUCCESS;
}

__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
	LSTATUS ret = ERROR_SUCCESS;

	LPSTR buf = new CHAR[*lpcbData]{ 0 };

	/* FF7 */
	// General
	if (strcmp(lpValueName, "AppPath") == 0)
	{
		GetCurrentDirectory(*lpcbData, buf);
		strcat(buf, R"(\)");

		strcpy((CHAR*)lpData, buf);
	}
	else if (strcmp(lpValueName, "DataPath") == 0)
	{
		GetCurrentDirectory(*lpcbData, buf);
		strcat(buf, R"(\data\)");

		strcpy((CHAR*)lpData, buf);
	}
	else if (strcmp(lpValueName, "DataDrive") == 0)
	{
		strcpy((CHAR*)lpData, "CD:");
	}
	else if (strcmp(lpValueName, "MoviePath") == 0)
	{
		GetCurrentDirectory(*lpcbData, buf);
		strcat(buf, R"(\data\movies\)");

		strcpy((CHAR*)lpData, buf);
	}
	else if (strcmp(lpValueName, "FullInstall") == 0)
	{
		lpData[0] = 0x1;
	}
	// Audio
	else if (strcmp(lpValueName, "DD_GUID") == 0 || strcmp(lpValueName, "Sound_GUID") == 0)
	{
		memcpy(lpData, buf, *lpcbData);
	}
	else if (strcmp(lpValueName, "MIDI_DeviceID") == 0)
	{
		lpData[0] = 0x0;
	}
	else if (strcmp(lpValueName, "Sound") == 0 || strcmp(lpValueName, "Midi") == 0 || strcmp(lpValueName, "wave_music") == 0)
	{
		ret = 2;
	}
	else if (strcmp(lpValueName, "SFXVolume") == 0)
	{
		lpData[0] = external_sfx_volume;
	}
	else if (strcmp(lpValueName, "MusicVolume") == 0)
	{
		lpData[0] = external_music_volume;
	}
	// Graphics
	else if (strcmp(lpValueName, "Driver") == 0)
	{
		lpData[0] = 0x3;
	}
	else if (strcmp(lpValueName, "DriverPath") == 0)
	{
		strcpy((CHAR*)lpData, R"(AF3DN.P)");
	}
	else if (strcmp(lpValueName, "Mode") == 0)
	{
		lpData[0] = 0x2;

		// Steam release is somehow requesting this key multiple times.
		// Returning 1 will set 2 internally in the engine
		if (*lpcbData == 256) ret = 1;
	}
	else if (strcmp(lpValueName, "Options") == 0)
	{
		lpData[0] = 0x0;
	}
	/* FF8 */
	else if (strcmp(lpValueName, "GraphicsGUID") == 0 || strcmp(lpValueName, "SoundGUID") == 0 || strcmp(lpValueName, "MIDIGUID") == 0)
	{
		memcpy(lpData, buf, 16);
	}
	else if (strcmp(lpValueName, "SoundOptions") == 0)
	{
		lpData[0] = 0x00000000;
	}
	else if (strcmp(lpValueName, "InstallOptions") == 0)
	{
		lpData[0] = 0x000000ff;
	}
	else if (strcmp(lpValueName, "MidiOptions") == 0)
	{
		lpData[0] = 0x00000001;
	}
	else if (strcmp(lpValueName, "Graphics") == 0)
	{
		lpData[0] = 0x00100021;
	}

	delete[] buf;

	return ret;
}

__declspec(dllexport) HANDLE __stdcall dotemuCreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	if (ff8_fs_last_fopen_is_redirected())
	{
		return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}

	HANDLE ret = INVALID_HANDLE_VALUE;

	if (strstr(lpFileName, "CD:") != NULL)
	{
		CHAR newPath[MAX_PATH]{ 0 };
		uint8_t requiredDisk = (*ff8_externals.savemap_field)->curr_disk;
		CHAR diskAsChar[2];

		itoa(requiredDisk, diskAsChar, 10);

		// Search for the last '\' character and get a pointer to the next char
		const char* pos = strrchr(lpFileName, 92) + 1;

		if (strstr(lpFileName, "DISK1") != NULL || strstr(lpFileName, "DISK2") != NULL || strstr(lpFileName, "DISK3") != NULL || strstr(lpFileName, "DISK4") != NULL)
		{
			PathAppendA(newPath, ff8_externals.app_path);
			PathAppendA(newPath, R"(data\disk)");
			PathAppendA(newPath, pos);

			if (strstr(lpFileName, diskAsChar) != NULL)
			{
				ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
			}
		}
	}
	else if (strstr(lpFileName, "app.log") || strstr(lpFileName, "ff8input.cfg"))
	{
		CHAR newPath[MAX_PATH]{ 0 };

		// Search for the last '\' character and get a pointer to the next char
		const char* pos = strrchr(lpFileName, 92) + 1;

		get_userdata_path(newPath, sizeof(newPath), false);
		PathAppendA(newPath, JP_VERSION ? "ff8input_jp.cfg" : pos);

		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
	else if (strstr(lpFileName, "temp.fi") || strstr(lpFileName, "temp.fl") || strstr(lpFileName, "temp.fs") || strstr(lpFileName, "temp_evn.") || strstr(lpFileName, "temp_odd."))
	{
		CHAR newPath[MAX_PATH]{ 0 };

		// Search for the last '\' character and get a pointer to the next char
		const char* pos = strrchr(lpFileName, 92) + 1;

		get_userdata_path(newPath, sizeof(newPath), false);
		PathAppendA(newPath, pos);

		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
	else if (strstr(lpFileName, ".fi") != NULL || strstr(lpFileName, ".fl") != NULL || strstr(lpFileName, ".fs") != NULL)
	{
		CHAR newPath[MAX_PATH]{ 0 };

		// Search for the last '\' character and get a pointer to the next char
		const char* pos = strrchr(lpFileName, 92) + 1;

		get_data_lang_path(newPath);
		PathAppendA(newPath, pos);

		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
	else if (StrStrIA(lpFileName, R"(SAVE\)") != NULL) // SAVE\SLOTX\saveN or save\chocorpg
	{
		CHAR newPath[MAX_PATH]{ 0 };
		CHAR saveFileName[50]{ 0 };

		// Search for the next character pointer after "SAVE\"
		const char* pos = StrStrIA(lpFileName, R"(SAVE\)") + 5;
		strcpy(saveFileName, pos);
		_strlwr(saveFileName);
		char* posSeparator = strstr(saveFileName, R"(\)");
		if (posSeparator != NULL)
		{
			*posSeparator = '_';
		}
		strcat(saveFileName, R"(.ff8)");

		get_userdata_path(newPath, sizeof(newPath), true);
		PathAppendA(newPath, saveFileName);

		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
	else
		ret = CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

	return ret;
}

__declspec(dllexport) UINT __stdcall dotemuGetDriveTypeA(LPCSTR lpRootPathName)
{
	UINT ret;

	if (strcmp(lpRootPathName, "CD:") == 0)
	{
		ret = DRIVE_CDROM;
	}
	else
	{
		ret = GetDriveTypeA(lpRootPathName);
	}

	return ret;
}

__declspec(dllexport) BOOL __stdcall dotemuDeleteFileA(LPCSTR lpFileName)
{
	BOOL ret = false;

	if (strstr(lpFileName, "app.log"))
	{
		CHAR newPath[260]{ 0 };

		// Search for the last '\' character and get a pointer to the next char
		const char* pos = strrchr(lpFileName, 92) + 1;

		get_userdata_path(newPath, 260, false);
		PathAppendA(newPath, pos);

		ret = DeleteFileA(newPath);
	}
	else if (strstr(lpFileName, "temp.fi") || strstr(lpFileName, "temp.fl") || strstr(lpFileName, "temp.fs") || strstr(lpFileName, "temp_evn.") || strstr(lpFileName, "temp_odd."))
	{
		CHAR newPath[260]{ 0 };

		// Search for the last '\' character and get a pointer to the next char
		const char* pos = strrchr(lpFileName, 92) + 1;

		get_userdata_path(newPath, 260, false);
		PathAppendA(newPath, pos);

		ret = DeleteFileA(newPath);
	}
	else
		ret = DeleteFileA(lpFileName);

	return ret;
}

// FF8 2000 Compatibility
__declspec(dllexport) HRESULT __stdcall EAXDirectSoundCreate(LPGUID guid, LPLPDIRECTSOUND directsound, IUnknown FAR* unk)
{
	typedef HRESULT(FAR PASCAL* LPEAXDIRECTSOUNDCREATE)(LPGUID, LPLPDIRECTSOUND, IUnknown FAR*);
	char eax_dll[MAX_PATH] = {};

	if (fileExists("creative_eax.dll")) {
		// For portable installation, this name can be used to load the official Creative EAX 2.0+ DLL along with FFNx
		snprintf(eax_dll, sizeof(eax_dll), R"(%s\creative_eax.dll)", basedir);
	} else {
		GetSystemDirectoryA(eax_dll, sizeof(eax_dll));
		strcat(eax_dll, R"(\eax.dll)");
	}

	FARPROC procDSoundCreate = NULL;
	HMODULE hDll = LoadLibraryA(eax_dll);
	if (hDll != NULL) {
		procDSoundCreate = GetProcAddress(hDll, "EAXDirectSoundCreate");
	}

	if (procDSoundCreate == NULL) {
		ffnx_warning("%s: Cannot load EAX Library, please install Creative EAX Unified redistribuable version 2.0+\n", __func__);

		hDll = LoadLibraryA("dsound.dll");
		if (hDll != NULL) {
			// EAXDirectSoundCreate is basically DirectSoundCreate with more features
			procDSoundCreate = GetProcAddress(hDll, "DirectSoundCreate");
		}
	}

	return LPEAXDIRECTSOUNDCREATE(procDSoundCreate)(guid, directsound, unk);
}

void ffnx_inject_driver(struct game_obj* game_object)
{
	VOBJ(game_obj, game_object, game_object);

	VRASS(game_object, current_gfx_driver, 2);
	VRASS(game_object, create_gfx_driver, new_dll_graphics_driver);
}

#if defined(__cplusplus)
}
#endif

constexpr int FFNX_LOGO_FRAME_COUNT = 180;
int ffnx_logo_current_frame = 0;

bool drawFFNxLogoFrame(struct game_obj* game_object)
{
	static int was_lighting_enabled = -1;

	if (was_lighting_enabled == -1) was_lighting_enabled = enable_lighting;

	if (ffnx_logo_current_frame >= FFNX_LOGO_FRAME_COUNT) {
		newRenderer.setOverallColorGamut(enable_ntscj_gamut_mode ? COLORGAMUT_NTSCJ : COLORGAMUT_SRGB); // set the gamut back to what it was before newRenderer.drawFFNxLogo() changed it
		enable_lighting = was_lighting_enabled;
		return false;
	}

	VOBJ(game_obj, game_object, game_object);

	int fade_frame_count = FFNX_LOGO_FRAME_COUNT / 3;
	float fade = 0.0;

	if(ffnx_logo_current_frame < fade_frame_count)
		fade = ffnx_logo_current_frame / static_cast<float>(fade_frame_count);
	else if(ffnx_logo_current_frame < 2 * fade_frame_count)
		fade = 1.0f;
	else
		fade = 1.0f - (ffnx_logo_current_frame - 2 * fade_frame_count) / static_cast<float>(fade_frame_count);

	enable_lighting = false;

	newRenderer.drawFFNxLogo(fade);

	common_flip(game_object);

	ffnx_logo_current_frame++;

	return true;
}

void stopDrawFFNxLogo()
{
	ffnx_logo_current_frame = FFNX_LOGO_FRAME_COUNT;
}
````

## File: src/common.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <windows.h>
#include <mmsystem.h>
#include <dinput.h>
#include <dsound.h>

#include "common_imports.h"

// all known OFFICIAL versions of FF7 & FF8 released for the PC
#define VERSION_FF7_102_US          1
#define VERSION_FF7_102_FR          2
#define VERSION_FF7_102_DE          3
#define VERSION_FF7_102_SP          4
#define VERSION_FF8_12_US           5
#define VERSION_FF8_12_US_NV        6
#define VERSION_FF8_12_FR           7
#define VERSION_FF8_12_FR_NV        8
#define VERSION_FF8_12_DE           9
#define VERSION_FF8_12_DE_NV       10
#define VERSION_FF8_12_SP          11
#define VERSION_FF8_12_SP_NV       12
#define VERSION_FF8_12_IT          13
#define VERSION_FF8_12_IT_NV       14
#define VERSION_FF8_12_US_EIDOS    15
#define VERSION_FF8_12_US_EIDOS_NV 16
#define VERSION_FF8_12_JP          17
#define VERSION_FF8_12_JP_NV       18

// Steam app id of FF7 & FF8
#define FF7_APPID 39140
#define FF8_APPID 39150

#define NV_VERSION (!(version & 1))
#define JP_VERSION (version == VERSION_FF8_12_JP || version == VERSION_FF8_12_JP_NV)
#define FF8_US_VERSION (version == VERSION_FF8_12_US || version == VERSION_FF8_12_US_NV || version == VERSION_FF8_12_US_EIDOS || version == VERSION_FF8_12_US_EIDOS_NV)
#define FF8_SP_VERSION (version == VERSION_FF8_12_SP || version == VERSION_FF8_12_SP_NV)
#define FF8_IT_VERSION (version == VERSION_FF8_12_IT || version == VERSION_FF8_12_IT_NV)

// FF8 does not support BLUE text!
enum
{
	TEXTCOLOR_GRAY,
	TEXTCOLOR_BLUE,
	TEXTCOLOR_RED,
	TEXTCOLOR_PINK,
	TEXTCOLOR_GREEN,
	TEXTCOLOR_LIGHT_BLUE,
	TEXTCOLOR_YELLOW,
	TEXTCOLOR_WHITE,
	NUM_TEXTCOLORS
};

enum game_modes
{
	MODE_FIELD = 0,
	MODE_BATTLE,
	MODE_WORLDMAP,
	MODE_MENU,
	MODE_HIGHWAY,
	MODE_CHOCOBO,
	MODE_SNOWBOARD,
	MODE_CONDOR,
	MODE_SUBMARINE,
	MODE_COASTER,
	MODE_CDCHECK,
	MODE_EXIT,
	MODE_SWIRL,
	MODE_GAMEOVER,
	MODE_ENDINGMOVIE,
	MODE_CREDITS,
	MODE_INTRO,
	MODE_CARDGAME,
	MODE_UNKNOWN,
	MODE_AFTER_BATTLE,
	MODE_MAIN_MENU,
};

enum AspectRatioMode
{
	AR_ORIGINAL = 0,
	AR_STRETCH,
	AR_WIDESCREEN_16X9,
	AR_WIDESCREEN_16X10,
	AR_COUNT
};

enum GamepadAnalogueIntent
{
	INTENT_NONE,
	INTENT_WALK,
	INTENT_RUN
};

// popup lifetime in frames
#define POPUP_TTL_MAX 10000

// dummy TEX version for framebuffer textures
#define FB_TEX_VERSION 100

struct game_mode
{
	uint32_t mode;
	char *name;
	uint32_t driver_mode;
	uint32_t trace;
	uint32_t main_loop;
};

struct light_data
{
	bgra_color global_light_color;
	vector3<float> light_dir_1;
	bgra_color light_color_1;
	vector3<float> light_dir_2;
	bgra_color light_color_2;
	vector3<float> light_dir_3;
	bgra_color light_color_3;
	bgra_color scripted_light_color;
};

gfx_init common_init;
gfx_cleanup common_cleanup;
gfx_lock common_lock;
gfx_unlock common_unlock;
gfx_flip common_flip;
gfx_clear common_clear;
gfx_clear_all common_clear_all;
gfx_setviewport common_setviewport;
gfx_setbg common_setbg;
gfx_prepare_polygon_set common_prepare_polygon_set;
gfx_load_group common_load_group;
gfx_setmatrix common_setmatrix;
gfx_light_polygon_set common_light_polygon_set;
gfx_unload_texture common_unload_texture;
gfx_load_texture common_load_texture;
gfx_palette_changed common_palette_changed;
gfx_write_palette common_write_palette;
gfx_blendmode common_blendmode;
gfx_light_polygon_set ff7gl_light_polygon_set;
gfx_field_64 common_field_64;
gfx_setrenderstate common_setrenderstate;
gfx_field_74 common_field_74;
gfx_field_78 common_field_78;
gfx_draw_deferred common_draw_deferred;
gfx_field_80 common_field_80;
gfx_field_84 common_field_84;
gfx_begin_scene common_begin_scene;
gfx_end_scene common_end_scene;
gfx_field_90 common_field_90;
gfx_polysetrenderstate common_setrenderstate_2D;
gfx_draw_vertices common_draw_2D;
gfx_draw_vertices common_draw_paletted2D;
gfx_polysetrenderstate common_setrenderstate_3D;
gfx_draw_vertices common_draw_3D;
gfx_draw_vertices common_draw_paletted3D;
gfx_draw_vertices common_draw_lines;
gfx_field_EC common_field_EC;

/*
 * This structure holds memory addresses and function pointers of the original
 * engine used within this program. Not all of them are currently used for both
 * games, MIDI functions for example are only used for FF7 but they could
 * concievably be used for FF8 aswell.
 */

struct common_externals
{
	WORD *_mode;
	WORD *_previous_mode;
	uint32_t dinput_hack1;
	gfx_load_group *generic_load_group;
	gfx_light_polygon_set *generic_light_polygon_set;
	void *(*assert_free)(void *, const char *, uint32_t);
	void *(*assert_malloc)(uint32_t, const char *, uint32_t);
	void *(*assert_calloc)(uint32_t, uint32_t, const char *, uint32_t);
	IDirectSound **directsound;
	uint32_t directsound_create;
	uint32_t directsound_createsoundbuffer;
	uint32_t directsound_release;
	struct palette *(*create_palette_for_tex)(uint32_t, struct tex_header *, struct texture_set *);
	struct game_obj *(*get_game_object)();
	struct texture_format *(*create_texture_format)();
	void (*add_texture_format)(struct texture_format *, struct game_obj *);
	void (*make_pixelformat)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, struct texture_format *);
	struct texture_set *(*create_texture_set)();
	uint32_t debug_print;
	uint32_t debug_print2;
	uint32_t prepare_movie;
	uint32_t release_movie_objects;
	uint32_t start_movie;
	uint32_t update_movie_sample;
	uint32_t stop_movie;
	uint32_t get_movie_frame;
	struct tex_header *(*create_tex_header)();
	uint64_t (*get_time)(uint64_t*);
	uint64_t (*diff_time)(uint64_t*,uint64_t*,uint64_t*);
	uint32_t midi_init;
	uint32_t midi_cleanup;
	uint32_t wav_cleanup;
	char *(*get_midi_name)(uint32_t);
	uint32_t use_midi;
	uint32_t play_midi;
	uint32_t play_wav;
	uint32_t stop_midi;
	uint32_t stop_wav;
	uint32_t cross_fade_midi;
	uint32_t pause_midi;
	uint32_t pause_wav;
	uint32_t restart_midi;
	uint32_t restart_wav;
	uint32_t midi_status;
	DWORD* master_midi_volume;
	uint32_t set_master_midi_volume;
	uint32_t set_midi_volume;
	uint32_t set_midi_volume_trans;
	uint32_t set_midi_volume_fade;
	uint32_t set_midi_tempo;
	uint32_t remember_midi_playing_time;
	uint32_t draw_graphics_object;
	char *font_info;
	uint32_t build_dialog_window;
	uint32_t write_file;
	uint32_t close_file;
	uint32_t open_file;
	uint32_t read_file;
	uint32_t __read_file;
	uint32_t get_filesize;
	uint32_t tell_file;
	uint32_t seek_file;
	void *(*alloc_read_file)(uint32_t, uint32_t, struct file *);
	void *(*alloc_get_file)(struct file_context *, uint32_t *, char *);
	void (*destroy_tex)(struct tex_header *);
	uint32_t destroy_tex_header;
	uint32_t start;
	uint32_t winmain;
	uint32_t load_tex_file;
	uint32_t directsound_buffer_flags_1;
	uint32_t sfx_init;
	uint32_t sfx_cleanup;
	uint32_t sfx_load;
	uint32_t sfx_unload;
	uint32_t sfx_pause;
	uint32_t sfx_resume;
	uint32_t sfx_stop;
	uint32_t sfx_release;
	uint32_t (*play_sfx)(uint32_t);
	uint32_t (*play_sfx_effects)(byte, uint32_t, uint32_t, uint32_t, uint32_t);
	uint32_t play_sfx_on_channel;
	uint32_t (*set_sfx_volume_on_channel)(uint32_t, uint32_t);
	uint32_t (*set_sfx_volume_trans_on_channel)(uint32_t, uint32_t, uint32_t);
	uint32_t (*set_sfx_panning_on_channel)(uint32_t, uint32_t);
	uint32_t (*set_sfx_panning_trans_on_channel)(uint32_t, uint32_t, uint32_t);
	uint32_t (*set_sfx_frequency_on_channel)(uint32_t, uint32_t);
	uint32_t (*set_sfx_frequency_trans_on_channel)(uint32_t, uint32_t, uint32_t);
	uint32_t *master_sfx_volume;
	uint32_t* dsound_volume_table;
	IDirectInputDeviceA **keyboard_device;
	uint32_t get_keyboard_state;
	uint32_t *keyboard_connected;
	int (*dinput_acquire_keyboard)();
	uint32_t create_window;
	WNDPROC engine_wndproc;
	uint32_t* execute_opcode_table;
	uint32_t update_field_entities;
	WORD* current_field_id;
	char* current_field_name;
	WORD* previous_field_id;
	uint32_t update_entities_call;
	int16_t* current_triangle_id;
	WORD* field_game_moment;
};

// heap allocation wrappers
// driver_* functions are to be used for data internal to the driver, memory which is never allocated or free'd by the game
// external_* functions must be used for memory which could be allocated or free'd by the game
#ifndef NO_EXT_HEAP
#define external_free(x) common_externals.assert_free(x, "", 0)
#define external_malloc(x) common_externals.assert_malloc(x, "", 0)
#define external_calloc(x, y) common_externals.assert_calloc(x, y, "", 0)
#else
void ext_free(void *ptr, const char *file, uint32_t line);
void *ext_malloc(uint32_t size, const char *file, uint32_t line);
void *ext_calloc(uint32_t size, uint32_t num, const char *file, uint32_t line);

#define external_free(x) ext_free(x, "", 0)
#define external_malloc(x) ext_malloc(x, "", 0)
#define external_calloc(x, y) ext_calloc(x, y, "", 0)
#endif

#ifndef HEAP_DEBUG
#define driver_malloc(x) malloc(x)
#define driver_calloc(x, y) calloc(x, y)
#define driver_free(x) free(x)
#define driver_realloc(x, y) realloc(x, y)
#else
void *driver_malloc(uint32_t size);
void *driver_calloc(uint32_t size, uint32_t num);
void driver_free(void *ptr);
void *driver_realloc(void *ptr, uint32_t size);
#endif

// profiling routines
#ifdef PROFILE
#define PROFILE_START() qpc_get_time(&profile_start)
#define PROFILE_END() { qpc_get_time(&profile_end); profile_total += profile_end - profile_start; }

extern time_t profile_start;
extern time_t profile_end;
extern time_t profile_total;
#endif PROFILE

struct driver_stats
{
	uint32_t texture_count;
	uint32_t external_textures;
	uint32_t ext_cache_size;
	uint32_t texture_reloads;
	uint32_t palette_writes;
	uint32_t palette_changes;
	uint32_t vertex_count;
	uint32_t deferred;
	time_t timer;
};

time_t qpc_get_time(time_t *dest);
time_t qpc_diff_time(time_t* t1, time_t* t2, time_t* out);
uint32_t get_version();
struct game_mode *getmode();
struct game_mode *getmode_cached();
struct tex_header *make_framebuffer_tex(uint32_t tex_w, uint32_t tex_h, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color_key);
void internal_set_renderstate(uint32_t state, uint32_t option, struct game_obj *game_object);
uint32_t create_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header);
void blit_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header);

void get_data_lang_path(PCHAR buffer);
void get_userdata_path(PCHAR buffer, size_t bufSize, bool isSavegameFile);

#if defined(__cplusplus)
extern "C" {
#endif

void ffnx_inject_driver(struct game_obj* game_object);

#if defined(__cplusplus)
}
#endif

bool drawFFNxLogoFrame(struct game_obj* game_object);
void stopDrawFFNxLogo();
````

## File: src/crashdump.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <shlwapi.h>
#include <commctrl.h>

#include "audio.h"

#include "crashdump.h"
#include "utils.h"

// FF7 save file checksum, original by dziugo
int ff7_checksum(void* qw)
{
	int i = 0, t, d;
	long r = 0xFFFF, len = 4336;
	long pbit = 0x8000;
	char* b = (char*)qw;

	while(len--)
	{
		t = b[i++];
		r ^= t << 8;

		for(d = 0; d < 8; d++)
		{
			if(r & pbit) r = (r << 1) ^ 0x1021;
			else r <<= 1;
		}

		r &= (1 << 16) - 1;
	}

	return (r ^ 0xFFFF) & 0xFFFF;
}

static const char save_name[] = "\x25" "MERGENCY" "\x00\x33" "AVE" "\xFF";

HRESULT CALLBACK TaskDialogCallbackProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData) {
	if (msg == TDN_HYPERLINK_CLICKED) {
		LPCWSTR url = (LPCWSTR)lParam;
		ShellExecuteW(NULL, L"open", url, NULL, NULL, SW_SHOWNORMAL);
	}
	return S_OK;
}

LONG WINAPI ExceptionHandler(EXCEPTION_POINTERS *ep)
{
	static uint32_t had_exception = false;
	char filePath[260]{ 0 };

	// give up if we crash again inside the exception handler (this function)
	if(had_exception)
	{
		ffnx_unexpected("ExceptionHandler: crash while running another ExceptionHandler. Exiting.");
		SetUnhandledExceptionFilter(0);
		return EXCEPTION_CONTINUE_EXECUTION;
	}

	ffnx_trace("*** Exception 0x%x, address 0x%x ***\n", ep->ExceptionRecord->ExceptionCode, ep->ExceptionRecord->ExceptionAddress);
	FFNxStackWalker sw;
	sw.ShowCallstack(
		GetCurrentThread(),
		ep->ContextRecord
	);

	had_exception = true;

	// show cursor in case it was hidden
	while (ShowCursor(true) < 0);

	if (create_crash_dump)
	{
		if (steam_edition) get_userdata_path(filePath, sizeof(filePath), false);
		PathAppendA(filePath, "crash.dmp");

		HANDLE file = CreateFile(filePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
		HANDLE proc = GetCurrentProcess();
		DWORD procid = GetCurrentProcessId();
		MINIDUMP_EXCEPTION_INFORMATION mdei;

		CONTEXT c;
		HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());;
		memset(&c, 0, sizeof(c));
		c.ContextFlags = CONTEXT_FULL;
		GetThreadContext(hThread, &c);

		mdei.ThreadId = GetCurrentThreadId();
		mdei.ExceptionPointers = ep;
		mdei.ExceptionPointers->ContextRecord = &c;
		mdei.ClientPointers = true;

		if (!MiniDumpWriteDump(
			proc,
			procid,
			file,
			(MINIDUMP_TYPE)(MiniDumpWithFullMemory |
				MiniDumpWithFullMemoryInfo |
				MiniDumpWithHandleData |
				MiniDumpWithUnloadedModules |
				MiniDumpWithThreadInfo),
			&mdei, NULL, NULL)) {
			ffnx_trace("MiniDumpWriteDump failed with error: %ls\n", GetErrorMessage(GetLastError()));
		}
	}


	if(!ff8)
	{
		memset(filePath, 0, sizeof(filePath));

		if (steam_edition)
		{
			get_userdata_path(filePath, sizeof(filePath), false);
			PathAppendA(filePath, "crash.ff7");
		}
		else
		{
			PathAppendA(filePath, "save/crash.ff7");
		}

		// try to dump the current savemap from memory
		// the savemap could be old, inconsistent or corrupted at this point
		// avoid playing from an emergency save if at all possible!
		FILE *f = fopen(filePath, "wb");
		uint32_t magic = 0x6277371;
		uint32_t bitmask = 1;
		struct savemap dummy[14];

		memset(dummy, 0, sizeof(dummy));

		memcpy(ff7_externals.savemap->preview_location, save_name, sizeof(save_name));

		ff7_externals.savemap->checksum = ff7_checksum(&(ff7_externals.savemap->preview_level));

		fwrite(&magic, 4, 1, f);
		fwrite("", 1, 1, f);
		fwrite(&bitmask, 4, 1, f);
		fwrite(ff7_externals.savemap, sizeof(*ff7_externals.savemap), 1, f);
		fwrite(dummy, sizeof(dummy), 1, f);
		fclose(f);
	}

	ffnx_error("Unhandled Exception. See dumped information above.\n");

	TASKDIALOGCONFIG config = { sizeof(config) };
	config.hwndParent = gameHwnd;
	config.dwFlags = TDF_ENABLE_HYPERLINKS;
	config.pszWindowTitle = L"Something went wrong";
	config.pszMainInstruction = L"Game crashed :(";
	config.pszContent = L"Something unexpected happened and unfortunately the game crashed.\n\nFeel free to visit <a href=\"https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/faq.md\">this link</a> to know about further next steps you can take.";
	config.pszMainIcon = TD_ERROR_ICON;
	config.pfCallback = TaskDialogCallbackProc;

	TaskDialogIndirect(&config, NULL, NULL, NULL);

	// Cleanup the audio device
	nxAudioEngine.cleanup();

	// let OS handle the crash
	SetUnhandledExceptionFilter(0);
	return EXCEPTION_CONTINUE_EXECUTION;
}
````

## File: src/crashdump.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <StackWalker.h>
#include <dbghelp.h>

#include "log.h"

#define STACK_MAX_NAME_LENGTH 256

class FFNxStackWalker : public StackWalker
{
public:
    FFNxStackWalker(bool muted = false) : StackWalker(), _baseAddress(0), _size(0), _muted(muted) {}
    DWORD64 getBaseAddress() const {
        return _baseAddress;
    }
    DWORD getSize() const {
        return _size;
    }
protected:
    virtual void OnLoadModule(LPCSTR img, LPCSTR mod, DWORD64 baseAddr,
        DWORD size, DWORD result, LPCSTR symType, LPCSTR pdbName,
        ULONGLONG fileVersion
    )
    {
        if (_baseAddress == 0 && _size == 0)
        {
            _baseAddress = baseAddr;
            _size = size;
        }
        StackWalker::OnLoadModule(
            img, mod, baseAddr, size, result, symType, pdbName, fileVersion
        );
    }

    virtual void OnDbgHelpErr(LPCSTR szFuncName, DWORD gle, DWORD64 addr)
    {
        // Silence is golden.
    }

    virtual void OnOutput(LPCSTR szText)
    {
        if (! _muted)
        {
            ffnx_trace(szText);
        }
    }
private:
    DWORD64 _baseAddress;
    DWORD _size;
    bool _muted;
};

LONG WINAPI ExceptionHandler(EXCEPTION_POINTERS *ep);
````

## File: src/exe_data.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2024 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "common.h"
#include "log.h"
#include "utils.h"
#include "patch.h"
#include "saveload.h"

uint8_t *ff8_exe_scan_texts = nullptr;
uint8_t *ff8_exe_card_names = nullptr;
uint8_t *ff8_exe_draw_point = nullptr;
uint8_t *ff8_exe_card_texts = nullptr;

bool ff8_get_exe_path(const char *name, char *target_filename)
{
    snprintf(target_filename, MAX_PATH, "%s/%s/exe/%s.msd", basedir, direct_mode_path.c_str(), name);
    normalize_path(target_filename);

    return fileExists(target_filename);
}

bool ff8_get_battle_scan_texts_filename(char *filename)
{
    return ff8_get_exe_path("battle_scans", filename);
}

bool ff8_get_card_names_filename(char *filename)
{
    return ff8_get_exe_path("card_names", filename);
}

bool ff8_get_draw_point_filename(char *filename)
{
    return ff8_get_exe_path("draw_point", filename);
}

bool ff8_get_card_texts_filename(char *filename)
{
    return ff8_get_exe_path("card_texts", filename);
}

void ff8_dump_msd(const char *filename, uint8_t *data)
{
    uint32_t *offsets = (uint32_t *)data;
    uint32_t first_offset = *offsets;
    int text_count = first_offset / 4;
    int higher_offset = 0;

    for (int i = 0; i < text_count; ++i) {
        if (offsets[i] > higher_offset) {
            higher_offset = offsets[i];
        }
    }

    for (int i = higher_offset; i < higher_offset + 1024; ++i) {
        if (data[i] == '\0') {
            higher_offset = i + 1;
            break;
        }
    }

    FILE *f = fopen(filename, "wb");

    if (f == nullptr) {
        return;
    }

    fwrite(data, first_offset + higher_offset, 1, f);
    fclose(f);
}

void ff8_dump_battle_scan_texts()
{
    uint8_t *data = (uint8_t *)ff8_externals.scan_text_data;
    uint16_t *offsets_rel_to_data = (uint16_t *)ff8_externals.scan_text_positions;
    int text_count = int((uint16_t *)data - offsets_rel_to_data);
    uint16_t data_offset = text_count * sizeof(uint32_t);
    uint32_t offsets_rel_to_start[0x200] = {};
    int higher_offset = 0;

    for (int i = 0; i < text_count; ++i) {
        offsets_rel_to_start[i] = offsets_rel_to_data[i] + data_offset;
        if (offsets_rel_to_data[i] > higher_offset) {
            higher_offset = offsets_rel_to_data[i];
        }
    }

    for (int i = higher_offset; i < higher_offset + 1024; ++i) {
        if (data[i] == '\0') {
            higher_offset = i + 1;
            break;
        }
    }

    char filename[MAX_PATH] = {};
    if (ff8_get_battle_scan_texts_filename(filename)) {
        ffnx_warning("Save exe file skipped because the file [ %s ] already exists.\n", filename);

        return;
    }

    FILE *f = fopen(filename, "wb");

    if (f == nullptr) {
        return;
    }

    fwrite(offsets_rel_to_start, data_offset, 1, f);
    fwrite(data, higher_offset, 1, f);
    fclose(f);
}

void ff8_dump_card_names()
{
    uint8_t *data = *(uint8_t **)ff8_externals.card_name_positions;
    uint16_t *positions = *(uint16_t **)ff8_externals.card_name_positions;
    constexpr int text_count = 110;
    uint16_t old_data_offset = (1 + text_count) * sizeof(uint16_t), new_data_offset = text_count * sizeof(uint32_t);
    uint32_t offsets_rel_to_start[text_count] = {};
    int higher_offset = 0;

    for (int i = 0; i < text_count; ++i) {
        offsets_rel_to_start[i] = positions[i + 1] - old_data_offset + new_data_offset;
        if (positions[i + 1] > higher_offset) {
            higher_offset = positions[i + 1];
        }
    }

    for (int i = higher_offset; i < higher_offset + 1024; ++i) {
        if (data[i] == '\0') {
            higher_offset = i + 1;
            break;
        }
    }

    char filename[MAX_PATH] = {};
    if (ff8_get_card_names_filename(filename)) {
        ffnx_warning("Save exe file skipped because the file [ %s ] already exists.\n", filename);

        return;
    }

    FILE *f = fopen(filename, "wb");

    if (f == nullptr) {
        return;
    }

    fwrite(offsets_rel_to_start, new_data_offset, 1, f);
    fwrite(data + old_data_offset, higher_offset - old_data_offset, 1, f);
    fclose(f);
}

void ff8_dump_card_texts()
{
    uint8_t *data = *ff8_externals.card_texts_off_B96968;
    uint16_t *offsets = (uint16_t *)(data + 2);
    uint32_t first_offset = *offsets;
    int text_count = first_offset / 4;
    int higher_offset = 0;
    uint32_t offsets_rel_to_start[0x200] = {};

    for (int i = 0; i < text_count; ++i) {
        offsets_rel_to_start[i] = offsets[i * 2];
        if (offsets[i * 2] > higher_offset) {
            higher_offset = offsets[i * 2];
        }
    }

    for (int i = higher_offset; i < higher_offset + 1024; ++i) {
        if (data[i] == '\0') {
            higher_offset = i + 1;
            break;
        }
    }

    char filename[MAX_PATH] = {};
    if (ff8_get_card_texts_filename(filename)) {
        ffnx_warning("Save exe file skipped because the file [ %s ] already exists.\n", filename);

        return;
    }

    FILE *f = fopen(filename, "wb");

    if (f == nullptr) {
        return;
    }

    fwrite(offsets_rel_to_start, text_count * 4, 1, f);
    fwrite(data + first_offset, higher_offset - first_offset, 1, f);
    fclose(f);
}

uint8_t *ff8_open_msd(char *filename, int *data_size = nullptr)
{
    if (trace_all || trace_direct) ffnx_info("Direct file using %s\n", filename);

    if (data_size != nullptr) {
        *data_size = 0;
    }

    FILE *f = fopen(filename, "rb");

    if (f == nullptr) {
        return nullptr;
    }

    fseek(f, 0, SEEK_END);
    long file_size = ftell(f);
    fseek(f, 0, SEEK_SET);

    uint8_t *target_data = (uint8_t *)driver_malloc(file_size); // Allocated once, never freed

    if (target_data == nullptr) {
        return nullptr;
    }

    fread(target_data, file_size, 1, f);
    fclose(f);

    if (data_size != nullptr) {
        *data_size = file_size;
    }

    return target_data;
}

uint8_t *ff8_override_battle_scans()
{
    if (ff8_exe_scan_texts != nullptr) {
        return ff8_exe_scan_texts;
    }

    char filename[MAX_PATH] = {};
    if (! ff8_get_battle_scan_texts_filename(filename)) {
        if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);

        return nullptr;
    }

    ff8_exe_scan_texts = ff8_open_msd(filename);

    return ff8_exe_scan_texts;
}

uint8_t *ff8_override_card_names()
{
    if (ff8_exe_card_names != nullptr) {
        return ff8_exe_card_names;
    }

    char filename[MAX_PATH] = {};
    if (! ff8_get_card_names_filename(filename)) {
        if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);

        return nullptr;
    }

    ff8_exe_card_names = ff8_open_msd(filename);

    return ff8_exe_card_names;
}

uint8_t *ff8_override_draw_point()
{
    if (ff8_exe_draw_point != nullptr) {
        return ff8_exe_draw_point;
    }

    char filename[MAX_PATH] = {};
    if (! ff8_get_draw_point_filename(filename)) {
        if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);

        return nullptr;
    }

    ff8_exe_draw_point = ff8_open_msd(filename);

    return ff8_exe_draw_point;
}

uint8_t *ff8_override_card_texts()
{
    if (ff8_exe_card_texts != nullptr) {
        return ff8_exe_card_texts;
    }

    char filename[MAX_PATH] = {};
    if (! ff8_get_card_texts_filename(filename)) {
        if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);

        return nullptr;
    }

    int data_size = 0;
    uint8_t *ff8_exe_card_texts_msd = ff8_open_msd(filename, &data_size);

    if (ff8_exe_card_texts_msd == nullptr) {
        return nullptr;
    }

    ff8_exe_card_texts = (uint8_t *)driver_malloc(data_size + 16); // Allocated once, never freed

    if (ff8_exe_card_texts == nullptr) {
        driver_free(ff8_exe_card_texts_msd);

        return nullptr;
    }

    uint32_t *msd_offsets = (uint32_t *)ff8_exe_card_texts_msd;
    *(uint16_t *)ff8_exe_card_texts = *(uint16_t *)*ff8_externals.card_texts_off_B96968;
    int text_count = 256;

    for (int i = 0; i < text_count; ++i) {
        if (msd_offsets[i] / 4 < text_count) {
            text_count = msd_offsets[i] / 4;
        }
    }

    // We shift the positions (+2)
    memcpy(ff8_exe_card_texts + 2, ff8_exe_card_texts_msd, text_count * 4);
    // But not the texts!
    memcpy(ff8_exe_card_texts + text_count * 4, ff8_exe_card_texts_msd + text_count * 4, data_size - text_count * 4);

    driver_free(ff8_exe_card_texts_msd);

    return ff8_exe_card_texts;
}

uint8_t *ff8_battle_get_scan_text(uint8_t target_id)
{
    uint8_t *direct_data_msd = ff8_override_battle_scans();

    if (direct_data_msd != nullptr) {
        uint32_t *positions = (uint32_t *)direct_data_msd;
        uint8_t *entities = (uint8_t *)ff8_externals.battle_entities_1D27BCB;

        if (trace_all) ffnx_trace("%s: get scan text target_id=%d entity_id=%d\n", __func__, target_id, entities[208 * target_id]);

        return direct_data_msd + positions[entities[208 * target_id]];
    }

    return ((uint8_t*(*)(uint8_t))ff8_externals.scan_get_text_sub_B687C0)(target_id);
}

char *ff8_get_card_name(int32_t card_id)
{
    if (card_id >= 110) {
        return nullptr;
    }

    uint8_t *direct_data_msd = ff8_override_card_names();
    if (direct_data_msd != nullptr) {
        uint32_t *positions = (uint32_t *)direct_data_msd;

        if (trace_all) ffnx_trace("%s: get card name card_id=%d\n", __func__, card_id);

        return (char *)direct_data_msd + positions[card_id];
    }

    uint16_t *positions = *(uint16_t **)ff8_externals.card_name_positions;

    return *(char **)ff8_externals.card_name_positions + positions[card_id + 1];
}

void dump_exe_data()
{
    char dirname[MAX_PATH] = {};
    snprintf(dirname, sizeof(dirname), "%s/%s/exe/", basedir, direct_mode_path.c_str());

    normalize_path(dirname);
    make_path(dirname);

    if (ff8)
    {
        ff8_dump_battle_scan_texts();
        ff8_dump_card_names();

        if (!ff8_get_draw_point_filename(dirname)) {
            ff8_dump_msd(dirname, *(uint8_t **)ff8_externals.drawpoint_messages);
        }

        ff8_dump_card_texts();
    }
}

void exe_data_init()
{
    if (save_exe_data)
    {
        dump_exe_data();
    }

    if (ff8)
    {
        replace_call(ff8_externals.sub_84F8D0 + 0x88, ff8_battle_get_scan_text);
        replace_function(ff8_externals.get_card_name, ff8_get_card_name);
        uint8_t *msd = ff8_override_draw_point();
        if (msd != nullptr) {
            patch_code_uint(ff8_externals.drawpoint_messages, uint32_t(msd));
        }
        msd = ff8_override_card_texts();
        if (msd != nullptr) {
            patch_code_uint(uint32_t(ff8_externals.card_texts_off_B96504), uint32_t(msd));
            patch_code_uint(uint32_t(ff8_externals.card_texts_off_B96968), uint32_t(msd));
        }
    }
}
````

## File: src/exe_data.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2024 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

void exe_data_init();
````

## File: src/external_mesh.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "external_mesh.h"

#include "cfg.h"
#include "log.h"
#include "utils.h"

#define CGLTF_IMPLEMENTATION
#include "cgltf.h"

bool ExternalMesh::importExternalMeshGltfFile(char* file_path, char* tex_path)
{
	cgltf_options options = {0};
	cgltf_data* data = NULL;
	cgltf_result result = cgltf_parse_file(&options, file_path, &data);
	if (result != cgltf_result_success)
	{
		return false;
	}

	result = cgltf_load_buffers(&options, data, file_path);
	if (result != cgltf_result_success)
	{
		return false;
	}

    std::string modelPath = file_path;
    std::string modelFolder = modelPath.substr(0, modelPath.find_last_of("/") + 1);
    std::string modelFilename =  modelPath.substr(modelPath.find_last_of("/") + 1);
    std::string modelFilenameWithoutExt =  modelFilename.substr(0, modelFilename.find_last_of("."));
    std::string configPath = modelFolder + modelFilenameWithoutExt + "_config.toml";
    loadConfig(configPath);

	for (size_t i = 0; i < data->textures_count; i++)
	{
		auto texture = data->textures[i];
		std::string relativePath = texture.image->uri;

		std::string filename = relativePath.substr(relativePath.find_last_of("/") + 1);
		std::string name = filename.substr(0, filename.find_last_of("."));

		std::string texFullPath = tex_path + name + ".dds";

        std::string modPath = !override_mod_path.empty() ? override_mod_path : mod_path;

        Material candidateMaterial;

        auto pair = materials.emplace(name, candidateMaterial);
        if(pair.second)
        {
            auto& material = (*pair.first).second;
            uint32_t width, height, mipCount = 0;

            char full_tex_path[512];

            int texCount = getTextureCount(name);
            material.frameInterval = getFrameInterval(name);
            for (int texIndex = 0; texIndex < texCount; ++texIndex)
            {
                if (texIndex != 0)
                {
                    auto nameWithoutNumber = name.substr(0, name.length() - 1);
                    _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s%s_00.dds", basedir, modPath.c_str(), nameWithoutNumber.data(), std::to_string(texIndex + 1).data());
                }
                else
                    _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s_00.dds", basedir, modPath.c_str(), name.data());

                auto textureHandle = newRenderer.createTextureHandle(full_tex_path, &width, &height, &mipCount);
                if (!textureHandle.idx)
                {
                    if (texIndex != 0)
                        _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s%s.dds", basedir, modPath.c_str(), name.data(), std::to_string(texIndex + 1).data());
                    else
                        _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s.dds", basedir, modPath.c_str(), name.data());

                    textureHandle = newRenderer.createTextureHandle(texFullPath.data(), &width, &height, &mipCount);
                    if (!textureHandle.idx) textureHandle = BGFX_INVALID_HANDLE;
                }

                if(bgfx::isValid(textureHandle))
                {
                    material.baseColorTexHandles.push_back(textureHandle);
                }
            }

            std::string nmlTexFullPath = tex_path + name + "_nml.dds";
            auto nmlTextureHandle = newRenderer.createTextureHandle(nmlTexFullPath.data(), &width, &height, &mipCount, false);
            if (!nmlTextureHandle.idx) nmlTextureHandle = BGFX_INVALID_HANDLE;
            if(bgfx::isValid(nmlTextureHandle))
            {
                material.normalTexHandles.push_back(nmlTextureHandle);
            }

            std::string pbrTexFullPath = tex_path + name + "_pbr.dds";
            auto pbrTextureHandle = newRenderer.createTextureHandle(pbrTexFullPath.data(), &width, &height, &mipCount, false);
            if (!pbrTextureHandle.idx) pbrTextureHandle = BGFX_INVALID_HANDLE;
            if(bgfx::isValid(pbrTextureHandle))
            {
                material.pbrTexHandles.push_back(pbrTextureHandle);
            }
        }
	}

	for (size_t i = 0; i < data->meshes_count; i++)
	{
		cgltf_mesh mesh = data->meshes[i];

		for (size_t j = 0; j < mesh.primitives_count; j++)
		{
			Shape outShape;

			cgltf_primitive primitive = mesh.primitives[j];
			auto indexCount = primitive.indices->count;
			auto vertexCount = 0;

			float* posBuffer = nullptr;
			float* normalBuffer = nullptr;
			float* uvBuffer = nullptr;
			float* colorBuffer = nullptr;
			for (size_t k = 0; k < primitive.attributes_count; k++)
			{
				cgltf_attribute attr = primitive.attributes[k];

				if(strcmp(attr.name, "POSITION") == 0)
				{
					vertexCount = attr.data->count;
					posBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
					outShape.min.x = attr.data->min[0];
					outShape.min.y = attr.data->min[1];
					outShape.min.z = attr.data->min[2];
					outShape.max.x = attr.data->max[0];
					outShape.max.y = attr.data->max[1];
					outShape.max.z = attr.data->max[2];
				}
				else if(strcmp(attr.name, "NORMAL") == 0)
				{
					normalBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
				}
				else if(strcmp(attr.name, "TEXCOORD_0") == 0)
				{
					uvBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
				}
				else if(strcmp(attr.name, "COLOR_0") == 0)
				{
					colorBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
				}
			}

            outShape.isDoubleSided = primitive.material->double_sided;

			auto texture = primitive.material->pbr_metallic_roughness.base_color_texture.texture;
			if(texture != nullptr)
			{
				std::string texName = texture->image->name;
				if(materials.contains(texName)) outShape.pMaterial = &materials[texName];
			}
			auto baseColorFactor = primitive.material->pbr_metallic_roughness.base_color_factor;
			for (int vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)
			{
				struct nvertex vertex;
				vertex._.x = posBuffer[3 * vertexIndex];
				vertex._.y = posBuffer[3 * vertexIndex + 2];
				vertex._.z = posBuffer[3 * vertexIndex + 1];

				vertex.color.w = 1.0f;
				vertex.color.r = static_cast<char>(baseColorFactor[0] * 255);
				vertex.color.g = static_cast<char>(baseColorFactor[1] * 255);
				vertex.color.b = static_cast<char>(baseColorFactor[2] * 255);
				vertex.color.a = static_cast<char>(baseColorFactor[3] * 255);

                if (uvBuffer != nullptr)
                {
				    vertex.u = uvBuffer[2 * vertexIndex];
				    vertex.v = uvBuffer[2 * vertexIndex + 1];
                }
                else
                {
                    vertex.u = 0.0f;
				    vertex.v = 0.0f;
                }

				outShape.vertices.push_back(vertex);

				struct vector3<float> normal;

				normal.x = normalBuffer[3 * vertexIndex];
				normal.y = normalBuffer[3 * vertexIndex + 2];
				normal.z = normalBuffer[3 * vertexIndex + 1];

				outShape.normals.push_back(normal);
			}

			if(primitive.indices->component_type == cgltf_component_type_r_16u)
			{
				auto indexBuffer = (unsigned short*)((char*)primitive.indices->buffer_view->buffer->data + primitive.indices->buffer_view->offset);

				for (int id = 0; id < indexCount; ++id)
				{
					outShape.indices.push_back(indexBuffer[id]);
				}
			}else if(primitive.indices->component_type == cgltf_component_type_r_32u)
			{
				auto indexBuffer = (unsigned int*)((char*)primitive.indices->buffer_view->buffer->data + primitive.indices->buffer_view->offset);
				for (int id = 0; id < indexCount; ++id)
				{
					outShape.indices.push_back(indexBuffer[id]);
				}
			}

            fillExternalMeshVertexBuffer(outShape.vertices.data(), outShape.normals.data(), outShape.vertices.size());
            fillExternalMeshIndexBuffer(outShape.indices.data(), outShape.indices.size());

            shapes.push_back(outShape);
		}
	}

    updateExternalMeshBuffers();

    cgltf_free(data);

	return true;
}

uint32_t ExternalMesh::fillExternalMeshVertexBuffer(struct nvertex* inVertex, struct vector3<float>* normals, uint32_t inCount)
{
    if (!bgfx::isValid(vertexBufferHandle)) vertexBufferHandle = bgfx::createDynamicVertexBuffer(inCount, newRenderer.GetVertexLayout(), BGFX_BUFFER_ALLOW_RESIZE);

    uint32_t currentOffset = vertexBufferData.size();

    for (uint32_t idx = 0; idx < inCount; idx++)
    {
        vertexBufferData.push_back(Vertex());

        vertexBufferData[currentOffset + idx].x = inVertex[idx]._.x;
        vertexBufferData[currentOffset + idx].y = inVertex[idx]._.y;
        vertexBufferData[currentOffset + idx].z = inVertex[idx]._.z;
        vertexBufferData[currentOffset + idx].w = (::isinf(inVertex[idx].color.w) ? 1.0f : inVertex[idx].color.w);
        vertexBufferData[currentOffset + idx].bgra = inVertex[idx].color.color;
        vertexBufferData[currentOffset + idx].u = inVertex[idx].u;
        vertexBufferData[currentOffset + idx].v = inVertex[idx].v;

        if (normals)
        {
            vertexBufferData[currentOffset + idx].nx = normals[idx].x;
            vertexBufferData[currentOffset + idx].ny = normals[idx].y;
            vertexBufferData[currentOffset + idx].nz = normals[idx].z;
        }

        if (vertex_log && idx == 0) ffnx_trace("%s: %u [XYZW(%f, %f, %f, %f), BGRA(%08x), UV(%f, %f)]\n", __func__, idx, vertexBufferData[currentOffset + idx].x, vertexBufferData[currentOffset + idx].y, vertexBufferData[currentOffset + idx].z, vertexBufferData[currentOffset + idx].w, vertexBufferData[currentOffset + idx].bgra, vertexBufferData[currentOffset + idx].u, vertexBufferData[currentOffset + idx].v);
        if (vertex_log && idx == 1) ffnx_trace("%s: See the rest on RenderDoc.\n", __func__);
    }

    return currentOffset;
};

uint32_t ExternalMesh::fillExternalMeshIndexBuffer(uint32_t* inIndex, uint32_t inCount)
{
    if (!bgfx::isValid(indexBufferHandle)) indexBufferHandle = bgfx::createDynamicIndexBuffer(inCount, BGFX_BUFFER_ALLOW_RESIZE | BGFX_BUFFER_INDEX32);

    uint32_t currentOffset = indexBufferData.size();

    for (uint32_t idx = 0; idx < inCount; idx++)
    {
        indexBufferData.push_back(inIndex[idx]);
    }

    return currentOffset;
};

void ExternalMesh::updateExternalMeshBuffers()
{
    bgfx::update(
        vertexBufferHandle,
        0,
        bgfx::copy(
            vertexBufferData.data(),
            vectorSizeOf(vertexBufferData)
        )
    );

    bgfx::update(
        indexBufferHandle,
        0,
        bgfx::copy(
            indexBufferData.data(),
            vectorSizeOf(indexBufferData)
        )
    );
}

void ExternalMesh::bindField3dVertexBuffer(uint32_t offset, uint32_t inCount)
{
    bgfx::setVertexBuffer(0, vertexBufferHandle, offset, inCount);
}

void ExternalMesh::bindField3dIndexBuffer(uint32_t offset, uint32_t inCount)
{
    bgfx::setIndexBuffer(indexBufferHandle, offset, inCount);
}

void ExternalMesh::clearExternalMesh3dBuffers()
{
    vertexBufferData.clear();
    vertexBufferData.shrink_to_fit();

    indexBufferData.clear();
    indexBufferData.shrink_to_fit();
}

void ExternalMesh::unloadExternalMesh()
{
    for (const auto& mat : materials)
    {
        for (const auto& tex : mat.second.baseColorTexHandles)
        {
            if (bgfx::isValid(tex))
                bgfx::destroy(tex);
        }
        for (const auto& tex : mat.second.normalTexHandles)
        {
            if (bgfx::isValid(tex))
                bgfx::destroy(tex);
        }
        for (const auto& tex : mat.second.pbrTexHandles)
        {
            if (bgfx::isValid(tex))
                bgfx::destroy(tex);
        }
    }
    shapes.clear();
    materials.clear();
    clearExternalMesh3dBuffers();
}

void ExternalMesh::loadConfig(const std::string& path)
{
    try
    {
        config = toml::parse_file(path);
    }
    catch (const toml::parse_error &err)
    {
        config = toml::parse("");
    }
}

int ExternalMesh::getTextureCount(std::string tex_name)
{
    auto node = config[tex_name];
    if(node)
    {
        if (auto sub_node = node["num_textures"]) return sub_node.value_or(0);
    }

    return 1;
}

int ExternalMesh::getFrameInterval(std::string tex_name)
{
    auto node = config[tex_name];
    if(node)
    {
        if (auto sub_node = node["frame_interval"]) return sub_node.value_or(0);
    }

    return 0;
}
````

## File: src/external_mesh.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <vector>
#include <map>
#include <string>
#include <toml++/toml.h>

#include "renderer.h"

struct Material
{
    std::vector<bgfx::TextureHandle> baseColorTexHandles;
    std::vector<bgfx::TextureHandle> normalTexHandles;
    std::vector<bgfx::TextureHandle> pbrTexHandles;
    int texIndex = 0;
    int frameInterval = 0;
};

struct Shape
{
    std::vector<nvertex> vertices;
    std::vector<vector3<float>> normals;
    std::vector<uint32_t> indices;
    vector3<float> min;
    vector3<float> max;
    Material* pMaterial = nullptr;
    bool isDoubleSided = false;
};

class ExternalMesh
{
public:
    bool importExternalMeshGltfFile(char* file_path, char* tex_path);
    uint32_t fillExternalMeshVertexBuffer(struct nvertex* inVertex, struct vector3<float>* normals, uint32_t inCount);
    uint32_t fillExternalMeshIndexBuffer(uint32_t* inIndex, uint32_t inCount);
    void updateExternalMeshBuffers();
    void bindField3dVertexBuffer(uint32_t offset, uint32_t inCount);
    void bindField3dIndexBuffer(uint32_t offset, uint32_t inCount);
    void clearExternalMesh3dBuffers();
    void unloadExternalMesh();

    std::vector<Shape> shapes;
	std::map<std::string, Material> materials;
private:
    void loadConfig(const std::string& path);

    int getTextureCount(std::string tex_name);
    int getFrameInterval(std::string tex_name);

private:
    // Config
    toml::parse_result config;

    std::vector<Vertex> vertexBufferData;
    bgfx::DynamicVertexBufferHandle vertexBufferHandle = BGFX_INVALID_HANDLE;

    std::vector<uint32_t> indexBufferData;
    bgfx::DynamicIndexBufferHandle indexBufferHandle = BGFX_INVALID_HANDLE;
};
````

## File: src/externals_102_de.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

common_externals.start =                      0x40B6E0;
common_externals.debug_print =                0x664E00;
common_externals.debug_print2 =               0x414EE0;
common_externals.create_tex_header = (tex_header * (*)(void))0x688C16;
common_externals.midi_init =                  0x6DE060;
common_externals.get_midi_name = (char* (*)(uint32_t))0x6E69B0;
common_externals.play_midi =                  0x6DE935;
common_externals.use_midi =                   0x6DDF83;
common_externals.stop_midi =                  0x6DF70B;
common_externals.cross_fade_midi =            0x6DF4CE;
common_externals.pause_midi =                 0x6DF65B;
common_externals.restart_midi =               0x6DF6B3;
common_externals.midi_status =                0x6DF793;
common_externals.set_master_midi_volume =     0x6DF7BA;
common_externals.set_midi_volume =            0x6DF817;
common_externals.set_midi_volume_trans =      0x6DF92C;
common_externals.set_midi_tempo =             0x6DFA9D;
common_externals.draw_graphics_object =       0x66E611;
common_externals.font_info =          (char *)0x99EB68;
common_externals.build_dialog_window =        0x7743B0;
common_externals.load_tex_file =              0x688C66;
common_externals.directsound_buffer_flags_1 = 0x6E6E3D;
common_externals.create_window =              0x6768FA;
common_externals.engine_wndproc =    (WNDPROC)0x6765E9;

ff7_externals.chocobo_fix =                   0x70B512;
ff7_externals.midi_fix =                      0x6E0422;
ff7_externals.snowboard_fix =         (void *)0x94BA30;
ff7_externals.cdcheck =                       0x408FF3;
ff7_externals.get_inserted_cd_sub =           0x404A7D;
ff7_externals.insertedCD =            (DWORD*)0x9A12F8;
ff7_externals.requiredCD =          (uint8_t*)0xF3990C;
ff7_externals.sub_665D9A = (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D6A;
ff7_externals.sub_671742 = (void (*)(uint32_t, p_hundred*, struc_186*))0x671712;
ff7_externals.sub_6B27A9 = (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B2779;
ff7_externals.sub_68D2B8 = (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D288;
ff7_externals.sub_665793 = (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665763;
ff7_externals.matrix3x4 = (void (*)(matrix*))0x67BC2B;
ff7_externals.matrix4x3_multiply =            0x66CC0B;
ff7_externals.sub_6B26C0 =                    0x6B2690;
ff7_externals.sub_6B2720 =                    0x6B26F0;
ff7_externals.sub_673F5C =                    0x673F2C;
ff7_externals.savemap =               (savemap *)0xF38A68;
ff7_externals.menu_objects =          (menu_objects *)0xF39CF0;
ff7_externals.magic_thread_start =            0x427928;
ff7_externals.destroy_magic_effects = (void (*)(void))0x429322;
ff7_externals.init_stuff =                    0x40A091;
ff7_externals.wm_activateapp =                0x409CF2;
ff7_externals.get_gamepad =                   0x41F99E;
ff7_externals.update_gamepad_status =         0x41F7D8;
ff7_externals.gamepad_status = (struct ff7_gamepad_status*)0x9AEBE8;
ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10AF;
ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10F3;
ff7_externals.sfx_play_summon =               0x6E586F;
ff7_externals.battle_summon_leviathan_loop =  0x5B1775;
ff7_externals.battle_limit_omnislash_loop =   0x46BA0B;
ff7_externals.sub_60B260 = (BYTE(*)())0x60B1F0;
ff7_externals.sub_767C55 = (BYTE(*)())0x7048C5;
ff7_externals.field_battle_toggle = 0x60B371;
ff7_externals.worldmap_battle_toggle = 0x7042E4;
````

## File: src/externals_102_fr.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

common_externals.start =                      0x40B6F0;
common_externals.debug_print =                0x664DD0;
common_externals.debug_print2 =               0x414EF0;
common_externals.create_tex_header = (tex_header * (*)(void))0x688BE6;
common_externals.midi_init =                  0x6DE000;
common_externals.get_midi_name = (char* (*)(uint32_t))0x6E6950;
common_externals.play_midi =                  0x6DE8D5;
common_externals.use_midi =                   0x6DDF23;
common_externals.stop_midi =                  0x6DF6AB;
common_externals.cross_fade_midi =            0x6DF46E;
common_externals.pause_midi =                 0x6DF5FB;
common_externals.restart_midi =               0x6DF653;
common_externals.midi_status =                0x6DF733;
common_externals.set_master_midi_volume =     0x6DF75A;
common_externals.set_midi_volume =            0x6DF7B7;
common_externals.set_midi_volume_trans =      0x6DF8CC;
common_externals.set_midi_tempo =             0x6DFA3D;
common_externals.draw_graphics_object =       0x66E5E1;
common_externals.font_info =           (char*)0x99FB98;
common_externals.build_dialog_window =        0x774690;
common_externals.load_tex_file =              0x688C36;
common_externals.directsound_buffer_flags_1 = 0x6E6DDD;
common_externals.create_window =              0x6768CA;
common_externals.engine_wndproc =    (WNDPROC)0x6765B9;

ff7_externals.chocobo_fix =                   0x70B4B2;
ff7_externals.midi_fix =                      0x6E03C2;
ff7_externals.snowboard_fix =         (void *)0x94BA48;
ff7_externals.cdcheck =                       0x409003;
ff7_externals.get_inserted_cd_sub =           0x404A8D;
ff7_externals.insertedCD =            (DWORD*)0x9A2328;
ff7_externals.requiredCD =          (uint8_t*)0xF3A91C;
ff7_externals.sub_665D9A = (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D3A;
ff7_externals.sub_671742 = (void (*)(uint32_t, p_hundred*, struc_186*))0x6716E2;
ff7_externals.sub_6B27A9 = (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B2749;
ff7_externals.sub_68D2B8 = (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D258;
ff7_externals.sub_665793 = (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665733;
ff7_externals.matrix3x4 = (void (*)(matrix*))0x67BBFB;
ff7_externals.matrix4x3_multiply =            0x66CBDB;
ff7_externals.sub_6B26C0 =                    0x6B2660;
ff7_externals.sub_6B2720 =                    0x6B26C0;
ff7_externals.sub_673F5C =                    0x673EFC;
ff7_externals.savemap =               (savemap*)0xF39A78;
ff7_externals.menu_objects =          (menu_objects*)0xF3AD00;
ff7_externals.magic_thread_start =            0x427938;
ff7_externals.destroy_magic_effects = (void (*)(void))0x429332;
ff7_externals.init_stuff =                    0x40A0A1;
ff7_externals.wm_activateapp =                0x409D02;
ff7_externals.get_gamepad =                   0x41F9AE;
ff7_externals.update_gamepad_status =         0x41F7E8;
ff7_externals.gamepad_status = (struct ff7_gamepad_status*)0x9AFC18;
ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10A5;
ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10DA;
ff7_externals.sfx_play_summon =               0x6E580F;
ff7_externals.battle_summon_leviathan_loop =  0x5B1785;
ff7_externals.battle_limit_omnislash_loop =   0x46BA1B;
ff7_externals.sub_60B260 = (BYTE(*)())0x60B200;
ff7_externals.sub_767C55 = (BYTE(*)())0x704865;
ff7_externals.field_battle_toggle = 0x60B381;
ff7_externals.worldmap_battle_toggle = 0x704284;
````

## File: src/externals_102_sp.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

common_externals.start =                      0x40B6F0;
common_externals.debug_print =                0x664DD0;
common_externals.debug_print2 =               0x414EF0;
common_externals.create_tex_header = (tex_header * (*)(void))0x688BE6;
common_externals.midi_init =                  0x6DE000;
common_externals.get_midi_name = (char* (*)(uint32_t))0x6E6950;
common_externals.play_midi =                  0x6DE8D5;
common_externals.use_midi =                   0x6DDF23;
common_externals.stop_midi =                  0x6DF6AB;
common_externals.cross_fade_midi =            0x6DF46E;
common_externals.pause_midi =                 0x6DF5FB;
common_externals.restart_midi =               0x6DF653;
common_externals.midi_status =                0x6DF733;
common_externals.set_master_midi_volume =     0x6DF75A;
common_externals.set_midi_volume =            0x6DF7B7;
common_externals.set_midi_volume_trans =      0x6DF8CC;
common_externals.set_midi_tempo =             0x6DFA3D;
common_externals.draw_graphics_object =       0x66E5E1;
common_externals.font_info =          (char *)0x9A05F8;
common_externals.build_dialog_window =        0x7747A0;
common_externals.load_tex_file =              0x688C36;
common_externals.directsound_buffer_flags_1 = 0x6E6DDD;
common_externals.create_window =              0x6768CA;
common_externals.engine_wndproc =    (WNDPROC)0x6765B9;

ff7_externals.chocobo_fix =                   0x70B4B2;
ff7_externals.midi_fix =                      0x6E03C2;
ff7_externals.snowboard_fix =         (void *)0x94CA30;
ff7_externals.cdcheck =                       0x409003;
ff7_externals.get_inserted_cd_sub =           0x404A8D;
ff7_externals.insertedCD =            (DWORD*)0x9A2D88;
ff7_externals.requiredCD =          (uint8_t*)0xF3B3EC;
ff7_externals.sub_665D9A = (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D3A;
ff7_externals.sub_671742 = (void (*)(uint32_t, p_hundred*, struc_186*))0x6716E2;
ff7_externals.sub_6B27A9 = (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B2749;
ff7_externals.sub_68D2B8 = (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D258;
ff7_externals.sub_665793 = (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665733;
ff7_externals.matrix3x4 = (void (*)(matrix*))0x67BBFB;
ff7_externals.matrix4x3_multiply =            0x66CBDB;
ff7_externals.sub_6B26C0 =                    0x6B2660;
ff7_externals.sub_6B2720 =                    0x6B26C0;
ff7_externals.sub_673F5C =                    0x673EFC;
ff7_externals.savemap =               (savemap *)0xF3A548;
ff7_externals.menu_objects =          (menu_objects *)0xF3B7D0;
ff7_externals.magic_thread_start =            0x427938;
ff7_externals.destroy_magic_effects = (void (*)(void))0x429332;
ff7_externals.init_stuff =                    0x40A0A1;
ff7_externals.wm_activateapp =                0x409D02;
ff7_externals.get_gamepad =                   0x41F9AE;
ff7_externals.update_gamepad_status =         0x41F7E8;
ff7_externals.gamepad_status = (struct ff7_gamepad_status*)0x9B0678;
ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10AC;
ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10E1;
ff7_externals.sfx_play_summon =               0x6E580F;
ff7_externals.battle_summon_leviathan_loop =  0x5B1785;
ff7_externals.battle_limit_omnislash_loop =   0x46BA1B;
ff7_externals.sub_60B260 = (BYTE(*)())0x60B200;
ff7_externals.sub_767C55 = (BYTE(*)())0x704865;
ff7_externals.field_battle_toggle = 0x60B381;
ff7_externals.worldmap_battle_toggle = 0x704284;
````

## File: src/externals_102_us.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

common_externals.start =                      0x40B6E0;
common_externals.debug_print =                0x664E30;
common_externals.debug_print2 =               0x414EE0;
common_externals.create_tex_header =  (tex_header* (*)(void))0x688C46;
common_externals.midi_init =                  0x741780;
common_externals.get_midi_name =      (char* (*)(uint32_t))0x74A0D0;
common_externals.play_midi =                  0x742055;
common_externals.use_midi =                   0x7416A3;
common_externals.stop_midi =                  0x742E2B;
common_externals.cross_fade_midi =            0x742BEE;
common_externals.pause_midi =                 0x742D7B;
common_externals.restart_midi =               0x742DD3;
common_externals.midi_status =                0x742EB3;
common_externals.set_master_midi_volume =     0x742EDA;
common_externals.set_midi_volume =            0x742F37;
common_externals.set_midi_volume_trans =      0x74304C;
common_externals.set_midi_tempo =             0x7431BD;
common_externals.draw_graphics_object =       0x66E272;
common_externals.font_info =          (char *)0x99DDA8;
common_externals.build_dialog_window =        0x6E97E0;
common_externals.load_tex_file =              0x688C96;
common_externals.directsound_buffer_flags_1 = 0x74A55D;
common_externals.create_window =              0x67692A;
common_externals.engine_wndproc =    (WNDPROC)0x676619;

ff7_externals.chocobo_fix =                   0x76EC32;
ff7_externals.midi_fix =                      0x743B42;
ff7_externals.snowboard_fix =         (void *)0x958328;
ff7_externals.cdcheck =                       0x408FF3;
ff7_externals.get_inserted_cd_sub =           0x404A7D;
ff7_externals.insertedCD =            (DWORD*)0x9A0538;
ff7_externals.requiredCD =          (uint8_t*)0xDC0BDC;
ff7_externals.sub_665D9A =            (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D9A;
ff7_externals.sub_671742 =            (void (*)(uint32_t, p_hundred*, struc_186*))0x671742;
ff7_externals.sub_6B27A9 =            (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B27A9;
ff7_externals.sub_68D2B8 =            (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D2B8;
ff7_externals.sub_665793 =            (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665793;
ff7_externals.matrix3x4 =             (void (*)(matrix*))0x67BC5B;
ff7_externals.matrix4x3_multiply =            0x66CC3B;
ff7_externals.sub_6B26C0 =                    0x6B26C0;
ff7_externals.sub_6B2720 =                    0x6B2720;
ff7_externals.sub_673F5C =                    0x673F5C;
ff7_externals.savemap =               (savemap *)0xDBFD38;
ff7_externals.menu_objects =          (menu_objects *)0xDC0FC0;
ff7_externals.magic_thread_start =            0x427928;
ff7_externals.destroy_magic_effects = (void (*)(void))0x429322;
ff7_externals.init_stuff =                    0x40A091;
ff7_externals.wm_activateapp =                0x409CF2;
ff7_externals.get_gamepad =                   0x41F99E;
ff7_externals.update_gamepad_status =         0x41F7D8;
ff7_externals.gamepad_status =        (struct ff7_gamepad_status*)0x9ADE28;
ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10A8;
ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10EC;
ff7_externals.sfx_play_summon =               0x748F8F;
ff7_externals.battle_summon_leviathan_loop =  0x5B1775;
ff7_externals.battle_limit_omnislash_loop =   0x46BA0B;
ff7_externals.sub_60B260 =         (BYTE(*)())0x60B260;
ff7_externals.sub_767C55 =         (BYTE(*)())0x767C55;
ff7_externals.field_battle_toggle =           0x60B3E1;
ff7_externals.worldmap_battle_toggle =        0x767674;
````

## File: src/fake_dd.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "renderer.h"

#include "fake_dd.h"
#include "gl.h"
#include "log.h"

uint32_t __stdcall fake_dd_blit_fast(struct ddsurface **me, uint32_t unknown1, uint32_t unknown2, struct ddsurface **target, LPRECT source, uint32_t unknown3);
uint32_t __stdcall fake_ddsurface_get_pixelformat(struct ddsurface **me, LPDDPIXELFORMAT pf);
uint32_t __stdcall fake_ddsurface_get_surface_desc(struct ddsurface **me, LPDDSURFACEDESC2 sd);
uint32_t __stdcall fake_ddsurface_get_dd_interface(struct ddsurface **me, struct dddevice ***dd);
uint32_t __stdcall fake_ddsurface_get_palette(struct ddsurface **me, void **palette);
uint32_t __stdcall fake_ddsurface_lock(struct ddsurface **me, LPRECT dest, LPDDSURFACEDESC sd, uint32_t flags, uint32_t unused);
uint32_t __stdcall fake_ddsurface_unlock(struct ddsurface **me, LPRECT dest);
uint32_t __stdcall fake_ddsurface_islost(struct ddsurface **me);
uint32_t __stdcall fake_ddsurface_restore(struct ddsurface **me);
uint32_t __stdcall fake_dd_query_interface(struct dddevice **me, uint32_t *iid, void **ppvobj);
uint32_t __stdcall fake_dd_addref(struct dddevice **me);
uint32_t __stdcall fake_dd_release(struct dddevice **me);
uint32_t __stdcall fake_dd_create_clipper(struct dddevice **me, DWORD flags, LPDIRECTDRAWCLIPPER *clipper);
uint32_t __stdcall fake_dd_create_palette(struct dddevice **me, LPPALETTEENTRY palette_entry, LPDIRECTDRAWPALETTE *palette, IUnknown *unused);
uint32_t __stdcall fake_dd_create_surface(struct dddevice **me, LPDDSURFACEDESC sd, LPDIRECTDRAWSURFACE *surface, IUnknown *unused);
uint32_t __stdcall fake_dd_get_caps(struct dddevice **me, LPDDCAPS halcaps, LPDDCAPS helcaps);
uint32_t __stdcall fake_dd_get_display_mode(struct dddevice **me, LPDDSURFACEDESC sd);
uint32_t __stdcall fake_dd_set_coop_level(struct dddevice **me, uint32_t coop_level);
uint32_t __stdcall fake_d3d_get_caps(struct d3d2device **me, void *a, void *b);

struct ddsurface fake_dd_surface = {
	fake_dd_query_interface,
	fake_dd_addref,
	fake_dd_release,
	0,
	0,
	0,
	0,
	fake_dd_blit_fast,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	fake_ddsurface_get_palette,
	fake_ddsurface_get_pixelformat,
	fake_ddsurface_get_surface_desc,
	0,
	fake_ddsurface_islost,
	fake_ddsurface_lock,
	0,
	fake_ddsurface_restore,
	0,
	0,
	0,
	0,
	fake_ddsurface_unlock,
	0,
	0,
	0,
	fake_ddsurface_get_dd_interface,
};
struct ddsurface *_fake_dd_back_surface = &fake_dd_surface;

struct ddsurface fake_dd_front_surface = {
	fake_dd_query_interface,
	fake_dd_addref,
	fake_dd_release,
	0,
	0,
	0,
	0,
	fake_dd_blit_fast,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	fake_ddsurface_get_palette,
	fake_ddsurface_get_pixelformat,
	fake_ddsurface_get_surface_desc,
	0,
	fake_ddsurface_islost,
	fake_ddsurface_lock,
	0,
	fake_ddsurface_restore,
	0,
	0,
	0,
	0,
	fake_ddsurface_unlock,
	0,
	0,
	0,
	fake_ddsurface_get_dd_interface,
};
struct ddsurface *_fake_dd_front_surface = &fake_dd_front_surface;

struct ddsurface fake_dd_temp_surface = {
	fake_dd_query_interface,
	fake_dd_addref,
	fake_dd_release,
	0,
	0,
	0,
	0,
	fake_dd_blit_fast,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	fake_ddsurface_get_palette,
	fake_ddsurface_get_pixelformat,
	fake_ddsurface_get_surface_desc,
	0,
	fake_ddsurface_islost,
	fake_ddsurface_lock,
	0,
	fake_ddsurface_restore,
	0,
	0,
	0,
	0,
	fake_ddsurface_unlock,
	0,
	0,
	0,
	fake_ddsurface_get_dd_interface,
};
struct ddsurface *_fake_dd_temp_surface = &fake_dd_temp_surface;

struct dddevice fake_dddevice = {
	fake_dd_query_interface,
	fake_dd_addref,
	fake_dd_release,
	0,
	fake_dd_create_clipper,
	fake_dd_create_palette,
	fake_dd_create_surface,
	0,
	0,
	0,
	0,
	fake_dd_get_caps,
	fake_dd_get_display_mode,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	fake_dd_set_coop_level,
	0,
	0,
	0,
};
struct dddevice *_fake_dddevice = &fake_dddevice;

struct d3d2device fake_d3d2device = {
	fake_dd_query_interface,
	fake_dd_addref,
	fake_dd_release,
	fake_d3d_get_caps,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
};
struct d3d2device *_fake_d3d2device = &fake_d3d2device;

uint8_t* fake_dd_surface_buffer = nullptr;

uint32_t movie_texture = 0;

uint32_t __stdcall fake_dd_blit_fast(struct ddsurface **me, uint32_t unknown1, uint32_t unknown2, struct ddsurface **source, LPRECT src_rect, uint32_t unknown3)
{
	if(trace_all || trace_fake_dx) ffnx_trace("blit_fast\n");

	return DD_OK;
}

uint32_t __stdcall fake_ddsurface_get_pixelformat(struct ddsurface **me, LPDDPIXELFORMAT pf)
{
	if(trace_all || trace_fake_dx) ffnx_trace("get_pixelformat\n");

	pf->dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
	pf->dwRGBBitCount = 32;
	pf->dwBBitMask = 0xFF;
	pf->dwGBitMask = 0xFF00;
	pf->dwRBitMask = 0xFF0000;
	pf->dwRGBAlphaBitMask = 0xFF000000;

	return 0;
}

uint32_t __stdcall fake_ddsurface_get_surface_desc(struct ddsurface **me, LPDDSURFACEDESC2 sd)
{
	if(trace_all || trace_fake_dx) ffnx_trace("get_surface_desc\n");

	return 0;
}

uint32_t __stdcall fake_ddsurface_get_dd_interface(struct ddsurface **me, struct dddevice ***dd)
{
	if(trace_all || trace_fake_dx) ffnx_trace("get_dd_interface\n");

	*dd = &_fake_dddevice;
	return 0;
}

uint32_t __stdcall fake_ddsurface_get_palette(struct ddsurface **me, void **palette)
{
	if(trace_all || trace_fake_dx) ffnx_trace("get_palette\n");

	//*palette = 0;

	return DDERR_UNSUPPORTED;
}

uint32_t __stdcall fake_ddsurface_lock(struct ddsurface **me, LPRECT dest, LPDDSURFACEDESC sd, uint32_t flags, uint32_t unused)
{
	if(trace_all || trace_fake_dx) ffnx_trace("lock\n");

	if (fake_dd_surface_buffer == nullptr) fake_dd_surface_buffer = (uint8_t*)driver_calloc(game_width * game_height, 4);

	sd->lpSurface = fake_dd_surface_buffer;
	sd->dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT | DDSD_LPSURFACE;

	sd->dwWidth = game_width;
	sd->dwHeight = game_height;
	sd->lPitch = game_width * 4;

	sd->ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
	sd->ddpfPixelFormat.dwRGBBitCount = 32;
	sd->ddpfPixelFormat.dwBBitMask = 0xFF;
	sd->ddpfPixelFormat.dwGBitMask = 0xFF00;
	sd->ddpfPixelFormat.dwRBitMask = 0xFF0000;
	sd->ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF000000;

	return DD_OK;
}

uint32_t __stdcall fake_ddsurface_unlock(struct ddsurface **me, LPRECT dest)
{
	if(trace_all || trace_fake_dx) ffnx_trace("unlock\n");

	if (movie_texture) newRenderer.deleteTexture(movie_texture);

	movie_texture = newRenderer.createTexture(
		fake_dd_surface_buffer,
		game_width,
		game_height,
		game_width * 4
	);

	newRenderer.useTexture(movie_texture);

	newRenderer.isMovie(true);

	gl_draw_movie_quad(game_width, game_height);

	newRenderer.isMovie(false);

	return DD_OK;
}

uint32_t __stdcall fake_ddsurface_islost(struct ddsurface **me)
{
	if(trace_all || trace_fake_dx) ffnx_trace("islost\n");

	return DD_OK;
}

uint32_t __stdcall fake_ddsurface_restore(struct ddsurface **me)
{
	if(trace_all || trace_fake_dx) ffnx_trace("restore\n");

	return DD_OK;
}

uint32_t __stdcall fake_dd_query_interface(struct dddevice **me, uint32_t *iid, void **ppvobj)
{
	if(trace_all || trace_fake_dx) ffnx_trace("query_interface: 0x%p 0x%p 0x%p 0x%p\n", iid[0], iid[1], iid[2], iid[3]);

	if(iid[0] == 0x6C14DB80)
	{
		*ppvobj = me;
		return S_OK;
	}

	if(iid[0] == 0x57805885)
	{
		*ppvobj = &_fake_dd_temp_surface;
		return S_OK;
	}

	return E_NOINTERFACE;
}

uint32_t __stdcall fake_dd_addref(struct dddevice **me)
{
	if(trace_all || trace_fake_dx) ffnx_trace("addref\n");

	return 1;
}

uint32_t __stdcall fake_dd_release(struct dddevice **me)
{
	if(trace_all || trace_fake_dx) ffnx_trace("release\n");

	return 0;
}

uint32_t __stdcall fake_dd_create_clipper(struct dddevice **me, DWORD flags, LPDIRECTDRAWCLIPPER *clipper)
{
	if(trace_all || trace_fake_dx) ffnx_trace("create_clipper\n");

	if(clipper == 0) return DDERR_INVALIDPARAMS;

	*clipper = 0;

	return DD_OK;
}

uint32_t __stdcall fake_dd_create_palette(struct dddevice **me, LPPALETTEENTRY palette_entry, LPDIRECTDRAWPALETTE *palette, IUnknown *unused)
{
	if(trace_all || trace_fake_dx) ffnx_trace("create_palette\n");

	if(palette == 0) return DDERR_INVALIDPARAMS;

	*palette = 0;

	return DD_OK;
}

uint32_t __stdcall fake_dd_create_surface(struct dddevice **me, LPDDSURFACEDESC sd, LPDIRECTDRAWSURFACE *surface, IUnknown *unused)
{
	if(trace_all || trace_fake_dx) ffnx_trace("create_surface %ix%i\n", sd->dwWidth, sd->dwHeight);

	*surface = (LPDIRECTDRAWSURFACE)&_fake_dd_temp_surface;

	return 0;
}

uint32_t __stdcall fake_dd_get_caps(struct dddevice **me, LPDDCAPS halcaps, LPDDCAPS helcaps)
{
	if(trace_all || trace_fake_dx) ffnx_trace("get_caps\n");

	halcaps->dwCaps = DDCAPS_BLTSTRETCH;
	return 0;
}

uint32_t __stdcall fake_dd_get_display_mode(struct dddevice **me, LPDDSURFACEDESC sd)
{
	if(trace_all || trace_fake_dx) ffnx_trace("get_display_mode\n");

	sd->dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT;

	sd->dwWidth = game_width;
	sd->dwHeight = game_height;
	sd->lPitch = game_width * 4;

	sd->ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
	sd->ddpfPixelFormat.dwRGBBitCount = 32;
	sd->ddpfPixelFormat.dwBBitMask = 0xFF;
	sd->ddpfPixelFormat.dwGBitMask = 0xFF00;
	sd->ddpfPixelFormat.dwRBitMask = 0xFF0000;
	sd->ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF000000;

	return 0;
}

uint32_t __stdcall fake_dd_set_coop_level(struct dddevice **me, uint32_t coop_level)
{
	if(trace_all || trace_fake_dx) ffnx_trace("set_coop_level\n");

	return 0;
}

uint32_t __stdcall fake_d3d_get_caps(struct d3d2device **me, void *a, void *b)
{
	if(trace_all || trace_fake_dx) ffnx_trace("d3d_get_caps\n");

	memset(a, -1, 0xFC);
	memset(b, -1, 0xFC);

	return DD_OK;
}
````

## File: src/fake_dd.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>

struct ddsurface
{
	void *query_interface;
	void *addref;
	void *release;
	uint32_t field_C;
	uint32_t field_10;
	uint32_t field_14;
	uint32_t field_18;
	void *blit_fast;
	uint32_t field_20;
	uint32_t field_24;
	uint32_t field_28;
	uint32_t field_2C;
	uint32_t field_30;
	uint32_t field_34;
	uint32_t field_38;
	uint32_t field_3C;
	uint32_t field_40;
	uint32_t field_44;
	uint32_t field_48;
	uint32_t field_4C;
	void *get_palette;
	void *get_pixelformat;
	void *get_surface_desc;
	uint32_t field_5C;
	void *islost;
	void *lock;
	uint32_t field_68;
	void *restore;
	uint32_t field_70;
	uint32_t field_74;
	uint32_t field_78;
	uint32_t field_7C;
	void *unlock;
	uint32_t field_84;
	uint32_t field_88;
	uint32_t field_8C;
	void *get_dd_interface;
};

struct dddevice
{
	void *query_interface;
	void *addref;
	void *release;
	uint32_t field_C;
	void *create_clipper;
	void *create_palette;
	void *create_surface;
	uint32_t field_1C;
	uint32_t field_20;
	uint32_t field_24;
	uint32_t field_28;
	void *get_caps;
	void *get_display_mode;
	uint32_t field_34;
	uint32_t field_38;
	uint32_t field_3C;
	uint32_t field_40;
	uint32_t field_44;
	uint32_t field_48;
	uint32_t field_4C;
	void *set_coop_level;
	uint32_t field_54;
	uint32_t field_58;
	uint32_t field_5C;
};

struct d3d2device
{
	void *query_interface;
	void *addref;
	void *release;
	void *get_caps;
	uint32_t field_10;
	uint32_t field_14;
	uint32_t field_18;
	uint32_t field_1C;
	uint32_t field_20;
	uint32_t field_24;
	uint32_t field_28;
	uint32_t field_2C;
	uint32_t field_30;
	uint32_t field_34;
	uint32_t field_38;
	uint32_t field_3C;
	uint32_t junk[10];
	void *set_transform;
	uint32_t field_6C;
	uint32_t field_70;
	uint32_t field_74;
	void *draw_indexed_primitive;
};

extern struct ddsurface *_fake_dd_back_surface;
extern struct ddsurface *_fake_dd_temp_surface;
extern struct ddsurface *_fake_dd_front_surface;
extern struct dddevice *_fake_dddevice;
extern struct d3d2device *_fake_d3d2device;
````

## File: src/ff7_data.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Marcin 'Maki' Gomulak                              //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <functional>

#include "ff7.h"
#include "globals.h"
#include "log.h"
#include "patch.h"

// FF7 game mode definitions
static struct game_mode ff7_modes[] = {
	{FF7_MODE_FIELD,       "MODE_FIELD",       MODE_FIELD,       true  },
	{FF7_MODE_BATTLE,      "MODE_BATTLE",      MODE_BATTLE,      true  },
	{FF7_MODE_WORLDMAP,    "MODE_WORLDMAP",    MODE_WORLDMAP,    true  },
	{FF7_MODE_UNKNOWN4,    "MODE_UNKNOWN4",    MODE_UNKNOWN,     false },
	{FF7_MODE_MENU,        "MODE_MENU",        MODE_MENU,        true  },
	{FF7_MODE_HIGHWAY,     "MODE_HIGHWAY",     MODE_HIGHWAY,     true  },
	{FF7_MODE_CHOCOBO,     "MODE_CHOCOBO",     MODE_CHOCOBO,     true  },
	{FF7_MODE_SNOWBOARD,   "MODE_SNOWBOARD",   MODE_SNOWBOARD,   true  },
	{FF7_MODE_CONDOR,      "MODE_CONDOR",      MODE_CONDOR,      true  },
	{FF7_MODE_SUBMARINE,   "MODE_SUBMARINE",   MODE_SUBMARINE,   true  },
	{FF7_MODE_COASTER,     "MODE_COASTER",     MODE_COASTER,     true  },
	{FF7_MODE_CDCHECK,     "MODE_CDCHECK",     MODE_CDCHECK,     true  },
	{FF7_MODE_UNKNOWN13,   "MODE_UNKNOWN13",   MODE_UNKNOWN,     false },
	{FF7_MODE_SNOWBOARD2,  "MODE_SNOWBOARD2",  MODE_SNOWBOARD,   true  },
	{FF7_MODE_UNKNOWN15,   "MODE_UNKNOWN15",   MODE_UNKNOWN,     false },
	{FF7_MODE_UNKNOWN16,   "MODE_UNKNOWN16",   MODE_UNKNOWN,     false },
	{FF7_MODE_BATTLE_MENU, "MODE_BATTLE_MENU", MODE_MENU,        true  },
	{FF7_MODE_UNKNOWN18,   "MODE_UNKNOWN18",   MODE_UNKNOWN,     false },
	{FF7_MODE_EXIT,        "MODE_EXIT",        MODE_EXIT,        true  },
	{FF7_MODE_MAIN_MENU,   "MODE_MAIN_MENU",   MODE_MAIN_MENU,   true  },
	{FF7_MODE_UNKNOWN21,   "MODE_UNKNOWN21",   MODE_UNKNOWN,     false },
	{FF7_MODE_INTRO,       "MODE_INTRO",       MODE_INTRO,       true  },
	{FF7_MODE_SWIRL,       "MODE_SWIRL",       MODE_SWIRL,       true  },
	{FF7_MODE_UNKNOWN24,   "MODE_UNKNOWN24",   MODE_UNKNOWN,     false },
	{FF7_MODE_ENDING2,     "MODE_ENDING2",     MODE_ENDINGMOVIE, false },
	{FF7_MODE_GAMEOVER,    "MODE_GAMEOVER",    MODE_GAMEOVER,    true  },
	{FF7_MODE_CREDITS,     "MODE_CREDITS",     MODE_CREDITS,     true  },
	{FF7_MODE_UNKNOWN28,   "MODE_UNKNOWN28",   MODE_UNKNOWN,     false },
};

inline void ff7_set_main_loop(uint32_t driver_mode, uint32_t main_loop)
{
	uint32_t i;

	for(i = 0; i < num_modes; i++) if(ff7_modes[i].driver_mode == driver_mode) ff7_modes[i].main_loop = main_loop;
}

inline void ff7_find_externals(struct ff7_game_obj* game_object)
{
	uint32_t main_init_loop = (uint32_t)game_object->engine_loop_obj.init;
	uint32_t main_loop = (uint32_t)game_object->engine_loop_obj.main_loop;
	uint32_t main_cleanup_loop = (uint32_t)game_object->engine_loop_obj.cleanup;
	uint32_t field_main_loop;
	uint32_t battle_main_loop;
	uint32_t menu_main_loop;
	uint32_t cdcheck_main_loop;
	uint32_t credits_main_loop;
	uint32_t coaster_main_loop;
	uint32_t condor_main_loop;
	uint32_t chocobo_main_loop;
	uint32_t highway_main_loop;
	uint32_t swirl_main_loop;
	uint32_t snowboard_main_loop;
	uint32_t submarine_main_loop;
	uint32_t gameover_main_loop;
	uint32_t movie_module;
	uint32_t file_module;

	if(*((uint32_t *)main_loop) != 0x81EC8B55) ffnx_unexpected("odd main loop prologue\n");

	common_externals.get_time = (uint64_t (*)(uint64_t*))get_relative_call(common_externals.winmain, 0x2BE);
	common_externals.diff_time = (uint64_t (*)(uint64_t*,uint64_t*,uint64_t*))get_relative_call(common_externals.winmain, 0x2F6);

	common_externals.update_movie_sample = get_relative_call(main_loop, 0x67);

	movie_module = common_externals.update_movie_sample - 0x3039;

	ff7_externals.movie_sub_415231 = (void (*)(char*))(movie_module + 0x331);
	common_externals.prepare_movie = movie_module + 0x1A95;
	common_externals.release_movie_objects = movie_module + 0x2859;
	common_externals.start_movie = movie_module + 0x2BB0;
	common_externals.stop_movie = movie_module + 0x2CB2;
	common_externals.get_movie_frame = movie_module + 0x3713;

	ff7_externals.movie_object = (struct movie_obj *)(get_absolute_value(common_externals.prepare_movie, 0x42) - 0xC);

	common_externals._mode = (WORD*)get_absolute_value(main_loop, 0x8C);
	common_externals._previous_mode = (WORD *)get_absolute_value(main_loop, 0x1D8);

	gameover_main_loop = get_absolute_value(main_loop, 0x1FE);
	ff7_set_main_loop(MODE_GAMEOVER, gameover_main_loop);
	swirl_main_loop = get_absolute_value(main_loop, 0x25B);
	ff7_set_main_loop(MODE_SWIRL, swirl_main_loop);
	cdcheck_main_loop = get_absolute_value(main_loop, 0x397);
	ff7_set_main_loop(MODE_CDCHECK, cdcheck_main_loop);
	credits_main_loop = get_absolute_value(main_loop, 0x4CA);
	ff7_set_main_loop(MODE_CREDITS, credits_main_loop);
	menu_main_loop = get_absolute_value(main_loop, 0x62E);
	ff7_set_main_loop(MODE_MENU, menu_main_loop);
	ff7_set_main_loop(MODE_MAIN_MENU, menu_main_loop);
	battle_main_loop = get_absolute_value(main_loop, 0x89A);
	ff7_set_main_loop(MODE_BATTLE, battle_main_loop);
	field_main_loop = get_absolute_value(main_loop, 0x8F8);
	ff7_set_main_loop(MODE_FIELD, field_main_loop);
	ff7_externals.world_loop_74BE49 = get_absolute_value(main_loop, 0x977);
	ff7_set_main_loop(MODE_WORLDMAP, ff7_externals.world_loop_74BE49);
	chocobo_main_loop = get_absolute_value(main_loop, 0x9C5);
	ff7_set_main_loop(MODE_CHOCOBO, chocobo_main_loop);
	condor_main_loop = get_absolute_value(main_loop, 0xA13);
	ff7_set_main_loop(MODE_CONDOR, condor_main_loop);
	highway_main_loop = get_absolute_value(main_loop, 0xA61);
	ff7_set_main_loop(MODE_HIGHWAY, highway_main_loop);
	coaster_main_loop = get_absolute_value(main_loop, 0xAAF);
	ff7_set_main_loop(MODE_COASTER, coaster_main_loop);
	submarine_main_loop = get_absolute_value(main_loop, 0xAFD);
	ff7_set_main_loop(MODE_SUBMARINE, submarine_main_loop);
	snowboard_main_loop = get_absolute_value(main_loop, 0xB3E);
	ff7_set_main_loop(MODE_SNOWBOARD, snowboard_main_loop);

	ff7_externals.reset_game_obj_sub_5F4971 = (void (*)(struct game_obj*))get_relative_call(condor_main_loop, 0x5B);
	ff7_externals.engine_exit_game_mode_sub_666C78 = get_relative_call(common_externals.winmain, 0x217);
	ff7_externals.sub_666C13 = (void* (*)(struct game_obj*))get_relative_call(ff7_externals.engine_exit_game_mode_sub_666C78, 0x35);
	ff7_externals.sub_670F9B = (void* (*)(void*))get_relative_call(ff7_externals.engine_exit_game_mode_sub_666C78, 0x47);
	ff7_externals.byte_CC0D89 = (BYTE*)get_absolute_value(main_loop, 0x71E);
	ff7_externals.word_CC0828 = (WORD*)get_absolute_value(main_init_loop, 0x4A5);

	ff7_externals.destroy_field_bk = get_relative_call(field_main_loop, 0x222);
	ff7_externals.destroy_field_tiles = get_relative_call(ff7_externals.destroy_field_bk, 0x1E6);
	ff7_externals.field_layers = (field_layer **)get_absolute_value(ff7_externals.destroy_field_tiles, 0x46);

	ff7_externals.num_field_entities = (WORD *)(((uint32_t)ff7_externals.field_layers) - 0xC);
	ff7_externals.field_objects = (field_object **)(((uint32_t)ff7_externals.field_layers) - 0x10);

	ff7_externals.field_id = (WORD *)get_absolute_value(field_main_loop, 0x326);

	ff7_externals.open_field_file = get_relative_call(field_main_loop, 0x331);
	ff7_externals.field_file_name = (char *)get_absolute_value(ff7_externals.open_field_file, 0x77);
	ff7_externals.read_field_file = get_relative_call(ff7_externals.open_field_file, 0xCF);

	ff7_externals.battle_enter = get_absolute_value(main_loop, 0x8A1);
	ff7_externals.battle_loop = get_relative_call(battle_main_loop, 0x1C8);
	ff7_externals.battle_mode = (DWORD*)get_absolute_value(ff7_externals.battle_loop, 0x18);
	ff7_externals.battle_sub_429AC0 = get_absolute_value(ff7_externals.battle_loop, 0x79);
	ff7_externals.battle_sub_42D808 = get_relative_call(ff7_externals.battle_sub_429AC0, 0xE7);
	ff7_externals.battle_sub_42D992 = get_relative_call(ff7_externals.battle_sub_42D808, 0x30);
	ff7_externals.battle_sub_42DAE5 = get_relative_call(ff7_externals.battle_sub_42D992, 0x7E);
	ff7_externals.battle_fight_end = get_relative_call(ff7_externals.battle_sub_42D992, 0xB7);
	ff7_externals.battle_fanfare_music = get_relative_call(ff7_externals.battle_fight_end, 0x25);
	ff7_externals.battle_sub_427C22 = get_relative_call(ff7_externals.battle_sub_42DAE5, 0xF);
	ff7_externals.battle_menu_update_6CE8B3 = get_relative_call(battle_main_loop, 0x368);
	ff7_externals.battle_sub_6DB0EE = get_relative_call(ff7_externals.battle_menu_update_6CE8B3, 0xD9);
	ff7_externals.is_battle_paused = (char*)get_absolute_value(ff7_externals.battle_menu_update_6CE8B3, 0xC3);
	ff7_externals.battle_actor_data = (battle_actor_data*)get_absolute_value(ff7_externals.battle_sub_6DB0EE, 0x276);
	ff7_externals.battle_menu_state_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_6DB0EE, 0x1B4), 64);
	ff7_externals.magic_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0xBF), 54);
	ff7_externals.battle_b3ddata_sub_428B12 = get_relative_call(ff7_externals.battle_sub_429AC0, 0x71);
	ff7_externals.graphics_render_sub_68A638 = get_relative_call(ff7_externals.battle_b3ddata_sub_428B12, 0x10A);
	ff7_externals.create_dx_sfx_something = get_relative_call(ff7_externals.graphics_render_sub_68A638, 0xD3);
	ff7_externals.load_p_file = get_relative_call(ff7_externals.create_dx_sfx_something, 0x144);

	ff7_externals.comet2_sub_5A42E5 = get_relative_call(ff7_externals.magic_effects_fn_table[46], 0x1A);
	ff7_externals.comet2_unload_sub_5A4359 = get_absolute_value(ff7_externals.comet2_sub_5A42E5, 0x34);

	ff7_externals.create_polygon_data = (polygon_data* (*)(uint32_t, uint32_t))get_relative_call(ff7_externals.load_p_file, 0x17);
	ff7_externals.create_polygon_lists = (void (*)(polygon_data*))get_relative_call(ff7_externals.load_p_file, 0x35B);
	ff7_externals.free_polygon_data = (void (*)(polygon_data*))get_relative_call(ff7_externals.load_p_file, 0x3C4);

	common_externals.open_file = get_relative_call(ff7_externals.load_p_file, 0x3A);

	file_module = common_externals.open_file - 0xE2;
	common_externals.close_file = file_module + 0xA1;
	common_externals.read_file = file_module + 0x611;
	common_externals.__read_file = file_module + 0x6A7;
	common_externals.write_file = file_module + 0x735;
	common_externals.alloc_read_file = (void* (*)(uint32_t, uint32_t, struct file*))(file_module + 0x830);
	common_externals.get_filesize = file_module + 0x84B;
	common_externals.tell_file = file_module + 0x8A1;
	common_externals.seek_file = file_module + 0x90A;
	common_externals.alloc_get_file = (void* (*)(file_context*, uint32_t*, char*))(file_module + 0xA0E);

	common_externals.destroy_tex = (void (*)(tex_header*))get_relative_call(common_externals.load_tex_file, 0x16D);
	common_externals.destroy_tex_header = get_relative_call((uint32_t)common_externals.destroy_tex, 0x78);

	ff7_externals.play_battle_music_call = main_loop + 0x300;
	ff7_externals.play_battle_end_music = (uint32_t(*)())get_relative_call(ff7_externals.battle_fanfare_music, 0x21);
	ff7_externals.play_battle_music_win_call = ff7_externals.battle_fanfare_music + 0x21;
	ff7_externals.battle_sub_42A0E7 = get_relative_call(ff7_externals.battle_sub_429AC0, 0xA4);
	ff7_externals.load_battle_stage = get_relative_call(ff7_externals.battle_sub_42A0E7, 0x78);
	ff7_externals.load_battle_stage_pc = get_relative_call(ff7_externals.load_battle_stage, 0x151);
	ff7_externals.read_battle_hrc = get_relative_call(ff7_externals.load_battle_stage_pc, 0x25);

	ff7_externals.battle_location_id = (WORD*)get_absolute_value(ff7_externals.battle_sub_42A0E7, 0x5F);

	ff7_externals.battle_regular_chdir = (void (*)(battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0x16);
	ff7_externals.battle_context_chdir = (void (*)(file_context*, battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0x2B);
	ff7_externals.swap_extension = (void (*)(char*, char*, char*))get_relative_call(ff7_externals.read_battle_hrc, 0x43);
	ff7_externals.destroy_battle_hrc = (void (*)(uint32_t, battle_hrc_header*))get_relative_call(ff7_externals.read_battle_hrc, 0xB3);
	ff7_externals.battle_regular_olddir = (void (*)(battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0xD2);
	ff7_externals.battle_context_olddir = (void (*)(file_context*, battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0xE7);

	ff7_externals.field_sub_60DCED = get_relative_call(field_main_loop, 0x37A);
	ff7_externals.field_load_models = get_relative_call(ff7_externals.field_sub_60DCED, 0x168);
	ff7_externals.field_models_eye_to_model = get_relative_call(ff7_externals.field_load_models, 0xA79);
	ff7_externals.field_load_animation = get_relative_call(ff7_externals.field_load_models, 0x8DF);
	ff7_externals.field_load_model_eye_tex = (int (*)(ff7_model_eye_texture_data*,field_animation_data*))get_relative_call(ff7_externals.field_load_models, 0xB90);
	ff7_externals.field_load_model_tex = (p_hundred* (*)(int, int, char*, struc_3*, game_obj*))get_relative_call((uint32_t)ff7_externals.field_load_model_eye_tex, 0x9D);
	ff7_externals.field_unload_model_tex = (void (*)(void*))get_relative_call((uint32_t)ff7_externals.field_load_model_eye_tex, 0x1DE);
	ff7_externals.create_struc_3_info_sub_67455E = (void (*)(struc_3*))get_relative_call((uint32_t)ff7_externals.field_load_model_eye_tex, 0x12);
	ff7_externals.load_animation = get_relative_call(ff7_externals.field_load_animation, 0x16D);
	ff7_externals.destroy_animation = (void (*)(anim_header*))get_relative_call(ff7_externals.load_animation, 0x162);
	ff7_externals.field_unk_909288 = (uint32_t*)get_absolute_value((uint32_t)ff7_externals.field_load_model_eye_tex, 0x1D);

	ff7_externals.field_models_eye_blink_buffer = (ff7_model_eye_texture_data*)get_absolute_value(ff7_externals.field_load_models, 0xB8C);
	ff7_externals.field_models_data = (DWORD*)get_absolute_value(ff7_externals.field_load_models, 0xE);

	ff7_externals.load_lgp = get_relative_call(main_loop, 0x450);
	ff7_externals.open_lgp_file = get_relative_call(ff7_externals.load_lgp, 0x1C);
	ff7_externals.__read = get_relative_call(common_externals.read_file, 0x4A);

	ff7_externals.lgp_open_file = get_relative_call((uint32_t)common_externals.open_file, 0x234);
	ff7_externals.lgp_seek_file = get_relative_call((uint32_t)common_externals.open_file, 0x265);
	ff7_externals.lgp_read = get_relative_call((uint32_t)common_externals.read_file, 0x2E);
	ff7_externals.lgp_get_filesize = get_relative_call((uint32_t)ff7_externals.read_field_file, 0x71);
	ff7_externals.lgp_read_file = get_relative_call((uint32_t)ff7_externals.read_field_file, 0xDD);

	ff7_externals.lzss_decode = (int (*)(char*, char*))get_relative_call((uint32_t)ff7_externals.read_field_file, 0xF2);
	ff7_externals.field_file_buffer = (char**)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0xB2);
	ff7_externals.field_file_section_ptrs = (DWORD*)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0x187);
	ff7_externals.known_field_buffer_size = (uint32_t*)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0xA4);
	ff7_externals.field_resuming_from_battle_CFF268 = (uint32_t*)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0xB);

	ff7_externals.lgp_fds = (FILE **)get_absolute_value(ff7_externals.lgp_seek_file, 0x17);

	ff7_externals.context_chdir = get_relative_call((uint32_t)ff7_externals.battle_context_chdir, 0x3C);
	ff7_externals.lgp_chdir = get_relative_call(ff7_externals.context_chdir, 0x2A);

	ff7_externals.lgp_lookup_tables = (lookup_table_entry **)get_absolute_value(ff7_externals.lgp_open_file, 0x194);
	ff7_externals.lgp_tocs = (lgp_toc_entry **)get_absolute_value(ff7_externals.lgp_open_file, 0x233);
	ff7_externals.lgp_folders = (lgp_folders *)get_absolute_value(ff7_externals.lgp_open_file, 0x42C);

	ff7_externals.battle_sub_437DB0 = get_absolute_value(ff7_externals.battle_loop, 0x8D);
	ff7_externals.sub_5CB2CC = get_relative_call(ff7_externals.battle_sub_437DB0, 0x43);
	ff7_externals.battle_formation_id = (WORD*)get_absolute_value(ff7_externals.battle_sub_437DB0, 0x1FD);
	ff7_externals.battle_scene_bin_sub_5D1050 = get_relative_call(ff7_externals.battle_sub_437DB0, 0x15D);
	ff7_externals.engine_load_bin_file_sub_419210 = (int (*)(char *filename, int offset, int size, char **out_buffer, void (*callback)(void)))(get_relative_call(ff7_externals.battle_scene_bin_sub_5D1050, 0x85));

	ff7_externals.play_midi = (void (*)(uint32_t))common_externals.play_midi;
	common_externals.master_midi_volume = (DWORD *)get_absolute_value(common_externals.set_master_midi_volume, 0x46);
	ff7_externals.midi_volume_control = (uint32_t *)get_absolute_value(common_externals.midi_init, 0x706);
	ff7_externals.midi_initialized = (uint32_t *)get_absolute_value(common_externals.midi_init, 0x3A);

	ff7_externals.menu_sub_6CDA83 = get_relative_call(menu_main_loop, 0x112);
	ff7_externals.menu_sub_6CBD43 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0xAF);
	ff7_externals.menu_sub_701EE4 = get_relative_call(ff7_externals.menu_sub_6CBD43, 0x7);
	ff7_externals.phs_menu_sub = get_relative_call(ff7_externals.menu_sub_701EE4, 0xE3);
	ff7_externals.menu_battle_end_sub_6C9543 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0x20);

	switch(version)
	{
		case VERSION_FF7_102_US:
			ff7_externals.menu_draw_party_member_stats = get_relative_call(ff7_externals.phs_menu_sub, 0x8FF);
			break;
		default:
			ff7_externals.menu_draw_party_member_stats = get_relative_call(ff7_externals.phs_menu_sub, 0x8F5);
			break;
	}

	ff7_externals.party_member_to_char_map = (uint32_t *)get_absolute_value(ff7_externals.menu_draw_party_member_stats, 0x14);

	ff7_externals.menu_start = get_absolute_value(main_loop, 0x627);
	ff7_externals.menu_sub_6CB56A = get_relative_call(ff7_externals.menu_sub_6CDA83, 0xDE);
	ff7_externals.menu_subs_call_table = (uint32_t *)get_absolute_value(ff7_externals.menu_sub_6CB56A, 0x2EC);
	ff7_externals.menu_tutorial_sub_6C49FD = (int (*)())get_relative_call(ff7_externals.menu_sub_6CB56A, 0x2B7);
	ff7_externals.timer_menu_sub = ff7_externals.menu_subs_call_table[0];
	ff7_externals.status_menu_sub = ff7_externals.menu_subs_call_table[5];
	ff7_externals.config_menu_sub = ff7_externals.menu_subs_call_table[8];
	ff7_externals.menu_sub_6FEDB0 = ff7_externals.menu_subs_call_table[10];

	ff7_externals.config_initialize = get_relative_call(main_init_loop, 0x4B0);

	ff7_externals.menu_tutorial_window_state = (BYTE*)get_absolute_value((uint32_t)ff7_externals.menu_tutorial_sub_6C49FD, 0x9);
	ff7_externals.menu_tutorial_window_text_ptr = (DWORD*)get_absolute_value((uint32_t)ff7_externals.menu_tutorial_sub_6C49FD, 0x18);

	switch(version)
	{
		case VERSION_FF7_102_US:
			ff7_externals.write_save_file = (BOOL (*)(char))(get_relative_call(ff7_externals.menu_sub_6FEDB0, 0x1096));
			break;
		case VERSION_FF7_102_DE:
		case VERSION_FF7_102_FR:
			ff7_externals.write_save_file = (BOOL (*)(char))(get_relative_call(ff7_externals.menu_sub_6FEDB0, 0x10B2));
			break;
		case VERSION_FF7_102_SP:
			ff7_externals.write_save_file = (BOOL (*)(char))(get_relative_call(ff7_externals.menu_sub_6FEDB0, 0x10FE));
			break;
	}

	ff7_externals.millisecond_counter = (DWORD *)get_absolute_value(ff7_externals.timer_menu_sub, 0xD06);
	ff7_externals.draw_status_limit_level_stats = get_relative_call(ff7_externals.status_menu_sub, 0x8E);

	ff7_externals.menu_sub_6F5C0C = (void *(*)(uint32_t, uint32_t, uint8_t, uint8_t, uint32_t))(get_relative_call(ff7_externals.timer_menu_sub, 0x72F));
	ff7_externals.menu_sub_6FAC38 = (void *(*)(uint32_t, uint32_t, uint8_t, uint8_t, uint32_t))(get_relative_call(ff7_externals.timer_menu_sub, 0xD77));

	ff7_externals.get_kernel_text = (char* (*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.draw_status_limit_level_stats, 0x10C);

	ff7_externals.sub_5CF282 = get_relative_call(ff7_externals.sub_5CB2CC, 0x4E);
	ff7_externals.get_equipment_stats = get_relative_call(ff7_externals.sub_5CF282, 0x2F0);

	ff7_externals.weapon_data_array = (weapon_data *)(get_absolute_value(ff7_externals.get_equipment_stats, 0x50) - 4);
	ff7_externals.armor_data_array = (armor_data *)(get_absolute_value(ff7_externals.get_equipment_stats, 0x78) - 2);

	ff7_externals.field_sub_6388EE = get_relative_call(field_main_loop, 0xFF);
	ff7_externals.field_draw_everything = get_relative_call(ff7_externals.field_sub_6388EE, 0x11);
	ff7_externals.field_draw_pointer_hand_60D4F3 = get_relative_call(ff7_externals.field_draw_everything, 0x1A9);
	ff7_externals.field_submit_draw_pointer_hand_60D572 = get_relative_call(ff7_externals.field_draw_pointer_hand_60D4F3, 0x4F);
	ff7_externals.field_pick_tiles_make_vertices = get_relative_call(ff7_externals.field_draw_everything, 0xC9);
	ff7_externals.field_layer1_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x2D);
	ff7_externals.field_layer1_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer1_pick_tiles, 0x8B);
	ff7_externals.field_layer1_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer1_pick_tiles, 0xA2);
	ff7_externals.field_layer1_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer1_pick_tiles, 0xBF);
	ff7_externals.field_layer2_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x48);
	ff7_externals.field_layer2_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0x8C);
	ff7_externals.field_layer2_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0xA3);
	ff7_externals.field_layer2_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0xC0);
	ff7_externals.field_layer3_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x12);
	ff7_externals.field_layer3_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0xAB);
	ff7_externals.field_layer3_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0xC1);
	ff7_externals.field_layer3_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0xDD);
	ff7_externals.do_draw_layer3_CFFE3C = (int*)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x9);
	ff7_externals.field_layer3_flag_CFFE40 = (int*)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x3B1);
	ff7_externals.field_layer4_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x5F);
	ff7_externals.field_layer4_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x90);
	ff7_externals.field_layer4_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0xA6);
	ff7_externals.field_layer4_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0xC2);
	ff7_externals.do_draw_layer4_CFFEA4 = (int*)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x9);
	ff7_externals.field_layer4_flag_CFFEA8 = (int*)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x3F3);
	ff7_externals.field_layer_sub_623C0F = (double(*)(rotation_matrix*, int, int, int))get_relative_call(ff7_externals.field_layer3_pick_tiles, 0x7E);
	ff7_externals.field_layer_CFF1D8 = (int *)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x264);
	ff7_externals.field_palette_D00088 = (uint16_t *)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x28A);
	ff7_externals.field_special_y_offset = (uint32_t *)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0x43);
	ff7_externals.field_bg_multiplier = (uint32_t *)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0x23);
	ff7_externals.add_page_tile = (void (*)(float, float, float, float, float, uint32_t, uint32_t))get_relative_call(ff7_externals.field_layer2_pick_tiles, 0x327);
	ff7_externals.field_triggers_header = (field_trigger_header**)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x134);
	ff7_externals.field_camera_rotation_matrix_CFF3D8 = (rotation_matrix*)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x7A);
	ff7_externals.field_draw_gray_quads_644E90 = (void(*)())get_relative_call(ff7_externals.field_draw_everything, 0x360);
	ff7_externals.engine_draw_graphics_object = (void(*)(ff7_graphics_object*, ff7_game_obj*))get_relative_call(ff7_externals.field_draw_everything, 0x1D2);

	ff7_externals.field_load_textures = get_relative_call(ff7_externals.field_sub_60DCED, 0x107);
	ff7_externals.field_convert_type2_layers = (void (*)())get_relative_call(ff7_externals.field_load_textures, 0xD);
	ff7_externals.make_struc3 = (void (*)(uint32_t, struc_3*))get_relative_call(ff7_externals.field_load_textures, 0xAC);
	ff7_externals.make_field_tex_header_pal = (void (*)(ff7_tex_header*))get_relative_call(ff7_externals.field_load_textures, 0x21F);
	ff7_externals.make_field_tex_header = (void (*)(ff7_tex_header*))get_relative_call(ff7_externals.field_load_textures, 0x23C);
	ff7_externals._load_texture = (ff7_graphics_object* (*)(uint32_t, uint32_t, struc_3*, char*, void*))get_relative_call(ff7_externals.field_load_textures, 0x2F8);

	ff7_externals.read_field_background_data = get_relative_call(ff7_externals.field_sub_60DCED, 0x8B);
	ff7_externals.layer2_end_page = (WORD *)get_absolute_value(ff7_externals.read_field_background_data, 0x788);

	ff7_externals.create_d3d2_indexed_primitive = get_relative_call((uint32_t)common_externals.generic_load_group, 0x22);
	ff7_externals.destroy_d3d2_indexed_primitive = get_relative_call(ff7_externals.create_d3d2_indexed_primitive, 0x290);

	ff7_externals.enter_main = get_absolute_value(ff7_externals.world_loop_74BE49, 0x2AE);

	ff7_externals.kernel_init = get_relative_call(ff7_externals.enter_main, 0xF1);
	ff7_externals.kernel_load_kernel2 = (void (*)(char*))get_relative_call(ff7_externals.kernel_init, 0x1FD);
	ff7_externals.kernel2_reset_counters = get_relative_call((uint32_t)ff7_externals.kernel_load_kernel2, 0x33);

	ff7_externals.sub_4012DA = get_absolute_value(ff7_externals.kernel_init, 0x136);
	ff7_externals.kernel2_add_section = get_relative_call(ff7_externals.sub_4012DA, 0x4D);
	ff7_externals.kernel2_get_text = get_relative_call((uint32_t)ff7_externals.get_kernel_text, 0xF7);
	ff7_externals.kernel_1to9_sections = (char**)get_absolute_value(ff7_externals.sub_4012DA, 0x6F);

	ff7_externals.draw_3d_model = get_relative_call(ff7_externals.field_draw_everything, 0x17F);
	ff7_externals.stack_push = (void (*)(struct stack*))get_relative_call(ff7_externals.draw_3d_model, 0x8E);
	ff7_externals.stack_top = (void* (*)(struct stack*))get_relative_call(ff7_externals.draw_3d_model, 0x9A);
	ff7_externals.stack_pop = (void (*)(struct stack*))get_relative_call(ff7_externals.draw_3d_model, 0x8FD);
	ff7_externals._root_animation = (void (*)(matrix*, anim_frame*, anim_header*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xD4);
	ff7_externals._frame_animation = (void (*)(uint32_t, matrix*, vector3<float>*, anim_frame*, anim_header*, hrc_bone*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xDB);
	ff7_externals.root_animation = (void (*)(matrix*, anim_frame*, anim_header*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xE7);
	ff7_externals.frame_animation = (void (*)(uint32_t, matrix*, vector3<float>*, anim_frame*, anim_header*, hrc_bone*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xEE);
	ff7_externals.model_mode = (uint32_t *)get_absolute_value(ff7_externals.draw_3d_model, 0x2A7);

	ff7_externals.name_menu_sub_6CBD32 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0x9A);
	ff7_externals.name_menu_sub_719C08 = get_relative_call(ff7_externals.name_menu_sub_6CBD32, 0x7);

	switch(version)
	{
		case VERSION_FF7_102_FR:
			ff7_externals.menu_sub_71894B = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x2B);
			ff7_externals.menu_sub_718DBE = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x77);
			ff7_externals.menu_sub_719B81 = get_relative_call(ff7_externals.name_menu_sub_719C08, 0xCC);

			ff7_externals.set_default_input_settings_save = get_relative_call(ff7_externals.menu_sub_71894B, 0x189);
			break;
		default:
			ff7_externals.menu_sub_71894B = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x2A);
			ff7_externals.menu_sub_718DBE = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x76);
			ff7_externals.menu_sub_719B81 = get_relative_call(ff7_externals.name_menu_sub_719C08, 0xCB);

			ff7_externals.set_default_input_settings_save = get_relative_call(ff7_externals.menu_sub_71894B, 0x188);
			break;
	}

	ff7_externals.keyboard_name_input = get_relative_call(ff7_externals.menu_sub_718DBE, 0x99);
 	ff7_externals.restore_input_settings = get_relative_call(ff7_externals.menu_sub_719B81, 0x80);

	ff7_externals.dinput_getdata2 = get_relative_call(ff7_externals.keyboard_name_input, 0x1C);
	common_externals.get_keyboard_state = get_relative_call(ff7_externals.keyboard_name_input, 0x6);

	ff7_externals.init_game = get_absolute_value(ff7_externals.init_stuff, 0x336);
	ff7_externals.sub_41A1B0 = get_relative_call(ff7_externals.init_game, 0x85);
	ff7_externals.init_directinput = get_relative_call(ff7_externals.sub_41A1B0, 0x34);
	ff7_externals.dinput_createdevice_mouse = get_relative_call(ff7_externals.init_directinput, 0x48);

	common_externals.dinput_acquire_keyboard = (int (*)())get_relative_call(common_externals.get_keyboard_state, 0x4F);
	common_externals.keyboard_device = (IDirectInputDeviceA**)get_absolute_value(common_externals.get_keyboard_state, 0x06);
	common_externals.keyboard_connected = (uint32_t*)get_absolute_value(common_externals.get_keyboard_state, 0x47);

	ff7_externals.sub_69C69F = (void (*)(matrix*, ff7_light*))get_relative_call(ff7_externals.draw_3d_model, 0x882);

	ff7_externals.coaster_sub_5E9051 = get_relative_call(coaster_main_loop, 0xC6);
	ff7_externals.coaster_sub_5EE150 = get_relative_call(ff7_externals.coaster_sub_5E9051, 0x3);

	ff7_externals.cleanup_game = get_absolute_value(ff7_externals.init_stuff, 0x350);
	common_externals.midi_cleanup = get_relative_call(ff7_externals.cleanup_game, 0x72);

	ff7_externals.sub_60DF96 = get_relative_call(ff7_externals.init_game, 0x42B);
	ff7_externals.sub_60EEB2 = get_relative_call(ff7_externals.sub_60DF96, 0x26);
	ff7_externals.open_flevel_siz = get_relative_call(ff7_externals.sub_60EEB2, 0x79F);
	ff7_externals.field_map_infos = get_absolute_value(ff7_externals.open_flevel_siz, 0xAF) - 0xBC;

	common_externals.sfx_init = get_relative_call(main_init_loop, 0xC3);
	ff7_externals.sfx_initialized = (uint32_t*)get_absolute_value(common_externals.sfx_init, 0x21);
	common_externals.sfx_release = get_relative_call(common_externals.sfx_init, 0x1FC);
	common_externals.sfx_cleanup = get_relative_call(main_cleanup_loop, 0x64);
	common_externals.sfx_load = get_relative_call(main_init_loop, 0xE3);
	common_externals.sfx_unload = get_relative_call(main_cleanup_loop, 0x5C);
	ff7_externals.sound_operation = get_relative_call(ff7_externals.enter_main, 0xE4);
	common_externals.sfx_pause = get_relative_call(ff7_externals.sound_operation, 0x6E3);
	common_externals.sfx_resume = get_relative_call(ff7_externals.sound_operation, 0x6F1);
	common_externals.sfx_stop = get_relative_call(ff7_externals.sound_operation, 0x290);
	common_externals.play_sfx_on_channel = get_relative_call(ff7_externals.sound_operation, 0x2AB);
	common_externals.set_sfx_volume_on_channel = (uint32_t(*)(uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x3B3);
	common_externals.set_sfx_volume_trans_on_channel = (uint32_t(*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x437);
	common_externals.set_sfx_panning_on_channel = (uint32_t(*)(uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x4C7);
	common_externals.set_sfx_panning_trans_on_channel = (uint32_t(*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x54B);
	common_externals.set_sfx_frequency_on_channel = (uint32_t(*)(uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x5DB);
	common_externals.set_sfx_frequency_trans_on_channel = (uint32_t(*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x65F);
	common_externals.dsound_volume_table = (uint32_t*)get_absolute_value(uint32_t(common_externals.set_sfx_volume_on_channel), 0xCC);
	common_externals.play_sfx = (uint32_t(*)(uint32_t))get_relative_call(ff7_externals.sound_operation, 0x703);
	common_externals.play_sfx_effects = (uint32_t(*)(byte, uint32_t, uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x327);
	ff7_externals.sfx_play_effects_id_channel_6 = (DWORD *)get_absolute_value((uint32_t)common_externals.play_sfx_effects, 0x119);
	ff7_externals.sound_states = (ff7_field_sfx_state*)get_absolute_value(common_externals.play_sfx_on_channel, 0x28);
	common_externals.master_sfx_volume = (uint32_t*)get_absolute_value(common_externals.play_sfx_on_channel, 0x342);
	ff7_externals.sfx_fmt_header = (ff7_audio_fmt*)get_absolute_value(common_externals.sfx_load, 0x51);

	common_externals.directsound_create = get_relative_call(common_externals.sfx_init, 0x11C);
	common_externals.directsound = (LPLPDIRECTSOUND)get_absolute_value(common_externals.directsound_create, 0x15);
	common_externals.directsound_createsoundbuffer = get_relative_call(common_externals.sfx_init, 0x16C);
	common_externals.directsound_release = get_relative_call(common_externals.sfx_init, 0x182);

	ff7_externals.battle_clear_sound_flags = get_relative_call(ff7_externals.battle_sub_429AC0, 0x6C);
	ff7_externals.swirl_sound_effect = get_relative_call(swirl_main_loop, 0x8B);
	ff7_externals.sfx_load_and_play_with_speed = get_relative_call(ff7_externals.swirl_sound_effect, 0x3E);

	ff7_externals.field_initialize_variables = get_relative_call(ff7_externals.field_sub_60DCED, 0x178);
	ff7_externals.music_lock_clear_fix = ff7_externals.field_initialize_variables + 0x2B8;
	ff7_externals.field_init_player_character_variables = get_relative_call(ff7_externals.field_initialize_variables, 0x31B);
	ff7_externals.field_init_event_wrapper_63BCA7 = get_relative_call(ff7_externals.field_initialize_variables, 0x29D);
	ff7_externals.field_init_event_60BACF = get_relative_call(ff7_externals.field_init_event_wrapper_63BCA7, 0x8);
	ff7_externals.field_init_field_objects_60BCFA = get_relative_call(ff7_externals.field_init_event_60BACF, 0x39);
	ff7_externals.execute_opcode = get_relative_call(ff7_externals.field_init_event_60BACF, 0x80);
	ff7_externals.modules_global_object = (ff7_modules_global_object*)get_absolute_value(ff7_externals.field_init_event_60BACF, 0x20);
	ff7_externals.field_global_object_ptr = (ff7_modules_global_object**)get_absolute_value(ff7_externals.field_init_event_60BACF, 0x1C);

	common_externals.execute_opcode_table = (uint32_t*)get_absolute_value(ff7_externals.execute_opcode, 0x10D);
	ff7_externals.opcode_tutor = common_externals.execute_opcode_table[0x21];
	ff7_externals.opcode_goldu = common_externals.execute_opcode_table[0x39];
	ff7_externals.opcode_dlitm = common_externals.execute_opcode_table[0x59];
	ff7_externals.opcode_smtra = common_externals.execute_opcode_table[0x5B];
	ff7_externals.opcode_akao2 = common_externals.execute_opcode_table[0xDA];
	ff7_externals.opcode_akao = common_externals.execute_opcode_table[0xF2];
	ff7_externals.opcode_bmusc = common_externals.execute_opcode_table[0xF6];
	ff7_externals.opcode_fmusc = common_externals.execute_opcode_table[0xFC];
	ff7_externals.opcode_cmusc = common_externals.execute_opcode_table[0xFD];
	ff7_externals.opcode_gameover = common_externals.execute_opcode_table[0xFF];
	ff7_externals.opcode_message = common_externals.execute_opcode_table[0x40];
	ff7_externals.opcode_ask = common_externals.execute_opcode_table[0x48];
	ff7_externals.opcode_canm1_canm2 = common_externals.execute_opcode_table[0xB1];
	ff7_externals.opcode_wmode = common_externals.execute_opcode_table[0x52];
	ff7_externals.opcode_fade = common_externals.execute_opcode_table[0x6B];
	ff7_externals.opcode_shake = common_externals.execute_opcode_table[0x5E];
	ff7_externals.opcode_setbyte = common_externals.execute_opcode_table[0x80];
	ff7_externals.opcode_biton = common_externals.execute_opcode_table[0x82];
	ff7_externals.opcode_pc = common_externals.execute_opcode_table[0xA0];
	ff7_externals.opcode_kawai = common_externals.execute_opcode_table[0x28];

	ff7_externals.field_opcode_08_sub_61D0D4 = get_relative_call(common_externals.execute_opcode_table[0x08], 0x5A);
	ff7_externals.field_opcode_08_09_set_rotation_61DB2C = (void(*)(short, byte, byte))get_relative_call(ff7_externals.field_opcode_08_sub_61D0D4, 0x196);
	ff7_externals.field_opcode_AA_2A_sub_616476 = get_relative_call(common_externals.execute_opcode_table[0xAA], 0x26);
	ff7_externals.field_opcode_turn_character_sub_616CB5 = get_relative_call(common_externals.execute_opcode_table[0xAB], 0x28);
	ff7_externals.field_get_rotation_final_636515 = (int(*)(vector3<int>*, vector3<int>*, int*))get_relative_call(ff7_externals.field_opcode_turn_character_sub_616CB5, 0x34F);

	ff7_externals.field_event_data_ptr = (field_event_data**)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0xC1);
	ff7_externals.field_animation_data_ptr = (field_animation_data**)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0x199);
	ff7_externals.field_model_id_array = (byte*)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0x12);
	ff7_externals.animation_type_array = (char*)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0x5D);
	ff7_externals.word_DB958A = (WORD *)get_absolute_value(common_externals.execute_opcode_table[0x23], 0x5);

	ff7_externals.field_opcode_message_update_loop_630D50 = get_relative_call(ff7_externals.opcode_message, 0x3B);
	ff7_externals.field_text_box_window_create_631586 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x39);
	ff7_externals.field_text_box_window_opening_6317A9 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x5A);
	ff7_externals.field_text_box_window_paging_631945 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x6D);
	ff7_externals.field_text_box_window_reverse_paging_632CAA = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x80);
	ff7_externals.field_text_box_window_closing_632EB8 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x235);
	ff7_externals.opcode_message_loop_code = (WORD*)get_absolute_value(ff7_externals.field_opcode_message_update_loop_630D50, 0x12);
	ff7_externals.current_dialog_string_pointer = (DWORD*)get_absolute_value(ff7_externals.field_text_box_window_create_631586, 0x154);
	ff7_externals.current_dialog_message_speed = (WORD*)get_absolute_value(ff7_externals.field_text_box_window_create_631586, 0x1C1);
	ff7_externals.field_entity_id_list = (char*)get_absolute_value(ff7_externals.field_text_box_window_create_631586, 0x1F);

	ff7_externals.field_opcode_ask_update_loop_6310A1 = (int (*)(uint8_t, uint8_t, uint8_t, uint8_t, WORD*))get_relative_call(ff7_externals.opcode_ask, 0x8E);
	ff7_externals.opcode_ask_question_code = (WORD*)get_absolute_value((uint32_t)ff7_externals.field_opcode_ask_update_loop_6310A1, 0x2FE);

	ff7_externals.field_music_helper = get_relative_call(ff7_externals.opcode_cmusc, 0x5E);
	ff7_externals.field_music_id_to_midi_id = (uint32_t (*)(int16_t))get_relative_call(ff7_externals.field_music_helper, 0x3B);
	ff7_externals.field_music_id_to_midi_id_call1 = ff7_externals.field_music_helper + 0x3B;
	ff7_externals.field_music_id_to_midi_id_call2 = ff7_externals.opcode_bmusc + 0x37;
	ff7_externals.field_music_id_to_midi_id_call3 = ff7_externals.opcode_fmusc + 0x37;

	switch(version)
	{
		case VERSION_FF7_102_DE:
			ff7_externals.field_music_helper_sound_op_call = ff7_externals.field_music_helper + 0x147;
			break;
		default:
			ff7_externals.field_music_helper_sound_op_call = ff7_externals.field_music_helper + 0x106;
			break;
	}

	ff7_externals.enter_gameover = get_absolute_value(main_loop, 0x1F7);
	ff7_externals.exit_gameover = get_absolute_value(main_loop, 0x213);
	ff7_externals.start_gameover = (void* (*)())get_relative_call(ff7_externals.enter_gameover, 0xC6);
	ff7_externals.gameover_sub_6C12B1 = (void* (*)())get_relative_call(ff7_externals.exit_gameover, 0x21);
	ff7_externals.on_gameover_enter = ff7_externals.enter_gameover + 0xC6;
	ff7_externals.on_gameover_exit = ff7_externals.exit_gameover + 0x21;

	ff7_externals.enter_field = get_absolute_value(main_loop, 0x90D);
	ff7_externals.field_init_viewport_values = get_relative_call(main_init_loop, 0x375);
	ff7_externals.field_loop_sub_63C17F = get_relative_call(field_main_loop, 0x59);
	ff7_externals.field_update_models_positions = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x5DD);
	ff7_externals.field_update_single_model_position = (int (*)(int16_t))get_relative_call(ff7_externals.field_update_models_positions, 0x8BC);
	ff7_externals.field_update_model_animation_frame = (void (*)(int16_t))get_relative_call(ff7_externals.field_update_models_positions, 0x68D);
	ff7_externals.field_check_collision_with_target = (int (*)(field_event_data*, short))get_relative_call(ff7_externals.field_update_models_positions, 0x9AA);
	ff7_externals.field_get_linear_interpolated_value = (int (*)(int, int, int, int))get_relative_call(ff7_externals.field_update_models_positions, 0x122);
	ff7_externals.field_get_smooth_interpolated_value = (int (*)(int, int, int, int))get_relative_call(ff7_externals.field_update_models_positions, 0x1EC);
	ff7_externals.field_evaluate_encounter_rate_60B2C6 = (void (*)())get_relative_call(ff7_externals.field_update_models_positions, 0x90F);
	ff7_externals.field_animate_3d_models_6392BB = get_relative_call(field_main_loop, 0xF6);
	ff7_externals.field_blink_3d_model_649B50 = (void(*)(field_animation_data*, field_model_blink_data*))get_relative_call(ff7_externals.field_animate_3d_models_6392BB, 0x8A7);
	ff7_externals.field_sub_6A2736 = (int (*)(ff7_polygon_set*))get_relative_call((uint32_t)ff7_externals.field_blink_3d_model_649B50, 0xC4);
	ff7_externals.field_sub_6A2782 = (p_hundred** (*)(int idx, p_hundred *hundreddata, ff7_polygon_set *polygon_set))(get_relative_call(uint32_t(ff7_externals.field_blink_3d_model_649B50), 0x143));
	ff7_externals.field_model_blink_data_D000C8 = (field_model_blink_data*)get_absolute_value(ff7_externals.field_animate_3d_models_6392BB, 0x7E6);
	ff7_externals.field_apply_kawai_op_64A070 = get_relative_call(ff7_externals.field_animate_3d_models_6392BB, 0x726);
	ff7_externals.sub_64EC60 = get_relative_call(ff7_externals.field_apply_kawai_op_64A070, 0x964);
	ff7_externals.field_player_model_id = (short*)get_absolute_value(ff7_externals.field_update_models_positions, 0x45D);
	ff7_externals.field_n_models = (WORD*)get_absolute_value(ff7_externals.field_update_models_positions, 0x25);
	ff7_externals.field_update_camera_data = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0xFD);
	ff7_externals.field_camera_data = (ff7_camdata**)get_absolute_value(ff7_externals.field_update_camera_data, 0x84);
	ff7_externals.sub_40B27B = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0xEE);
	ff7_externals.word_CC0DD4 = (WORD*)get_absolute_value(ff7_externals.enter_field, 0x124);
	ff7_externals.word_CC1638 = (WORD*)get_absolute_value(ff7_externals.sub_40B27B, 0x25);
	ff7_externals.field_init_scripted_bg_movement = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x182);
	ff7_externals.field_update_scripted_bg_movement = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x187);
	ff7_externals.field_update_background_positions = (void (*)())get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x1A6);
	ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x62C);
	ff7_externals.field_submit_draw_arrow_63A171 = (void(*)(field_arrow_graphics_data*))get_relative_call(ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B, 0x357);
	ff7_externals.field_sub_64314F = get_relative_call((uint32_t)ff7_externals.field_update_background_positions, 0x288);
	ff7_externals.set_world_pos_based_on_player_pos_643C86 = (void(*)(vector2<short>*))get_relative_call(ff7_externals.field_update_scripted_bg_movement, 0x3D);
	ff7_externals.field_clip_with_camera_range_6438F6 = (void(*)(vector2<short>*))get_relative_call((uint32_t)ff7_externals.field_update_background_positions, 0x2B7);
	ff7_externals.field_layer3_clip_with_camera_range_643628 = get_relative_call((uint32_t)ff7_externals.field_update_background_positions, 0x2CA);
	ff7_externals.engine_set_game_engine_delta_values_661976 = (void (*)(int, int))get_relative_call(ff7_externals.field_sub_64314F, 0x2D);
	ff7_externals.engine_apply_matrix_product_66307D = get_relative_call(ff7_externals.field_sub_64314F, 0x45);
	ff7_externals.engine_convert_psx_matrix_to_float_matrix_row_version_661465 = (void (*)(rotation_matrix*, float*))get_relative_call(ff7_externals.engine_apply_matrix_product_66307D, 0x23);
	ff7_externals.engine_apply_matrix_product_to_vector_66CF7E = (void (*)(float*, vector3<float>*, vector3<float>*))get_relative_call(ff7_externals.engine_apply_matrix_product_66307D, 0x37);
	ff7_externals.field_bg_offset = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x3E8);
	ff7_externals.field_curr_delta_world_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x98F);
	ff7_externals.field_curr_delta_world_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x9AC);
	ff7_externals.scripted_world_initial_pos_x = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0xB8);
	ff7_externals.scripted_world_initial_pos_y = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0xE5);
	ff7_externals.scripted_world_final_pos_x = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x215);
	ff7_externals.scripted_world_final_pos_y = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x243);
	ff7_externals.scripted_world_move_n_steps = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x8A);
	ff7_externals.scripted_world_move_step_index = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x102);
	ff7_externals.field_world_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x403);
	ff7_externals.field_world_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x424);
	ff7_externals.field_cursor_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x5C3);
	ff7_externals.field_cursor_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x5F6);
	ff7_externals.field_viewport_xy_CFF204 = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_sub_64314F, 0x28);
	ff7_externals.field_max_half_viewport_width_height_CFF1F4 = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_sub_64314F, 0x58);
	ff7_externals.field_curr_half_viewport_width_height_CFF1FC = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x5AD);
	ff7_externals.field_bg_flag_CC15E4 = (WORD*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x129);
	ff7_externals.field_sub_640EB7 = get_relative_call(ff7_externals.field_draw_everything, 0x34);
	ff7_externals.field_sub_661B68 = get_relative_call(ff7_externals.field_sub_640EB7, 0x61);
	ff7_externals.field_prev_world_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_sub_640EB7, 0x6);
	ff7_externals.field_prev_world_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_sub_640EB7, 0x18);
	ff7_externals.engine_set_game_engine_world_coord_661B23 = (void (*)(int, int))get_relative_call(ff7_externals.field_sub_661B68, 0x1A);
	ff7_externals.engine_sub_67CCDE = (void (*)(float, float, float, float, float, float, float, ff7_game_obj*))get_relative_call(ff7_externals.field_sub_661B68, 0x72);
	ff7_externals.field_handle_screen_fading = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x634);
	ff7_externals.sub_62120E = get_relative_call(ff7_externals.enter_field, 0x229);
	ff7_externals.field_load_map_trigger_data_sub_6211C3 = (int(*)())get_relative_call(ff7_externals.sub_62120E, 0x3AA);
	ff7_externals.field_fade_screen_sub_63B84B = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x634);
	ff7_externals.field_calc_fade_color_sub_63AE66 = get_relative_call(ff7_externals.field_fade_screen_sub_63B84B, 0xE7);

	ff7_externals.sfx_stop_channel_6 = get_relative_call(common_externals.sfx_cleanup, 0x16);
	ff7_externals.sfx_stop_channel_timer_handle = (UINT *)get_absolute_value(ff7_externals.sfx_stop_channel_6, 0x5);

	ff7_externals.current_movie_frame = (WORD*)get_absolute_value(ff7_externals.field_loop_sub_63C17F, 0x133);
	ff7_externals.opening_movie_music_start_frame = (DWORD *)(ff7_externals.field_loop_sub_63C17F + 0x139);
	ff7_externals.opening_movie_play_midi_call = ff7_externals.field_loop_sub_63C17F + 0x145;

	ff7_externals.byte_CC164C = (BYTE *)get_absolute_value(main_loop, 0x32A);
	ff7_externals.word_CC0DC6 = (WORD *)get_absolute_value(main_init_loop, 0x4BD);

	ff7_externals.sub_5F5042 = get_relative_call(condor_main_loop, 0x69);
	ff7_externals.highway_loop_sub_650F36 = get_relative_call(highway_main_loop, 0x53);
	ff7_externals.snowboard_enter_sub_722C10 = get_absolute_value(main_loop, 0xB53);
	ff7_externals.snowboard_loop_sub_72381C = get_relative_call(snowboard_main_loop, 0x7D);
	ff7_externals.snowboard_exit_sub_722C52 = get_absolute_value(main_loop, 0xB5A);
	ff7_externals.sub_779E14 = get_relative_call(chocobo_main_loop, 0x70);

	ff7_externals.condor_enter = get_absolute_value(main_loop, 0xA28);
	ff7_externals.condor_exit = get_absolute_value(main_loop, 0xA2F);
	ff7_externals.sub_5F7756 = get_relative_call(ff7_externals.condor_enter, 0x1B0);
	ff7_externals.sub_5F4273 = get_relative_call(ff7_externals.sub_5F7756, 0xA2);
	ff7_externals.sub_5F342C = get_relative_call(ff7_externals.sub_5F4273, 0xBF);
	ff7_externals.condor_uses_lgp = (DWORD*)get_absolute_value(ff7_externals.sub_5F342C, 0x7A);

	ff7_externals.fps_limiter_swirl = get_relative_call(swirl_main_loop, 0xDE);
	ff7_externals.fps_limiter_battle = get_relative_call(battle_main_loop, 0x1DD);
	ff7_externals.fps_limiter_coaster = get_relative_call(coaster_main_loop, 0x51);
	ff7_externals.fps_limiter_condor = get_relative_call(ff7_externals.sub_5F5042, 0x5F);
	ff7_externals.fps_limiter_field = get_relative_call(ff7_externals.field_sub_6388EE, 0x58);
	ff7_externals.fps_limiter_highway = get_relative_call(ff7_externals.highway_loop_sub_650F36, 0xC3);
	ff7_externals.fps_limiter_snowboard = get_relative_call(ff7_externals.snowboard_loop_sub_72381C, 0x14);
	ff7_externals.fps_limiter_worldmap = get_relative_call(ff7_externals.world_loop_74BE49, 0x1D);
	ff7_externals.fps_limiter_chocobo = get_relative_call(ff7_externals.sub_779E14, 0x4D);
	ff7_externals.fps_limiter_submarine = get_relative_call(submarine_main_loop, 0x98);
	ff7_externals.fps_limiter_credits = get_relative_call(credits_main_loop, 0x1C);
	ff7_externals.fps_limiter_menu = get_relative_call(menu_main_loop, 0x16);

	ff7_externals.battle_fps_menu_multiplier = battle_main_loop + 0x335;
	ff7_externals.submarine_minigame_status = (DWORD *)get_absolute_value(ff7_externals.fps_limiter_submarine, 0x48);
	ff7_externals.submarine_last_gametime = (time_t *)get_absolute_value(ff7_externals.fps_limiter_submarine, 0x26);
	ff7_externals.field_limit_fps = (DWORD *)get_absolute_value(ff7_externals.fps_limiter_field, 0x1F);
	ff7_externals.swirl_limit_fps = (DWORD *)get_absolute_value(ff7_externals.fps_limiter_swirl, 0x48);

	ff7_externals.get_bank_value = (int16_t (*)(int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0xF1], 0x30);
	ff7_externals.set_bank_value = (int8_t (*)(int16_t, int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0xFA], 0x1A);
	ff7_externals.get_char_bank_value = (int8_t (*)(int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0x5E], 0x41);
	ff7_externals.sub_611BAE = get_relative_call(common_externals.execute_opcode_table[0x16], 0x4);

	ff7_externals.wait_frames_ptr = (WORD*)get_absolute_value(common_externals.execute_opcode_table[0x24], 0x1C);

	ff7_externals.world_mode_loop_sub_74DB8C = get_relative_call(ff7_externals.world_loop_74BE49, 0x114);
	ff7_externals.sub_767039 = (void (*)(DWORD*,DWORD*,DWORD*))get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x613);
	ff7_externals.wm_change_music = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x2CF);
	ff7_externals.wm_play_music_call = ff7_externals.wm_change_music + 0x5A;

	ff7_externals.sub_630C48 = (int (*)(int16_t, int16_t, int16_t, int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0x50], 0x174);

	ff7_externals.current_entity_id = (byte*)get_absolute_value(common_externals.execute_opcode_table[0x5F], 0x06); // 0xCC0964
	ff7_externals.field_script_ptr = (byte**)get_absolute_value(ff7_externals.open_field_file, 0xEA); //0xCBF5E8
	ff7_externals.field_curr_script_position = (WORD*)get_absolute_value(common_externals.execute_opcode_table[0x5F], 0xE); //0xCC0CF8
	common_externals.field_game_moment = (WORD*)get_absolute_value(common_externals.execute_opcode_table[0x9D], 0xEA); //0xDC08DC

	ff7_externals.sub_408074 = get_relative_call(main_loop, 0x681);
	ff7_externals.sub_60BB58 = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x16F);
	common_externals.update_field_entities = get_relative_call(ff7_externals.sub_60BB58, 0x3A); // 0x60C94D

	common_externals.current_field_id = (WORD*)get_absolute_value(ff7_externals.sub_408074, 0x41); // 0xCC15D0
	common_externals.previous_field_id = (WORD*)get_absolute_value(ff7_externals.sub_408074, 0x4F); // 0xCC0DEC
	common_externals.update_entities_call = common_externals.update_field_entities + 0x461; // 0x60CDAE

	ff7_externals.field_level_data_pointer = (byte**)ff7_externals.field_file_buffer; // 0xCFF594

	ff7_externals.sub_408116 = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x2A);
	ff7_externals.word_CC16E8 = (char *)get_absolute_value(ff7_externals.sub_408116, 0x8E);
	common_externals.current_triangle_id = (int16_t *)((char *)ff7_externals.word_CC16E8 + 136 * ff7_externals.modules_global_object->field_model_id);

	ff7_externals.sub_6499F7 = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x10C);
	ff7_externals.input_ok_button_status = (DWORD*)get_absolute_value(ff7_externals.sub_6499F7, 0x60);
	ff7_externals.input_run_button_status = (DWORD*)get_absolute_value(ff7_externals.sub_6499F7, 0x55);

	ff7_externals.field_load_models_atoi = ff7_externals.field_load_models + 0x262;

	// auto attack gamehacks
	ff7_externals.handle_actor_ready = ff7_externals.battle_menu_state_fn_table[0];
	ff7_externals.battle_menu_state = (WORD*)get_absolute_value(ff7_externals.handle_actor_ready, 0x17B);
	ff7_externals.set_battle_menu_state_data = get_relative_call(ff7_externals.handle_actor_ready, 0x187);
	ff7_externals.dispatch_chosen_battle_action = get_relative_call(ff7_externals.battle_sub_6DB0EE, 0x50E);
	ff7_externals.set_battle_targeting_data = get_relative_call(ff7_externals.battle_menu_state_fn_table[19], 0x11A);
	ff7_externals.issued_command_id = (byte*)get_absolute_value(ff7_externals.dispatch_chosen_battle_action, 0x12B);
	ff7_externals.issued_action_id = (uint16_t*)get_absolute_value(ff7_externals.dispatch_chosen_battle_action, 0x122);
	ff7_externals.issued_action_target_type = (byte*)get_absolute_value(ff7_externals.set_battle_targeting_data, 0x14E);
	ff7_externals.issued_action_target_index = (byte*)get_absolute_value(ff7_externals.set_battle_targeting_data, 0x164);
	// --------------------------------

	// ---------- 60 FPS feature ------------
	// Camera
	ff7_externals.handle_camera_functions = get_relative_call(ff7_externals.battle_sub_42D992, 0xE3);
	ff7_externals.set_camera_focal_position_scripts = get_relative_call(ff7_externals.handle_camera_functions, 0x35);
	ff7_externals.set_camera_position_scripts = get_relative_call(ff7_externals.handle_camera_functions, 0x4B);
	ff7_externals.execute_camera_functions = get_relative_call(ff7_externals.handle_camera_functions, 0x55);
	ff7_externals.add_fn_to_camera_fn_array = get_relative_call(ff7_externals.set_camera_focal_position_scripts, 0xF40);
	ff7_externals.battle_camera_sub_5C52F8 = get_relative_call(ff7_externals.set_camera_focal_position_scripts, 0x10A8);
	ff7_externals.battle_camera_sub_5C3E6F = get_relative_call(ff7_externals.set_camera_position_scripts, 0x169E);
	ff7_externals.camera_fn_array = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x39), 16);
	ff7_externals.camera_fn_data = std::span((bcamera_fn_data*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x4D), 16);
	ff7_externals.battle_camera_position = std::span((bcamera_position*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0x331), 4);
	ff7_externals.battle_camera_focal_point = std::span((bcamera_position*)get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0x233), 4);
	ff7_externals.battle_camera_focal_scripts_8FEE30 = (byte*)get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0xC1);
	ff7_externals.battle_camera_position_scripts_8FEE2C = (byte*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0xC1);
	ff7_externals.battle_camera_global_scripts_9A13BC = (DWORD*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0x17);
	ff7_externals.battle_camera_position_scripts_9010D0 = (DWORD*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0xDC);
	ff7_externals.battle_camera_focal_scripts_901270 = (DWORD*)get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0xDC);
	ff7_externals.battle_camera_script_index = (byte*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0xD2);
	ff7_externals.battle_camera_script_offset = (DWORD*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0x25);
	ff7_externals.camera_fn_index = (WORD*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x46);
	ff7_externals.camera_fn_counter = (WORD*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x54);

	ff7_externals.battle_camera_position_sub_5C3D0D = get_absolute_value(ff7_externals.set_camera_position_scripts, 0x5DE);
	ff7_externals.battle_camera_position_sub_5C5B9C = get_absolute_value(ff7_externals.set_camera_position_scripts, 0x40A);
	ff7_externals.battle_camera_position_sub_5C557D = get_absolute_value(ff7_externals.set_camera_position_scripts, 0xE28);
	ff7_externals.battle_camera_focal_sub_5C5F5E = get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0xBDB);
	ff7_externals.battle_camera_focal_sub_5C5714 = get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0x67D);

	ff7_externals.battle_sub_430DD0 = get_relative_call(ff7_externals.battle_loop, 0x99E);
	ff7_externals.battle_sub_429D8A = get_absolute_value(ff7_externals.battle_loop, 0x59);
	ff7_externals.update_battle_camera_sub_5C20CE = get_relative_call(ff7_externals.battle_sub_42D992, 0xFB);
	ff7_externals.set_battle_camera_sub_5C22BD = get_relative_call(ff7_externals.update_battle_camera_sub_5C20CE, 0x5A);
	ff7_externals.battle_camera_sub_5C22A9 = get_relative_call(ff7_externals.update_battle_camera_sub_5C20CE, 0x97);
	ff7_externals.compute_interpolation_to_formation_camera = get_relative_call(ff7_externals.battle_camera_sub_5C22A9, 0x3);
	ff7_externals.set_battle_camera_sub_5C2350 = get_relative_call(ff7_externals.battle_camera_sub_5C22A9, 0xA);
	ff7_externals.g_battle_camera_position = (vector3<short>*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x17);
	ff7_externals.g_battle_camera_focal_point = (vector3<short>*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x5E);
	ff7_externals.formation_camera = std::span((formation_camera*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x10), 4);
	ff7_externals.curr_formation_camera_idx = (byte*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x6);
	ff7_externals.battle_enter_frames_to_wait = (byte*)get_absolute_value(ff7_externals.battle_sub_429AC0, 0x14E);
	ff7_externals.g_variation_index = (byte*)get_absolute_value(ff7_externals.update_battle_camera_sub_5C20CE, 0x6F);
	ff7_externals.is_camera_moving_BFB2DC = (byte*)get_absolute_value(ff7_externals.update_battle_camera_sub_5C20CE, 0x1C1);

	// Animation effects
	uint32_t battle_sub_42A5D0 = get_relative_call(ff7_externals.battle_sub_429AC0, 0x1A6);
	ff7_externals.battle_sub_42A5EB = get_relative_call(battle_sub_42A5D0, 0x14);
	ff7_externals.battle_sub_42E275 = get_relative_call(ff7_externals.battle_sub_42D992, 0x6C);
	uint32_t battle_sub_42E3CA = get_relative_call(ff7_externals.battle_sub_42D992, 0x48);
	ff7_externals.battle_sub_42E34A = get_relative_call(battle_sub_42E3CA, 0x70);
	uint32_t battle_sub_42DBD2 = get_relative_call(ff7_externals.battle_sub_42D992, 0x90);
	uint32_t battle_sub_42F21F = get_relative_call(battle_sub_42DBD2, 0x37);
	ff7_externals.battle_sub_5B9EC2 = get_relative_call(battle_sub_42F21F, 0x38);
	ff7_externals.battle_sub_5BD5E9 = get_relative_call(ff7_externals.battle_sub_5B9EC2, 0x41);
	uint32_t battle_sub_42DE61 = get_relative_call(ff7_externals.battle_sub_42D992, 0x9F);
	ff7_externals.run_summon_animations_script_5C1B81 = get_absolute_value(battle_sub_42DE61, 0x17E);
	ff7_externals.run_summon_animations_script_sub_5C1D9A = get_relative_call(ff7_externals.run_summon_animations_script_5C1B81, 0xA4);
	ff7_externals.run_animation_script = get_relative_call(ff7_externals.battle_sub_42A5EB, 0xB8);
	ff7_externals.add_fn_to_effect100_fn = get_relative_call(ff7_externals.run_animation_script, 0x48C2);
	ff7_externals.execute_effect100_fn = get_relative_call(ff7_externals.battle_sub_42D992, 0x12E);
	ff7_externals.add_fn_to_effect60_fn = get_relative_call(ff7_externals.run_animation_script, 0x394);
	ff7_externals.execute_effect60_fn = get_relative_call(ff7_externals.battle_sub_42D992, 0x129);
	ff7_externals.add_fn_to_effect10_fn = get_relative_call(ff7_externals.run_animation_script, 0x825);
	ff7_externals.execute_effect10_fn = get_relative_call(ff7_externals.battle_sub_42D992, 0x4D);
	uint32_t battle_sub_42B66A = get_relative_call(ff7_externals.run_animation_script, 0x460A);
	ff7_externals.battle_update_3d_model_data = get_relative_call(ff7_externals.run_animation_script, 0x623);

	ff7_externals.effect100_array_data = std::span((effect100_data*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x5D), 100);
	ff7_externals.effect100_array_fn = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x48), 100);
	ff7_externals.effect100_counter = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x63);
	ff7_externals.effect100_array_idx = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x32);
	ff7_externals.effect60_array_data = std::span((effect60_data*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x5D), 60);
	ff7_externals.effect60_array_fn = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x48), 60);
	ff7_externals.effect60_array_idx = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x32);
	ff7_externals.effect60_counter = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x63);
	ff7_externals.effect10_array_data = std::span((effect10_data*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x5D), 10);
	ff7_externals.effect10_array_fn = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x48), 10);
	ff7_externals.effect10_array_idx = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x32);
	ff7_externals.effect10_counter = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x63);
	ff7_externals.g_actor_idle_scripts = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x304);
	ff7_externals.g_battle_model_state = std::span((battle_model_state*)get_absolute_value(battle_sub_42B66A, 0xD9), 10);
	ff7_externals.g_small_battle_model_state = std::span((battle_model_state_small*)get_absolute_value(ff7_externals.run_animation_script, 0x2BB9), 10);
	std::function<int(int)> shift_index = [](int index){return index - 0x2E;};
	ff7_externals.animation_script_pointers[shift_index(0x2E)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x81);
	ff7_externals.animation_script_pointers[shift_index(0x2F)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x90);
	ff7_externals.animation_script_pointers[shift_index(0x30)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x9F);
	ff7_externals.animation_script_pointers[shift_index(0x31)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xAE);
	ff7_externals.animation_script_pointers[shift_index(0x32)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xBD);
	ff7_externals.animation_script_pointers[shift_index(0x34)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xCC);
	ff7_externals.animation_script_pointers[shift_index(0x35)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xD8);
	ff7_externals.animation_script_pointers[shift_index(0x36)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xE4);
	ff7_externals.animation_script_pointers[shift_index(0x37)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xF0);
	ff7_externals.animation_script_pointers[shift_index(0x38)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xFC);
	ff7_externals.animation_script_pointers[shift_index(0x39)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x12D);
	ff7_externals.animation_script_pointers[shift_index(0x3A)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x139);
	ff7_externals.animation_script_pointers[shift_index(0x3B)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x145);
	ff7_externals.g_is_effect_loading = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x2D25);
	ff7_externals.g_is_battle_paused = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xA);
	ff7_externals.special_actor_id = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x286B);
	ff7_externals.g_script_wait_frames = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x27E8);
	ff7_externals.g_script_args = std::span((int**)get_absolute_value(ff7_externals.run_animation_script, 0x3EA), 8);
	ff7_externals.limit_break_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0x40E), 80);
	ff7_externals.enemy_atk_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0x4B9), 157);
	ff7_externals.enemy_skill_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0x20A), 24);

	// Enemy death animations
	uint32_t battle_run_enemy_deaths_42567E = get_relative_call(ff7_externals.run_animation_script, 0x4869);
	ff7_externals.battle_enemy_death_5BBD24 = get_absolute_value(battle_run_enemy_deaths_42567E, 0x37);
	ff7_externals.battle_enemy_death_sub_5BBE32 = get_relative_call(ff7_externals.battle_enemy_death_5BBD24, 0xF1);
	ff7_externals.battle_iainuki_death_5BCAAA = get_absolute_value(battle_run_enemy_deaths_42567E, 0x72);
	ff7_externals.battle_iainuki_death_sub_5BCBB8 = get_relative_call(ff7_externals.battle_iainuki_death_5BCAAA, 0xF1);
	ff7_externals.battle_boss_death_5BC48C = get_absolute_value(battle_run_enemy_deaths_42567E, 0x16A);
	ff7_externals.battle_boss_death_sub_5BC6ED = get_relative_call(ff7_externals.battle_boss_death_5BC48C, 0x144);
	ff7_externals.battle_boss_death_sub_5BC5EC = get_absolute_value(ff7_externals.battle_boss_death_5BC48C, 0x9F);
	ff7_externals.battle_boss_death_call_5BD436 = get_relative_call(ff7_externals.battle_boss_death_sub_5BC5EC, 0x7C);
	ff7_externals.field_battle_BFB2E0 = (int*)get_absolute_value(ff7_externals.battle_boss_death_sub_5BC5EC, 0x85);
	ff7_externals.battle_melting_death_5BC21F = get_absolute_value(battle_run_enemy_deaths_42567E, 0xF7);
	ff7_externals.battle_melting_death_sub_5BC32D = get_relative_call(ff7_externals.battle_melting_death_5BC21F, 0xF1);
	ff7_externals.battle_disintegrate_2_death_5BBA82 = get_absolute_value(battle_run_enemy_deaths_42567E, 0x132);
	ff7_externals.battle_disintegrate_2_death_sub_5BBBDE = get_relative_call(ff7_externals.battle_disintegrate_2_death_5BBA82, 0xFE);
	ff7_externals.field_float_battle_7B7680 = (float*)get_absolute_value(ff7_externals.battle_disintegrate_2_death_sub_5BBBDE, 0x10F);
	ff7_externals.battle_morph_death_5BC812 = get_absolute_value(battle_run_enemy_deaths_42567E, 0x1A2);
	ff7_externals.battle_morph_death_sub_5BC920 = get_relative_call(ff7_externals.battle_morph_death_5BC812, 0xF1);
	ff7_externals.battle_disintegrate_1_death_5BBF31 = get_absolute_value(battle_run_enemy_deaths_42567E, 0xAD);
	ff7_externals.battle_disintegrate_1_death_sub_5BC04D = get_relative_call(ff7_externals.battle_disintegrate_1_death_5BBF31, 0xFF);
	ff7_externals.battle_sub_42C0A7 = get_relative_call(ff7_externals.battle_disintegrate_1_death_sub_5BC04D, 0x8D);
	ff7_externals.effect10_array_data_8FE1F6 = (short*)get_absolute_value(ff7_externals.battle_disintegrate_1_death_sub_5BC04D, 0x123);

	// Display string for actor actions
	ff7_externals.display_battle_action_text_42782A = get_absolute_value(ff7_externals.run_animation_script, 0x4906);
	ff7_externals.get_n_frames_display_action_string = get_relative_call(ff7_externals.run_animation_script, 0x4918);
	ff7_externals.field_byte_DC0E11 = (byte*)get_absolute_value(ff7_externals.get_n_frames_display_action_string, 0x6);
	uint32_t battle_sub_4351BD = get_relative_call(ff7_externals.battle_loop, 0x47C);
	uint32_t** battle_functions_table_7C2AC0 = (uint32_t**)get_absolute_value(battle_sub_4351BD, 0x3A);
	ff7_externals.battle_sub_434C8B = battle_functions_table_7C2AC0[1][1];
	uint32_t battle_sub_435789 = get_relative_call(ff7_externals.battle_loop, 0x3B8);
	ff7_externals.battle_sub_435D81 = get_relative_call(battle_sub_435789, 0x505);

	// Display battle damage
	ff7_externals.battle_sub_425D29 = get_absolute_value(ff7_externals.run_animation_script, 0x2850);
	ff7_externals.battle_sub_425E5F = get_absolute_value(ff7_externals.battle_sub_425D29, 0xA8);
	ff7_externals.display_battle_damage_5BB410 = get_absolute_value(ff7_externals.battle_sub_425D29, 0x3D);

	// Reduce actor size (for Mini status effect)
	ff7_externals.battle_sub_42CBF9 = get_relative_call(ff7_externals.battle_loop, 0x425);
	ff7_externals.battle_sub_5BDA0F = get_absolute_value(ff7_externals.battle_sub_42CBF9, 0x240);

	// Character fade in/out
	ff7_externals.vincent_limit_fade_effect_sub_5D4240 = ff7_externals.limit_break_effects_fn_table[56];
	ff7_externals.battle_sub_5BD96D = get_absolute_value(ff7_externals.vincent_limit_fade_effect_sub_5D4240, 0x27);
	ff7_externals.battle_sub_5C1C8F = get_absolute_value(ff7_externals.run_summon_animations_script_5C1B81, 0x3F);
	uint32_t handle_fade_character_42C31C = get_relative_call(ff7_externals.battle_sub_5C1C8F, 0xEC);
	ff7_externals.battle_sub_5C18BC = get_absolute_value(ff7_externals.run_summon_animations_script_5C1B81, 0x30);
	ff7_externals.battle_sub_42A72D = get_relative_call(ff7_externals.battle_sub_429AC0, 0xD0);

	// resting positions and rotations
	uint32_t battle_sub_426C9B = get_relative_call(ff7_externals.run_animation_script, 0x14C7);
	ff7_externals.battle_sub_426DE3 = get_absolute_value(battle_sub_426C9B, 0x5);
	ff7_externals.battle_sub_426941 = get_absolute_value(ff7_externals.run_animation_script, 0x1A5D);
	ff7_externals.battle_sub_426899 = get_absolute_value(ff7_externals.run_animation_script, 0x821);
	ff7_externals.battle_sub_4267F1 = get_absolute_value(ff7_externals.run_animation_script, 0xFF6);
	ff7_externals.battle_move_character_sub_426A26 = get_absolute_value(ff7_externals.run_animation_script, 0x1568);
	ff7_externals.field_battle_byte_BF2E1C = (byte*)get_absolute_value(ff7_externals.battle_move_character_sub_426A26, 0x86);
	ff7_externals.field_battle_byte_BE10B4 = (byte*)get_absolute_value(ff7_externals.battle_move_character_sub_426A26, 0x148);
	ff7_externals.battle_move_character_sub_42739D = get_absolute_value(ff7_externals.run_animation_script, 0x248E);
	ff7_externals.battle_move_character_sub_426F58 = get_absolute_value(ff7_externals.run_animation_script, 0x26AF);
	ff7_externals.resting_Y_array_data = (short*)get_absolute_value(ff7_externals.battle_move_character_sub_426F58, 0x122);
	ff7_externals.battle_move_character_sub_4270DE = get_absolute_value(ff7_externals.run_animation_script, 0x2357);

	// aura animations (magic, limit breaks, enemy skill and summon)
	ff7_externals.handle_aura_effects_425520 = get_absolute_value(ff7_externals.run_animation_script, 0x3F7A);
	ff7_externals.run_aura_effects_5C0230 = get_relative_call(ff7_externals.handle_aura_effects_425520, 0x42);
	ff7_externals.limit_break_aura_effects_5C0572 = get_absolute_value(ff7_externals.run_aura_effects_5C0230, 0x72);
	ff7_externals.enemy_skill_aura_effects_5C06BF = get_absolute_value(ff7_externals.run_aura_effects_5C0230, 0x7E);
	ff7_externals.handle_summon_aura_5C0850 = get_absolute_value(ff7_externals.run_aura_effects_5C0230, 0x8F);
	ff7_externals.summon_aura_effects_5C0953 = get_absolute_value(ff7_externals.handle_summon_aura_5C0850, 0x31);

	// effect 60 related
	ff7_externals.battle_sub_4276B6 = get_absolute_value(ff7_externals.run_animation_script, 0x3091);
	ff7_externals.battle_sub_4255B7 = get_absolute_value(ff7_externals.run_animation_script, 0x390);
	ff7_externals.battle_sub_5BCF9D = get_absolute_value(ff7_externals.battle_sub_429AC0, 0xDB);
	ff7_externals.battle_sub_5BD050 = get_relative_call(ff7_externals.battle_sub_5BCF9D, 0x95);
	ff7_externals.battle_sub_425AAD = get_absolute_value(ff7_externals.run_animation_script, 0x413);
	ff7_externals.battle_sub_427A6C = ff7_externals.enemy_atk_effects_fn_table[147];
	ff7_externals.battle_sub_427AF1 = get_absolute_value(ff7_externals.battle_sub_427A6C, 0x56);
	ff7_externals.battle_sub_427737 = get_absolute_value(ff7_externals.run_animation_script, 0x3158);
	ff7_externals.battle_sub_4277B1 = get_absolute_value(ff7_externals.run_animation_script, 0x472B);
	ff7_externals.battle_sub_5BCD42 = get_absolute_value(ff7_externals.run_animation_script, 0x66F);
	uint32_t battle_sub_5BE490 = get_relative_call(ff7_externals.run_animation_script, 0x3E6E);
	ff7_externals.battle_smoke_move_handler_5BE4E2 = get_absolute_value(battle_sub_5BE490, 0x5);
	ff7_externals.battle_sub_6CE81E = (void(*)())get_relative_call(ff7_externals.battle_sub_42D808, 0x117);
	ff7_externals.battle_play_sfx_sound_430D32 = (void(*)(uint16_t, short, char))get_relative_call(ff7_externals.battle_sub_427737, 0x35);

	// Limit breaks
	uint32_t battle_sub_4E1627 = get_relative_call(ff7_externals.run_animation_script, 0x3848);
	ff7_externals.run_tifa_limit_effects = get_relative_call(battle_sub_4E1627, 0xD);
	uint32_t tifa_limit_1_2_main_4E2DF3 = get_absolute_value(ff7_externals.run_tifa_limit_effects, 0x47);
	ff7_externals.tifa_limit_1_2_sub_4E3D51 = get_absolute_value(tifa_limit_1_2_main_4E2DF3, 0x4BB);
	uint32_t tifa_limit_2_1_main_4E401E = get_absolute_value(ff7_externals.run_tifa_limit_effects, 0x67);
	ff7_externals.tifa_limit_2_1_sub_4E48D4 = get_absolute_value(tifa_limit_2_1_main_4E401E, 0x41A);
	uint32_t aerith_limit_2_1_main_45AE80 = ff7_externals.limit_break_effects_fn_table[16];
	uint32_t aerith_limit_2_1_sub_45AEA6 = get_relative_call(aerith_limit_2_1_main_45AE80, 0x1A);
	uint32_t aerith_limit_2_1_sub_45AEE8 = get_absolute_value(aerith_limit_2_1_sub_45AEA6, 0xE);
	uint32_t aerith_limit_2_1_sub_45AF39 = get_absolute_value(aerith_limit_2_1_sub_45AEE8, 0x5);
	ff7_externals.aerith_limit_2_1_sub_45B0CF = get_absolute_value(aerith_limit_2_1_sub_45AF39, 0x4A);
	uint32_t cloud_limit_2_2_main_466A31 = ff7_externals.limit_break_effects_fn_table[3];
	uint32_t cloud_limit_2_2_sub_466A57 = get_relative_call(cloud_limit_2_2_main_466A31, 0x1A);
	uint32_t cloud_limit_2_2_sub_466A7A = get_absolute_value(cloud_limit_2_2_sub_466A57, 0x15);
	uint32_t cloud_limit_2_2_sub_466CD2 = get_absolute_value(cloud_limit_2_2_sub_466A7A, 0x185);
	ff7_externals.cloud_limit_2_2_sub_467256 = get_absolute_value(cloud_limit_2_2_sub_466CD2, 0x38C);
	uint32_t aerith_limit_4_1_sub_473A70 = ff7_externals.limit_break_effects_fn_table[20];
	uint32_t aerith_limit_4_1_sub_473B84 = get_relative_call(aerith_limit_4_1_sub_473A70, 0xAA);
	uint32_t aerith_limit_4_1_sub_473C82 = get_relative_call(aerith_limit_4_1_sub_473B84, 0xB7);
	ff7_externals.aerith_limit_4_1_camera_473CC2 = get_absolute_value(aerith_limit_4_1_sub_473C82, 0x5);
	uint32_t vincent_limit_satan_slam_sub_45C0C0 = ff7_externals.limit_break_effects_fn_table[69];
	uint32_t vincent_limit_satan_slam_sub_45C1EA = get_relative_call(vincent_limit_satan_slam_sub_45C0C0, 0x87);
	uint32_t vincen_limit_satan_slam_sub_45C263 = get_absolute_value(vincent_limit_satan_slam_sub_45C1EA, 0x47);
	uint32_t vincent_limit_satan_slam_sub_45CEEA = get_relative_call(vincen_limit_satan_slam_sub_45C263, 0x228);
	ff7_externals.vincent_limit_satan_slam_camera_45CF2A = get_absolute_value(vincent_limit_satan_slam_sub_45CEEA, 0x5);
	uint32_t barret_limit_4_1_sub_468691 = ff7_externals.limit_break_effects_fn_table[13];
	uint32_t barret_limit_4_1_sub_468725 = get_relative_call(barret_limit_4_1_sub_468691, 0x88);
	uint32_t barret_limit_4_1_sub_468862 = get_relative_call(barret_limit_4_1_sub_468725, 0x11B);
	ff7_externals.barret_limit_4_1_camera_4688A2 = get_absolute_value(barret_limit_4_1_sub_468862, 0x5);
	ff7_externals.barret_limit_4_1_model_movement_4698EF = get_absolute_value(barret_limit_4_1_sub_468725, 0x101);
	ff7_externals.barret_limit_4_1_actor_id = (int*)get_absolute_value(ff7_externals.barret_limit_4_1_model_movement_4698EF, 0x82);

	// Summons
	uint32_t battle_sub_5C0E39 = get_relative_call(ff7_externals.battle_sub_427C22, 0x4DE);
	ff7_externals.run_summon_animations_5C0E4B = get_absolute_value(battle_sub_5C0E39, 0x4);
	uint32_t run_chocomog_main_5099D6 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x223);
	uint32_t run_chocomog_sub_507BAD = get_relative_call(run_chocomog_main_5099D6, 0x2E);
	uint32_t run_chocomog_camera_handler_509AD0 = get_relative_call(run_chocomog_sub_507BAD, 0x9C);
	uint32_t run_chocomog_main_loop_50A9E0 = get_absolute_value(run_chocomog_sub_507BAD, 0x74);
	ff7_externals.run_chocomog_movement_50B1A3 = get_absolute_value(run_chocomog_main_loop_50A9E0, 0xD1);
	ff7_externals.run_chocomog_camera_509B10 = get_absolute_value(run_chocomog_camera_handler_509AD0, 0x5);
	uint32_t run_fat_chocobo_main_507B91 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x245);
	uint32_t run_fat_chocobo_sub_507BAD = get_relative_call(run_fat_chocobo_main_507B91, 0x10);
	uint32_t run_fat_chocobo_camera_handler_507C64 = get_relative_call(run_fat_chocobo_sub_507BAD, 0x87);
	uint32_t run_fat_chocobo_main_loop_508BED = get_absolute_value(run_fat_chocobo_sub_507BAD, 0x5F);
	ff7_externals.run_fat_chocobo_movement_509692 = get_absolute_value(run_fat_chocobo_main_loop_508BED, 0x103);
	ff7_externals.run_fat_chocobo_camera_507CA4 = get_absolute_value(run_fat_chocobo_camera_handler_507C64, 0x5);
	ff7_externals.run_fat_chocobo_camera_shake_5095F5 = get_absolute_value(run_fat_chocobo_main_loop_508BED, 0x18D);
	uint32_t run_summon_shiva_main_58E411 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x267);
	uint32_t run_summon_shiva_sub_58E4D8 = get_relative_call(run_summon_shiva_main_58E411, 0xBB);
	uint32_t run_summon_shiva_camera_handler_58E5CD = get_relative_call(run_summon_shiva_sub_58E4D8, 0xBB);
	ff7_externals.run_shiva_movement_592538 = get_absolute_value(run_summon_shiva_sub_58E4D8, 0x7B);
	ff7_externals.run_shiva_camera_58E60D = get_absolute_value(run_summon_shiva_camera_handler_58E5CD, 0x5);
	uint32_t run_ifrit_main_5927C1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x3FC);
	uint32_t run_ifrit_sub_5928FE = get_relative_call(run_ifrit_main_5927C1, 0x12F);
	uint32_t run_ifrit_camera_handler_5929F6 = get_relative_call(run_ifrit_sub_5928FE, 0xC5);
	uint32_t run_ifrit_main_loop_593A95 = get_absolute_value(run_ifrit_sub_5928FE, 0x9D);
	ff7_externals.run_ifrit_movement_596702 = get_absolute_value(run_ifrit_main_loop_593A95, 0x15B);
	ff7_externals.run_ifrit_camera_592A36 = get_absolute_value(run_ifrit_camera_handler_5929F6, 0x5);
	uint32_t run_summon_ramuh_main_596FF1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x311);
	uint32_t run_summon_ramuh_sub_59706F = get_relative_call(run_summon_ramuh_main_596FF1, 0x70);
	uint32_t run_summon_ramuh_sub_5971C6 = get_relative_call(run_summon_ramuh_sub_59706F, 0x13C);
	ff7_externals.run_ramuh_camera_597206 = get_absolute_value(run_summon_ramuh_sub_5971C6, 0x5);
	uint32_t run_titan_main_59B1DA = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x355);
	uint32_t run_titan_sub_59B273 = get_relative_call(run_titan_main_59B1DA, 0x8B);
	uint32_t run_titan_camera_handler_59B470 = get_relative_call(run_titan_sub_59B273, 0x1CA);
	ff7_externals.run_titan_camera_59B4B0 = get_absolute_value(run_titan_camera_handler_59B470, 0x5);
	uint32_t run_summon_odin_gunge_main_4A0AE1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x3DD);
	uint32_t run_summon_odin_gunge_sub_4A0B6D = get_relative_call(run_summon_odin_gunge_main_4A0AE1, 0x7F);
	uint32_t run_summon_odin_gunge_camera_handler_4A0F12 = get_relative_call(run_summon_odin_gunge_sub_4A0B6D, 0x1C0);
	uint32_t run_summon_odin_gunge_main_loop_4A0B6D = get_absolute_value(run_summon_odin_gunge_sub_4A0B6D, 0x163);
	ff7_externals.run_odin_gunge_movement_4A584D = get_absolute_value(run_summon_odin_gunge_main_loop_4A0B6D, 0x152);
	ff7_externals.run_odin_gunge_camera_4A0F52 = get_absolute_value(run_summon_odin_gunge_camera_handler_4A0F12, 0x5);
	uint32_t run_summon_odin_steel_main_4A5B61 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x3BB);
	uint32_t run_summon_odin_steel_sub_4A5BE5 = get_relative_call(run_summon_odin_steel_main_4A5B61, 0x77);
	uint32_t run_summon_odin_steel_main_loop_4A8B86 = get_absolute_value(run_summon_odin_steel_sub_4A5BE5, 0xA7);
	uint32_t run_summon_odin_steel_camera_handler_4A5CFC = get_relative_call(run_summon_odin_steel_sub_4A5BE5, 0xF3);
	ff7_externals.run_odin_steel_movement_4A6CB8 = get_absolute_value(run_summon_odin_steel_sub_4A5BE5, 0xCB);
	ff7_externals.run_odin_steel_sub_4A9908 = get_absolute_value(run_summon_odin_steel_main_loop_4A8B86, 0x43E);
	ff7_externals.run_odin_steel_camera_4A5D3C = get_absolute_value(run_summon_odin_steel_camera_handler_4A5CFC, 0x5);
	ff7_externals.field_odin_frames_AEEC14 = (WORD*)get_absolute_value(ff7_externals.run_odin_steel_sub_4A9908, 0x316);
	uint32_t run_leviathan_main_5B048B = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x333);
	uint32_t run_leviathan_sub_5B055B = get_relative_call(run_leviathan_main_5B048B, 0xC2);
	uint32_t run_leviathan_camera_handler_5B06D6 = get_relative_call(run_leviathan_sub_5B055B, 0x148);
	ff7_externals.run_leviathan_camera_5B0716 = get_absolute_value(run_leviathan_camera_handler_5B06D6, 0x5);
	uint32_t run_bahamut_main_4978B9 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x201);
	uint32_t run_bahamut_sub_497919 = get_relative_call(run_bahamut_main_4978B9, 0x52);
	uint32_t run_bahamut_camera_handler_4979F7 = get_relative_call(run_bahamut_sub_497919, 0xAB);
	ff7_externals.run_bahamut_movement_49ADEC = get_absolute_value(run_bahamut_sub_497919, 0x76);
	ff7_externals.run_bahamut_camera_497A37 = get_absolute_value(run_bahamut_camera_handler_4979F7, 0x5);
	uint32_t run_kujata_main_4F9891 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x2EF);
	uint32_t run_kujata_sub_4F9937 = get_relative_call(run_kujata_main_4F9891, 0x98);
	uint32_t run_kujata_camera_handler_4F9A0D = get_relative_call(run_kujata_sub_4F9937, 0x96);
	ff7_externals.run_kujata_camera_4F9A4D = get_absolute_value(run_kujata_camera_handler_4F9A0D, 0x5);
	uint32_t run_alexander_main_501491 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x2CD);
	uint32_t run_alexander_sub_501514 = get_relative_call(run_alexander_main_501491, 0x73);
	uint32_t run_alexander_camera_handler_5015F7 = get_relative_call(run_alexander_sub_501514, 0xA3);
	uint32_t run_alexander_main_loop_50265E = get_absolute_value(run_alexander_sub_501514, 0xC4);
	ff7_externals.run_alexander_movement_5078D8 = get_absolute_value(run_alexander_main_loop_50265E, 0x2E2);
	ff7_externals.run_alexander_camera_501637 = get_absolute_value(run_alexander_camera_handler_5015F7, 0x5);
	uint32_t run_summon_phoenix_main_515101 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x2AB);
	uint32_t run_summon_phoenix_sub_515127 = get_relative_call(run_summon_phoenix_main_515101, 0x1A);
	uint32_t run_summon_phoenix_camera_handler_5151F8 = get_relative_call(run_summon_phoenix_sub_515127, 0x91);
	ff7_externals.run_phoenix_main_loop_516297 = get_absolute_value(run_summon_phoenix_sub_515127, 0xB2);
	ff7_externals.run_phoenix_movement_518AFF = get_absolute_value(ff7_externals.run_phoenix_main_loop_516297, 0x310);
	ff7_externals.run_phoenix_camera_515238 = get_absolute_value(run_summon_phoenix_camera_handler_5151F8, 0x5);
	ff7_externals.run_bahamut_neo_main_48C2A1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x377);
	uint32_t run_bahamut_neo_sub_48C60B = get_relative_call(ff7_externals.run_bahamut_neo_main_48C2A1, 0x35D);
	uint32_t run_bahamut_neo_camera_handler_48C71D = get_relative_call(run_bahamut_neo_sub_48C60B, 0xD2);
	ff7_externals.run_bahamut_neo_movement_48D7BC = get_absolute_value(run_bahamut_neo_sub_48C60B, 0xAA);
	ff7_externals.run_bahamut_neo_camera_48C75D = get_absolute_value(run_bahamut_neo_camera_handler_48C71D, 0x5);
	uint32_t run_hades_main_4B6351 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x289);
	uint32_t run_hades_sub_4B636D = get_relative_call(run_hades_main_4B6351, 0x10);
	uint32_t run_hades_main_loop_4B636D = get_absolute_value(run_hades_sub_4B636D, 0x4);
	uint32_t run_hades_camera_handler_4B6568 = get_relative_call(run_hades_main_loop_4B636D, 0x1B7);
	ff7_externals.run_hades_camera_4B65A8 = get_absolute_value(run_hades_camera_handler_4B6568, 0x5);
	uint32_t run_typhoon_main_4D5751 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x41B);
	uint32_t run_typhoon_sub_4D57EF = get_relative_call(run_typhoon_main_4D5751, 0x91);
	uint32_t run_typhoon_main_loop_4D69A6 = get_absolute_value(run_typhoon_sub_4D57EF, 0x101);
	uint32_t run_typhoon_camera_handler_4D590C = get_relative_call(run_typhoon_sub_4D57EF, 0xF8);
	ff7_externals.run_typhoon_sub_4DA182 = get_absolute_value(run_typhoon_main_loop_4D69A6, 0x319);
	ff7_externals.run_typhoon_camera_4D594C = get_absolute_value(run_typhoon_camera_handler_4D590C, 0x5);
	uint32_t run_bahamut_zero_main_4835C1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x399);
	uint32_t run_bahamut_zero_sub_483762 = get_relative_call(run_bahamut_zero_main_4835C1, 0x194);
	uint32_t run_bahamut_zero_camera_handler_483826 = get_relative_call(run_bahamut_zero_sub_483762, 0x94);
	ff7_externals.run_bahamut_zero_main_loop_484A16 = get_absolute_value(run_bahamut_zero_sub_483762, 0x5F);
	ff7_externals.run_bahamut_zero_movement_48BBFC = get_absolute_value(run_bahamut_zero_sub_483762, 0x6C);
	ff7_externals.run_bahamut_zero_camera_483866 = get_absolute_value(run_bahamut_zero_camera_handler_483826, 0x5);
	ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA = get_absolute_value(ff7_externals.run_bahamut_zero_main_loop_484A16, 0x2E8);
	ff7_externals.bahamut_zero_bg_star_graphics_data_7F6748 = get_absolute_value(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA, 0x1BC);
	uint32_t run_summon_kotr_main_476842 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x43A);
	ff7_externals.run_summon_kotr_sub_476857 = get_relative_call(run_summon_kotr_main_476842, 0xB);
	ff7_externals.run_summon_kotr_main_loop_478031 = get_absolute_value(ff7_externals.run_summon_kotr_sub_476857, 0x1AC);
	ff7_externals.run_summon_kotr_knight_script[0] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x2D3);
	ff7_externals.run_summon_kotr_knight_script[1] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x341);
	ff7_externals.run_summon_kotr_knight_script[2] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x3EA);
	ff7_externals.run_summon_kotr_knight_script[3] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x475);
	ff7_externals.run_summon_kotr_knight_script[4] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x532);
	ff7_externals.run_summon_kotr_knight_script[5] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x5BA);
	ff7_externals.run_summon_kotr_knight_script[6] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x666);
	ff7_externals.run_summon_kotr_knight_script[7] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x6F3);
	ff7_externals.run_summon_kotr_knight_script[8] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x79D);
	ff7_externals.run_summon_kotr_knight_script[9] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x869);
	ff7_externals.run_summon_kotr_knight_script[10] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x934);
	ff7_externals.run_summon_kotr_knight_script[11] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x9CF);
	ff7_externals.run_summon_kotr_knight_script[12] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0xAB8);
	ff7_externals.add_kotr_camera_fn_to_effect100_fn_476AAB = (void(*)(DWORD, DWORD, WORD))get_relative_call(ff7_externals.run_summon_kotr_sub_476857, 0x1C6);
	ff7_externals.run_kotr_camera_476AFB = get_absolute_value((uint32_t)ff7_externals.add_kotr_camera_fn_to_effect100_fn_476AAB, 0xA);

	ff7_externals.battle_sub_661000 = (vector3<int>*(*)(int))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x38);
	ff7_externals.engine_set_game_engine_rot_matrix_663673 = (void(*)(rotation_matrix*))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x169);
	ff7_externals.engine_set_game_engine_position_663707 = (void(*)(rotation_matrix*))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x176);
	ff7_externals.engine_apply_translation_with_delta_662ECC = (void(*)(vector3<short>*, vector3<int>*, int*))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x193);
	ff7_externals.byte_BCC788 = (byte*)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x1C);
	ff7_externals.ifrit_vector3_int_ptr_BCC6A8 = (vector3<int>**)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x41);
	ff7_externals.battle_ifrit_model_position = (vector3<short>*)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x12D);
	ff7_externals.ifrit_rot_matrix_BCC768 = (rotation_matrix*)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x165);

	// Enemy attacks
	uint32_t battle_sub_5C1484 = ff7_externals.magic_effects_fn_table[7];
	uint32_t battle_sub_55FE60 = get_relative_call(battle_sub_5C1484, 0x33E);
	uint32_t battle_handle_chocobuckle_and_confu_sub_55FE9C = get_relative_call(battle_sub_55FE60, 0x12);
	uint32_t handler_chocobuckle_sub_5609DB = get_absolute_value(battle_handle_chocobuckle_and_confu_sub_55FE9C, 0x27);
	uint32_t handler_confu_magic_sub_55FEF2 = get_absolute_value(battle_handle_chocobuckle_and_confu_sub_55FE9C, 0x36);
	ff7_externals.run_chocobuckle_main_loop_560C32 = get_absolute_value(handler_chocobuckle_sub_5609DB, 0x6F);
	ff7_externals.run_confu_main_loop_5600BE = get_absolute_value(handler_confu_magic_sub_55FEF2, 0x6C);
	uint32_t battle_escape_magic_entrypoint_5D5720 = ff7_externals.magic_effects_fn_table[25];
	uint32_t battle_escape_magic_sub_5D573F = get_relative_call(battle_escape_magic_entrypoint_5D5720, 0x15);
	ff7_externals.battle_escape_magic_init_data_5D59B0 = get_relative_call(battle_escape_magic_sub_5D573F, 0x6);
	ff7_externals.battle_escape_magic_loop_5D602A = get_absolute_value(battle_escape_magic_sub_5D573F, 0x11);
	uint32_t bomb_blast_effects_5373D0 = ff7_externals.enemy_atk_effects_fn_table[67];
	uint32_t bomb_blast_effects_sub_5373E5 = get_relative_call(bomb_blast_effects_5373D0, 0xB);
	ff7_externals.bomb_blast_black_bg_effect_537427 = get_absolute_value(bomb_blast_effects_sub_5373E5, 0x34);
	uint32_t goblin_punch_effects_572C20 = ff7_externals.enemy_skill_effects_fn_table[17];
	uint32_t goblin_punch_effects_sub_572C3A = get_relative_call(goblin_punch_effects_572C20, 0x10);
	uint32_t goblin_punch_handler_572CE0 = get_absolute_value(goblin_punch_effects_sub_572C3A, 0x70);
	uint32_t goblin_punch_main_loop_572DE7 = get_absolute_value(goblin_punch_handler_572CE0, 0x21);
	ff7_externals.goblin_punch_flash_573291 = get_absolute_value(goblin_punch_main_loop_572DE7, 0x4B);
	uint32_t death_sentence_sub_565F50 = get_relative_call(battle_sub_5C1484, 0x15F);
	uint32_t death_sentence_sub_565F9C = get_relative_call(death_sentence_sub_565F50, 0x1A);
	uint32_t death_sentence_handler_566007 = get_absolute_value(death_sentence_sub_565F9C, 0x5B);
	ff7_externals.roulette_skill_main_loop_566287 = get_absolute_value(death_sentence_handler_566007, 0x2E);
	ff7_externals.death_sentence_main_loop_5661A0 = get_absolute_value(death_sentence_handler_566007, 0x138);
	uint32_t battle_sub_561C20 = get_relative_call(battle_sub_5C1484, 0x97);
	uint32_t death_kill_sub_561C3C = get_relative_call(battle_sub_561C20, 0x10);
	uint32_t death_kill_sub_561C87 = get_absolute_value(death_kill_sub_561C3C, 0x21);
	uint32_t death_kill_main_loop_561FAF = get_absolute_value(death_kill_sub_561C87, 0x93);
	ff7_externals.death_kill_sub_loop_562C60 = get_absolute_value(death_kill_main_loop_561FAF, 0x42);
	ff7_externals.death_kill_sub_loop_5624A5 = get_absolute_value(death_kill_main_loop_561FAF, 0x5F);
	uint32_t enemy_atk_sub_439B71 = ff7_externals.enemy_atk_effects_fn_table[143];
	uint32_t enemy_atk_sub_439B86 = get_relative_call(enemy_atk_sub_439B71, 0xB);
	uint32_t enemy_atk_sub_439C6B = get_absolute_value(enemy_atk_sub_439B86, 0x1C);
	uint32_t enemy_atk_sub_439EA0 = get_relative_call(enemy_atk_sub_439C6B, 0x214);
	ff7_externals.enemy_atk_camera_sub_439EE0 = get_absolute_value(enemy_atk_sub_439EA0, 0x5);
	uint32_t enemy_atk_sub_44A5A0 = ff7_externals.enemy_atk_effects_fn_table[150];
	uint32_t enemy_atk_sub_44A719 = get_relative_call(enemy_atk_sub_44A5A0, 0xB0);
	uint32_t enemy_atk_sub_44A792 = get_relative_call(enemy_atk_sub_44A719, 0x41);
	ff7_externals.enemy_atk_camera_sub_44A7D2 = get_absolute_value(enemy_atk_sub_44A792, 0x5);
	uint32_t enemy_atk_sub_44ECB1 = ff7_externals.enemy_atk_effects_fn_table[149];
	uint32_t enemy_atk_sub_44ED00 = get_relative_call(enemy_atk_sub_44ECB1, 0x44);
	uint32_t enemy_atk_sub_44ED80 = get_relative_call(enemy_atk_sub_44ED00, 0x48);
	ff7_externals.enemy_atk_camera_sub_44EDC0 = get_absolute_value(enemy_atk_sub_44ED80, 0x5);
	uint32_t enemy_atk_sub_427A6C = ff7_externals.enemy_atk_effects_fn_table[147];
	uint32_t enemy_atk_sub_4520C1 = get_relative_call(enemy_atk_sub_427A6C, 0x4D);
	uint32_t enemy_atk_sub_452170 = get_relative_call(enemy_atk_sub_4520C1, 0xA3);
	uint32_t enemy_atk_sub_45226D = get_relative_call(enemy_atk_sub_452170, 0xDC);
	ff7_externals.enemy_atk_camera_sub_4522AD = get_absolute_value(enemy_atk_sub_45226D, 0x5);
	uint32_t enemy_atk_sub_457B20 = ff7_externals.enemy_atk_effects_fn_table[142];
	uint32_t enemy_atk_sub_457B4C = get_relative_call(enemy_atk_sub_457B20, 0x22);
	uint32_t enemy_atk_sub_457C20 = get_relative_call(enemy_atk_sub_457B4C, 0xB4);
	ff7_externals.enemy_atk_camera_sub_457C60 = get_absolute_value(enemy_atk_sub_457C20, 0x5);
	ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0 = ff7_externals.enemy_atk_effects_fn_table[59];
	uint32_t pollensalta_cold_breath_atk_main_sub_547595 = get_relative_call(ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0, 0x99);
	uint32_t pollensalta_cold_breath_atk_callback_sub_5455E7 = get_absolute_value(pollensalta_cold_breath_atk_main_sub_547595, 0x4);
	ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0 = get_absolute_value(pollensalta_cold_breath_atk_callback_sub_5455E7, 0x7);
	ff7_externals.pollensalta_cold_breath_atk_draw_bg_effect_547B94 = get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0, 0x16F);
	ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56 = get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0, 0x39);
	ff7_externals.pollensalta_cold_breath_atk_draw_white_dots_547E75 = (void(*)(short))get_relative_call(ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56, 0x20);
	ff7_externals.pollensalta_cold_breath_white_dots_pos = std::span((vector4<short>*) get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56, 0x79), 400);
	ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar = (short*) get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56, 0x1B);
	ff7_externals.pollensalta_cold_breath_bg_texture_ctx = get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_draw_bg_effect_547B94, 0x2A);
	uint32_t pandora_box_skill_enter_5667E1 = ff7_externals.enemy_skill_effects_fn_table[23];
	uint32_t pandora_box_skill_main_566806 = get_relative_call(pandora_box_skill_enter_5667E1, 0x1A);
	uint32_t pandora_box_skill_sub_566871 = get_absolute_value(pandora_box_skill_main_566806, 0x30);
	uint32_t pandora_box_skill_main_loop_566E61 = get_absolute_value(pandora_box_skill_sub_566871, 0x1F);
	ff7_externals.pandora_box_skill_draw_bg_flash_effect_568371 = get_absolute_value(pandora_box_skill_main_loop_566E61, 0x162);

	// Texture/Material animation
	uint32_t battle_leviathan_sub_5B2F18 = get_absolute_value(ff7_externals.battle_summon_leviathan_loop, 0x50E);
	ff7_externals.battle_animate_material_texture = get_relative_call(battle_leviathan_sub_5B2F18, 0x19F);
	ff7_externals.get_global_model_matrix_buffer_66100D = (rotation_matrix*(*)())get_relative_call(ff7_externals.battle_animate_material_texture, 0x5E);
	ff7_externals.get_draw_chain_68F860 = (struc_84*(*)(struc_49*, graphics_instance*))get_relative_call(ff7_externals.battle_animate_material_texture, 0x85);
	ff7_externals.battle_sub_5D1AAA = (p_hundred*(*)(int, ff7_polygon_set*))get_relative_call(ff7_externals.battle_animate_material_texture, 0xB3);
	ff7_externals.get_alpha_from_transparency_429343 = (int(*)(int))get_relative_call(ff7_externals.battle_animate_material_texture, 0xDF);
	ff7_externals.get_stored_color_66101A = (color_ui8(*)())get_relative_call(ff7_externals.battle_animate_material_texture, 0x110);
	ff7_externals.battle_sub_68CF75 = (void(*)(char, struc_173*))get_relative_call(ff7_externals.battle_animate_material_texture, 0x1CD);
	ff7_externals.create_rot_matrix_from_word_matrix_6617E9 = (void(*)(rotation_matrix*, matrix*))get_relative_call(ff7_externals.battle_animate_material_texture, 0x38B);
	ff7_externals.battle_animate_texture_spt = get_relative_call(ff7_externals.summon_aura_effects_5C0953, 0x16A);
	ff7_externals.get_draw_chain_671C71 = (struc_84*(*)(ff7_graphics_object*))get_relative_call(ff7_externals.battle_animate_texture_spt, 0x15F);
	ff7_externals.palette_extra_data_C06A00 = (palette_extra*)get_absolute_value(ff7_externals.battle_animate_material_texture, 0x2FA);
	ff7_externals.global_game_engine_data = (ff7_game_engine_data**)get_absolute_value((uint32_t)ff7_externals.get_global_model_matrix_buffer_66100D, 0x4);

	// Battle menu
	uint32_t battle_sub_6D83C8 = get_relative_call(ff7_externals.battle_menu_update_6CE8B3, 0x77);
	uint32_t battle_sub_6D82EA = get_relative_call(battle_sub_6D83C8, 0xE0);
	ff7_externals.display_battle_menu_6D797C = get_relative_call(battle_sub_6D82EA, 0x59);
	ff7_externals.display_tifa_slots_handler_6E3135 = (void(*)())get_relative_call(ff7_externals.display_battle_menu_6D797C, 0x1C2);
	ff7_externals.battle_draw_text_ui_graphics_objects_call = battle_main_loop + 0x289;
	ff7_externals.battle_draw_box_ui_graphics_objects_call = battle_main_loop + 0x2CF;
	ff7_externals.battle_draw_call_42908C = (void(*)(int, int))get_relative_call(battle_main_loop, 0x2CF);
	ff7_externals.battle_set_do_render_menu_call = battle_main_loop + 0x32A;
	ff7_externals.battle_set_do_render_menu = get_relative_call(battle_main_loop, 0x32A);
	ff7_externals.g_do_render_menu = (int*)get_absolute_value(ff7_externals.battle_set_do_render_menu, 0x7);
	uint32_t battle_sub_4297B9 = get_relative_call(ff7_externals.battle_sub_42D992, 0x59);
	uint32_t battle_sub_42952E = get_relative_call(battle_sub_4297B9, 0x10);
	ff7_externals.battle_sub_42F3E8 = get_relative_call(battle_sub_42952E, 0xCD);
	uint32_t battle_sub_5B9B30 = get_relative_call(ff7_externals.battle_sub_42F3E8, 0x756);
	ff7_externals.battle_handle_status_effect_anim_5BA7C0 = get_relative_call(battle_sub_5B9B30, 0xB2);
	ff7_externals.battle_handle_player_mark_5B9C8E = get_relative_call(battle_sub_5B9B30, 0x123);
	ff7_externals.battle_update_targeting_info_6E6291 = get_relative_call(ff7_externals.battle_sub_6DB0EE, 0x1F9);
	ff7_externals.targeting_actor_id_DC3C98 = (byte*)get_absolute_value(ff7_externals.battle_update_targeting_info_6E6291, 0x684);
	ff7_externals.battle_menu_closing_window_box_6DAEF0 = get_relative_call(ff7_externals.battle_sub_6DB0EE, 0x1D8);

	// 3D Battleground
	ff7_externals.update_3d_battleground = get_relative_call(ff7_externals.battle_sub_42D992, 0x4);
	ff7_externals.battleground_shake_train_42F088 = (void(*)())get_relative_call(ff7_externals.update_3d_battleground, 0xBF);
	ff7_externals.battleground_vertical_scrolling_42F126 = get_relative_call(ff7_externals.update_3d_battleground, 0x783);
	ff7_externals.battleground_midgar_flashback_rain_5BDC4F = get_relative_call(ff7_externals.update_3d_battleground, 0x3C);

	// World externals
	ff7_externals.world_dword_DE68FC = (void(**)())get_absolute_value(ff7_externals.world_loop_74BE49, 0x123);
	ff7_externals.world_exit_74BD77 = get_absolute_value(main_loop, 0x993);
	ff7_externals.world_exit_destroy_graphics_objects_75A921 = (void(*)())get_relative_call(ff7_externals.world_exit_74BD77, 0x11);
	ff7_externals.world_init_variables_74E1E9 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x108);
	ff7_externals.world_sub_7641A7 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x210);
	ff7_externals.world_init_load_wm_bot_block_7533AF = (void(*)())get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x296);
	ff7_externals.run_world_event_scripts = get_relative_call(ff7_externals.world_sub_7641A7, 0x1D);
	ff7_externals.run_world_event_scripts_system_operations = get_relative_call(ff7_externals.run_world_event_scripts, 0xC7);
	ff7_externals.pop_world_script_stack = (int(*)())get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0x44);
	ff7_externals.world_animate_all_models = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5A1);
	ff7_externals.world_animate_single_model = get_relative_call(ff7_externals.world_animate_all_models, 0x20);
	ff7_externals.run_world_snake_ai_script_7562FF = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5AB);
	ff7_externals.world_sub_75EF46 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x44E);
	ff7_externals.world_sub_767540 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5BE);
	ff7_externals.world_sub_767641 = get_relative_call(ff7_externals.world_sub_767540, 0xCB);
	ff7_externals.get_world_encounter_rate = (int(*)())get_relative_call(ff7_externals.world_sub_767641, 0x110);
	ff7_externals.update_world_snake_position_7564CD = get_relative_call(ff7_externals.run_world_snake_ai_script_7562FF, 0x151);
	ff7_externals.is_update_snake_enabled_7562A9 = get_relative_call(ff7_externals.run_world_snake_ai_script_7562FF, 0x12);
	ff7_externals.animate_world_snake_75692A = get_relative_call(ff7_externals.run_world_snake_ai_script_7562FF, 0x16C);
	ff7_externals.sub_753366 = (bool (*)(short, short))get_relative_call(ff7_externals.animate_world_snake_75692A, 0x93);
	ff7_externals.world_draw_snake_texture_75D544 = (void (*)(short, short, short, short, world_snake_graphics_data*, short))get_relative_call(ff7_externals.animate_world_snake_75692A, 0x159);
	ff7_externals.world_snake_data_position_ptr_E2A18C = (vector4<short> **)get_absolute_value(ff7_externals.update_world_snake_position_7564CD, 0x2F);
	ff7_externals.world_snake_data_position_E29F80 = (vector4<short> *)get_absolute_value((uint32_t)ff7_externals.animate_world_snake_75692A, 0x2A);
	ff7_externals.world_snake_graphics_data_E2A490 = (world_snake_graphics_data *)get_absolute_value(ff7_externals.animate_world_snake_75692A, 0x3A);
	ff7_externals.world_snake_graphics_data_end_E2A6D0 = (world_snake_graphics_data *)get_absolute_value(ff7_externals.animate_world_snake_75692A, 0x4C);
	ff7_externals.snake_position_size_of_array_E2A100 = (vector4<short> *)get_absolute_value(ff7_externals.update_world_snake_position_7564CD, 0x3C);
	ff7_externals.world_opcode_message_sub_75EE86 = get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0xB6D);
	ff7_externals.world_opcode_ask_sub_75EEBB = get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0xBA1);
	ff7_externals.world_opcode_message = get_relative_call(ff7_externals.world_sub_75EF46, 0x8C);
	ff7_externals.world_opcode_ask = get_relative_call(ff7_externals.world_sub_75EF46, 0xAF);
	ff7_externals.world_text_box_window_opening_769A66 = get_relative_call(ff7_externals.world_opcode_message, 0x5A);
	ff7_externals.world_text_box_window_paging_769C02 = get_relative_call(ff7_externals.world_opcode_message, 0x6D);
	ff7_externals.world_text_box_reverse_paging_76ABE9 = get_relative_call(ff7_externals.world_opcode_message, 0x80);
	ff7_externals.world_text_box_window_closing_76ADF7 = get_relative_call(ff7_externals.world_opcode_message, 0x235);
	ff7_externals.world_update_player_74EA48 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x2D7);
	ff7_externals.world_get_player_model_id = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x1B);
	ff7_externals.world_get_current_key_input_status = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x4A);
	ff7_externals.world_get_player_walkmap_type = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x7DF);
	ff7_externals.world_get_player_walkmap_region = (int(*)())get_relative_call(ff7_externals.world_sub_767641, 0x2B);
	ff7_externals.world_sub_753D00 = (void(*)(vector3<short>*, short))get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0xDF9);
	ff7_externals.world_update_model_movement_762E87 = (void(*)(int, int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xCDF);
	ff7_externals.engine_apply_rotation_to_transform_matrix_6628DE = (void(*)(vector3<short>*, rotation_matrix*))get_relative_call(ff7_externals.world_update_player_74EA48, 0x733);
	ff7_externals.world_is_player_model_bitmask = (bool(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x9F);
	ff7_externals.world_copy_player_pos_to_param_762798 = (void(*)(vector4<int>*))get_relative_call(ff7_externals.world_update_player_74EA48, 0x7B8);
	ff7_externals.world_set_current_entity_to_player_entity = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x16);
	ff7_externals.world_add_y_pos_to_current_entity_761F22 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x7FD);
	ff7_externals.world_add_delta_movement_due_to_bridge_7591C2 = (void(*)(int*, int*))get_relative_call(ff7_externals.world_update_player_74EA48, 0xCAA);
	ff7_externals.world_current_entity_model_collision_detection_with_other_models_76296E = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xCE7);
	ff7_externals.world_get_unknown_flag_75335C = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x3D);
	ff7_externals.world_get_minimap_mask = (short(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xBC8);
	ff7_externals.world_set_minimap_mask = (void(*)(short))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC00);
	ff7_externals.world_set_facing_and_direction_to_current_entity = (void(*)(short))get_relative_call(ff7_externals.world_update_player_74EA48, 0x6F3);
	ff7_externals.world_is_current_entity_animated_761F44 = (bool(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x8D0);
	ff7_externals.world_sub_74D6BB = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xB71);
	ff7_externals.world_sub_74D6F6 = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xB82);
	ff7_externals.world_sub_762F75 = (void(*)(short, short, short))get_relative_call(ff7_externals.world_update_player_74EA48, 0x9A3);
	ff7_externals.world_run_special_opcode_7640BC = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC30);
	ff7_externals.world_set_camera_fade_speed_755B97 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC56);
	ff7_externals.world_set_world_control_lock_74D438 = (void(*)(int, int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC62);
	ff7_externals.world_sub_74C980 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC76);
	ff7_externals.world_sub_753BE8 = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xC8A);
	ff7_externals.world_music_set_frequency_all_channels_75E6A8 = (void(*)(byte, char))get_relative_call(ff7_externals.world_update_player_74EA48, 0xB05);
	ff7_externals.world_sfx_play_or_stop_75E6CC = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xCCF);
	ff7_externals.world_set_camera_view_type_74D3D1 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x79);

	ff7_externals.world_compute_all_models_data_76323A = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5A1);
	ff7_externals.world_compute_3d_model_data_76328F = get_relative_call(ff7_externals.world_compute_all_models_data_76323A, 0x20);
	ff7_externals.world_sub_74D319 = get_relative_call(ff7_externals.world_compute_3d_model_data_76328F, 0x7D4);
	ff7_externals.world_sub_762F9A = get_relative_call(ff7_externals.world_compute_3d_model_data_76328F, 0x419);

	ff7_externals.world_update_camera_74E8CE = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x40F);
	ff7_externals.world_snowstorm_get_camera_movement_758B12 = (int(*)(int, int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x38C);
	ff7_externals.world_get_camera_rotation_x_74F916 = (int(*)())get_relative_call(ff7_externals.world_update_camera_74E8CE, 0x6);
	ff7_externals.world_highwind_height_lowerbound_DF5420 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x7EE);
	ff7_externals.world_mode_E045E4 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xC21);
	ff7_externals.previous_player_direction_DF5434 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xA5B);
	ff7_externals.world_is_control_enabled_DE6B5C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x25);
	ff7_externals.world_special_delta_movement_DE6A18 = (short*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x5D6);
	ff7_externals.world_y_player_pos_flag_DE6A14 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x875);
	ff7_externals.world_unk_rotation_value_E045E0 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x972);
	ff7_externals.world_event_current_entity_ptr_E39AD8 = (world_event_data**)get_absolute_value((uint32_t)ff7_externals.world_update_model_movement_762E87, 0x5);
	ff7_externals.world_event_current_entity_ptr_E3A7CC = (world_event_data**)get_absolute_value(ff7_externals.run_world_event_scripts_system_operations, 0x8E6);
	ff7_externals.world_progress_E28CB4 = (int*)get_absolute_value((uint32_t)ff7_externals.world_init_load_wm_bot_block_7533AF, 0xA1);
	ff7_externals.is_wait_frames_zero_E39BC0 = (int*)get_absolute_value(ff7_externals.run_world_event_scripts_system_operations, 0xD46);
	ff7_externals.world_prev_key_input_status_DFC470 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x35A);
	ff7_externals.world_map_type_E045E8 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x66);
	ff7_externals.world_movement_multiplier_DFC480 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xDA);
	ff7_externals.world_camera_var1_DF542C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x1BD);
	ff7_externals.world_camera_var2_DE6B4C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xD2F);
	ff7_externals.world_camera_var3_DE6A0C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x179);
	ff7_externals.world_camera_viewtype_DFC4B4 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x54);
	ff7_externals.world_camera_front_DFC484 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x39E);
	ff7_externals.world_camera_rotation_y_DFC474 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xD51);
	ff7_externals.world_camera_position_z_DFC478 = (int*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x79);
	ff7_externals.world_camera_delta_y_DE6A04 = (int*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0xAB);
	ff7_externals.world_current_camera_rotation_x_DE7418 = (short*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x117);
	ff7_externals.world_camera_rotation_z_DE6B70 = (int*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x149);
	ff7_externals.world_camera_x_rotation_array_E37120 = std::span((short*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x103), 512);
	ff7_externals.world_camera_position_matrix_DE6A20 = (rotation_matrix*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0xBF);
	ff7_externals.world_camera_direction_matrix_DFC448 = (rotation_matrix*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x162);
	ff7_externals.world_sub_75A1C6 = get_relative_call(ff7_externals.world_init_variables_74E1E9, 0x3A);
	ff7_externals.world_load_graphics_objects_75A5D5 = get_relative_call(ff7_externals.world_sub_75A1C6, 0x61);
	ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 = get_relative_call(ff7_externals.world_load_graphics_objects_75A5D5, 0x340);
	ff7_externals.world_wm0_overworld_draw_all_74C179 = (void(*)())get_absolute_value(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283, 0xA7);
	ff7_externals.world_wm2_underwater_draw_all_74C3F0 = (void(*)())get_absolute_value(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283, 0xDF);
	ff7_externals.world_wm3_snowstorm_draw_all_74C589 = (void(*)())get_absolute_value(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283, 0x117);
	ff7_externals.world_draw_all_3d_model_74C6B0 =  get_relative_call((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179, 0x155);
	ff7_externals.world_draw_fade_quad_75551A = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x554);
	ff7_externals.world_sub_75079D = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x421);
	ff7_externals.world_sub_751EFC = get_relative_call(ff7_externals.world_sub_75079D, 0x1FB);
	ff7_externals.world_sub_75C02B = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5A6);
	ff7_externals.world_sub_75C0FD = get_relative_call(ff7_externals.world_sub_75C02B, 0x43);
	ff7_externals.world_sub_75C283 = get_relative_call(ff7_externals.world_sub_75C0FD, 0x175);
	ff7_externals.world_culling_bg_meshes_75F263 = get_relative_call(ff7_externals.world_sub_751EFC, 0x7C6);
	ff7_externals.world_submit_draw_bg_meshes_75F68C = get_relative_call(ff7_externals.world_sub_751EFC, 0x7FD);
	ff7_externals.world_compute_skybox_data_754100 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x537);
	ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x547);
	ff7_externals.world_sub_75F0AD = get_relative_call(ff7_externals.world_sub_751EFC, 0x551);
	ff7_externals.world_sub_75042B = get_relative_call(ff7_externals.world_compute_3d_model_data_76328F, 0x37D);
	ff7_externals.world_player_pos_E04918 = (vector4<int>*)get_absolute_value(ff7_externals.world_sub_75042B, 0xE);
		ff7_externals.sub_74C9A5 = (int (*)())get_relative_call(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6, 0x09);
	ff7_externals.is_meteor_flag_on_E2AAE4 = (int*)get_absolute_value(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6, 0x592);
	ff7_externals.engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF = get_relative_call(ff7_externals.world_compute_skybox_data_754100, 0x85);
	ff7_externals.engine_apply_4x4_matrix_product_between_matrices_66C6CD = (void (*)(struct matrix *, struct matrix *, struct matrix *))get_relative_call(ff7_externals.engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF, 0x16);
	ff7_externals.world_copy_position_75042B = (void (*)(vector4<int>* a1))get_relative_call(ff7_externals.world_sub_75C0FD, 0x52);
	ff7_externals.get_world_camera_front_rot_74D298 = (int (*)())get_relative_call(ff7_externals.world_sub_75C0FD, 0xF);
	ff7_externals.engine_apply_rotation_to_rot_matrix_662AD8 = (void (*)(vector3<short>*, transform_matrix*))get_relative_call(ff7_externals.world_sub_75C0FD, 0x28);
	ff7_externals.world_get_world_current_camera_rotation_x_74D3C6 = (short (*)())get_relative_call(ff7_externals.world_sub_75C0FD, 0x30);
	ff7_externals.world_submit_draw_effects_75C283 = (int (_stdcall *)(world_texture_data *, int, vector3<short>*, short))get_relative_call(ff7_externals.world_sub_75C0FD, 0x175);
	ff7_externals.dword_E35648 = (world_effect_2d_list_node**)get_absolute_value(ff7_externals.world_sub_75C0FD, 0x5B);
	ff7_externals.byte_96D6A8 = (byte*)get_absolute_value(ff7_externals.world_sub_75C0FD, 0x169);

	// Swirl externals
	ff7_externals.swirl_main_loop = swirl_main_loop;
	ff7_externals.swirl_loop_sub_4026D4 = get_relative_call(swirl_main_loop, 0xC9);
	ff7_externals.swirl_enter_40164E = get_absolute_value(main_loop, 0x254);
	ff7_externals.swirl_enter_sub_401810 = get_relative_call(ff7_externals.swirl_enter_40164E, 0x160);

	// --------------------------------

	// battle dialogues
	ff7_externals.add_text_to_display_queue = get_relative_call(ff7_externals.battle_sub_42CBF9, 0x1C7);
	ff7_externals.update_display_text_queue = get_relative_call(ff7_externals.battle_sub_42D808, 0x2B);
	ff7_externals.set_battle_text_active = get_relative_call(ff7_externals.update_display_text_queue, 0x14A);
	ff7_externals.battle_sfx_play_effect_430D14 = get_relative_call(ff7_externals.update_display_text_queue, 0x46);
	ff7_externals.battle_sub_66C3BF = (int(*)())get_relative_call(ff7_externals.update_display_text_queue, 0x139);
	ff7_externals.battle_sub_43526A = get_relative_call(ff7_externals.battle_loop, 0x475);
	ff7_externals.battle_sub_5C8931 = get_relative_call(ff7_externals.battle_sub_43526A, 0x1F0);
	ff7_externals.run_enemy_ai_script = get_relative_call(ff7_externals.battle_sub_5C8931, 0xA0);
	ff7_externals.enqueue_script_action = get_relative_call(ff7_externals.run_enemy_ai_script, 0xB7F);
	ff7_externals.battle_sub_41B577 = get_relative_call(ff7_externals.battle_enter, 0x17);
	ff7_externals.battle_sub_41CCB2 = get_relative_call(ff7_externals.battle_sub_41B577, 0xB);

	ff7_externals.battle_display_text_queue = std::span((battle_text_data*)get_absolute_value(ff7_externals.add_text_to_display_queue, 0x25), 64);
	ff7_externals.battle_context = (battle_ai_context*)get_absolute_value(ff7_externals.battle_sub_41CCB2, 0x5F);
	ff7_externals.anim_event_queue = std::span((battle_anim_event*)get_absolute_value(ff7_externals.battle_sub_42CBF9, 0x23), 64);
	ff7_externals.anim_event_index = (byte*)get_absolute_value(ff7_externals.battle_sub_42CBF9, 0x19);
	ff7_externals.g_is_battle_running_9AD1AC = (int*)get_absolute_value(battle_main_loop, 0x247);
	ff7_externals.field_battle_word_BF2E08 = (WORD*)get_absolute_value(ff7_externals.update_display_text_queue, 0xA);
	ff7_externals.field_battle_word_BF2032 = (WORD*)get_absolute_value(ff7_externals.update_display_text_queue, 0x12C);
	ff7_externals.g_active_actor_id = (byte*)get_absolute_value(ff7_externals.display_battle_action_text_42782A, 0x52);
	// --------------------------------

	// Widescreen
	ff7_externals.field_culling_model_639252 = get_relative_call(ff7_externals.field_animate_3d_models_6392BB, 0x203);
	ff7_externals.field_sub_63AC66 = get_relative_call(ff7_externals.sub_60DF96, 0xB0);
	ff7_externals.field_sub_63AC3F = (void(*)(int, int, int, int))get_relative_call(ff7_externals.field_sub_63AC66, 0xD5);

	ff7_externals.battle_draw_quad_5BD473 = get_relative_call(ff7_externals.battle_boss_death_call_5BD436, 0x16);
	ff7_externals.battle_sub_5895E0 = ff7_externals.enemy_atk_effects_fn_table[119];
	ff7_externals.battle_sub_589827 = get_relative_call(ff7_externals.battle_sub_5895E0, 0x10D);
	ff7_externals.battle_sub_58AC59 = get_absolute_value(ff7_externals.battle_sub_589827, 0x64);
	ff7_externals.battle_sub_58ACB9 = get_relative_call(ff7_externals.battle_sub_58AC59, 0x22);
	ff7_externals.ifrit_sub_595A05 = get_absolute_value(run_ifrit_main_loop_593A95, 0x51B);
	ff7_externals.engine_draw_sub_66A47E = (void(*)(int))get_relative_call(ff7_externals.ifrit_sub_595A05, 0x930);
	ff7_externals.battle_viewport_height = (int*)get_absolute_value(battle_main_loop, 0x151);
	ff7_externals.neo_bahamut_main_loop_48DA7A = get_absolute_value(run_bahamut_neo_sub_48C60B, 0xF3);
	ff7_externals.neo_bahamut_effect_sub_490F2A = get_absolute_value(ff7_externals.neo_bahamut_main_loop_48DA7A, 0x2CD);
	ff7_externals.odin_gunge_effect_sub_4A4BE6 = get_absolute_value(run_summon_odin_gunge_main_loop_4A0B6D, 0xA7);
	ff7_externals.odin_gunge_effect_sub_4A3A2E = get_absolute_value(run_summon_odin_gunge_main_loop_4A0B6D, 0x2D8);
	ff7_externals.typhoon_sub_4D6FF8 = get_relative_call(run_typhoon_main_loop_4D69A6, 0x4B7);
	ff7_externals.typhoon_effect_sub_4D7044 = get_absolute_value(ff7_externals.typhoon_sub_4D6FF8, 0xF);
	ff7_externals.typhoon_effect_sub_4DB15F = get_absolute_value(run_typhoon_main_loop_4D69A6, 0x416);
	ff7_externals.fat_chocobo_sub_5096F3 = get_absolute_value(run_fat_chocobo_main_loop_508BED, 0x110);
	uint32_t barret_limit_3_1_main_46FF90 = ff7_externals.limit_break_effects_fn_table[11];
	uint32_t barret_limit_3_1_sub_46FFAC = get_relative_call(barret_limit_3_1_main_46FF90, 0x10);
	uint32_t barret_limit_3_1_sub_470031 = get_absolute_value(barret_limit_3_1_sub_46FFAC, 0x44);
	ff7_externals.barret_limit_3_1_sub_4700F7 = get_absolute_value(barret_limit_3_1_sub_470031, 0x36);
	uint32_t shadow_flare_enemy_skill_entry_576FD0 = ff7_externals.enemy_skill_effects_fn_table[22];
	uint32_t shadow_flare_enemy_skill_sub_576FEA = get_relative_call(shadow_flare_enemy_skill_entry_576FD0, 0x10);
	uint32_t shadow_flare_enemy_skill_main_loop_57708E = get_absolute_value(shadow_flare_enemy_skill_sub_576FEA, 0x70);
	ff7_externals.shadow_flare_draw_white_bg_57747E = get_relative_call(shadow_flare_enemy_skill_main_loop_57708E, 0x6C);

	ff7_externals.cdcheck_enter_sub = get_absolute_value(main_loop, 0x390);
	ff7_externals.credits_submit_draw_fade_quad_7AA89B = get_relative_call(credits_main_loop, 0xD9);
	ff7_externals.get_button_pressed = (int(*)(int))get_relative_call(credits_main_loop, 0x14C);
	ff7_externals.credits_main_loop = credits_main_loop;
	ff7_externals.menu_submit_draw_fade_quad_6CD64E = get_relative_call(ff7_externals.menu_battle_end_sub_6C9543, 0x104);
	ff7_externals.highway_submit_fade_quad_659532 = get_relative_call(ff7_externals.highway_loop_sub_650F36, 0x126);
	ff7_externals.chocobo_init_viewport_values_76D320 = get_relative_call(main_init_loop, 0x38B);
	uint32_t chocobo_sub_77C462 = get_relative_call(chocobo_main_loop, 0x5E);
	uint32_t chocobo_sub_77946A = get_relative_call(chocobo_sub_77C462, 0x649);
	ff7_externals.chocobo_submit_draw_fade_quad_77B1CE = get_relative_call(chocobo_sub_77946A, 0x33);
	ff7_externals.chocobo_submit_draw_water_quad_77A7D0 = get_relative_call(chocobo_sub_77C462, 0x30B);
	ff7_externals.generic_submit_quad_graphics_object_671D2A = (void(*)(int, int, int, int, int, int, float, DWORD*))get_relative_call(ff7_externals.chocobo_submit_draw_water_quad_77A7D0, 0x9F);
	ff7_externals.chocobo_fade_quad_data_97A498 = (byte*)get_absolute_value(chocobo_sub_77946A, 0x2F);
	ff7_externals.snowboard_draw_sky_and_mountains_72DAF0 = get_relative_call(ff7_externals.snowboard_loop_sub_72381C, 0x27);
	ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F = get_relative_call(ff7_externals.snowboard_draw_sky_and_mountains_72DAF0, 0x24D);
	ff7_externals.snowboard_sky_quad_pos_x_7B7DB8 = (float*)get_absolute_value(ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F, 0x2E);
	uint32_t snowboard_callable_submit_draw_sub_723F60 = get_absolute_value(ff7_externals.snowboard_loop_sub_72381C, 0x10E);
	uint32_t snowboard_callable_draw_black_quad_7241E5 = get_absolute_value(snowboard_callable_submit_draw_sub_723F60, 0x15C);
	uint32_t snowboard_submit_draw_fade_black_quad_729926 = get_relative_call(snowboard_callable_draw_black_quad_7241E5, 0x31);
	ff7_externals.snowboard_submit_draw_black_quad_graphics_object_72DD94 = get_relative_call(snowboard_submit_draw_fade_black_quad_729926, 0xD);
	uint32_t snowboard_callable_draw_white_quad_7240D6 = get_absolute_value(snowboard_callable_submit_draw_sub_723F60, 0x165);
	uint32_t snowboard_submit_draw_white_fade_quad_729912 = get_relative_call(snowboard_callable_draw_white_quad_7240D6, 0x38);
	ff7_externals.snowboard_submit_draw_white_fade_quad_graphics_object_72DD53 = get_relative_call(snowboard_submit_draw_white_fade_quad_729912, 0xD);
	uint32_t snowboard_submit_draw_opaque_quad_72993A = get_relative_call(snowboard_callable_draw_white_quad_7240D6, 0xCC);
	ff7_externals.snowboard_submit_draw_opaque_quad_graphics_object_72DDD5 = get_relative_call(snowboard_submit_draw_opaque_quad_72993A, 0xD);
	ff7_externals.sub_735220 = get_relative_call(ff7_externals.snowboard_loop_sub_72381C, 0xBF);
	ff7_externals.sub_735332 = get_relative_call(ff7_externals.sub_735220, 0xE6);
	ff7_externals.snowboard_parse_model_vertices_732159 = get_relative_call(ff7_externals.sub_735332, 0x29);
	ff7_externals.sub_7322D6 = (char* (*)(tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x10E);
	ff7_externals.sub_732429 = (char* (*)(tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x12A);
	ff7_externals.sub_732546 = (char* (__thiscall *)(snowboard_this*, tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x162);
	ff7_externals.sub_732BB9 = (char* (*)(tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x146);
	ff7_externals.sub_733479 = (matrix* (__thiscall *)(void*, const matrix*))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x5F);
	ff7_externals.sub_733564 = (point4d* (__thiscall *)(void*, vector3<float>*, point4d*))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0xDC);
	ff7_externals.snowboard_global_object_off_926290 = (DWORD*)get_absolute_value(ff7_externals.snowboard_parse_model_vertices_732159, 0x55);
	// --------------------------------

	// Steam achievement
	uint32_t sub_434347 = get_relative_call(ff7_externals.battle_loop, 0x484);
	uint32_t* pointer_functions_7C2980 = (uint32_t*)get_absolute_value(sub_434347, 0x19C);
	ff7_externals.battle_enemy_killed_sub_433BD2 = pointer_functions_7C2980[0];
	ff7_externals.battle_sub_5C7F94 = get_relative_call(ff7_externals.battle_enemy_killed_sub_433BD2, 0x2AF);
	ff7_externals.menu_battle_end_mode = (uint16_t*)get_absolute_value(ff7_externals.menu_battle_end_sub_6C9543, 0x2C);
	uint32_t menu_sub_6CBD54 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0xC1);
	ff7_externals.menu_sub_71FF95 = get_relative_call(menu_sub_6CBD54, 0x7);
	ff7_externals.menu_shop_loop = get_relative_call(ff7_externals.menu_sub_71FF95, 0x84);
	if (version == VERSION_FF7_102_US) {
		ff7_externals.get_materia_gil = get_relative_call(ff7_externals.menu_shop_loop, 0x548);
	} else {
		ff7_externals.get_materia_gil = get_relative_call(ff7_externals.menu_shop_loop, 0x5C4);
	}
	ff7_externals.opcode_increase_gil_call = get_relative_call(ff7_externals.opcode_goldu, 0x38);

	ff7_externals.display_battle_action_text_sub_6D71FA = get_relative_call(ff7_externals.display_battle_action_text_42782A, 0x77);

	ff7_externals.opcode_add_materia_inventory_call = get_relative_call(ff7_externals.opcode_smtra, 0x72);
	ff7_externals.menu_sub_6CBCF3 = get_relative_call(ff7_externals.opcode_add_materia_inventory_call, 0x43);
	ff7_externals.menu_sub_705D16 = ff7_externals.menu_subs_call_table[4];
	ff7_externals.menu_sub_6CC17F = get_relative_call(ff7_externals.menu_sub_705D16, 0x1729);

	ff7_externals.menu_decrease_item_quantity = get_relative_call(ff7_externals.opcode_dlitm, 0x38);

	ff7_externals.sub_60FA7D = get_relative_call(ff7_externals.opcode_setbyte, 0x14);

	uint32_t menu_sub_6CBD65 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0x54);
	uint32_t menu_sub_722393 = get_relative_call(menu_sub_6CBD65, 0x4);
	ff7_externals.menu_sub_7212FB = get_relative_call(menu_sub_722393, 0x8B);
	switch(version) {
		case VERSION_FF7_102_US:
		case VERSION_FF7_102_SP:
			ff7_externals.load_save_file = get_relative_call(ff7_externals.menu_sub_7212FB, 0xE9D);
			break;
		case VERSION_FF7_102_DE:
		case VERSION_FF7_102_FR:
			ff7_externals.load_save_file = get_relative_call(ff7_externals.menu_sub_7212FB, 0xEC5);
			break;
	}

	// --------------------------------
}

inline void ff7_data(struct ff7_game_obj* game_object)
{
	num_modes = sizeof(ff7_modes) / sizeof(ff7_modes[0]);

	ff7_find_externals(game_object);

	memcpy(modes, ff7_modes, sizeof(ff7_modes));

	text_colors[TEXTCOLOR_GRAY] = 0x08;
	text_colors[TEXTCOLOR_BLUE] = 0x01;
	text_colors[TEXTCOLOR_RED] = 0x04;
	text_colors[TEXTCOLOR_PINK] = 0x05;
	text_colors[TEXTCOLOR_GREEN] = 0x02;
	text_colors[TEXTCOLOR_LIGHT_BLUE] = 0x09;
	text_colors[TEXTCOLOR_YELLOW] = 0x0E;
	text_colors[TEXTCOLOR_WHITE] = 0x0F;
}
````

## File: src/ff7_opengl.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//    Copyright (C) 2023 Marcin 'Maki' Gomulak                              //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "cfg.h"
#include "ff7.h"
#include "patch.h"
#include "ff7/defs.h"
#include "ff7_data.h"
#include "ff7/widescreen.h"
#include "ff7/time.h"
#include "ff7/battle/defs.h"
#include "ff7/field/defs.h"
#include "ff7/world/defs.h"

unsigned char midi_fix[] = {0x8B, 0x4D, 0x14};
WORD snowboard_fix[] = {0x0F, 0x10, 0x0F};

uint32_t ff7_credits_loop_gfx_begin_scene(uint32_t unknown, struct game_obj *game_object)
{
	if (drawFFNxLogoFrame(game_object)) {
		if (ff7_externals.get_button_pressed(-1)) {
			stopDrawFFNxLogo();
		}

		return 0;
	}

	return common_begin_scene(unknown, game_object);
}

void ff7_init_hooks(struct game_obj *_game_object)
{
	struct ff7_game_obj *game_object = (struct ff7_game_obj *)_game_object;

	common_externals.add_texture_format = game_object->externals->add_texture_format;
	common_externals.assert_calloc = game_object->externals->assert_calloc;
	common_externals.assert_malloc = game_object->externals->assert_malloc;
	common_externals.assert_free = game_object->externals->assert_free;
	common_externals.create_palette_for_tex = game_object->externals->create_palette_for_tex;
	common_externals.create_texture_format = game_object->externals->create_texture_format;
	common_externals.create_texture_set = game_object->externals->create_texture_set;
	common_externals.generic_light_polygon_set = game_object->externals->generic_light_polygon_set;
	common_externals.generic_load_group = game_object->externals->generic_load_group;
	common_externals.get_game_object = game_object->externals->get_game_object;
	ff7_externals.sub_6A2865 = game_object->externals->sub_6A2865;
	common_externals.make_pixelformat = game_object->externals->make_pixelformat;

	ff7_data(game_object);

	if (game_width == 1280)
		MessageBoxA(gameHwnd, "Using this driver with the old high-res patch is NOT recommended, there will be glitches.", "Warning", 0);

	game_object->d3d2_flag = 1;
	game_object->nvidia_fix = 0;

	// Load Models atoi function
	replace_call_function(ff7_externals.field_load_models_atoi, ff7_field_load_models_atoi);

	// DirectInput hack, try to reacquire on any error
	memset_code(ff7_externals.dinput_getdata2 + 0x65, 0x90, 9);
	memset_code((uint32_t)common_externals.dinput_acquire_keyboard + 0x31, 0x90, 5);

	// Allow mouse cursor to be shown
	replace_function(ff7_externals.dinput_createdevice_mouse, noop);

	// TODO: Comment this if Chocobo's not visible in race
	// replace_function(ff7_externals.draw_3d_model, draw_3d_model);

	// sub_6B27A9 hack, replace d3d code
	memset_code((uint32_t)ff7_externals.sub_6B27A9 + 25, 0x90, 6);
	replace_function(ff7_externals.sub_6B26C0, draw_single_triangle);
	replace_function(ff7_externals.sub_6B2720, sub_6B2720);

	// replace framebuffer access routine with our own version
	replace_function(ff7_externals.sub_673F5C, sub_673F5C);

	replace_function(ff7_externals.destroy_d3d2_indexed_primitive, destroy_d3d2_indexed_primitive);

	replace_function(ff7_externals.load_animation, load_animation);
	replace_function(ff7_externals.read_battle_hrc, read_battle_hrc);
	replace_function(common_externals.destroy_tex_header, destroy_tex_header);
	replace_function(ff7_externals.load_p_file, load_p_file);
	replace_function(common_externals.load_tex_file, load_tex_file);

	replace_function(ff7_externals.field_load_textures, ff7::field::field_load_textures);
	replace_function(ff7_externals.field_layer1_pick_tiles, ff7::field::field_layer1_pick_tiles);
	replace_function(ff7_externals.field_layer2_pick_tiles, ff7::field::field_layer2_pick_tiles);
	replace_function(ff7_externals.field_layer3_pick_tiles, ff7::field::field_layer3_pick_tiles);
	replace_function(ff7_externals.field_layer4_pick_tiles, ff7::field::field_layer4_pick_tiles);
	patch_code_byte(ff7_externals.field_draw_everything + 0xE2, 0x1D);
	patch_code_byte(ff7_externals.field_draw_everything + 0x353, 0x1D);
	replace_function(ff7_externals.open_flevel_siz, ff7::field::field_open_flevel_siz);
	replace_function(ff7_externals.field_init_scripted_bg_movement, ff7::field::field_init_scripted_bg_movement);
	replace_function(ff7_externals.field_update_scripted_bg_movement, ff7::field::field_update_scripted_bg_movement);

	replace_function(ff7_externals.get_equipment_stats, get_equipment_stats);

	replace_function(common_externals.open_file, open_file);
	replace_function(common_externals.read_file, read_file);
	replace_function(common_externals.__read_file, __read_file);
	replace_function(ff7_externals.__read, __read);
	replace_function(common_externals.write_file, write_file);
	replace_function(common_externals.close_file, close_file);
	replace_function(common_externals.get_filesize, get_filesize);
	replace_function(common_externals.tell_file, tell_file);
	replace_function(common_externals.seek_file, seek_file);
	replace_function(ff7_externals.open_lgp_file, open_lgp_file);
	replace_function(ff7_externals.lgp_chdir, lgp_chdir);
	replace_function(ff7_externals.lgp_open_file, lgp_open_file);
	replace_function(ff7_externals.lgp_read, lgp_read);
	replace_function(ff7_externals.lgp_read_file, lgp_read_file);
	replace_function(ff7_externals.lgp_get_filesize, lgp_get_filesize);
	replace_function(ff7_externals.lgp_seek_file, lgp_seek_file);

	replace_function(ff7_externals.magic_thread_start, ff7::battle::magic_thread_start);

	replace_function(ff7_externals.kernel2_reset_counters, kernel2_reset_counters);
	replace_function(ff7_externals.kernel2_add_section, kernel2_add_section);
	replace_function(ff7_externals.kernel2_get_text, kernel2_get_text);
	patch_code_uint((uint32_t)ff7_externals.kernel_load_kernel2 + 0x1D, 20 * 65536);
	replace_call_function(ff7_externals.kernel_init + 0x1FD, ff7_load_kernel2_wrapper);
	replace_call_function(ff7_externals.battle_scene_bin_sub_5D1050 + 0x85, ff7::battle::load_scene_bin_chunk);

	replace_function(ff7_externals.read_field_file, ff7_read_field_file);

	// prevent FF7 from stopping the movie when the window gets unfocused
	replace_function(ff7_externals.wm_activateapp, ff7_wm_activateapp);

	// required for the soft reset
	replace_function(ff7_externals.engine_exit_game_mode_sub_666C78, ff7_engine_exit_game_mode);

	// required to fix missing gameover music and broken menu sound after playing it
	replace_call_function(ff7_externals.on_gameover_enter, ff7_on_gameover_enter);
	replace_call_function(ff7_externals.on_gameover_exit, ff7_on_gameover_exit);

	// Disable DirectSound creation when using the external SFX layer
	// TODO: We need to hook more functions in the engine as it causes crashes around the game the way it is now.
	// if (use_external_sfx)
	// {
	// 	replace_function(common_externals.directsound_create, ff7_dsound_create);
	// 	replace_function(common_externals.directsound_release, ff7_dsound_release);
	// 	replace_function(common_externals.directsound_createsoundbuffer, ff7_dsound_createsoundbuffer);
	// }

	// ##################################
	// animation glitch fixes
	// ##################################

	// phoenix camera animation glitch
	memset_code(ff7_externals.run_phoenix_main_loop_516297 + 0x3A5, 0x90, 49);
	memset_code(ff7_externals.run_phoenix_main_loop_516297 + 0x3F7, 0x90, 49);

	// ##################################
	// bugfixes to enhance game stability
	// ##################################

	// chocobo crash fix
	memset_code(ff7_externals.chocobo_fix - 12, 0x90, 36);

	// midi transition crash fix
	memcpy_code(ff7_externals.midi_fix, midi_fix, sizeof(midi_fix));
	memset_code(ff7_externals.midi_fix + sizeof(midi_fix), 0x90, 18 - sizeof(midi_fix));

	// snowboard crash fix
	memcpy(ff7_externals.snowboard_fix, snowboard_fix, sizeof(snowboard_fix));

	// coaster aim fix
	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x129, 5);
	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x14A, 5);
	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x16D, 5);
	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x190, 5);

	// condor minigame load unit textures fix
	replace_call_function(ff7_externals.sub_5F342C + 0x66E, ff7_condor_fix_unit_texture_load);
	replace_call_function(ff7_externals.sub_5F342C + 0x7B9, ff7_condor_fix_unit_texture_load);
	replace_call_function(ff7_externals.sub_5F342C + 0x904, ff7_condor_fix_unit_texture_load);
	replace_call_function(ff7_externals.sub_5F342C + 0x977, ff7_condor_fix_unit_texture_load);
	replace_call_function(ff7_externals.sub_5F342C + 0x9EA, ff7_condor_fix_unit_texture_load);
	replace_call_function(ff7_externals.sub_5F342C + 0xA35, ff7_condor_fix_unit_texture_load);

	// ##################################
	// menu UI glitch fix
	// ##################################
	replace_call_function(ff7_externals.battle_set_do_render_menu_call, ff7::battle::battle_menu_enter);

	// #####################
	// widescreen / uncrop
	// #####################
	if(widescreen_enabled || enable_uncrop)
		ff7_widescreen_hook_init();

	if (enable_time_cycle)
		ff7::time_hook_init();

	// #####################
	// new timer calibration
	// #####################

	// replace time diff
	replace_function((uint32_t)common_externals.diff_time, qpc_diff_time);

	if (ff7_fps_limiter >= FPS_LIMITER_DEFAULT)
	{
		// replace rdtsc timing
		replace_function((uint32_t)common_externals.get_time, qpc_get_time);

		// override the timer calibration
		QueryPerformanceFrequency((LARGE_INTEGER *)&game_object->_countspersecond);
		game_object->countspersecond = (double)game_object->_countspersecond;

		replace_function(ff7_externals.fps_limiter_swirl, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_battle, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_coaster, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_condor, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_field, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_highway, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_snowboard, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_worldmap, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_chocobo, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_submarine, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_credits, ff7_limit_fps);
		replace_function(ff7_externals.fps_limiter_menu, ff7_limit_fps);

		if (ff7_fps_limiter >= FPS_LIMITER_30FPS)
		{
			battle_frame_multiplier = (ff7_fps_limiter == FPS_LIMITER_30FPS) ? 2 : 4;

			patch_divide_code<byte>(ff7_externals.battle_fps_menu_multiplier, battle_frame_multiplier); // Works perfectly only in 30 FPS

			ff7::battle::camera_hook_init();
			ff7::battle::animations_hook_init();

			if(ff7_fps_limiter == FPS_LIMITER_60FPS)
			{
				common_frame_multiplier = 2;

				// Swirl mode 60FPS fix
				patch_multiply_code<byte>(ff7_externals.swirl_main_loop + 0x184, common_frame_multiplier); // wait frames before swirling
				patch_multiply_code<byte>(ff7_externals.swirl_loop_sub_4026D4 + 0x3E, common_frame_multiplier);
				byte swirl_cmp_fix[7] = {0x82, 0xB9, 0x50, 0x11, 0x00, 0x00, 0x9C};
				memcpy_code(ff7_externals.swirl_loop_sub_4026D4 + 0x10B, swirl_cmp_fix, sizeof(swirl_cmp_fix));
				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1AB), common_frame_multiplier);
				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1B1), common_frame_multiplier);
				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1E4), common_frame_multiplier);
				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1EA), common_frame_multiplier);
			}
		}
	}

	// World fix (60 FPS, night cycle, external mesh)
	ff7::world::world_hook_init();

	// Field FPS fix (60FPS, 30FPS movies)
	ff7::field::ff7_field_hook_init();

	// ##########################
	// field eye to model mapping
	// ##########################
	replace_function(ff7_externals.field_models_eye_to_model, ff7::field::ff7_field_models_eye_to_model);

	// #####################
	// red XIII eye blinking
	// #####################
	byte ff7_redxiii_eye_fix[] = "\xEC\x79\x90\x00\x00\x00\x00\x00";
	memcpy_code((uint32_t)ff7_externals.field_models_eye_blink_buffer + 0x58, ff7_redxiii_eye_fix, sizeof(ff7_redxiii_eye_fix) - 1);

	// ##################
	// field eye blinking
	// ##################
	replace_function(uint32_t(ff7_externals.field_blink_3d_model_649B50), ff7::field::ff7_field_blink_eye_sub_649B50);
	// allow eye condition to always match
	memset_code(ff7_externals.opcode_kawai + 0x275, 0x90, 6);
	memset_code(ff7_externals.opcode_kawai + 0x294, 0x90, 2);
	// allow up to 128 eyes
	memset_code(ff7_externals.opcode_kawai + 0x286, 0x7F, 1);
	memset_code(ff7_externals.opcode_kawai + 0x2A1, 0x7F, 1);

	// #####################
	// field vertical center
	// #####################
	if(ff7_field_center || widescreen_enabled)
	{
		patch_code_byte(ff7_externals.field_init_viewport_values + 0x35, 16);
		patch_code_int(ff7_externals.field_init_viewport_values + 0x6E, 240);
	}

	// ########################
	// field direct color black
	// ########################
	patch_code_short(uint32_t(ff7_externals.field_convert_type2_layers) + 0xE3, 0x8000);

	// #####################
	// worldmap footsteps
	// #####################
	if(ff7_footsteps)
		replace_call_function(ff7_externals.world_update_player_74EA48 + 0xCDF, ff7::world::world_update_model_movement);

	// #####################
	// worldmap fx effects ( forest trail, ocean trail with highwind, etc. )
	// #####################
	switch(version)
		{
			case VERSION_FF7_102_US:
				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0x8);
				break;
			case VERSION_FF7_102_DE:
				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0x20);
				break;
			case VERSION_FF7_102_FR:
				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0x50);
				break;
			case VERSION_FF7_102_SP:
				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0xB0);
				break;
		}

	// #####################
	// battle toggle
	// #####################
	replace_call_function(ff7_externals.field_battle_toggle, ff7_toggle_battle_field);
	replace_call_function(ff7_externals.worldmap_battle_toggle, ff7_toggle_battle_worldmap);

	// #####################
	// auto attack toggle
	// #####################
	replace_call_function(ff7_externals.battle_menu_update_6CE8B3 + 0xD9, ff7_battle_menu_sub_6DB0EE);
	replace_call_function(ff7_externals.handle_actor_ready + 0x187, ff7_set_battle_menu_state_data_at_full_atb);

	// #####################
	// gamepad
	// #####################
	replace_function(ff7_externals.get_gamepad, ff7_get_gamepad);
	replace_function(ff7_externals.update_gamepad_status, ff7_update_gamepad_status);

	// ###########################
	// control battle/world camera
	// ###########################
	if(enable_analogue_controls) {
		replace_call_function(ff7_externals.battle_sub_42D992 + 0xFB, ff7::battle::update_battle_camera);
		replace_function((uint32_t)ff7_externals.field_clip_with_camera_range_6438F6, ff7::field::ff7_field_clip_with_camera_range);

		// Disable show targets with R2 in battles
        memset_code(ff7_externals.handle_actor_ready + 0xA8, 0x90, 29);
	}

	//######################
	// menu rendering fix
	//######################
	replace_call_function(ff7_externals.timer_menu_sub + 0x72F, ff7_menu_sub_6F5C0C);
	replace_call_function(ff7_externals.timer_menu_sub + 0xD77, ff7_menu_sub_6FAC38);

	//######################
	// shadow lighting fix
	//######################
	if(enable_lighting)
	    memset_code(ff7_externals.battle_sub_42F3E8 + 0xD7D, 0x90, 78); // Disable battle shadow draw call

	//######################
	// day night time cycle
	//######################
	if (enable_time_cycle)
	{
		replace_call_function(ff7_externals.battle_draw_text_ui_graphics_objects_call, ff7::battle::draw_ui_graphics_objects_wrapper);
		replace_call_function(ff7_externals.battle_draw_box_ui_graphics_objects_call, ff7::battle::draw_ui_graphics_objects_wrapper);
	}

	if (game_lighting != GAME_LIGHTING_ORIGINAL)
	{
		// Disables unnecesary lighting in Chocobos applied throught the KAWAI op
		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x864, 0x90, 5);
		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x2E4, 0x90, 5);
		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x3A3, 0x90, 5);
		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x23C, 0x90, 5);
		// Disables unnecessary lighting in temple of the ancients rolling rocks
		replace_function(ff7_externals.sub_64EC60, noop);
	}

	//#############################################
	// steam save game preservation and other fixes
	//#############################################
	if (steam_edition)
	{
		switch(version)
		{
			case VERSION_FF7_102_US:
				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x1096, ff7_write_save_file);
				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
				memset_code(ff7_externals.config_menu_sub + 0x8AC, 0x90, 0xE6);
				break;
			case VERSION_FF7_102_DE:
				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x10B2, ff7_write_save_file);
				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
				memset_code(ff7_externals.config_menu_sub + 0x8B3, 0x90, 0xE6);
				break;
			case VERSION_FF7_102_FR:
				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x10B2, ff7_write_save_file);
				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
				memset_code(ff7_externals.config_menu_sub + 0x8AC, 0x90, 0xE6);
				break;
			case VERSION_FF7_102_SP:
				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x10FE, ff7_write_save_file);
				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
				memset_code(ff7_externals.config_menu_sub + 0x8B3, 0x90, 0xE6);
				break;
		}

		// Restore Steam release behavior on character name screen when using gamepads in Steam Input mode
		// Aali driver used to patch out these three functions to fix this issue
		replace_function(ff7_externals.set_default_input_settings_save, noop);
		replace_function(ff7_externals.keyboard_name_input, noop);
		replace_function(ff7_externals.restore_input_settings, noop);

    // Patch the default config bitmask so that "Customize" controller option is enabled by default
    memset_code(ff7_externals.config_initialize + 0x36, 0x45, 1);
	}

	//###############################
	// steam achievement unlock calls
	//###############################
	if(steam_edition || enable_steam_achievements)
	{
		// BATTLE SQUARE
		replace_call_function(ff7_externals.battle_sub_42A0E7 + 0x78, ff7::battle::load_battle_stage);

		// GIL, MASTER MATERIA, BATTLE WON
		replace_call_function(ff7_externals.battle_enemy_killed_sub_433BD2 + 0x2AF, ff7::battle::battle_sub_5C7F94);
		replace_call_function(ff7_externals.menu_sub_6CDA83 + 0x20, ff7_menu_battle_end_sub_6C9543);
		if (version == VERSION_FF7_102_US) {
			replace_call_function(ff7_externals.menu_shop_loop + 0x327B, ff7_get_materia_gil);
		} else {
			replace_call_function(ff7_externals.menu_shop_loop + 0x3373, ff7_get_materia_gil);
		}
		replace_function(ff7_externals.opcode_increase_gil_call, ff7_opcode_increase_gil_call);

		// 1ST LIMIT BREAK
		replace_function(ff7_externals.display_battle_action_text_sub_6D71FA, ff7::battle::display_battle_action_text_sub_6D71FA);

		// MATERIA GOT
		replace_call_function(ff7_externals.opcode_add_materia_inventory_call + 0x43, ff7_menu_sub_6CBCF3);
		replace_call_function(ff7_externals.menu_sub_705D16 + 0x1729, ff7_menu_sub_6CC17F);
		replace_call_function(ff7_externals.menu_sub_705D16 + 0x1819, ff7_menu_sub_6CC17F);

		// LAST LIMIT BREAK
		replace_function(ff7_externals.menu_decrease_item_quantity, ff7_menu_decrease_item_quantity);

		// GOLD CHOCOBO, YUFFIE, VINCENT: called through update_field_entities
		replace_call_function(ff7_externals.opcode_setbyte + 0x14, ff7_chocobo_field_entity_60FA7D);
		replace_call_function(ff7_externals.opcode_biton + 0x3A, ff7_character_regularly_field_entity_60FA7D);

		// INITIALIZATION AT LOAD SAVE FILE
		switch(version) {
			case VERSION_FF7_102_US:
			case VERSION_FF7_102_SP:
				replace_call_function(ff7_externals.menu_sub_7212FB + 0xE9D, ff7_load_save_file);
				break;
			case VERSION_FF7_102_DE:
			case VERSION_FF7_102_FR:
				replace_call_function(ff7_externals.menu_sub_7212FB + 0xEC5, ff7_load_save_file);
				break;
		}
	}

	replace_call(ff7_externals.credits_main_loop + 0xAC, ff7_credits_loop_gfx_begin_scene);

	//######################
	// snowboard .P model vertices limit fix + allow float vertex data type
	//######################
	replace_function(ff7_externals.snowboard_parse_model_vertices_732159, ff7_snowboard_parse_model_vertices);
}

struct ff7_gfx_driver *ff7_load_driver(void* _game_object)
{
	struct ff7_gfx_driver *ret = (ff7_gfx_driver *)external_calloc(1, sizeof(*ret));

	ret->init = common_init;
	ret->cleanup = common_cleanup;
	ret->lock = common_lock;
	ret->unlock = common_unlock;
	ret->flip = common_flip;
	ret->clear = common_clear;
	ret->clear_all= common_clear_all;
	ret->setviewport = common_setviewport;
	ret->setbg = common_setbg;
	ret->prepare_polygon_set = common_prepare_polygon_set;
	ret->load_group = common_load_group;
	ret->setmatrix = common_setmatrix;
	ret->unload_texture = common_unload_texture;
	ret->load_texture = common_load_texture;
	ret->palette_changed = common_palette_changed;
	ret->write_palette = common_write_palette;
	ret->blendmode = common_blendmode;
	ret->light_polygon_set = common_light_polygon_set;
	ret->field_64 = common_field_64;
	ret->setrenderstate = common_setrenderstate;
	ret->_setrenderstate = common_setrenderstate;
	ret->__setrenderstate = common_setrenderstate;
	ret->field_74 = common_field_74;
	ret->field_78 = common_field_78;
	ret->draw_deferred = common_draw_deferred;
	ret->field_80 = common_field_80;
	ret->field_84 = common_field_84;
	ret->begin_scene = common_begin_scene;
	ret->end_scene = common_end_scene;
	ret->field_90 = common_field_90;
	ret->setrenderstate_flat2D = common_setrenderstate_2D;
	ret->setrenderstate_smooth2D = common_setrenderstate_2D;
	ret->setrenderstate_textured2D = common_setrenderstate_2D;
	ret->setrenderstate_paletted2D = common_setrenderstate_2D;
	ret->_setrenderstate_paletted2D = common_setrenderstate_2D;
	ret->draw_flat2D = common_draw_2D;
	ret->draw_smooth2D = common_draw_2D;
	ret->draw_textured2D = common_draw_2D;
	ret->draw_paletted2D = common_draw_paletted2D;
	ret->setrenderstate_flat3D = common_setrenderstate_3D;
	ret->setrenderstate_smooth3D = common_setrenderstate_3D;
	ret->setrenderstate_textured3D = common_setrenderstate_3D;
	ret->setrenderstate_paletted3D = common_setrenderstate_3D;
	ret->_setrenderstate_paletted3D = common_setrenderstate_3D;
	ret->draw_flat3D = common_draw_3D;
	ret->draw_smooth3D = common_draw_3D;
	ret->draw_textured3D = common_draw_3D;
	ret->draw_paletted3D = common_draw_paletted3D;
	ret->setrenderstate_flatlines = common_setrenderstate_2D;
	ret->setrenderstate_smoothlines = common_setrenderstate_2D;
	ret->draw_flatlines = common_draw_lines;
	ret->draw_smoothlines = common_draw_lines;
	ret->field_EC = common_field_EC;

	return ret;
}
````

## File: src/ff7.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Marcin 'Maki' Gomulak                              //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <ddraw.h>
#include <stdio.h>
#include <array>
#include <span>

#include "common.h"

#define FF7_MAX_NUM_MODEL_ENTITIES 32

/*
 * Primitive types supported by the engine, mostly a 1:1 mapping to PSX GPU
 * capabilities.
 *
 * Key:
 * T/S/L - triangle/square(quad)/line
 * F/G - flat/gouraud
 * T - textured
 * 2D/3D - self explanatory except 2D means no transforms at all, billboard sprites etc are still "3D"
 */
enum polygon_types
{
	PT_TF2D = 0,
	PT_TF3D,
	PT_TG2D,
	PT_TG3D,
	PT_T2D,
	PT_T3D,
	PT_TGT2D,
	PT_TGT3D,
	PT_SF2D,
	PT_SF3D,
	PT_SG2D,
	PT_SG3D,
	PT_S2D,
	PT_S3D,
	PT_SGT2D,
	PT_SGT3D,
	polygon_type_10,
	polygon_type_11,
	PT_LF2D,
	PT_L2D,
};

// FF7 modules, unknowns are either unused or not relevant to rendering
enum ff7_game_modes
{
	FF7_MODE_FIELD = 1,
	FF7_MODE_BATTLE,
	FF7_MODE_WORLDMAP,
	FF7_MODE_UNKNOWN4,
	FF7_MODE_MENU,
	FF7_MODE_HIGHWAY,
	FF7_MODE_CHOCOBO,
	FF7_MODE_SNOWBOARD,
	FF7_MODE_CONDOR,
	FF7_MODE_SUBMARINE,
	FF7_MODE_COASTER,
	FF7_MODE_CDCHECK,
	FF7_MODE_UNKNOWN13,
	FF7_MODE_SNOWBOARD2,
	FF7_MODE_UNKNOWN15,
	FF7_MODE_UNKNOWN16,
	FF7_MODE_BATTLE_MENU,
	FF7_MODE_UNKNOWN18,
	FF7_MODE_EXIT,
	FF7_MODE_MAIN_MENU,
	FF7_MODE_UNKNOWN21,
	FF7_MODE_INTRO,
	FF7_MODE_SWIRL,
	FF7_MODE_UNKNOWN24,
	FF7_MODE_ENDING2,
	FF7_MODE_GAMEOVER,
	FF7_MODE_CREDITS,
	FF7_MODE_UNKNOWN28,
};

// 3D model flags
enum model_modes
{
	MDL_ROOT_ROTATION         = 0x0001,
	MDL_ROOT_ROTATION_NEGX    = 0x0002,
	MDL_ROOT_ROTATION_NEGY    = 0x0004,
	MDL_ROOT_ROTATION_NEGZ    = 0x0008,
	MDL_ROOT_TRANSLATION      = 0x0010,
	MDL_ROOT_TRANSLATION_NEGX = 0x0020,
	MDL_ROOT_TRANSLATION_NEGY = 0x0040,
	MDL_ROOT_TRANSLATION_NEGZ = 0x0080,
	MDL_USE_STRUC110_MATRIX   = 0x4000,
	MDL_USE_CAMERA_MATRIX     = 0x8000,
};

enum class cmd_id
{
	CMD_ATTACK = 0x01,
	CMD_MAGIC = 0x02,
	CMD_SUMMON = 0x03,
	CMD_ITEM = 0x04,
	CMD_STEAL = 0x05,
	CMD_SENSE = 0x06,
	CMD_COIN = 0x07,
	CMD_THROW = 0x08,
	CMD_MORPH = 0x09,
	CMD_DEATHBLOW = 0x0A,
	CMD_MANIPULATE = 0x0B,
	CMD_MIME = 0x0C,
	CMD_ENEMY_SKILL = 0x0D,
	CMD_MUG = 0x11,
	CMD_CHANGE = 0x12,
	CMD_DEFEND = 0x13,
	CMD_LIMIT = 0x14,
	CMD_W_MAGIC = 0x15,
	CMD_W_SUMMON = 0x16,
	CMD_W_ITEM = 0x17,
	CMD_SLASH_ALL = 0x18,
	CMD_DOUBLE_CUT = 0x19,
	CMD_FLASH = 0x1A,
	CMD_QUAD_CUT = 0x1B,
	CMD_ENEMY_ACTION = 0x20,
	CMD_POISONTICK = 0x23
};

// internal structure for menu sprites (global values, may not be a structure at all)
struct menu_objects
{
	struct ff7_graphics_object *unknown1;
	struct ff7_graphics_object *unused;
	struct ff7_graphics_object *btl_win_a;
	struct ff7_graphics_object *btl_win_b;
	struct ff7_graphics_object *btl_win_c;
	struct ff7_graphics_object *btl_win_d;
	struct ff7_graphics_object *_btl_win;
	struct ff7_graphics_object *blend_btl_win_a;
	struct ff7_graphics_object *add_btl_win_a;
	struct ff7_graphics_object *add_btl_win_b;
	struct ff7_graphics_object *add_btl_win_c;
	struct ff7_graphics_object *add_btl_win_d;
	struct ff7_graphics_object *window_bg;
	struct ff7_graphics_object *blend_window_bg;
	struct ff7_graphics_object *unknown2;
	struct ff7_graphics_object *unknown3;
	struct ff7_graphics_object *unknown4;
	struct ff7_graphics_object *unknown5;
	struct ff7_graphics_object *menu_fade;
	struct ff7_graphics_object *font_a;
	struct ff7_graphics_object *font_b;
	struct ff7_graphics_object *menu_avatars[3];
	struct ff7_graphics_object *menu_avatars2[9];
	struct ff7_graphics_object *buster_tex;
	struct ff7_graphics_object *font;
	struct ff7_graphics_object *btl_win;
	struct ff7_graphics_object *blend_btl_win;
	struct ff7_graphics_object *add_btl_win;
};

// file modes
enum
{
	FF7_FMODE_READ = 0,
	FF7_FMODE_READ_TEXT,
	FF7_FMODE_WRITE,
	FF7_FMODE_CREATE,
};

/*
 * This section defines some structures used internally by the FF7 game engine.
 *
 * Documentation for some of them can be found on the Qhimm wiki, a lot of
 * information can be gleaned from the source code to this program but in many
 * cases nothing is known except the size and general layout of the structure.
 *
 * Variable and structure names are mostly based on what they contain rather
 * than what they are for, a lot of names may be wrong, inappropriate or
 * downright misleading. Thread with caution!
 */

struct list
{
	uint32_t use_assert_alloc;
	uint32_t field_4;
	uint32_t nodes;
	struct list_node *head;
	struct list_node *tail;
	void *destructor;
	void *recursive_find_cb;
	uint32_t field_1C;
};

struct list_node
{
	struct list_node *next;
	void *object;
};

struct file_context
{
	uint32_t mode;
	uint32_t use_lgp;
	uint32_t lgp_num;
	void (*name_mangler)(char *, char *);
};

struct ff7_file
{
	char *name;
	struct lgp_file *fd;
	struct file_context context;
};

struct ff7_indexed_vertices
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t count;
	uint32_t vertexcount;
	uint32_t field_10;
	struct nvertex *vertices;
	uint32_t indexcount;
	uint32_t field_1C;
	WORD *indices;
	uint32_t field_24;
	unsigned char *palettes;
	uint32_t field_2C;
	struct ff7_graphics_object *graphics_object;
};

struct ff7_graphics_object
{
	uint32_t polytype;
	uint32_t field_4;
	uint32_t field_8;
	struct p_hundred *hundred_data;
	struct matrix_set *matrix_set;
	struct polygon_set *polygon_set;
	uint32_t field_18;
	uint32_t field_1C;
	uint32_t field_20;
	float u_offset;
	float v_offset;
	void *dx_sfx_2C;
	void *graphics_instance;
	uint32_t field_34;
	uint32_t vertices_per_shape;
	uint32_t indices_per_shape;
	uint32_t vertex_offset;
	uint32_t index_offset;
	uint32_t field_48;
	uint32_t field_4C;
	uint32_t field_50;
	uint32_t field_54;
	uint32_t field_58;
	uint32_t field_5C;
	uint32_t field_60;
	uint32_t field_64;
	uint32_t field_68;
	uint32_t field_6C;
	uint32_t field_70;
	uint32_t field_74;
	uint32_t field_78;
	uint32_t field_7C;
	uint32_t field_80;
	uint32_t field_84;
	uint32_t field_88;
	struct ff7_indexed_vertices *indexed_vertices;
	gfx_polysetrenderstate *func_90;
	gfx_draw_vertices *func_94;
	uint32_t use_matrix_pointer;
	struct matrix *matrix_pointer;
	struct matrix matrix;
};

struct polygon_group
{
	uint32_t field_0;
	uint32_t numvert;
	void *driver_data;
	uint32_t field_C;
	uint32_t normindexes;
	uint32_t vertices;
	uint32_t vertex_colors;
	uint32_t texcoords;
	uint32_t texture_set;
};

struct struc_106
{
	uint32_t field_0;
	uint32_t color;
	vector3<float> point;
	struct bgra_color d3dcol;
};

struct ff7_light
{
	uint32_t flags;
	uint32_t field_4;
	struct struc_106 *color_1;
	struct struc_106 *color_2;
	struct struc_106 *color_3;
	struct bgra_color global_light_color_abgr;
	struct bgra_color global_light_color_abgr_norm;
	uint32_t global_light_color_rgba;
	struct matrix field_38;
	struct matrix field_78;
	struct matrix field_B8;
	struct matrix field_F8;
	uint32_t field_138;
	struct matrix normal_matrix;
	uint32_t field_17C;
	uint32_t field_180;
	uint32_t field_184;
	uint32_t field_188;
	uint32_t field_18C;
	uint32_t field_190;
	uint32_t field_194;
	uint32_t field_198;
	struct matrix *matrix_pointer;
	uint32_t field_1A0;
	uint32_t field_1A4[256];
	uint32_t field_5A4;
	bgra_color_ui8 color;
};

struct ff7_polygon_set
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t field_8;
	uint32_t field_C;
	uint32_t numgroups;
	struct struc_49 field_14;
	uint32_t field_2C;
	struct polygon_data *polygon_data;
	struct p_hundred *hundred_data;
	uint32_t per_group_hundreds;
	struct p_hundred **hundred_data_group_array;
	struct matrix_set *matrix_set;
	struct ff7_light *light;
	uint32_t field_48;
	void *execute_buffers;			// IDirect3DExecuteBuffer **
	struct indexed_primitive **indexed_primitives;
	uint32_t field_54;
	uint32_t field_58;
	struct polygon_group *polygon_group_array;
	uint32_t field_60;
	uint32_t field_64;
	uint32_t field_68;
	uint32_t field_6C;
	uint32_t field_70;
	uint32_t field_74;
	uint32_t field_78;
	uint32_t field_7C;
	uint32_t field_80;
	uint32_t field_84;
	uint32_t field_88;
	uint32_t field_8C;
	uint32_t field_90;
	uint32_t has_struc_173;
	uint32_t field_98;
	struct struc_173 *struc_173;
	uint32_t field_A0;
	uint32_t field_A4;
	uint32_t field_A8;
	uint32_t field_AC;
};

struct ff7_tex_header
{
	uint32_t version;
	uint32_t field_4;
	uint32_t color_key;
	uint32_t field_C;
	uint32_t field_10;
	union
	{
		struct
		{
			uint32_t minbitspercolor;
			uint32_t maxbitspercolor;
			uint32_t minalphabits;
			uint32_t maxalphabits;
		} v1_1;

		struct
		{
			uint32_t x;
			uint32_t y;
			uint32_t w;
			uint32_t h;
		} fb_tex;
	};
	union
	{
		struct
		{
			uint32_t minbitsperpixel;
			uint32_t maxbitsperpixel;
		} v1_2;

		struct
		{
			char *psx_name;
			char *pc_name;
		} file;
	};
	uint32_t field_2C;
	uint32_t palettes;					// ?
	uint32_t palette_entries;			// ?
	uint32_t bpp;
	struct texture_format tex_format;
	uint32_t use_palette_colorkey;
	char *palette_colorkey;
	uint32_t reference_alpha;
	uint32_t blend_mode;
	uint32_t field_CC;
	uint32_t palette_index;
	unsigned char *image_data;
	unsigned char *old_palette_data;
	uint32_t field_DC;
	uint32_t field_E0;
	uint32_t *vram_positions;
	uint32_t y;
};

struct ff7_texture_set
{
	union
	{
		struct
		{
			void *ddsurface1;
			void *d3d2texture1;
			void *ddsurface2;
			void *d3d2texture2;
		} d3d;

		struct
		{
			uint32_t external;
			struct gl_texture_set *gl_set;
			uint32_t width;
			uint32_t height;
		} ogl;
	};

	uint32_t field_10;
	uint32_t field_14;
	uint32_t refcount;
	uint32_t field_1C;
	uint32_t field_20;
	uint32_t field_24;
	uint32_t field_28;
	uint32_t field_2C;
	uint32_t field_30;
	uint32_t field_34;
	uint32_t field_38;
	uint32_t field_3C;
	uint32_t field_40;
	uint32_t field_44;
	uint32_t field_48;
	uint32_t field_4C;
	uint32_t field_50;
	uint32_t field_54;
	uint32_t field_58;
	uint32_t field_5C;
	uint32_t field_60;
	uint32_t field_64;
	uint32_t field_68;
	uint32_t field_6C;
	uint32_t field_70;
	uint32_t field_74;
	uint32_t field_78;
	uint32_t *texturehandle;
	struct texture_format *texture_format;
	struct tex_header *tex_header;
	uint32_t palette_index;
	struct palette *palette;
	uint32_t field_90;
	uint32_t field_94;
	uint32_t field_98;
	uint32_t field_9C;
};

struct field_layer
{
	struct ff7_tex_header *tex_header;
	void *image_data;
	struct ff7_graphics_object *graphics_object;
	uint32_t present;
	uint32_t field_10;
	uint32_t field_14;
	WORD field_18;
	WORD type;
};

struct field_object
{
	char name[256];
	char field_100[256];
	char hrc_filename[256];
	char field_300[33];
	char field_321;
	char field_322;
	char field_323;
	char field_324;
	char field_325;
	char field_326;
	unsigned char r_ambient;
	unsigned char g_ambient;
	unsigned char b_ambient;
	unsigned char r_light1;
	unsigned char g_light1;
	unsigned char b_light1;
	unsigned char r_light2;
	unsigned char g_light2;
	unsigned char b_light2;
	unsigned char r_light3;
	unsigned char g_light3;
	unsigned char b_light3;
	unsigned char field_333;
	short x_light1;
	short y_light1;
	short z_light1;
	short x_light2;
	short y_light2;
	short z_light2;
	short x_light3;
	short y_light3;
	short z_light3;
	WORD field_346;
	WORD field_348;
	WORD num_animations;
	char anim_filenames[8880];
	char field_25FC[592];
	char field_284C[60];
	uint32_t field_2888;
};

struct struc_110
{
	uint32_t field_0;
	vector3<float> position;
	vector3<float> rotation;
	vector3<float> scale;
	float scale_factor;
	struct matrix matrix;
	vector3<float> *bone_positions;
	struct matrix *bone_matrices;
};

struct battle_actor_data
{
	uint32_t index;
	uint32_t level;
	uint32_t formation_entry;
	uint32_t command_index;
	uint32_t action_index;
	uint32_t field_14;
	uint32_t allowed_targets;
	uint32_t field_1C;
	uint32_t command_animation;
	uint32_t attack_effect;
	uint32_t field_28;
	uint32_t field_2C;
	uint32_t self_mask_1;
	uint32_t self_mask_2;
	uint32_t mp_cost;
	uint32_t action_accuracy;
	uint32_t damage_calc;
	uint32_t action_element;
	uint32_t action_power;
	uint32_t attack_power;
	uint32_t action_target_mask;
	uint32_t field_54[131];
};

struct battle_actor_vars
{
	uint32_t statusMask;		   // 0x00
	uint32_t stateFlags;		   // 0x04
	byte index;					   // 0x08
	byte level;					   // 0x09
	byte unknown0;				   // 0x0A
	byte elementDamageMask;		   // 0x0B
	byte characterID;			   // 0x0C
	byte physAtk;				   // 0x0D
	byte magAtk;				   // 0x0E
	byte pEvade;				   // 0x0F
	byte idleAnimScript;		   // 0x10
	byte damageAnimID;			   // 0x11
	byte backDamageMult;		   // 0x12
	byte sizeScale;				   // 0x13
	byte dexterity;				   // 0x14
	byte luck;					   // 0x15
	byte idleAnimHolder;		   // 0x16
	byte lastCovered;			   // 0x17
	uint16_t lastTargets;		   // 0x18
	uint16_t prevAttackerMask;	   // 0x1A
	uint16_t prevPhysAttackerMask; // 0x1C
	uint16_t prevMagAttackerMask;  // 0x1E
	uint16_t defense;			   // 0x20
	uint16_t mDefense;
	uint16_t formationID;
	uint16_t absorbedElementsMask;
	uint16_t currentMP;
	uint16_t maxMP;
	int currentHP;
	int maxHP;
	uint32_t unknown1;
	uint32_t unknown2;
	uint32_t unknown3;
	uint32_t unknown4;
	uint32_t initalStatusMasks;
	uint32_t unknown5;
	byte unknown6;
	byte mEvade;
	byte actorRow;
	byte cameraData;
	uint16_t gilStolen;
	uint16_t itemStolen;
	uint16_t unknown7;
	byte missAnimScript;
	byte APValue;
	uint32_t gilValue;
	uint32_t expValue;
	byte unused8;
	byte unused9;
	uint16_t unused10; // This is being used for the tactical elements mod, unused in original game
	byte unused12;
	byte unused13;
	byte unused14;
	byte unused15;
};

struct battle_ai_context
{
	byte lastCommandIdx;  // 00
	byte lastActionIdx;	  // 08
	byte bankAccessValue; // 10
	byte dummyByte;		  // 18
	byte battleType;	  // 20
	byte colorMask;		  // 30
	byte limitLevel;	  // 38
	byte unk3;			  // 40
	byte unk4;			  // 48
	byte pad;
	uint16_t activeActorMask;	 // 50
	uint16_t scriptOwnerMask;	 // 60
	uint16_t actionTargetMask;	 // 70
	uint16_t actorAlliesMask;	 // 80
	uint16_t activeAlliesMask;	 // 90
	uint16_t actorEnemiesMask;	 // A0
	uint16_t activeEnemiesMask;	 // B0
	uint16_t actorPartyMask;	 // C0
	uint16_t enemyActorsMask;	 // D0
	uint16_t allActorsMask;		 // E0
	uint16_t unkMask2;			 // F0
	uint16_t unkMask3;			 // 0x100
	uint16_t endBattleFlags;	 // 2110
	uint16_t lastActionElements; // 2120
	uint16_t unkDword3;			 // 130
	uint16_t battleFormationIdx; // 140
	uint16_t lastAbsActionIdx;	 // 150
	uint16_t unkBattleFlags;	 // 160
	uint16_t specialAttackFlags; // 170
	uint16_t unkLimitDivisor;	 // 180
	uint16_t unkDword;			 // 190
	uint16_t stringArgs;
	uint16_t somethingEmerald; // 1A0
	uint32_t partyGil;		   // 1C0
	battle_actor_vars actor_vars[10];
};

struct battle_anim_event {
    byte attackerID;
    byte activeAllies;
    byte spellEffectID;
    byte commandIndex;
    byte actionFlags;
    byte animationScriptID;
    uint16_t actionIndex;
    uint16_t cameraData;
    uint16_t damageEventQueueIdx;
};

struct formation_camera{
	vector3<short> position;
	vector3<short> focal_point;
};

struct bcamera_position{
	vector3<short> point;
	WORD unused_6;
	short current_position;
	short frames_to_wait;
	byte field_C;
	byte field_D;
};

struct bcamera_fn_data{
	WORD field_0;
	WORD field_2;
	WORD n_frames;
	short field_6;
	short field_8;
	short field_A;
	short field_C;
	short field_E;
	short field_10;
	byte unused_12[6];
	byte field_18;
	byte unused_19[15];
};

struct battle_model_state
{
    uint16_t characterID;     // BE1178, 0
    uint16_t animScriptIndex; // BE117A, 2
    byte actionFlags;
    byte field_5;
    short field_6;
    uint16_t AnimationData; // BE1180, 8
    uint16_t animScriptPtr; // BE1182, 0xA
    uint16_t field_C;
    uint16_t runningAnimIdx; // 0xE
    uint16_t totalBones;
    uint16_t height;
    short field_14;
    uint16_t initialXRotation;
    uint16_t initialYRotation;
    uint16_t initialZRotation;
    uint16_t field_1C;
    uint16_t field_1E;
    uint16_t field_20;
    byte animationEffect; // BE119A, 0x22
    byte commandID;       // BE119B, 0x23
    byte field_24;
    byte field_25;
    byte actorIsNotActing;
    byte field_27;
    byte field_28;
    byte unkActorFlags;
    byte field_2A;
    byte bData0x12[16];         // 0x2B
    byte isScriptExecuting;     // BE11B3, 0x3B
    byte currentScriptPosition; // 0x3C
    byte waitFrames;            // 0x3D
    byte modelEffectFlags;      // 0x3E
    byte field_3F;
    uint32_t field_40;
    uint32_t field_44;
    uint32_t field_48;
    uint32_t field_4C;
    uint32_t field_50;
    uint32_t field_54;
    uint32_t field_58;
    uint32_t field_5C;
    uint32_t field_60;
    uint32_t field_64;
    uint32_t field_68;
    uint32_t field_6C;
    uint32_t field_70;
    uint32_t field_74;
    byte padding3[0xE6];       // 0x78
	vector3<uint16_t> modelRotation; // BE12D8, 0x15E
    uint16_t field_164;
	vector3<short> modelPosition; // BE12DE, 0x166
    uint32_t field_16C;
    uint32_t *field_170;
    uint32_t field_174;
    byte padding5[0xA24];
    uint32_t playedAnimFrames;
    uint32_t currentPlayingFrame;
    uint32_t tableRelativeModelAnimIdx;
    uint32_t *modelDataPtr;
    byte padding4[0xF18];
    uint32_t setForLimitBreaks; // 0x1AC4
    uint32_t field_1AC8;
    float field_1ACC;
    float field_1AD0;
    float field_1AD4;
    uint32_t padding_1AD8;
    float field_1ADC;
    uint32_t padding_1AE0;
    uint32_t field_1AE4;
    uint32_t field_1AE8;
};

struct battle_model_state_small
{
    uint32_t field_0;
    uint16_t bData68[4];
    uint16_t field_C;
    uint16_t bData76[6];
    uint16_t bData88[6];
    uint16_t actorIsNotActing;
    uint16_t field_28;
    uint16_t field_2A;
    uint16_t someHPCopy;
    uint16_t field_2E;
    uint16_t someMPCopy;
    byte modelDataIndex; // 0x032
    byte field_33;
    byte innateStatusMask;
    byte field_35;
    byte field_36;
    byte field_37;
    uint16_t field_38;
    uint16_t field_3A;
    uint16_t field_3C;
    uint16_t actionIdx;
    byte field_40;
    byte field_41;
    byte field_42;
    byte field_43;
    byte field_44;
    byte field_45;
    byte field_46;
    byte field_47;
    byte field_48;
    byte field_49;
    byte field_4A;
    byte field_4B;
    byte field_4C;
    byte field_4D;
    byte field_4E;
    byte field_4F;
    byte field_50;
    byte field_51;
    byte field_52;
    byte field_53;
    byte field_54;
    byte field_55;
    byte field_56;
    byte field_57;
    byte field_58;
    byte field_59;
    byte field_5A;
    byte field_5B;
    byte field_5C;
    byte field_5D;
    byte field_5E;
    byte field_5F;
    byte field_60;
    byte field_61;
    byte field_62;
    byte field_63;
    byte field_64;
    byte field_65;
    byte field_66;
    byte field_67;
    byte field_68;
    byte field_69;
    byte field_6A;
    byte field_6B;
    byte field_6C;
    byte field_6D;
    byte field_6E;
    byte field_6F;
    byte field_70;
    byte field_71;
    byte field_72;
    byte field_73;
};

struct effect100_data
{
    uint16_t field_0;
    short field_2;
    short n_frames;
    short field_6;
    short field_8;
    short field_A;
    short field_C;
    short field_E;
    int field_10;
    int field_14;
    byte field_18;
    byte field_19;
	short field_1A;
    byte field_1C[4];
};

struct effect60_data
{
    uint16_t field_0;
    short field_2;
    short n_frames;
    short field_6;
    short field_8;
    short field_A;
    uint16_t padding;
    short field_E;
    int field_10;
    int field_14;
    byte field_18;
    byte field_19[7];
};

struct effect10_data
{
    uint16_t field_0;
    short field_2;
    short n_frames;
    short field_6;
    short field_8;
    short field_A;
    short field_C;
    short field_E;
    int field_10;
    int field_14;
    byte field_18;
    byte field_19;
    byte field_1A;
    byte field_1B[5];
};

struct material_anim_ctx
{
    uint32_t *materialRSD;
    uint32_t negateColumnFlags;
    WORD field_8;
    short transparency;
    short field_C;
    short paletteIdx;
};

struct palette_extra
{
    int x_offset;
    p_hundred *aux_gfx_ptr;
    int z_offset_2;
    int y_offset;
    int scroll_v;
    int v_offset;
    int z_offset;
    int field_1C;
    int field_20;
    int field_24;
    int field_28;
};

struct page_spt
{
    int field_0;
    short field_4;
    short field_6;
    short uScale;
    short vScale;
    short field_C;
    short palette_something;
    short field_10;
    short field_12;
};

struct tex_page_list
{
    WORD *field_0;
    page_spt *page_spt_ptr;
};

struct texture_spt
{
    int *spt_handle_copy;
    tex_page_list *pages;
    byte *spt_handle;
    int tex_page_count;
    uint32_t field_10[4];
    ff7_graphics_object *game_drawable[4];
};

struct texture_spt_anim_ctx
{
    texture_spt *effect_spt;
    ff7_graphics_object *effectDrawable;
    color_ui8 color;
    WORD field_C;
    WORD field_E;
};

#pragma pack(push, 1)
struct rotation_matrix
{
    short r3_sub_matrix[3][3];
    int position[3];
};
#pragma pack(pop)

#pragma pack(push, 1)
struct transform_matrix
{
  int16_t eye_x;
  int16_t eye_y;
  int16_t eye_z;
  int16_t target_x;
  int16_t target_y;
  int16_t target_z;
  int16_t up_x;
  int16_t up_y;
  int16_t up_z;
  int pos_x;
  int pos_y;
  int pos_z;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct ff7_game_engine_data
{
	float scale;
	byte field_4[4];
	double field_8;
	rotation_matrix rot_matrix;
	byte field_2E[2];
	DWORD field_30;
	DWORD field_34;
	float float_delta_x;
	float float_delta_y;
	vector2<int> world_coord;
	int do_not_transpose;
	color_ui8 primary_color;
	color_ui8 secondary_color;
	float field_54;
	float field_58;
};
#pragma pack(pop)

struct battle_text_data
{
	short buffer_idx;
	short field_2;
	byte wait_frames;
	byte n_frames;
};

struct battle_chdir_struc
{
	uint32_t sucess;
	char olddir[200];
};

struct battle_hrc_bone
{
	uint32_t parent;
	float bone_length;
	uint32_t num_rsd;
};

struct battle_hrc_header
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t field_8;
	uint32_t bones;
	uint32_t field_10;
	uint32_t field_14;
	uint32_t num_textures;
	uint32_t num_animations_1;
	uint32_t animations_2_start_index;
	uint32_t num_weapons;
	uint32_t num_animations_2;
	uint32_t field_2C;
	struct battle_hrc_bone *bone_data;
};

struct anim_frame_header
{
	vector3<float> root_rotation;
	vector3<float> root_translation;
};

struct anim_frame
{
	struct anim_frame_header *header;
	vector3<float> *data;
};

struct anim_header
{
	union
	{
		struct
		{
			uint32_t version;
		} version;

		struct
		{
			char *pc_name;
		} file;
	};
	uint32_t num_frames;
	uint32_t num_bones;
	char rotation_order[4];
	void *frame_data;
	struct anim_frame *anim_frames;
	uint32_t use_matrix_array;
	struct matrix *matrix_array;
	struct matrix *current_matrix_array;
};

struct hrc_data
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t debug;
	uint32_t flags;
	uint32_t num_bones;
	struct hrc_bone *bones;
	uint32_t field_18;
	struct list *bone_list;
	struct ff7_game_obj *game_object;
	struct matrix field_24;
	struct matrix field_64;
	uint32_t *field_A4;
};

struct hrc_bone
{
	char *bone_name;
	char *bone_parent;
	uint32_t parent_index;
	float bone_length;
	uint32_t num_rsd;
	char **rsd_names;
	struct rsd_array_member *rsd_array;
};

struct bone_list_member
{
	WORD bone_type;
	WORD bone_index;
};

struct rsd_array_member
{
	uint32_t field_0;
	struct rsd_data *rsd_data;
};

struct rsd_data
{
	struct matrix_set *matrix_set;
	struct ff7_polygon_set *polygon_set;
	struct pd_data *pd_data;
};

#pragma pack(push, 1)
struct ff7_hrc_polygon_data
{
  int version;
  DWORD dword4;
  DWORD number_of_frames;
  DWORD dwordC;
  DWORD dword10;
  DWORD dword14;
  BYTE gap18[4];
  DWORD dword1C;
  BYTE gap20[8];
  DWORD dword28;
  int fps;
  DWORD dword30;
  DWORD dword34;
  struc_110 struc_110;
  BYTE gapAC[4];
  DWORD dwordB0;
  hrc_data *hrc_data;
  ff7_game_obj *game_obj;
  __int64 lag;
  unsigned __int64 current_time;
  BYTE gapCC[8];
  file_context file_contextD4;
};
#pragma pack(pop)

struct lgp_toc_entry
{
	char name[16];
	uint32_t offset;
	WORD unknown1;
	WORD conflict;
};

struct lookup_table_entry
{
	unsigned short toc_offset;
	unsigned short num_files;
};

struct conflict_entry
{
	char name[128];
	unsigned short toc_index;
};

struct conflict_list
{
	uint32_t num_conflicts;
	struct conflict_entry *conflict_entries;
};

struct lgp_folders
{
	struct conflict_list conflicts[1000];
};

struct hpmp_bar
{
	WORD x;
	WORD y;
	WORD w;
	WORD h;
	WORD value1;
	WORD max_value;
	WORD healing_animation;
	WORD value2;
	uint32_t color;
};

struct savemap_char
{
	char id;
	char level;
	char field_2;
	char field_3;
	char field_4;
	char field_5;
	char dex;
	char field_7;
	char field_8;
	char field_9;
	char field_A;
	char field_B;
	char field_C;
	char field_D;
	char current_limit_level;
	unsigned char current_limit_bar;
	char name[12];
	char equipped_weapon;
	char equipped_armor;
	char field_1E;
	char flags;
	char field_20;
	unsigned char level_progress_bar;
	WORD learned_limit_break;
	WORD num_kills;
	WORD used_n_limit_1_1;
	WORD field_28;
	WORD field_2A;
	WORD hp;
	WORD base_hp;
	WORD mp;
	WORD base_mp;
	uint32_t field_34;
	WORD max_hp;
	WORD max_mp;
	uint32_t current_exp;
	uint32_t equipped_materia[16];
	uint32_t exp_to_next_level;
};

struct chocobo_slot
{
	WORD sprint_speed;
	WORD max_sprint_speed;
	WORD speed;
	WORD max_speed;
	char acceleration;
	char cooperation;
	char intelligence;
	char personality;
	char p_count;
	char n_races_won;
	boolean is_female;
	char type;
};

#pragma pack(push,1)

struct savemap
{
	uint32_t checksum;
	char preview_level;
	char preview_portraits[3];
	char preview_char_name[16];
	WORD preview_hp;
	WORD preview_maxhp;
	WORD preview_mp;
	WORD preview_maxmp;
	uint32_t preview_gil;
	uint32_t preview_seconds;
	char preview_location[32];
	char ul_window_red;
	char ul_window_green;
	char ul_window_blue;
	char ur_window_red;
	char ur_window_green;
	char ur_window_blue;
	char ll_window_red;
	char ll_window_green;
	char ll_window_blue;
	char lr_window_red;
	char lr_window_green;
	char lr_window_blue;
	savemap_char chars[9];
	byte party_members[3];
	char padding_4FB;
	WORD items[320];
	uint32_t materia[200];
	uint32_t stolen_materia[48];
	char field_B5C[32];
	uint32_t gil;
	uint32_t seconds;
	uint32_t countdown_timer;
	char field_B88[12];
	WORD current_mode;
	WORD current_location;
	WORD field_B98;
	WORD x;
	WORD y;
	WORD z_walkmeshtri;
	char field_BA0[467];
	char yuffie_reg_mask;
	char field_D74[80];
	chocobo_slot chocobo_slots_first[4];
	char field_E04[240];
	char vincent_reg_mask;
	char field_EF5[399];
	chocobo_slot chocobo_slots_last[2];
	WORD phs_lock;
	WORD phs_visi;
	char field_10A8[48];
	char battle_speed;
	char battle_msg_speed;
	char config_bitmap_1;
	char config_bitmap_2;
	char controller_mapping[16];
	char message_speed;
	char field_10ED[7];
};

struct weapon_data
{
	char field_0;
	char field_1;
	char field_2;
	char field_3;
	unsigned char attack_stat;
	char field_5;
	char field_6;
	char field_7;
	char field_8;
	char field_9;
	char field_A;
	char field_B;
	WORD field_C;
	WORD field_E;
	WORD field_10;
	WORD field_12;
	char stat_increase_types[4];
	char stat_increase_amounts[4];
	char field_1C[8];
	char field_24;
	char field_25;
	char field_26;
	char field_27;
	WORD field_28;
	WORD field_2A;
};

struct armor_data
{
	char field_0;
	char field_1;
	unsigned char defense_stat;
	unsigned char mdef_stat;
	char field_4;
	char field_5;
	char field_6;
	WORD field_7;
	char field_9[8];
	char field_11;
	WORD field_12;
	WORD field_14;
	WORD field_16;
	uint32_t field_18;
	uint32_t field_1C;
	WORD field_20;
	WORD field_22;
};

struct party_member_data
{
	char field_0;
	char field_1;
	char field_2;
	char field_3;
	char field_4;
	char field_5;
	char field_6;
	char field_7;
	WORD field_8;
	WORD field_A;
	WORD field_C;
	WORD field_E;
	WORD hp;
	WORD max_hp;
	WORD mp;
	WORD max_mp;
	WORD field_18;
	WORD field_1A;
	WORD field_1C;
	WORD field_1E;
	char field_20;
	char field_21;
	char field_22;
	char field_23;
	char field_24[24];
	WORD field_3C;
	WORD field_3E;
	WORD field_40;
	WORD field_42;
	uint32_t field_44;
	uint32_t field_48;
	uint32_t field_4C[24];
	char field_AC[8];
	uint32_t field_B4[21];
	uint32_t field_108[112];
	uint32_t field_2C8[32];
	uint32_t field_348[48];
	struct weapon_data weapon_data;
	uint32_t field_434;
	uint32_t field_438;
	uint32_t field_43C;
};

#pragma pack(pop)

struct field_tile
{
	short x;
	short y;
	float z;
	WORD field_8;
	WORD field_A;
	WORD img_x;
	WORD img_y;
	float u;
	float v;
	WORD fx_img_x;
	WORD fx_img_y;
	uint32_t field_1C;
	uint32_t field_20;
	uint32_t field_24;
	uint32_t field_28;
	WORD tile_size_x;
	WORD tile_size_y;
	WORD palette_index;
	WORD flags;
	char anim_group;
	char anim_bitmask;
	WORD field_36;
	char field_38[4096];
	WORD field_1038;
	WORD field_103A;
	uint32_t use_fx_page;
	uint32_t field_1040;
	uint32_t field_1044;
	uint32_t field_1048;
	uint32_t field_104C;
	char field_1050;
	char field_1051;
	char field_1052;
	char field_1053;
	WORD blend_mode;
	WORD page;
	WORD fx_page;
	WORD field_105A;
};

struct struc_3
{
	uint32_t field_0;
	uint32_t field_4;
	uint32_t convert_animations;
	uint32_t create_matrix_set;
	uint32_t field_10;
	uint32_t matrix_set_size;
	struct graphics_instance *graphics_instance;
	uint32_t field_1C;
	uint32_t blend_mode;
	uint32_t base_directory;
	struct ff7_tex_header *tex_header;
	uint32_t field_2C;
	uint32_t light;
	uint32_t field_34;
	float bone_scale_factor;
	uint32_t field_3C;
	struct file_context file_context;
	uint32_t field_50;
	uint32_t field_54;
	uint32_t field_58;
	uint32_t palette_index;
	uint32_t field_60;
	uint32_t field_64;
	uint32_t field_68;
	uint32_t field_6C;
	uint32_t field_70;
};

struct wordmatrix
{
	WORD _11;
	WORD _12;
	WORD _13;
	WORD _21;
	WORD _22;
	WORD _23;
	WORD _31;
	WORD _32;
	WORD _33;
	uint32_t _41;
	uint32_t _42;
	uint32_t _43;
};

struct struc_154_2
{
	short field_0;
	WORD field_2;
	WORD field_4;
	WORD field_6;
	WORD field_8;
	WORD field_A;
	WORD field_C;
	WORD field_E;
	uint32_t field_10;
	uint32_t field_14;
	unsigned char field_18[8];
};

struct struc_154_3
{
	short field_0;
	WORD field_2;
	WORD field_4;
	WORD field_6;
	WORD field_8;
	WORD field_A;
	WORD field_C;
	WORD field_E;
	uint32_t field_10;
	uint32_t field_14;
	unsigned char field_18[8];
};

struct struc_154
{
	short field_0;
	WORD field_2;
	WORD field_4;
	WORD field_6;
	WORD field_8;
	WORD field_A;
	WORD field_C;
	WORD field_E;
	uint32_t field_10;
	uint32_t field_14;
	unsigned char field_18[8];
};

struct struc_205
{
	short field_0;
	WORD field_2;
	WORD field_4;
	WORD field_6;
	WORD field_8;
	WORD field_A;
	WORD field_C;
	WORD field_E;
	uint32_t field_10;
	uint32_t field_14;
	unsigned char field_18[16];
};

struct movie_obj
{
	void *ddstream;
	uint32_t field_4;
	void *mediastream;
	uint32_t loop;
	uint32_t field_10;
	DDSURFACEDESC movie_sdesc;
	void *graphbuilder;
	uint32_t movie_surfaceheight;
	uint32_t field_88;
	void *amms;
	void *movie_surface;
	void *sample;
	uint32_t movie_left;
	uint32_t movie_top;
	uint32_t movie_right;
	uint32_t movie_bottom;
	uint32_t target_left;
	uint32_t target_top;
	uint32_t target_right;
	uint32_t target_bottom;
	void *sts1;
	void *vts1;
	void *sts2;
	void *vts2;
	void *st1;
	void *vt1;
	void *st2;
	void *vt2;
	uint32_t vt1handle;
	uint32_t vt2handle;
	uint32_t field_E0;
	uint32_t movie_surfacewidth;
	uint32_t field_E8;
	struct nvertex movie_vt2prim[4];
	struct nvertex movie_vt1prim[4];
	void *mediaseeking;
	uint32_t graphics_mode;
	uint32_t field_1F4;
	uint32_t field_1F8;
	uint32_t is_playing;
	uint32_t movie_end;
	uint32_t global_movie_flag;
};

struct dll_gfx_externals
{
	void *(*assert_free)(void *, const char *, uint32_t);
	void *(*assert_malloc)(uint32_t, const char *, uint32_t);
	void *(*assert_calloc)(uint32_t, uint32_t, const char *, uint32_t);
	struct texture_format *(*create_texture_format)();
	void (*add_texture_format)(struct texture_format *, struct game_obj *);
	struct game_obj *(*get_game_object)();
	uint32_t free_driver;
	uint32_t create_gfx_driver;
	void (*make_pixelformat)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, struct texture_format *);
	uint32_t gltexformat2texformat;
	uint32_t sub_686143;
	uint32_t sub_6861EC;
	uint32_t sub_68631E;
	uint32_t sub_686351;
	uint32_t pal_pixel2bgra;
	uint32_t pal_pixel2bgra_8bit;
	uint32_t texture_set_destroy_pal;
	struct palette *(*create_palette_for_tex)(uint32_t, struct tex_header *, struct texture_set *);
	uint32_t convert_texture;
	uint32_t texture_set_decref;
	struct texture_set *(*create_texture_set)();
	uint32_t write_palette;
	uint32_t rgba2d3dcol;
	uint32_t sub_6A5FEB;
	uint32_t sub_6A604A;
	uint32_t destroy_palette;
	uint32_t create_palette;
	uint32_t call_gfx_write_palette;
	uint32_t call_gfx_palette_changed;
	uint32_t sub_6A5A70;
	uint32_t sub_6A5BA0;
	uint32_t sub_6A5C3B;
	uint32_t sub_6A5CE2;
	void *(*sub_6A2865)(void *);
	gfx_load_group *generic_load_group;
	gfx_light_polygon_set *generic_light_polygon_set;
};

struct ff7_audio_fmt
{
	uint32_t length;
	uint32_t offset;
	uint32_t loop;
	uint32_t count;
	uint32_t loop_start;
	uint32_t loop_end;
	LPWAVEFORMATEX wave_format;
};

struct ff7_game_obj
{
	uint32_t do_quit;
	uint32_t dc_horzres;
	uint32_t dc_vertres;
	uint32_t dc_bitspixel;
	uint32_t window_pos_x;
	uint32_t window_pos_y;
	uint32_t window_size_x;
	uint32_t window_size_y;
	uint32_t window_minimized;
	uint32_t field_24;
	uint32_t field_28;
	uint32_t field_2C;
	double countspersecond;
	time_t _countspersecond;
	uint32_t field_40;
	uint32_t field_44;
	double fps;
	uint32_t tsc;
	uint32_t field_54;					// tsc high bits?
	HINSTANCE hinstance;
	HWND hwnd;
	uint32_t field_60;
	uint32_t field_64;
	uint32_t field_68;
	uint32_t field_6C;
	uint32_t field_70;
	void *dddevice;
	void *dd2interface;
	LPDIRECTDRAWSURFACE front_surface[3];
	DDSURFACEDESC front_surface_desc[3];
	uint32_t field_1CC;
	uint32_t field_1D0;
	IDirectDrawClipper* dd_clipper;
	uint32_t field_1D8;
	DDSURFACEDESC d3d_surfacedesc;
	void *dd_interface;
	uint32_t field_24C;
	DDSURFACEDESC dd_surfacedesc;
	struct list *d3ddev_list;
	void *d3dinterface;
	void *surface_d3ddev;			// IDirect3DDevice
	struct list *textureformat_list;
	void *d3ddev_struct;
	void *d3dviewport;
	void *d3dmaterial;
	uint32_t field_2D8;
	void *d3d2interface;
	void *d3d2device;
	void *d3dviewport2;
	struct list *list_2E8;
	struct polygon_set *polygon_set_2EC;
	struct polygon_set *polygon_set_2F0;
	struct stack *matrix_stack1;
	struct stack *matrix_stack2;
	struct matrix *camera_matrix;
	struct graphics_instance *graphics_instance;
	uint32_t field_304;
	uint32_t field_308;
	uint32_t field_30C;
	uint32_t field_310;
	uint32_t field_314;
	uint32_t field_318;
	uint32_t field_31C;
	uint32_t field_320;
	D3DDEVICEDESC d3d_halcaps;
	D3DDEVICEDESC d3d_helcaps;
	DDCAPS_DX5 halcaps;
	DDCAPS_DX5 helcaps;
	uint32_t field_794;
	uint32_t field_798;
	struct texture_format surface_tex_format;
	uint32_t in_scene;
	struct p_hundred *hundred_array[5];
	void *applog_debug1;
	uint32_t applog_debug2;
	void *dxdbg_file;
	uint32_t field_840;
	uint32_t field_844;
	uint32_t _res_x;
	uint32_t _res_y;
	uint32_t _res_w;
	uint32_t _res_h;
	uint32_t field_858;
	uint32_t field_85C;
	uint32_t field_860;
	uint32_t field_864;
	uint32_t field_868;
	uint32_t field_86C;
	uint32_t field_870;
	uint32_t field_874;
	uint32_t field_878;
	uint32_t field_87C;
	uint32_t field_880;
	uint32_t field_884;
	uint32_t field_888;
	uint32_t field_88C;
	struct matrix matrix_890;
	struct matrix matrix_8D0;
	void *dx_sfx_something;
	struct list *tex_list_pointer;
	struct stack *stack_918;
	uint32_t field_91C;
	void *_3d2d_something;
	uint32_t field_924;
	uint32_t field_928;
	uint32_t field_92C;
	uint32_t field_930;
	struct gfx_driver *gfx_driver;
	void *_3dobject_pool;
	uint32_t field_93C;
	struct p_hundred *current_hundred;
	struct struc_81 *field_944;
	uint32_t field_948;
	uint32_t field_94C;
	uint32_t field_950;
	uint32_t window_width;
	uint32_t window_height;
	uint32_t colordepth;
	uint32_t field_960;
	uint32_t is_fullscreen;
	uint32_t field_968;
	uint32_t no_hardware;
	uint32_t field_970;
	uint32_t show_cursor;
	uint32_t colorkey;
	uint32_t field_97C;
	uint32_t field_980;
	uint32_t d3d2_flag;
	uint32_t field_988;
	uint32_t field_98C;
	uint32_t field_990;
	uint32_t field_994;
	uint32_t matrix_stack_size;
	uint32_t field_99C;
	uint32_t field_9A0;
	uint32_t field_9A4;
	uint32_t field_9A8;
	uint32_t field_9AC;
	uint32_t random_seed;
	char *window_title;
	char *window_class;
	uint32_t use_custom_wndclass;
	WNDCLASSA wndclass_struct;
	uint32_t use_custom_dwStyle;
	DWORD dwStyle;
	struct main_obj engine_loop_obj;
	struct main_obj game_loop_obj;
	void *wm_activate;
	uint32_t field_A2C;
	uint32_t field_A30;
	uint32_t field_A34;
	uint32_t field_A38;
	uint32_t field_A3C;
	uint32_t field_A40;
	uint32_t field_A44;
	uint32_t field_A48;
	uint32_t field_A4C;
	uint32_t field_A50;
	uint32_t gfx_reset;
	uint32_t field_A58;
	uint32_t field_A5C;
	uint32_t current_gfx_driver;
	uint32_t field_A64;
	uint32_t field_A68;
	uint32_t field_A6C;
	uint32_t field_A70;
	uint32_t field_A74;
	uint32_t field_A78;
	void *gfx_driver_data;
	uint32_t field_A80;
	uint32_t field_A84;
	void *create_gfx_driver;
	struct dll_gfx_externals *externals;
	uint32_t nvidia_fix;
	uint32_t tnt_fix;
	uint32_t no_riva_fix;
	uint32_t field_A9C;
};

struct ff7_gamepad_status
{
	uint32_t pos_x;
	uint32_t pos_y;
	uint32_t dpad_up;
	uint32_t dpad_down;
	uint32_t dpad_left;
	uint32_t dpad_right;
	uint32_t button1;
	uint32_t button2;
	uint32_t button3;
	uint32_t button4;
	uint32_t button5;
	uint32_t button6;
	uint32_t button7;
	uint32_t button8;
	uint32_t button9;
	uint32_t button10;
	uint32_t button11;
	uint32_t button12;
	uint32_t button13;
	uint32_t button14;
	uint32_t button15;
	uint32_t button16;
};

struct ff7_gfx_driver
{
	gfx_init *init;
	gfx_cleanup *cleanup;
	gfx_lock *lock;
	gfx_unlock *unlock;
	gfx_flip *flip;
	gfx_clear *clear;
	gfx_clear_all *clear_all;
	gfx_setviewport *setviewport;
	gfx_setbg *setbg;
	uint32_t field_24;
	struct bgra_color field_28;			// ?
	uint32_t field_38;
	uint32_t field_3C;
	gfx_prepare_polygon_set *prepare_polygon_set;
	gfx_load_group *load_group;
	gfx_setmatrix *setmatrix;
	gfx_unload_texture *unload_texture;
	gfx_load_texture *load_texture;
	gfx_palette_changed *palette_changed;
	gfx_write_palette *write_palette;
	gfx_blendmode *blendmode;
	gfx_light_polygon_set *light_polygon_set;
	gfx_field_64 *field_64;
	gfx_setrenderstate *setrenderstate;
	gfx_setrenderstate *_setrenderstate;
	gfx_setrenderstate *__setrenderstate;
	gfx_field_74 *field_74;
	gfx_field_78 *field_78;
	gfx_draw_deferred *draw_deferred;
	gfx_field_80 *field_80;
	gfx_field_84 *field_84;
	gfx_begin_scene *begin_scene;
	gfx_end_scene *end_scene;
	gfx_field_90 *field_90;
	gfx_polysetrenderstate *setrenderstate_flat2D;
	gfx_polysetrenderstate *setrenderstate_smooth2D;
	gfx_polysetrenderstate *setrenderstate_textured2D;
	gfx_polysetrenderstate *setrenderstate_paletted2D;
	gfx_polysetrenderstate *_setrenderstate_paletted2D;
	gfx_draw_vertices *draw_flat2D;
	gfx_draw_vertices *draw_smooth2D;
	gfx_draw_vertices *draw_textured2D;
	gfx_draw_vertices *draw_paletted2D;
	gfx_polysetrenderstate *setrenderstate_flat3D;
	gfx_polysetrenderstate *setrenderstate_smooth3D;
	gfx_polysetrenderstate *setrenderstate_textured3D;
	gfx_polysetrenderstate *setrenderstate_paletted3D;
	gfx_polysetrenderstate *_setrenderstate_paletted3D;
	gfx_draw_vertices *draw_flat3D;
	gfx_draw_vertices *draw_smooth3D;
	gfx_draw_vertices *draw_textured3D;
	gfx_draw_vertices *draw_paletted3D;
	gfx_polysetrenderstate *setrenderstate_flatlines;
	gfx_polysetrenderstate *setrenderstate_smoothlines;
	gfx_draw_vertices *draw_flatlines;
	gfx_draw_vertices *draw_smoothlines;
	gfx_field_EC *field_EC;
};

struct ff7_field_sfx_state {
	uint32_t u1;
	uint32_t volume1;
	uint32_t volume2;
	uint32_t u2;
	uint32_t u3;
	uint32_t u4;
	uint32_t pan1;
	uint32_t pan2;
	uint32_t u5;
	uint32_t u6;
	uint32_t u7;
	uint32_t byte;
	uint32_t u9;
	uint32_t u10;
	uint32_t u11;
	uint32_t frequency;
	uint32_t sound_id;
	IDirectSoundBuffer* buffer1;
	IDirectSoundBuffer* buffer2;
	uint32_t is_looped;
	uint32_t u12;
};

struct ff7_camdata
{
	// EYE
	vector3<short> eye;
	// TARGET
	vector3<short> target;
	// UP
	vector3<short> up;
	// FILLER?
	int16_t padding;
	// POSITION
	vector3<int> position;
	// PAN
	int16_t pan_x;
	int16_t pan_y;
	// ZOOM
	int16_t zoom;
	// FILLER?
	int16_t padding2;
};

struct ff7_shake_bg_data
{
	uint8_t do_shake;
	uint8_t shake_phase;
	char amp_index;
	char shake_curr_value;
	short shake_amplitude;
	short shake_initial;
	short shake_final;
	short shake_n_steps;
	short shake_idx;
};

struct ff7_modules_global_object
{
  uint8_t field_0;
  uint8_t game_mode;
  uint16_t battle_id;
  uint16_t field_model_pos_x;
  uint16_t field_model_pos_y;
  uint16_t field_8;
  short field_A;
  short field_C;
  uint16_t field_E;
  int16_t field_10;
  uint8_t field_12;
  uint8_t field_13;
  uint8_t field_14;
  uint8_t field_15;
  short field_16;
  uint16_t field_18;
  uint16_t field_1A;
  uint8_t field_1C;
  byte world_move_mode;
  char world_move_follow_model_id;
  byte world_move_status;
  uint16_t field_20;
  uint16_t field_model_triangle_id;
  uint16_t field_model_anim_id;
  uint16_t previous_game_mode;
  uint16_t num_models;
  uint16_t field_model_id;
  uint16_t field_2C;
  uint16_t field_2E;
  uint16_t field_30;
  uint8_t field_32;
  uint8_t field_33;
  uint8_t field_34;
  uint8_t field_35;
  uint8_t field_36;
  uint8_t SCRLO_flag;
  uint8_t MPDSP_flag;
  uint8_t MVCAM_flag;
  uint8_t BGMOVIE_flag;
  uint8_t BTLON_flag;
  uint8_t field_3C;
  uint8_t field_3D;
  uint16_t field_3E;
  uint16_t field_40;
  uint16_t field_42;
  uint32_t midi_id;
  uint32_t field_48;
  uint16_t fade_type;
  uint16_t fade_adjustment;
  uint16_t fade_speed;
  short fade_r;
  short fade_g;
  short fade_b;
  uint16_t field_58;
  uint16_t field_5A;
  uint16_t field_5C;
  uint16_t nfade_r;
  uint16_t nfade_g;
  uint16_t nfade_b;
  uint16_t field_id;
  uint16_t field_66;
  uint32_t current_key_input_status;
  uint32_t previous_key_input_status;
  uint16_t field_70;
  uint16_t field_72;
  uint16_t field_74;
  uint16_t field_76;
  uint32_t field_78;
  uint16_t field_7C;
  uint32_t field_80;
  uint16_t field_84;
  uint16_t field_86;
  uint16_t MOVIE_frame;
  ff7_shake_bg_data shake_bg_x;
  ff7_shake_bg_data shake_bg_y;
  uint16_t bg2_scroll_speed_x;
  uint16_t bg2_scroll_speed_y;
  uint16_t bg3_scroll_speed_x;
  uint16_t bg3_scroll_speed_y;
  uint16_t field_AE;
  uint16_t field_B0;
  uint8_t field_B2[64];
  uint8_t background_sprite_layer[64];
  uint16_t field_132;
  uint32_t field_134;
};

struct ff7_field_script_header {
	WORD unknown1;			// Always 0x0502
	char nEntities;			// Number of entities
	char nModels;			// Number of models
	WORD wStringOffset;		// Offset to strings
	WORD nAkaoOffsets;		// Specifies the number of Akao/tuto blocks/offsets
	WORD scale;             // Scale of field. For move and talk calculation (9bit fixed point).
	WORD blank[3];
	char szCreator[8];      // Field creator (never shown)
	char szName[8];			// Field name (never shown)
};

struct field_event_data
{
	WORD field_0;
	WORD padding_2;
	DWORD field_4;
	byte field_8;
	byte padding_9;
	WORD blink_wait_frames;
	vector3<int> model_pos;
	vector3<int> model_initial_pos;
	byte field_24[8];
	int field_2C;
	short movement_ladder_jump_steps;
	short movement_step_idx;
	byte padding_34;
	byte field_35;
	byte rotation_value;
	byte field_37;
	byte rotation_curr_value;
	byte rotation_n_steps;
	byte rotation_step_idx;
	byte rotation_steps_type;
	short rotation_initial;
	short rotation_final;
	short offset_position_x;
	short field_42;
	short offset_initial_x;
	short offset_final_x;
	short offset_position_y;
	short field_4A;
	short offset_initial_y;
	short offset_final_y;
	short offset_position_z;
	short field_52;
	short offset_initial_z;
	short offset_final_z;
	short offset_n_steps;
	short offset_step_idx;
	char offset_movement_phase;
	byte entity_id;
	byte field_5E;
	byte field_5F;
	byte field_60;
	byte field_61;
	byte field_62;
	char movement_type;
	char animation_id;
	byte padding_65;
	short animation_speed;
	short currentFrame;
	short lastFrame;
	short character_id;
	short field_direction_or_collision;
	short movement_phase;
	short collision_radius;
	short talk_radius;
	WORD movement_speed;
	short field_triangle_id;
	short field_7A;
	vector3<int> model_final_pos;
};

struct field_animation_data
{
	int field_0;
	int actor_x;
	int actor_y;
	int actor_z;
	byte field_10[16];
	byte eye_texture_idx;
	byte field_24[336];
	WORD field_174;
	WORD field_176;
	ff7_hrc_polygon_data *anim_frame_object;
	uint32_t *field_17C;
	p_hundred* custom_left_eye_tex;
  p_hundred* static_left_eye_tex;
  p_hundred* custom_right_eye_tex;
  p_hundred* static_right_eye_tex;
};

struct field_gateway
{
	vector3<short> v1_exit_line;
	vector3<short> v2_exit_line;
	vector3<short> destination_vertex;
	SHORT field_id;
	byte unknown[4];
};

struct field_trigger
{
	vector3<short> v_corner1;
	vector3<short> v_corner2;
	byte bg_group_id;
	byte bg_frame_id;
	byte behavior;
	byte sound_id;
};

struct field_arrow
{
	int pos_x;
	int pos_y;
	int pos_z;
	int arrow_type;
};

struct field_camera_range
{
	short left;
	short top;
	short right;
	short bottom;
};

struct field_trigger_header
{
	byte field_name[9];
	byte control_direction;
	short focus_height;
	field_camera_range camera_range;
	byte field_14[4];
	short bg3_width;
	short bg3_height;
	short bg4_width;
	short bg4_height;
	short bg3_pos_x;
	short bg3_pos_y;
	short bg4_pos_x;
	short bg4_pos_y;
	short bg3_speed_x;
	short bg3_speed_y;
	short bg4_speed_x;
	short bg4_speed_y;
	short field_30[4];
	field_gateway gateways[12];
	field_trigger triggers[12];
	byte show_arrow_flag[12];
	field_arrow arrows[12];
};

struct field_arrow_graphics_data
{
	ff7_graphics_object *arrow_graphics_object;
	vector2<float> vertices[4];
	vector2<float> texture_uv[4];
	float z_value;
	int n_shapes;
};

struct field_model_blink_data
{
	byte blink_left_eye_mode;
  byte blink_right_eye_mode;
  char blink_mouth_mode;
  char model_id;
};

struct world_event_data
{
	world_event_data *next_ptr;
	world_event_data *player_data_ptr;
	world_event_data *special_data_ptr;
	vector4<int> position;
	vector4<int> prev_position;
	byte field_28[20];
	short facing;
	byte field_42[2];
	short offset_y;
	short curr_script_position;
	byte field_48[2];
	WORD walkmap_type;
	short direction;
	byte field_4E[2];
	byte model_id;
	byte animation_is_loop_mask;
	byte model_id_special;
	byte animation_frame_idx;
	byte field_54;
	byte movement_speed;
	byte wait_frames;
	byte is_function_running_maybe;
	byte animation_speed;
	byte field_59[3];
	char vertical_speed;
	byte animation_id;
	byte field_5E;
	char vertical_speed_2;
	byte field_60[104];
};

// Snowboard

struct tmd_3_fs_fp
{
  uint8_t r;
  uint8_t g;
  uint8_t b;
  uint8_t mode2;
  uint16_t normal0;
  uint16_t vertex0;
  uint16_t vertex1;
  uint16_t vertex2;
};

struct tmd_3_fs_gp
{
  uint8_t r0;
  uint8_t g0;
  uint8_t b0;
  uint8_t mode2;
  uint8_t r1;
  uint8_t g1;
  uint8_t b1;
  uint8_t pad1;
  uint8_t r2;
  uint8_t g2;
  uint8_t b2;
  uint8_t pad2;
  uint16_t normal0;
  uint16_t vertex0;
  uint16_t vertex1;
  uint16_t vertex2;
};

struct tmd_3_gs_fp
{
  uint8_t r;
  uint8_t g;
  uint8_t b;
  uint8_t mode2;
  uint16_t normal0;
  uint16_t vertex0;
  uint16_t normal1;
  uint16_t vertex1;
  uint16_t normal2;
  uint16_t vertex2;
};

struct tmd_3_gs_gp
{
  uint8_t r0;
  uint8_t g0;
  uint8_t b0;
  uint8_t mode2;
  uint8_t r1;
  uint8_t g1;
  uint8_t b1;
  uint8_t pad1;
  uint8_t r2;
  uint8_t g2;
  uint8_t b2;
  uint8_t pad2;
  uint16_t normal0;
  uint16_t vertex0;
  uint16_t normal1;
  uint16_t vertex1;
  uint16_t normal2;
  uint16_t vertex2;
};

struct tmd_3_ns_fp
{
  uint8_t r;
  uint8_t g;
  uint8_t b;
  uint8_t mode2;
  uint16_t vertex0;
  uint16_t vertex1;
  uint16_t vertex2;
  uint16_t pad;
};

struct tmd_3_ns_gp
{
  uint8_t r0;
  uint8_t g0;
  uint8_t b0;
  uint8_t mode2;
  uint8_t r1;
  uint8_t g1;
  uint8_t b1;
  uint8_t pad1;
  uint8_t r2;
  uint8_t g2;
  uint8_t b2;
  uint8_t pad2;
  uint16_t vertex0;
  uint16_t vertex1;
  uint16_t vertex2;
  uint16_t pad;
};

struct tmd_3_tx_fs_np
{
  uint8_t u0;
  uint8_t v0;
  uint16_t cba;
  uint8_t u1;
  uint8_t v1;
  uint16_t tsb;
  uint8_t u2;
  uint8_t v2;
  uint16_t pad;
  uint16_t normal;
  uint16_t vertex0;
  uint16_t vertex1;
  uint16_t vertex2;
};

struct tmd_3_tx_gs_np
{
  uint8_t u0;
  uint8_t v0;
  uint16_t cba;
  uint8_t u1;
  uint8_t v1;
  uint16_t tsb;
  uint8_t u2;
  uint8_t v2;
  uint16_t pad;
  uint16_t normal;
  uint16_t vertex0;
  uint16_t normal1;
  uint16_t vertex1;
  uint16_t normal2;
  uint16_t vertex2;
};

struct tmd_3_tx_ns_fp
{
  uint8_t u0;
  uint8_t v0;
  uint16_t cba;
  uint8_t u1;
  uint8_t v1;
  uint16_t tsb;
  uint8_t u2;
  uint8_t v2;
  uint16_t pad1;
  uint8_t r;
  uint8_t g;
  uint8_t b;
  uint8_t pad2;
  uint16_t vertex0;
  uint16_t vertex1;
  uint16_t vertex2;
  uint16_t pad;
};

struct tmd_3_tx_ns_gp
{
  uint8_t u0;
  uint8_t v0;
  uint16_t cba;
  uint8_t u1;
  uint8_t v1;
  uint16_t tsb;
  uint8_t u2;
  uint8_t v2;
  uint16_t pad1;
  uint8_t r0;
  uint8_t g0;
  uint8_t b0;
  uint8_t pad2;
  uint8_t r1;
  uint8_t g1;
  uint8_t b1;
  uint8_t pad3;
  uint8_t r2;
  uint8_t g2;
  uint8_t b2;
  uint8_t pad4;
  uint16_t vertex0;
  uint16_t vertex1;
  uint16_t vertex2;
  uint16_t pad;
};

struct tmd_header
{
  int32_t version;
  int32_t flags;
  int32_t nobjects;
};

struct tmd_normal
{
  int16_t nx;
  int16_t ny;
  int16_t nz;
  int16_t pad;
};

struct tmd_primitive_header
{
  uint8_t olen;
  uint8_t ilen;
  uint8_t flag;
  uint8_t mode;
};

struct tmd_primitive_packet
{
  tmd_3_fs_fp tmd3fsfp;
  tmd_3_gs_fp tmd3gsfp;
  tmd_3_fs_gp tmd3fsgp;
  tmd_3_gs_gp tmd3gsgp;
  tmd_3_tx_fs_np tmd3txfsnp;
  tmd_3_tx_gs_np tmd3txgsnp;
  tmd_3_ns_fp tmd3nsfp;
  tmd_3_ns_gp tmd3nsgp;
  tmd_3_tx_ns_fp tmd3txnsfp;
  tmd_3_tx_ns_gp tmd3txnsgp;
};

struct tmd_vertex
{
  int16_t vx;
  int16_t vy;
  int16_t vz;
  int16_t pad;
};

struct tmd_vertex_float
{
	float vx;
	float vy;
	float vz;
	float pad;
};

struct tmd_object
{
  int32_t offsetverts;
  int32_t nverts;
  int32_t offsetnormals;
  int32_t nnormals;
  int32_t offsetprimitives;
  int32_t nprimitives;
  int32_t scale;
  tmd_primitive_header *tmdprimitivelist;
  tmd_primitive_packet *tmdprimitivelistpacket;
  tmd_vertex *tmdvertexlist;
  tmd_normal *tmdnormallist;
};

struct tmdmodel
{
  tmd_header tmdheader;
  tmd_object *tmdobjectlist;
};

struct snowboard_this
{
  DWORD num_objects;
  tmdmodel *model_data;
  DWORD field_8;
  DWORD field_C;
  DWORD field_10;
  float h_scale;
  float v_scale;
};

struct snowboard_object
{
  snowboard_this *_this;
  int actor;
  int actor_num_tmd_blocks;
  char *field_C;
  char *field_10;
  char *field_14;
  char *field_18;
  char *field_1C;
  char *field_20;
  int field_24;
  int field_28;
  int field_2C;
  int field_30;
  int field_34;
  int field_38;
  int field_3C;
  int field_40;
  int field_44;
  int field_48;
  int field_4C;
  int field_50;
  int field_54;
  int field_58;
  int field_5C;
  int field_60;
  int field_64;
  int field_68;
};

struct world_texture_data
{
	int field_0[2];
	short top_left_x;
	short top_left_y;
	uint8_t start_u_multiplier;
	uint8_t start_v_multiplier;
	uint8_t field_E[2];
	short top_right_x;
	short top_right_y;
	uint8_t end_u_multiplier;
	uint8_t field_15[3];
	short bottom_left_x;
	short bottom_left_y;
	uint8_t field_1C;
	uint8_t end_v_multiplier;
	uint8_t field_1E[2];
	short bottom_right_x;
	short bottom_right_y;
	uint8_t field_24[4];
	struct ff7_graphics_object* graphics_object;
	bgra_color_ui8 color;
};

struct world_effect_2d_list_node
{
  world_effect_2d_list_node *next;
  int x;
  int y;
  int z;
  byte field_10[10];
  __int16 rotation_y;
  byte unknown_idx;
  byte field_1C;
  byte apply_rotation_y;
  byte field_1E[5];
  world_texture_data texture_data;
};

struct world_snake_graphics_data
{
	int field_0[2];
    vector2<short> top_left_vertex;
    uint8_t top_left_u;
    uint8_t top_left_v;
    short n_shapes;
    vector2<short> top_right_vertex;
	uint8_t top_right_u;
	uint8_t top_right_v;
	uint8_t field_16[2];
	vector2<short> bottom_left_vertex;
	uint8_t bottom_left_u;
	uint8_t bottom_left_v;
	short delta_x;
	vector2<short> bottom_right_vertex;
	uint8_t bottom_right_u;
	uint8_t bottom_right_v;
	short delta_y;
	struct ff7_graphics_object* graphics_object;
	bgra_color_ui8 color;
};

struct ff7_model_eye_texture_data
{
  int has_eyes;
  char *custom_left_eye_filename;
  char *static_left_eye_filename;
  char *custom_right_eye_filename;
  char *static_right_eye_filename;
};


// --------------- end of FF7 imports ---------------

struct ff7_model_custom_data
{
	int has_mouth;
	int current_mouth_idx;
	char* mouth_tex_filename;
	p_hundred* mouth_tex;
	char *left_eye_tex_filename;
	char *right_eye_tex_filename;
	p_hundred* left_eye_tex;
	p_hundred* right_eye_tex;
};

struct ff7_channel_6_state
{
	float volume;
	float panning;
};

// memory addresses and function pointers from FF7.exe
struct ff7_externals
{
	uint32_t chocobo_fix;
	uint32_t midi_fix;
	void *snowboard_fix;
	uint32_t cdcheck;
	uint32_t cdcheck_enter_sub;
	uint32_t get_inserted_cd_sub;
	DWORD* insertedCD;
	uint8_t* requiredCD;
	struct movie_obj *movie_object;
	void (*movie_sub_415231)(char *);
	void (*sub_665D9A)(struct matrix *, struct nvertex *, struct indexed_primitive *, struct p_hundred *, struct struc_186 *, struct ff7_game_obj *);
	void (*sub_671742)(uint32_t, struct p_hundred *, struct struc_186 *);
	void (*sub_6B27A9)(struct matrix *, struct indexed_primitive *, struct ff7_polygon_set *, struct p_hundred *, struct p_group *, void *, struct ff7_game_obj *);
	void (*sub_68D2B8)(uint32_t, struct ff7_polygon_set *, void *);
	void (*sub_665793)(struct matrix *, uint32_t, struct indexed_primitive *, struct ff7_polygon_set *, struct p_hundred *, struct p_group *, struct ff7_game_obj *);
	void (*matrix3x4)(struct matrix *);
	uint32_t matrix4x3_multiply;
	void *(*sub_6A2865)(void *);
	uint32_t sub_6B26C0;
	uint32_t sub_6B2720;
	uint32_t sub_673F5C;
	struct savemap *savemap;
	struct menu_objects *menu_objects;
	uint32_t magic_thread_start;
	void (*destroy_magic_effects)();
	uint32_t lgp_open_file;
	uint32_t lgp_read_file;
	uint32_t lgp_read;
	uint32_t lgp_get_filesize;
	uint32_t lgp_seek_file;
	int (*lzss_decode)(char*, char*);
	char** field_file_buffer;
	DWORD* field_file_section_ptrs;
	uint32_t* known_field_buffer_size;
	uint32_t* field_resuming_from_battle_CFF268;
	void (*draw_character)(uint32_t, uint32_t, char *, uint32_t, float);
	uint32_t destroy_field_bk;
	uint32_t destroy_field_tiles;
	struct field_layer **field_layers;
	WORD *num_field_entities;
	struct field_object **field_objects;
	uint32_t open_field_file;
	WORD *field_id;
	char *field_file_name;
	uint32_t read_field_file;
	uint32_t battle_enter;
	uint32_t battle_loop;
	battle_actor_data *battle_actor_data;
	DWORD *battle_mode;
	WORD *battle_location_id;
	WORD *battle_formation_id;
	uint32_t battle_sub_429AC0;
	uint32_t battle_sub_42D808;
	uint32_t battle_sub_42D992;
	uint32_t battle_sub_42DAE5;
	uint32_t battle_sub_427C22;
	uint32_t battle_menu_update_6CE8B3;
	uint32_t battle_sub_6DB0EE;
	char* is_battle_paused;
	std::span<uint32_t> battle_menu_state_fn_table;
	std::span<uint32_t> magic_effects_fn_table;
	uint32_t comet2_sub_5A42E5;
	uint32_t comet2_unload_sub_5A4359;
	uint32_t battle_b3ddata_sub_428B12;
	uint32_t graphics_render_sub_68A638;
	uint32_t create_dx_sfx_something;
	uint32_t load_p_file;
	struct polygon_data *(*create_polygon_data)(uint32_t, uint32_t);
	void (*create_polygon_lists)(struct polygon_data *);
	void (*free_polygon_data)(struct polygon_data *);
	uint32_t battle_sub_42A0E7;
	uint32_t load_battle_stage;
	uint32_t load_battle_stage_pc;
	uint32_t read_battle_hrc;
	void (*battle_regular_chdir)(struct battle_chdir_struc *);
	void (*battle_context_chdir)(struct file_context *, struct battle_chdir_struc *);
	void (*swap_extension)(char *, char *, char *);
	void (*destroy_battle_hrc)(uint32_t, struct battle_hrc_header *);
	void (*battle_regular_olddir)(struct battle_chdir_struc *);
	void (*battle_context_olddir)(struct file_context *, struct battle_chdir_struc *);
	uint32_t load_animation;
	uint32_t field_load_animation;
	uint32_t field_load_models;
	uint32_t field_models_eye_to_model;
	ff7_model_eye_texture_data* field_models_eye_blink_buffer;
	DWORD* field_models_data;
	int (*field_load_model_eye_tex)(ff7_model_eye_texture_data *eye_data, field_animation_data *anim_data);
	p_hundred* (*field_load_model_tex)(int idx1, int shademode, char *filename, struc_3 *tex_info, game_obj *game_object);
	void (*field_unload_model_tex)(void* eye_tex);
	void (*create_struc_3_info_sub_67455E)(struc_3 *tex_info);
	uint32_t field_sub_60DCED;
	int (*field_sub_6A2736)(ff7_polygon_set *polygon_set);
	p_hundred** (*field_sub_6A2782)(int idx, p_hundred *hundreddata, ff7_polygon_set *polygon_set);
	uint32_t* field_unk_909288;
	void (*destroy_animation)(struct anim_header *);
	uint32_t context_chdir;
	uint32_t lgp_chdir;
	struct lookup_table_entry **lgp_lookup_tables;
	struct lgp_toc_entry **lgp_tocs;
	struct lgp_folders *lgp_folders;
	uint32_t __read;
	uint32_t load_lgp;
	uint32_t open_lgp_file;
	FILE **lgp_fds;
	uint32_t battle_sub_437DB0;
	uint32_t battle_scene_bin_sub_5D1050;
	int (*engine_load_bin_file_sub_419210)(char *filename, int offset, int size, char **out_buffer, void (*callback)(void));
	uint32_t sub_5CB2CC;
	uint32_t *midi_volume_control;
	uint32_t *midi_initialized;
	uint32_t menu_sub_6CDA83;
	uint32_t menu_sub_6CBD43;
	uint32_t menu_sub_701EE4;
	uint32_t phs_menu_sub;
	uint32_t menu_draw_party_member_stats;
	uint32_t *party_member_to_char_map;
	uint32_t menu_sub_6CB56A;
	uint32_t menu_sub_6FEDB0;
	void *(*menu_sub_6F5C0C)(uint32_t,uint32_t,uint8_t,uint8_t,uint32_t);
	void *(*menu_sub_6FAC38)(uint32_t,uint32_t,uint8_t,uint8_t,uint32_t);
	BOOL (*write_save_file)(char);
	uint32_t *menu_subs_call_table;
	int (*menu_tutorial_sub_6C49FD)();
	BYTE* menu_tutorial_window_state;
	DWORD* menu_tutorial_window_text_ptr;
	uint32_t status_menu_sub;
	uint32_t draw_status_limit_level_stats;
	uint32_t timer_menu_sub;
	DWORD *millisecond_counter;
	char *(*get_kernel_text)(uint32_t, uint32_t, uint32_t);
	uint32_t sub_5CF282;
	uint32_t get_equipment_stats;
	struct weapon_data *weapon_data_array;
	struct armor_data *armor_data_array;
	uint32_t field_sub_6388EE;
	uint32_t field_draw_everything;
	uint32_t field_pick_tiles_make_vertices;
	uint32_t field_layer1_pick_tiles;
	uint32_t *field_layer1_tiles_num;
	uint32_t **field_layer1_palette_sort;
	field_tile **field_layer1_tiles;
	uint32_t field_layer2_pick_tiles;
	uint32_t *field_layer2_tiles_num;
	uint32_t **field_layer2_palette_sort;
	field_tile **field_layer2_tiles;
	uint32_t field_layer3_pick_tiles;
	uint32_t *field_layer3_tiles_num;
	uint32_t **field_layer3_palette_sort;
	field_tile **field_layer3_tiles;
	int *do_draw_layer3_CFFE3C;
	int *field_layer3_flag_CFFE40;
	uint32_t field_layer4_pick_tiles;
	uint32_t *field_layer4_tiles_num;
	uint32_t **field_layer4_palette_sort;
	field_tile **field_layer4_tiles;
	int *do_draw_layer4_CFFEA4;
	int *field_layer4_flag_CFFEA8;
	int *field_layer_CFF1D8;
	uint16_t *field_palette_D00088;
	uint32_t *field_special_y_offset;
	uint32_t *field_bg_multiplier;
	void (*add_page_tile)(float, float, float, float, float, uint32_t, uint32_t);
	double (*field_layer_sub_623C0F)(rotation_matrix*, int, int, int);
	void (*field_draw_gray_quads_644E90)();
	void (*engine_draw_graphics_object)(ff7_graphics_object*, ff7_game_obj*);
	field_trigger_header** field_triggers_header;
	rotation_matrix* field_camera_rotation_matrix_CFF3D8;
	uint32_t field_load_textures;
	void (*field_convert_type2_layers)();
	void (*make_struc3)(uint32_t, struct struc_3 *);
	void (*make_field_tex_header_pal)(struct ff7_tex_header *);
	void (*make_field_tex_header)(struct ff7_tex_header *);
	struct ff7_graphics_object *(*_load_texture)(uint32_t, uint32_t, struct struc_3 *, char *, void *);
	uint32_t read_field_background_data;
	WORD *layer2_end_page;
	uint32_t create_d3d2_indexed_primitive;
	uint32_t destroy_d3d2_indexed_primitive;
	uint32_t enter_main;
	uint32_t kernel_init;
	void (*kernel_load_kernel2)(char* filename);
	uint32_t kernel2_reset_counters;
	uint32_t sub_4012DA;
	uint32_t kernel2_add_section;
	uint32_t kernel2_get_text;
	char **kernel_1to9_sections;
	uint32_t draw_3d_model;
	void (*stack_push)(struct stack *);
	void *(*stack_top)(struct stack *);
	void (*stack_pop)(struct stack *);
	void (*_root_animation)(struct matrix *, struct anim_frame *, struct anim_header *, struct hrc_data *);
	void (*_frame_animation)(uint32_t, struct matrix *, vector3<float> *, struct anim_frame *, struct anim_header *, struct hrc_bone *, struct hrc_data *);
	void (*root_animation)(struct matrix *, struct anim_frame *, struct anim_header *, struct hrc_data *);
	void (*frame_animation)(uint32_t, struct matrix *, vector3<float> *, struct anim_frame *, struct anim_header *, struct hrc_bone *, struct hrc_data *);
	uint32_t *model_mode;
	uint32_t name_menu_sub_6CBD32;
	uint32_t name_menu_sub_719C08;
	uint32_t menu_sub_71894B;
	uint32_t menu_sub_718DBE;
	uint32_t menu_sub_719B81;
	uint32_t set_default_input_settings_save;
	uint32_t keyboard_name_input;
	uint32_t restore_input_settings;
	uint32_t dinput_getdata2;
	uint32_t init_stuff;
	uint32_t init_game;
	uint32_t sub_41A1B0;
	uint32_t init_directinput;
	uint32_t dinput_createdevice_mouse;
	void (*sub_69C69F)(struct matrix *, struct ff7_light *);
	uint32_t coaster_sub_5E9051;
	uint32_t coaster_sub_5EE150;
	uint32_t cleanup_game;
	uint32_t wm_activateapp;
	uint32_t get_gamepad;
	uint32_t update_gamepad_status;
	struct ff7_gamepad_status* gamepad_status;
	uint32_t music_is_locked;
	uint32_t field_initialize_variables;
	uint32_t music_lock_clear_fix;
	uint32_t sub_60DF96;
	uint32_t sub_60EEB2;
	uint32_t open_flevel_siz;
	uint32_t field_map_infos;
	uint32_t sound_operation;
	struct ff7_field_sfx_state* sound_states;
	uint32_t config_menu_sub;
  uint32_t config_initialize;
	uint32_t call_menu_sound_slider_loop_sfx_up;
	uint32_t call_menu_sound_slider_loop_sfx_down;
	uint32_t menu_start;
	uint32_t battle_clear_sound_flags;
	uint32_t swirl_sound_effect;
	uint32_t field_init_player_character_variables;
	uint32_t field_init_event_wrapper_63BCA7;
	uint32_t field_init_event_60BACF;
	uint32_t field_init_field_objects_60BCFA;
	uint32_t execute_opcode;
	uint32_t opcode_goldu;
	uint32_t opcode_dlitm;
	uint32_t opcode_smtra;
	uint32_t opcode_akao;
	uint32_t opcode_akao2;
	uint32_t opcode_bmusc;
	uint32_t opcode_fmusc;
	uint32_t opcode_cmusc;
	uint32_t opcode_canm1_canm2;
	uint32_t opcode_fade;
	uint32_t opcode_shake;
	uint32_t field_opcode_08_sub_61D0D4;
	void (*field_opcode_08_09_set_rotation_61DB2C)(short, byte, byte);
	uint32_t field_opcode_AA_2A_sub_616476;
	uint32_t field_opcode_turn_character_sub_616CB5;
	int (*field_get_rotation_final_636515)(vector3<int>*, vector3<int>*, int*);
	uint32_t field_music_helper;
	uint32_t field_music_helper_sound_op_call;
	uint32_t (*field_music_id_to_midi_id)(int16_t);
	uint32_t field_music_id_to_midi_id_call1;
	uint32_t field_music_id_to_midi_id_call2;
	uint32_t field_music_id_to_midi_id_call3;
	uint32_t opcode_gameover;
	uint32_t opcode_message;
	uint32_t opcode_ask;
	uint32_t opcode_wmode;
	uint32_t opcode_tutor;
	uint32_t opcode_pc;
	uint32_t opcode_kawai;
	uint32_t *sfx_initialized;
	uint32_t sfx_play_summon;
	uint32_t sfx_load_and_play_with_speed;
	ff7_audio_fmt* sfx_fmt_header;
	DWORD *sfx_play_effects_id_channel_6;
	uint32_t sfx_stop_channel_6;
	UINT *sfx_stop_channel_timer_handle;
	uint32_t battle_summon_leviathan_loop;
	uint32_t battle_limit_omnislash_loop;
	void (*reset_game_obj_sub_5F4971)(struct game_obj*);
	uint32_t engine_exit_game_mode_sub_666C78;
	void* (*sub_666C13)(struct game_obj*);
	void* (*sub_670F9B)(void*);
	WORD* word_CC0828;
	BYTE* byte_CC0D89;
	WORD* word_DB958A;
	BYTE* byte_CC164C;
	WORD* word_CC0DC6;
	uint32_t enter_gameover;
	uint32_t exit_gameover;
	void* (*start_gameover)();
	void* (*gameover_sub_6C12B1)();
	uint32_t on_gameover_enter;
	uint32_t on_gameover_exit;
	BYTE (*sub_60B260)();
	BYTE(*sub_767C55)();
	uint32_t field_battle_toggle;
	uint32_t worldmap_battle_toggle;
	uint32_t enter_field;
	uint32_t field_init_viewport_values;
	uint32_t field_loop_sub_63C17F;
	uint32_t field_update_models_positions;
	int (*field_update_single_model_position)(short);
	void (*field_update_model_animation_frame)(short);
	int (*field_check_collision_with_target)(field_event_data*, short);
	int (*field_get_linear_interpolated_value)(int, int, int, int);
	int (*field_get_smooth_interpolated_value)(int, int, int, int);
	void (*field_evaluate_encounter_rate_60B2C6)();
	uint32_t field_animate_3d_models_6392BB;
	uint32_t field_apply_kawai_op_64A070;
	uint32_t sub_64EC60;
	field_model_blink_data* field_model_blink_data_D000C8;
	void (*field_blink_3d_model_649B50)(field_animation_data*, field_model_blink_data*);
	short *field_player_model_id;
	WORD *field_n_models;
	uint32_t field_update_camera_data;
	ff7_camdata** field_camera_data;
	uint32_t sub_40B27B;
	WORD* word_CC0DD4;
	WORD* word_CC1638;
	uint32_t field_init_scripted_bg_movement;
	uint32_t field_update_scripted_bg_movement;
	void (*field_update_background_positions)();
	uint32_t compute_and_submit_draw_gateways_arrows_64DA3B;
	void (*field_submit_draw_arrow_63A171)(field_arrow_graphics_data*);
	uint32_t field_draw_pointer_hand_60D4F3;
	uint32_t field_submit_draw_pointer_hand_60D572;
	uint32_t field_sub_64314F;
	void (*set_world_pos_based_on_player_pos_643C86)(vector2<short>*);
	void(*field_clip_with_camera_range_6438F6)(vector2<short>*);
	uint32_t field_layer3_clip_with_camera_range_643628;
	void (*engine_set_game_engine_delta_values_661976)(int, int);
	uint32_t engine_apply_matrix_product_66307D;
	void (*engine_convert_psx_matrix_to_float_matrix_row_version_661465)(rotation_matrix*, float*);
	void (*engine_apply_rotation_to_transform_matrix_6628DE)(vector3<short>*, rotation_matrix*);
	void (*engine_apply_matrix_product_to_vector_66CF7E)(float*, vector3<float>*, vector3<float>*);
	vector2<int>* field_bg_offset;
	short* field_curr_delta_world_pos_x;
	short* field_curr_delta_world_pos_y;
	short* scripted_world_initial_pos_x;
	short* scripted_world_initial_pos_y;
	short* scripted_world_final_pos_x;
	short* scripted_world_final_pos_y;
	short* scripted_world_move_n_steps;
	short* scripted_world_move_step_index;
	short* field_world_pos_x;
	short* field_world_pos_y;
	short* field_prev_world_pos_x;
	short* field_prev_world_pos_y;
	short* field_cursor_pos_x;
	short* field_cursor_pos_y;
	vector2<int>* field_viewport_xy_CFF204;
	vector2<int>* field_max_half_viewport_width_height_CFF1F4;
	vector2<int>* field_curr_half_viewport_width_height_CFF1FC;
	WORD* field_bg_flag_CC15E4;
	uint32_t field_sub_640EB7;
	uint32_t field_sub_661B68;
	void (*engine_set_game_engine_world_coord_661B23)(int, int);
	void (*engine_sub_67CCDE)(float, float, float, float, float, float, float, ff7_game_obj*);
	uint32_t field_handle_screen_fading;
	uint32_t field_opcode_message_update_loop_630D50;
	uint32_t field_text_box_window_create_631586;
	uint32_t field_text_box_window_opening_6317A9;
	uint32_t field_text_box_window_paging_631945;
	uint32_t field_text_box_window_reverse_paging_632CAA;
	uint32_t field_text_box_window_closing_632EB8;
	char* field_entity_id_list; // 0xCC0960
	DWORD* current_dialog_string_pointer; //0xCBF578
	WORD* current_dialog_message_speed; // 0xCC0418
	WORD* opcode_message_loop_code;
	int (*field_opcode_ask_update_loop_6310A1)(uint8_t, uint8_t, uint8_t, uint8_t, WORD*);
	WORD* opcode_ask_question_code;
	void (*play_midi)(uint32_t);
	WORD *current_movie_frame;
	uint32_t opening_movie_play_midi_call;
	DWORD *opening_movie_music_start_frame;
	uint32_t fps_limiter_swirl;
	uint32_t fps_limiter_battle;
	uint32_t fps_limiter_coaster;
	uint32_t fps_limiter_condor;
	uint32_t fps_limiter_field;
	uint32_t fps_limiter_highway;
	uint32_t fps_limiter_snowboard;
	uint32_t fps_limiter_worldmap;
	uint32_t fps_limiter_chocobo;
	uint32_t fps_limiter_submarine;
	uint32_t fps_limiter_credits;
	uint32_t fps_limiter_menu;
	uint32_t sub_5F5042;
	uint32_t highway_loop_sub_650F36;
	uint32_t sub_779E14;
	uint32_t battle_fps_menu_multiplier;
	DWORD *submarine_minigame_status;
	time_t *submarine_last_gametime;
	DWORD *field_limit_fps;
	DWORD *swirl_limit_fps;
	int16_t (*get_bank_value)(int16_t, int16_t);
	int8_t (*set_bank_value)(int16_t, int16_t, int16_t);
	int8_t (*get_char_bank_value)(int16_t, int16_t);
	uint32_t sub_611BAE;
	byte* current_entity_id;
	byte** field_script_ptr; //0xCBF5E8
	WORD* field_curr_script_position; //0xCC0CF8
	byte* field_model_id_array; //0xCBFB70
	field_event_data** field_event_data_ptr; // 0xCC0B60
	field_animation_data** field_animation_data_ptr; // 0xCFF738
	WORD* wait_frames_ptr; //0xCC0900
	char* animation_type_array; //0xCC0980
	ff7_modules_global_object *modules_global_object; // 0xCC0D88
	ff7_modules_global_object **field_global_object_ptr; // 0xCBF9D8
	void (*sub_767039)(DWORD*,DWORD*,DWORD*);
	uint32_t play_battle_music_call;
	uint32_t (*play_battle_end_music)();
	uint32_t play_battle_music_win_call;
	uint32_t wm_change_music;
	uint32_t wm_play_music_call;
	uint32_t battle_fight_end;
	uint32_t battle_fanfare_music;
	int (*sub_630C48)(int16_t, int16_t, int16_t, int16_t, int16_t);
	uint32_t sub_408074;
	uint32_t sub_60BB58;
	byte** field_level_data_pointer;
	uint32_t sub_408116;
	char *word_CC16E8;
	uint16_t* menu_battle_end_mode;
	uint32_t* pointer_functions_7C2980;
	uint32_t battle_enemy_killed_sub_433BD2;
	uint32_t battle_sub_5C7F94;
	uint32_t menu_battle_end_sub_6C9543;
	uint32_t menu_sub_71FF95, menu_shop_loop, get_materia_gil, opcode_increase_gil_call;
	uint32_t opcode_add_materia_inventory_call, menu_sub_6CBCF3, menu_sub_705D16, menu_sub_6CC17F;
	uint32_t display_battle_action_text_42782A;
	uint32_t display_battle_action_text_sub_6D71FA;
	uint32_t menu_decrease_item_quantity;
	uint32_t opcode_setbyte, opcode_biton;
	uint32_t sub_60FA7D;
	uint32_t menu_sub_7212FB;
	uint32_t load_save_file;
	uint32_t handle_actor_ready;
	WORD* battle_menu_state;
	uint32_t set_battle_menu_state_data;
	uint32_t dispatch_chosen_battle_action;
	uint32_t set_battle_targeting_data;
	uint16_t* issued_action_id;
	byte* issued_command_id;
	byte* issued_action_target_type;
	byte* issued_action_target_index;
	uint32_t field_load_models_atoi;
	uint32_t sub_6499F7;
	DWORD* input_ok_button_status;
	DWORD* input_run_button_status;
	uint32_t sub_62120E;
	int (*field_load_map_trigger_data_sub_6211C3)();
	uint32_t field_fade_screen_sub_63B84B;
	uint32_t field_calc_fade_color_sub_63AE66;

	// battle camera script externals
	uint32_t handle_camera_functions;
	uint32_t set_camera_focal_position_scripts;
	uint32_t set_camera_position_scripts;
	uint32_t add_fn_to_camera_fn_array;
	uint32_t execute_camera_functions;
	uint32_t battle_camera_sub_5C52F8;
	uint32_t battle_camera_sub_5C3E6F;
	uint32_t battle_camera_position_sub_5C3D0D;
	uint32_t battle_camera_position_sub_5C557D;
	uint32_t battle_camera_position_sub_5C5B9C;
	uint32_t battle_camera_focal_sub_5C5F5E;
	uint32_t battle_camera_focal_sub_5C5714;
	uint32_t battle_sub_430DD0;
	uint32_t battle_sub_429D8A;
	uint32_t update_battle_camera_sub_5C20CE;
	uint32_t set_battle_camera_sub_5C22BD;
	uint32_t battle_camera_sub_5C22A9;
	uint32_t compute_interpolation_to_formation_camera;
	uint32_t set_battle_camera_sub_5C2350;
	std::span<bcamera_fn_data> camera_fn_data;
	std::span<bcamera_position> battle_camera_position;
	std::span<bcamera_position> battle_camera_focal_point;
	std::span<uint32_t> camera_fn_array;
	byte* battle_camera_focal_scripts_8FEE30;
	byte* battle_camera_position_scripts_8FEE2C;
	DWORD* battle_camera_global_scripts_9A13BC;
	DWORD* battle_camera_position_scripts_9010D0;
	DWORD* battle_camera_focal_scripts_901270;
	byte* battle_camera_script_index;
	DWORD* battle_camera_script_offset;
	WORD* camera_fn_index;
	WORD* camera_fn_counter;
	vector3<short>* g_battle_camera_position;
	vector3<short>* g_battle_camera_focal_point;
	std::span<formation_camera> formation_camera;
	byte* curr_formation_camera_idx;
	byte* battle_enter_frames_to_wait;
	byte* g_variation_index;
	byte* is_camera_moving_BFB2DC;

	// animation script externals
	uint32_t battle_sub_42A5EB;
	uint32_t battle_sub_42E275;
	uint32_t battle_sub_42E34A;
	uint32_t battle_sub_5B9EC2;
	uint32_t battle_sub_5BD5E9;
	uint32_t run_summon_animations_script_5C1B81;
	uint32_t run_summon_animations_script_sub_5C1D9A;
	uint32_t run_animation_script;
	uint32_t add_fn_to_effect100_fn;
	uint32_t execute_effect100_fn;
	uint32_t add_fn_to_effect60_fn;
	uint32_t execute_effect60_fn;
	uint32_t add_fn_to_effect10_fn;
	uint32_t execute_effect10_fn;
	uint32_t battle_enemy_death_5BBD24;
	uint32_t battle_enemy_death_sub_5BBE32;
	uint32_t battle_iainuki_death_5BCAAA;
	uint32_t battle_iainuki_death_sub_5BCBB8;
	uint32_t battle_boss_death_5BC48C;
	uint32_t battle_boss_death_sub_5BC6ED;
	uint32_t battle_boss_death_sub_5BC5EC;
	uint32_t battle_boss_death_call_5BD436;
	uint32_t battle_melting_death_5BC21F;
	uint32_t battle_melting_death_sub_5BC32D;
	uint32_t battle_disintegrate_2_death_5BBA82;
	uint32_t battle_disintegrate_2_death_sub_5BBBDE;
	uint32_t battle_morph_death_5BC812;
	uint32_t battle_morph_death_sub_5BC920;
	uint32_t battle_disintegrate_1_death_5BBF31;
	uint32_t battle_disintegrate_1_death_sub_5BC04D;
	uint32_t battle_sub_42C0A7;
	uint32_t run_summon_animations_5C0E4B;
	uint32_t vincent_limit_fade_effect_sub_5D4240;
	uint32_t battle_sub_5BD96D;
	uint32_t battle_sub_425D29;
	uint32_t display_battle_damage_5BB410;
	uint32_t battle_sub_5BDA0F;
	uint32_t get_n_frames_display_action_string;
	uint32_t battle_sub_434C8B;
	uint32_t battle_sub_435D81;
	uint32_t battle_sub_426DE3;
	uint32_t battle_sub_426941;
	uint32_t battle_sub_426899;
	uint32_t battle_sub_4267F1;
	uint32_t battle_sub_5C1C8F;
	uint32_t battle_move_character_sub_426A26;
	uint32_t battle_move_character_sub_42739D;
	uint32_t battle_move_character_sub_426F58;
	uint32_t battle_move_character_sub_4270DE;
	uint32_t handle_aura_effects_425520;
	uint32_t run_aura_effects_5C0230;
	uint32_t limit_break_aura_effects_5C0572;
	uint32_t enemy_skill_aura_effects_5C06BF;
	uint32_t handle_summon_aura_5C0850;
	uint32_t summon_aura_effects_5C0953;
	uint32_t battle_sub_5C18BC;
	uint32_t battle_sub_4276B6;
	uint32_t battle_sub_4255B7;
	uint32_t battle_sub_425E5F;
	uint32_t battle_sub_5BCF9D;
	uint32_t battle_sub_425AAD;
	uint32_t battle_sub_427A6C;
	uint32_t battle_sub_427AF1;
	uint32_t battle_sub_427737;
	uint32_t battle_sub_4277B1;
	uint32_t battle_sub_5BCD42;
	uint32_t battle_sub_5BD050;
	uint32_t battle_smoke_move_handler_5BE4E2;
	uint32_t battle_sub_42A72D;
	void (*battle_play_sfx_sound_430D32)(uint16_t, short, char);
	uint32_t run_tifa_limit_effects;
	uint32_t tifa_limit_1_2_sub_4E3D51;
	uint32_t tifa_limit_2_1_sub_4E48D4;
	uint32_t aerith_limit_2_1_sub_45B0CF;
	uint32_t cloud_limit_2_2_sub_467256;
	uint32_t vincent_limit_satan_slam_camera_45CF2A;
	uint32_t barret_limit_4_1_camera_4688A2;
	uint32_t barret_limit_4_1_model_movement_4698EF;
	int *barret_limit_4_1_actor_id;
	uint32_t aerith_limit_4_1_camera_473CC2;
	uint32_t run_chocomog_movement_50B1A3;
	uint32_t run_chocomog_camera_509B10;
	uint32_t run_fat_chocobo_movement_509692;
	uint32_t run_fat_chocobo_camera_507CA4;
	uint32_t run_fat_chocobo_camera_shake_5095F5;
	uint32_t run_shiva_movement_592538;
	uint32_t run_shiva_camera_58E60D;
	uint32_t run_ifrit_movement_596702;
	uint32_t run_ifrit_camera_592A36;
	uint32_t run_ramuh_camera_597206;
	uint32_t run_titan_camera_59B4B0;
	uint32_t run_odin_gunge_movement_4A584D;
	uint32_t run_odin_gunge_camera_4A0F52;
	uint32_t run_odin_steel_movement_4A6CB8;
	uint32_t run_odin_steel_sub_4A9908;
	uint32_t run_odin_steel_camera_4A5D3C;
	uint32_t run_leviathan_camera_5B0716;
	uint32_t run_bahamut_movement_49ADEC;
	uint32_t run_bahamut_camera_497A37;
	uint32_t run_kujata_camera_4F9A4D;
	uint32_t run_alexander_movement_5078D8;
	uint32_t run_alexander_camera_501637;
	uint32_t run_phoenix_main_loop_516297;
	uint32_t run_phoenix_movement_518AFF;
	uint32_t run_phoenix_camera_515238;
	uint32_t run_bahamut_neo_main_48C2A1;
	uint32_t run_bahamut_neo_movement_48D7BC;
	uint32_t run_bahamut_neo_camera_48C75D;
	uint32_t run_hades_camera_4B65A8;
	uint32_t run_typhoon_camera_4D594C;
	uint32_t run_typhoon_sub_4DA182;
	uint32_t run_bahamut_zero_main_loop_484A16;
	uint32_t run_bahamut_zero_movement_48BBFC;
	uint32_t run_bahamut_zero_camera_483866;
	uint32_t bahamut_zero_draw_bg_effect_sub_4859AA;
	uint32_t bahamut_zero_bg_star_graphics_data_7F6748;
	uint32_t run_summon_kotr_sub_476857;
	uint32_t run_summon_kotr_main_loop_478031;
	std::array<uint32_t, 13> run_summon_kotr_knight_script;
	void(*add_kotr_camera_fn_to_effect100_fn_476AAB)(DWORD, DWORD, WORD);
	uint32_t run_kotr_camera_476AFB;
	vector3<int>* (*battle_sub_661000)(int);
	void (*engine_set_game_engine_rot_matrix_663673)(rotation_matrix*);
	void (*engine_set_game_engine_position_663707)(rotation_matrix*);
	void (*engine_apply_translation_with_delta_662ECC)(vector3<short>*, vector3<int>*, int*);
	uint32_t run_chocobuckle_main_loop_560C32;
	uint32_t run_confu_main_loop_5600BE;
	uint32_t battle_escape_magic_init_data_5D59B0;
	uint32_t battle_escape_magic_loop_5D602A;
	uint32_t bomb_blast_black_bg_effect_537427;
	uint32_t goblin_punch_flash_573291;
	uint32_t roulette_skill_main_loop_566287;
	uint32_t death_sentence_main_loop_5661A0;
	uint32_t death_kill_sub_loop_562C60;
	uint32_t death_kill_sub_loop_5624A5;
	uint32_t enemy_atk_camera_sub_439EE0;
	uint32_t enemy_atk_camera_sub_44A7D2;
	uint32_t enemy_atk_camera_sub_44EDC0;
	uint32_t enemy_atk_camera_sub_4522AD;
	uint32_t enemy_atk_camera_sub_457C60;
	uint32_t battle_update_3d_model_data;
	uint32_t battle_animate_material_texture;
	uint32_t battle_animate_texture_spt;
	rotation_matrix* (*get_global_model_matrix_buffer_66100D)();
	struc_84* (*get_draw_chain_68F860)(struc_49*, graphics_instance*);
	p_hundred* (*battle_sub_5D1AAA)(int, ff7_polygon_set*);
	int (*get_alpha_from_transparency_429343)(int);
	color_ui8 (*get_stored_color_66101A)();
	void (*battle_sub_68CF75)(char, struc_173*);
	void (*create_rot_matrix_from_word_matrix_6617E9)(rotation_matrix*, matrix*);
	struc_84* (*get_draw_chain_671C71)(ff7_graphics_object*);
	void (*battle_sub_6CE81E)();
	std::span<battle_model_state> g_battle_model_state;
	std::span<battle_model_state_small> g_small_battle_model_state;
	std::span<uint32_t> effect100_array_fn;
	std::span<effect100_data> effect100_array_data;
	uint16_t* effect100_counter;
	uint16_t* effect100_array_idx;
	std::span<uint32_t> effect60_array_fn;
	std::span<effect60_data> effect60_array_data;
	uint16_t* effect60_counter;
	uint16_t* effect60_array_idx;
	std::span<uint32_t> effect10_array_fn;
	std::span<effect10_data> effect10_array_data;
	uint16_t* effect10_counter;
	uint16_t* effect10_array_idx;
	short* effect10_array_data_8FE1F6;
	std::array<byte*, 14> animation_script_pointers;
	byte* g_is_effect_loading;
	byte* g_is_battle_paused;
	byte* g_actor_idle_scripts;
	byte* g_script_wait_frames;
	std::span<int*> g_script_args;
	byte* special_actor_id;
	int* field_battle_BFB2E0;
	float* field_float_battle_7B7680;
	byte* field_byte_DC0E11;
	byte* field_battle_byte_BF2E1C;
	byte* field_battle_byte_BE10B4;
	short* resting_Y_array_data;
	WORD* field_odin_frames_AEEC14;
	palette_extra* palette_extra_data_C06A00;
	ff7_game_engine_data** global_game_engine_data;
	std::span<uint32_t> limit_break_effects_fn_table;
	std::span<uint32_t> enemy_atk_effects_fn_table;
	std::span<uint32_t> enemy_skill_effects_fn_table;
	byte* byte_BCC788;
	vector3<int>** ifrit_vector3_int_ptr_BCC6A8;
	vector3<short>* battle_ifrit_model_position;
	rotation_matrix* ifrit_rot_matrix_BCC768;
	uint32_t pollensalta_cold_breath_atk_enter_sub_5474F0;
	uint32_t pollensalta_cold_breath_atk_main_loop_5476B0;
	uint32_t pollensalta_cold_breath_atk_draw_bg_effect_547B94;
	uint32_t pollensalta_cold_breath_atk_white_dot_effect_547D56;
	void (*pollensalta_cold_breath_atk_draw_white_dots_547E75)(short);
	std::span<vector4<short>> pollensalta_cold_breath_white_dots_pos;
	short* pollensalta_cold_breath_white_dot_rgb_scalar;
	uint32_t pollensalta_cold_breath_bg_texture_ctx;
	uint32_t pandora_box_skill_draw_bg_flash_effect_568371;

	// battle menu
	uint32_t display_battle_menu_6D797C;
	void (*display_tifa_slots_handler_6E3135)();
	uint32_t battle_draw_text_ui_graphics_objects_call;
	uint32_t battle_draw_box_ui_graphics_objects_call;
	void (*battle_draw_call_42908C)(int, int);
	uint32_t battle_set_do_render_menu_call;
	uint32_t battle_set_do_render_menu;
	int *g_do_render_menu;
	uint32_t battle_sub_42F3E8;
	uint32_t battle_handle_player_mark_5B9C8E;
	uint32_t battle_handle_status_effect_anim_5BA7C0;
	uint32_t battle_update_targeting_info_6E6291;
	byte *targeting_actor_id_DC3C98;
	uint32_t battle_menu_closing_window_box_6DAEF0;

	//battle 3d battleground
	uint32_t update_3d_battleground;
	void (*battleground_shake_train_42F088)();
	uint32_t battleground_vertical_scrolling_42F126;
	uint32_t battleground_midgar_flashback_rain_5BDC4F;

	// battle dialogue
	uint32_t battle_sub_42CBF9;
	uint32_t add_text_to_display_queue;
	uint32_t update_display_text_queue;
	uint32_t set_battle_text_active;
	uint32_t battle_sfx_play_effect_430D14;
	int (*battle_sub_66C3BF)();
	uint32_t battle_sub_43526A;
	uint32_t battle_sub_5C8931;
	uint32_t run_enemy_ai_script;
	uint32_t enqueue_script_action;
	uint32_t battle_sub_41B577;
	uint32_t battle_sub_41CCB2;
	std::span<battle_text_data> battle_display_text_queue;
	battle_ai_context *battle_context;
	std::span<battle_anim_event> anim_event_queue;
	byte* anim_event_index;
	int* g_is_battle_running_9AD1AC;
	WORD* field_battle_word_BF2E08;
	WORD* field_battle_word_BF2032;
	byte* g_active_actor_id;

	// world stuff
	uint32_t world_mode_loop_sub_74DB8C;
	uint32_t world_exit_74BD77;
	uint32_t world_loop_74BE49;
	void (**world_dword_DE68FC)();
	void (*world_exit_destroy_graphics_objects_75A921)();
	uint32_t world_init_variables_74E1E9;
	uint32_t world_sub_7641A7;
	void (*world_init_load_wm_bot_block_7533AF)();
	uint32_t run_world_event_scripts;
	uint32_t run_world_event_scripts_system_operations;
	uint32_t world_animate_all_models;
	uint32_t world_animate_single_model;
	uint32_t run_world_snake_ai_script_7562FF;
	uint32_t update_world_snake_position_7564CD;
	uint32_t is_update_snake_enabled_7562A9;
	uint32_t animate_world_snake_75692A;
	bool (*sub_753366)(short, short);
	void (*world_draw_snake_texture_75D544)(short, short, short, short, world_snake_graphics_data*, short);
	vector4<short>** world_snake_data_position_ptr_E2A18C;
	vector4<short>* world_snake_data_position_E29F80;
	vector4<short>* snake_position_size_of_array_E2A100;
	world_snake_graphics_data* world_snake_graphics_data_E2A490;
	world_snake_graphics_data* world_snake_graphics_data_end_E2A6D0;
	uint32_t world_sub_75EF46;
	uint32_t world_sub_767540;
	uint32_t world_sub_767641;
	uint32_t world_opcode_message_sub_75EE86;
	uint32_t world_opcode_ask_sub_75EEBB;
	uint32_t world_opcode_message;
	uint32_t world_opcode_ask;
	uint32_t world_text_box_window_opening_769A66;
	uint32_t world_text_box_window_paging_769C02;
	uint32_t world_text_box_reverse_paging_76ABE9;
	uint32_t world_text_box_window_closing_76ADF7;
	uint32_t world_compute_all_models_data_76323A;
	uint32_t world_compute_3d_model_data_76328F;
	uint32_t world_sub_74D319;
	uint32_t world_sub_762F9A;
	int (*get_world_encounter_rate)();
	int (*pop_world_script_stack)();
	uint32_t world_update_player_74EA48;
	int (*world_get_player_model_id)();
	int (*world_get_current_key_input_status)();
	int (*world_get_player_walkmap_type)();
	int (*world_get_player_walkmap_region)();
	void(*world_sub_753D00)(vector3<short>*, short);
	void(*world_update_model_movement_762E87)(int, int);
	bool (*world_is_player_model_bitmask)(int);
	void (*world_copy_player_pos_to_param_762798)(vector4<int>*);
	void (*world_set_current_entity_to_player_entity)();
	void (*world_add_y_pos_to_current_entity_761F22)(int);
	void (*world_add_delta_movement_due_to_bridge_7591C2)(int*, int*);
	void (*world_current_entity_model_collision_detection_with_other_models_76296E)();
	int (*world_get_unknown_flag_75335C)();
	short (*world_get_minimap_mask)();
	void (*world_set_minimap_mask)(short);
	void (*world_set_facing_and_direction_to_current_entity)(short);
	bool (*world_is_current_entity_animated_761F44)();
	void (*world_sub_74D6BB)();
	void (*world_sub_74D6F6)();
	void (*world_sub_762F75)(short, short, short);
	void (*world_run_special_opcode_7640BC)(int);
	void (*world_set_camera_fade_speed_755B97)(int);
	void (*world_set_world_control_lock_74D438)(int, int);
	void (*world_sub_74C980)(int);
	void (*world_sub_753BE8)();
	void (*world_music_set_frequency_all_channels_75E6A8)(byte, char);
	void (*world_sfx_play_or_stop_75E6CC)(int);
	void (*world_set_camera_view_type_74D3D1)(int);
	uint32_t world_update_camera_74E8CE;
	int (*world_snowstorm_get_camera_movement_758B12)(int, int);
	int (*world_get_camera_rotation_x_74F916)();
	int* world_highwind_height_lowerbound_DF5420;
	int* world_mode_E045E4;
	int* previous_player_direction_DF5434;
	int* world_is_control_enabled_DE6B5C;
	short* world_special_delta_movement_DE6A18;
	int* world_y_player_pos_flag_DE6A14;
	int* world_unk_rotation_value_E045E0;
	world_event_data** world_event_current_entity_ptr_E39AD8;
	world_event_data** world_event_current_entity_ptr_E3A7CC;
	int* world_progress_E28CB4;
	int* is_wait_frames_zero_E39BC0;
	int* world_prev_key_input_status_DFC470;
	int* world_map_type_E045E8;
	int* world_movement_multiplier_DFC480;
	int* world_camera_var1_DF542C;
	int* world_camera_var2_DE6B4C;
	int* world_camera_var3_DE6A0C;
	int* world_camera_viewtype_DFC4B4;
	int* world_camera_front_DFC484;
	int* world_camera_rotation_y_DFC474;
	int* world_camera_position_z_DFC478;
	int* world_camera_delta_y_DE6A04;
	int* world_camera_rotation_z_DE6B70;
	short* world_current_camera_rotation_x_DE7418;
	std::span<short> world_camera_x_rotation_array_E37120;
	rotation_matrix* world_camera_position_matrix_DE6A20;
	rotation_matrix* world_camera_direction_matrix_DFC448;
	vector4<int>* world_player_pos_E04918;
	uint32_t world_sub_75A1C6;
	uint32_t world_load_graphics_objects_75A5D5;
	uint32_t world_init_load_map_meshes_graphics_objects_75A283;
	void (*world_wm0_overworld_draw_all_74C179)();
	void (*world_wm2_underwater_draw_all_74C3F0)();
	void (*world_wm3_snowstorm_draw_all_74C589)();
	uint32_t world_draw_all_3d_model_74C6B0;
	uint32_t world_draw_fade_quad_75551A;
	uint32_t world_sub_75079D;
	uint32_t world_sub_751EFC;
	uint32_t world_sub_75C02B;
	uint32_t world_sub_75C0FD;
	uint32_t world_sub_75C283;
	uint32_t world_sub_75F0AD;
	uint32_t world_sub_75042B;
	uint32_t world_culling_bg_meshes_75F263;
	uint32_t world_submit_draw_bg_meshes_75F68C;
	uint32_t world_compute_skybox_data_754100;
	uint32_t world_submit_draw_clouds_and_meteor_7547A6;
	int (*sub_74C9A5)();
	int* is_meteor_flag_on_E2AAE4;
	uint32_t engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF;
	void (*engine_apply_4x4_matrix_product_between_matrices_66C6CD)(struct matrix *, struct matrix *, struct matrix *);
	void (*world_copy_position_75042B)(vector4<int>* a1);
	int (*get_world_camera_front_rot_74D298)();
	void (*engine_apply_rotation_to_rot_matrix_662AD8)(vector3<short>*, transform_matrix*);
	short (*world_get_world_current_camera_rotation_x_74D3C6)();
	int (_stdcall *world_submit_draw_effects_75C283)(world_texture_data*, int, vector3<short>*, short);
	world_effect_2d_list_node** dword_E35648;
	byte* byte_96D6A8;

	uint32_t swirl_main_loop;
	uint32_t swirl_loop_sub_4026D4;
	uint32_t swirl_enter_40164E;
	uint32_t swirl_enter_sub_401810;

	uint32_t field_culling_model_639252;
	uint32_t field_sub_63AC66;
	void (*field_sub_63AC3F)(int, int, int, int);
	uint32_t battle_draw_quad_5BD473;
	uint32_t battle_sub_5895E0;
	uint32_t battle_sub_589827;
	uint32_t battle_sub_58AC59;
	uint32_t battle_sub_58ACB9;
	uint32_t ifrit_sub_595A05;
	void (*engine_draw_sub_66A47E)(int);
	int* battle_viewport_height;
	uint32_t neo_bahamut_main_loop_48DA7A;
	uint32_t neo_bahamut_effect_sub_490F2A;
	uint32_t odin_gunge_effect_sub_4A4BE6;
	uint32_t odin_gunge_effect_sub_4A3A2E;
	uint32_t typhoon_effect_sub_4DB15F;
	uint32_t typhoon_sub_4D6FF8;
	uint32_t typhoon_effect_sub_4D7044;
	uint32_t fat_chocobo_sub_5096F3;
	uint32_t barret_limit_3_1_sub_4700F7;
	uint32_t shadow_flare_draw_white_bg_57747E;
	uint32_t credits_submit_draw_fade_quad_7AA89B;
	uint32_t menu_submit_draw_fade_quad_6CD64E;
	int (*get_button_pressed)(int);
	uint32_t credits_main_loop;
	uint32_t highway_submit_fade_quad_659532;
	uint32_t chocobo_enter_76D597;
	uint32_t chocobo_initialize_variables_76BAFD;
	uint32_t chocobo_init_viewport_values_76D320;
	uint32_t chocobo_submit_draw_fade_quad_77B1CE;
	uint32_t chocobo_submit_draw_water_quad_77A7D0;
	void(*generic_submit_quad_graphics_object_671D2A)(int, int, int, int, int, int, float, DWORD*) ;
	byte* chocobo_fade_quad_data_97A498;

	// snowboard
	uint32_t snowboard_enter_sub_722C10;
	uint32_t snowboard_loop_sub_72381C;
	uint32_t snowboard_exit_sub_722C52;
	uint32_t snowboard_draw_sky_and_mountains_72DAF0;
	uint32_t snowboard_submit_draw_sky_quad_graphics_object_72E31F;
	float* snowboard_sky_quad_pos_x_7B7DB8;
	uint32_t snowboard_submit_draw_black_quad_graphics_object_72DD94;
	uint32_t snowboard_submit_draw_white_fade_quad_graphics_object_72DD53;
	uint32_t snowboard_submit_draw_opaque_quad_graphics_object_72DDD5;
	uint32_t snowboard_parse_model_vertices_732159;
	uint32_t sub_735220;
	uint32_t sub_735332;
	char* (*sub_7322D6)(tmd_primitive_packet*, int, int);
	char* (*sub_732429)(tmd_primitive_packet*, int, int);
	char* (*sub_732BB9)(tmd_primitive_packet*, int, int);
	char* (__thiscall *sub_732546)(snowboard_this*, tmd_primitive_packet*, int, int);
	matrix* (__thiscall *sub_733479)(void*, const matrix*);
	point4d* (__thiscall *sub_733564)(void*, vector3<float>*, point4d*);
	DWORD* snowboard_global_object_off_926290;

	// condor
	uint32_t condor_enter;
	uint32_t condor_exit;
	uint32_t sub_5F7756;
	uint32_t sub_5F4273;
	uint32_t sub_5F342C;
	DWORD* condor_uses_lgp;
};

uint32_t ff7gl_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *hundred_data, struct p_group *group_data, struct polygon_data *polygon_data, struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object);
void ff7gl_field_78(struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object);
void ff7_init_hooks(struct game_obj *_game_object);
struct ff7_gfx_driver *ff7_load_driver(void *game_object);
````

## File: src/field.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <imgui.h>
#include <stdint.h>

#include "globals.h"
#include "common.h"
#include "patch.h"
#include "log.h"
#include "utils.h"

#include "field.h"

#include "ff7/field/model.h"

// Data for debug map jumps
int target_triangle = 0;
int target_field = 0;
byte map_patch_storage[7] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // Place to store the original bytes so that we can patch back after a map jump
bool map_changing = false;

// FF7 only
int (*opcode_old_kawai)();
int (*opcode_old_pc)();

byte get_field_bank_value(int16_t bank)
{
	switch(bank)
	{
	case 0:
		return (get_field_parameter<byte>(0) >> 4) & 0xF;
	case 1:
		return get_field_parameter<byte>(0) & 0xF;
	case 2:
		return (get_field_parameter<byte>(1) >> 4) & 0xF;
	case 3:
		return get_field_parameter<byte>(1) & 0xF;
	case 4:
		return (get_field_parameter<byte>(2) >> 4) & 0xF;
	case 5:
		return get_field_parameter<byte>(2) & 0xF;
	default:
		return 0;
	}
}

int opcode_kawai_eye_texture() {
	byte num_params = get_field_parameter<byte>(0);
	byte subcode = get_field_parameter<byte>(1);

	if (subcode == 0x0) // EYETX
	{
		byte left_eye_index = get_field_parameter<byte>(2);
		byte right_eye_index = get_field_parameter<byte>(3);
		byte mouth_index = get_field_parameter<byte>(4);

		field_animation_data* animation_data = *ff7_externals.field_animation_data_ptr;
		byte curr_entity_id = *ff7_externals.current_entity_id;
		byte curr_model_id = ff7_externals.field_model_id_array[curr_entity_id];
		byte curr_eye_index = animation_data[curr_model_id].eye_texture_idx;

		ff7::field::ff7_model_data[curr_model_id].current_mouth_idx = mouth_index;

		if (trace_all || trace_opcodes)
		{
			ffnx_trace("opcode[KAWAI]: num_params=%u,subcode=0x%x,left_eye_index=%u,right_eye_index=%u,mouth_index=%u\n", num_params, subcode, left_eye_index, right_eye_index, mouth_index);
			ffnx_trace("subcode[EYETX]: curr_entity_id=%u,curr_model_id=%u,curr_eye_index=%u\n", curr_entity_id, curr_model_id, curr_eye_index);
		}
	}

	return opcode_old_kawai();
}

int opcode_pc_map_change() {
	if (map_changing)
	{
		byte* level_data = *ff7_externals.field_level_data_pointer;
		uint32_t walkmesh_offset = *(uint32_t*)(level_data + 0x16);
		vertex_3s* triangle_data = (vertex_3s*)(level_data + walkmesh_offset + 8 + 24 * target_triangle);

		// Calculates the centroid of the walkmesh triangle
		int x = (triangle_data[0].x + triangle_data[1].x + triangle_data[2].x) / 3;
		int y = (triangle_data[0].y + triangle_data[1].y + triangle_data[2].y) / 3;

		ff7_externals.modules_global_object->field_model_pos_x = x;
		ff7_externals.modules_global_object->field_model_pos_y = y;
		ff7_externals.modules_global_object->field_model_triangle_id = target_triangle;
		map_changing = false;
	}

	return opcode_old_pc();
}

int field_calc_window_pos(int16_t WINDOW_ID, int16_t X, int16_t Y, int16_t W, int16_t H)
{
	return ff7_externals.sub_630C48(WINDOW_ID, X, ff7_field_center ? Y + 8 : Y, W, H);
}

int ff7_calc_opcode_type_2_fade_color(int16_t r, int16_t g, int16_t b)
{
	uint8_t fade_b = (256 - b) * (256 - ff7_externals.modules_global_object->fade_adjustment / 2) / 256;
	uint8_t fade_g = (256 - g) * (256 - ff7_externals.modules_global_object->fade_adjustment / 2) / 256;
	uint8_t fade_r = (256 - r) * (256 - ff7_externals.modules_global_object->fade_adjustment / 2) / 256;

	return 0xFF000000 | (fade_r << 16) | (fade_g << 8) | fade_b;
}

int ff8_field_init_from_file(int unk1, int unk2, int unk3, int unk4)
{
	int ret = ff8_externals.field_scripts_init(unk1, unk2, unk3, unk4);

	// Current triangle id address changes on each field on FF8
	// Loop through objects until we find the one that has a valid triangle ID
	for(int i = 0; i < MAXBYTE; i++)
	{
		common_externals.current_triangle_id = (int16_t*)(*ff8_externals.game_mode_obj_1D9CF88 + 0x264 * i + 0x1FA);
		if (*common_externals.current_triangle_id != 0) break;
	}

	return ret;
}

void field_init()
{
	if (!ff8)
	{
		// Proxies the PC field opcode to reposition the player after a forced map change
		opcode_old_pc = (int (*)())ff7_externals.opcode_pc;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0xA0], (DWORD)&opcode_pc_map_change);

		opcode_old_kawai = (int (*)())ff7_externals.opcode_kawai;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x28], (DWORD)&opcode_kawai_eye_texture);

		// Proxy the window calculation formula so we can offset windows vertically
		replace_call_function(common_externals.execute_opcode_table[0x50] + 0x174, field_calc_window_pos);

		// Proxy FADE opcode color calculation
		byte opcode_fade_patch[] = {0x0F, 0xBF, 0x45, 0x10, 0x50, 0x0F, 0xBF, 0x45, 0x0C, 0x50, 0x0F, 0xBF, 0x45, 0x08, 0x50, 0xE8, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xC4, 0x0C};
		memcpy_code(ff7_externals.field_calc_fade_color_sub_63AE66 + 0x244, opcode_fade_patch, sizeof(opcode_fade_patch));
		memset_code(ff7_externals.field_calc_fade_color_sub_63AE66 + 0x244 + sizeof(opcode_fade_patch), 0x90, 0xE1 - sizeof(opcode_fade_patch));
		replace_call_function(ff7_externals.field_calc_fade_color_sub_63AE66 + 0x244 + 0xF, ff7_calc_opcode_type_2_fade_color);

		// Init custom eyes and mouths structs
		for(int i = 0; i < FF7_MAX_NUM_MODEL_ENTITIES; i++)
		{
			ff7::field::ff7_model_data[i].left_eye_tex_filename = (char*)external_calloc(sizeof(char), sizeof(basedir) + 1024);
			ff7::field::ff7_model_data[i].right_eye_tex_filename = (char*)external_calloc(sizeof(char), sizeof(basedir) + 1024);
			ff7::field::ff7_model_data[i].current_mouth_idx = 0;
			ff7::field::ff7_model_data[i].mouth_tex_filename = (char*)external_calloc(sizeof(char), sizeof(basedir) + 1024);
			ff7::field::ff7_model_data[i].mouth_tex = NULL;
		}
	}
	else
	{
		// Proxy the field init file read
		replace_call_function(ff8_externals.read_field_data + (JP_VERSION ? 0xEDC : 0xE49), ff8_field_init_from_file);
	}
}

int map_jump_ff7()
{
	// Restores the original field update code
	memcpy_code(common_externals.update_entities_call, map_patch_storage, 7);

	byte* current_executing_code = get_field_parameter_address<byte>(-1);

	// Inject MAPJUMP coordinates
	memset(current_executing_code, 0, 10);
	*(current_executing_code) = 0x60; // MAPJUMP
	*(WORD*)(current_executing_code + 1) = target_field;

	int (*mapjump)() = (int (*)())common_externals.execute_opcode_table[0x60];
	return mapjump();
}

int map_jump_ff8(byte* entity, int arg)
{
	// Forces the entity to be able to trigger a map jump
	entity[0x175] |= 0x01;

	// Restores the original field update code
	memcpy_code(common_externals.update_entities_call, map_patch_storage, 7);
	map_changing = false;

	// Executes the field script to change map
	int (**field_functions)(byte*, uint32_t) = (int (**)(byte*, uint32_t))common_externals.execute_opcode_table;
	field_functions[0xB9](entity, 0); // KILLTIMER
	field_functions[0x07](entity, target_field); // PSHN_L
	field_functions[0x07](entity, target_triangle); // PSHN_L
	return field_functions[0x5C](entity, 0); // MAPJUMP
}

void field_debug(bool *isOpen)
{
	if (!ImGui::Begin("Field Debug", isOpen, ImGuiWindowFlags_::ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::End();
		return;
	}

	if (getmode_cached()->driver_mode != MODE_FIELD)
	{
		ImGui::Text("Not currently on a field.");
		ImGui::End();
		return;
	}

	ImGui::Text("Game Moment: %u", *common_externals.field_game_moment);
	ImGui::Text("Current field ID: %u", *common_externals.current_field_id);
	if (common_externals.current_triangle_id != 0) ImGui::Text("Current triangle ID: %d", *common_externals.current_triangle_id);
	ImGui::Text("Previous field ID: %u", *common_externals.previous_field_id);
	ImGui::Separator();

	// Inputs for changing field map
	ImGui::Text("Switch Field"); ImGui::SetNextItemWidth(100);
	ImGui::InputInt("Field ID", &target_field); ImGui::SameLine(200); ImGui::SetNextItemWidth(100);
	ImGui::InputInt("Triangle ID", &target_triangle);

	if (ImGui::Button("Change") && !map_changing) {
		// Injects a call into where the field entities are checked
		memcpy(map_patch_storage, (void*)common_externals.update_entities_call, 7); // Make a copy of the existing CALL
		patch_code_dword(common_externals.update_entities_call, 0x00E89090); // Places 2 NOPs and a CALL
		replace_call(common_externals.update_entities_call + 2, ff8 ? (void*)&map_jump_ff8 : (void*)&map_jump_ff7);
		map_changing = true;
	}
	ImGui::End();
}
````

## File: src/field.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "globals.h"

void field_init();
void field_debug(bool *isOpen);

template<typename T>
T* get_field_parameter_address(int id)
{
	byte* scriptPtr = *ff7_externals.field_script_ptr;
	return (T*)(&scriptPtr[ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] + id + 1]);
}

template<typename T>
T get_field_parameter(int id)
{
	return *get_field_parameter_address<T>(id);
}

template<typename T>
void set_field_parameter(int id, T value)
{
	byte* scriptPtr = *ff7_externals.field_script_ptr;
	*(T*)(&scriptPtr[ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] + id + 1]) = value;
}

byte get_field_bank_value(int16_t bank);

byte* get_level_data_pointer();
````

## File: src/game_cfg.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "game_cfg.h"

#include "patch.h"
#include "globals.h"
#include "cfg.h"
#include "log.h"

void normalize_path_win(char *name)
{
	int idx = 0;
	while (name[idx] != 0)
	{
		if (name[idx] == '/') name[idx] = '\\';
		idx++;
	}
}

void set_game_paths(int install_options, char *_app_path, const char *_dataDrive)
{
	char fileName[MAX_PATH] = {};

	if (!app_path.empty())
	{
		ffnx_info("Overriding AppPath with %s\n", app_path.c_str());
		strncpy(fileName, app_path.c_str(), sizeof(fileName));
		_app_path = fileName;
		normalize_path_win(_app_path);
	}

	if (!steam_edition && !data_drive.empty())
	{
		ffnx_info("Overriding DataDrive with %s\n", data_drive.c_str());
		_dataDrive = data_drive.c_str();
	}

	ff8_externals.set_game_paths(install_options, _app_path, _dataDrive);
}

void game_cfg_init()
{
	if (ff8)
	{
		replace_call(ff8_externals.init_config + 0x3E, set_game_paths);
	}
}
````

## File: src/game_cfg.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/
#pragma once

void game_cfg_init();
````

## File: src/gamehacks.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "gamehacks.h"
#include "audio.h"
#include "ff7/defs.h"
#include "gamepad.h"
#include "joystick.h"

GameHacks gamehacks;

// PRIVATE

void GameHacks::toggleSpeedhack()
{
	speedhack_enabled = !speedhack_enabled;

	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Current Speedhack: %s", speedhack_enabled ? "ENABLED" : "DISABLED");

	holdInput();
}

void GameHacks::resetSpeedhack()
{
	speedhack_current_speed = speedhack_min;
}

void GameHacks::increaseSpeedhack()
{
	speedhack_enabled = true;

	if ((speedhack_current_speed + speedhack_step) <= speedhack_max) speedhack_current_speed += speedhack_step;

	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Current Speedhack: %2.1lfx", speedhack_current_speed);

	holdInput();
}

void GameHacks::decreaseSpeedhack()
{
	speedhack_enabled = true;

	if ((speedhack_current_speed - speedhack_step) >= speedhack_min) speedhack_current_speed -= speedhack_step;

	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Current Speedhack: %2.1lfx", speedhack_current_speed);

	holdInput();
}

void GameHacks::toggleBattleMode()
{
	battle_wanted = !battle_wanted;

	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Battle mode: %s", battle_wanted ? "ENABLED" : "DISABLED");

	holdInput();
}

void GameHacks::toggleAutoAttackMode()
{
	auto_attack_mode = !auto_attack_mode;

	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Auto attack mode: %s", auto_attack_mode ? "ENABLED" : "DISABLED");

	holdInput();
}

void GameHacks::toggleMusicOnBattlePause()
{
	if (!ff8) {
		if (*ff7_externals.is_battle_paused && use_external_music) {
			if (nxAudioEngine.isMusicPlaying())
				nxAudioEngine.pauseMusic();
			else
				nxAudioEngine.resumeMusic();
		}
	}
}

void GameHacks::toggleAutoText()
{
	enable_voice_auto_text = !enable_voice_auto_text;

	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Voice auto text mode: %s", enable_voice_auto_text ? "ENABLED" : "DISABLED");

	holdInput();
}

void GameHacks::skipMovies()
{
	if (!ff8)
	{
		if (ff7_skip_movies())
		{
			show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "FMV Skipped");

			holdInput();
		}
		else clear_popup_msg();
	}
	else
	{
		if (ff8_skip_movies())
		{
			show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "FMV Skipped");

			holdInput();
		}
		else clear_popup_msg();
	}
}

void GameHacks::softReset()
{
	if (!ff8) ff7_do_reset = true;

	resetSpeedhack();

	holdInput();

	clear_popup_msg();
}

// PUBLIC

void GameHacks::init()
{
	resetSpeedhack();

	if (speedhack_current_speed > 1.0) speedhack_enabled = true;
}

void GameHacks::processKeyboardInput(UINT msg, WPARAM wParam, LPARAM lParam)
{
	isKeyboardShortcutMode = false;
	switch (msg)
	{
	case WM_KEYDOWN:
		if ((::GetKeyState(VK_CONTROL) & 0x8000) != 0)
		{
			isKeyboardShortcutMode = true;
			switch (wParam)
			{
			case 'A':
				toggleAutoAttackMode();
				break;
			case 'B':
				toggleBattleMode();
				break;
			case 'M':
				toggleMusicOnBattlePause();
				break;
			case 'R':
				softReset();
				break;
			case 'S':
				skipMovies();
				break;
			case 'T':
				toggleAutoText();
				break;
			case VK_UP:
				increaseSpeedhack();
				break;
			case VK_DOWN:
				decreaseSpeedhack();
				break;
			case VK_LEFT:
			case VK_RIGHT:
				toggleSpeedhack();
				break;
			}
		}
		break;
	}
}

void GameHacks::processGamepadInput()
{
	if(isGamepadShortcutMode && get_popup_time() == 0) isGamepadShortcutMode = false;

	if (xinput_connected)
	{
		if (gamepad.Refresh())
		{
			if(gamepad.IsIdle())
			{
				hold_input_for_frames = 0;
				enable_hold_input = true;
			}

			if(hold_input_for_frames > 0)
			{
				drawnInput();
				return;
			}

			if (gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_THUMB)) // L2
			{
				isGamepadShortcutMode = !isGamepadShortcutMode;
				if(isGamepadShortcutMode) show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Waiting for shortcut input..");
				else clear_popup_msg();
				holdInput();
			}

			if(!isGamepadShortcutMode) return;

			// Soft reset on START+SELECT
			if (
				gamepad.IsPressed(XINPUT_GAMEPAD_BACK) &&
				gamepad.IsPressed(XINPUT_GAMEPAD_START)
				)
				softReset();
			// Increase in-game speed on R1
			else if (
				gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_SHOULDER)
				)
				increaseSpeedhack();
			// Decrease in-game speed on L1
			else if (
				gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_SHOULDER)
				)
				decreaseSpeedhack();
			// Toggle Speedhack on L2/R2
			else if (
				gamepad.leftTrigger > 0.85f ||
				gamepad.rightTrigger > 0.85f
				)
				toggleSpeedhack();
			// Toggle battle mode on Circle
			else if (
				gamepad.IsPressed(XINPUT_GAMEPAD_B)
				)
				toggleBattleMode();
			// Toggle auto attack mode on Triangle
			else if (
				gamepad.IsPressed(XINPUT_GAMEPAD_Y)
				)
				toggleAutoAttackMode();
			// Skip Movies on Square
			else if (
				gamepad.IsPressed(XINPUT_GAMEPAD_X)
				)
				skipMovies();
		}
	}
	else
	{
		if (joystick.Refresh())
		{
			if(joystick.IsIdle())
			{
				hold_input_for_frames = 0;
				enable_hold_input = true;
			}

			if(hold_input_for_frames > 0)
			{
				drawnInput();
				return;
			}

			if (joystick.GetState()->rgbButtons[10] & 0x80) // L2
			{
				isGamepadShortcutMode = !isGamepadShortcutMode;
				if(isGamepadShortcutMode) show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Waiting for shortcut input..");
				else clear_popup_msg();
				holdInput();
			}

			if(!isGamepadShortcutMode) return;

			// Soft reset on START+SELECT
			if (
				(joystick.GetState()->rgbButtons[8] & 0x80) &&
				(joystick.GetState()->rgbButtons[9] & 0x80)
				)
				softReset();
			// Increase in-game speed on R1
			else if (
				joystick.GetState()->rgbButtons[5] & 0x80
				)
				increaseSpeedhack();
			// Decrease in-game speed on L1
			else if (
				joystick.GetState()->rgbButtons[4] & 0x80
				)
				decreaseSpeedhack();
			// Toggle Speedhack on L2/R2
			else if (
				(joystick.GetState()->rgbButtons[6] & 0x80) ||
				(joystick.GetState()->rgbButtons[7] & 0x80)
				)
				toggleSpeedhack();
			// Toggle battle mode on Circle
			else if (
				joystick.GetState()->rgbButtons[2] & 0x80
				)
				toggleBattleMode();
			// Toggle auto attack mode on Triangle
			else if (
				joystick.GetState()->rgbButtons[3] & 0x80
				)
				toggleAutoAttackMode();
			// Skip Movies on Square
			else if (
				joystick.GetState()->rgbButtons[0] & 0x80
				)
				skipMovies();
		}
	}
}

double GameHacks::getCurrentSpeedhack()
{
	return speedhack_enabled ? speedhack_current_speed : 1.0;
}

bool GameHacks::wantsBattle()
{
	return battle_wanted;
}

bool GameHacks::isAutoAttack()
{
	return auto_attack_mode;
}

void GameHacks::holdInput()
{
	if(!enable_hold_input) return;
	hold_input_for_frames = 30; // ~1 sec
	enable_hold_input = false;
}

void GameHacks::drawnInput()
{
	if (hold_input_for_frames > 0) hold_input_for_frames--;
}

bool GameHacks::canInputBeProcessed()
{
	return !isGamepadShortcutMode && !isKeyboardShortcutMode;
}
````

## File: src/gamehacks.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>
#include <windows.h>

class GameHacks
{
private:
	uint16_t hold_input_for_frames = 0;
	bool enable_hold_input = true;

	bool speedhack_enabled;
	double speedhack_current_speed;
	bool battle_wanted = true;
	bool auto_attack_mode = false;

	// SPEEDHACK
	void toggleSpeedhack();
	void resetSpeedhack();
	void increaseSpeedhack();
	void decreaseSpeedhack();

	// BATTLE
	void toggleBattleMode();
	void toggleAutoAttackMode();
	void toggleMusicOnBattlePause();

	// MOVIES
	void skipMovies();

	// SOFT RESET
	void softReset();

	// INPUT VALIDATION
	void holdInput();
	void drawnInput();

	// VOICE AUTO TEXT
	void toggleAutoText();

public:
	void init();

	// GLOBALS
	void processKeyboardInput(UINT msg, WPARAM wParam, LPARAM lParam);
	void processGamepadInput();

	// SPEEDHACK
	double getCurrentSpeedhack();

	// BATTLE
	bool wantsBattle();
	bool isAutoAttack();

	// INPUT VALIDATION
	bool canInputBeProcessed();

private:
	bool isKeyboardShortcutMode = false;
	bool isGamepadShortcutMode = false;
};

extern GameHacks gamehacks;
````

## File: src/gamepad.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <cmath>

#include "gamepad.h"

Gamepad gamepad;

int Gamepad::GetPort() const
{
    return cId + 1;
}

XINPUT_GAMEPAD* Gamepad::GetState()
{
    return &state.Gamepad;
}

const XINPUT_VIBRATION &Gamepad::GetVibrationState() const
{
    return vibration;
}

bool Gamepad::Vibrate(WORD wLeftMotorSpeed, WORD wRightMotorSpeed)
{
    vibration.wLeftMotorSpeed = wLeftMotorSpeed;
    vibration.wRightMotorSpeed = wRightMotorSpeed;

    if (cId == -1)
        CheckConnection();

    if (cId != -1)
    {
        if (XInputSetState(cId, &vibration) != ERROR_SUCCESS)
        {
            cId = -1;
            return false;
        }

        return true;
    }

    return false;
}

bool Gamepad::CheckConnection()
{
    int controllerId = -1;

    for (DWORD i = 0; i < XUSER_MAX_COUNT && controllerId == -1; i++)
    {
        XINPUT_STATE state;
        ZeroMemory(&state, sizeof(XINPUT_STATE));

        if (XInputGetState(i, &state) == ERROR_SUCCESS)
            controllerId = i;
    }

    cId = controllerId;

    return controllerId != -1;
}

// Returns false if the controller has been disconnected
bool Gamepad::Refresh()
{
    if (cId == -1)
        CheckConnection();

    if (cId != -1)
    {
        ZeroMemory(&state, sizeof(XINPUT_STATE));
        if (XInputGetState(cId, &state) != ERROR_SUCCESS)
        {
            cId = -1;
            return false;
        }

        float normLX = fmaxf(-1, (float)state.Gamepad.sThumbLX / 32767);
        float normLY = fmaxf(-1, (float)state.Gamepad.sThumbLY / 32767);

        leftStickX = (abs(normLX) < deadzoneX ? 0 : (abs(normLX) - deadzoneX) * (normLX / abs(normLX)));
        leftStickY = (abs(normLY) < deadzoneY ? 0 : (abs(normLY) - deadzoneY) * (normLY / abs(normLY)));

        if (deadzoneX > 0) leftStickX *= 1 / (1 - deadzoneX);
        if (deadzoneY > 0) leftStickY *= 1 / (1 - deadzoneY);

        float normRX = fmaxf(-1, (float)state.Gamepad.sThumbRX / 32767);
        float normRY = fmaxf(-1, (float)state.Gamepad.sThumbRY / 32767);

        rightStickX = (abs(normRX) < deadzoneX ? 0 : (abs(normRX) - deadzoneX) * (normRX / abs(normRX)));
        rightStickY = (abs(normRY) < deadzoneY ? 0 : (abs(normRY) - deadzoneY) * (normRY / abs(normRY)));

        if (deadzoneX > 0) rightStickX *= 1 / (1 - deadzoneX);
        if (deadzoneY > 0) rightStickY *= 1 / (1 - deadzoneY);

        leftTrigger = (float)state.Gamepad.bLeftTrigger / 255;
        rightTrigger = (float)state.Gamepad.bRightTrigger / 255;

        return true;
    }
    return false;
}

bool Gamepad::IsPressed(WORD button) const
{
    return (state.Gamepad.wButtons & button) != 0;
}

bool Gamepad::IsIdle()
{
  return  !(gamepad.leftStickY > 0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_UP)) &&
          !(gamepad.leftStickY < -0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_DOWN)) &&
          !(gamepad.leftStickX < -0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_LEFT)) &&
          !(gamepad.leftStickX > 0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_RIGHT)) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_X) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_A) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_B) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_Y) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_SHOULDER)&&
          !gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_SHOULDER) &&
          !(gamepad.leftTrigger > 0.85f) &&
          !(gamepad.rightTrigger > 0.85f) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_BACK) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_START) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_START) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_THUMB) &&
          !gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_THUMB) &&
          !gamepad.IsPressed(0x400);
}
````

## File: src/gamepad.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <Windows.h>
#include <Xinput.h>

// Kudos to https://katyscode.wordpress.com/2013/08/30/xinput-tutorial-part-1-adding-gamepad-support-to-your-windows-game/
class Gamepad
{
private:
    int cId;
    XINPUT_STATE state;
    XINPUT_VIBRATION vibration;

    float deadzoneX;
    float deadzoneY;

public:
    Gamepad() : deadzoneX(0.05f), deadzoneY(0.02f) {}
    Gamepad(float dzX, float dzY) : deadzoneX(dzX), deadzoneY(dzY) {}

    float leftStickX;
    float leftStickY;
    float rightStickX;
    float rightStickY;
    float leftTrigger;
    float rightTrigger;

    int  GetPort() const;
    XINPUT_GAMEPAD* GetState();
    const XINPUT_VIBRATION &GetVibrationState() const;
    bool CheckConnection();
    // Get state from remote device
    bool Refresh();
    bool Vibrate(WORD wLeftMotorSpeed, WORD wRightMotorSpeed);
    bool IsPressed(WORD) const;
    bool IsIdle();
};

extern Gamepad gamepad;
````

## File: src/gl.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <map>
#include <string>
#include <vector>

#include "common.h"

#define VERTEX 1
#define LVERTEX 2
#define TLVERTEX 3

enum DrawCallType
{
	DCT_CLEAR = 0,
	DCT_BLIT,
	DCT_DRAW,
	DCT_DRAW_MOVIE,
	DCT_BATTLE_DEPTH_CLEAR,
	DCT_ZOOM,
	DCT_WORLD_EXTERNAL_MESH,
	DCT_CLOUD_EXTERNAL_MESH,
};

struct driver_state
{
	struct texture_set *texture_set;
	uint32_t texture_handle;
	uint32_t blend_mode;
	uint32_t viewport[4];
	uint32_t fb_texture;
	uint32_t wireframe;
	uint32_t texture_filter;
	uint32_t cullface;
	uint32_t nocull;
	uint32_t depthtest;
	uint32_t depthmask;
	uint32_t shademode;
	uint32_t alphatest;
	uint32_t alphafunc;
	uint32_t alpharef;
	struct matrix world_view_matrix;
	struct matrix d3dprojection_matrix;
};

struct deferred_draw
{
	uint32_t primitivetype;
	uint32_t vertextype;
	uint32_t vertexcount;
	uint32_t count;
	struct nvertex* vertices;
	vector3<float>* normals;
	WORD *indices;
	struct boundingbox* boundingbox;
	uint32_t clip;
	uint32_t mipmap;
	struct driver_state state;
	struct light_data* lightdata;
	DrawCallType draw_call_type;
	struct texture_set *fb_texture_set;
	struct tex_header *fb_tex_header;
	uint32_t clear_color;
	uint32_t clear_depth;
	struct game_obj *game_object;
	uint32_t movie_buffer_index;
	bool is_time_filter_enabled;
	bool is_fog_enabled;
};

struct deferred_sorted_draw
{
	deferred_draw deferred_draw;
	double z;
	uint32_t drawn;
};

struct gl_texture_set
{
	uint32_t textures;
	uint32_t force_filter;
	uint32_t force_zsort;
	uint32_t disable_lighting;
	uint32_t default_texture_id;
	// ANIMATED TEXTURES
	uint32_t is_animated;
	std::map<std::string, uint32_t> animated_textures;
	// ADDITIONAL TEXTURES
	std::map<uint16_t, uint32_t> additional_textures;
};

extern struct matrix d3dviewport_matrix;

extern struct driver_state current_state;

extern uint32_t current_program;

extern int max_texture_size;

typedef void (*draw_field_shadow_callback)(void);

void gl_draw_movie_quad(uint32_t width, uint32_t height);
void gl_save_state(struct driver_state *dest);
void gl_load_state(struct driver_state *src);
uint32_t gl_defer_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex* vertices, struct vector3<float>* normals, uint32_t vertexcount, WORD* indices, uint32_t count, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap);
uint32_t gl_defer_sorted_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, uint32_t clip, uint32_t mipmap, uint32_t force_defer);
uint32_t gl_defer_blit_framebuffer(struct texture_set *texture_set, struct tex_header *tex_header);
uint32_t gl_defer_clear_buffer(uint32_t clear_color, uint32_t clear_depth, struct game_obj *game_object);
uint32_t gl_defer_yuv_frame(uint32_t buffer_index);
uint32_t gl_defer_battle_depth_clear();
uint32_t gl_defer_zoom();
uint32_t gl_defer_world_external_mesh();
uint32_t gl_defer_cloud_external_mesh();
void gl_draw_deferred(draw_field_shadow_callback shadow_callback);
struct boundingbox calculateSceneAabb();
void gl_draw_sorted_deferred();
void gl_check_deferred(struct texture_set *texture_set);
void gl_cleanup_deferred();
uint32_t gl_special_case(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, struct graphics_object *graphics_object, uint32_t clip, uint32_t mipmap);
void gl_calculate_normals(std::vector<vector3<float>>* normals, struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata);
void gl_draw_without_lighting(struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip);
void gl_draw_with_lighting(struct indexed_primitive *ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip);
void gl_draw_indexed_primitive(uint32_t, uint32_t, struct nvertex *, struct vector3<float>* normals, uint32_t, WORD *, uint32_t, struct graphics_object *, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap);
void gl_set_worldview_matrix(struct matrix *matrix);
void gl_set_d3dprojection_matrix(struct matrix *matrix);
void gl_set_blend_func(uint32_t);
bool gl_check_texture_dimensions(uint32_t width, uint32_t height, char *source);
void gl_replace_texture(struct texture_set *texture_set, uint32_t palette_index, uint32_t new_texture);
void gl_upload_texture(struct texture_set *texture_set, uint32_t palette_index, void *image_data, uint32_t format);
void gl_bind_texture_set(struct texture_set *);
void gl_set_texture(uint32_t texture, struct gl_texture_set* gl_set);
uint32_t gl_draw_text(uint32_t x, uint32_t y, uint32_t color, uint32_t alpha, char *fmt, ...);
````

## File: src/globals.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <mimalloc-new-delete.h>
#include <windows.h>
#include <toml++/toml.h>

#if defined(__cplusplus)
extern "C" {
#endif

#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libavutil/imgutils.h>
#include <libswscale/swscale.h>
#include <libswresample/swresample.h>

#if defined(__cplusplus)
}
#endif

#include "ff7.h"
#include "ff8.h"

#define FFNX_API __declspec(dllexport)

extern HINSTANCE gameHinstance;
extern HWND gameHwnd;

extern MEMORYSTATUSEX last_ram_state;
extern uint32_t version;
extern uint32_t steam_edition;
extern uint32_t steam_stock_launcher;
extern uint32_t estore_edition;
extern uint32_t ff7_japanese_edition;
extern uint32_t ff7_do_reset;

#define BASEDIR_LENGTH 512
extern char basedir[BASEDIR_LENGTH];

extern uint32_t game_width;
extern uint32_t game_height;
extern uint32_t x_offset;
extern uint32_t y_offset;
extern uint32_t widescreen_enabled;

extern struct texture_format *texture_format;

extern struct ff7_externals ff7_externals;
extern struct ff8_externals ff8_externals;
extern struct common_externals common_externals;
extern struct driver_stats stats;

extern char popup_msg[];
extern uint32_t popup_ttl;
extern uint32_t popup_color;

extern struct game_mode modes[];
extern uint32_t num_modes;

extern uint32_t text_colors[];

extern uint32_t ff8;

extern uint32_t frame_counter;
extern double frame_rate;
extern int battle_frame_multiplier;
extern int common_frame_multiplier;

extern bool xinput_connected;
extern bool simulate_OK_button;
extern GamepadAnalogueIntent gamepad_analogue_intent;

extern bool next_music_is_battle;
extern uint16_t next_battle_scene_id;

extern char *get_current_field_name();
extern uint32_t noop();
extern uint32_t noop_a1(uint32_t a1);
extern uint32_t noop_a2(uint32_t a1, uint32_t a2);
extern uint32_t noop_a3(uint32_t a1, uint32_t a2, uint32_t a3);
````

## File: src/hext.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "hext.h"
#include "log.h"
#include "patch.h"
#include "utils.h"
#include <fstream>
#include <filesystem>
#include <io.h>

Hext hextPatcher;

// PRIVATE

int Hext::getAddress(std::string token)
{
    int ret;

    std::vector<std::string> sparts = split(token, "[+-]+");
    std::vector<int> iparts;

    if (ends_with(sparts[0], "^"))
    {
        std::stringstream ss;
        int *ptr = (int*)(std::stoi(sparts[0].substr(0, sparts[0].length() - 1), nullptr, 16) + inGlobalOffset);
        ss << std::hex << *ptr;
        sparts[0] = ss.str();
    }

    for (auto &part : sparts)
    {
        iparts.push_back(
            std::stoi(part, nullptr, 16)
        );
    }

    ret = iparts[0];

    if (contains(token, "+"))
    {
        ret += iparts[1];
    }
    else if (contains(token, "-"))
    {
        ret -= iparts[1];
    }

    return ret + inGlobalOffset;
}

std::vector<char> Hext::getBytes(std::string token)
{
    std::vector<char> ret;

    if (contains(token, ":"))
    {
        std::vector<std::string> parts = split(token, "[:]+");
        int count = std::stoi(parts[1], nullptr, 0);
        while (count > 0)
        {
            ret.push_back(std::stoi(parts[0], nullptr, 16));
            count--;
        }
    }
    else
    {
        std::vector<std::string> bytes = split(token, "[\\s,\\t]+");

        for (auto byte : bytes)
        {
            ret.push_back(std::stoi(byte, nullptr, 16));
        }
    }

    return ret;
}

bool Hext::hasCheckpoint(std::string token)
{
    if (starts_with(token, "!"))
    {
        return true;
    }

    return false;
}

bool Hext::parseCheckpoint(std::string token, std::string checkpoint)
{
    if (starts_with(token, "!"))
    {
        if (contains(token, checkpoint))
        {
            return true;
        }
    }

    return false;
}

bool Hext::parseCommands(std::string token)
{
    if (starts_with(token, "<<"))
    {
        replaceOnce(token, "<<", "");

        trim(token);

        ffnx_trace("%s\n", token.data());

        return true;
    }

    return false;
}

bool Hext::parseComment(std::string token)
{
    if (isMultilineComment)
    {
        if (ends_with(token, "}}")) isMultilineComment = false;
        return true;
    }

    if (starts_with(token, "{{"))
    {
        isMultilineComment = true;
        return true;
    }

    if (starts_with(token, "#")) return true;
    if (starts_with(token, "{")) return true;
    if (starts_with(token, ".")) return true;

    return false;
}

bool Hext::parseGlobalOffset(std::string token)
{
    if (starts_with(token, "+"))
    {
        inGlobalOffset = std::stoi(token.substr(1), nullptr, 16);

        return true;
    }
    else if (starts_with(token, "-"))
    {
        inGlobalOffset = -std::stoi(token.substr(1), nullptr, 16);

        return true;
    }

    return false;
}

bool Hext::parseMemoryPermission(std::string token)
{
    if (contains(token, ":"))
    {
        DWORD dummy;

        std::vector<std::string> parts = split(token, "[:]+");
        int addr = getAddress(parts[0]);
        int length = std::stoi(parts[1], nullptr, 16);

        VirtualProtect((LPVOID)addr, length, PAGE_EXECUTE_READWRITE, &dummy);

        return true;
    }

    return false;
}

bool Hext::parseMemoryPatch(std::string token)
{
    if (contains(token, "="))
    {
        DWORD dummy;

        std::vector<std::string> parts = split(token, "[=]+");
        int addr = getAddress(parts[0]);
        std::vector<char> bytes = getBytes(parts[1]);

        memcpy_code(addr, bytes.data(), bytes.size());

        return true;
    }

    return false;
}

// PUBLIC

void Hext::apply(std::string filename)
{
    std::string line;
    std::ifstream ifs(filename);

    while (std::getline(ifs, line))
    {
        if (line.empty()) continue;

        // Check if delayed, if so it should not be applied
        if (hasCheckpoint(line)) {
            ifs.close();
            return;
        }

        // Check if is a comment
        if (parseComment(line)) continue;

        // Check if is a command
        if (parseCommands(line)) continue;

        // Check if is a global offset
        if (parseGlobalOffset(line)) continue;

        // Check if is a memory permission range
        if (parseMemoryPermission(line)) continue;

        // Check if is a memory patch instruction
        if (parseMemoryPatch(line)) continue;
    }

    ifs.close();

    ffnx_trace("Applied Hext patch: %s\n", filename.c_str());
}

void Hext::applyDelayed(std::string filename, std::string checkpoint)
{
    std::string line;
    std::ifstream ifs(filename);

    bool matchCheckpoint = false;

    while (std::getline(ifs, line))
    {
        if (line.empty()) continue;

        // Check if is a comment
        if (parseComment(line)) continue;

        // Check if is a delayed patch.
        if (parseCheckpoint(line, checkpoint)) {
            matchCheckpoint = true;

            continue;
        }

        if (matchCheckpoint)
        {
            // Check if is a command
            if (parseCommands(line)) continue;

            // Check if is a global offset
            if (parseGlobalOffset(line)) continue;

            // Check if is a memory permission range
            if (parseMemoryPermission(line)) continue;

            // Check if is a memory patch instruction
            if (parseMemoryPatch(line)) continue;
        }
        else
        {
            break;
        }
    }

    ifs.close();

    if (matchCheckpoint) ffnx_trace("Applied delayed Hext patch: %s\n", filename.c_str());
}

void Hext::applyAll(std::string checkpoint)
{
    if (fileExists(hext_patching_path.c_str()))
    {
        if (!checkpoint.empty())
        {
            for (const auto& entry : std::filesystem::directory_iterator(hext_patching_path))
            {
                if (entry.is_regular_file()) {
                    applyDelayed(entry.path().string(), checkpoint);
                }

                inGlobalOffset = 0;
            }
        }
        else
        {
            for (const auto& entry : std::filesystem::directory_iterator(hext_patching_path))
            {
                if (entry.is_regular_file()) {
                    apply(entry.path().string());
                }

                inGlobalOffset = 0;
            }
        }
    }
}
````

## File: src/hext.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

/*
	HEXT Specification by DLPB

	See https://forums.qhimm.com/index.php?topic=13574.0

	This implementation may differ from the original specification as new required functionalities will be implemented,
	in order to ease modders life.
*/

#pragma once

#include <string>
#include <vector>

class Hext {
private:
	int inGlobalOffset;
	bool isMultilineComment = false;

	int getAddress(std::string token);
	std::vector<char> getBytes(std::string token);

	bool hasCheckpoint(std::string token);
	bool parseCheckpoint(std::string token, std::string checkpoint);
	bool parseCommands(std::string token);
	bool parseComment(std::string token);
	bool parseGlobalOffset(std::string token);
	bool parseMemoryPermission(std::string token);
	bool parseMemoryPatch(std::string token);

public:
	void apply(std::string filename);
	void applyDelayed(std::string filename, std::string checkpoint);
	void applyAll(std::string checkpoint = std::string());
};

extern Hext hextPatcher;
````

## File: src/input.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <windowsx.h>
#include <dinput.h>
#include "input.h"
#include "gamehacks.h"
#include "globals.h"

byte keys[256];
bool blockKeys = false;

void SetBlockKeysFromGame(bool block) {
    blockKeys = block;
}

void MouseDown(MouseEventArgs e)
{
    for (MouseListener* listener : mouseListeners)
        listener->MouseDown(e);
}

void MouseUp(MouseEventArgs e)
{
    for (MouseListener* listener : mouseListeners)
        listener->MouseUp(e);
}

void MouseWheel(MouseEventArgs e)
{
    for (MouseListener* listener : mouseListeners)
        listener->MouseWheel(e);
}

void MouseMove(MouseEventArgs e)
{
    for (MouseListener* listener : mouseListeners)
        listener->MouseMove(e);
}

void KeyUp(KeyEventArgs e)
{
    for (KeyListener* listener : keyListeners)
        listener->KeyUp(e);
}

void KeyDown(KeyEventArgs e)
{
    for (KeyListener* listener : keyListeners)
        listener->KeyDown(e);
}

void KeyPress(KeyPressEventArgs e)
{
    for (KeyListener* listener : keyListeners)
        listener->KeyPress(e);
}

void RefreshDevices()
{

}

// Handles inputs coming from the WindowProc function - originates from DispatchMessage in the message loop
bool HandleInputEvents(UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_XBUTTONDOWN:
    {
        int button = 0;
        if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) { button = 1; }
        if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) { button = 2; }
        if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) { button = 3; }
        if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 4 : 5; }
        MouseDown(MouseEventArgs{
            (int)button,
            0,
            GET_X_LPARAM(lParam),
            GET_Y_LPARAM(lParam),
            });
        return true;
    }
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_XBUTTONUP:
    {
        int button = 0;
        if (msg == WM_LBUTTONUP) { button = 1; }
        if (msg == WM_RBUTTONUP) { button = 2; }
        if (msg == WM_MBUTTONUP) { button = 3; }
        if (msg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 4 : 5; }
        MouseUp(MouseEventArgs{
            (int)button,
            0,
            GET_X_LPARAM(lParam),
            GET_Y_LPARAM(lParam)
            });
        return true;
    }
    case WM_MOUSEWHEEL:
        MouseWheel(MouseEventArgs{
            0,
            GET_WHEEL_DELTA_WPARAM(wParam) / WHEEL_DELTA,
            GET_X_LPARAM(lParam),
            GET_Y_LPARAM(lParam)
            });
        return true;
    case WM_MOUSEMOVE:
        MouseMove(MouseEventArgs{
            0,
            0,
            GET_X_LPARAM(lParam),
            GET_Y_LPARAM(lParam)
            });
        return true;
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        KeyDown(KeyEventArgs{
            (int)wParam,
            (bool)((lParam >> 24) & 1)
            });
        return true;
    case WM_KEYUP:
    case WM_SYSKEYUP:
        KeyUp(KeyEventArgs{
            (int)wParam,
            (bool)((lParam >> 24) & 1)
            });
        return true;
    case WM_CHAR:
        KeyPress(KeyPressEventArgs{
            (int)wParam
            });
        return true;
    case WM_DEVICECHANGE:
        RefreshDevices();
        return true;
    }
    return false;
}

// Handles polling the keyboard input using DirectInput
byte* GetGameKeyState()
{
    IDirectInputDeviceA* keyboard_device = *common_externals.keyboard_device;
    if (keyboard_device != NULL)
    {
        if (blockKeys || !gamehacks.canInputBeProcessed())
        {
            std::memset(keys, 0, 256);
            return keys;
        }

        // This is the existing functionality but retries on any error rather than just DIERR_INPUTLOST
        if (keyboard_device->GetDeviceState(256, keys) == 0)
            return keys;

        *common_externals.keyboard_connected = 0;
        if (common_externals.dinput_acquire_keyboard() != 0 && keyboard_device->GetDeviceState(256, keys) != 0)
            return keys;
    }
    return NULL;
}
````

## File: src/input.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <windows.h>
#include <vector>

struct KeyEventArgs
{
	int keyValue;
	bool isExtended;
};

struct KeyPressEventArgs
{
	int keyChar;
};

struct MouseEventArgs
{
	int button;
	int delta;
	int x;
	int y;
};

class MouseListener
{
public:
	virtual void MouseDown(MouseEventArgs e) = 0;
	virtual void MouseUp(MouseEventArgs e) = 0;
	virtual void MouseWheel(MouseEventArgs e) = 0;
	virtual void MouseMove(MouseEventArgs e) = 0;
};

class KeyListener
{
public:
	virtual void KeyUp(KeyEventArgs e) = 0;
	virtual void KeyDown(KeyEventArgs e) = 0;
	virtual void KeyPress(KeyPressEventArgs e) = 0;
};

std::vector<MouseListener*> mouseListeners;
std::vector<KeyListener*> keyListeners;

void SetBlockKeysFromGame(bool block = false);
bool HandleInputEvents(UINT msg, WPARAM wParam, LPARAM lParam);
byte* GetGameKeyState();
````

## File: src/joystick.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <wbemidl.h>
#include <oleauto.h>

#include "joystick.h"
#include "log.h"

#ifndef SAFE_RELEASE
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }
#endif

Joystick joystick;

BOOL CALLBACK Joystick::staticEnumerateGameControllers(LPCDIDEVICEINSTANCE devInst, LPVOID pvRef)
{
	Joystick* inputHandlerInstance = (Joystick*)pvRef;
	return inputHandlerInstance->enumerateGameControllers(devInst);
}

BOOL CALLBACK Joystick::staticSetGameControllerProperties(LPCDIDEVICEOBJECTINSTANCE devObjInst, LPVOID pvRef)
{
  // the game controller
	LPDIRECTINPUTDEVICE8 gameController = (LPDIRECTINPUTDEVICE8)pvRef;
	gameController->Unacquire();

  // structure to hold game controller range properties
	DIPROPRANGE gameControllerRange;

	// set the range to -32768 and 32768
	gameControllerRange.lMin = SHRT_MIN;
	gameControllerRange.lMax = SHRT_MAX;

	// set the size of the structure
	gameControllerRange.diph.dwSize = sizeof(DIPROPRANGE);
	gameControllerRange.diph.dwHeaderSize = sizeof(DIPROPHEADER);

	// set the object that we want to change
	gameControllerRange.diph.dwHow = DIPH_BYID;
	gameControllerRange.diph.dwObj = devObjInst->dwType;

	// now set the range for the axis
	if (FAILED(gameController->SetProperty(DIPROP_RANGE, &gameControllerRange.diph)))
		return DIENUM_STOP;

	return DIENUM_CONTINUE;
}

BOOL Joystick::enumerateGameControllers(LPCDIDEVICEINSTANCE devInst)
{
  if(isXInputDevice(&devInst->guidProduct))
    return DIENUM_CONTINUE;

	// enumerate devices
	LPDIRECTINPUTDEVICE8 gameController;

	// create interface for the current game controller
	if (FAILED(dev->CreateDevice(devInst->guidInstance, &gameController, NULL)))
		return DIENUM_CONTINUE;
	else
	{
    if (trace_all || trace_gamepad)
    {
      // get game controller name
      DIDEVICEINSTANCE deviceInfo;
      deviceInfo.dwSize = sizeof(DIDEVICEINSTANCE);
      gameController->GetDeviceInfo(&deviceInfo);
      ffnx_trace("Found DInput Gamepad #%d: %s\n", gameControllers.size(), deviceInfo.tszInstanceName);
    }

		// store the game controller
		gameControllers.push_back(gameController);
		return DIENUM_CONTINUE;
	}
}

LPDIJOYSTATE2 Joystick::GetState()
{
  return &currentState;
}

LPDIDEVCAPS Joystick::GetCaps()
{
  return &caps;
}

bool Joystick::CheckConnection()
{
  if (dev == nullptr)
  {
    // initialize the main DirectInput 8 device
    if (FAILED(DirectInput8Create(gameHinstance, DIRECTINPUT_VERSION, IID_IDirectInput8, (void **)&dev, NULL)))
      return false;

    gameControllers.clear();

    // enumerate all available game controllers. Attempt to fetch the ones that support force feedback
    if (FAILED(dev->EnumDevices(DI8DEVCLASS_GAMECTRL, &staticEnumerateGameControllers, this, DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK)))
      return false;

    // If the collection is empty it means the API call was successful but no device was found. Re-iterate without force feedback this time.
    if (!gameControllers.empty())
      gameControllerSupportsVibration = true;
    else
    {
      if (FAILED(dev->EnumDevices(DI8DEVCLASS_GAMECTRL, &staticEnumerateGameControllers, this, DIEDFL_ATTACHEDONLY)))
        return false;
    }

    if (gameControllers.empty())
      return false;

    gameController = gameControllers.at(0);

    // Get controller capabilities
    caps.dwSize = sizeof(DIDEVCAPS);

    if (FAILED(gameController->GetCapabilities(&caps)))
      return false;

    if (trace_all || trace_gamepad)
    {
      // get game controller name
      DIDEVICEINSTANCE deviceInfo;
      deviceInfo.dwSize = sizeof(DIDEVICEINSTANCE);
      gameController->GetDeviceInfo(&deviceInfo);
      ffnx_trace("Using Gamepad: %s (Supports Force Feedback: %s)\n", deviceInfo.tszInstanceName, gameControllerSupportsVibration ? "yes" : "no");
    }

    // set cooperative level
    if (FAILED(gameController->SetCooperativeLevel(gameHwnd, ((ff8 && ff8_always_capture_input) ? DISCL_BACKGROUND : DISCL_FOREGROUND) | DISCL_NONEXCLUSIVE)))
      return false;

    // set data format
    if (FAILED(gameController->SetDataFormat(&c_dfDIJoystick2)))
      return false;

    // set range and dead zone of joystick axes
    if (FAILED(gameController->EnumObjects(&staticSetGameControllerProperties, gameController, DIDFT_AXIS)))
      return false;

    // get game controller max force feedback supported magnitude
    if (gameControllerSupportsVibration)
    {
      gameControllerInfo.dwSize = sizeof(DIDEVICEOBJECTINSTANCE);

      if (FAILED(gameController->GetObjectInfo(&gameControllerInfo, DIDFT_AXIS, DIPH_BYID)))
        return false;
    }
  }

  // clean joystick states
  ZeroMemory(&currentState, sizeof(DIJOYSTATE2));

  return gameController != nullptr;
}

// poll
bool Joystick::Refresh()
{
  HRESULT hr;

  // Return if no joystick detected
  if (!CheckConnection()) return false;

  // poll the device to read the current state
  hr = gameController->Poll();

  if (FAILED(hr))
  {
    // DirectInput lost the device, try to re-acquire it
    hr = gameController->Acquire();
    while (hr == DIERR_INPUTLOST)
      hr = gameController->Acquire();

    // return if a fatal error is encountered
    if ((hr == DIERR_INVALIDPARAM) || (hr == DIERR_NOTINITIALIZED))
      return false;

    // if another application has control of this device, we have to wait for our turn
    if (hr == DIERR_OTHERAPPHASPRIO)
      return false;
  }

  // now if everything is okay, we can get the state of the device
  if (FAILED(hr = gameController->GetDeviceState(sizeof(DIJOYSTATE2), &currentState)))
    return false;

  return true;
}

bool Joystick::HasAnalogTriggers()
{
  return caps.dwAxes >=6;
}

void Joystick::Clean()
{
  for (LPDIRECTINPUTDEVICE8 controller : gameControllers)
    SAFE_RELEASE(controller);

  SAFE_RELEASE(dev);

  dev = nullptr;
  gameController = nullptr;
  gameControllers.clear();
}

LONG Joystick::GetDeadZone(float percent)
{
  return SHRT_MAX * percent;
}

bool Joystick::HasForceFeedback()
{
  return gameControllerSupportsVibration;
}

DWORD Joystick::GetMaxVibration()
{
  return gameControllerSupportsVibration ? gameControllerInfo.dwFFMaxForce : 0;
}

void Joystick::Vibrate(WORD leftMotorSpeed, WORD rightMotorSpeed)
{
  if (gameControllerSupportsVibration)
  {
    DWORD      dwAxes[2] = { DIJOFS_X, DIJOFS_Y };
    LONG       lDirection[2] = { leftMotorSpeed, rightMotorSpeed };

    DIPERIODIC diPeriodic;      // type-specific parameters
    DIENVELOPE diEnvelope;      // envelope
    DIEFFECT   diEffect;        // general parameters

    // setup the periodic structure
    diPeriodic.dwMagnitude = DI_FFNOMINALMAX;
    diPeriodic.lOffset = 0;
    diPeriodic.dwPhase = 0;
    diPeriodic.dwPeriod = (DWORD) (0.05 * DI_SECONDS);

    // set the modulation envelope
    diEnvelope.dwSize = sizeof(DIENVELOPE);
    diEnvelope.dwAttackLevel = 0;
    diEnvelope.dwAttackTime = (DWORD) (0.01 * DI_SECONDS);
    diEnvelope.dwFadeLevel = 0;
    diEnvelope.dwFadeTime = (DWORD) (3.0 * DI_SECONDS);

    // set up the effect structure itself
    diEffect.dwSize = sizeof(DIEFFECT);
    diEffect.dwFlags = DIEFF_POLAR | DIEFF_OBJECTOFFSETS;
    diEffect.dwDuration = (DWORD) INFINITE; // (1 * DI_SECONDS);

    // set up details of effect
    diEffect.dwSamplePeriod = 0;               // = default
    diEffect.dwGain = DI_FFNOMINALMAX;         // no scaling
    diEffect.dwTriggerButton = DIJOFS_BUTTON0; // connect effect to trigger button
    diEffect.dwTriggerRepeatInterval = 0;
    diEffect.cAxes = 2;
    diEffect.rgdwAxes = dwAxes;
    diEffect.rglDirection = &lDirection[0];
    diEffect.lpEnvelope = &diEnvelope;
    diEffect.cbTypeSpecificParams = sizeof(diPeriodic);
    diEffect.lpvTypeSpecificParams = &diPeriodic;

    // create the effect and get the interface to it
    if (SUCCEEDED(gameController->CreateEffect(GUID_Square, &diEffect, &gameControllerEffect, NULL)))
      // Play the effect
      gameControllerEffect->Start(1, DIES_SOLO);
  }
}

bool Joystick::IsIdle()
{
  return  !(joystick.GetState()->lY < joystick.GetDeadZone(-0.5f) || joystick.GetState()->rgdwPOV[0] == 0) &&
          !(joystick.GetState()->lY > joystick.GetDeadZone(0.5f) || joystick.GetState()->rgdwPOV[0] == 18000) &&
          !(joystick.GetState()->lX < joystick.GetDeadZone(-0.5f) || joystick.GetState()->rgdwPOV[0] == 27000) &&
          !(joystick.GetState()->lX > joystick.GetDeadZone(0.5f) || joystick.GetState()->rgdwPOV[0] == 9000) &&
          !(joystick.GetState()->rgbButtons[0] & 0x80) &&
          !(joystick.GetState()->rgbButtons[1] & 0x80) &&
          !(joystick.GetState()->rgbButtons[2] & 0x80) &&
          !(joystick.GetState()->rgbButtons[3] & 0x80) &&
          !(joystick.GetState()->rgbButtons[4] & 0x80) &&
          !(joystick.GetState()->rgbButtons[5] & 0x80) &&
          !(joystick.GetState()->rgbButtons[6] & 0x80) &&
          !(joystick.GetState()->rgbButtons[7] & 0x80) &&
          !(joystick.GetState()->rgbButtons[8] & 0x80) &&
          !(joystick.GetState()->rgbButtons[9] & 0x80) &&
          !(joystick.GetState()->rgbButtons[10] & 0x80) &&
          !(joystick.GetState()->rgbButtons[11] & 0x80) &&
          !(joystick.GetState()->rgbButtons[12] & 0x80);
}

//-----------------------------------------------------------------------------
// Enum each PNP device using WMI and check each device ID to see if it contains
// "IG_" (ex. "VID_045E&PID_028E&IG_00").  If it does, then it's an XInput device
// Unfortunately this information can not be found by just using DirectInput
//-----------------------------------------------------------------------------
BOOL Joystick::isXInputDevice(const GUID* pGuidProductFromDirectInput)
{
  IWbemLocator*           pIWbemLocator  = NULL;
  IEnumWbemClassObject*   pEnumDevices   = NULL;
  IWbemClassObject*       pDevices[20]   = {0};
  IWbemServices*          pIWbemServices = NULL;
  BSTR                    bstrNamespace  = NULL;
  BSTR                    bstrDeviceID   = NULL;
  BSTR                    bstrClassName  = NULL;
  DWORD                   uReturned      = 0;
  bool                    bIsXinputDevice= false;
  UINT                    iDevice        = 0;
  VARIANT                 var;
  HRESULT                 hr;

  // CoInit if needed
  hr = CoInitialize(NULL);
  bool bCleanupCOM = SUCCEEDED(hr);

  // So we can call VariantClear() later, even if we never had a successful IWbemClassObject::Get().
  VariantInit(&var);

  // Create WMI
  hr = CoCreateInstance(__uuidof(WbemLocator), NULL, CLSCTX_INPROC_SERVER, __uuidof(IWbemLocator), (LPVOID*) &pIWbemLocator);

  if(FAILED(hr) || pIWbemLocator == NULL)
    goto LCleanup;

  bstrNamespace = SysAllocString(L"\\\\.\\root\\cimv2"); if(bstrNamespace == NULL) goto LCleanup;
  bstrClassName = SysAllocString(L"Win32_PNPEntity");    if(bstrClassName == NULL) goto LCleanup;
  bstrDeviceID  = SysAllocString(L"DeviceID");           if(bstrDeviceID == NULL)  goto LCleanup;

  // Connect to WMI
  hr = pIWbemLocator->ConnectServer(bstrNamespace, NULL, NULL, 0L, 0L, NULL, NULL, &pIWbemServices);
  if(FAILED(hr) || pIWbemServices == NULL)
    goto LCleanup;

  // Switch security level to IMPERSONATE.
  CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);

  hr = pIWbemServices->CreateInstanceEnum(bstrClassName, 0, NULL, &pEnumDevices);
  if(FAILED(hr) || pEnumDevices == NULL)
    goto LCleanup;

  // Loop over all devices
  for(;;)
  {
    // Get 20 at a time
    hr = pEnumDevices->Next(10000, 20, pDevices, &uReturned);

    if(FAILED(hr))
      goto LCleanup;

    if(uReturned == 0)
      break;

    for(iDevice=0; iDevice<uReturned; iDevice++)
    {
      // For each device, get its device ID
      hr = pDevices[iDevice]->Get(bstrDeviceID, 0L, &var, NULL, NULL);
      if(SUCCEEDED(hr) && var.vt == VT_BSTR && var.bstrVal != NULL)
      {
        // Check if the device ID contains "IG_".  If it does, then it's an XInput device
        // This information can not be found from DirectInput
        if(wcsstr(var.bstrVal, L"IG_"))
        {
          // If it does, then get the VID/PID from var.bstrVal
          DWORD dwPid = 0, dwVid = 0;
          WCHAR* strVid = wcsstr(var.bstrVal, L"VID_");

          if(strVid && swscanf(strVid, L"VID_%4X", &dwVid) != 1)
            dwVid = 0;

          WCHAR* strPid = wcsstr(var.bstrVal, L"PID_");

          if(strPid && swscanf(strPid, L"PID_%4X", &dwPid) != 1)
            dwPid = 0;

          // Compare the VID/PID to the DInput device
          DWORD dwVidPid = MAKELONG(dwVid, dwPid);
          if(dwVidPid == pGuidProductFromDirectInput->Data1)
          {
            bIsXinputDevice = true;
            goto LCleanup;
          }
        }
      }
      VariantClear(&var);
      SAFE_RELEASE(pDevices[iDevice]);
    }
  }

LCleanup:
  VariantClear(&var);
  if(bstrNamespace)
    SysFreeString(bstrNamespace);
  if(bstrDeviceID)
    SysFreeString(bstrDeviceID);
  if(bstrClassName)
    SysFreeString(bstrClassName);
  for(iDevice=0; iDevice<20; iDevice++)
    SAFE_RELEASE(pDevices[iDevice]);
  SAFE_RELEASE(pEnumDevices);
  SAFE_RELEASE(pIWbemLocator);
  SAFE_RELEASE(pIWbemServices);

  if(bCleanupCOM)
    CoUninitialize();

  return bIsXinputDevice;
}
````

## File: src/joystick.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <vector>
#include <dinput.h>

// Inspired by https://bell0bytes.eu/directinput/

// the joystick class (DirectInput)
class Joystick
{
private:
  LPDIRECTINPUT8 dev = nullptr;                          // dinput interface
  LPDIRECTINPUTDEVICE8 gameController = nullptr;         // the actual joystick device
  LPDIRECTINPUTEFFECT  gameControllerEffect = nullptr;   // force feedback effect object
  DIDEVICEOBJECTINSTANCE gameControllerInfo;             // the device object info
  DIDEVCAPS caps;                                        // the device capabilities
  DIJOYSTATE2 currentState;			                         // the state of the joystick in the current frame

  BOOL enumerateGameControllers(LPCDIDEVICEINSTANCE devInst);
  std::vector<LPDIRECTINPUTDEVICE8> gameControllers;	// a vector of all available game controllers

  BOOL isXInputDevice(const GUID *pGuidProductFromDirectInput);

  static BOOL CALLBACK staticEnumerateGameControllers(LPCDIDEVICEINSTANCE devInst, LPVOID pvRef);
  static BOOL CALLBACK staticSetGameControllerProperties(LPCDIDEVICEOBJECTINSTANCE devObjInst, LPVOID pvRef);

  BOOL gameControllerSupportsVibration = false;

public:
  LPDIJOYSTATE2 GetState();
  LPDIDEVCAPS GetCaps();
  bool CheckConnection();
  bool Refresh();
  bool HasAnalogTriggers();
  bool HasForceFeedback();
  void Clean();
  void Vibrate(WORD leftMotorSpeed, WORD rightMotorSpeed);
  bool IsIdle();

  LONG GetDeadZone(float percent);
  DWORD GetMaxVibration();
};

extern Joystick joystick;
````

## File: src/lighting_debug.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "lighting_debug.h"
#include "lighting.h"
#include "cfg.h"
#include "common.h"

#include <imgui.h>
#include <math.h>

void lighting_debug(bool* isOpen)
{
    if (!ImGui::Begin("Lighting Debug", isOpen, ImGuiWindowFlags_::ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::End();
        return;
    }

    if (!(getmode_cached()->driver_mode == MODE_FIELD || getmode_cached()->driver_mode == MODE_BATTLE || getmode_cached()->driver_mode == MODE_WORLDMAP))
	{
		ImGui::Text("Not currently on a battle/field or worldmap.");
		ImGui::End();
		return;
	}

    ImGui::Text("Group ID: %s", lighting.getConfigGroup().c_str());

    bool isLightingEnabled = enable_lighting;
    if (ImGui::Checkbox("Enable Lighting", &isLightingEnabled))
    {
        enable_lighting = isLightingEnabled;
    }
    bool isPbrTexturesEnabled = lighting.isPbrTextureEnabled();
    if (ImGui::Checkbox("Enable PBR Textures", &isPbrTexturesEnabled))
    {
        lighting.setPbrTextureEnabled(isPbrTexturesEnabled);
    }
    bool isEnvironmentLightingEnabled = lighting.isEnvironmentLightingEnabled();
    if (ImGui::Checkbox("Enable Environment Lighting", &isEnvironmentLightingEnabled))
    {
        lighting.setEnvironmentLightingEnabled(isEnvironmentLightingEnabled);
    }
    int gameLightingMode = game_lighting;
    if (ImGui::Combo("Game Lighting", &gameLightingMode, "Original (CPU)\0Per-Vertex (GPU)\0Per-Pixel (GPU)\0"))
    {
        game_lighting = gameLightingMode;
    }
    ImGui::BeginGroup();
    if (ImGui::Button("Load config from disk")) {
        lighting.reload();
    }
    ImGui::SameLine();
    if (ImGui::Button("Save config to disk")) {
        lighting.save();
    }
    ImGui::EndGroup();
    if (ImGui::CollapsingHeader("Direct Lighting", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
    {
        vector3<float> lightDirVector = lighting.getWorldLightDir();
        float lightRotation[3] = { lightDirVector.x , lightDirVector.y };
        if (ImGui::DragFloat2("Light Rotation", lightRotation, 1.0f))
        {
            lightRotation[0] = std::max(0.0f, std::min(180.0f, lightRotation[0]));
            lightRotation[1] = std::max(0.0f, std::min(360.0f, lightRotation[1]));
            lighting.setWorldLightDir(lightRotation[0], lightRotation[1], 0.0f);
            lighting.setConfigEntry("light_rotation_vertical", lightRotation[0]);
	        lighting.setConfigEntry("light_rotation_horizontal", lightRotation[1]);
        }
        float lightIntensity = lighting.getLightIntensity();
        if (ImGui::DragFloat("Intensity##0", &lightIntensity, 0.01f, 0.0f, 100.0f))
        {
            lighting.setLightIntensity(lightIntensity);
            lighting.setConfigEntry("light_intensity", lightIntensity);
        }
        vector3<float> lightColorPoint3d = lighting.getLightColor();
        float lightColor[3] = { lightColorPoint3d.x, lightColorPoint3d.y, lightColorPoint3d.z };
        if (ImGui::ColorEdit3("Color##0", lightColor))
        {
            lighting.setLightColor(lightColor[0], lightColor[1], lightColor[2]);
            lighting.setConfigEntry("light_color", toml::array(lightColor[0], lightColor[1], lightColor[2]));
        }
    }
    if (ImGui::CollapsingHeader("Indirect Lighting", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
    {
        float ambientIntensity = lighting.getAmbientIntensity();
        if (ImGui::DragFloat("Intensity##1", &ambientIntensity, 0.01f, 0.0f, 100.0f))
        {
            lighting.setAmbientIntensity(ambientIntensity);
            lighting.setConfigEntry("ambient_light_intensity", ambientIntensity);
        }

        vector3<float> ambientLightColorPoint3d = lighting.getAmbientLightColor();
        float ambientLightColor[3] = { ambientLightColorPoint3d.x, ambientLightColorPoint3d.y, ambientLightColorPoint3d.z };
        if (ImGui::ColorEdit3("Color##1", ambientLightColor))
        {
            lighting.setAmbientLightColor(ambientLightColor[0], ambientLightColor[1], ambientLightColor[2]);
            lighting.setConfigEntry("ambient_light_color", toml::array(ambientLightColor[0], ambientLightColor[1], ambientLightColor[2]));
        }
    }
    if (ImGui::CollapsingHeader("Material", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
    {
        float roughness = lighting.getRoughness();
        if (ImGui::DragFloat("Roughness", &roughness, 0.01f, 0.0f, 1.0f))
        {
            lighting.setRoughness(roughness);
        }
        float metallic = lighting.getMetallic();
        if (ImGui::DragFloat("Metallic", &metallic, 0.01f, 0.0f, 1.0f))
        {
            lighting.setMetallic(metallic);
        }
        float specular = lighting.getSpecular();
        if (ImGui::DragFloat("Specular", &specular, 0.01f, 0.0f, 1.0f))
        {
            lighting.setSpecular(specular);
        }
        float roughnessScale = lighting.getRoughnessScale();
        if (ImGui::DragFloat("Roughness Scale", &roughnessScale, 0.01f, 0.0f, 2.0f))
        {
            lighting.setRoughnessScale(roughnessScale);
        }
        float metallicScale = lighting.getMetallicScale();
        if (ImGui::DragFloat("Metallic Scale", &metallicScale, 0.01f, 0.0f, 2.0f))
        {
            lighting.setMetallicScale(metallicScale);
        }
        float specularScale = lighting.getSpecularScale();
        if (ImGui::DragFloat("Specular Scale", &specularScale, 0.01f, 0.0f, 2.0f))
        {
            lighting.setSpecularScale(specularScale);
        }
    }
    if (ImGui::CollapsingHeader("Shadow map (common)", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
    {
        bool isShadowFaceCullingEnabled = lighting.isShadowFaceCullingEnabled();
        if (ImGui::Checkbox("Face culling", &isShadowFaceCullingEnabled))
        {
            lighting.setShadowFaceCullingEnabled(isShadowFaceCullingEnabled);
        }
        int shadowMapResolution = lighting.getShadowMapResolution();
        if (ImGui::SliderInt("Resolution", &shadowMapResolution, 512, 4096))
        {
            lighting.setShadowMapResolution(shadowMapResolution);
        }
        float shadowConstantBias = lighting.getShadowConstantBias();
        if (ImGui::DragFloat("Constant Bias", &shadowConstantBias, 0.001f, 0.0f, 1.0f))
        {
            lighting.setShadowConstantBias(shadowConstantBias);
        }
    }
    if (ImGui::CollapsingHeader("Battle shadow map", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
    {
        float shadowMapArea = lighting.getShadowMapArea();
        if (ImGui::DragFloat("Area##0", &shadowMapArea, 10.0f, 0.0f, 100000.0f))
        {
            lighting.setShadowMapArea(shadowMapArea);
        }
        float shadowMapNearFarSize = lighting.getShadowMapNearFarSize();
        if (ImGui::DragFloat("Near/far size##0", &shadowMapNearFarSize, 10.0f, 0.0f, 100000.0f))
        {
            lighting.setShadowMapNearFarSize(shadowMapNearFarSize);
        }
    }
    if (ImGui::CollapsingHeader("Field shadow map", ImGuiTreeNodeFlags_DefaultOpen| ImGuiTreeNodeFlags_SpanAvailWidth))
    {
        float fieldShadowOcclusion = lighting.getFieldShadowOcclusion();
        if (ImGui::DragFloat("Occlusion", &fieldShadowOcclusion, 0.01f, 0.0f, 1.0f))
        {
            lighting.setFieldShadowOcclusion(fieldShadowOcclusion);
            lighting.setConfigEntry("shadowmap_occlusion", fieldShadowOcclusion);
        }
        float fieldShadowMapArea = lighting.getFieldShadowMapArea();
        if (ImGui::DragFloat("Area##1", &fieldShadowMapArea, 10.0f, 0.0f, 100000.0f))
        {
            lighting.setFieldShadowMapArea(fieldShadowMapArea);
            lighting.setConfigEntry("shadowmap_area", fieldShadowMapArea);
        }
        float fieldShadowMapNearFarSize = lighting.getFieldShadowMapNearFarSize();
        if (ImGui::DragFloat("Near/far size##1", &fieldShadowMapNearFarSize, 10.0f, 0.0f, 100000.0f))
        {
            lighting.setFieldShadowMapNearFarSize(fieldShadowMapNearFarSize);
            lighting.setConfigEntry("shadowmap_near_far_size", fieldShadowMapNearFarSize);
        }
        float fieldShadowDistance = lighting.getFieldShadowFadeStartDistance();
        if (ImGui::DragFloat("Fade Start Distance", &fieldShadowDistance, 1.0f, 0.0f, 1000.0f))
        {
            lighting.setFieldShadowFadeStartDistance(fieldShadowDistance);
            lighting.setConfigEntry("shadowmap_fade_start_distance", fieldShadowDistance);
        }
        float fieldShadowFadeRange = lighting.getFieldShadowFadeRange();
        if (ImGui::DragFloat("Fade Range", &fieldShadowFadeRange, 1.0f, 0.0f, 1000.0f))
        {
            lighting.setFieldShadowFadeRange(fieldShadowFadeRange);
            lighting.setConfigEntry("shadowmap_fade_range", fieldShadowDistance);
        }
        float walkMeshExtrudeSize = lighting.getWalkmeshExtrudeSize();
        if (ImGui::DragFloat("Walkmesh extrude size", &walkMeshExtrudeSize, 0.01f, 0.0f, 100.0f))
        {
            lighting.setWalkmeshExtrudeSize(walkMeshExtrudeSize);
        }
        float offset = lighting.getWalkmeshPosOffset();
        if (ImGui::DragFloat("Walkmesh offset", &offset, 0.01f, -100.0f, 100.0f))
        {
            lighting.setWalkmeshPosOffset(offset);
        }
    }
    if (ImGui::CollapsingHeader("Debug", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
    {
        int debugOutput = lighting.GetDebugOutput();
        if (ImGui::Combo("Debug Output", &debugOutput, "Disabled\0Color\0Normal\0Roughness\0Metallic\0AO\0Specular\0IBL (Specular)\0IBL (Diffuse)\0"))
        {
            lighting.setDebugOutput(static_cast<DebugOutput>(debugOutput));
        }
        bool isHide2dEnabled = lighting.isHide2dEnabled();
        if (ImGui::Checkbox("Hide 2D", &isHide2dEnabled))
        {
            lighting.setHide2dEnabled(isHide2dEnabled);
        }
        bool isShowWalkmeshEnabled = lighting.isShowWalkmeshEnabled();
        if (ImGui::Checkbox("Show walkmesh", &isShowWalkmeshEnabled))
        {
            lighting.setShowWalkmeshEnabled(isShowWalkmeshEnabled);
        }
    }
    ImGui::End();
}
````

## File: src/lighting_debug.h
````
/****************************************************************************/
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

void lighting_debug(bool* isOpen);
````

## File: src/lighting.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "lighting.h"
#include "gl.h"
#include "globals.h"
#include "renderer.h"
#include "macro.h"
#include "cfg.h"
#include "utils.h"
#include <fstream>

Lighting lighting;

std::string Lighting::getConfigGroup()
{
	const struct game_mode *mode = getmode_cached();
	std::string ret;
	char *field_name = nullptr;

	switch(mode->driver_mode)
	{
		case MODE_FIELD:
			ret.append("field_");
			field_name = get_current_field_name();
			if (field_name) ret.append(field_name);
			break;
		case MODE_BATTLE:
			ret.append("bat_");
			ret.append(std::to_string(ff7_externals.modules_global_object->battle_id));
			break;
	}

	return ret;
}

auto Lighting::getConfigEntry(char *key)
{
	std::string groupKey = getConfigGroup();

	if (!groupKey.empty() && config.contains(groupKey))
	{
		auto ret = config[groupKey][key];
		if (ret) return ret;
	}

	return config[key];
}

void Lighting::loadConfig()
{
	try
	{
		if (enable_devtools && fileExists(configDevToolsPath))
			config = toml::parse_file(configDevToolsPath);
		else
			config = toml::parse_file(configPath);
	}
	catch (const toml::parse_error &err)
	{
		config = toml::parse("");
	}
}

void Lighting::initParamsFromConfig()
{
	struct game_mode *mode = getmode_cached();

	float lightRotationV = getConfigEntry("light_rotation_vertical").value_or(60.0);
	lightRotationV = std::max(0.0f, std::min(180.0f, lightRotationV));
	float lightRotationH = getConfigEntry("light_rotation_horizontal").value_or(60.0);
	lightRotationH = std::max(0.0f, std::min(360.0f, lightRotationH));
	lighting.setWorldLightDir(lightRotationV, lightRotationH, 0.0f);

	float lightIntensity = getConfigEntry("light_intensity").value_or(4.0);
	lighting.setLightIntensity(lightIntensity);

	toml::array *lightColorArray = getConfigEntry("light_color").as_array();
	if (lightColorArray != nullptr && lightColorArray->size() == 3)
	{
		float r = lightColorArray->get(0)->value<float>().value_or(1.0);
		float g = lightColorArray->get(1)->value<float>().value_or(1.0);
		float b = lightColorArray->get(2)->value<float>().value_or(1.0);
		lighting.setLightColor(r, g, b);
	}

	float ambientLightIntensity = getConfigEntry("ambient_light_intensity").value_or(1.0);
	lighting.setAmbientIntensity(ambientLightIntensity);

	toml::array *ambientLightColorArray = getConfigEntry("ambient_light_color").as_array();
	if (ambientLightColorArray != nullptr && ambientLightColorArray->size() == 3)
	{
		float r = ambientLightColorArray->get(0)->value<float>().value_or(1.0);
		float g = ambientLightColorArray->get(1)->value<float>().value_or(1.0);
		float b = ambientLightColorArray->get(2)->value<float>().value_or(1.0);
		lighting.setAmbientLightColor(r, g, b);
	}

	float roughness = config["material_roughness"].value_or(0.7);
	lighting.setRoughness(roughness);

	float metallic = config["material_metallic"].value_or(0.5);
	lighting.setMetallic(metallic);

	float specular = config["material_specular"].value_or(0.1);
	lighting.setSpecular(specular);

	int shadowMapResolution = config["shadowmap_resolution"].value_or(2048);
	shadowMapResolution = std::max(0, std::min(16384, shadowMapResolution));
	lighting.setShadowMapResolution(shadowMapResolution);

	if (mode->driver_mode == MODE_FIELD)
	{
		float occlusion = getConfigEntry("shadowmap_occlusion").value_or(0.3);
		lighting.setFieldShadowOcclusion(occlusion);

		float area = getConfigEntry("shadowmap_area").value_or(3000.0);
		lighting.setFieldShadowMapArea(area);

		float nearFarSize = getConfigEntry("shadowmap_near_far_size").value_or(3000.0);
		lighting.setFieldShadowMapNearFarSize(nearFarSize);

		float fadeStartDistance = getConfigEntry("shadowmap_fade_start_distance").value_or(1000.0);
		lighting.setFieldShadowFadeStartDistance(fadeStartDistance);

		float fadeStartRange = getConfigEntry("shadowmap_fade_range").value_or(100.0);
		lighting.setFieldShadowFadeRange(fadeStartRange);
	}
}

void Lighting::updateLightMatrices(const vector3<float>& center)
{
	struct game_mode *mode = getmode_cached();

	float rotMatrix[16];
	float degreeToRadian = M_PI / 180.0f;
	bx::mtxRotateXYZ(rotMatrix, lightingState.worldLightRot.x * degreeToRadian,
									 lightingState.worldLightRot.y * degreeToRadian, lightingState.worldLightRot.z * degreeToRadian);

	const float forwardVector[4] = {0.0f, 0.0f, -1.0f, 0.0};
	float worldSpaceLightDir[4] = {0.0f, 0.0f, 0.0f, 0.0};
	bx::vec4MulMtx(worldSpaceLightDir, forwardVector, rotMatrix);

	float area = lightingState.shadowMapArea;
	float nearFarSize = lightingState.shadowMapNearFarSize;

	if (mode->driver_mode == MODE_FIELD)
	{
		// In Field mode the z axis is the up vector so we swap y and z axis
		float tmp = worldSpaceLightDir[1];
		worldSpaceLightDir[1] = worldSpaceLightDir[2];
		worldSpaceLightDir[2] = -tmp;

		area = lightingState.fieldShadowMapArea;
		nearFarSize = lightingState.fieldShadowMapNearFarSize;
	}
	if (mode->driver_mode == MODE_WORLDMAP)
    {
		worldSpaceLightDir[1] *= -1.0f;
        worldSpaceLightDir[2] *= -1.0f;
		worldSpaceLightDir[3] *= -1.0f;
	}

	// Transform light direction into view space
	float viewSpaceLightDir[4];
	bx::vec4MulMtx(viewSpaceLightDir, worldSpaceLightDir, newRenderer.getViewMatrix());

    const bx::Vec3 at = { center.x, center.y, center.z };
    const bx::Vec3 eye = { center.x + viewSpaceLightDir[0],
                           center.y + viewSpaceLightDir[1],
                           center.z + viewSpaceLightDir[2] };

	bx::Vec3 up = {0, 1, 0};
	const bx::Vec3 viewDir = {worldSpaceLightDir[0], worldSpaceLightDir[1], worldSpaceLightDir[2]};
	if (bx::abs(bx::dot(viewDir, up)) > 0.999)
	{
		up = {1.0, 0.0, 0.0};
	}

	// Light view matrix
	bx::mtxLookAt(lightingState.lightViewMatrix, eye, at, up);

	// Light projection matrix
	bx::mtxOrtho(lightingState.lightProjMatrix, -area, area, -area, area,
							 -nearFarSize, nearFarSize, 0.0f, bgfx::getCaps()->homogeneousDepth);

	// Light view projection matrix
	bx::mtxMul(lightingState.lightViewProjMatrix, lightingState.lightViewMatrix, lightingState.lightProjMatrix);

	// Matrix for converting from NDC to texture coordinates
	const float sy = bgfx::getCaps()->originBottomLeft ? 0.5f : -0.5f;
	const float sz = bgfx::getCaps()->homogeneousDepth ? 0.5f : 1.0f;
	const float tz = bgfx::getCaps()->homogeneousDepth ? 0.5f : 0.0f;
	const float mtxCrop[16] =
			{
					0.5f,
					0.0f,
					0.0f,
					0.0f,
					0.0f,
					sy,
					0.0f,
					0.0f,
					0.0f,
					0.0f,
					sz,
					0.0f,
					0.5f,
					0.5f,
					tz,
					1.0f,
			};

	float mtxTmp[16];
	bx::mtxMul(mtxTmp, lightingState.lightProjMatrix, mtxCrop);
	bx::mtxMul(lightingState.lightViewProjTexMatrix, lightingState.lightViewMatrix, mtxTmp);

	// Inverse of all light transformations above
	bx::mtxInverse(lightingState.lightInvViewProjTexMatrix, lightingState.lightViewProjTexMatrix);
}

void Lighting::ff7_load_ibl()
{
	struct game_mode *mode = getmode_cached();
	static uint32_t prev_mode = -1;
	static char filename[64]{0};
	static char specularFullpath[MAX_PATH];
	static char diffuseFullpath[MAX_PATH];
	static WORD last_field_id = 0, last_battle_id = 0;

	switch (mode->driver_mode)
	{
	case MODE_BATTLE:
		if (mode->driver_mode != prev_mode || last_battle_id != ff7_externals.modules_global_object->battle_id)
		{
			last_battle_id = ff7_externals.modules_global_object->battle_id;

			sprintf(filename, "bat_%d", last_battle_id);
			sprintf(specularFullpath, "%s/%s/ibl/%s_s.dds", basedir, external_lighting_path.c_str(), filename);
			sprintf(diffuseFullpath, "%s/%s/ibl/%s_d.dds", basedir, external_lighting_path.c_str(), filename);

			newRenderer.prepareSpecularIbl(specularFullpath);
			newRenderer.prepareDiffuseIbl(diffuseFullpath);
		}
		break;
	case MODE_FIELD:
		if (mode->driver_mode != prev_mode || last_field_id != *ff7_externals.field_id)
		{
			last_field_id = *ff7_externals.field_id;

			sprintf(filename, "field_%d", last_field_id);
			sprintf(specularFullpath, "%s/%s/ibl/%s_s.dds", basedir, external_lighting_path.c_str(), filename);
			sprintf(diffuseFullpath, "%s/%s/ibl/%s_d.dds", basedir, external_lighting_path.c_str(), filename);

			newRenderer.prepareSpecularIbl(specularFullpath);
			newRenderer.prepareDiffuseIbl(diffuseFullpath);
		}
		break;
	default:
		break;
	}

	prev_mode = mode->driver_mode;
}

void Lighting::ff7_create_walkmesh(std::vector<struct walkmeshEdge> &edges)
{
	byte *level_data = *ff7_externals.field_level_data_pointer;
	if (!level_data)
	{
		return;
	}

	uint32_t walkmesh_offset = *(uint32_t *)(level_data + 0x16);

	WORD numTris = *(WORD *)(level_data + walkmesh_offset + 4);

	for (int i = 0; i < numTris; ++i)
	{
		vertex_3s *triangle_data = (vertex_3s *)(level_data + walkmesh_offset + 8 + 24 * i);

		for (int j = 0; j < 3; ++j)
		{
			struct nvertex vertex;
			vertex._.x = triangle_data[j].x;
			vertex._.y = triangle_data[j].y;
			vertex._.z = triangle_data[j].z;
			vertex.color.w = 1.0f;
			vertex.color.r = 0xff;
			vertex.color.g = 0xff;
			vertex.color.b = 0xff;
			vertex.color.a = 0xff;

			vertex.u = 0.0;
			vertex.v = 0.0;

			walkMeshVertices.push_back(vertex);
			walkMeshIndices.push_back(walkMeshIndices.size());
		}

		int vId0 = walkMeshVertices.size() - 3;
		int vId1 = walkMeshVertices.size() - 3 + 1;
		int vId2 = walkMeshVertices.size() - 3 + 2;
		walkmeshEdge e0;
		e0.v0 = vId0;
		e0.v1 = vId1;
		e0.ov = vId2;
		e0.prevEdge = -1;
		e0.nextEdge = -1;
		e0.isBorder = false;
		e0.perpDir = {0.0f, 0.0f, 0.0f};
		walkmeshEdge e1;
		e1.v0 = vId1;
		e1.v1 = vId2;
		e1.ov = vId0;
		e1.prevEdge = -1;
		e1.nextEdge = -1;
		e1.isBorder = false;
		e1.perpDir = {0.0f, 0.0f, 0.0f};
		walkmeshEdge e2;
		e2.v0 = vId2;
		e2.v1 = vId0;
		e2.ov = vId1;
		e2.prevEdge = -1;
		e2.nextEdge = -1;
		e2.isBorder = false;
		e2.perpDir = {0.0f, 0.0f, 0.0f};
		edges.push_back(e0);
		edges.push_back(e1);
		edges.push_back(e2);
	}
}

// creates the field walkmesh for rendering
void Lighting::createFieldWalkmesh(float extrudeSize)
{
	static WORD last_field_id = 0;

	if (*ff7_externals.field_id == last_field_id)
	{
		return;
	}

	walkMeshVertices.clear();
	walkMeshIndices.clear();

	std::vector<struct walkmeshEdge> edges;

	// Get the walkmesh triangles and edges
	ff7_create_walkmesh(edges);

	// Detect triangle edges that are external borders of the walkmesh
	// Border edges will be use to extrude a small area where field shadows will fade out
	// This is done to prevent sharp discontinuities at the walkmesh borders
	extractWalkmeshBorderData(edges);

	// Extract previous and next adjacent border edges
	// Calculate extrude direction for each border edge
	createWalkmeshBorderExtrusionData(edges);

	// Create triangles for the border extrusion
	createWalkmeshBorder(edges, extrudeSize);

	last_field_id = *ff7_externals.field_id;
}

void Lighting::extractWalkmeshBorderData(std::vector<struct walkmeshEdge> &edges)
{
	int numEdges = edges.size();
	for (int i = 0; i < numEdges; ++i)
	{
		auto &e = edges[i];
		vector3<float> pos0 = walkMeshVertices[e.v0]._;
		vector3<float> pos1 = walkMeshVertices[e.v1]._;

		bool isBorder = true;
		for (int j = 0; j < numEdges; ++j)
		{
			if (j == i)
			{
				continue;
			}

			auto &other_e = edges[j];
			vector3<float> other_pos0 = walkMeshVertices[other_e.v0]._;
			vector3<float> other_pos1 = walkMeshVertices[other_e.v1]._;

			float errorMargin = 0.001f;
			if (std::abs(pos0.x - other_pos0.x) < errorMargin && std::abs(pos0.y - other_pos0.y) < errorMargin && std::abs(pos0.z - other_pos0.z) < errorMargin &&
					std::abs(pos1.x - other_pos1.x) < errorMargin && std::abs(pos1.y - other_pos1.y) < errorMargin && std::abs(pos1.z - other_pos1.z) < errorMargin)
			{
				isBorder = false;
			}

			if (std::abs(pos1.x - other_pos0.x) < errorMargin && std::abs(pos1.y - other_pos0.y) < errorMargin && std::abs(pos1.z - other_pos0.z) < errorMargin &&
					std::abs(pos0.x - other_pos1.x) < errorMargin && std::abs(pos0.y - other_pos1.y) < errorMargin && std::abs(pos0.z - other_pos1.z) < errorMargin)
			{
				isBorder = false;
			}
		}
		e.isBorder = isBorder;

		if (isBorder)
		{
			auto &v0 = walkMeshVertices[e.v0];
			auto &v1 = walkMeshVertices[e.v1];
		}
	}
}

void Lighting::createWalkmeshBorderExtrusionData(std::vector<struct walkmeshEdge> &edges)
{
	int numEdges = edges.size();
	for (int i = 0; i < numEdges; ++i)
	{
		auto &e = edges[i];
		if (!e.isBorder)
		{
			continue;
		}

		vector3<float> pos0 = walkMeshVertices[e.v0]._;
		vector3<float> pos1 = walkMeshVertices[e.v1]._;

		for (int j = 0; j < numEdges; ++j)
		{
			if (j == i)
			{
				continue;
			}

			auto &other_e = edges[j];
			if (!other_e.isBorder)
			{
				continue;
			}

			vector3<float> other_pos0 = walkMeshVertices[other_e.v0]._;
			vector3<float> other_pos1 = walkMeshVertices[other_e.v1]._;

			float errorMargin = 0.1f;
			;
			if ((std::abs(pos0.x - other_pos0.x) < errorMargin && std::abs(pos0.y - other_pos0.y) < errorMargin && std::abs(pos0.z - other_pos0.z) < errorMargin) ||
					(std::abs(pos0.x - other_pos1.x) < errorMargin && std::abs(pos0.y - other_pos1.y) < errorMargin && std::abs(pos0.z - other_pos1.z) < errorMargin))
			{
				e.prevEdge = j;
			}

			if ((std::abs(pos1.x - other_pos0.x) < errorMargin && std::abs(pos1.y - other_pos0.y) < errorMargin && std::abs(pos1.z - other_pos0.z) < errorMargin) ||
					(std::abs(pos1.x - other_pos1.x) < errorMargin && std::abs(pos1.y - other_pos1.y) < errorMargin && std::abs(pos1.z - other_pos1.z) < errorMargin))
			{
				e.nextEdge = j;
			}

			vector3<float> pos0 = walkMeshVertices[e.v0]._;
			vector3<float> pos1 = walkMeshVertices[e.v1]._;
			vector3<float> ovPos = walkMeshVertices[e.ov]._;

			vector3<float> triCenter;
			add_vector(&pos0, &pos1, &triCenter);
			add_vector(&triCenter, &ovPos, &triCenter);
			divide_vector(&triCenter, 2.0f, &triCenter);

			vector3<float> edgeDir0;
			subtract_vector(&pos1, &pos0, &edgeDir0);
			normalize_vector(&edgeDir0);
			vector3<float> edgeDir1;
			subtract_vector(&ovPos, &pos0, &edgeDir1);
			normalize_vector(&edgeDir1);
			vector3<float> normal;
			cross_product(&edgeDir0, &edgeDir1, &normal);

			vector3<float> perpDir;
			cross_product(&edgeDir0, &normal, &perpDir);
			normalize_vector(&perpDir);

			vector3<float> ovDir0;
			subtract_vector(&pos0, &ovPos, &ovDir0);
			normalize_vector(&ovDir0);

			vector3<float> ovDir1;
			subtract_vector(&pos1, &ovPos, &ovDir1);
			normalize_vector(&ovDir1);

			if (dot_product(&ovDir0, &perpDir) < 0.0)
			{
				multiply_vector(&perpDir, -1.0f, &perpDir);
			}

			e.perpDir = perpDir;
		}
	}
}

void Lighting::createWalkmeshBorder(std::vector<struct walkmeshEdge> &edges, float extrudeSize)
{
	int numEdges = edges.size();
	for (int i = 0; i < numEdges; ++i)
	{
		auto &e = edges[i];
		if (e.isBorder == false)
		{
			continue;
		}

		vector3<float> pos0 = walkMeshVertices[e.v0]._;
		vector3<float> pos1 = walkMeshVertices[e.v1]._;

		if (e.prevEdge == -1 || e.nextEdge == -1)
			continue;

		auto &prevEdge = edges[e.prevEdge];
		auto &nextEdge = edges[e.nextEdge];

		vector3<float> capExtrudeDir0;
		add_vector(&e.perpDir, &prevEdge.perpDir, &capExtrudeDir0);
		normalize_vector(&capExtrudeDir0);

		vector3<float> capExtrudeDir1;
		add_vector(&e.perpDir, &nextEdge.perpDir, &capExtrudeDir1);
		normalize_vector(&capExtrudeDir1);

		// Extrude triangle 0
		vector3<float> extrudePos0;
		{
			vector3<float> perpDir = {capExtrudeDir0.x, capExtrudeDir0.y, capExtrudeDir0.z};
			float cos = dot_product(&e.perpDir, &capExtrudeDir0);

			vector3<float> extrudeOffset;
			multiply_vector(&perpDir, extrudeSize / cos, &extrudeOffset);

			add_vector(&pos0, &extrudeOffset, &extrudePos0);

			struct nvertex v0;
			v0._.x = pos1.x;
			v0._.y = pos1.y;
			v0._.z = pos1.z;
			v0.color.w = 1.0f;
			v0.color.r = 0xff;
			v0.color.g = 0x00;
			v0.color.b = 0x00;
			v0.color.a = 0xff;
			walkMeshVertices.push_back(v0);
			walkMeshIndices.push_back(walkMeshIndices.size());

			struct nvertex v1;
			v1._.x = pos0.x;
			v1._.y = pos0.y;
			v1._.z = pos0.z;
			v1.color.w = 1.0f;
			v1.color.r = 0xff;
			v1.color.g = 0x00;
			v1.color.b = 0x00;
			v1.color.a = 0xff;

			walkMeshVertices.push_back(v1);
			walkMeshIndices.push_back(walkMeshIndices.size());

			struct nvertex v2;
			v2._.x = extrudePos0.x;
			v2._.y = extrudePos0.y;
			v2._.z = extrudePos0.z;
			v2.color.w = 1.0f;
			v2.color.r = 0xff;
			v2.color.g = 0x00;
			v2.color.b = 0x00;
			v2.color.a = 0x00;

			walkMeshVertices.push_back(v2);
			walkMeshIndices.push_back(walkMeshIndices.size());
		}

		// Extrude triangle 1
		vector3<float> extrudePos1;
		{
			vector3<float> perpDir = {capExtrudeDir1.x, capExtrudeDir1.y, capExtrudeDir1.z};
			float cos = dot_product(&e.perpDir, &capExtrudeDir1);

			vector3<float> extrudeOffset;
			multiply_vector(&perpDir, extrudeSize / cos, &extrudeOffset);

			add_vector(&pos1, &extrudeOffset, &extrudePos1);

			struct nvertex v0;
			v0._.x = extrudePos1.x;
			v0._.y = extrudePos1.y;
			v0._.z = extrudePos1.z;
			v0.color.w = 1.0f;
			v0.color.r = 0xff;
			v0.color.g = 0x00;
			v0.color.b = 0x00;
			v0.color.a = 0x00;

			walkMeshVertices.push_back(v0);
			walkMeshIndices.push_back(walkMeshIndices.size());

			struct nvertex v1;
			v1._.x = pos1.x;
			v1._.y = pos1.y;
			v1._.z = pos1.z;
			v1.color.w = 1.0f;
			v1.color.r = 0xff;
			v1.color.g = 0x00;
			v1.color.b = 0x00;
			v1.color.a = 0xff;

			walkMeshVertices.push_back(v1);
			walkMeshIndices.push_back(walkMeshIndices.size());

			struct nvertex v2;
			v2._.x = extrudePos0.x;
			v2._.y = extrudePos0.y;
			v2._.z = extrudePos0.z;
			v2.color.w = 1.0f;
			v2.color.r = 0xff;
			v2.color.g = 0x00;
			v2.color.b = 0x00;
			v2.color.a = 0x00;

			walkMeshVertices.push_back(v2);
			walkMeshIndices.push_back(walkMeshIndices.size());
		}
	}
}

struct boundingbox Lighting::calcFieldSceneAabb(struct boundingbox *sceneAabb)
{
	byte *level_data = *ff7_externals.field_level_data_pointer;
	if (!level_data)
	{
		return *sceneAabb;
	}

	uint32_t walkmesh_offset = *(uint32_t *)(level_data + 0x16);

	std::vector<struct nvertex> vertices;
	std::vector<WORD> indices;
	std::vector<struct walkmeshEdge> edges;

	WORD numTris = *(WORD *)(level_data + walkmesh_offset + 4);

	vector3<float> boundingMin = {FLT_MAX, FLT_MAX, FLT_MAX};
	vector3<float> boundingMax = {FLT_MIN, FLT_MIN, FLT_MIN};

	// Calculates walkmesh AABB
	for (int i = 0; i < numTris; ++i)
	{
		vertex_3s *triangle_data = (vertex_3s *)(level_data + walkmesh_offset + 8 + 24 * i);

		for (int j = 0; j < 3; ++j)
		{
			boundingMin.x = std::min(boundingMin.x, static_cast<float>(triangle_data[j].x));
			boundingMin.y = std::min(boundingMin.y, static_cast<float>(triangle_data[j].y));
			boundingMin.z = std::min(boundingMin.z, static_cast<float>(triangle_data[j].z));
			boundingMax.x = std::max(boundingMax.x, static_cast<float>(triangle_data[j].x));
			boundingMax.y = std::max(boundingMax.y, static_cast<float>(triangle_data[j].y));
			boundingMax.z = std::max(boundingMax.z, static_cast<float>(triangle_data[j].z));
		}
	}

	// Calculates walkmesh AABB in view space
	struct boundingbox bb;
	bb.min_x = FLT_MAX;
	bb.min_y = FLT_MAX;
	bb.min_z = FLT_MAX;
	bb.max_x = FLT_MIN;
	bb.max_y = FLT_MIN;
	bb.max_z = FLT_MIN;

	vector3<float> corners[8] = {{boundingMin.x, boundingMin.y, boundingMin.z},
															 {boundingMin.x, boundingMin.y, boundingMax.z},
															 {boundingMin.x, boundingMax.y, boundingMin.z},
															 {boundingMin.x, boundingMax.y, boundingMax.z},
															 {boundingMax.x, boundingMin.y, boundingMin.z},
															 {boundingMax.x, boundingMin.y, boundingMax.z},
															 {boundingMax.x, boundingMax.y, boundingMin.z},
															 {boundingMax.x, boundingMax.y, boundingMax.z}};

	for (int j = 0; j < 8; ++j)
	{
		vector3<float> cornerViewSpace;
		struct matrix viewMatrix;
		::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
		transform_point(&viewMatrix, &corners[j], &cornerViewSpace);

		bb.min_x = std::min(bb.min_x, cornerViewSpace.x);
		bb.min_y = std::min(bb.min_y, cornerViewSpace.y);
		bb.min_z = std::min(bb.min_z, cornerViewSpace.z);

		bb.max_x = std::max(bb.max_x, cornerViewSpace.x);
		bb.max_y = std::max(bb.max_y, cornerViewSpace.y);
		bb.max_z = std::max(bb.max_z, cornerViewSpace.z);
	}

	bb.min_x = std::min(bb.min_x, sceneAabb->min_x);
	bb.min_y = std::min(bb.min_y, sceneAabb->min_y);
	bb.min_z = std::min(bb.min_z, sceneAabb->min_z);

	bb.max_x = std::max(bb.max_x, sceneAabb->max_x);
	bb.max_y = std::max(bb.max_y, sceneAabb->max_y);
	bb.max_z = std::max(bb.max_z, sceneAabb->max_z);

	return bb;
}

void Lighting::init()
{
	sprintf(configPath, "%s/%s/config.toml", basedir, external_lighting_path.c_str());
	sprintf(configDevToolsPath, "%s/%s/config.devtools.toml", basedir, external_lighting_path.c_str());

	reload();
}

void Lighting::reload()
{
	loadConfig();
	initParamsFromConfig();
}

void Lighting::save()
{
	std::ofstream ofs(configDevToolsPath);
	ofs << config << std::endl;
}

void Lighting::draw(struct game_obj *game_object)
{
	VOBJ(game_obj, game_object, game_object);
	struct game_mode *mode = getmode_cached();
	static WORD last_field_id = 0, last_battle_id = 0;

	ff7_load_ibl();

	struct boundingbox sceneAabb = calculateSceneAabb();

	switch(mode->driver_mode)
	{
		case MODE_FIELD:
		{
			// Refresh the configuration if we're on a new field
			if (last_field_id != *ff7_externals.field_id)
			{
				last_field_id = *ff7_externals.field_id;
				initParamsFromConfig();
			}

			struct boundingbox fieldSceneAabb = calcFieldSceneAabb(&sceneAabb);

			// Light view frustum pointing to scene AABB center
			vector3<float> center = {
				0.5f * (fieldSceneAabb.min_x + fieldSceneAabb.max_x),
				0.5f * (fieldSceneAabb.min_y + fieldSceneAabb.max_y),
				0.5f * (fieldSceneAabb.min_z + fieldSceneAabb.max_z) };

				float viewSpaceCenter[4];
	float centerFloat[4];
	centerFloat[0] = center.x;
	centerFloat[1] = center.y;
	centerFloat[2] = center.z;
	centerFloat[3] = 1;
	bx::vec4MulMtx(viewSpaceCenter, centerFloat, newRenderer.getViewMatrix());
			updateLightMatrices(center);
			gl_draw_deferred(&drawFieldShadowCallback);
			break;
		}
		case MODE_WORLDMAP:
		{
			int world_pos_x = ff7_externals.world_player_pos_E04918->x;
			int world_pos_y = ff7_externals.world_player_pos_E04918->y;
			int world_pos_z = ff7_externals.world_player_pos_E04918->z;

			// Light view frustum pointing to player position
			vector3<float> center = {
				static_cast<float>(world_pos_x),
				static_cast<float>(world_pos_y),
				static_cast<float>(world_pos_z)};

			struct matrix viewMatrix;
    		::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
			vector3<float> centerViewSpace;
			transform_point(&viewMatrix, &center, &centerViewSpace);

			updateLightMatrices(centerViewSpace);
			gl_draw_deferred(nullptr);
		}
		break;
		case MODE_BATTLE:
		{
			// Refresh the configuration if we're on a new battle
			if (last_battle_id != ff7_externals.modules_global_object->battle_id)
			{
				last_battle_id = ff7_externals.modules_global_object->battle_id;
				initParamsFromConfig();
			}
		}
		default:
		{
			// Light view frustum pointing to scene AABB center
			vector3<float> center = {
				0.5f * (sceneAabb.min_x + sceneAabb.max_x),
				0.5f * (sceneAabb.min_y + sceneAabb.max_y),
				0.5f * (sceneAabb.min_z + sceneAabb.max_z) };

			updateLightMatrices(center);
			gl_draw_deferred(nullptr);
			break;
		}
	}
}

void drawFieldShadowCallback()
{
	lighting.createFieldWalkmesh(lighting.getWalkmeshExtrudeSize());

	auto walkMeshVertices = lighting.getWalkmeshVertices();
	auto walkMeshIndices = lighting.getWalkmeshIndices();

	newRenderer.bindVertexBuffer(walkMeshVertices.data(), 0, walkMeshVertices.size());
	newRenderer.bindIndexBuffer(walkMeshIndices.data(), walkMeshIndices.size());

	newRenderer.setPrimitiveType();
	newRenderer.isTLVertex(false);
	newRenderer.setCullMode(RendererCullMode::BACK);
	newRenderer.setBlendMode(RendererBlendMode::BLEND_AVG);
	newRenderer.isFBTexture(false);
	newRenderer.doDepthTest(true);
	newRenderer.doDepthWrite(false);

	// Create a world matrix
	struct matrix worldMatrix;
	identity_matrix(&worldMatrix);

	// WalkMesh offset to adjust vertical position of walkmesh so that it is just under the character feets
	worldMatrix._43 = lighting.getWalkmeshPosOffset();

	// View matrix
	struct matrix viewMatrix;
	memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));

	// Create a world view matrix
	struct matrix worldViewMatrix;
	multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix);
	newRenderer.setWorldViewMatrix(&worldViewMatrix);

	newRenderer.drawFieldShadow();
}

const LightingState &Lighting::getLightingState()
{
	return lightingState;
}

void Lighting::setPbrTextureEnabled(bool isEnabled)
{
	lightingState.lightingSettings[0] = isEnabled;
}

bool Lighting::isPbrTextureEnabled()
{
	return lightingState.lightingSettings[0];
}

void Lighting::setEnvironmentLightingEnabled(bool isEnabled)
{
	lightingState.lightingSettings[1] = isEnabled;
}

bool Lighting::isEnvironmentLightingEnabled()
{
	return lightingState.lightingSettings[1];
}

void Lighting::setWorldLightDir(float dirX, float dirY, float dirZ)
{
	lightingState.worldLightRot.x = dirX;
	lightingState.worldLightRot.y = dirY;
	lightingState.worldLightRot.z = dirZ;
}

vector3<float> Lighting::getWorldLightDir()
{
	return lightingState.worldLightRot;
}

void Lighting::setLightIntensity(float intensity)
{
	lightingState.lightData[3] = intensity;
}

float Lighting::getLightIntensity()
{
	return lightingState.lightData[3];
}

void Lighting::setLightColor(float r, float g, float b)
{
	lightingState.lightData[0] = r;
	lightingState.lightData[1] = g;
	lightingState.lightData[2] = b;
}

vector3<float> Lighting::getLightColor()
{
	vector3<float> color = {lightingState.lightData[0],
													lightingState.lightData[1],
													lightingState.lightData[2]};
	return color;
}

void Lighting::setAmbientIntensity(float intensity)
{
	lightingState.ambientLightData[3] = intensity;
}

float Lighting::getAmbientIntensity()
{
	return lightingState.ambientLightData[3];
}

void Lighting::setAmbientLightColor(float r, float g, float b)
{
	lightingState.ambientLightData[0] = r;
	lightingState.ambientLightData[1] = g;
	lightingState.ambientLightData[2] = b;
}

vector3<float> Lighting::getAmbientLightColor()
{
	vector3<float> color = {lightingState.ambientLightData[0],
													lightingState.ambientLightData[1],
													lightingState.ambientLightData[2]};
	return color;
}

void Lighting::setIblMipCount(int mipCount)
{
	lightingState.iblData[0] = mipCount;
}

bool Lighting::isDisabledLightingTexture(const std::string &textureName)
{
	toml::array *disabledTextures = config["disable_lighting_textures"].as_array();
	if (disabledTextures && !disabledTextures->empty() && disabledTextures->is_homogeneous(toml::node_type::string))
	{
		int count = disabledTextures->size();
		for (int i = 0; i < count; ++i)
		{
			auto disabledTextureName = disabledTextures->get(i)->value<std::string>();
			if (disabledTextureName.has_value() && textureName == disabledTextureName.value())
			{
				return true;
			}
		}
	}

	return false;
}

void Lighting::setRoughness(float roughness)
{
	lightingState.materialData[0] = roughness;
}

float Lighting::getRoughness()
{
	return lightingState.materialData[0];
}

void Lighting::setMetallic(float metallic)
{
	lightingState.materialData[1] = metallic;
}

float Lighting::getMetallic()
{
	return lightingState.materialData[1];
}

void Lighting::setSpecular(float specular)
{
	lightingState.materialData[2] = specular;
}

float Lighting::getSpecular()
{
	return lightingState.materialData[2];
}

void Lighting::setRoughnessScale(float scale)
{
	lightingState.materialScaleData[0] = scale;
}

float Lighting::getRoughnessScale()
{
	return lightingState.materialScaleData[0];
}

void Lighting::setMetallicScale(float scale)
{
	lightingState.materialScaleData[1] = scale;
}

float Lighting::getMetallicScale()
{
	return lightingState.materialScaleData[1];
}

void Lighting::setSpecularScale(float scale)
{
	lightingState.materialScaleData[2] = scale;
}

float Lighting::getSpecularScale()
{
	return lightingState.materialScaleData[2];
}

void Lighting::setShadowFaceCullingEnabled(bool isEnabled)
{
	lightingState.isShadowMapFaceCullingEnabled = isEnabled;
}

bool Lighting::isShadowFaceCullingEnabled()
{
	return lightingState.isShadowMapFaceCullingEnabled;
}

void Lighting::setShadowMapResolution(int resolution)
{
	lightingState.shadowData[3] = resolution;
	newRenderer.prepareShadowMap();
}

int Lighting::getShadowMapResolution()
{
	return lightingState.shadowData[3];
}

void Lighting::setShadowConstantBias(float bias)
{
	lightingState.shadowData[0] = bias;
}

float Lighting::getShadowConstantBias()
{
	return lightingState.shadowData[0];
}

void Lighting::setShadowMapArea(float area)
{
	lightingState.shadowMapArea = area;
}

float Lighting::getShadowMapArea()
{
	return lightingState.shadowMapArea;
}

void Lighting::setShadowMapNearFarSize(float size)
{
	lightingState.shadowMapNearFarSize = size;
}

float Lighting::getShadowMapNearFarSize()
{
	return lightingState.shadowMapNearFarSize;
}

void Lighting::setFieldShadowMapArea(float area)
{
	lightingState.fieldShadowMapArea = area;
}

float Lighting::getFieldShadowMapArea()
{
	return lightingState.fieldShadowMapArea;
}

void Lighting::setFieldShadowMapNearFarSize(float size)
{
	lightingState.fieldShadowMapNearFarSize = size;
}

float Lighting::getFieldShadowMapNearFarSize()
{
	return lightingState.fieldShadowMapNearFarSize;
}

void Lighting::setFieldShadowOcclusion(float value)
{
	lightingState.fieldShadowData[0] = value;
}

float Lighting::getFieldShadowOcclusion()
{
	return lightingState.fieldShadowData[0];
}

void Lighting::setFieldShadowFadeStartDistance(float value)
{
	lightingState.fieldShadowData[1] = value;
}

float Lighting::getFieldShadowFadeStartDistance()
{
	return lightingState.fieldShadowData[1];
}

void Lighting::setFieldShadowFadeRange(float value)
{
	lightingState.fieldShadowData[2] = value;
}

float Lighting::getFieldShadowFadeRange()
{
	return lightingState.fieldShadowData[2];
}

void Lighting::setWalkmeshExtrudeSize(float size)
{
	lightingState.walkMeshExtrudeSize = size;
}

float Lighting::getWalkmeshExtrudeSize()
{
	return lightingState.walkMeshExtrudeSize;
}

void Lighting::setWalkmeshPosOffset(float offset)
{
	lightingState.walkMeshPosOffset = offset;
}

float Lighting::getWalkmeshPosOffset()
{
	return lightingState.walkMeshPosOffset;
}

const std::vector<nvertex> &Lighting::getWalkmeshVertices()
{
	return walkMeshVertices;
}

const std::vector<WORD> &Lighting::getWalkmeshIndices()
{
	return walkMeshIndices;
}

void Lighting::setHide2dEnabled(bool isEnabled)
{
	lightingState.lightingDebugData[0] = isEnabled;
}

bool Lighting::isHide2dEnabled()
{
	return lightingState.lightingDebugData[0];
}

void Lighting::setShowWalkmeshEnabled(bool isEnabled)
{
	lightingState.lightingDebugData[1] = isEnabled;
}

bool Lighting::isShowWalkmeshEnabled()
{
	return lightingState.lightingDebugData[1];
}

void Lighting::setDebugOutput(DebugOutput output)
{
	lightingState.lightingDebugData[2] = output;
}

DebugOutput Lighting::GetDebugOutput()
{
	return static_cast<DebugOutput>(lightingState.lightingDebugData[2]);
}
````

## File: src/lighting.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "common_imports.h"

#include <vector>
#include <toml++/toml.h>
#include <windows.h>

enum DebugOutput
{
    DEBUG_OUTPUT_DISABLED = 0,
    DEBUG_OUTPUT_COLOR,
    DEBUG_OUTPUT_NORMALMAP,
    DEBUG_OUTPUT_ROUGHNESS,
    DEBUG_OUTPUT_METALLIC,
    DEBUG_OUTPUT_AO,
    DEBUG_OUTPUT_SPECULAR,
    DEBUG_OUTPUT_IBL_SPECULAR,
    DEBUG_OUTPUT_IBL_DIFFUSE,
};

struct walkmeshEdge
{
    int v0;                      // edge vertex index 0
    int v1;                      // edge vertex index 1
    int ov;                      // opposite vertex index
    int prevEdge;                // previous vertex index
    int nextEdge;	             // next vertex index
    bool isBorder;               // border edge flag
    vector3<float> perpDir;      // perpendicular direction
};

struct LightingState
{
    float lightViewMatrix[16];
    float lightProjMatrix[16];
    float lightInvViewProjTexMatrix[16];
    float lightViewProjMatrix[16];
    float lightViewProjTexMatrix[16];

    float lightingSettings[4] = { 1.0, 1.0, 1.0, 0.0 };
    float lightDirData[4] = { 0.3, -1.0, -0.3, 0.0 };
    float lightData[4] = { 1.0, 1.0, 1.0, 4.0 };
    float ambientLightData[4] = { 1.0, 1.0, 1.0, 1.0 };
    float materialData[4] = { 0.7, 0.5, 0.1, 0.0 };
    float materialScaleData[4] = { 1.0, 1.0, 1.0, 1.0 };
    float shadowData[4] = { 0.001, 0.0, 0.0, 2048.0 };
    float fieldShadowData[4] = { 0.3, 1000.0, 100.0, 0.0 };
    float iblData[4] = { 1.0, 0.0, 0.0, 0.0 };

    float lightingDebugData[4] = { 0.0, 0.0, 0.0, 0.0 };

    // Light Direction
    vector3<float> worldLightRot = { 60.0, 60.0, 0.0 };

    // Shadowmap face culling
    bool isShadowMapFaceCullingEnabled = false;

    // Battle shadowmap frustum parameters
    float shadowMapArea = 20000.0f;
    float shadowMapNearFarSize = 20000.0f;

    // Field shadowmap frustum parameters
    float fieldShadowMapArea = 3000.0f;
    float fieldShadowMapNearFarSize = 3000.0f;

    // Field Shadow walkmesh parameters
    float walkMeshExtrudeSize = 20.0;
    float walkMeshPosOffset = -11.0;
};

class Lighting
{
private:
    LightingState lightingState;

    // Config
    char configPath[MAX_PATH];
    char configDevToolsPath[MAX_PATH];
    toml::parse_result config;

    std::vector<nvertex> walkMeshVertices;
    std::vector<WORD> walkMeshIndices;

    auto getConfigEntry(char* key);

    void loadConfig();
    void initParamsFromConfig();

    void ff7_load_ibl();

    void ff7_create_walkmesh(std::vector<struct walkmeshEdge>& edges);

    void extractWalkmeshBorderData(std::vector<struct walkmeshEdge>& edges);
    void createWalkmeshBorderExtrusionData(std::vector<struct walkmeshEdge>& edges);
    void createWalkmeshBorder(std::vector<struct walkmeshEdge>& edges, float extrudeSize);
    struct boundingbox calcFieldSceneAabb(struct boundingbox* sceneAbb);

public:
    void init();
    void reload();
    void save();

    void updateLightMatrices(const vector3<float>& center);
    void draw(struct game_obj* game_object);

    const LightingState& getLightingState();

    // Config
    std::string getConfigGroup();
    void setConfigEntry(const char* key, auto value);

    // Lighting
    void setPbrTextureEnabled(bool isEnabled);
    bool isPbrTextureEnabled();
    void setEnvironmentLightingEnabled(bool isEnabled);
    bool isEnvironmentLightingEnabled();
    void setWorldLightDir(float dirX, float dirY, float dirZ);
    vector3<float> getWorldLightDir();
    void setLightIntensity(float intensity);
    float getLightIntensity();
    void setLightColor(float r, float g, float b);
    vector3<float> getLightColor();
    void setAmbientIntensity(float intensity);
    float getAmbientIntensity();
    void setAmbientLightColor(float r, float g, float b);
    vector3<float> getAmbientLightColor();
    void setIblMipCount(int mipCount);
    bool isDisabledLightingTexture(const std::string& textureName);

    // Material
    void setRoughness(float roughness);
    float getRoughness();
    void setMetallic(float metallic);
    float getMetallic();
    void setSpecular(float metallic);
    float getSpecular();
    void setRoughnessScale(float scale);
    float getRoughnessScale();
    void setMetallicScale(float scale);
    float getMetallicScale();
    void setSpecularScale(float scale);
    float getSpecularScale();

    // Shadow (common)
    void setShadowFaceCullingEnabled(bool isEnabled);
    bool isShadowFaceCullingEnabled();
    void setShadowMapResolution(int size);
    int getShadowMapResolution();
    void setShadowConstantBias(float bias);
    float getShadowConstantBias();

    // Battle Shadow
    void setShadowMapArea(float area);
    float getShadowMapArea();
    void setShadowMapNearFarSize(float size);
    float getShadowMapNearFarSize();

    // Field Shadow
    void createFieldWalkmesh(float extrudeSize);
    void setFieldShadowMapArea(float area);
    float getFieldShadowMapArea();
    void setFieldShadowMapNearFarSize(float size);
    float getFieldShadowMapNearFarSize();
    void setFieldShadowOcclusion(float value);
    float getFieldShadowOcclusion();
    void setFieldShadowFadeStartDistance(float value);
    float getFieldShadowFadeStartDistance();
    void setFieldShadowFadeRange(float value);
    float getFieldShadowFadeRange();
    void setWalkmeshExtrudeSize(float size);
    float getWalkmeshExtrudeSize();
    void setWalkmeshPosOffset(float size);
    float getWalkmeshPosOffset();
    const std::vector<nvertex>& getWalkmeshVertices();
    const std::vector<WORD>& getWalkmeshIndices();

    // Lighting Debug
    void setHide2dEnabled(bool isEnabled);
    bool isHide2dEnabled();
    void setShowWalkmeshEnabled(bool isEnabled);
    bool isShowWalkmeshEnabled();
    void setDebugOutput(DebugOutput output);
    DebugOutput GetDebugOutput();
};

inline void Lighting::setConfigEntry(const char *key, auto value)
{
	std::string groupKey = getConfigGroup();

	if (!groupKey.empty())
	{
		if (config.contains(groupKey))
			config[groupKey].as_table()->insert_or_assign(key, value);
		else
			config.insert_or_assign(groupKey, toml::table{ {key, value} });
	}
	else
		config.insert_or_assign(key, value);
}

void drawFieldShadowCallback();

extern Lighting lighting;
````

## File: src/log.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <string>
#include <stdio.h>
#include <windows.h>

#include "log.h"
#include "hext.h"
#include "utils.h"

#define FFNX_DEBUG_BUFFER_SIZE 4096

FILE *app_log;

void open_applog(char *path)
{
	app_log = fopen(path, "wb");

	if(!app_log) MessageBoxA(gameHwnd, "Failed to open log file", "Error", 0);
}

void plugin_trace(const char *fmt, ...)
{
	va_list args;
	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];

	va_start(args, fmt);

	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);

	va_end(args);

	ffnx_trace("%s", tmp_str);
}

void plugin_info(const char *fmt, ...)
{
	va_list args;
	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];

	va_start(args, fmt);

	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);

	va_end(args);

	ffnx_info("%s", tmp_str);
}

void plugin_glitch(const char *fmt, ...)
{
	va_list args;
	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];

	va_start(args, fmt);

	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);

	va_end(args);

	ffnx_glitch("%s", tmp_str);
}

void plugin_error(const char *fmt, ...)
{
	va_list args;
	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];

	va_start(args, fmt);

	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);

	va_end(args);

	ffnx_error("%s", tmp_str);
}

void debug_print(const char *str)
{
	char tmp_str[FFNX_DEBUG_BUFFER_SIZE + 16];

	sprintf(tmp_str, "[%08i] %s", frame_counter, str);

	fwrite(tmp_str, 1, strlen(tmp_str), app_log);
	fflush(app_log);
}

void show_popup_msg(uint8_t text_color, const char* fmt, ...)
{
	va_list args;
	char tmp_str[1024];

	va_start(args, fmt);

	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);

	va_end(args);

	strcpy(popup_msg, tmp_str);
	popup_ttl = POPUP_TTL_MAX;
	popup_color = text_colors[text_color];
}

void clear_popup_msg()
{
	popup_ttl = 0;
}

uint32_t get_popup_time()
{
	return popup_ttl;
}

void external_debug_print(const char *str)
{
	std::string msg(str);
	msg.erase(std::remove(msg.begin(), msg.end(), '\n'), msg.end());
	trim(msg);

	if (msg.length() == 0) return;

	if (ff8)
	{
		if (starts_with(msg, "Patch")) return;
	}
	else
	{
		if (starts_with(msg, "SET VOLUME")) return;
	}

	hextPatcher.applyAll(msg);

	msg += "\n";

	if (show_applog) debug_print(msg.c_str());
	if (show_error_popup) show_popup_msg(TEXTCOLOR_GRAY, str);
}

void external_debug_print2(const char *fmt, ...)
{
	va_list args;
	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];

	va_start(args, fmt);

	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);

	va_end(args);

	external_debug_print(tmp_str);
}

void debug_printf(const char *prefix, uint32_t color, const char *fmt, ...)
{
	va_list args;
	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];
	char tmp_str2[FFNX_DEBUG_BUFFER_SIZE];

	va_start(args, fmt);

	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);

	va_end(args);

	if ( prefix == nullptr)
		_snprintf(tmp_str2, sizeof(tmp_str2), "%s", tmp_str);
	else
		_snprintf(tmp_str2, sizeof(tmp_str2), "%s: %s", prefix, tmp_str);
	debug_print(tmp_str2);
}

void windows_error(uint32_t error)
{
	char tmp_str[200];

	if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error == 0 ? GetLastError() : error, 0, tmp_str, sizeof(tmp_str), 0)) debug_print(tmp_str);
}
````

## File: src/log.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

// Header include necessary due to macro dependencies
#include "cfg.h"
#include "common.h"
#include "globals.h"

#define ffnx_error(x, ...) debug_printf("ERROR", text_colors[TEXTCOLOR_RED], (x), ## __VA_ARGS__)
#define ffnx_warning(x, ...) debug_printf("WARNING", text_colors[TEXTCOLOR_YELLOW], (x), ## __VA_ARGS__)
#define ffnx_info(x, ...) debug_printf("INFO", text_colors[TEXTCOLOR_WHITE], (x), ## __VA_ARGS__)
#define ffnx_dump(x, ...) debug_printf("DUMP", text_colors[TEXTCOLOR_PINK], (x), ## __VA_ARGS__)
#define ffnx_trace(x, ...) debug_printf("TRACE", text_colors[TEXTCOLOR_GREEN], (x), ## __VA_ARGS__)
#define ffnx_glitch(x, ...) debug_printf("GLITCH", text_colors[TEXTCOLOR_GRAY], (x), ## __VA_ARGS__)
#define ffnx_unexpected(x, ...) debug_printf("UNEXPECTED", text_colors[TEXTCOLOR_LIGHT_BLUE], (x), ## __VA_ARGS__)

#define ffnx_glitch_once(x, ...) { static uint32_t glitch_ ## __LINE__ = false; if(!glitch_ ## __LINE__) { ffnx_glitch(x, ## __VA_ARGS__); glitch_ ## __LINE__ = true; } }
#define ffnx_unexpected_once(x, ...) { static uint32_t unexpected_ ## __LINE__ = false; if(!unexpected_ ## __LINE__) { ffnx_unexpected(x, ## __VA_ARGS__); unexpected_ ## __LINE__ = true; } }

void open_applog(char *path);

void plugin_trace(const char *fmt, ...);
void plugin_info(const char *fmt, ...);
void plugin_glitch(const char *fmt, ...);
void plugin_error(const char *fmt, ...);

void external_debug_print(const char *str);
void external_debug_print2(const char *fmt, ...);

void show_popup_msg(uint8_t text_color, const char* fmt, ...);
void clear_popup_msg();
uint32_t get_popup_time();

void debug_printf(const char *, uint32_t, const char *, ...);

void windows_error(uint32_t error);
````

## File: src/macro.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#define LIST_FOR_EACH(X, Y) for((X) = (Y)->head; (X); (X) = (X)->next)

/*
 * Versioned structure macros, used to access FF7 and FF8 data in a portable
 * way. Allows massive, relatively straightforward code reuse between the two
 * games. Watch out for block statements and using expressions with side
 * effects! These macros can have unintended effects if you're not careful.
 */

/*
 * VOBJ - Define a versioned object, structure must have FF7 and FF8 variants
 * named ff7_<type name> and ff8_<type name> respectively.
 * X - type name
 * Y - object name
 * Z - initial value
 */
#define VOBJ(X,Y,Z) struct ff7_ ## X *ff7_ ## Y = ff8 ? 0 : (struct ff7_ ## X *)(Z); struct ff8_ ## X *ff8_ ## Y = ff8 ? (struct ff8_ ## X *)(Z) : 0

/*
 * VPTR - Access the raw pointer contained in an object.
 * X - object
 */
#define VPTR(X) (ff8 ? (void *)ff8_ ## X : (void *)ff7_ ## X)

 /*
  * VPTRCAST - Access the raw pointer contained in an object, casting to a defined type
  * T - object type
  * X - object
  */
#define VPTRCAST(T, X) (ff8 ? (struct T *)ff8_ ## X : (struct T *)ff7_ ## X)

/*
 * VASS - Assign a new pointer to an object.
 * T - object type
 * X - object
 * Y - new value
 */
#define VASS(T,X,Y) { if(ff8) ff8_ ## X = (struct ff8_ ## T *)(Y); else ff7_ ## X = (struct ff7_ ## T *)(Y); }

/*
 * VREF - Retrieve the value of a member of an object.
 * X - object
 * Y - member name (member must be identical in both versions of the structure!)
 */
#define VREF(X,Y) (ff8 ? ff8_ ## X->Y : ff7_ ## X->Y)

/*
 * VREFP - Create a pointer to a member.
 * X - object
 * Y - member name (member must be identical in both versions of the structure!)
 */
#define VREFP(X,Y) (ff8 ? &(ff8_ ## X->Y) : &(ff7_ ## X->Y))

/*
 * VRASS - Assign a value to a member.
 * X - object
 * Y - member name (member must be identical in both versions of the structure!)
 */
#define VRASS(X,Y,Z) { if(ff8) ff8_ ## X->Y = (Z); else ff7_ ## X->Y = (Z); }

/*
 * UNSAFE_VREF - Retrieve the value of a member of an object WITHOUT type safety.
 * T - object type
 * X - object
 * Y - member name (types can be different in the different versions)
 */
#define UNSAFE_VREF(T,X,Y) (ff8 ? (struct T *)ff8_ ## X->Y : (struct T *)ff7_ ## X->Y)

#define BGRA2RGBA(n) (((n >> 24) & 0xFF) << 24 | (n & 0xFF) << 16 | ((n >> 8) & 0xFF) << 8 | ((n >> 16) & 0xFF))

#define BGRA_R(x) (x >> 16 & 0xFF)
#define BGRA_G(x) (x >> 8 & 0xFF)
#define BGRA_B(x) (x & 0xFF)
#define BGRA_A(x) (x >> 24 & 0xFF)

#define BIT(x) (1 << x)
````

## File: src/matrix.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <string.h>
#include <math.h>

#include "math.h"
#include "log.h"

void add_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest)
{
	dest->x = a->x + b->x;
	dest->y = a->y + b->y;
	dest->z = a->z + b->z;
}

void subtract_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest)
{
	dest->x = a->x - b->x;
	dest->y = a->y - b->y;
	dest->z = a->z - b->z;
}

void multiply_vector(vector3<float> *vector, float scalar, vector3<float> *dest)
{
	dest->x = vector->x * scalar;
	dest->y = vector->y * scalar;
	dest->z = vector->z * scalar;
}

void divide_vector(vector3<float> *vector, float scalar, vector3<float> *dest)
{
	dest->x = vector->x / scalar;
	dest->y = vector->y / scalar;
	dest->z = vector->z / scalar;
}

float vector_length(vector3<float> *vector)
{
	return sqrtf(vector->x * vector->x + vector->y * vector->y + vector->z * vector->z);
}

void normalize_vector(vector3<float> *vector)
{
	float length = vector_length(vector);

	divide_vector(vector, length, vector);
}

float dot_product(vector3<float> *a, vector3<float> *b)
{
	return a->x * b->x + a->y * b->y + a->z * b->z;
}

void cross_product(vector3<float> *a, vector3<float> *b, vector3<float> *dest)
{
	dest->x = a->y * b->z - a->z * b->y;
	dest->y = a->z * b->x - a->x * b->z;
	dest->z = a->x * b->y - a->y * b->x;
}

void transform_point(struct matrix *matrix, vector3<float> *point, vector3<float> *dest)
{
	dest->x = matrix->_11 * point->x + matrix->_21 * point->y + matrix->_31 * point->z + matrix->_41;
	dest->y = matrix->_12 * point->x + matrix->_22 * point->y + matrix->_32 * point->z + matrix->_42;
	dest->z = matrix->_13 * point->x + matrix->_23 * point->y + matrix->_33 * point->z + matrix->_43;
}

void transform_point_w(struct matrix *matrix, vector3<float> *point, struct point4d *dest)
{
	dest->x = matrix->_11 * point->x + matrix->_21 * point->y + matrix->_31 * point->z + matrix->_41;
	dest->y = matrix->_12 * point->x + matrix->_22 * point->y + matrix->_32 * point->z + matrix->_42;
	dest->z = matrix->_13 * point->x + matrix->_23 * point->y + matrix->_33 * point->z + matrix->_43;
	dest->w = matrix->_14 * point->x + matrix->_24 * point->y + matrix->_34 * point->z + matrix->_44;
}

void transform_point4d(struct matrix *matrix, struct point4d *point, struct point4d *dest)
{
	dest->x = matrix->_11 * point->x + matrix->_21 * point->y + matrix->_31 * point->z + matrix->_41 * point->w;
	dest->y = matrix->_12 * point->x + matrix->_22 * point->y + matrix->_32 * point->z + matrix->_42 * point->w;
	dest->z = matrix->_13 * point->x + matrix->_23 * point->y + matrix->_33 * point->z + matrix->_43 * point->w;
	dest->w = matrix->_14 * point->x + matrix->_24 * point->y + matrix->_34 * point->z + matrix->_44 * point->w;
}

void transpose_matrix(struct matrix *matrix, struct matrix *dest)
{
	dest->_11 = matrix->_11;
	dest->_12 = matrix->_21;
	dest->_13 = matrix->_31;
	dest->_14 = matrix->_41;
	dest->_21 = matrix->_12;
	dest->_22 = matrix->_22;
	dest->_23 = matrix->_32;
	dest->_24 = matrix->_42;
	dest->_31 = matrix->_13;
	dest->_32 = matrix->_23;
	dest->_33 = matrix->_33;
	dest->_34 = matrix->_43;
	dest->_41 = matrix->_14;
	dest->_42 = matrix->_24;
	dest->_43 = matrix->_34;
	dest->_44 = matrix->_44;
}

void multiply_matrix(struct matrix *a, struct matrix *b, struct matrix *dest)
{

#define MMUL(I, J, N) a->m[I - 1][N - 1] * b->m[N - 1][J - 1]
#define MMUL1(I, J) dest->m[I - 1][J - 1] = MMUL(I, J, 1) + MMUL(I, J, 2) + MMUL(I, J, 3) + MMUL(I, J, 4)
#define MMULROW(I) MMUL1(I, 1); MMUL1(I, 2); MMUL1(I, 3); MMUL1(I, 4)

	MMULROW(1);
	MMULROW(2);
	MMULROW(3);
	MMULROW(4);
}

void multiply_matrix_unary(struct matrix *a, struct matrix *b)
{
	struct matrix tmp;

	memcpy(&tmp, a, sizeof(tmp));
	multiply_matrix(&tmp, b, a);
}

void identity_matrix(struct matrix *matrix)
{
	matrix->_11 = 1.0f;
	matrix->_12 = 0.0f;
	matrix->_13 = 0.0f;
	matrix->_14 = 0.0f;
	matrix->_21 = 0.0f;
	matrix->_22 = 1.0f;
	matrix->_23 = 0.0f;
	matrix->_24 = 0.0f;
	matrix->_31 = 0.0f;
	matrix->_32 = 0.0f;
	matrix->_33 = 1.0f;
	matrix->_34 = 0.0f;
	matrix->_41 = 0.0f;
	matrix->_42 = 0.0f;
	matrix->_43 = 0.0f;
	matrix->_44 = 1.0f;
}

void uniform_scaling_matrix(float scale, struct matrix *matrix)
{
	identity_matrix(matrix);

	matrix->_11 = scale;
	matrix->_22 = scale;
	matrix->_33 = scale;
}

void scaling_matrix(vector3<float> *scale, struct matrix *matrix)
{
	identity_matrix(matrix);

	matrix->_11 = scale->x;
	matrix->_22 = scale->y;
	matrix->_33 = scale->z;
}

void rotation_matrix_x(float angle, struct matrix *matrix)
{
	identity_matrix(matrix);

	matrix->_22 = cosf(angle);
	matrix->_23 = sinf(angle);
	matrix->_32 = -sinf(angle);
	matrix->_33 = cosf(angle);
}

void rotation_matrix_y(float angle, struct matrix *matrix)
{
	identity_matrix(matrix);

	matrix->_11 = cosf(angle);
	matrix->_13 = -sinf(angle);
	matrix->_31 = sinf(angle);
	matrix->_33 = cosf(angle);
}

void rotation_matrix_z(float angle, struct matrix *matrix)
{
	identity_matrix(matrix);

	matrix->_11 = cosf(angle);
	matrix->_12 = sinf(angle);
	matrix->_21 = -sinf(angle);
	matrix->_22 = cosf(angle);
}

void rotate_matrix_x(float angle, struct matrix *matrix)
{
	struct matrix tmp;

	rotation_matrix_x(angle, &tmp);
	multiply_matrix_unary(matrix, &tmp);
}

void rotate_matrix_y(float angle, struct matrix *matrix)
{
	struct matrix tmp;

	rotation_matrix_y(angle, &tmp);
	multiply_matrix_unary(matrix, &tmp);
}

void rotate_matrix_z(float angle, struct matrix *matrix)
{
	struct matrix tmp;

	rotation_matrix_z(angle, &tmp);
	multiply_matrix_unary(matrix, &tmp);
}

float determinant_3x3(struct matrix *m)
{
	return m->_11 * m->_22 * m->_33 + m->_12 * m->_23 * m->_31 + m->_13 * m->_21 * m->_32 -
		m->_11 * m->_23 * m->_32 - m->_12 * m->_21 * m->_33 - m->_13 * m->_22 * m->_31;
}

void inverse_matrix(struct matrix *matrix, struct matrix *dest)
{
	float det = determinant_3x3(matrix);

	if((det >= 0.99 && det <= 1.01) || (det <= -0.99 && det >= -1.01))
	{
		vector3<float> translation;

		transpose_matrix(matrix, dest);
		dest->_14 = matrix->_14;
		dest->_24 = matrix->_24;
		dest->_34 = matrix->_34;
		dest->_44 = matrix->_44;

		transform_point(dest, (vector3<float> *)&matrix->_41, &translation);

		dest->_41 = -translation.x;
		dest->_42 = -translation.y;
		dest->_43 = -translation.z;
	}
	else ffnx_glitch_once("Non-uniform scaling: %f\n", det);
}
````

## File: src/matrix.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#define DEG2RAD(X) ((X) * (M_PI/180.0f))

struct matrix
{
	union
	{
		struct
		{
			float _11;
			float _12;
			float _13;
			float _14;
			float _21;
			float _22;
			float _23;
			float _24;
			float _31;
			float _32;
			float _33;
			float _34;
			float _41;
			float _42;
			float _43;
			float _44;
		};

		float m[4][4];
	};
};

template <typename T>
struct vector2
{
	T x;
	T y;
};

template <typename T>
struct vector3
{
	T x;
	T y;
	T z;
};

template <typename T>
struct vector4
{
	T x;
	T y;
	T z;
	T w;
};

struct point4d
{
	float x;
	float y;
	float z;
	float w;
};

void add_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest);
void subtract_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest);
void multiply_vector(vector3<float> *vector, float scalar, vector3<float> *dest);
void divide_vector(vector3<float> *vector, float scalar, vector3<float> *dest);
float vector_length(vector3<float> *vector);
void normalize_vector(vector3<float> *vector);
float dot_product(vector3<float> *a, vector3<float> *b);
void cross_product(vector3<float> *a, vector3<float> *b, vector3<float> *dest);
void transform_point(struct matrix *matrix, vector3<float> *point, vector3<float> *dest);
void transform_point_w(struct matrix *matrix, vector3<float> *point, struct point4d *dest);
void transform_point4d(struct matrix *matrix, struct point4d *point, struct point4d *dest);
void transpose_matrix(struct matrix *matrix, struct matrix *dest);
void multiply_matrix(struct matrix *a, struct matrix *b, struct matrix *dest);
void multiply_matrix_unary(struct matrix *a, struct matrix *b);
void identity_matrix(struct matrix *matrix);
void uniform_scaling_matrix(float scale, struct matrix *matrix);
void scaling_matrix(vector3<float> *scale, struct matrix *matrix);
void rotation_matrix_x(float angle, struct matrix *matrix);
void rotation_matrix_y(float angle, struct matrix *matrix);
void rotation_matrix_z(float angle, struct matrix *matrix);
void rotate_matrix_x(float angle, struct matrix *matrix);
void rotate_matrix_y(float angle, struct matrix *matrix);
void rotate_matrix_z(float angle, struct matrix *matrix);
void inverse_matrix(struct matrix *matrix, struct matrix *dest);
````

## File: src/metadata.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <shlwapi.h>
#include <chrono>

#include "metadata.h"
#include "log.h"
#include "utils.h"

Metadata metadataPatcher;

// PRIVATE
void Metadata::loadXml()
{
    ffnx_trace("Metadata: loading metadata.xml\n");

    // Load Metadata
    doc.load_file(savePath);
}

void Metadata::saveXml()
{
    ffnx_trace("Metadata: saving metadata.xml\n");

    // Save Metadata
    doc.save_file(savePath);
}

void Metadata::calcNow()
{
    std::chrono::milliseconds nowMS = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()
    );

    now = std::to_string(nowMS.count());
}

// PUBLIC
void Metadata::init()
{
    ffnx_trace("Metadata: Initializing manager.\n");

    // Get Save Path
    get_userdata_path(userPath, sizeof(userPath), true);

    // Get Metadata Path
    strcpy(savePath, userPath);
    PathAppendA(savePath, "metadata.xml");

    // Save userID
    userID.assign(strrchr(userPath, '_') + 1);
}

void Metadata::updateFF7(uint8_t save)
{
    char currentSave[260]{ 0 };
    BYTE dataBuffer[64 * 1024 + 8]{0};
    int dataSize = userID.length();

    loadXml();

    // Append save file name
    strcpy(currentSave, userPath);
    sprintf(currentSave + strlen(currentSave), R"(\save%02i.ff7)", save);

    // Hash existing save files
    if (fileExists(currentSave))
    {
        ffnx_trace("Metadata: calculating hash for %s\n", currentSave);

        FILE* file = fopen(currentSave, "rb");

        fseek(file, 0, SEEK_END);
        int fileSize = ftell(file);
        fseek(file, 0, SEEK_SET);
        fread(dataBuffer, 1, fileSize, file);
        fclose(file);

        memcpy(dataBuffer + fileSize, userID.data(), userID.length());

        dataSize += fileSize;
    }
    else
    {
        memcpy(dataBuffer, userID.data(), userID.length());
    }
    std::string md5 = md5_hash(dataBuffer, dataSize);

    // Update metadata
    calcNow();
    for (pugi::xml_node gamestatus : doc.children())
    {
        for (pugi::xml_node savefiles : gamestatus.children())
        {
            if (std::atoi(savefiles.attribute("block").value()) == (save+1))
            {
                ffnx_trace("Metadata: updating timestamp and signature for %s\n", currentSave);

                for (pugi::xml_node child : savefiles.children())
                {
                    if (strcmp(child.name(), "timestamp") == 0)
                    {
                        child.text().set(now.data());
                    }

                    if (strcmp(child.name(), "signature") == 0)
                    {
                        child.text().set(md5.data());
                    }
                }
            }
        }
    }

    // Flush
    saveXml();
}

void Metadata::updateFF8(uint8_t slot, uint8_t save)
{
    char currentSave[260]{ 0 };
    BYTE dataBuffer[8 * 1024 + 8]{0};
    int dataSize = userID.length();

    loadXml();

    // Append save file name
    strcpy(currentSave, userPath);
    if (slot > 2) {
        strcpy(currentSave + strlen(currentSave), "\\chocorpg.ff8");
    } else {
        sprintf(currentSave + strlen(currentSave), R"(\slot%d_save%02i.ff8)", slot, save);
    }

    // Hash existing save files
    if (fileExists(currentSave))
    {
        ffnx_trace("Metadata: calculating hash for %s\n", currentSave);

        FILE* file = fopen(currentSave, "rb");

        fseek(file, 0, SEEK_END);
        int fileSize = ftell(file);
        fseek(file, 0, SEEK_SET);
        fread(dataBuffer, 1, fileSize, file);
        fclose(file);

        memcpy(dataBuffer + fileSize, userID.data(), userID.length());

        dataSize += fileSize;
    }
    else
    {
        memcpy(dataBuffer, userID.data(), userID.length());
    }
    std::string md5 = md5_hash(dataBuffer, dataSize);

    // Update metadata
    calcNow();
    for (pugi::xml_node gamestatus : doc.children())
    {
        for (pugi::xml_node savefile : gamestatus.children())
        {
            if ((
                strcmp(savefile.attribute("type").value(), "choco") == 0 && slot > 2) ||
                (std::atoi(savefile.attribute("num").value()) == save && std::atoi(savefile.attribute("slot").value()) == slot)
            )
            {
                ffnx_trace("Metadata: updating timestamp and signature for %s\n", currentSave);

                for (pugi::xml_node child : savefile.children())
                {
                    if (strcmp(child.name(), "timestamp") == 0)
                    {
                        child.text().set(now.data());
                    }

                    if (strcmp(child.name(), "signature") == 0)
                    {
                        child.text().set(md5.data());
                    }
                }
            }
        }
    }

    // Flush
    saveXml();
}
````

## File: src/metadata.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <io.h>

#include <pugiconfig.hpp>
#include <pugixml.hpp>

class Metadata
{
private:
	pugi::xml_document doc;

	std::string now;
	std::string userID;
	char userPath[260]{ 0 };
	char savePath[260]{ 0 };

	void calcNow();
	void loadXml();
	void saveXml();

public:
	void init();
	void updateFF7(uint8_t save);
	void updateFF8(uint8_t slot, uint8_t save);
};

extern Metadata metadataPatcher;
````

## File: src/movies.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "audio.h"
#include "movies.h"
#include "patch.h"
#include "ff7/widescreen.h"
#include "video/movies.h"
#include "redirect.h"
#include "achievement.h"

enum MovieAudioLayers {
	MUSIC = 0,
	VOICE
};

char movie_music_path[512];
char movie_voice_path[512];

uint8_t ff8_movie_cam_buffer[2*1024*1024]; // 2MB

uint32_t ff7_prepare_movie(char *name, uint32_t loop, struct dddevice **dddevice, uint32_t dd2interface)
{
	char drivename[4];
	char dirname[256];
	char filename[128];
	char fmvName[512];
	char newFmvName[512];

	if(trace_all || trace_movies) ffnx_trace("prepare_movie %s\n", name);

	ff7_externals.movie_object->loop = loop;
	ff7_externals.movie_sub_415231(name);

	ff7_externals.movie_object->field_1F8 = 1;
	ff7_externals.movie_object->is_playing = 0;
	ff7_externals.movie_object->movie_end = 0;
	ff7_externals.movie_object->global_movie_flag = 0;
	ff7_externals.movie_object->field_E0 = !((struct ff7_game_obj *)common_externals.get_game_object())->field_968;

	_splitpath(name, drivename, dirname, filename, NULL);
	_snprintf(fmvName, sizeof(fmvName), "%s%s%s.%s", drivename, dirname, filename, ffmpeg_video_ext.c_str());

	redirect_path_with_override(fmvName, newFmvName, sizeof(newFmvName));

	_splitpath(newFmvName, drivename, dirname, filename, NULL);
	// Remove extension
	_snprintf(movie_music_path, sizeof(movie_music_path), "%s%s%s", drivename, dirname, filename);
	_snprintf(movie_voice_path, sizeof(movie_voice_path), "%s%s%s_va", drivename, dirname, filename);

	bool has_ext_audio_file = nxAudioEngine.canPlayMovieAudio(movie_music_path);
	ffmpeg_prepare_movie(newFmvName, !has_ext_audio_file);
	if (!has_ext_audio_file) nxAudioEngine.setStreamMasterVolume(ffmpeg_video_volume / 100.0f);

	ff7_externals.movie_object->global_movie_flag = 1;

	// Required by > 15 FPS movies
	movie_fps_ratio = ffmpeg_get_fps_ratio();
	if (movie_fps_ratio > 1)
	{
		if (strcmp(filename, "opening") == 0)
		{
			*ff7_externals.opening_movie_music_start_frame = *ff7_externals.opening_movie_music_start_frame * movie_fps_ratio;
		}
	}
	// ---------------------------

	if(widescreen_enabled)
		widescreen.initMovieParamsFromConfig(filename);

	if(steam_edition || enable_steam_achievements)
		g_FF7SteamAchievements->initMovieStats(std::string(filename));

	return true;
}

uint32_t ff7_update_movie_sample(LPDIRECTDRAWSURFACE surface)
{
	uint32_t movie_end;

	ff7_externals.movie_object->movie_end = 0;

	if(!ff7_externals.movie_object->is_playing) return false;

retry:
	// Use native movie fps limiter if it's not been playback in fields ( no 3d models drawn on top )
	movie_end = !ffmpeg_update_movie_sample(!(*ff7_externals.field_limit_fps));

	if(movie_end)
	{
		if(trace_all || trace_movies) ffnx_trace("movie end\n");
		if(ff7_externals.movie_object->loop)
		{
			ffmpeg_loop();
			goto retry;
		}

		ff7_externals.movie_object->movie_end = 1;
		is_movie_bgfield = false;

		if(steam_edition || enable_steam_achievements)
			if(g_FF7SteamAchievements->isEndingMovie())
				g_FF7SteamAchievements->unlockGameProgressAchievement();

		return true;
	}

	return true;
}

uint32_t ff7_start_movie()
{
	if(trace_all || trace_movies) ffnx_trace("start_movie\n");

	if(ff7_externals.movie_object->is_playing) return true;

	ff7_externals.movie_object->is_playing = 1;

	if (!is_movie_bgfield) nxAudioEngine.pauseAmbient();
	nxAudioEngine.setMovieMasterVolume(ffmpeg_video_volume / 100.0f);
	nxAudioEngine.playMovieAudio(movie_music_path, MovieAudioLayers::MUSIC);
	nxAudioEngine.playMovieAudio(movie_voice_path, MovieAudioLayers::VOICE, 3.0f);

	return ff7_update_movie_sample(0);
}

uint32_t ff7_stop_movie()
{
	if(trace_all || trace_movies) ffnx_trace("stop_movie\n");

	if(ff7_externals.movie_object->is_playing)
	{
		ff7_externals.movie_object->is_playing = 0;
		ff7_externals.movie_object->movie_end = 0;

		ffmpeg_stop_movie();

		nxAudioEngine.stopMovieAudio(MovieAudioLayers::MUSIC);
		nxAudioEngine.stopMovieAudio(MovieAudioLayers::VOICE);
		if (!is_movie_bgfield) nxAudioEngine.resumeAmbient();
	}

	return true;
}

void ff7_release_movie_objects()
{
	if(trace_all || trace_movies) ffnx_trace("release_movie_objects\n");

	ff7_stop_movie();

	ffmpeg_release_movie_objects();

	ff7_externals.movie_object->global_movie_flag = 0;
}

void draw_current_frame()
{
	if (trace_all || trace_movies) ffnx_trace("draw_current_frame\n");

	ffmpeg_draw_current_frame();

	// FF8 on Steam sometimes forgets to release the movie objects, so we do ensure it's done anyway
	ffmpeg_release_movie_objects();
}

uint32_t ff7_get_movie_frame()
{
	if(!ff7_externals.movie_object->is_playing) return 0;

	return ffmpeg_get_movie_frame();
}

uint32_t ff8_movie_frames;

void ff8_prepare_movie(uint8_t disc, uint32_t movie)
{
	char fmvName[MAX_PATH], camName[MAX_PATH], newFmvName[MAX_PATH], newCamName[MAX_PATH];
	uint32_t camOffset = 0;

	_snprintf(fmvName, sizeof(fmvName), "data/movies/disc%02i_%02ih.%s", disc, movie, ffmpeg_video_ext.c_str());

	if (redirect_path_with_override(fmvName, newFmvName, sizeof(newFmvName)) != 0) {
		_snprintf(newFmvName, sizeof(newFmvName), "%s/%s", ff8_externals.app_path, fmvName);
	}

	if(disc != 4)
	{
		_snprintf(camName, sizeof(camName), "data/movies/disc%02i_%02i.cam", disc, movie);

		if (redirect_path_with_override(camName, newCamName, sizeof(newCamName)) != 0) {
			_snprintf(newCamName, sizeof(newCamName), "%s/%s", ff8_externals.app_path, camName);
		}

		FILE *camFile = fopen(newCamName, "rb");

		if(!camFile)
		{
			ffnx_error("could not load camera data from %s\n", newCamName);
			return;
		}

		fseek(camFile, 0, SEEK_END);
		long camFileSize = ftell(camFile);
		rewind(camFile);
		fread(&ff8_movie_cam_buffer, 1, camFileSize, camFile);
		fclose(camFile);

		ff8_externals.movie_object->movie_intro_pak = false;
	}
	else ff8_externals.movie_object->movie_intro_pak = true;

	ff8_externals.movie_object->camdata_start = (struct ff8_camdata *)(&ff8_movie_cam_buffer[8]);
	ff8_externals.movie_object->camdata_pointer = ff8_externals.movie_object->camdata_start;

	ff8_externals.movie_object->movie_current_frame = 0;

	if(trace_all || trace_movies) ffnx_trace("prepare_movie %s disc=%d movie=%d\n", newFmvName, disc, movie);

	if (steam_edition || enable_steam_achievements) {
		if (disc == 3 && movie == 4) // game ending movie
		{
			int squall_lvl = ff8_externals.get_char_level_4961D0(ff8_externals.savemap->chars[0].exp, 0);
			g_FF8SteamAchievements->unlockEndOfGameAchievement(squall_lvl);
		}
	}

	ff8_movie_frames = ffmpeg_prepare_movie(newFmvName);
}

void ff8_release_movie_objects()
{
	if(trace_all || trace_movies) ffnx_trace("release_movie_objects\n");

	ffmpeg_release_movie_objects();
}

int ff8_update_movie_sample()
{
	if(trace_all || trace_movies) ffnx_trace("update_movie_sample\n");

	ff8_externals.movie_object->movie_current_frame = ffmpeg_get_movie_frame();

	if(ff8_externals.movie_object->camdata_pointer->flag & 0x8) *ff8_externals.byte_1CE4907 = 0;
	if(ff8_externals.movie_object->camdata_pointer->flag & 0x10) *ff8_externals.byte_1CE4907 = 1;
	if(ff8_externals.movie_object->camdata_pointer->flag & 0x20)
	{
		*ff8_externals.byte_1CE4901 = 1;
		ff8_externals.movie_object->field_4C4B0 = 1;
	}
	else
	{
		*ff8_externals.byte_1CE4901 = 0;
		ff8_externals.movie_object->field_4C4B0 = 0;
	}

	if(ff8_externals.movie_object->camdata_pointer->flag & 0x1)
	{
		*ff8_externals.byte_1CE4901 = 1;
		ff8_externals.movie_object->field_4C4B0 = 1;
	}

	*ff8_externals.byte_1CE490D = ff8_externals.movie_object->camdata_pointer->flag & 0x40;

	int ret = 0;

	if (ff8_externals.movie_object->movie_current_frame <= ff8_externals.movie_object->movie_total_frames)
	{
		ffmpeg_update_movie_sample();
		ret = (int)ff8_externals.movie_object->camdata_start;
		ff8_externals.movie_object->camdata_pointer = &ff8_externals.movie_object->camdata_start[ff8_externals.movie_object->movie_current_frame];
	}
	else if(ff8_externals.movie_object->movie_intro_pak)
		ret = ff8_stop_movie();
	else
		ret = ff8_externals.sub_5304B0();

	return ret;
}

int ff8_start_movie()
{
	if(trace_all || trace_movies) ffnx_trace("start_movie\n");

	if(ff8_externals.movie_object->movie_intro_pak) ff8_externals.movie_object->movie_total_frames = ff8_movie_frames;
	else
	{
		ff8_externals.movie_object->movie_total_frames = ((WORD *)ff8_movie_cam_buffer)[3];
		ffnx_trace("%i frames\n", ff8_externals.movie_object->movie_total_frames);
	}

	ff8_externals.movie_object->field_4C4B0 = 0;

	*ff8_externals.enable_framelimiter = false;

	ff8_externals.movie_object->movie_is_playing = true;

	return ff8_update_movie_sample();
}

int ff8_stop_movie()
{
	if(trace_all || trace_movies) ffnx_trace("stop_movie\n");

	ffmpeg_stop_movie();

	ff8_externals.movie_object->movie_is_playing = false;

	ff8_externals.movie_object->field_4C4AC = 0;
	ff8_externals.movie_object->field_4C4B0 = 0;

	*ff8_externals.enable_framelimiter = true;

	int ret = (int)ff8_externals.movie_object->movie_file_handle;

	if (ff8_externals.movie_object->movie_file_handle)
	{
		ret = CloseHandle(ff8_externals.movie_object->movie_file_handle);
		ff8_externals.movie_object->movie_file_handle = 0;
	}

	return ret;
}

bool is_overlapping_movie_playing()
{
	return ff7_externals.movie_object->is_playing && !is_movie_bgfield;
}

void movie_init()
{
	if(!ff8)
	{
		nxAudioEngine.setMovieAudioMaxSlots(2);

		replace_function(common_externals.prepare_movie, ff7_prepare_movie);
		replace_function(common_externals.release_movie_objects, ff7_release_movie_objects);
		replace_function(common_externals.start_movie, ff7_start_movie);
		replace_function(common_externals.update_movie_sample, ff7_update_movie_sample);
		replace_function(common_externals.stop_movie, ff7_stop_movie);
		replace_function(common_externals.get_movie_frame, ff7_get_movie_frame);
	}
	else
	{
		replace_function(common_externals.prepare_movie, ff8_prepare_movie);
		replace_function(common_externals.release_movie_objects, ff8_release_movie_objects);
		replace_function(common_externals.start_movie, ff8_start_movie);
		replace_function(common_externals.update_movie_sample, ff8_update_movie_sample);
		replace_function(ff8_externals.draw_movie_frame, draw_current_frame);
		replace_function(common_externals.stop_movie, ff8_stop_movie);
	}

	ffmpeg_movie_init();
}
````

## File: src/movies.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

extern short movie_fps_ratio = 1;
extern bool is_movie_bgfield = false;

bool is_overlapping_movie_playing();
void movie_init();
void ff7_release_movie_objects();
void ff8_release_movie_objects();
int ff8_stop_movie();
````

## File: src/music.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <windows.h>
#include <unordered_map>

#include "audio.h"
#include "music.h"
#include "patch.h"

#include "ff8/engine.h"

bool was_battle_gameover = false;
bool next_music_channel = 0;
bool next_music_is_skipped = false;
bool next_music_is_skipped_with_saved_offset = false;
std::unordered_map<uint32_t, bool> remember_musics;
bool hold_volume_for_channel[2] = { false, false };
bool next_music_is_not_multi = false;
double next_music_fade_time = 0.0;
bool next_music_is_battle = false;
bool next_music_is_world = false;
uint16_t next_battle_scene_id = 0;
bool ff8_music_intro_volume_changed = false;
char* eyes_on_me_track = "eyes_on_me";
bool eyes_on_me_is_playing = false;
uint8_t ff7_last_akao_call_type = 0;
uint32_t ff7_last_music_id = 0;
uint32_t ff7_last_region_id = -1;
int16_t ff7_next_field_music_relative_id = -1;

void handle_mainmenu_playback()
{
	struct game_mode *mode = getmode_cached();
	static bool is_main_menu = false;

	switch (mode->driver_mode)
	{
	case MODE_MAIN_MENU:
		if (!is_main_menu)
		{
			is_main_menu = true;

			nxAudioEngine.playMusic("main_menu", 0xFF, 0);
		}
		break;
	default:
		if (is_main_menu)
		{
			nxAudioEngine.stopMusic();
			is_main_menu = false;
		}
		break;
	}
}

void music_flush()
{
	nxAudioEngine.flush();
}

bool is_gameover(uint32_t midi)
{
	bool ret = false;

	if (ff8)
	{
		switch (midi)
		{
		case 0: // Lose
			ret = true;
		}
	}
	else
	{
		switch (midi)
		{
		case 58: // OVER2
			ret = true;
		}
	}

	return ret;
}

uint32_t ff7_no_loop_ids[11] = {
	5, // FANFARE
	14, // TB
	22, // WALZ
	48, // CANNON
	57, // YADO
	89, // RO
	90, // JYRO
	92, // RIKU
	93, // SI
	94, // MOGU
	98, // ROLL
};

bool no_loop(uint32_t midi)
{
	if (ff8) {
		return false; // TODO
	}

	for (int i = 0; i < 11; ++i) {
		if (ff7_no_loop_ids[i] == midi) {
			return true;
		}
	}

	return false;
}

uint32_t ff7_midi_init(uint32_t unknown)
{
	// without this there will be no volume control for music in the config menu
	*ff7_externals.midi_volume_control = true;

	// enable fade function
	*ff7_externals.midi_initialized = true;

	return true;
}

char ff8_midi[32];

char* ff8_format_midi_name(const char* midi_name)
{
	// midi_name format: {num}{type}-{name}.sgt or {name}.sgt or _Missing.sgt
	const char* truncated_name = midi_name;

	if (!ff8_external_music_force_original_filenames) {
		truncated_name = strchr(midi_name, '-');

		if (nullptr != truncated_name) {
			truncated_name += 1; // Remove "-"
		}
		else {
			truncated_name = midi_name;
		}
	}

	// Remove extension
	const char* max_midi_name = strchr(truncated_name, '.');

	if (nullptr != max_midi_name) {
		size_t len = max_midi_name - truncated_name;

		if (len < 32) {
			memcpy(ff8_midi, truncated_name, len);
			ff8_midi[len] = '\0';

			return ff8_midi;
		}
	}

	return nullptr;
}

char* ff8_midi_name(uint32_t musicId)
{
	if (musicId != UINT_MAX)
	{
		const char* midi_name = common_externals.get_midi_name(musicId);
		return ff8_format_midi_name(midi_name);
	}

	return nullptr;
}

char* current_midi_name(int channel)
{
	const uint32_t musicId = nxAudioEngine.currentMusicId(channel);
	return ff8 ? ff8_midi_name(musicId) : common_externals.get_midi_name(musicId);
}

void pause_music()
{
	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));

	nxAudioEngine.pauseMusic();
}

void restart_music()
{
	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));

	nxAudioEngine.resumeMusic();
}

uint32_t ff7_use_midi(uint32_t midi)
{
	const char* name = common_externals.get_midi_name(midi);

	if (nxAudioEngine.canPlayMusic(name)) {
		return 1;
	}

	return strcmp(name, "HEART") != 0 && strcmp(name, "SATO") != 0 && strcmp(name, "SENSUI") != 0 && strcmp(name, "WIND") != 0;
}

bool play_music(const char* music_name, uint32_t music_id, int channel, NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions(), char* fullpath = nullptr)
{
	const struct game_mode* mode;
	bool playing = false;
	char new_music_name[50];

	if (nxAudioEngine.isMusicDisabled(music_name)) {
		ff7_next_field_music_relative_id = -1;

		return false;
	}

	if (ff8)
	{
		const char* current_party_leader = ff8_names[*(byte*)(ff8_externals.field_vars_stack_1CFE9B8 + 0xCB) == 62 ? 8 : 0].c_str();

		mode = getmode();

		// Attempt to override battle music
		if (next_music_is_battle)
		{
			if (next_battle_scene_id > 0)
			{
				sprintf(new_music_name, "%s_%s_%u", music_name, current_party_leader, next_battle_scene_id);

				// Attempt to load theme by party leader and battle id
				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);

				if (!playing)
				{
					sprintf(new_music_name, "%s_%u", music_name, next_battle_scene_id);

					// Attempt to load theme by battle id
					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
				}
			}

			next_music_is_battle = false;
		}
		// Attempt to override field music
		else if (mode->driver_mode == MODE_FIELD)
		{
			sprintf(new_music_name, "%s_field_%s_%s", music_name, current_party_leader, get_current_field_name());

			// Attempt to load theme by party leader and map name
			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);

			if (!playing)
			{
				sprintf(new_music_name, "%s_field_%s", music_name, get_current_field_name());

				// Attempt to load theme by map name
				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
			}
		}

		if (!playing)
		{
			sprintf(new_music_name, "%s_%s", music_name, current_party_leader);

			// Attempt to load current music name using the party leader in the name
			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
		}

		if (!playing) {
			if (fullpath == nullptr || nxAudioEngine.canPlayMusic(music_name))
			{
				playing = nxAudioEngine.playMusic(music_name, music_id, channel, options);
			}
			else if (fullpath != nullptr)
			{
				if (trace_all || trace_music) ffnx_info("%s: back to wav %s\n", __func__, fullpath);

				options.useNameAsFullPath = true;
				strcpy(options.format, "wav");
				playing = nxAudioEngine.playMusic(fullpath, music_id, channel, options);
			}
		}
	}
	else
	{
		const uint32_t main_theme_midi_id = 13; // The Main Theme is always resumed

		mode = getmode_cached();

		if (external_music_resume) {
			if (nxAudioEngine.currentMusicId(0) == main_theme_midi_id || channel == 1) {
				// Backup current state of the music
				nxAudioEngine.pauseMusic(0, options.fadetime == 0.0 ? (next_music_is_battle && !external_music_sync ? 0.2 : 1.0) : options.fadetime, true);
			}
			else if (channel == 0) {
				// Channel 1 is never resumed
				nxAudioEngine.stopMusic(1, options.fadetime == 0.0 ? 1.0 : options.fadetime);
			}
		}

		// Attempt to customize the battle theme flow
		if (next_music_is_battle)
		{
			uint16_t battle_id = next_battle_scene_id;

			if (mode->driver_mode == MODE_FIELD)
			{
				battle_id = ff7_externals.modules_global_object->battle_id;
			}

			if (battle_id > 0)
			{
				sprintf(new_music_name, "bat_%u_a%d", battle_id, ff7_externals.world_get_player_walkmap_region());

				// Attempt to load theme by Battle ID + WM region
				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);

				if (!playing)
				{
					sprintf(new_music_name, "bat_%u", battle_id);

					// Attempt to load theme by Battle ID
					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
				}

				if (!playing && *common_externals._previous_mode == FF7_MODE_FIELD)
				{
					sprintf(new_music_name, "bat_%s", get_current_field_name());

					// Attempt to load theme by Field name
					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
				}

				if (!playing)
				{
					sprintf(new_music_name, "bat_a%d", ff7_externals.world_get_player_walkmap_region());

					// Attempt to load theme by Battle WM region
					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
				}
			}
			else
			{
				if (trace_all || trace_music) ffnx_warning("%s: Unknown battle_id\n", __func__);
			}
		}
		else if (next_music_is_world)
		{
			ff7_last_region_id = ff7_externals.world_get_player_walkmap_region();

			sprintf(new_music_name, "%s_a%d", music_name, ff7_last_region_id);

			// Since world music comes with the same ID, we need to stop manually the channel to allow the new per region file to load again
			if (nxAudioEngine.canPlayMusic(new_music_name)) nxAudioEngine.stopMusic(channel);

			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
		}
		// Attempt to override field music
		else if (mode->driver_mode == MODE_FIELD)
		{
			if (ff7_next_field_music_relative_id >= 0)
			{
				sprintf(new_music_name, "field_%s_%d", get_current_field_name(), ff7_next_field_music_relative_id);

				// Attempt to load theme by map name + relative field music id
				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
			}

			if (!playing)
			{
				sprintf(new_music_name, "field_%s", get_current_field_name());

				// Attempt to load theme by map name
				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
				if (!playing)
				{
					sprintf(new_music_name, "field_%d", *ff7_externals.field_id);

					// Attempt to load theme by Field ID
					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
				}
			}
		}
		else if (mode->driver_mode == MODE_CONDOR)
		{
			sprintf(new_music_name, "condor_%s", music_name);

			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
		}
		else if (mode->driver_mode == MODE_SNOWBOARD)
		{
			sprintf(new_music_name, "snowboard_%s", music_name);

			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
		}
		else if (mode->driver_mode == MODE_HIGHWAY)
		{
			sprintf(new_music_name, "highway_%s", music_name);

			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
		}
		else if (mode->driver_mode == MODE_CHOCOBO)
		{
			sprintf(new_music_name, "chocobo_%s", music_name);

			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
		}
		else if (mode->driver_mode == MODE_CREDITS)
		{
			sprintf(new_music_name, "credits_%s", music_name);

			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
		}

		if (!playing)
		{
			// Nothing worked, switch back to default
			playing = nxAudioEngine.playMusic(music_name, music_id, channel, options);
		}

		ff7_next_field_music_relative_id = -1;
	}

	if (playing)
	{
		nxAudioEngine.setMusicLooping(!no_loop(music_id), channel);
	}

	return playing;
}

void ff7_play_midi(uint32_t music_id)
{
	const int channel = external_music_resume ? next_music_channel : 0;

	if (nxAudioEngine.currentMusicId(0) != music_id && nxAudioEngine.currentMusicId(1) != music_id)
	{
		if (is_gameover(music_id)) music_flush();

		const char* midi_name = common_externals.get_midi_name(music_id);
		struct game_mode* mode = getmode_cached();

		// Avoid restarting the same music when transitioning from the battle gameover to the gameover screen
		if (mode->driver_mode == MODE_GAMEOVER && was_battle_gameover)
		{
			was_battle_gameover = false;
			return;
		}

		if (mode->driver_mode == MODE_BATTLE && is_gameover(music_id)) was_battle_gameover = true;

		play_music(midi_name, music_id, channel);

		if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(channel), midi_name);
	}
}

void stop_music_for_channel(int channel)
{
	if (!ff8)
	{
		struct game_mode* mode = getmode_cached();

		// Do not stop the gameover music if coming from a battle
		if (mode->driver_mode == MODE_GAMEOVER && was_battle_gameover) return;
	}

	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s, channel=%d\n", __func__, nxAudioEngine.currentMusicId(channel), current_midi_name(channel), channel);

	nxAudioEngine.stopMusic(channel);

	if (ff8)
	{
		ff8_externals.current_music_ids[channel] = 0;
	}
}

void stop_music()
{
	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));

	stop_music_for_channel(0);
	stop_music_for_channel(1);
}

void ff7_cross_fade_midi(uint32_t music_id, uint32_t steps)
{
	const char* midi_name = common_externals.get_midi_name(music_id);
	const int channel = external_music_resume ? next_music_channel : 0;

	/* FIXME: the game uses cross_fade_midi only in two places,
	 * with steps = 4 everytime. In the PS version, theses transitions
	 * last 1-2 seconds fade in / out, no more.
	 * Therefore steps value is clearly wrong here, so the formula
	 * to get the correct time is different than the one in set_midi_volume_trans.
	 */
	double time = (steps & 0xFF) / 4.0;

	if (music_id != 0)
	{
		if (music_id == 1)
		{
			music_id = (nxAudioEngine.currentMusicId(channel) == 2) + 1;
		}
		else if (music_id == 2)
		{
			music_id = (nxAudioEngine.currentMusicId(channel) != 1) + 1;
		}

		if (nxAudioEngine.currentMusicId(channel) != music_id)
		{
			NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
			options.fadetime = time;
			options.targetVolume = 1.0f;
			play_music(midi_name, music_id, channel, options);
		}
		else
		{
			nxAudioEngine.setMusicVolume(1.0f, channel, time);
		}
	}
	else
	{
		stop_music();
	}

	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s, time=%fs\n", __func__, music_id, midi_name, time);
}

uint32_t music_status()
{
	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));

	if (ff8) {
		// When the game asks for a music status, you know that it ends eventually
		nxAudioEngine.setMusicLooping(false, 0);
		nxAudioEngine.setMusicLooping(false, 1);
	}

	return nxAudioEngine.isMusicPlaying(0) || nxAudioEngine.isMusicPlaying(1);
}

void set_master_midi_volume(uint32_t volume)
{
	if (trace_all || trace_music) ffnx_trace("%s: volume=%u\n", __func__, volume);

	nxAudioEngine.setMusicMasterVolume(volume / 100.0f);
}

void set_music_volume(uint32_t volume)
{
	const int channel = 0;

	if (volume > 127) volume = 127;

	if (trace_all || trace_music) ffnx_trace("%s: volume=%u, channel=%u\n", __func__, volume, channel);

	nxAudioEngine.setMusicVolume(volume / 127.0f, channel);
}

void set_volume_trans(int channel, double volume, double time)
{
	if (time != 0.0)
	{
		if (volume == 0.0)
		{
			nxAudioEngine.stopMusic(channel, time);
		}
		else
		{
			nxAudioEngine.setMusicVolume(volume, channel, time);
		}
	}
	else if (volume != 0.0)
	{
		nxAudioEngine.setMusicVolume(volume, channel);
	}
	else
	{
		stop_music_for_channel(channel);
	}
}

void ff7_volume_trans(uint32_t volume, uint32_t steps)
{
	const int channel = 0;

	if (volume > 127) volume = 127;

	double time = (steps & 0xFF) / 64.0;

	if (trace_all || trace_music) ffnx_trace("%s: volume=%u, steps=%u (=> time=%fs), channel=%u\n", __func__, volume, steps, time, channel);

	set_volume_trans(channel, volume / 127.0, time);
}

void set_midi_tempo(int8_t tempo)
{
	const int channel = 0;

	if (trace_all || trace_music) ffnx_trace("%s: tempo=%d, channel=%u\n", __func__, tempo, channel);

	if (tempo == -128) {
		tempo = -127; // Prevent speed to be 0 (can crash with SoLoud)
	}

	float speed = float(tempo) / 128.0f + 1.0f;

	// FIXME: will change the pitch
	nxAudioEngine.setMusicSpeed(speed, channel);
}

uint32_t ff7_music_sound_operation_fix(uint32_t type, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4, uint32_t param5)
{
	if (trace_all || trace_music) ffnx_trace("%s: AKAO call type=%X params=(%i %i %i %i)\n", __func__, type, param1, param2, param3, param4, param5);

	type &= 0xFF; // The game does not always set this parameter as a 32-bit integer

	if (type == 0xDA) { // Assimilated to stop music (Cid speech in Highwind)
		return ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(0xF0, 0, 0, 0, 0, 0);
	}

	// Play music (channel #2) and Play music with fade (channel #2)
	if (use_external_music && (type == 0x14 || type == 0x19)) {
		const uint32_t music_id = param1;
		if (music_id > 0 && music_id <= 0x62) {
			if (trace_all || trace_music) ffnx_trace("%s: set music channel to 1\n", __func__);
			next_music_channel = 1;
		}
	}

	uint32_t ret = ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(type, param1, param2, param3, param4, param5);
	next_music_channel = 0;
	return ret;
}

uint32_t ff7_battle_music(uint32_t type, uint32_t music_id, uint32_t fadetime, uint32_t param3, uint32_t param4, uint32_t param5)
{
	if (trace_all || trace_music) ffnx_trace("%s: music_id=%d\n", __func__, music_id);

	next_music_is_battle = true;

	uint32_t ret = ff7_music_sound_operation_fix(type, music_id, fadetime, param3, param4, param5);

	next_music_is_battle = false;

	return ret;
}

uint32_t ff7_battle_music_fanfare()
{
	if (trace_all || trace_music) ffnx_trace("%s: set music channel to 1\n", __func__);

	next_music_channel = 1;

	uint32_t ret = ff7_externals.play_battle_end_music();

	next_music_channel = 0;

	return ret;
}

uint32_t ff7_worldmap_music_change(uint32_t type, uint32_t music_id, uint32_t fadetime, uint32_t param3, uint32_t param4, uint32_t param5)
{
	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	if (music_id == 7) { // Battle
		ffnx_trace("%s: force music type to channel 1\n", __func__);

		next_music_is_battle = true;

		switch (type) {
		case 0x10:
			type = 0x14;
			break;
		case 0x18:
			type = 0x19;
			break;
		}
	}
	else
		next_music_is_world = true;

	// Backup music operation type for custom battle music call
	ff7_last_akao_call_type = type;
	ff7_last_music_id = music_id;

	return 0;
}

void ff7_worldmap_on_loop()
{
	(*ff7_externals.world_dword_DE68FC)();

	// If we change region while moving in the worldmap, trigger a new music change
	if (ff7_last_region_id != ff7_externals.world_get_player_walkmap_region()) next_music_is_world = true;

	if (next_music_is_battle || next_music_is_world)
	{
		ff7_music_sound_operation_fix(ff7_last_akao_call_type, ff7_last_music_id, 4, 0, 0, 0);

		next_music_is_battle = false;
		next_music_is_world = false;
	}
}

void ff7_worldmap_play_custom_battle_music(DWORD* unk1, DWORD* unk2, DWORD* battle_id)
{
	ff7_externals.sub_767039(unk1, unk2, battle_id);

	if (*unk1)
	{
		next_battle_scene_id = *battle_id;
		next_music_is_battle = true;

		// Now we know the battle scene ID, so we can try to customize battle music in Worldmap too
		stop_music();
		// Play music
		ff7_music_sound_operation_fix(ff7_last_akao_call_type, ff7_last_music_id, 4, 0, 0, 0);

		next_battle_scene_id = 0;
		next_music_is_battle = false;
	}
}

uint32_t ff7_field_music_id_to_midi_id(int16_t field_music_id)
{
	if (trace_all || trace_music) ffnx_trace("%s: field_music_id=%d\n", __func__, field_music_id);

	ff7_next_field_music_relative_id = field_music_id;

	return ff7_externals.field_music_id_to_midi_id(field_music_id);
}

uint32_t ff8_remember_playing_time()
{
	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	nxAudioEngine.pauseMusic(0, 0.0, true);
	// We never remember dualmusic, but battle and cardgame do not pause or stop channel 1 before playing the next music
	stop_music_for_channel(1);

	return 0;
}

uint32_t* ff8_load_music(uint32_t channel, uint32_t music_id, uint32_t data)
{
	if (trace_all || trace_music) ffnx_trace("%s: channel=%u, music_id=%u, data=%u\n", __func__, channel, music_id, data);

	// Do not apply volume changes for this channel between load_music and change_music/dual_music/replay_music instructions
	hold_volume_for_channel[channel] = true;

	return ((uint32_t * (*)(uint32_t, uint32_t, uint32_t))ff8_externals.music_load)(channel, music_id, data);
}

uint32_t ff8_play_midi(uint32_t music_id, int32_t volume, uint32_t unused1, uint32_t unused2)
{
	const int channel = next_music_channel;

	if (nxAudioEngine.currentMusicId(channel) != music_id)
	{
		if (is_gameover(music_id)) music_flush();

		const char* music_name = ff8_midi_name(music_id);

		if (nullptr == music_name) {
			ffnx_error("%s: Cannot get music name from music_id %d\n", __func__, music_id);
			return 0; // Error
		}

		if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, name=%s, channel=%d, volume=%d\n", __func__, music_id, music_name, channel, volume);

		SoLoud::time offset = 0;
		bool noIntro = false, backup_channel_1_after = false;

		if (next_music_is_skipped_with_saved_offset && remember_musics[music_id]) {
			remember_musics[music_id] = false;
			if (trace_all || trace_music) ffnx_trace("%s: use remembered music time\n", __func__);
			// Move music to channel 1
			nxAudioEngine.swapChannels();
			nxAudioEngine.pauseMusic(1, 1.0);
			backup_channel_1_after = true;
		}
		else if (next_music_is_skipped) {
			noIntro = true;
		}
		else if (remember_musics[music_id]) {
			if (trace_all || trace_music) ffnx_trace("%s: discard remembered music\n", __func__);
			remember_musics[music_id] = false;
		}

		NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
		options.fadetime = next_music_fade_time;
		options.noIntro = noIntro;
		if (volume >= 0 && volume <= 127) {
			options.targetVolume = volume / 127.0f;
		}
		play_music(music_name, music_id, channel, options);

		if (backup_channel_1_after) {
			// Backup channel 1 music state
			nxAudioEngine.pauseMusic(1, 1.0, true);
		}

		if (music_id == 93) { // The Extreme
			nxAudioEngine.pauseMusic(0);
		}
	}
	else if (trace_all || trace_music) {
		ffnx_trace("%s: is already playing music_id=%u, channel=%d, volume=%d\n", __func__, music_id, channel, volume);
	}

	return 1; // Success
}

uint32_t ff8_play_wav(uint32_t zero, char* filename, uint32_t volume)
{
	int channel = next_music_channel;
	uint32_t music_id = ff8_externals.current_music_ids[channel];
	bool the_extreme_intro = false;

	if (strstr(filename, "field2.fs") != nullptr) { // The Extreme Intro
		channel = 1;
		music_id = 111; // Arbitrary
		the_extreme_intro = true;
	}

	if (the_extreme_intro || nxAudioEngine.currentMusicId(channel) != music_id)
	{
		if (is_gameover(music_id)) music_flush();

		char* music_name = nullptr;

		if (the_extreme_intro) {
			music_name = "lasbossintro";
		}
		else {
			music_name = ff8_format_midi_name(filename);
		}

		if (nullptr == music_name) {
			ffnx_error("%s: Cannot get music name from filename %s\n", __func__, filename);
			return 0; // Error
		}

		if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, name=%s, channel=%d, volume=%u\n", __func__, music_id, music_name, channel, volume);

		NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
		options.fadetime = next_music_fade_time;
		if (volume >= 0 && volume < 127) {
			options.targetVolume = volume / 127.0f;
		}
		play_music(music_name, music_id, channel, options, filename);
	}
	else if (trace_all || trace_music) {
		ffnx_trace("%s: is already playing music_id=%u, filename=%s, channel=%d, volume=%d\n", __func__, music_id, filename, channel, volume);
	}

	return 1; // Success
}

uint32_t ff8_opcode_dualmusic_play_music(char* midi_data, uint32_t volume)
{
	uint32_t channel = 1;

	if (trace_all || trace_music) ffnx_trace("%s: channel=%u, volume=%u\n", __func__, channel, volume);

	next_music_channel = channel;
	channel = ff8_externals.sd_music_play(channel, midi_data, volume);
	next_music_channel = 0;
	return channel;
}

uint32_t ff8_cross_fade_midi(char* midi_data, uint32_t steps, uint32_t volume)
{
	uint32_t channel = 0;
	double time = steps / 50.0;

	if (trace_all || trace_music) ffnx_trace("%s: steps=%u (time=%fs), volume=%u\n", __func__, steps, time, volume);

	next_music_fade_time = time;
	channel = ff8_externals.sd_music_play(channel, midi_data, volume);
	next_music_fade_time = 0;
	return channel;
}

uint32_t ff8_play_music_to_channel_0(char* midi_data)
{
	uint32_t channel = 0;

	hold_volume_for_channel[channel] = false;

	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
	// Force known volume value
	return ff8_externals.sd_music_play(channel, midi_data, uint32_t(nxAudioEngine.getMusicVolume(channel) * 127));
}

uint32_t ff8_play_midi_at(char* midi_data, uint32_t offset)
{
	// We don't know what offset means in seconds
	if (trace_all || trace_music) ffnx_trace("%s: play midi at %d\n", __func__, offset);
	next_music_is_skipped = true;
	uint32_t channel = ff8_play_music_to_channel_0(midi_data);
	next_music_is_skipped = false;
	return channel;
}

uint32_t ff8_opcode_musicskip_play_midi_at(char* midi_data, uint32_t offset)
{
	uint32_t channel = 0;

	hold_volume_for_channel[channel] = false;

	if (trace_all || trace_music) ffnx_trace("%s: music skip, play midi at %d\n", __func__, offset);
	next_music_is_skipped_with_saved_offset = offset & 0xFF == 0xFF; // Special offset returned by ff8_opcode_getmusicoffset()
	channel = ff8_play_midi_at(midi_data, offset);
	next_music_is_skipped_with_saved_offset = false;
	return channel;
}

uint32_t ff8_opcode_getmusicoffset()
{
	const uint32_t channel = 0;
	const uint32_t musicId = nxAudioEngine.currentMusicId(channel);

	if (trace_all || trace_music) ffnx_trace("%s: save music %d\n", __func__, musicId);

	remember_musics[musicId] = true;

	return 0xFFFFFFFF; // Return a special offset to recognize it in ff8_opcode_musicskip_play_midi_at()
}

uint32_t ff8_field_pause_music(uint32_t a1)
{
	if (trace_all || trace_music) ffnx_trace("%s: a1=%d\n", __func__, a1);

	((uint32_t(*)(uint32_t))ff8_externals.pause_music_and_sfx)(0);

	return ff8_externals.check_game_is_paused(a1);
}

uint32_t ff8_field_restart_music(uint32_t a1)
{
	uint32_t ret = ff8_externals.check_game_is_paused(a1);

	if (ret == 0) { // Unpause
		if (trace_all || trace_music) ffnx_trace("%s: a1=%d\n", __func__, a1);

		((uint32_t(*)(uint32_t))ff8_externals.restart_music_and_sfx)(0);
	}

	return ret;
}

uint32_t set_music_volume_for_channel(int32_t channel, uint32_t volume)
{
	if (trace_all || trace_music) ffnx_trace("%s: channel=%d, volume=%d, hold=%d\n", __func__, channel, volume, hold_volume_for_channel[channel]);

	if (hold_volume_for_channel[channel] || channel < 0 || channel > 1) {
		return 1;
	}

	if (volume > 127) volume = 127;

	nxAudioEngine.setMusicVolume(volume / 127.0f, channel);

	return 1; // Success
}

uint32_t ff8_volume_trans(int32_t channel, uint32_t steps, uint32_t volume)
{
	double time = steps / 50.0;

	if (trace_all || trace_music) ffnx_trace("%s: channel=%d, volume=%u, steps=%u (=> time=%fs), hold=%d\n", __func__, channel, volume, steps, time, hold_volume_for_channel[channel]);

	if (hold_volume_for_channel[channel] || channel < 0 || channel > 1) {
		return 1;
	}

	if (volume > 127) volume = 127;

	nxAudioEngine.setMusicVolume(volume / 127.0f, channel, time);

	return 1;
}

uint32_t ff8_volume_fade(uint32_t channel, uint32_t steps, uint32_t volume1, uint32_t volume2)
{
	if (trace_all || trace_music) ffnx_trace("%s: channel=%d, volume1=%u, volume2=%u, steps=%u\n", __func__, channel, volume1, volume2, steps);

	set_music_volume_for_channel(channel, volume1);
	ff8_volume_trans(channel, steps, volume2);

	return 1;
}

uint32_t ff8_volume_sync(int a1)
{
	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	if (nxAudioEngine.isMusicVolumeFadeFinished()) {
		return 2; // Continue
	}

	return 1; // Wait
}

uint32_t ff8_play_music_worldmap(char* midi_data)
{
	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	nxAudioEngine.setMusicVolume(0.0f, 0, 0.5); // Fadeout: 500ms
	return ff8_cross_fade_midi(midi_data, 60, 127); // Fadein: ~1s
}

uint32_t ff8_load_cdrom()
{
	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	if (eyes_on_me_is_playing) {
		return 1;
	}

	char fullpath[MAX_PATH];

	snprintf(fullpath, MAX_PATH, "%s..\\%s.wav", ff8_externals.music_path, eyes_on_me_track);

	NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
	options.targetVolume = 1.0f;
	eyes_on_me_is_playing = play_music(eyes_on_me_track, 111, 0, options, fullpath);

	if (eyes_on_me_is_playing) {
		return 1;
	}

	// Fallback
	return ff8_externals.load_cdrom();
}

uint32_t ff8_play_cdrom(uint32_t trackStart, uint32_t trackEnd, uint32_t unknown)
{
	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	if (eyes_on_me_is_playing) {
		return 1;
	}

	return ff8_externals.play_cdrom(trackStart, trackEnd, unknown);
}

uint32_t ff8_stop_cdrom()
{
	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	if (eyes_on_me_is_playing) {
		nxAudioEngine.stopMusic(0);
		eyes_on_me_is_playing = false;
		return 1;
	}

	return ff8_externals.stop_cdrom();
}

std::vector<std::string> musics;

uint32_t ff8_opcode_choicemusic(uint32_t unused, uint32_t instruments)
{
	if (trace_all || trace_music) ffnx_trace("%s: Clear musics\n", __func__);

	musics.clear();

	return ((uint32_t(*)(uint32_t, uint32_t))ff8_externals.choice_music)(unused, instruments);
}

uint32_t ff8_load_midi_segment(void* directsound, const char* filename)
{
	const char* midi_name = ff8_format_midi_name(filename);

	hold_volume_for_channel[0] = false;

	if (next_music_is_not_multi) {
		next_music_is_not_multi = false;
		NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
		options.suppressOpeningSilence = true;
		play_music(midi_name, 43, 0, options);
		return 1; // Success
	}

	if (trace_all || trace_music) ffnx_trace("%s: load music %s (%s)\n", __func__, midi_name, filename);

	musics.push_back(midi_name);

	return 1; // Success
}

uint32_t ff8_play_midi_segments()
{
	const int channel = 0;

	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);

	nxAudioEngine.playSynchronizedMusics(musics, 43);
	nxAudioEngine.setMusicLooping(true, channel);

	return 0;
}

uint32_t ff8_load_and_play_one_midi_segment(uint32_t segment_id)
{
	// In this call we know that we play only one segment
	next_music_is_not_multi = true;
	((uint32_t(*)(uint32_t))ff8_externals.load_midi_segment_from_id)(segment_id);
	next_music_is_not_multi = false;

	return 0; // Fail (to prevent execution of the game's code)
}

uint32_t ff8_set_music_volume_intro_credits(uint32_t channel, uint32_t volume)
{
	if (ff8_music_intro_volume_changed) {
		if (nxAudioEngine.isMusicVolumeFadeFinished()) {
			*ff8_externals.credits_counter = 255; // Stop intro credits
			ff8_music_intro_volume_changed = false;
		}

		return 1;
	}

	if (trace_all || trace_music) ffnx_trace("%s %d %d\n", __func__, channel, volume);

	if (nxAudioEngine.isMusicPlaying(channel)) {
		nxAudioEngine.stopMusic(channel, 2.0);
		ff8_music_intro_volume_changed = true;
	}
	else {
		*ff8_externals.credits_counter = 255; // Stop intro credits
	}

	return 1;
}

void music_init()
{
	if (!ff8)
	{
		// Fix music stop issue in FF7
		patch_code_dword(ff7_externals.music_lock_clear_fix + 2, 0xCC195C);
		// Fix Cid speech music stop + music channel detection (field only)
		replace_call(ff7_externals.opcode_akao + 0xEA, ff7_music_sound_operation_fix);
		replace_call(ff7_externals.opcode_akao2 + 0xE8, ff7_music_sound_operation_fix);
		replace_call(ff7_externals.field_music_helper_sound_op_call, ff7_music_sound_operation_fix);
	}
	else
	{
		// Adding pause/resume music (and sfx) when pausing the game in field
		replace_call(ff8_externals.sub_4767B0 + (JP_VERSION ? 0x9BF : 0x9CC), ff8_field_pause_music);
		replace_call(ff8_externals.field_main_loop + 0x16C, ff8_field_restart_music);
	}

	if (use_external_music)
	{
		if (ff8)
		{
			/* Play & Stop */
			replace_call(ff8_externals.opcode_musicload + 0x8C, ff8_load_music);
			replace_function(common_externals.play_midi, ff8_play_midi);
			replace_function(common_externals.play_wav, ff8_play_wav);
			// Removing stop_midi call from sd_music_play
			replace_call(uint32_t(ff8_externals.sd_music_play) + 0x1B1, noop_a1);
			replace_function(ff8_externals.sdmusicplay, ff8_play_music_to_channel_0);
			replace_function(common_externals.pause_midi, pause_music);
			replace_function(common_externals.pause_wav, noop_a1);
			replace_function(common_externals.restart_midi, restart_music);
			replace_function(common_externals.restart_wav, noop_a1);
			replace_function(ff8_externals.stop_music, stop_music_for_channel);
			// Called by game credits
			replace_function(common_externals.stop_midi, stop_music);
			replace_function(common_externals.midi_status, music_status);
			// Music channel detection
			replace_call(ff8_externals.opcode_dualmusic + 0x58, ff8_opcode_dualmusic_play_music);
			/* Volume */
			replace_function(common_externals.cross_fade_midi, ff8_cross_fade_midi);
			replace_function(common_externals.set_midi_volume_trans, ff8_volume_trans);
			replace_function(common_externals.set_midi_volume_fade, ff8_volume_fade);
			replace_function(common_externals.set_midi_volume, set_music_volume_for_channel);
			// Not implemented by the game
			replace_function(ff8_externals.opcode_musicvolsync, ff8_volume_sync);
			// Called by game credits
			replace_function(uint32_t(ff8_externals.dmusicperf_set_volume_sub_46C6F0), set_music_volume);
			// Fix intro credits volume fadeout time
			replace_call(ff8_externals.load_credits_image + 0x5DF, ff8_set_music_volume_intro_credits);
			replace_call(ff8_externals.load_credits_image + 0x5C2, noop_a1);
			// Worldmap: Replace stop and play music by a cross fade on leaving cities
			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x2, noop_a2); // set volume to 0
			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x8, noop_a1); // stop music
			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x28, ff8_play_music_worldmap); // play music
			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x3B, noop_a3); // volume fade (channel=0, steps=60, volume=127)
			/* Remember time and resume music */
			replace_function(ff8_externals.sd_music_play_at, ff8_play_midi_at);
			replace_function(common_externals.remember_midi_playing_time, ff8_remember_playing_time);
			replace_call(ff8_externals.opcode_musicskip + 0x46, ff8_opcode_musicskip_play_midi_at);
			// getmusicoffset opcode is not implemented, but could be used to skip music with musicskip opcode
			replace_call(ff8_externals.opcode_getmusicoffset, ff8_opcode_getmusicoffset);
			/* Eyes On Me */
			replace_call(ff8_externals.load_cdrom_call, ff8_load_cdrom);
			replace_call(ff8_externals.play_cdrom_call, ff8_play_cdrom);
			replace_call(ff8_externals.stop_cdrom_field_call, ff8_stop_cdrom);
			replace_call(ff8_externals.stop_cdrom_cleanup_call, ff8_stop_cdrom);
			/* MIDI segments (Fisherman's Horizon concert instruments) */
			// Initialization
			replace_call(ff8_externals.opcode_choicemusic + 0x5D, ff8_opcode_choicemusic);
			replace_function(ff8_externals.load_midi_segment, ff8_load_midi_segment);
			replace_function(ff8_externals.play_midi_segments, ff8_play_midi_segments);
			// The next played song will stop the previous one
			replace_function(ff8_externals.stop_midi_segments, noop);
			// Detect solo play_midi
			replace_call(ff8_externals.load_and_play_midi_segment + 0x41, ff8_load_and_play_one_midi_segment);
			/* Nullify MIDI subs */
			replace_function(ff8_externals.volume_music_update, noop_a1);
			replace_function(ff8_externals.dmusic_segment_connect_to_dls, noop_a2);
			replace_function(common_externals.midi_cleanup, noop);
			replace_function(common_externals.wav_cleanup, noop);
		}
		else
		{
			replace_function(common_externals.midi_init, ff7_midi_init);
			replace_function(common_externals.use_midi, ff7_use_midi);
			replace_function(common_externals.play_midi, ff7_play_midi);
			replace_function(common_externals.cross_fade_midi, ff7_cross_fade_midi);
			replace_function(common_externals.pause_midi, pause_music);
			replace_function(common_externals.restart_midi, restart_music);
			replace_function(common_externals.stop_midi, stop_music);
			replace_function(common_externals.midi_status, music_status);
			replace_function(common_externals.set_master_midi_volume, set_master_midi_volume);
			replace_function(common_externals.set_midi_volume, set_music_volume);
			replace_function(common_externals.set_midi_volume_trans, ff7_volume_trans);
			replace_function(common_externals.set_midi_tempo, set_midi_tempo);
			replace_function(common_externals.midi_cleanup, noop);

			// Allow custom worldmap battle musics
			replace_call_function(ff7_externals.world_mode_loop_sub_74DB8C + 0x613, ff7_worldmap_play_custom_battle_music);
			// Force channel detection (1) for battle music
			replace_call(ff7_externals.play_battle_music_call, ff7_battle_music);
			replace_call(ff7_externals.play_battle_music_win_call, ff7_battle_music_fanfare);
			replace_call(ff7_externals.wm_play_music_call, ff7_worldmap_music_change);
			// Introduce a custom hook to run music AKAO code
			patch_code_byte(ff7_externals.world_loop_74BE49 + 0x121, 0x90);
			replace_call_function(ff7_externals.world_loop_74BE49 + 0x122, ff7_worldmap_on_loop);

			replace_call(ff7_externals.field_music_id_to_midi_id_call1, ff7_field_music_id_to_midi_id);
			replace_call(ff7_externals.field_music_id_to_midi_id_call2, ff7_field_music_id_to_midi_id);
			replace_call(ff7_externals.field_music_id_to_midi_id_call3, ff7_field_music_id_to_midi_id);

			if (ff7_external_opening_music) {
				// Disable opening music part 2 (ob)
				replace_call(ff7_externals.opening_movie_play_midi_call, noop_a1);
				// Reenable opening music part 1 (oa)
				patch_code_byte(ff7_externals.field_music_helper + 0xD1 + 2, 0x00);
			}
		}
	}
}
````

## File: src/music.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>

void handle_mainmenu_playback();
void ff7_play_midi(uint32_t music_id);
void music_init();
````

## File: src/overlay.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2020 Marcin Gomulak                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "api.h"
#include "field.h"
#include "overlay.h"
#include <bx/file.h>
#include "cfg.h"
#include "world.h"
#include "lighting_debug.h"

#define IMGUI_VIEW_ID 255

inline bool Overlay::IsVkDown(int vk)
{
    return (::GetKeyState(vk) & 0x8000) != 0;
}

// Updates the mouse position
void Overlay::UpdateMousePos()
{
    ImGuiIO& io = ImGui::GetIO();

    // Set OS mouse position if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
    if (io.WantSetMousePos)
    {
        POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
        ::ClientToScreen(gameHwnd, &pos);
        ::SetCursorPos(pos.x, pos.y);
    }

    // Set mouse position
    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    POINT pos;
    if (HWND active_window = ::GetForegroundWindow())
        if (active_window == gameHwnd || ::IsChild(active_window, gameHwnd))
            if (::GetCursorPos(&pos) && ::ScreenToClient(gameHwnd, &pos))
                io.MousePos = ImVec2((float)pos.x, (float)pos.y);
}

// Sets the cursor icon
bool Overlay::UpdateMouseCursor()
{
    ImGuiIO& io = ImGui::GetIO();
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return false;

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        ::SetCursor(NULL);
    }
    else
    {
        // Show OS mouse cursor
        LPTSTR win32_cursor = IDC_ARROW;
        switch (imgui_cursor)
        {
        case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
        case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
        case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
        case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
        case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
        case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
        case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
        case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
        case ImGuiMouseCursor_NotAllowed:   win32_cursor = IDC_NO; break;
        }
        ::SetCursor(::LoadCursor(NULL, win32_cursor));
    }
    return true;
}

void Overlay::Update()
{
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");

    // Block keys from reaching the game engine if the debug windows need input
    SetBlockKeysFromGame(io.WantCaptureKeyboard);

    // Setup display size (every frame to accommodate for window resizing)
    RECT rect;
    ::GetClientRect(gameHwnd, &rect);
    io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

    // Setup time step
    INT64 current_time;
    ::QueryPerformanceCounter((LARGE_INTEGER*)&current_time);
    io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;
    g_Time = current_time;

    // Read keyboard modifiers inputs
    io.KeyCtrl = (::GetKeyState(VK_CONTROL) & 0x8000) != 0;
    io.KeyShift = (::GetKeyState(VK_SHIFT) & 0x8000) != 0;
    io.KeyAlt = (::GetKeyState(VK_MENU) & 0x8000) != 0;
    io.KeySuper = false;

    // Update OS mouse position
    UpdateMousePos();

    // Update OS mouse cursor with the cursor requested by imgui
    ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
    if (g_LastMouseCursor != mouse_cursor)
    {
        g_LastMouseCursor = mouse_cursor;
        UpdateMouseCursor();
    }
}

void Overlay::Render(ImDrawData* drawData)
{
    const ImGuiIO& io = ImGui::GetIO();
    const float width = io.DisplaySize.x;
    const float height = io.DisplaySize.y;

    bgfx::setViewName(IMGUI_VIEW_ID, "ImGui");
    bgfx::setViewMode(IMGUI_VIEW_ID, bgfx::ViewMode::Sequential);

    const bgfx::Caps* caps = bgfx::getCaps();
    {
        float ortho[16];
        bx::mtxOrtho(ortho, 0.0f, width, height, 0.0f, 0.0f, 1000.0f, 0.0f, caps->homogeneousDepth);
        bgfx::setViewTransform(IMGUI_VIEW_ID, NULL, ortho);
        bgfx::setViewRect(IMGUI_VIEW_ID, 0, 0, uint16_t(width), uint16_t(height));
    }

    for (int32_t ii = 0, num = drawData->CmdListsCount; ii < num; ++ii)
    {
        const ImDrawList* drawList = drawData->CmdLists[ii];
        uint32_t numVertices = (uint32_t)drawList->VtxBuffer.size();
        uint32_t numIndices = (uint32_t)drawList->IdxBuffer.size();

        bgfx::TransientVertexBuffer vb;
        if (bgfx::getAvailTransientVertexBuffer(drawList->VtxBuffer.Size, imguiVertexLayout)) {
            bgfx::allocTransientVertexBuffer(&vb, drawList->VtxBuffer.Size, imguiVertexLayout);
            memcpy(vb.data, drawList->VtxBuffer.Data, drawList->VtxBuffer.Size * sizeof(ImDrawVert));
        }

        bgfx::TransientIndexBuffer ib;
        if (bgfx::getAvailTransientIndexBuffer(drawList->IdxBuffer.Size)) {
            bgfx::allocTransientIndexBuffer(&ib, drawList->IdxBuffer.Size);
            memcpy(ib.data, drawList->IdxBuffer.Data, drawList->IdxBuffer.Size * sizeof(ImDrawIdx));
        }

        uint32_t offset = 0;
        for (ImDrawCmd cmd : drawList->CmdBuffer)
        {
            if (cmd.UserCallback)
            {
                cmd.UserCallback(drawList, &cmd);
            }
            else if (0 != cmd.ElemCount)
            {
                uint64_t state = 0
                    | BGFX_STATE_WRITE_RGB
                    | BGFX_STATE_WRITE_A
                    | BGFX_STATE_MSAA
                    ;

                bgfx::TextureHandle th = m_texture;
                bgfx::ProgramHandle program = m_program;

                if (NULL != cmd.TextureId)
                {
                    union { ImTextureID ptr; struct { bgfx::TextureHandle handle; uint8_t flags; uint8_t mip; } s; } texture = { cmd.TextureId };
                    state |= 0 != (texture.s.flags)
                        ? BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA)
                        : BGFX_STATE_NONE
                        ;
                    th = texture.s.handle;
                }
                else
                {
                    state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA);
                }

                const uint16_t xx = uint16_t(bx::max(cmd.ClipRect.x, 0.0f));
                const uint16_t yy = uint16_t(bx::max(cmd.ClipRect.y, 0.0f));
                bgfx::setScissor(xx, yy
                    , uint16_t(bx::min(cmd.ClipRect.z, 65535.0f) - xx)
                    , uint16_t(bx::min(cmd.ClipRect.w, 65535.0f) - yy)
                );

                bgfx::setState(state);
                bgfx::setTexture(0, s_tex, th);
                bgfx::setVertexBuffer(0, &vb, 0, numVertices);
                bgfx::setIndexBuffer(&ib, offset, cmd.ElemCount);
                bgfx::submit(IMGUI_VIEW_ID, m_program);
            }

            offset += cmd.ElemCount;
        }
    }
}

bool Overlay::init(bgfx::ProgramHandle program, int width, int height)
{
    mem_edit.Open = false;

    if (!IMGUI_CHECKVERSION())
        return false;
    if (!::QueryPerformanceFrequency((LARGE_INTEGER*)&g_TicksPerSecond))
        return false;
    if (!::QueryPerformanceCounter((LARGE_INTEGER*)&g_Time))
        return false;

    ImGui::CreateContext();
    ImGui::StyleColorsDark();
    ImGui::SetNextWindowBgAlpha(0.3f);

    // Setup back-end capabilities flags
    ImGuiIO& io = ImGui::GetIO();
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
    io.BackendPlatformName = "imgui_impl_win32";
    ImGui::GetMainViewport()->PlatformHandleRaw = gameHwnd;

    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.
    io.AddKeyEvent(ImGuiKey_Tab, IsVkDown(VK_TAB));
    io.AddKeyEvent(ImGuiKey_LeftArrow, IsVkDown(VK_LEFT));
    io.AddKeyEvent(ImGuiKey_RightArrow, IsVkDown(VK_RIGHT));
    io.AddKeyEvent(ImGuiKey_UpArrow, IsVkDown(VK_UP));
    io.AddKeyEvent(ImGuiKey_DownArrow, IsVkDown(VK_DOWN));
    io.AddKeyEvent(ImGuiKey_PageUp, IsVkDown(VK_PRIOR));
    io.AddKeyEvent(ImGuiKey_PageDown, IsVkDown(VK_NEXT));
    io.AddKeyEvent(ImGuiKey_Home, IsVkDown(VK_HOME));
    io.AddKeyEvent(ImGuiKey_End, IsVkDown(VK_END));
    io.AddKeyEvent(ImGuiKey_Insert, IsVkDown(VK_INSERT));
    io.AddKeyEvent(ImGuiKey_Delete, IsVkDown(VK_DELETE));
    io.AddKeyEvent(ImGuiKey_Backspace, IsVkDown(VK_BACK));
    io.AddKeyEvent(ImGuiKey_Space, IsVkDown(VK_SPACE));
    io.AddKeyEvent(ImGuiKey_Enter, IsVkDown(VK_RETURN));
    io.AddKeyEvent(ImGuiKey_Escape, IsVkDown(VK_ESCAPE));
    io.AddKeyEvent(ImGuiKey_KeypadEnter, IsVkDown(VK_RETURN));
    io.AddKeyEvent(ImGuiKey_A, IsVkDown('A'));
    io.AddKeyEvent(ImGuiKey_C, IsVkDown('C'));
    io.AddKeyEvent(ImGuiKey_V, IsVkDown('V'));
    io.AddKeyEvent(ImGuiKey_X, IsVkDown('X'));
    io.AddKeyEvent(ImGuiKey_Y, IsVkDown('Y'));
    io.AddKeyEvent(ImGuiKey_Z, IsVkDown('Z'));

    io.DisplaySize = ImVec2(width, height);
    io.DeltaTime = 1.0f / 60.0f;
    io.IniFilename = NULL;

    bgfx::RendererType::Enum type = bgfx::getRendererType();
    m_program = program;

    s_tex = bgfx::createUniform("s_tex", bgfx::UniformType::Sampler);

    // Load fonts
    // Build texture atlas
    unsigned char* pixels;
    int twidth, theight;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &twidth, &theight);

    const bgfx::Memory* mem = bgfx::makeRef(pixels, twidth * theight * 4);
    m_texture = bgfx::createTexture2D(
        twidth
        , theight
        , false
        , 1
        , bgfx::TextureFormat::BGRA8
        , 0
        , mem
    );

    imguiVertexLayout
        .begin()
        .add(bgfx::Attrib::Position, 2, bgfx::AttribType::Float)
        .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float)
        .add(bgfx::Attrib::Color0, 4, bgfx::AttribType::Uint8, true)
        .end();

    nxRegisterMouseListener(this);
    nxRegisterKeyListener(this);

    return true;
}

void Overlay::drawMainWindow() {
    if (!ImGui::Begin("DevTools", &visible, ImGuiWindowFlags_::ImGuiWindowFlags_MenuBar))
    {
        ImGui::End();
        return;
    }

    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("Tools"))
        {
            ImGui::MenuItem("Memory Debug", NULL, &mem_edit.Open);
            ImGui::MenuItem("Field Debug", NULL, &field_debug_open);
            if (!ff8) ImGui::MenuItem("Lighting Debug", NULL, &lighting_debug_open);
            if (ff8) ImGui::MenuItem("World Debug", NULL, &world_debug_open);
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }
    ImGui::Text("Select a dev tool from the menu.");
    ImGui::End();
}

void Overlay::draw()
{
    Update();
    ImGui::NewFrame();

    // This is a placeholder UI
    if (visible)
    {
        drawMainWindow();
        if (mem_edit.Open)
        {
            if (!ff8) mem_edit.DrawWindow("Memory Editor", (void*)0x401000, 0xF52000 - 0x401000, 0x401000);
            else mem_edit.DrawWindow("Memory Editor", (void*)0x401000, 0x27A0000 - 0x401000, 0x401000);
        }
        if (field_debug_open) field_debug(&field_debug_open);
        if (!ff8 && lighting_debug_open) lighting_debug(&lighting_debug_open);
        if (ff8 && world_debug_open) world_debug(&world_debug_open);
    }

    ImGui::Render();
    Render(ImGui::GetDrawData());
}

void Overlay::destroy()
{
    bgfx::destroy(s_tex);
    bgfx::destroy(m_texture);

    ImGui::DestroyContext();
}

void Overlay::MouseDown(MouseEventArgs e)
{
    if (!ImGui::IsAnyMouseDown() && ::GetCapture() == NULL)
        ::SetCapture(gameHwnd);
    ImGui::GetIO().MouseDown[e.button - 1] = true;
}

void Overlay::MouseUp(MouseEventArgs e)
{
    ImGui::GetIO().MouseDown[e.button - 1] = false;
    if (!ImGui::IsAnyMouseDown() && ::GetCapture() == gameHwnd)
        ::ReleaseCapture();
}

void Overlay::MouseWheel(MouseEventArgs e)
{
    ImGui::GetIO().MouseWheel += e.delta;
}

void Overlay::MouseMove(MouseEventArgs e)
{
    UpdateMouseCursor();
}

void Overlay::KeyUp(KeyEventArgs e)
{
    if (e.keyValue == devtools_hotkey)
        visible = !visible;
}

void Overlay::KeyDown(KeyEventArgs e)
{
    // Silence is golden
}

void Overlay::KeyPress(KeyPressEventArgs e)
{
    if (e.keyChar > 0 && e.keyChar < 0x10000)
        ImGui::GetIO().AddInputCharacterUTF16((unsigned short)e.keyChar);
}
````

## File: src/overlay.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2020 Marcin Gomulak                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <bgfx/bgfx.h>
#include <imgui.h>
#include "imgui_club/imgui_memory_editor.h"
#include "input.h"

class Overlay : public MouseListener, public KeyListener {
private:
	INT64 g_Time = 0;
	INT64  g_TicksPerSecond = 0;
	ImGuiMouseCursor g_LastMouseCursor = ImGuiMouseCursor_COUNT;
	bgfx::VertexLayout imguiVertexLayout;
	bgfx::UniformHandle s_tex;
	bgfx::TextureHandle m_texture;
	bgfx::ProgramHandle m_program;
	bool visible = true;
	bool field_debug_open = false;
	bool lighting_debug_open = false;
	bool world_debug_open = false;

	MemoryEditor mem_edit;

	void UpdateMousePos();
	bool UpdateMouseCursor();
	void Update();
	void Render(ImDrawData* drawData);
	inline bool IsVkDown(int vk);
public:
	bool init(bgfx::ProgramHandle program, int width, int height);
	void drawMainWindow();
	void draw();
	void destroy();
	void MouseDown(MouseEventArgs e);
	void MouseUp(MouseEventArgs e);
	void MouseWheel(MouseEventArgs e);
	void MouseMove(MouseEventArgs e);
	void KeyUp(KeyEventArgs e);
	void KeyDown(KeyEventArgs e);
	void KeyPress(KeyPressEventArgs e);
};
````

## File: src/patch.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/
#include "patch.h"

#include <windows.h>
#include <stdint.h>

#include "crashdump.h"

#ifdef PATCH_COLLECT_DUPLICATES
#	include <unordered_set>
std::unordered_set<uint32_t> offsets;
std::unordered_set<uint32_t> addresses;
uint32_t min_addr = 0;
uint32_t max_addr = 0;
#endif

uint32_t replace_counter = 0;
uint32_t replaced_functions[512 * 3];

uint8_t check_is_call(const char *name, uint32_t base, uint32_t offset, uint16_t instruction)
{
	if ((instruction & 0xFF) != 0xE8 && (instruction & 0xFF) != 0xE9 && instruction != 0x15FF)
	{
		// Warning to diagnose errors faster
		ffnx_warning("%s: Unrecognized call/jmp instruction at 0x%X + 0x%X (0x%X): 0x%X\n", name, base, offset, base + offset, instruction);
	}

	return instruction == 0x15FF ? 2 : 1;
}

#ifdef PATCH_COLLECT_DUPLICATES
void check_boundaries(const char *name, uint32_t base, uint32_t offset, uint32_t address)
{
	if (min_addr == 0)
	{
		// Get EXE boundaries
		FFNxStackWalker sw(true);
		if (sw.LoadModules()) {
			min_addr = sw.getBaseAddress();
			max_addr = min_addr + sw.getSize();
		}
	}

	if (min_addr != 0 && (base + offset < min_addr || base + offset > max_addr))
	{
		ffnx_warning("%s: Out of bounds offset at 0x%X + 0x%X (0x%X) (min: 0x%X, max: 0x%X)\n", name, base, offset, base + offset, min_addr, max_addr);
	}

	if (min_addr != 0 && (address < min_addr || address > max_addr))
	{
		ffnx_warning("%s: Out of bounds address at 0x%X + 0x%X (0x%X): 0x%X (min: 0x%X, max: 0x%X)\n", name, base, offset, base + offset, address, min_addr, max_addr);
	}
}

void collect_addresses(const char *name, uint32_t base, uint32_t offset, uint32_t address)
{
	check_boundaries(name, base, offset, address);

	if (offsets.contains(base + offset))
	{
		ffnx_warning("%s: Offset used before 0x%X + 0x%X (0x%X)\n", name, base, offset, base + offset);
	}

	if (addresses.contains(address))
	{
		ffnx_warning("%s: Address used before 0x%X + 0x%X (0x%X): 0x%X\n", name, base, offset, base + offset, address);
	}

	offsets.insert(base + offset);
	addresses.insert(address);
}
#endif

uint32_t replace_function(uint32_t offset, void *func)
{
	DWORD dummy;

	VirtualProtect((void *)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);

	replaced_functions[replace_counter++] = *(unsigned char *)offset;
	replaced_functions[replace_counter++] = *(uint32_t *)(offset + 1);
	replaced_functions[replace_counter++] = offset;

	*(unsigned char *)offset = 0xE9;
	*(uint32_t *)(offset + 1) = ((uint32_t)func - offset) - 5;

	return replace_counter - 3;
}

void unreplace_function(uint32_t func)
{
	uint32_t offset = replaced_functions[func + 2],
		value = replaced_functions[func + 1],
		instr = replaced_functions[func];
	DWORD dummy;

	VirtualProtect((void *)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);

	// Remember previous state to rereplace later
	replaced_functions[func + 1] = *(uint32_t *)(offset + 1);
	replaced_functions[func] = *(unsigned char *)offset;

	*(uint32_t *)(offset + 1) = value;
	*(unsigned char *)offset = instr;
}

void rereplace_function(uint32_t func)
{
	// In fact this is the same operation than unreplace_function
	unreplace_function(func);
}

void unreplace_functions()
{
	while(replace_counter > 0)
	{
		uint32_t offset = replaced_functions[--replace_counter];
		DWORD dummy;

		VirtualProtect((void *)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);
		*(uint32_t *)(offset + 1) = replaced_functions[--replace_counter];
		*(unsigned char *)offset = replaced_functions[--replace_counter];
	}
}

void replace_call(uint32_t offset, void *func)
{
	DWORD dummy;

	uint8_t size = check_is_call(__func__, offset, 0, *((uint16_t *)(offset)));

	VirtualProtect((void *)offset, size + 4, PAGE_EXECUTE_READWRITE, &dummy);

	*(uint32_t *)(offset + size) = ((uint32_t)func - offset) - (size + 4);
}

uint32_t replace_call_function(uint32_t offset, void* func)
{
	DWORD dummy;

	VirtualProtect((void*)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);

	replaced_functions[replace_counter++] = *(unsigned char*)offset;
	replaced_functions[replace_counter++] = *(uint32_t*)(offset + 1);
	replaced_functions[replace_counter++] = offset;

	*(unsigned char*)offset = 0xE8;
	*(uint32_t*)(offset + 1) = ((uint32_t)func - offset) - 5;

	return replace_counter - 3;
}

uint32_t get_relative_call(uint32_t base, uint32_t offset)
{
	uint16_t instruction = *((uint16_t *)(base + offset));

	uint8_t size = check_is_call(__func__, base, offset, instruction);

	uint32_t ret = base + *((uint32_t *)(base + offset + size)) + offset + 4 + size;

#ifdef PATCH_COLLECT_DUPLICATES
	collect_addresses(__func__, base, offset, ret);
#endif

	return ret;
}

uint32_t get_absolute_value(uint32_t base, uint32_t offset)
{
#ifdef PATCH_COLLECT_DUPLICATES
	collect_addresses(__func__, base, offset, *((uint32_t *)(base + offset)));
#endif

	return *((uint32_t *)(base + offset));
}

void patch_code_byte(uint32_t offset, unsigned char r)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(unsigned char *)offset = r;
}

void patch_code_char(uint32_t offset, char r)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(char *)offset = r;
}

void patch_code_word(uint32_t offset, WORD r)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(WORD *)offset = r;
}

void patch_code_short(uint32_t offset, short r)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(short *)offset = r;
}

void patch_code_dword(uint32_t offset, DWORD r)
{
	DWORD dummy;

	VirtualProtect((void*)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(DWORD*)offset = r;
}

void patch_code_int(uint32_t offset, int r)
{
	DWORD dummy;

	VirtualProtect((void*)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(int*)offset = r;
}

void patch_code_uint(uint32_t offset, uint32_t r)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(uint32_t *)offset = r;
}

void patch_code_float(uint32_t offset, float r)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(float *)offset = r;
}

void patch_code_double(uint32_t offset, double r)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);

	*(double *)offset = r;
}

void memcpy_code(uint32_t offset, void *data, uint32_t size)
{
	DWORD dummy;

	VirtualProtect((void *)offset, size, PAGE_EXECUTE_READWRITE, &dummy);

	memcpy((void *)offset, data, size);
}

void memset_code(uint32_t offset, uint32_t val, uint32_t size)
{
	DWORD dummy;

	VirtualProtect((void *)offset, size, PAGE_EXECUTE_READWRITE, &dummy);

	memset((void *)offset, val, size);
}

// From https://stackoverflow.com/a/21636483
void* member_func_to_ptr(char i, ...)
{
    va_list v;
    va_start(v,i);
    void* ret = va_arg(v, void*);
    va_end(v);
    return ret;
}
````

## File: src/patch.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>
#include <windows.h>

uint32_t replace_function(uint32_t offset, void *func);
// Can also unreplace a call_function
void unreplace_function(uint32_t func);
// Replace again a function unreplaced before
void rereplace_function(uint32_t func);
void unreplace_functions();

void replace_call(uint32_t offset, void *func);
uint32_t replace_call_function(uint32_t offset, void* func);

uint32_t get_relative_call(uint32_t base, uint32_t offset);
uint32_t get_absolute_value(uint32_t base, uint32_t offset);
void patch_code_char(uint32_t offset, char r);
void patch_code_byte(uint32_t offset, unsigned char r);
void patch_code_word(uint32_t offset, WORD r);
void patch_code_short(uint32_t offset, short r);
void patch_code_dword(uint32_t offset, DWORD r);
void patch_code_int(uint32_t offset, int r);
void patch_code_uint(uint32_t offset, uint32_t r);
void patch_code_float(uint32_t offset, float r);
void patch_code_double(uint32_t offset, double r);

template<typename T>
void patch_multiply_code(uint32_t offset, int multiplier)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(T), PAGE_EXECUTE_READWRITE, &dummy);

	*(T *)offset = (*(T *)offset) * (T)multiplier;

    // TODO Add assertion
}

template<typename T>
void patch_divide_code(uint32_t offset, int multiplier)
{
	DWORD dummy;

	VirtualProtect((void *)offset, sizeof(T), PAGE_EXECUTE_READWRITE, &dummy);

	*(T *)offset = (*(T *)offset) / (T)multiplier;

    // TODO Add assertion
}

void memcpy_code(uint32_t offset, void *data, uint32_t size);
void memset_code(uint32_t offset, uint32_t val, uint32_t size);

void* member_func_to_ptr(char i, ...);
````

## File: src/redirect.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <shlwapi.h>
#include <filesystem>
#include <io.h>
#include "log.h"
#include "utils.h"

#include "redirect.h"

int attempt_redirection(const char* in, char* out, size_t size, bool wantsSteamPath)
{
	std::string newIn(in);

	if (!ff8)
	{
		std::transform(newIn.begin(), newIn.end(), newIn.begin(), ::tolower);
	}

	bool isSavegame = !ff8 && strstr(newIn.data(), ".ff7") != NULL;
	bool isCacheFile = !ff8 && strstr(newIn.data(), ".p") != NULL;

	if (wantsSteamPath && !fileExists(in))
	{
		if (
			strcmp(newIn.data(), "scene.bin") == 0 ||
			strcmp(newIn.data(), "camdat0.bin") == 0 ||
			strcmp(newIn.data(), "camdat1.bin") == 0 ||
			strcmp(newIn.data(), "camdat2.bin") == 0 ||
			strcmp(newIn.data(), "co.bin") == 0
			)
		{
			get_data_lang_path(out);
			PathAppendA(out, R"(battle)");
			PathAppendA(out, newIn.data());

			if (!fileExists(out))
				return 1;
		}
		else
		{
			const char* pos = strstr(newIn.data(), "data");

			if (pos != NULL)
			{
				pos += 5;
			}
			else
			{
				// Search for the last '\' character and get a pointer to the next char
				pos = strrchr(in, 92);

				if (pos != NULL) pos += 1;
			}

			get_data_lang_path(out);
			if (pos != NULL) PathAppendA(out, pos);

			if ((!fileExists(out) || pos == NULL))
			{
				// If steam edition, do one more try in the user data path
				if (steam_edition) get_userdata_path(out, size, isSavegame);
				else strcpy(out, "");

				if (isCacheFile)
				{
					if (steam_edition)
					{
						PathAppendA(out, "cache");
						std::filesystem::create_directories(out);
					}
					PathAppendA(out, newIn.data());
				}
				else
				{
					if (isSavegame)
					{
						pos = strrchr(newIn.data(), 47) + 1;
						PathAppendA(out, pos);
					}
					else
					{
						PathAppendA(out, pos);
						if (!fileExists(out))
							return 1;
					}
				}
			}
		}

		if (trace_all || trace_files) ffnx_trace("Redirected: %s -> %s\n", newIn.data(), out);

		return 0;
	}
	else
	{
		if (isSavegame && !save_path.empty())
		{
			char* pos = strrchr(newIn.data(), 47);

			// This case may happen if we have already redirected the path
			if (strstr(newIn.data(), "save/save") == NULL)
			{
				// Allow the game to continue by forward the redirected path again
				strcpy(out, newIn.data());
			}
			// This one means we still have to redirect it
			else if (pos != NULL)
			{
				strcpy(out, basedir);
				PathAppendA(out, save_path.c_str());
				PathAppendA(out, ++pos);

				if (trace_all || trace_files) ffnx_trace("Redirected: %s -> %s\n", newIn.data(), out);
			}

			// Always return as found in order to allow non existing save files to be saved under the new redirected path
			return 0;
		}
		else if (!isCacheFile)
		{
			const char* pos = ff8 ? newIn.data() : strstr(newIn.data(), "data");

			if (pos != NULL)
			{
				pos += ff8 ? 0 : 5;
			}
			else
			{
				// Search for the last '\' character and get a pointer to the next char
				pos = strrchr(newIn.data(), 92);

				if (pos != NULL) pos += 1;
			}

			strcpy(out, basedir);
			PathAppendA(out, override_path.c_str());
			if (pos != NULL)
				PathAppendA(out, pos);
			else
			{
				PathAppendA(out, R"(battle)");
				PathAppendA(out, newIn.data());
			}

			if (!fileExists(out))
				return -1;

			if (trace_all || trace_files) ffnx_trace("Redirected: %s -> %s\n", newIn.data(), out);

			return 0;
		}
	}

	return -1;
}

int redirect_path_with_override(const char* in, char* out, size_t out_size)
{
	char _newFilename[MAX_PATH]{ 0 };

	// Attempt another redirection based on Steam/eStore logic
	int redirect_status = attempt_redirection(in, _newFilename, sizeof(_newFilename), steam_edition || estore_edition);

	// File was found
	if (redirect_status == 0)
	{
		// Attemp override redirection on top of Steam/eStore new path
		redirect_status = attempt_redirection(_newFilename, out, out_size);

		if (redirect_status == -1)
		{
			if (trace_all || trace_files) ffnx_trace("Redirection attempted, but file was not found: %s -> %s\n", in, _newFilename);

			// If was not found, use original redirected path
			strcpy(out, _newFilename);
		}
	}
	// File was not found
	else if (redirect_status == -1)
	{
		// Attemp override redirection on top of classic path
		redirect_status = attempt_redirection(in, out, out_size);

		if (redirect_status == -1)
		{
			if (trace_all || trace_files) ffnx_trace("Redirection attempted, but file was not found: %s -> %s\n", in, out);

			// If was not found, use original filename
			strcpy(out, in);
		}
	}

	return redirect_status;
}
````

## File: src/redirect.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

/**
 * Returns:
 *  -1 if the file was not found
 *   0 if the file is redirected
 *   1 if the file was not found but required
 */
int attempt_redirection(const char* in, char* out, size_t size, bool wantsSteamPath = false);
/**
 * Returns:
 *  -1 if the file was not found, in this case, `out` path is filled with `in` path content
 *  0  if the file is redirected
 *  1  if the file was not found but required
 */
int redirect_path_with_override(const char* in, char* out, size_t out_size);
````

## File: src/renderer.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

// We need to set WINVER and _WIN32_WINNT to Win10 in order for DISPLAYCONFIG_SDR_WHITE_LEVEL to be defined.
// Since the relevant functions have been defined since Win7, and we're only using a johnny-come-lately *parameter*,
// the SDR-white-level-for-HDR autodetection code should fail gracefully with a bad parameter error on older versions of Windows.
// In theory at least. (Not tested yet.)
// It does fail gracefully on Wine.
#define WINVER 0x0A00
#define _WIN32_WINNT 0x0A00

#include <windows.h>
#include <vector>

#include "lighting.h"
#include "ff7/widescreen.h"
#include "image/image.h"
#include "gl.h"
#include "log.h"
#include "cfg.h"
#include "utils.h"
#include "renderer.h"

CMRC_DECLARE(FFNx);

Renderer newRenderer;
RendererCallbacks bgfxCallbacks;

// BGFX CALLBACKS
void RendererCallbacks::fatal(const char* _filePath, uint16_t _line, bgfx::Fatal::Enum _code, const char* _str)
{
    std::string error;

    switch (_code) {
    case bgfx::Fatal::Enum::DebugCheck: error = "Debug Check";
    case bgfx::Fatal::Enum::InvalidShader: error = "Invalid Shader";
    case bgfx::Fatal::Enum::UnableToInitialize: error = "Unable To Initialize";
    case bgfx::Fatal::Enum::UnableToCreateTexture: error = "Unable To Create Texture";
    case bgfx::Fatal::Enum::DeviceLost: error = "Device Lost";
    }

    ffnx_error("[%s] %s\n", error.c_str(), _str);
}

void RendererCallbacks::traceVargs(const char* _filePath, uint16_t _line, const char* _format, va_list _argList)
{
    if (renderer_debug)
    {
        char buffer[16 * 1024];

        va_list argListCopy;
        va_copy(argListCopy, _argList);
        vsnprintf(buffer, sizeof(buffer), _format, argListCopy);
        va_end(argListCopy);

        ffnx_trace("%s", buffer);
    }
}

uint32_t RendererCallbacks::cacheReadSize(uint64_t _id)
{
    // Return 0 if shader is not found.
    return 0;
}

bool RendererCallbacks::cacheRead(uint64_t _id, void* _data, uint32_t _size)
{
    // Shader is not found in cache, needs to be rebuilt.
    return false;
}

void RendererCallbacks::cacheWrite(uint64_t _id, const void* _data, uint32_t _size)
{
}

// PRIVATE

// Via https://stackoverflow.com/a/14375308
uint32_t Renderer::createBGRA(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
{
    return ((b & 0xff) << 24) + ((g & 0xff) << 16) + ((r & 0xff) << 8) + (a & 0xff);
}

void Renderer::setCommonUniforms()
{
    internalState.VSFlags = {
        (float)internalState.bIsTLVertex,
        (float)internalState.blendMode,
        (float)internalState.bIsFBTexture,
        (float)internalState.bIsTexture
    };
    if (uniform_log) ffnx_trace("%s: VSFlags XYZW(isTLVertex %f, blendMode %f, isFBTexture %f, isTexture %f)\n", __func__, internalState.VSFlags[0], internalState.VSFlags[1], internalState.VSFlags[2], internalState.VSFlags[3]);

    internalState.FSAlphaFlags = {
        (float)internalState.alphaRef,
        (float)internalState.alphaFunc,
        (float)internalState.bDoAlphaTest,
        NULL
    };
    if (uniform_log) ffnx_trace("%s: FSAlphaFlags XYZW(inAlphaRef %f, inAlphaFunc %f, bDoAlphaTest %f, NULL)\n", __func__, internalState.FSAlphaFlags[0], internalState.FSAlphaFlags[1], internalState.FSAlphaFlags[2]);

    internalState.FSMiscFlags = {
        (float)internalState.bIsMovieFullRange,
        (float)internalState.bIsMovieYUV,
        (float)internalState.bModulateAlpha,
        (float)internalState.bIsMovie
    };
    if (uniform_log) ffnx_trace("%s: FSMiscFlags XYZW(isMovieFullRange %f, isMovieYUV %f, modulateAlpha %f, isMovie %f)\n", __func__, internalState.FSMiscFlags[0], internalState.FSMiscFlags[1], internalState.FSMiscFlags[2], internalState.FSMiscFlags[3]);

    internalState.FSHDRFlags = {
        (float)internalState.bIsHDR,
        (float)hdr_max_nits,
        (float)internalState.bIsOverrideGamut,
        NULL
    };
    if (uniform_log) ffnx_trace("%s: FSMiscFlags XYZW(isHDR %f, monitorNits %f, NULL, NULL)\n", __func__, internalState.FSHDRFlags[0], internalState.FSHDRFlags[1]);

    internalState.FSTexFlags = {
        (float)(internalState.texHandlers[RendererTextureSlot::TEX_NML].idx != bgfx::kInvalidHandle),
        (float)(internalState.texHandlers[RendererTextureSlot::TEX_PBR].idx != bgfx::kInvalidHandle),
        (float)(specularIblTexture.idx != bgfx::kInvalidHandle && diffuseIblTexture.idx != bgfx::kInvalidHandle && envBrdfTexture.idx != bgfx::kInvalidHandle),
        NULL
    };
    if (uniform_log) ffnx_trace("%s: FSTexFlags XYZW(isNmlTextureLoaded %f, isPbrTextureLoaded %f, isIblTextureLoaded %f, NULL)\n", __func__, internalState.FSTexFlags[0], internalState.FSTexFlags[1], internalState.FSTexFlags[2]);

    internalState.WMFlags = {
        (float)internalState.sphericalWorldRate,
        (float)internalState.bIsFogEnabled,
        NULL,
        NULL
    };
    if (uniform_log) ffnx_trace("%s: VSFlags XYZW(isTLVertex %f, blendMode %f, isFBTexture %f, isTexture %f)\n", __func__, internalState.VSFlags[0], internalState.VSFlags[1], internalState.VSFlags[2], internalState.VSFlags[3]);

    internalState.FSMovieFlags = {
        (float)internalState.bIsMovieColorMatrix,
        (float)internalState.bIsMovieColorGamut,
        (float)internalState.bIsMovieGammaType,
        (float)internalState.bIsOverallColorGamut,
    };
    if (uniform_log) ffnx_trace("%s: FSMovieFlags XYZW(color matrix %f, color gamut %f, gamma type %f, overall color gamut %f)\n", __func__, internalState.FSMovieFlags[0], internalState.FSMovieFlags[1], internalState.FSMovieFlags[2], internalState.FSMovieFlags[3]);

    internalState.gameLightingFlags = {
        (float)game_lighting,
        NULL,
        NULL,
        NULL,
    };

    setUniform(RendererUniform::VS_FLAGS,  internalState.VSFlags.data());
    setUniform(RendererUniform::FS_ALPHA_FLAGS, internalState.FSAlphaFlags.data());
    setUniform(RendererUniform::FS_MISC_FLAGS, internalState.FSMiscFlags.data());
    setUniform(RendererUniform::FS_HDR_FLAGS, internalState.FSHDRFlags.data());
    setUniform(RendererUniform::FS_TEX_FLAGS, internalState.FSTexFlags.data());
    setUniform(RendererUniform::FS_MOVIE_FLAGS, internalState.FSMovieFlags.data());
    setUniform(RendererUniform::WM_FLAGS, internalState.WMFlags.data());
    setUniform(RendererUniform::TIME_COLOR, internalState.TimeColor.data());
    setUniform(RendererUniform::TIME_DATA, internalState.TimeData.data());

    setUniform(RendererUniform::D3D_VIEWPORT, internalState.d3dViewMatrix);
    setUniform(RendererUniform::D3D_PROJECTION, internalState.d3dProjectionMatrix);
    setUniform(RendererUniform::WORLD_VIEW, internalState.worldViewMatrix);
    setUniform(RendererUniform::NORMAL_MATRIX, internalState.normalMatrix);
    setUniform(RendererUniform::VIEW_MATRIX, internalState.viewMatrix);
    setUniform(RendererUniform::INV_VIEW_MATRIX, internalState.invViewMatrix);

    setUniform(RendererUniform::GAME_LIGHTING_FLAGS,  internalState.gameLightingFlags.data());
    setUniform(RendererUniform::GAME_GLOBAL_LIGHT_COLOR, internalState.gameGlobalLightColor);
    setUniform(RendererUniform::GAME_LIGHT_COLOR1, internalState.gameLightColor1);
    setUniform(RendererUniform::GAME_LIGHT_COLOR2, internalState.gameLightColor2);
    setUniform(RendererUniform::GAME_LIGHT_COLOR3, internalState.gameLightColor3);
    setUniform(RendererUniform::GAME_LIGHT_DIR1, internalState.gameLightDir1);
    setUniform(RendererUniform::GAME_LIGHT_DIR2, internalState.gameLightDir2);
    setUniform(RendererUniform::GAME_LIGHT_DIR3, internalState.gameLightDir3);
    setUniform(RendererUniform::GAME_SCRIPTED_LIGHT_COLOR, internalState.gameScriptedLightColor);
}

void Renderer::setLightingUniforms()
{
    auto lightingState = lighting.getLightingState();

    setUniform(RendererUniform::LIGHTING_SETTINGS, lightingState.lightingSettings);
    setUniform(RendererUniform::LIGHT_DIR_DATA, lightingState.lightDirData);
    setUniform(RendererUniform::LIGHT_DATA, lightingState.lightData);
    setUniform(RendererUniform::AMBIENT_LIGHT_DATA, lightingState.ambientLightData);
    setUniform(RendererUniform::SHADOW_DATA, lightingState.shadowData);
    setUniform(RendererUniform::FIELD_SHADOW_DATA, lightingState.fieldShadowData);
    setUniform(RendererUniform::MATERIAL_DATA, lightingState.materialData);
    setUniform(RendererUniform::MATERIAL_SCALE_DATA, lightingState.materialScaleData);
    setUniform(RendererUniform::LIGHTING_DEBUG_DATA, lightingState.lightingDebugData);
    setUniform(RendererUniform::IBL_DATA, lightingState.iblData);

    setUniform(RendererUniform::LIGHT_VIEW_PROJ_MATRIX, lightingState.lightViewProjMatrix);
    setUniform(RendererUniform::LIGHT_VIEW_PROJ_TEX_MATRIX, lightingState.lightViewProjTexMatrix);
    setUniform(RendererUniform::LIGHT_INV_VIEW_PROJ_TEX_MATRIX, lightingState.lightInvViewProjTexMatrix);
}

bgfx::RendererType::Enum Renderer::getUserChosenRenderer() {
    bgfx::RendererType::Enum ret;

    switch (renderer_backend)
    {
    case RENDERER_BACKEND_AUTO:
        ret = bgfx::RendererType::Count;
        break;
    case RENDERER_BACKEND_OPENGL:
        ret = bgfx::RendererType::OpenGL;
        break;
    case RENDERER_BACKEND_DIRECT3D11:
        ret = bgfx::RendererType::Direct3D11;
        break;
    case RENDERER_BACKEND_DIRECT3D12:
        ret = bgfx::RendererType::Direct3D12;
        break;
    case RENDERER_BACKEND_VULKAN:
        ret = bgfx::RendererType::Vulkan;
        break;
    default:
        ret = bgfx::RendererType::Noop;
        break;
    }

    return ret;
}

void Renderer::updateRendererShaderPaths()
{
    std::string shaderSuffix;

    switch (getCaps()->rendererType)
    {
    case bgfx::RendererType::OpenGL:
        currentRenderer = "OpenGL";
        shaderSuffix = ".gl";
        break;
    case bgfx::RendererType::Direct3D11:
        currentRenderer = "Direct3D11";
        shaderSuffix = ".d3d11";
        break;
    case bgfx::RendererType::Direct3D12:
        currentRenderer = "Direct3D12";
        shaderSuffix = ".d3d12";
        break;
    case bgfx::RendererType::Vulkan:
        currentRenderer = "Vulkan";
        shaderSuffix = ".vk";
        break;
    }

    vertexPathFlat += ".flat" + shaderSuffix + ".vert";
    fragmentPathFlat += ".flat" + shaderSuffix + ".frag";
    vertexPathSmooth += ".smooth" + shaderSuffix + ".vert";
    fragmentPathSmooth += ".smooth" + shaderSuffix + ".frag";
    vertexPostPath += ".smooth" + shaderSuffix + ".vert";
    fragmentPostPath += ".smooth" + shaderSuffix + ".frag";
    vertexOverlayPath += ".smooth" + shaderSuffix + ".vert";
    fragmentOverlayPath += ".smooth" + shaderSuffix + ".frag";
    vertexLightingPathFlat += ".flat" + shaderSuffix + ".vert";
    fragmentLightingPathFlat += ".flat" + shaderSuffix + ".frag";
    vertexLightingPathSmooth += ".smooth" + shaderSuffix + ".vert";
    fragmentLightingPathSmooth += ".smooth" + shaderSuffix + ".frag";
    vertexShadowMapPath += ".smooth" + shaderSuffix + ".vert";
    fragmentShadowMapPath += ".smooth" + shaderSuffix + ".frag";
    vertexFieldShadowPath += ".smooth" + shaderSuffix + ".vert";
    fragmentFieldShadowPath += ".smooth" + shaderSuffix + ".frag";
    vertexBlitPath += ".flat" + shaderSuffix + ".vert";
    fragmentBlitPath += ".flat" + shaderSuffix + ".frag";
}

// Via https://dev.to/pperon/hello-bgfx-4dka
bgfx::ShaderHandle Renderer::getShader(const char* filePath)
{
    bgfx::ShaderHandle handle = BGFX_INVALID_HANDLE;

    FILE* file = fopen(filePath, "rb");

    if (file == NULL)
    {
        char tmp[1024]{ 0 };

        sprintf(tmp, "Oops! Something very bad happened.\n\nCould not find shader file:\n%s\n\nMake sure all the provided files are installed correctly.", filePath);

        MessageBoxA(gameHwnd, tmp, "Error", MB_ICONERROR | MB_OK);

        exit(1);
    }

    fseek(file, 0, SEEK_END);
    long fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);

    const bgfx::Memory* mem = bgfx::alloc(fileSize);
    fread(mem->data, 1, fileSize, file);
    fclose(file);

    handle = bgfx::createShader(mem);

    if (bgfx::isValid(handle))
    {
        bgfx::setName(handle, filePath);
    }

    return handle;
}

bgfx::UniformHandle Renderer::createUniform(std::string uniformName, bgfx::UniformType::Enum uniformType)
{
    bgfx::UniformHandle handle;
    handle = bgfx::createUniform(uniformName.c_str(), uniformType);
    return handle;
}

bgfx::UniformHandle Renderer::setUniform(RendererUniform uniform, const void* uniformValue)
{
    bgfx::UniformHandle handle = bgfxUniformHandles[uniform];

    if (bgfx::isValid(handle))
    {
        bgfx::setUniform(handle, uniformValue);
    }

    return handle;
}

void Renderer::destroyUniforms()
{
    for (const auto& handle : bgfxUniformHandles)
    {
        if (bgfx::isValid(handle))
            bgfx::destroy(handle);
    }
}

void Renderer::destroyAll()
{
    destroyUniforms();

    for (auto& handle : internalState.texHandlers)
    {
        if (bgfx::isValid(handle))
            bgfx::destroy(handle);
    }

    bgfx::destroy(vertexBufferHandle);

    bgfx::destroy(indexBufferHandle);

    bgfx::destroy(backendFrameBuffer);

    bgfx::destroy(shadowMapFrameBuffer);

    for (auto& handle : backendProgramHandles)
    {
        if (bgfx::isValid(handle))
            bgfx::destroy(handle);
    }

    if (enable_devtools)
        overlay.destroy();
};

void Renderer::resetState()
{
    setBackgroundColor();

    doAlphaTest();
    doDepthTest();
    doDepthWrite();
    doScissorTest();
    setCullMode();
    setBlendMode();
    setAlphaRef();
    setInterpolationQualifier();
    isTLVertex();
    isYUV();
    isFullRange();
    isFBTexture();
    isTexture();
    doModulateAlpha();
    doTextureFiltering();
    isExternalTexture();
    setColorMatrix();
    setColorGamut();
    setOverallColorGamut(enable_ntscj_gamut_mode ? COLORGAMUT_NTSCJ : COLORGAMUT_SRGB);
    setGamutOverride();
    setGammaType();
    setGameLightData();

    doMirrorTextureWrap();
    setSphericalWorldRate();
    setFogEnabled();

    resetViewMatrixFlag();
};

void Renderer::renderFrame()
{
    /*  y0    y2
     x0 +-----+ x2
        |    /|
        |   / |
        |  /  |
        | /   |
        |/    |
     x1 +-----+ x3
        y1    y3
    */

    // 0
    float x0 = framebufferVertexOffsetX;
    if (aspect_ratio == AR_STRETCH) x0 = 0.0f;
    float y0 = 0.0f;
    float u0 = 0.0f;
    float v0 = getCaps()->originBottomLeft ? 1.0f : 0.0f;
    // 1
    float x1 = x0;
    float y1 = game_height;
    float u1 = u0;
    float v1 = getCaps()->originBottomLeft ? 0.0f : 1.0f;
    // 2
    float x2 = x0 + framebufferVertexWidth;
    if (aspect_ratio == AR_STRETCH) x2 = x0 + game_width;
    float y2 = y0;
    float u2 = 1.0f;
    float v2 = v0;
    // 3
    float x3 = x2;
    float y3 = y1;
    float u3 = u2;
    float v3 = v1;

    struct nvertex vertices[] = {
        {x0, y0, 1.0f, 1.0f, 0xff000000, 0, u0, v0},
        {x1, y1, 1.0f, 1.0f, 0xff000000, 0, u1, v1},
        {x2, y2, 1.0f, 1.0f, 0xff000000, 0, u2, v2},
        {x3, y3, 1.0f, 1.0f, 0xff000000, 0, u3, v3},
    };
    WORD indices[] = {
        0, 1, 2,
        1, 3, 2
    };

    backendProgram = RendererProgram::POSTPROCESSING;
    backendViewId++;
    {
        bool needsToDraw = internalState.bHasDrawBeenDone;

        if (internalState.bHasDrawBeenDone)
            useTexture(
                bgfx::getTexture(backendFrameBuffer).idx
            );
        else
            useTexture(0);

        setClearFlags(true, true);

        bindVertexBuffer(vertices, 0, 4);
        bindIndexBuffer(indices, 6);

        setBlendMode(RendererBlendMode::BLEND_DISABLED);
        setPrimitiveType();

        if (needsToDraw) draw();

        setBlendMode();
    }
};

void Renderer::printMatrix(char* name, float* mat)
{
    ffnx_trace("%s: 0 [%f, %f, %f, %f]\n", name, mat[0], mat[1], mat[2], mat[3]);
    ffnx_trace("%s: 1 [%f, %f, %f, %f]\n", name, mat[4], mat[5], mat[6], mat[7]);
    ffnx_trace("%s: 2 [%f, %f, %f, %f]\n", name, mat[8], mat[9], mat[10], mat[11]);
    ffnx_trace("%s: 3 [%f, %f, %f, %f]\n", name, mat[12], mat[13], mat[14], mat[15]);
};

bool Renderer::doesItFitInMemory(size_t size)
{
    if (size <= 0) ffnx_glitch("Unexpected texture size while checking if it fits in memory.\n");

    // We need to check this value as much as in real time as possible, to avoid possible crashes
    GlobalMemoryStatusEx(&last_ram_state);

    return size < last_ram_state.ullAvailVirtual;
}

void Renderer::recalcInternals()
{
    scalingFactor = internal_resolution_scale;

    viewWidth = window_size_x;
    viewHeight = window_size_y;

    // aspect correction
    switch(aspect_ratio){
        case AR_ORIGINAL:
            if (viewWidth * 3 != viewHeight * 4)
            {
                if (viewHeight * 4 > viewWidth * 3)
                {
                    viewOffsetY = viewHeight - (viewWidth * 3) / 4;
                    viewHeight = (viewWidth * 3) / 4;

                    y_offset = viewOffsetY;
                }
                else if (viewWidth * 3 > viewHeight * 4)
                {
                    viewOffsetX = (viewWidth - (viewHeight * 4) / 3) / 2;
                    viewWidth = (viewHeight * 4) / 3;

                    x_offset = viewOffsetX;
                }
            }
            break;
        case AR_WIDESCREEN_16X9:
            if (viewWidth * 9 != viewHeight * 16)
            {
                if (viewHeight * 16 > viewWidth * 9)
                {
                    viewOffsetY = viewHeight - (viewWidth * 9) / 16;
                    viewHeight = (viewWidth * 9) / 16;

                    y_offset = viewOffsetY;
                }
                else if (viewWidth * 9 > viewHeight * 16)
                {
                    viewOffsetX = (viewWidth - (viewHeight * 16) / 9) / 2;
                    viewWidth = (viewHeight * 16) / 9;

                    x_offset = viewOffsetX;
                }
            }
            break;
        case AR_WIDESCREEN_16X10:
            if (viewWidth * 10 != viewHeight * 16)
            {
                if (viewHeight * 16 > viewWidth * 10)
                {
                    viewOffsetY = viewHeight - (viewWidth * 10) / 16;
                    viewHeight = (viewWidth * 10) / 16;

                    y_offset = viewOffsetY;
                }
                else if (viewWidth * 10 > viewHeight * 16)
                {
                    viewOffsetX = (viewWidth - (viewHeight * 16) / 10) / 2;
                    viewWidth = (viewHeight * 16) / 10;

                    x_offset = viewOffsetX;
                }
            }
            break;
    }

    // If internal_resolution_scale from settings is less than one, calculate the closest fit for the output resolution, otherwise use the value directly
    if (internal_resolution_scale < 1)
    {
        long scaleW = ::round(viewWidth / (float)game_width);
        long scaleH = ::round(viewHeight / (float)game_height);

        if (scaleH > scaleW) scaleW = scaleH;
        if (scaleW > internal_resolution_scale) scalingFactor = scaleW;
        if (scalingFactor < 1) scalingFactor = 1;
    }

    // Use the set or calculated scaling factor to determine the width and height of the framebuffer according to the original resolution
    if(widescreen_enabled)
    {
        framebufferWidth = wide_game_width * scalingFactor;
        framebufferHeight = wide_game_height * scalingFactor;

        framebufferVertexWidth = (viewWidth * wide_game_width) / window_size_x;
        framebufferVertexOffsetX = (wide_game_width - framebufferVertexWidth) / 2;
    }
    else
    {
        framebufferWidth = game_width * scalingFactor;
        framebufferHeight = game_height * scalingFactor;

        framebufferVertexWidth = (viewWidth * game_width) / window_size_x;
        framebufferVertexOffsetX = (game_width - framebufferVertexWidth) / 2;
    }

    // Let the user know about chosen resolutions
    if (widescreen_enabled)
        ffnx_info("Original resolution %ix%i, Scaling factor %ix, Internal resolution %ix%i, Output resolution %ix%i\n", wide_game_width, wide_game_height, scalingFactor, framebufferWidth, framebufferHeight, window_size_x, window_size_y);
    else
        ffnx_info("Original resolution %ix%i, Scaling factor %ix, Internal resolution %ix%i, Output resolution %ix%i\n", game_width, game_height, scalingFactor, framebufferWidth, framebufferHeight, window_size_x, window_size_y);
}

void Renderer::calcBackendProjMatrix()
{
    // Used by the game
    bx::mtxOrtho(
        internalState.backendProjMatrix,
        widescreen_enabled ? wide_viewport_x : 0.0f,
        widescreen_enabled ? wide_viewport_width + wide_viewport_x : game_width,
        widescreen_enabled ? wide_game_height : game_height,
        0.0f,
        getCaps()->homogeneousDepth ? -1.0f : 0.0f,
        1.0f,
        0.0,
        getCaps()->homogeneousDepth
    );

    // Used by postprocessing ( rendering the game framebuffer on screen)
    bx::mtxOrtho(
        internalState.postprocessingProjMatrix,
        0.0f,
        widescreen_enabled ? wide_game_width : game_width,
        widescreen_enabled ? wide_game_height : game_height,
        0.0f,
        getCaps()->homogeneousDepth ? -1.0f : 0.0f,
        1.0f,
        0.0,
        getCaps()->homogeneousDepth
    );
}

void Renderer::prepareFramebuffer()
{
    // If already existing, destroy
    if (bgfx::isValid(backendFrameBuffer))
        bgfx::destroy(backendFrameBuffer);

    uint64_t fbFlags = BGFX_TEXTURE_RT;

    if (enable_antialiasing > 0)
    {
        if (enable_antialiasing <= 2)
            fbFlags = BGFX_TEXTURE_RT_MSAA_X2;
        else if (enable_antialiasing <= 4)
            fbFlags = BGFX_TEXTURE_RT_MSAA_X4;
        else if (enable_antialiasing <= 8)
            fbFlags = BGFX_TEXTURE_RT_MSAA_X8;
        else if (enable_antialiasing <= 16)
            fbFlags = BGFX_TEXTURE_RT_MSAA_X16;
    }

    backendFrameBufferRT[0] = bgfx::createTexture2D(
        framebufferWidth,
        framebufferHeight,
        false,
        1,
        internalState.bIsHDR ? bgfx::TextureFormat::RGB10A2 : bgfx::TextureFormat::RGBA16,
        fbFlags | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP
    );

    backendFrameBufferRT[1] = bgfx::createTexture2D(
        framebufferWidth,
        framebufferHeight,
        false,
        1,
        bgfx::TextureFormat::D32F,
        fbFlags | BGFX_TEXTURE_RT_WRITE_ONLY
    );

    backendFrameBuffer = bgfx::createFrameBuffer(
        backendFrameBufferRT.size(),
        backendFrameBufferRT.data(),
        true
    );
}

void Renderer::bindTextures()
{
    if (!internalState.bTexturesBound)
    {
        for (uint32_t idx = RendererTextureSlot::TEX_Y; idx < RendererTextureSlot::COUNT; idx++)
        {
            bgfx::TextureHandle handle = internalState.texHandlers[idx];

            if (bgfx::isValid(handle))
            {
                uint32_t flags = 0;

                switch(idx)
                {
                    case RendererTextureSlot::TEX_Y:
                    case RendererTextureSlot::TEX_U:
                    case RendererTextureSlot::TEX_V:
                        if (!internalState.bIsMovie && idx > RendererTextureSlot::TEX_Y) handle = BGFX_INVALID_HANDLE;

                        if (backendProgram == RendererProgram::POSTPROCESSING)
                        {
                            flags = BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP | BGFX_SAMPLER_MIN_ANISOTROPIC | BGFX_SAMPLER_MAG_ANISOTROPIC;
                        }
                        else
                        {
                            if (internalState.bDoMirrorTextureWrap) flags |= BGFX_SAMPLER_U_MIRROR | BGFX_SAMPLER_V_MIRROR | BGFX_SAMPLER_W_CLAMP;

                            if (internalState.bIsMovie) flags |= BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP;

                            if (!internalState.bDoTextureFiltering || !internalState.bIsExternalTexture) flags |= BGFX_SAMPLER_MIN_POINT | BGFX_SAMPLER_MAG_POINT | BGFX_SAMPLER_MIP_POINT;
                        }
                        break;
                    case RendererTextureSlot::TEX_S:
                    case RendererTextureSlot::TEX_D:
                        // Specially handled, move on
                        continue;
                    case RendererTextureSlot::TEX_G_LUT:
                        flags |= BGFX_SAMPLER_POINT | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP;
                        break;
                    default:
                        break;
                }

                if (flags == 0) flags = UINT32_MAX;

                bgfx::setTexture(idx, bgfxTexUniformHandles[idx], handle, flags);
            }
        }

        internalState.bTexturesBound = true;
    }
}

void Renderer::AssignGamutLUT()
{
	// Since HDR uses the super-wide rec2020 gamut, it doesn't need a gamut (compression) mapping algorithm,
	// so it would be better to use the old matrix-based conversions instead of the LUTs that embody a GMA.
	// That's what we do in post-processing.
	// However, in two cases we have two serial conversions happening:
	// (1) Movies where the movie's gamut isn't the same as the selected gamut mode
	// (2) The implemented but as-yet unused internalState.bIsOverrideGamut
	// What I'd *like* to do is to do matrix-based conversions for the first round,
	// then *tolerate* the out-of-bounds values until post processing,
	// then the final conversion to rec2020 will bring those values back in bounds.
	// Unfortunately, I don't think the lighting code could tolerate out-of-bounds values.
	// (Also, the srgb gamma function would need to be changed to avoid calling pow() on a negative input.)
	// So, for now I'm using the LUTs for the first step for both SDR and HDR,
	// and I'm putting this comment here in case we ever figure out how to tolerate out-of-bounds values
	//if (internalState.bIsHDR) return;


	// NTSCJ mode post-processing
	if ((backendProgram == RendererProgram::POSTPROCESSING) && (internalState.bIsOverallColorGamut == COLORGAMUT_NTSCJ)){
		LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB); // load LUT if not already loaded
		useTexture(GLUTHandleNTSCJtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
	}
	// Movies and override flag
	// Note: Override flag currently does nothing because it's never set to true anywhere
	// The intent is to eventually have a way to say "I want to display a NTSCJ asset in sRGB mode" or "I want to display a sRGB asset in NTSCJ mode."
	else {
		if (internalState.bIsOverallColorGamut == COLORGAMUT_SRGB){
			if ((internalState.bIsMovieColorGamut == COLORGAMUT_NTSCJ) || internalState.bIsOverrideGamut){
				LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB); // load LUT if not already loaded
				useTexture(GLUTHandleNTSCJtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
			}
			else if (internalState.bIsMovieColorGamut == COLORGAMUT_SMPTEC){
				LoadGamutLUT(INDEX_LUT_SMPTEC_TO_SRGB); // load LUT if not already loaded
				useTexture(GLUTHandleSMPTECtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
			}
			else if (internalState.bIsMovieColorGamut == COLORGAMUT_EBU){
				LoadGamutLUT(INDEX_LUT_EBU_TO_SRGB); // load LUT if not already loaded
				useTexture(GLUTHandleEBUtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
			}
		}
		else if (internalState.bIsOverallColorGamut == COLORGAMUT_NTSCJ){
			// SDR should use the "inverse" conversions created with gamutthingy's "expand" flag, to compensate for the compression later,
			// but HDR should not because the conversion to rec2020 doesn't involve compression
			// This isn't exactly kosher for the SMPTEC and EBU cases, but they're close enough to sRGB
			// that doing the expansion probably gives closer to accurate results than not doing it.
			if (internalState.bIsHDR){
				if ((internalState.bIsMovieColorGamut == COLORGAMUT_SRGB) || internalState.bIsOverrideGamut){
					LoadGamutLUT(INDEX_LUT_SRGB_TO_NTSCJ); // load LUT if not already loaded
					useTexture(GLUTHandleSRGBtoNTSCJ.idx, RendererTextureSlot::TEX_G_LUT);
				}
				else if (internalState.bIsMovieColorGamut == COLORGAMUT_SMPTEC){
					LoadGamutLUT(INDEX_LUT_SMPTEC_TO_NTSCJ); // load LUT if not already loaded
					useTexture(GLUTHandleSMPTECtoNTSCJ.idx, RendererTextureSlot::TEX_G_LUT);
				}
				else if (internalState.bIsMovieColorGamut == COLORGAMUT_EBU){
					LoadGamutLUT(INDEX_LUT_EBU_TO_NTSCJ); // load LUT if not already loaded
					useTexture(GLUTHandleEBUtoNTSCJ.idx, RendererTextureSlot::TEX_G_LUT);
				}
			}
			else{
				if ((internalState.bIsMovieColorGamut == COLORGAMUT_SRGB) || internalState.bIsOverrideGamut){
					LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_SRGB); // load LUT if not already loaded
					useTexture(GLUTHandleInverseNTSCJtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
				}
				else if (internalState.bIsMovieColorGamut == COLORGAMUT_SMPTEC){
					LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_SMPTEC); // load LUT if not already loaded
					useTexture(GLUTHandleInverseNTSCJtoSMPTEC.idx, RendererTextureSlot::TEX_G_LUT);
				}
				else if (internalState.bIsMovieColorGamut == COLORGAMUT_EBU){
					LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_EBU); // load LUT if not already loaded
					useTexture(GLUTHandleInverseNTSCJtoEBU.idx, RendererTextureSlot::TEX_G_LUT);
				}
			}
		}

	}
	return;
}

// PUBLIC

void Renderer::init()
{
    recalcInternals();

    // Init renderer
    bgfxInit.platformData.nwh = gameHwnd;
    bgfxInit.type = getUserChosenRenderer();
    bgfxInit.resolution.width = window_size_x;
    bgfxInit.resolution.height = window_size_y;

    if (enable_anisotropic)
        bgfxInit.resolution.reset |= BGFX_RESET_MAXANISOTROPY;

    if (enable_vsync)
        bgfxInit.resolution.reset |= BGFX_RESET_VSYNC;

    bgfxInit.debug = renderer_debug;
    bgfxInit.callback = &bgfxCallbacks;

    if (!bgfx::init(bgfxInit)) exit(1);

    // If HDR support is present, make use of it
    if (getCaps()->supported & BGFX_CAPS_HDR10)
    {
        internalState.bIsHDR = true;
        ffnx_info("HDR monitor detected. HDR enabled.\n");

        bgfxInit.resolution.reset |= BGFX_RESET_HDR10;
        bgfxInit.resolution.format = bgfx::TextureFormat::RGB10A2;

        if (hdr_max_nits <= 0) {
            ffnx_info("Attempting to autodetect SDR white level for HDR...\n");
            // The goal here is to autodetect "the brightness level that SDR 'white' is rendered at within an HDR monitor."
            // See: https://www.pyromuffin.com/2018/07/how-to-do-nothing-in-hdr.html
            // See also: https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-displayconfig_sdr_white_level
            // Autodetection may fail on some monitor models.
            // Autodetection WILL fail on Windows older than Win10 Fall Creators Update (Version 1709) and WILL fail on WINE (at least as of WINE 7.22)

            // First, enumerate the DISPLAYCONFIG_PATH_INFO for all monitors.
            // Code borrowed from Microsoft's example: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-querydisplayconfig#examples
            std::vector<DISPLAYCONFIG_PATH_INFO> paths;
            std::vector<DISPLAYCONFIG_MODE_INFO> modes;
            UINT32 flags = QDC_ONLY_ACTIVE_PATHS; // | QDC_VIRTUAL_MODE_AWARE; // MS's example is wrong. Causes bad param error on WINE. See: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdisplayconfigbuffersizes
            LONG monresult = ERROR_SUCCESS;
            bool gotbuffersizes = false;
            bool usedefaultnits = true;
            do {
                // Determine how many path and mode structures to allocate
                UINT32 pathCount, modeCount;
                monresult = GetDisplayConfigBufferSizes(flags, &pathCount, &modeCount);

                if (monresult != ERROR_SUCCESS){
                    if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Cannot enumerate monitors. GetDisplayConfigBufferSizes() failed with error code %i.\n", monresult);
                    break;
                }
                gotbuffersizes = true;

                // Allocate the path and mode arrays
                paths.resize(pathCount);
                modes.resize(modeCount);

                // Get all active paths and their modes
                monresult = QueryDisplayConfig(flags, &pathCount, paths.data(), &modeCount, modes.data(), nullptr);

                // The function may have returned fewer paths/modes than estimated
                paths.resize(pathCount);
                modes.resize(modeCount);

                // It's possible that between the call to GetDisplayConfigBufferSizes and QueryDisplayConfig
                // that the display state changed, so loop on the case of ERROR_INSUFFICIENT_BUFFER.
            } while (monresult == ERROR_INSUFFICIENT_BUFFER);

            if (monresult != ERROR_SUCCESS){
                if (gotbuffersizes){
                    if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Cannot enumerate monitors. QueryDisplayConfig() failed with error code %i.\n", monresult);
                }
            }
            else {
                // loop over monitors and take the SDR white level of the first HDR monitor we find.
                int pathidx = -1;
                for (auto& path : paths) {
                    pathidx++;

                    // Check if this monitor is HDR capable and HDR enabled
                    // Borrowed from these two examples:
                    // https://forum.doom9.org/showthread.php?s=33dc0ad84a0997fce56710b3959e0415&p=1897630#post1897630
                    // https://stackoverflow.com/a/66160049
                    DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO getColorInfo = {};
                    getColorInfo.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;
                    getColorInfo.header.id = path.targetInfo.id;
                    getColorInfo.header.adapterId = path.targetInfo.adapterId;
                    getColorInfo.header.size = sizeof(getColorInfo);
                    monresult = DisplayConfigGetDeviceInfo(&getColorInfo.header);
                    if (monresult != ERROR_SUCCESS){
                        if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR skipping monitor #%i because DisplayConfigGetDeviceInfo() DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO check failed with error code %i.\n", pathidx, monresult);
                        continue;
                    }
                    if (!getColorInfo.advancedColorSupported || !getColorInfo.advancedColorEnabled){
                        if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR determined that monitor #%i is not an HDR monitor or HDR is not enabled. Checking next monitor (if any)...\n", pathidx);
                        continue;
                    }

                    // If we found an HDR monitor, then query its SDR white level
                    // Code borrowed from Google Chrome: https://chromium.googlesource.com/chromium/src/+/c71f15ab1ace78c7efeeeda9f8552b4af9db2877/ui/display/win/screen_win.cc#112
                    DISPLAYCONFIG_SDR_WHITE_LEVEL white_level = {};
                    white_level.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL;
                    white_level.header.id = path.targetInfo.id;
                    white_level.header.adapterId = path.targetInfo.adapterId;
                    white_level.header.size = sizeof(white_level);
                    monresult = DisplayConfigGetDeviceInfo(&white_level.header);
                    if (monresult != ERROR_SUCCESS){
                        if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Monitor #%i appears to be an HDR monitor, but DisplayConfigGetDeviceInfo() DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL check failed with error code %i.\n", pathidx, monresult);
                        break;
                    }
                    if (white_level.SDRWhiteLevel == 0){
                        if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Monitor #%i appears to be an HDR monitor, but SDR white level is reported as 0.\n", pathidx);
                        break;
                    }
                    // SDRWhiteLevel is stored in units of 2/25 nits (but with steps of 80 nits), because Microsoft.
                    // See: https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-displayconfig_sdr_white_level
                    hdr_max_nits = white_level.SDRWhiteLevel * 80.0 / 1000.0;
                    ffnx_info("SDR white level for HDR successfully autodetected as %i nits.\n", (int)hdr_max_nits);
                    usedefaultnits = false;
                    break;

                } // end for (auto& path : paths)

            } // end else (monresult == ERROR_SUCCESS)
            if (usedefaultnits){
                ffnx_info("Autodetection of SDR white level for HDR failed. Assuming default value of 200 nits.\n");
                // Google thinks 200 nits is a good default. Who are we to argue?
                hdr_max_nits = 200.0;
            }
        } // end if  (hdr_max_nits <= 0)

        bgfx::reset(window_size_x, window_size_y, bgfxInit.resolution.reset, bgfxInit.resolution.format);
    } //end if HDR

    internalState.texHandlers.resize(RendererTextureSlot::COUNT, BGFX_INVALID_HANDLE);

    updateRendererShaderPaths();

    calcBackendProjMatrix();

    prepareFramebuffer();

    prepareShadowMap();

    // Create Program
    backendProgramHandles[RendererProgram::POSTPROCESSING] = bgfx::createProgram(
        getShader(vertexPostPath.c_str()),
        getShader(fragmentPostPath.c_str()),
        true
    );

    backendProgramHandles[RendererProgram::FLAT] = bgfx::createProgram(
        getShader(vertexPathFlat.c_str()),
        getShader(fragmentPathFlat.c_str()),
        true
    );

    backendProgramHandles[RendererProgram::SMOOTH] = bgfx::createProgram(
        getShader(vertexPathSmooth.c_str()),
        getShader(fragmentPathSmooth.c_str()),
        true
    );

    backendProgramHandles[RendererProgram::LIGHTING_FLAT] = bgfx::createProgram(
        getShader(vertexLightingPathFlat.c_str()),
        getShader(fragmentLightingPathFlat.c_str()),
        true
    );

    backendProgramHandles[RendererProgram::LIGHTING_SMOOTH] = bgfx::createProgram(
        getShader(vertexLightingPathSmooth.c_str()),
        getShader(fragmentLightingPathSmooth.c_str()),
        true
    );

    backendProgramHandles[RendererProgram::FIELD_SHADOW] = bgfx::createProgram(
        getShader(vertexFieldShadowPath.c_str()),
        getShader(fragmentFieldShadowPath.c_str()),
        true
    );

    backendProgramHandles[RendererProgram::SHADOW_MAP] = bgfx::createProgram(
        getShader(vertexShadowMapPath.c_str()),
        getShader(fragmentShadowMapPath.c_str()),
        true
    );

    backendProgramHandles[RendererProgram::BLIT] = bgfx::createProgram(
        getShader(vertexBlitPath.c_str()),
        getShader(fragmentBlitPath.c_str()),
        true
    );

    vertexLayout
        .begin()
        .add(bgfx::Attrib::Position, 4, bgfx::AttribType::Float)
        .add(bgfx::Attrib::Color0, 4, bgfx::AttribType::Uint8, true)
        .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float)
        .add(bgfx::Attrib::Normal, 3, bgfx::AttribType::Float)
        .end();

    bgfx::setDebug(BGFX_DEBUG_TEXT);

    bgfx::frame();

    if (enable_devtools)
    {
        backendProgramHandles[RendererProgram::OVERLAY] = bgfx::createProgram(
            getShader(vertexOverlayPath.c_str()),
            getShader(fragmentOverlayPath.c_str()),
            true
        );
        overlay.init(backendProgramHandles[RendererProgram::OVERLAY], window_size_x, window_size_y);
    }

    bgfxUniformHandles[RendererUniform::VS_FLAGS] = createUniform("VSFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::FS_ALPHA_FLAGS] = createUniform("FSAlphaFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::FS_MISC_FLAGS] = createUniform("FSMiscFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::FS_HDR_FLAGS] = createUniform("FSHDRFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::FS_TEX_FLAGS] = createUniform("FSTexFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::FS_MOVIE_FLAGS] = createUniform("FSMovieFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::WM_FLAGS] = createUniform("WMFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::TIME_COLOR] = createUniform("TimeColor", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::TIME_DATA] = createUniform("TimeData", bgfx::UniformType::Vec4);

    bgfxUniformHandles[RendererUniform::D3D_VIEWPORT] = createUniform("d3dViewport", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::D3D_PROJECTION] = createUniform("d3dProjection", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::WORLD_VIEW] = createUniform("worldView", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::NORMAL_MATRIX] = createUniform("normalMatrix", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::VIEW_MATRIX] = createUniform("viewMatrix", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::INV_VIEW_MATRIX] = createUniform("invViewMatrix", bgfx::UniformType::Mat4);

    bgfxUniformHandles[RendererUniform::LIGHTING_SETTINGS] = createUniform("lightingSettings", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::LIGHT_DIR_DATA] = createUniform("lightDirData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::LIGHT_DATA] = createUniform("lightData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::AMBIENT_LIGHT_DATA] = createUniform("ambientLightData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::SHADOW_DATA] = createUniform("shadowData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::FIELD_SHADOW_DATA] = createUniform("fieldShadowData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::MATERIAL_DATA] = createUniform("materialData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::MATERIAL_SCALE_DATA] = createUniform("materialScaleData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::LIGHTING_DEBUG_DATA] = createUniform("lightingDebugData", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::IBL_DATA] = createUniform("iblData", bgfx::UniformType::Vec4);

    bgfxUniformHandles[RendererUniform::LIGHT_VIEW_PROJ_MATRIX] = createUniform("lightViewProjMatrix", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::LIGHT_VIEW_PROJ_TEX_MATRIX] = createUniform("lightViewProjTexMatrix", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::LIGHT_INV_VIEW_PROJ_TEX_MATRIX] = createUniform("lightInvViewProjTexMatrix", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::VIEW_OFFSET_MATRIX] = createUniform("viewOffsetMatrix", bgfx::UniformType::Mat4);
    bgfxUniformHandles[RendererUniform::INV_VIEW_OFFSET_MATRIX] = createUniform("invViewOffsetMatrix", bgfx::UniformType::Mat4);

    bgfxUniformHandles[RendererUniform::GAME_LIGHTING_FLAGS] = createUniform("gameLightingFlags", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_GLOBAL_LIGHT_COLOR] = createUniform("gameGlobalLightColor", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_LIGHT_COLOR1] = createUniform("gameLightColor1", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_LIGHT_COLOR2] = createUniform("gameLightColor2", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_LIGHT_COLOR3] = createUniform("gameLightColor3", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_LIGHT_DIR1] = createUniform("gameLightDir1", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_LIGHT_DIR2] = createUniform("gameLightDir2", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_LIGHT_DIR3] = createUniform("gameLightDir3", bgfx::UniformType::Vec4);
    bgfxUniformHandles[RendererUniform::GAME_SCRIPTED_LIGHT_COLOR] = createUniform("gameScriptedLightColor", bgfx::UniformType::Vec4);

    for(int i = 0; i < RendererTextureSlot::COUNT; ++i)
    {
        bgfxTexUniformHandles[i] = createUniform("tex_" + std::to_string(i), bgfx::UniformType::Sampler);
    }

    // Set defaults
    show();
};

void Renderer::reset()
{
    recalcInternals();

    calcBackendProjMatrix();

    prepareFramebuffer();

    if(!ff8 && enable_lighting) prepareShadowMap();

    bgfx::reset(window_size_x, window_size_y, bgfxInit.resolution.reset, bgfxInit.resolution.format);
}

#define FFNX_LOGO_PATH ".logo/logo_nobg.png"

void Renderer::prepareFFNxLogo()
{
    if (bgfx::isValid(FFNxLogoHandle))
        bgfx::destroy(FFNxLogoHandle);

    auto fs = cmrc::FFNx::get_filesystem();
    auto logo = fs.open(FFNX_LOGO_PATH);

    uint32_t width, height, mipCount = 0;
    FFNxLogoHandle = createTextureHandle(&logo, FFNX_LOGO_PATH, &width, &height, &mipCount, true);
    if (!FFNxLogoHandle.idx) FFNxLogoHandle = BGFX_INVALID_HANDLE;
}

void Renderer::prepareShadowMap()
{
    if (bgfx::isValid(shadowMapFrameBuffer))
        bgfx::destroy(shadowMapFrameBuffer);

    auto shadowMapResolution = lighting.getShadowMapResolution();
    shadowMapTexture = bgfx::createTexture2D(
        shadowMapResolution,
        shadowMapResolution,
        false,
        1,
        bgfx::TextureFormat::D32F,
        BGFX_TEXTURE_RT | BGFX_SAMPLER_COMPARE_LEQUAL | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP
    );

    shadowMapFrameBuffer = bgfx::createFrameBuffer(
        1,
        &shadowMapTexture,
        true
    );
}

void Renderer::prepareSpecularIbl(char* fullpath)
{
    if (bgfx::isValid(specularIblTexture))
        bgfx::destroy(specularIblTexture);

    uint32_t width, height, mipCount = 0;
    specularIblTexture = createTextureHandle(fullpath, &width, &height, &mipCount, false);
    if (!specularIblTexture.idx) specularIblTexture = BGFX_INVALID_HANDLE;
    lighting.setIblMipCount(mipCount);
}

void Renderer::prepareDiffuseIbl(char* fullpath)
{
    if (bgfx::isValid(diffuseIblTexture))
        bgfx::destroy(diffuseIblTexture);

    uint32_t width, height, mipCount = 0;
    diffuseIblTexture = createTextureHandle(fullpath, &width, &height, &mipCount, false);
    if (!diffuseIblTexture.idx) diffuseIblTexture = BGFX_INVALID_HANDLE;
}

void Renderer::prepareEnvBrdf()
{
    static char fullpath[MAX_PATH];

    if (bgfx::isValid(envBrdfTexture))
        bgfx::destroy(envBrdfTexture);

    sprintf(fullpath, "%s/%s/ibl/envBrdf.dds", basedir, external_lighting_path.c_str());

    uint32_t width, height, mipCount = 0;
    envBrdfTexture = createTextureHandle(fullpath, &width, &height, &mipCount, false);
    if (!envBrdfTexture.idx) envBrdfTexture = BGFX_INVALID_HANDLE;
}

void Renderer::prepareGamutLUTs()
{

	// flush everything (they should have all initialized to BGFX_INVALID_HANDLE, but let's be careful)
	if (bgfx::isValid(GLUTHandleNTSCJtoSRGB))
		bgfx::destroy(GLUTHandleNTSCJtoSRGB);
	if (bgfx::isValid(GLUTHandleSMPTECtoSRGB))
		bgfx::destroy(GLUTHandleSMPTECtoSRGB);
	if (bgfx::isValid(GLUTHandleEBUtoSRGB))
		bgfx::destroy(GLUTHandleEBUtoSRGB);
	if (bgfx::isValid(GLUTHandleInverseNTSCJtoSRGB))
		bgfx::destroy(GLUTHandleInverseNTSCJtoSRGB);
	if (bgfx::isValid(GLUTHandleInverseNTSCJtoSMPTEC))
		bgfx::destroy(GLUTHandleInverseNTSCJtoSMPTEC);
	if (bgfx::isValid(GLUTHandleInverseNTSCJtoEBU))
		bgfx::destroy(GLUTHandleInverseNTSCJtoEBU);
	if (bgfx::isValid(GLUTHandleSRGBtoNTSCJ))
		bgfx::destroy(GLUTHandleSRGBtoNTSCJ);
	if (bgfx::isValid(GLUTHandleSMPTECtoNTSCJ))
		bgfx::destroy(GLUTHandleSMPTECtoNTSCJ);
	if (bgfx::isValid(GLUTHandleEBUtoNTSCJ))
		bgfx::destroy(GLUTHandleEBUtoNTSCJ);

	// load only the LUTs we are likely to need
	// consult the global setting so we don't get tripped up by renderer state changing to accomodate the FFNx logo
	if (enable_ntscj_gamut_mode){
		if (internalState.bIsHDR){
			// Final NTSC-J to rec2020 conversion will be handled by matrix math in the shader (no gamut compression mapping needed)
			// We will probably have some sRGB videos that must go sRGB -> NTSC-J -> rec2020.
			// Use the compress-only (non "inverse") LUT because the final step for HDR won't invert expansions
			LoadGamutLUT(INDEX_LUT_SRGB_TO_NTSCJ);
		}
		// SDR
		else {
			// Final NTSC-J to sRGB conversion needs gamut compression mapping LUT
			LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB);
			// We will probably have some sRGB videos that must go sRGB -> NTSC-J -> sRGB.
			// Use expanding "inverse" LUT to counteract the compression in the final conversion.
			LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_SRGB);
		}
	}
	// Most FF7 movies will need NTSC-J to sRGB conversion for sRGB mode
	// (FF8 Steam edition movies were already converted)
	else if(!ff8){
		LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB);
	}

	// Any other LUTs we end up needing will be lazy loaded by AssignGamutLUT()

	return;
}

void Renderer::LoadGamutLUT(GamutLUTIndexType whichLUT)
{

	static char fullpath[MAX_PATH];
	uint32_t width = 0;
	uint32_t height = 0;
	uint32_t mipCount = 0;

	// Note: It's important that the final parameter to createTextureHandle() -- isSrgb -- is false.
	// Otherwise the sRGB gamma function will be applied to convert sRGB to linear RGB.
	// But we don't want that because these LUTs are already in linear RGB.

	switch (whichLUT){
		case INDEX_LUT_NTSCJ_TO_SRGB:
			if (!bgfx::isValid(GLUTHandleNTSCJtoSRGB)){
				sprintf(fullpath, "%s/shaders/glut_ntscj_to_srgb.png", basedir);
				GLUTHandleNTSCJtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleNTSCJtoSRGB.idx) GLUTHandleNTSCJtoSRGB = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_SMPTEC_TO_SRGB:
			if (!bgfx::isValid(GLUTHandleSMPTECtoSRGB)){
				sprintf(fullpath, "%s/shaders/glut_smptec_to_srgb.png", basedir);
				GLUTHandleSMPTECtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleSMPTECtoSRGB.idx) GLUTHandleSMPTECtoSRGB = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_EBU_TO_SRGB:
			if (!bgfx::isValid(GLUTHandleEBUtoSRGB)){
				sprintf(fullpath, "%s/shaders/glut_ebu_to_srgb.png", basedir);
				GLUTHandleEBUtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleEBUtoSRGB.idx) GLUTHandleEBUtoSRGB = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_INVERSE_NTSCJ_TO_SRGB:
			if (!bgfx::isValid(GLUTHandleInverseNTSCJtoSRGB)){
				sprintf(fullpath, "%s/shaders/glut_inverse_ntscj_to_srgb.png", basedir);
				GLUTHandleInverseNTSCJtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleInverseNTSCJtoSRGB.idx) GLUTHandleInverseNTSCJtoSRGB = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_INVERSE_NTSCJ_TO_SMPTEC:
			if (!bgfx::isValid(GLUTHandleInverseNTSCJtoSMPTEC)){
				sprintf(fullpath, "%s/shaders/glut_inverse_ntscj_to_smptec.png", basedir);
				GLUTHandleInverseNTSCJtoSMPTEC = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleInverseNTSCJtoSMPTEC.idx) GLUTHandleInverseNTSCJtoSMPTEC = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_INVERSE_NTSCJ_TO_EBU:
			if (!bgfx::isValid(GLUTHandleInverseNTSCJtoEBU)){
				sprintf(fullpath, "%s/shaders/glut_inverse_ntscj_to_ebu.png", basedir);
				GLUTHandleInverseNTSCJtoEBU = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleInverseNTSCJtoEBU.idx) GLUTHandleInverseNTSCJtoEBU = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_SRGB_TO_NTSCJ:
			if (!bgfx::isValid(GLUTHandleSRGBtoNTSCJ)){
				sprintf(fullpath, "%s/shaders/glut_srgb_to_ntscj.png", basedir);
				GLUTHandleSRGBtoNTSCJ = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleSRGBtoNTSCJ.idx) GLUTHandleSRGBtoNTSCJ = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_SMPTEC_TO_NTSCJ:
			if (!bgfx::isValid(GLUTHandleSMPTECtoNTSCJ)){
				sprintf(fullpath, "%s/shaders/glut_smptec_to_ntscj.png", basedir);
				GLUTHandleSMPTECtoNTSCJ = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleSMPTECtoNTSCJ.idx) GLUTHandleSMPTECtoNTSCJ = BGFX_INVALID_HANDLE;
			}
			break;
		case INDEX_LUT_EBU_TO_NTSCJ:
			if (!bgfx::isValid(GLUTHandleEBUtoNTSCJ)){
				sprintf(fullpath, "%s/shaders/glut_ebu_to_ntscj.png", basedir);
				GLUTHandleEBUtoNTSCJ = createTextureHandle(fullpath, &width, &height, &mipCount, false);
				if (!GLUTHandleEBUtoNTSCJ.idx) GLUTHandleEBUtoNTSCJ = BGFX_INVALID_HANDLE;
			}
			break;
		default:
			ffnx_error("LoadGamutLUT: called with invalid index: %i\n", whichLUT);
			break;
	}
	return;
}

void Renderer::shutdown()
{
    destroyAll();

    bgfx::shutdown();
}

void Renderer::clearShadowMap()
{
    bgfx::setViewClear(0, BGFX_CLEAR_DEPTH, internalState.clearColorValue, 1.0f, 0);
    bgfx::touch(0);
}

void Renderer::drawToShadowMap(bool uniformsAlreadyAttached, bool texturesAlreadyAttached)
{
    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s with backendProgram %d\n", __func__, backendProgram);

    // Lighting state
    auto lightingState = lighting.getLightingState();

    // Set view to render in the framebuffer
    bgfx::setViewFrameBuffer(0, shadowMapFrameBuffer);

    // Set current view rect
    int shadowMapResolution = lighting.getShadowMapResolution();
    bgfx::setViewRect(0, 0, 0, shadowMapResolution, shadowMapResolution);

    // Set current view transform
    bgfx::setViewTransform(0, lightingState.lightViewMatrix, lightingState.lightProjMatrix);

    // Set uniforms
    if(!uniformsAlreadyAttached)
    {
        setLightingUniforms();
        setCommonUniforms();
    }

    // Bind textures in pipeline
    if (!texturesAlreadyAttached)
    {
        bindTextures();
    }

    // Set state
    internalState.state = BGFX_STATE_DEPTH_TEST_LEQUAL | BGFX_STATE_WRITE_Z;

    // Face culling
    if (lighting.isShadowFaceCullingEnabled())
    {
        switch (internalState.cullMode)
        {
        case RendererCullMode::FRONT: internalState.state |= BGFX_STATE_CULL_CW;
        case RendererCullMode::BACK: internalState.state |= BGFX_STATE_CULL_CCW;
        }
    }
    bgfx::setState(internalState.state);

    bgfx::submit(0, backendProgramHandles[RendererProgram::SHADOW_MAP], 0, BGFX_DISCARD_NONE);
};

void Renderer::drawWithLighting(bool uniformsAlreadyAttached, bool texturesAlreadyAttached, bool keepBindings)
{
    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s with backendProgram %d\n", __func__, backendProgram);

    // Set lighting program
    backendProgram = backendProgram == SMOOTH ? LIGHTING_SMOOTH : LIGHTING_FLAT;

    // Re-Bind shadow map with comparison sampler
    bgfx::setTexture(RendererTextureSlot::TEX_S, bgfxTexUniformHandles[RendererTextureSlot::TEX_S], bgfx::getTexture(shadowMapFrameBuffer));

    // Bind specular IBL cubemap
    if (bgfx::isValid(specularIblTexture))
    {
        bgfx::setTexture(RendererTextureSlot::TEX_IBL_SPEC, bgfxTexUniformHandles[RendererTextureSlot::TEX_IBL_SPEC], specularIblTexture);
    }

    // Bind diffuse IBL cubemap
    if (bgfx::isValid(diffuseIblTexture))
    {
        bgfx::setTexture(RendererTextureSlot::TEX_IBL_DIFF, bgfxTexUniformHandles[RendererTextureSlot::TEX_IBL_DIFF], diffuseIblTexture);
    }

    // Bind environment BRDF texture
    if (bgfx::isValid(envBrdfTexture))
    {
        bgfx::setTexture(RendererTextureSlot::TEX_BRDF, bgfxTexUniformHandles[RendererTextureSlot::TEX_BRDF], envBrdfTexture, BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP);
    }

    // Draw with lighting
    draw(uniformsAlreadyAttached, texturesAlreadyAttached, keepBindings);
}

void Renderer::drawFieldShadow()
{
    backendProgram = RendererProgram::FIELD_SHADOW;

    // Re-Bind shadow map with comparison sampler
    bgfx::setTexture(RendererTextureSlot::TEX_S, bgfxTexUniformHandles[RendererTextureSlot::TEX_S], bgfx::getTexture(shadowMapFrameBuffer));

    // Re-Bind shadow map for direct depth sampling
    bgfx::setTexture(RendererTextureSlot::TEX_D, bgfxTexUniformHandles[RendererTextureSlot::TEX_D], bgfx::getTexture(shadowMapFrameBuffer), BGFX_TEXTURE_RT | BGFX_SAMPLER_POINT | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP);

    draw();
}

void Renderer::draw(bool uniformsAlreadyAttached, bool texturesAlreadyAttached, bool keepBindings)
{
    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s with backendProgram %d\n", __func__, backendProgram);

    // Set current view rect
    if (backendProgram == RendererProgram::POSTPROCESSING)
    {
        bgfx::setViewRect(backendViewId, 0, 0, window_size_x, window_size_y);

        // Set current view transform
        bgfx::setViewTransform(backendViewId, NULL, internalState.postprocessingProjMatrix);
    }
    else
    {
        // Set view to render in the framebuffer
        bgfx::setViewFrameBuffer(backendViewId, backendFrameBuffer);

        bgfx::setViewRect(backendViewId, 0, 0, framebufferWidth, framebufferHeight);

        if (internalState.bDoScissorTest) bgfx::setScissor(scissorOffsetX, scissorOffsetY, scissorWidth, scissorHeight);

        // Set current view transform
        bgfx::setViewTransform(backendViewId, NULL, internalState.backendProjMatrix);
    }

    // Skip uniform attachment as it has been done already
    if (!uniformsAlreadyAttached)
    {
        setCommonUniforms();
        setLightingUniforms();
    }

    // set up a gamut LUT if we need one
    AssignGamutLUT();

    // Bind textures in pipeline
    if (!texturesAlreadyAttached)
    {
        bindTextures();
    }

    // Set state
    {
        internalState.state = BGFX_STATE_LINEAA | BGFX_STATE_MSAA | BGFX_STATE_WRITE_RGB | BGFX_STATE_WRITE_A;

        switch (internalState.cullMode)
        {
        case RendererCullMode::FRONT: internalState.state |= BGFX_STATE_CULL_CW;
        case RendererCullMode::BACK: internalState.state |= BGFX_STATE_CULL_CCW;
        }

        switch (internalState.blendMode)
        {
        case RendererBlendMode::BLEND_AVG:
            internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
            internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA);
            break;
        case RendererBlendMode::BLEND_ADD:
            internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
            internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ONE);
            break;
        case RendererBlendMode::BLEND_SUB:
            internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_REVSUB);
            internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ONE);
            break;
        case RendererBlendMode::BLEND_25P:
            internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
            internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_ONE);
            break;
        case RendererBlendMode::BLEND_NONE:
            internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
            if (internalState.bIsExternalTexture && !ff8) internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA);
            else internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ZERO);
            break;
        }

        switch (internalState.primitiveType)
        {
        case RendererPrimitiveType::PT_LINES:
            internalState.state |= BGFX_STATE_PT_LINES;
            break;
        case RendererPrimitiveType::PT_POINTS:
            internalState.state |= BGFX_STATE_PT_POINTS;
            break;
        }

        if (internalState.bDoDepthTest) internalState.state |= BGFX_STATE_DEPTH_TEST_LEQUAL;

        if (internalState.bDoDepthWrite) internalState.state |= BGFX_STATE_WRITE_Z;
    }
    bgfx::setState(internalState.state);

    auto flags = keepBindings ? BGFX_DISCARD_STATE : BGFX_DISCARD_ALL;
    bgfx::submit(backendViewId, backendProgramHandles[backendProgram], 0, flags);

    internalState.bHasDrawBeenDone = true;
    internalState.bTexturesBound = false;
};

void Renderer::discardAllBindings()
{
    bgfx::discard(BGFX_DISCARD_ALL);
}

void Renderer::drawOverlay()
{
    if (enable_devtools)
        overlay.draw();
}

void Renderer::drawFFNxLogo(float fade)
{
    setClearFlags(true, false);

	/*  y0    y2
	 x0 +-----+ x2
		|    /|
		|   / |
		|  /  |
		| /   |
		|/    |
	 x1 +-----+ x3
		y1    y3
	*/

	// 0
	float x0 = 0.0f;
	float y0 = 0.0f;
	float u0 = 0.0f;
	float v0 = 0.0f;
	// 1
	float x1 = x0;
	float y1 = game_height;
	float u1 = u0;
	float v1 = 1.0f;
	// 2
	float x2 = game_width;
	float y2 = y0;
	float u2 = 1.0f;
	float v2 = v0;
	// 3
	float x3 = x2;
	float y3 = y1;
	float u3 = u2;
	float v3 = v1;

	struct nvertex vertices[] = {
		{x0, y0, 1.0f, 1.0f, 0xffffffff, 0, u0, v0},
		{x1, y1, 1.0f, 1.0f, 0xffffffff, 0, u1, v1},
		{x2, y2, 1.0f, 1.0f, 0xffffffff, 0, u2, v2},
		{x3, y3, 1.0f, 1.0f, 0xffffffff, 0, u3, v3},
	};

    for(int i = 0; i < 4; ++i)
    {
        vertices[i].color.a = 255 * fade;
    }

	WORD indices[] = {
		0, 1, 2,
		1, 3, 2
	};

    bindVertexBuffer(vertices, 0, 4);
	bindIndexBuffer(indices, 6);

    resetState();
    setOverallColorGamut(COLORGAMUT_SRGB); // always draw the logo in sRGB mode. The old setting is restored in drawFFNxLogo() in common.cpp
	setPrimitiveType();
	isTLVertex(true);
	setCullMode(RendererCullMode::DISABLED);
	setBlendMode(RendererBlendMode::BLEND_AVG);
    doTextureFiltering(true);
    isExternalTexture(true);
	isTexture(true);
	doDepthTest(false);
	doDepthWrite(false);
    doModulateAlpha(true);
    useTexture(FFNxLogoHandle.idx);

	draw();
}

void Renderer::show()
{
    // Reset internal state
    resetState();

    renderFrame();

    bgfx::update(
        vertexBufferHandle,
        0,
        bgfx::copy(
            vertexBufferData.data(),
            vectorSizeOf(vertexBufferData)
        )
    );

    bgfx::update(
        indexBufferHandle,
        0,
        bgfx::copy(
            indexBufferData.data(),
            vectorSizeOf(indexBufferData)
        )
    );

    bgfx::frame(doCaptureFrame);

    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s\n", __func__);

    bgfx::dbgTextClear();

    if(!ff8 && getmode_cached()->driver_mode == MODE_BATTLE) {
        for(int i = 0; i <= backendViewId; i++)
            bgfx::resetView(i);
    }

    backendViewId = 1;

    vertexBufferData.clear();
    vertexBufferData.shrink_to_fit();

    indexBufferData.clear();
    indexBufferData.shrink_to_fit();

    bgfx::setViewMode(backendViewId, bgfx::ViewMode::Sequential);
}

void Renderer::printText(uint16_t x, uint16_t y, uint32_t color, const char* text)
{
    bgfx::dbgTextPrintf(
        x,
        y,
        color,
        text
    );
}

void Renderer::toggleCaptureFrame()
{
    doCaptureFrame = !doCaptureFrame;
}

const bgfx::Caps* Renderer::getCaps()
{
    return bgfx::getCaps();
};

const bgfx::Stats* Renderer::getStats()
{
    return bgfx::getStats();
}

const bgfx::VertexLayout& Renderer::GetVertexLayout()
{
    return vertexLayout;
}

void Renderer::bindVertexBuffer(struct nvertex* inVertex, vector3<float>* normals, uint32_t inCount)
{
    if (!bgfx::isValid(vertexBufferHandle)) vertexBufferHandle = bgfx::createDynamicVertexBuffer(inCount, vertexLayout, BGFX_BUFFER_ALLOW_RESIZE);

    uint32_t currentOffset = vertexBufferData.size();

    for (uint32_t idx = 0; idx < inCount; idx++)
    {
        vertexBufferData.push_back(Vertex());

        vertexBufferData[currentOffset + idx].x = inVertex[idx]._.x;
        vertexBufferData[currentOffset + idx].y = inVertex[idx]._.y;
        vertexBufferData[currentOffset + idx].z = inVertex[idx]._.z;
        vertexBufferData[currentOffset + idx].w = ( ::isinf(inVertex[idx].color.w) ? 1.0f : inVertex[idx].color.w );
        vertexBufferData[currentOffset + idx].bgra = inVertex[idx].color.color;
        vertexBufferData[currentOffset + idx].u = inVertex[idx].u;
        vertexBufferData[currentOffset + idx].v = inVertex[idx].v;

        if (normals)
        {
            vertexBufferData[currentOffset + idx].nx = normals[idx].x;
            vertexBufferData[currentOffset + idx].ny = normals[idx].y;
            vertexBufferData[currentOffset + idx].nz = normals[idx].z;
        }

        if (vertex_log && idx == 0) ffnx_trace("%s: %u [XYZW(%f, %f, %f, %f), BGRA(%08x), UV(%f, %f)]\n", __func__, idx, vertexBufferData[currentOffset + idx].x, vertexBufferData[currentOffset + idx].y, vertexBufferData[currentOffset + idx].z, vertexBufferData[currentOffset + idx].w, vertexBufferData[currentOffset + idx].bgra, vertexBufferData[currentOffset + idx].u, vertexBufferData[currentOffset + idx].v);
        if (vertex_log && idx == 1) ffnx_trace("%s: See the rest on RenderDoc.\n", __func__);
    }

    bgfx::setVertexBuffer(0, vertexBufferHandle, currentOffset, inCount);
};

void Renderer::bindIndexBuffer(WORD* inIndex, uint32_t inCount)
{
    if (!bgfx::isValid(indexBufferHandle)) indexBufferHandle = bgfx::createDynamicIndexBuffer(inCount, BGFX_BUFFER_ALLOW_RESIZE);

    uint32_t currentOffset = indexBufferData.size();

    for (uint32_t idx = 0; idx < inCount; idx++)
    {
        indexBufferData.push_back(inIndex[idx]);
    }

    bgfx::setIndexBuffer(indexBufferHandle, currentOffset, inCount);
};

void Renderer::setScissor(uint16_t x, uint16_t y, uint16_t width, uint16_t height)
{
    scissorOffsetX = getInternalCoordX(x);
    scissorOffsetY = getInternalCoordY(y);
    scissorWidth = getInternalCoordX(width);
    scissorHeight = getInternalCoordY(height);

    // This removes the black bars on the top and bottom of the screen
    if (enable_uncrop)
    {
        bool is_movie_playing = *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag;
        if(!(is_movie_playing && widescreen.getMovieMode() == WM_DISABLED))
        {
            if(y == 16 && height == 448)
            {
                scissorOffsetY = getInternalCoordY(0.0);
                scissorHeight = getInternalCoordY(480);
            }
        }
    }

    if(!widescreen_enabled) return;

    struct game_mode* mode = getmode_cached();
    switch(mode->driver_mode)
    {
        case MODE_CREDITS:
            {
                // Keep the default scissor for credits mode
                scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
            }
            break;
        case MODE_FIELD:
            {
                // Keep the default scissor for widescreen disabled movies and fields
                bool isKeepDefaultScissor = false;
                if (!ff8)
                {
                     bool is_movie_playing = *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag;
                     isKeepDefaultScissor = (is_movie_playing && widescreen.getMovieMode() == WM_DISABLED) || widescreen.getMode() == WM_DISABLED;
                }

                if (isKeepDefaultScissor)
                {
                    scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
                    return;
                }

                // This changes the scissor width and makes it bigger to fit widescreen
                if(x == 0 && width == game_width)
                    scissorWidth = getInternalCoordX(wide_viewport_width);
                else
                    scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
            }
            break;
        case MODE_SWIRL:
            {
                // This changes the scissor width and makes it bigger to fit widescreen
                if(x == 0 && width == game_width)
                    scissorWidth = getInternalCoordX(wide_viewport_width);
                else
                    scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
            }
            break;
        case MODE_BATTLE:
            {
                if(x == 0 && width == game_width)
                    scissorWidth = getInternalCoordX(wide_viewport_width);
                else if(internalState.bIsTLVertex)
                    scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));

                if (ff8)
                {
                    // This removes the black bars on the top and bottom of the screen
                    if(y == 24 && height == 432)
                    {
                        scissorOffsetY = getInternalCoordY(0.0);
                        scissorHeight = getInternalCoordY(480);
                    }
                }
            }
            break;
        default:
            {
                // This changes the scissor width and makes it bigger to fit widescreen
                if(x == 0 && width == game_width)
                    scissorWidth = getInternalCoordX(wide_viewport_width);
                else
                    scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));

                if (ff8)
                {
                    // This removes the black bars on the top and bottom of the screen
                    if(y == 16 && height == 448)
                    {
                        scissorOffsetY = getInternalCoordY(0.0);
                        scissorHeight = getInternalCoordY(480);
                    }
                }
            }
            break;
    }
}

void Renderer::setClearFlags(bool doClearColor, bool doClearDepth)
{
    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s clearColor=%d,clearDepth=%d\n", __func__, doClearColor, doClearDepth);

    uint16_t clearFlags = BGFX_CLEAR_NONE;

    if (doClearColor)
        clearFlags |= BGFX_CLEAR_COLOR;

    if (doClearDepth)
        clearFlags |= BGFX_CLEAR_DEPTH;

    bgfx::setViewClear(backendViewId, clearFlags, internalState.clearColorValue, 1.0f);
    bgfx::touch(backendViewId);

    internalState.bHasDrawBeenDone = false;
}

void Renderer::setBackgroundColor(float r, float g, float b, float a)
{
    internalState.clearColorValue = createBGRA(r * 255, g * 255, b * 255, a * 255);
}

uint32_t Renderer::createTexture(uint8_t* data, size_t width, size_t height, int stride, RendererTextureType type, bool isSrgb, bool copyData)
{
    bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;

    bgfx::TextureFormat::Enum texFormat = bgfx::TextureFormat::R8;
    bimg::TextureFormat::Enum imgFormat = bimg::TextureFormat::R8;

    if (type == RendererTextureType::BGRA)
    {
        texFormat = bgfx::TextureFormat::BGRA8;
        imgFormat = bimg::TextureFormat::BGRA8;
    }

    bimg::TextureInfo texInfo;
    bimg::imageGetSize(&texInfo, width, height, 0, false, false, 1, imgFormat);

    // If the texture we are going to create does not fit in memory, return an empty one.
    // Will prevent the game from crashing, while allowing the player to not loose its progress.
    if (doesItFitInMemory(texInfo.storageSize) && (data != NULL))
    {
        const bgfx::Memory* mem;

        if (copyData)
        {
            mem = bgfx::alloc(texInfo.storageSize);
            // Protect from crashes
            if (mem != NULL) {
                bx::memCopy(mem->data, data, texInfo.storageSize);
            }
        }
        else
        {
            mem = bgfx::makeRef(data, texInfo.storageSize, RendererReleaseData, (void *)data);
        }

        uint64_t flags = BGFX_SAMPLER_NONE;

        if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
        else flags |= BGFX_TEXTURE_NONE;

        ret = bgfx::createTexture2D(
            width,
            height,
            false,
            1,
            texFormat,
            flags,
            stride > 0 ? NULL : mem
        );

        if (stride > 0)
            bgfx::updateTexture2D(
                ret,
                0,
                0,
                0,
                0,
                width,
                height,
                mem,
                stride
            );

        if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from data with stride %u\n", __func__, ret.idx, width, height, stride);
    }

    return ret.idx;
};

uint32_t Renderer::createTexture(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb)
{
    bgfx::TextureHandle handle = createTextureHandle(filename, width, height, mipCount, isSrgb);
    return handle.idx;
}

bimg::ImageContainer* Renderer::createImageContainer(const char* filename, bimg::TextureFormat::Enum targetFormat)
{
    return loadImageContainer(&defaultAllocator, filename, targetFormat);
}

bimg::ImageContainer* Renderer::createImageContainer(cmrc::file* file, bimg::TextureFormat::Enum targetFormat)
{
    bimg::ImageContainer* img = nullptr;

    if (file->size() > 0)
    {
        img = bimg::imageParse(&defaultAllocator, file->begin(), file->size(), targetFormat);
    }

    return img;
}

bgfx::TextureHandle Renderer::createTextureHandle(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb)
{
    bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;
    bimg::ImageContainer* img = createImageContainer(filename);

    if (img != nullptr)
    {
        if (gl_check_texture_dimensions(img->m_width, img->m_height, filename) && doesItFitInMemory(img->m_size))
        {
            uint64_t flags = BGFX_SAMPLER_NONE;

            if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
            else flags |= BGFX_TEXTURE_NONE;

            const bgfx::Memory* mem = bgfx::makeRef(img->m_data, img->m_size, RendererReleaseImageContainer, img);
            if (img->m_cubeMap)
            {
                ret = bgfx::createTextureCube(
                    img->m_width,
                    1 < img->m_numMips,
                    img->m_numLayers,
                    bgfx::TextureFormat::Enum(img->m_format),
                    flags,
                    mem
                );
            }
            else
            {

                ret = bgfx::createTexture2D(
                    img->m_width,
                    img->m_height,
                    1 < img->m_numMips,
                    img->m_numLayers,
                    bgfx::TextureFormat::Enum(img->m_format),
                    flags,
                    mem
                );
            }

            *width = img->m_width;
            *height = img->m_height;
            *mipCount = img->m_numMips;

            if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from filename %s\n", __func__, ret.idx, width, height, filename);
        }
    }

    return ret;
}

bgfx::TextureHandle Renderer::createTextureHandle(cmrc::file* file, char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb)
{
    bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;
    bimg::ImageContainer* img = createImageContainer(file);

    if (img != nullptr)
    {
        if (gl_check_texture_dimensions(img->m_width, img->m_height, filename) && doesItFitInMemory(img->m_size))
        {
            uint64_t flags = BGFX_SAMPLER_NONE;

            if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
            else flags |= BGFX_TEXTURE_NONE;

            const bgfx::Memory* mem = bgfx::makeRef(img->m_data, img->m_size, RendererReleaseImageContainer, img);
            if (img->m_cubeMap)
            {
                ret = bgfx::createTextureCube(
                    img->m_width,
                    1 < img->m_numMips,
                    img->m_numLayers,
                    bgfx::TextureFormat::Enum(img->m_format),
                    flags,
                    mem
                );
            }
            else
            {

                ret = bgfx::createTexture2D(
                    img->m_width,
                    img->m_height,
                    1 < img->m_numMips,
                    img->m_numLayers,
                    bgfx::TextureFormat::Enum(img->m_format),
                    flags,
                    mem
                );
            }

            *width = img->m_width;
            *height = img->m_height;
            *mipCount = img->m_numMips;

            if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from filename %s\n", __func__, ret.idx, width, height, filename);
        }
    }

    return ret;
}

uint32_t Renderer::createTextureLibPng(char* filename, uint32_t* width, uint32_t* height, bool isSrgb)
{
    bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;
    bimg::ImageMip mip;

    if (!loadPng(filename, mip)) {
        return ret.idx;
    }

    const bgfx::Memory* mem = bgfx::makeRef(mip.m_data, mip.m_size, RendererReleaseData, (void *)mip.m_data);

    uint64_t flags = BGFX_SAMPLER_NONE;

    if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
    else flags |= BGFX_TEXTURE_NONE;

    ret = bgfx::createTexture2D(
        mip.m_width,
        mip.m_height,
        false,
        1,
        bgfx::TextureFormat::Enum(mip.m_format),
        flags,
        mem
    );

    *width = mip.m_width;
    *height = mip.m_height;

    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from filename %s\n", __func__, ret.idx, *width, *height, filename);

    return ret.idx;
}

bool Renderer::saveTexture(const char* filename, uint32_t width, uint32_t height, const void* data)
{
    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %ux%u with filename %s\n", __func__, width, height, filename);

    if (bx::open(&defaultWriter, filename, false))
    {
        bimg::imageWritePng(
            &defaultWriter,
            width,
            height,
            width * 4,
            data,
            bimg::TextureFormat::BGRA8,
            false
        );

        bx::close(&defaultWriter);

        return true;
    }

    return false;
}

void Renderer::deleteTexture(uint16_t rt)
{
    if (rt > 0)
    {
        bgfx::TextureHandle handle = { rt };

        if (bgfx::isValid(handle)) {
            bgfx::destroy(handle);

            if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u Texture was valid and is now destroyed!\n", __func__, rt);
        }
    }
};

void Renderer::useTexture(uint16_t rt, uint32_t slot)
{
    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: [%u] => %u\n", __func__, slot, rt);

    if (rt > 0)
    {
        internalState.texHandlers[slot] = { rt };
        if (slot == RendererTextureSlot::TEX_Y) isTexture(true);
    }
    else
    {
        internalState.texHandlers[slot] = BGFX_INVALID_HANDLE;
        if (slot == RendererTextureSlot::TEX_Y) isTexture(false);
    }
};

uint32_t Renderer::createBlitTexture(uint32_t x, uint32_t y, uint32_t width, uint32_t height)
{
    uint16_t newX = getInternalCoordX(x);
    uint16_t newY = getInternalCoordY(y);
    uint16_t newWidth = getInternalCoordX(width);
    uint16_t newHeight = getInternalCoordY(height);

    bgfx::TextureHandle ret = bgfx::createTexture2D(newWidth, newHeight, false, 1, internalState.bIsHDR ? bgfx::TextureFormat::RGB10A2 : bgfx::TextureFormat::RGBA16, BGFX_TEXTURE_BLIT_DST);

    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => XY(%u,%u) WH(%u,%u)\n", __func__, ret.idx, newX, newY, newWidth, newHeight);

    return ret.idx;
}

void Renderer::blitTexture(uint16_t dest, uint32_t x, uint32_t y, uint32_t width, uint32_t height)
{
    uint16_t newX = getInternalCoordX(x);
    uint16_t newY = getInternalCoordY(y);
    uint16_t newWidth = getInternalCoordX(width);
    uint16_t newHeight = getInternalCoordY(height);

    uint16_t dstY = 0;

    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => XY(%u,%u) WH(%u,%u)\n", __func__, dest, newX, newY, newWidth, newHeight);

    if (getCaps()->originBottomLeft)
    {
        int _newY = framebufferHeight - (newY + newHeight);

        // If the new Y is a positive value, we can use it as it is
        if (_newY > 0)
        {
            newY = _newY;
            dstY = 0;
        }
        // Otherwise, it means we have to copy the whole source texture
        // but shift the result on the Y axis of the dest texture of the absolute negative difference
        else
        {
            newY = 0;
            dstY = ::abs(_newY);
        }
    }

    backendViewId++;

    bgfx::TextureHandle texHandle = { dest };
    bgfx::blit(backendViewId, texHandle, 0, dstY, bgfx::getTexture(backendFrameBuffer, 0), newX, newY, newWidth, newHeight);
    bgfx::touch(backendViewId);
    setClearFlags(false, false);

    backendViewId++;
    setClearFlags(false, false);
}

void Renderer::zoomBackendFrameBuffer(int x, int y, int width, int height)
{
    if(!internalState.bHasDrawBeenDone) return;

    bgfx::TextureHandle textureHandle = bgfx::createTexture2D(width, height, false, 1, internalState.bIsHDR ? bgfx::TextureFormat::RGB10A2 : bgfx::TextureFormat::RGBA16, BGFX_TEXTURE_BLIT_DST);

    backendViewId++;
    bgfx::setViewClear(backendViewId, BGFX_CLEAR_NONE, internalState.clearColorValue, 1.0f);
    bgfx::touch(backendViewId);
    bgfx::blit(backendViewId, textureHandle, 0, 0, bgfx::getTexture(backendFrameBuffer, 0), x, y, width, height);
    backendViewId++;
    bgfx::setViewClear(backendViewId, BGFX_CLEAR_NONE, internalState.clearColorValue, 1.0f);
    bgfx::touch(backendViewId);

    /*  y0    y2
     x0 +-----+ x2
        |    /|
        |   / |
        |  /  |
        | /   |
        |/    |
     x1 +-----+ x3
        y1    y3
    */

    // 0
    float x0 = wide_viewport_x;
    float y0 = wide_viewport_y;
    float u0 = 0.0f;
    float v0 = getCaps()->originBottomLeft ? 1.0f : 0.0f;
    // 1
    float x1 = x0;
    float y1 = wide_viewport_height;
    float u1 = u0;
    float v1 = getCaps()->originBottomLeft ? 0.0f : 1.0f;
    // 2
    float x2 = x0 + wide_viewport_width;
    float y2 = y0;
    float u2 = 1.0f;
    float v2 = v0;
    // 3
    float x3 = x2;
    float y3 = y1;
    float u3 = u2;
    float v3 = v1;

    struct nvertex vertices[] = {
        {x0, y0, 1.0f, 1.0f, 0xff000000, 0, u0, v0},
        {x1, y1, 1.0f, 1.0f, 0xff000000, 0, u1, v1},
        {x2, y2, 1.0f, 1.0f, 0xff000000, 0, u2, v2},
        {x3, y3, 1.0f, 1.0f, 0xff000000, 0, u3, v3},
    };
    WORD indices[] = {
        0, 1, 2,
        1, 3, 2
    };

    backendProgram = RendererProgram::BLIT;

    useTexture(textureHandle.idx);

    bindVertexBuffer(vertices, 0, 4);
    bindIndexBuffer(indices, 6);

    doDepthTest(false);
    setCullMode(RendererCullMode::DISABLED);
    setBlendMode(RendererBlendMode::BLEND_DISABLED);
    setPrimitiveType();

    draw();

    if (bgfx::isValid(textureHandle)) bgfx::destroy(textureHandle);
}

void Renderer::clearDepthBuffer()
{
    backendViewId++;
    bgfx::setViewMode(backendViewId, bgfx::ViewMode::Sequential);
    bgfx::setViewRect(backendViewId, 0, 0, framebufferWidth, framebufferHeight);
    bgfx::setViewFrameBuffer(backendViewId, backendFrameBuffer);
    bgfx::setViewClear(backendViewId, BGFX_CLEAR_DEPTH);
    bgfx::touch(backendViewId);

    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: Clearing depth\n", __func__, backendViewId);
}

void Renderer::isMovie(bool flag)
{
    internalState.bIsMovie = flag;
};

void Renderer::isTLVertex(bool flag)
{
    internalState.bIsTLVertex = flag;
};

void Renderer::setBlendMode(RendererBlendMode mode)
{
    internalState.blendMode = mode;
};

void Renderer::isTexture(bool flag)
{
    internalState.bIsTexture = flag;
};

void Renderer::isFBTexture(bool flag)
{
    internalState.bIsFBTexture = flag;
};

void Renderer::isFullRange(bool flag)
{
    internalState.bIsMovieFullRange = flag;
};

void Renderer::isYUV(bool flag)
{
    internalState.bIsMovieYUV = flag;
};

void Renderer::doModulateAlpha(bool flag)
{
    internalState.bModulateAlpha = flag;
};

void Renderer::doTextureFiltering(bool flag)
{
    internalState.bDoTextureFiltering = flag;
};

void Renderer::doMirrorTextureWrap(bool flag)
{
    internalState.bDoMirrorTextureWrap = flag;
}

void Renderer::isExternalTexture(bool flag)
{
    internalState.bIsExternalTexture = flag;
}

bool Renderer::isHDR()
{
    return internalState.bIsHDR;
}

void Renderer::setColorMatrix(ColorMatrixType cmtype){
    internalState.bIsMovieColorMatrix = cmtype;
}

void Renderer::setColorGamut(ColorGamutType cgtype){
    internalState.bIsMovieColorGamut = cgtype;
}

void Renderer::setOverallColorGamut(ColorGamutType cgtype){
    internalState.bIsOverallColorGamut = cgtype;
}

void Renderer::setGamutOverride(bool flag)
{
    internalState.bIsOverrideGamut = flag;
}

void Renderer::setGammaType(InverseGammaFunctionType gtype)
{
    internalState.bIsMovieGammaType = gtype;
};

void Renderer::setAlphaRef(RendererAlphaFunc func, float ref)
{
    internalState.alphaFunc = func;
    internalState.alphaRef = ref;
};

void Renderer::doAlphaTest(bool flag)
{
    internalState.bDoAlphaTest = flag;
};

void Renderer::setInterpolationQualifier(RendererInterpolationQualifier qualifier)
{
    switch (qualifier)
    {
    case RendererInterpolationQualifier::FLAT:
        backendProgram = RendererProgram::FLAT;
        if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: FLAT\n", __func__);
        break;
    case RendererInterpolationQualifier::SMOOTH:
        backendProgram = RendererProgram::SMOOTH;
        if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: SMOOTH\n", __func__);
        break;
    }
}

void Renderer::setPrimitiveType(RendererPrimitiveType type)
{
    if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u\n", __func__, type);

    internalState.primitiveType = type;
};

void Renderer::setCullMode(RendererCullMode mode)
{
    internalState.cullMode = mode;
}

void Renderer::doDepthTest(bool flag)
{
    internalState.bDoDepthTest = flag;
}

void Renderer::doDepthWrite(bool flag)
{
    internalState.bDoDepthWrite = flag;
}

void Renderer::doScissorTest(bool flag)
{
    internalState.bDoScissorTest = flag;
}

void Renderer::setWireframeMode(bool flag)
{
    if (flag) bgfx::setDebug(BGFX_DEBUG_WIREFRAME);
}

void Renderer::setViewMatrix(struct matrix* matrix)
{
    ::memcpy(internalState.viewMatrix, &matrix->m[0][0], sizeof(matrix->m));

    bx::mtxInverse(internalState.invViewMatrix, internalState.viewMatrix);

    internalState.isViewMatrixSet = true;

    if (uniform_log) printMatrix(__func__, internalState.viewMatrix);
}

float* Renderer::getViewMatrix()
{
    return internalState.viewMatrix;
}

float* Renderer::getInvViewMatrix()
{
    return internalState.invViewMatrix;
}

bool Renderer::isViewMatrixSet()
{
    return internalState.isViewMatrixSet;
}

void Renderer::resetViewMatrixFlag()
{
    internalState.isViewMatrixSet = false;
}

void Renderer::setWorldViewMatrix(struct matrix *matrix, bool calculateNormalMatrix)
{
    ::memcpy(internalState.worldViewMatrix, &matrix->m[0][0], sizeof(matrix->m));

    if (uniform_log) printMatrix(__func__, internalState.worldViewMatrix);

    if(calculateNormalMatrix)
    {
        struct matrix transpose;
        transpose_matrix(matrix, &transpose);
        struct matrix invTranspose;
        inverse_matrix(&transpose, &invTranspose);
        invTranspose._41 = 0.0;
        invTranspose._42 = 0.0;
        invTranspose._43 = 0.0;
        invTranspose._44 = 1.0;

        ::memcpy(internalState.normalMatrix, &invTranspose.m[0][0], sizeof(invTranspose.m));

        if (uniform_log) printMatrix(__func__, internalState.normalMatrix);
    }
}

float* Renderer::getWorldViewMatrix()
{
    return internalState.worldViewMatrix;
}

float* Renderer::getNormalMatrix()
{
    return internalState.normalMatrix;
}

void Renderer::setD3DViweport(struct matrix* matrix)
{
    ::memcpy(internalState.d3dViewMatrix, &matrix->m[0][0], sizeof(matrix->m));

    if (uniform_log) printMatrix(__func__, internalState.d3dViewMatrix);
};

void Renderer::setD3DProjection(struct matrix* matrix)
{
    ::memcpy(internalState.d3dProjectionMatrix, &matrix->m[0][0], sizeof(matrix->m));

    // Modify the projection matrix to prevent stretching
    if(widescreen_enabled)
    {
        float widescreenScale = round(float(game_width) / wide_viewport_width * 100) / 100.f;
        internalState.d3dProjectionMatrix[0] *= widescreenScale;
        internalState.d3dProjectionMatrix[8] *= widescreenScale;
    }

    // Modify the projection matrix to extend view distance
    if (enable_worldmap_external_mesh)
    {
        struct game_mode* mode = getmode_cached();
        if(mode->driver_mode == MODE_WORLDMAP)
        {
            const float f_offset = 0.0035f;
            const float n_offset = 0.0f;

            float a = internalState.d3dProjectionMatrix[10];
            float b = internalState.d3dProjectionMatrix[11];

            float f = b / (a + 1.0f) + f_offset;
            float n = b / (a - 1.0f) + n_offset;

            internalState.d3dProjectionMatrix[10] = -(f + n) / (f -n);
            internalState.d3dProjectionMatrix[11] = -(2*f*n) / (f - n);
        }
    }

    if (uniform_log) printMatrix(__func__, internalState.d3dProjectionMatrix);
};

uint16_t Renderer::getInternalCoordX(uint16_t inX)
{
    if(widescreen_enabled)
        return (inX * framebufferWidth) / (wide_viewport_width);
    else
        return (inX * framebufferWidth) / (game_width);
}

uint16_t Renderer::getInternalCoordY(uint16_t inY)
{
    return (inY * framebufferHeight) / game_height;
}

uint16_t Renderer::getScalingFactor()
{
    return scalingFactor;
}

void Renderer::setTimeColor(bx::Vec3 color)
{
    internalState.TimeColor[0] = color.x;
    internalState.TimeColor[1] = color.y;
    internalState.TimeColor[2] = color.z;
}

void Renderer::setTimeEnabled(bool flag)
{
    internalState.TimeData[0] = static_cast<float>(flag);
}

void Renderer::setTimeFilterEnabled(bool flag)
{
    internalState.TimeData[1] = static_cast<float>(flag);
}

bool Renderer::isTimeFilterEnabled()
{
    return static_cast<bool>(internalState.TimeData[1]);
}

void Renderer::setSphericalWorldRate(float value)
{
    internalState.sphericalWorldRate = value;
}

void Renderer::setFogEnabled(bool flag)
{
    internalState.bIsFogEnabled = flag;
}

bool Renderer::isFogEnabled()
{
    return internalState.bIsFogEnabled;
}

void Renderer::setGameLightData(light_data* lightdata)
{
    struct game_mode* mode = getmode_cached();

    bool useGameLighting = lightdata != nullptr;
    if (enable_worldmap_external_mesh && mode->driver_mode == MODE_WORLDMAP)
    {
        useGameLighting = false;
    }

    if (useGameLighting)
    {
        internalState.gameGlobalLightColor[0] = lightdata->global_light_color.r;
        internalState.gameGlobalLightColor[1] = lightdata->global_light_color.g;
        internalState.gameGlobalLightColor[2] = lightdata->global_light_color.b;
        internalState.gameGlobalLightColor[3] = enable_lighting ? 2.5f : 1.0f;

        internalState.gameLightColor1[0] = lightdata->light_color_1.r;
        internalState.gameLightColor1[1] = lightdata->light_color_1.g;
        internalState.gameLightColor1[2] = lightdata->light_color_1.b;
        internalState.gameLightColor1[3] = 1.0;

        internalState.gameLightColor2[0] = lightdata->light_color_2.r;
        internalState.gameLightColor2[1] = lightdata->light_color_2.g;
        internalState.gameLightColor2[2] = lightdata->light_color_2.b;
        internalState.gameLightColor2[3] = 1.0;

        internalState.gameLightColor3[0] = lightdata->light_color_3.r;
        internalState.gameLightColor3[1] = lightdata->light_color_3.g;
        internalState.gameLightColor3[2] = lightdata->light_color_3.b;
        internalState.gameLightColor3[3] = 1.0;

        if (mode->driver_mode == MODE_WORLDMAP)
        {
            internalState.gameLightDir1[0] = lightdata->light_dir_1.x;
            internalState.gameLightDir1[1] = lightdata->light_dir_1.z;
            internalState.gameLightDir1[2] = lightdata->light_dir_1.y;

            internalState.gameLightDir2[0] = lightdata->light_dir_2.x;
            internalState.gameLightDir2[1] = lightdata->light_dir_2.z;
            internalState.gameLightDir2[2] = lightdata->light_dir_2.y;

            internalState.gameLightDir3[0] = lightdata->light_dir_3.x;
            internalState.gameLightDir3[1] = lightdata->light_dir_3.z;
            internalState.gameLightDir3[2] = lightdata->light_dir_3.y;
        }
        else
        {
            internalState.gameLightDir1[0] = -lightdata->light_dir_1.x;
            internalState.gameLightDir1[1] = -lightdata->light_dir_1.y;
            internalState.gameLightDir1[2] = -lightdata->light_dir_1.z;

            internalState.gameLightDir2[0] = -lightdata->light_dir_2.x;
            internalState.gameLightDir2[1] = -lightdata->light_dir_2.y;
            internalState.gameLightDir2[2] = -lightdata->light_dir_2.z;

            internalState.gameLightDir3[0] = -lightdata->light_dir_3.x;
            internalState.gameLightDir3[1] = -lightdata->light_dir_3.y;
            internalState.gameLightDir3[2] = -lightdata->light_dir_3.z;
        }

        internalState.gameScriptedLightColor[0] = lightdata->scripted_light_color.r;
        internalState.gameScriptedLightColor[1] = lightdata->scripted_light_color.g;
        internalState.gameScriptedLightColor[2] = lightdata->scripted_light_color.b;
    }
    else
    {
        internalState.gameGlobalLightColor[0] = 1.0;
        internalState.gameGlobalLightColor[1] = 1.0;
        internalState.gameGlobalLightColor[2] = 1.0;
        internalState.gameGlobalLightColor[3] = 1;

        internalState.gameLightColor1[0] = 0;
        internalState.gameLightColor1[1] = 0;
        internalState.gameLightColor1[2] = 0;
        internalState.gameLightColor1[3] = 0;

        internalState.gameLightColor2[0] = 0;
        internalState.gameLightColor2[1] = 0;
        internalState.gameLightColor2[2] = 0;
        internalState.gameLightColor2[3] = 0;

        internalState.gameLightColor3[0] = 0;
        internalState.gameLightColor3[1] = 0;
        internalState.gameLightColor3[2] = 0;
        internalState.gameLightColor3[3] = 0;

        internalState.gameLightDir1[0] = 0;
        internalState.gameLightDir1[1] = 0;
        internalState.gameLightDir1[2] = 0;

        internalState.gameLightDir2[0] = 0;
        internalState.gameLightDir2[1] = 0;
        internalState.gameLightDir2[2] = 0;

        internalState.gameLightDir3[0] = 0;
        internalState.gameLightDir3[1] = 0;
        internalState.gameLightDir3[2] = 0;

        internalState.gameScriptedLightColor[0] = 1.0;
        internalState.gameScriptedLightColor[1] = 1.0;
        internalState.gameScriptedLightColor[2] = 1.0;
    }
}
````

## File: src/renderer.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include "common.h"
#include "overlay.h"

#include <cmrc/cmrc.hpp>
#include <vector>
#include <array>
#include <string>
#include <math.h>
#include <bx/math.h>
#include <bx/bx.h>
#include <bx/allocator.h>
#include <bx/file.h>
#include <bimg/bimg.h>
#include <bimg/decode.h>
#include <bimg/encode.h>
#include <bgfx/platform.h>
#include <bgfx/bgfx.h>

#define FFNX_RENDERER_INVALID_HANDLE { 0 }

enum RendererInterpolationQualifier {
    FLAT = 0,
    SMOOTH
};

enum RendererBlendMode {
    BLEND_AVG = 0,
    BLEND_ADD,
    BLEND_SUB,
    BLEND_25P,
    BLEND_NONE,
    BLEND_DISABLED = 999
};

enum RendererCullMode {
    DISABLED = 0,
    FRONT,
    BACK
};

enum RendererAlphaFunc {
    NEVER = 0,
    LESS,
    EQUAL,
    LEQUAL,
    GREATER,
    NOTEQUAL,
    GEQUAL,
    ALWAYS
};

enum RendererPrimitiveType
{
    PT_POINTS = 0,
    PT_LINES,
    PT_LINE_LOOP,
    PT_LINE_STRIP,
    PT_TRIANGLES,
    PT_TRIANGLE_STRIP,
    PT_TRIANGLE_FAN,
    PT_QUADS,
    PT_QUAD_STRIP
};

enum RendererTextureType
{
    BGRA = 0,
    YUV
};

enum RendererUniform
{
    VS_FLAGS = 0,
    FS_ALPHA_FLAGS,
    FS_MISC_FLAGS,
    FS_HDR_FLAGS,
    FS_TEX_FLAGS,
    FS_MOVIE_FLAGS,
    WM_FLAGS,
    TIME_COLOR,
    TIME_DATA,
    D3D_VIEWPORT,
    D3D_PROJECTION,
    WORLD_VIEW,
    NORMAL_MATRIX,
    VIEW_MATRIX,
    INV_VIEW_MATRIX,
    GAME_LIGHTING_FLAGS,
    GAME_GLOBAL_LIGHT_COLOR,
    GAME_LIGHT_COLOR1,
    GAME_LIGHT_COLOR2,
    GAME_LIGHT_COLOR3,
    GAME_LIGHT_DIR1,
    GAME_LIGHT_DIR2,
    GAME_LIGHT_DIR3,
    GAME_SCRIPTED_LIGHT_COLOR,

    LIGHTING_SETTINGS,
    LIGHT_DIR_DATA,
    LIGHT_DATA,
    AMBIENT_LIGHT_DATA,
    SHADOW_DATA,
    FIELD_SHADOW_DATA,
    MATERIAL_DATA,
    MATERIAL_SCALE_DATA,
    LIGHTING_DEBUG_DATA,
    IBL_DATA,
    LIGHT_VIEW_PROJ_MATRIX,
    LIGHT_VIEW_PROJ_TEX_MATRIX,
    LIGHT_INV_VIEW_PROJ_TEX_MATRIX,
    VIEW_OFFSET_MATRIX,
    INV_VIEW_OFFSET_MATRIX,

    COUNT,
};

enum ColorMatrixType{
    COLORMATRIX_BT601 = 0,
    COLORMATRIX_BT709 = 1,
    COLORMATRIX_BGR24 = 2
};

enum ColorGamutType{
    COLORGAMUT_SRGB = 0,
    COLORGAMUT_NTSCJ = 1,
    COLORGAMUT_SMPTEC = 2,
    COLORGAMUT_EBU = 3
};

enum InverseGammaFunctionType{
    GAMMAFUNCTION_SRGB = 0,
    GAMMAFUNCTION_TWO_PT_TWO = 1,
    GAMMAFUNCTION_SMPTE170M = 2,
    GAMMAFUNCTION_TOELESS_SRGB = 3,
    GAMMAFUNCTION_TWO_PT_EIGHT = 4
};

namespace RendererTextureSlot {
    enum RendererTextureSlot
    {
        TEX_Y = 0,
        TEX_U,
        TEX_V,
        TEX_S,
        TEX_D,
        TEX_NML,
        TEX_PBR,
        TEX_IBL_SPEC,
        TEX_IBL_DIFF,
        TEX_BRDF,
        TEX_G_LUT,
        COUNT
    };
};

enum GamutLUTIndexType{
	INDEX_LUT_NTSCJ_TO_SRGB,
	INDEX_LUT_SMPTEC_TO_SRGB,
	INDEX_LUT_EBU_TO_SRGB,
	INDEX_LUT_INVERSE_NTSCJ_TO_SRGB,
	INDEX_LUT_INVERSE_NTSCJ_TO_SMPTEC,
	INDEX_LUT_INVERSE_NTSCJ_TO_EBU,
	INDEX_LUT_SRGB_TO_NTSCJ,
	INDEX_LUT_SMPTEC_TO_NTSCJ,
	INDEX_LUT_EBU_TO_NTSCJ
};

static void RendererReleaseImageContainer(void* _ptr, void* _userData)
{
    BX_UNUSED(_ptr);
    bimg::ImageContainer* imageContainer = (bimg::ImageContainer*)_userData;
    bimg::imageFree(imageContainer);
}

static void RendererReleaseData(void* _ptr, void* _userData)
{
    BX_UNUSED(_ptr);
    driver_free(_userData);
}

struct RendererCallbacks : public bgfx::CallbackI {
    std::string cachePath = R"(shaders\cache)";

    virtual ~RendererCallbacks() {};
    virtual void fatal(const char* _filePath, uint16_t _line, bgfx::Fatal::Enum _code, const char* _str) override;
    virtual void traceVargs(const char* _filePath, uint16_t _line, const char* _format, va_list _argList) override;
    virtual void profilerBegin(const char* _name, uint32_t _abgr, const char* _filePath, uint16_t _line) override {};
    virtual void profilerBeginLiteral(const char* _name, uint32_t _abgr, const char* _filePath, uint16_t _line) override {};
    virtual void profilerEnd() override {};
    virtual uint32_t cacheReadSize(uint64_t _id) override;
    virtual bool cacheRead(uint64_t _id, void* _data, uint32_t _size) override;
    virtual void cacheWrite(uint64_t _id, const void* _data, uint32_t _size) override;
    virtual void screenShot(const char* _filePath, uint32_t _width, uint32_t _height, uint32_t _pitch, const void* _data, uint32_t _size, bool _yflip) override {};
    virtual void captureBegin(uint32_t _width, uint32_t _height, uint32_t _pitch, bgfx::TextureFormat::Enum _format, bool _yflip) override {};
    virtual void captureEnd() override {};
    virtual void captureFrame(const void* _data, uint32_t _size) override {};
};

// Vertex data structure
struct Vertex
{
    float x;
    float y;
    float z;
    float w;
    uint32_t bgra;
    float u;
    float v;
    float nx;
    float ny;
    float nz;
};

class Renderer {
private:
    friend class Lighting;

    // Current renderer view
    enum RendererProgram {
        FLAT = 0,
        SMOOTH,
        SHADOW_MAP,
        LIGHTING_FLAT,
        LIGHTING_SMOOTH,
        FIELD_SHADOW,
        POSTPROCESSING,
        OVERLAY,
        BLIT,
        COUNT
    };

    struct RendererState
    {
        std::vector<bgfx::TextureHandle> texHandlers;
        bool bTexturesBound = false;

        bool bHasDrawBeenDone = false;

        bool bDoAlphaTest = false;
        float alphaRef = 0.0f;
        RendererAlphaFunc alphaFunc;

        bool bDoDepthTest = false;
        bool bDoDepthWrite = false;
        bool bDoScissorTest = false;

        bool bIsTLVertex = false;
        bool bIsFBTexture = false;
        bool bIsTexture = false;
        bool bDoTextureFiltering = false;
        bool bDoMirrorTextureWrap = false;
        bool bModulateAlpha = false;
        bool bIsMovie = false;
        bool bIsMovieFullRange = false;
        bool bIsMovieYUV = false;
        bool bIsExternalTexture = false;
        bool bIsHDR = false;
        bool bIsFogEnabled = false;
        ColorMatrixType bIsMovieColorMatrix = COLORMATRIX_BT601;
        ColorGamutType bIsMovieColorGamut = COLORGAMUT_SRGB;
        ColorGamutType bIsOverallColorGamut = COLORGAMUT_SRGB;
        bool bIsOverrideGamut = false;
        InverseGammaFunctionType bIsMovieGammaType = GAMMAFUNCTION_SRGB;

        float backendProjMatrix[16];
        float postprocessingProjMatrix[16];

        std::vector<float> VSFlags;
        std::vector<float> FSAlphaFlags;
        std::vector<float> FSMiscFlags;
        std::vector<float> FSHDRFlags;
        std::vector<float> FSTexFlags;
        std::vector<float> WMFlags;
        std::vector<float> FSMovieFlags;

        std::array<float, 4> TimeColor;
        std::array<float, 4> TimeData;

        std::array<float, 4> gameLightingFlags;
        float gameGlobalLightColor[4] = { 0.0, 0.0, 0.0, 0.0 };
        float gameLightDir1[4] = { 0.0, 0.0, 0.0, 0.0 };
        float gameLightColor1[4] = { 0.0, 0.0, 0.0, 0.0 };
        float gameLightDir2[4] = { 0.0, 0.0, 0.0, 0.0 };
        float gameLightColor2[4] = { 0.0, 0.0, 0.0, 0.0 };
        float gameLightDir3[4] = { 0.0, 0.0, 0.0, 0.0 };
        float gameLightColor3[4] = { 0.0, 0.0, 0.0, 0.0 };
        float gameScriptedLightColor[4] = { 0.0, 0.0, 0.0, 0.0 };

        float d3dViewMatrix[16];
        float d3dProjectionMatrix[16];
        float viewMatrix[16];
        float invViewMatrix[16];
        float worldViewMatrix[16];
        float normalMatrix[16];

        float sphericalWorldRate = 0.0f;

        uint32_t clearColorValue;

        RendererCullMode cullMode = RendererCullMode::DISABLED;
        RendererBlendMode blendMode = RendererBlendMode::BLEND_NONE;
        RendererPrimitiveType primitiveType = RendererPrimitiveType::PT_TRIANGLES;

        uint64_t state = BGFX_STATE_MSAA;

        bool isViewMatrixSet = false;
    };

    std::string vertexPathFlat = "shaders/FFNx";
    std::string fragmentPathFlat = "shaders/FFNx";
    std::string vertexPathSmooth = "shaders/FFNx";
    std::string fragmentPathSmooth = "shaders/FFNx";
    std::string vertexPostPath = "shaders/FFNx.post";
    std::string fragmentPostPath = "shaders/FFNx.post";
    std::string vertexOverlayPath = "shaders/FFNx.overlay";
    std::string fragmentOverlayPath = "shaders/FFNx.overlay";
    std::string vertexLightingPathFlat = "shaders/FFNx.lighting";
    std::string fragmentLightingPathFlat = "shaders/FFNx.lighting";
    std::string vertexLightingPathSmooth = "shaders/FFNx.lighting";
    std::string fragmentLightingPathSmooth = "shaders/FFNx.lighting";
    std::string vertexShadowMapPath = "shaders/FFNx.shadowmap";
    std::string fragmentShadowMapPath = "shaders/FFNx.shadowmap";
    std::string vertexFieldShadowPath = "shaders/FFNx.field.shadow";
    std::string fragmentFieldShadowPath = "shaders/FFNx.field.shadow";
    std::string vertexBlitPath = "shaders/FFNx.blit";
    std::string fragmentBlitPath = "shaders/FFNx.blit";

    bgfx::ViewId backendViewId = 1;
    RendererProgram backendProgram = RendererProgram::SMOOTH;

    std::vector<bgfx::ProgramHandle> backendProgramHandles = std::vector<bgfx::ProgramHandle>(RendererProgram::COUNT, BGFX_INVALID_HANDLE);

    std::vector<bgfx::TextureHandle> backendFrameBufferRT = { BGFX_INVALID_HANDLE, BGFX_INVALID_HANDLE };
    bgfx::FrameBufferHandle backendFrameBuffer = BGFX_INVALID_HANDLE;

    bgfx::TextureHandle shadowMapTexture = BGFX_INVALID_HANDLE;
    bgfx::FrameBufferHandle shadowMapFrameBuffer = BGFX_INVALID_HANDLE;

    bgfx::TextureHandle specularIblTexture = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle diffuseIblTexture = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle envBrdfTexture = BGFX_INVALID_HANDLE;

    std::vector<Vertex> vertexBufferData;
    bgfx::DynamicVertexBufferHandle vertexBufferHandle = BGFX_INVALID_HANDLE;

    std::vector<WORD> indexBufferData;
    bgfx::DynamicIndexBufferHandle indexBufferHandle = BGFX_INVALID_HANDLE;

    bgfx::TextureHandle FFNxLogoHandle = BGFX_INVALID_HANDLE;

    bgfx::TextureHandle GLUTHandleNTSCJtoSRGB = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleSMPTECtoSRGB = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleEBUtoSRGB = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleInverseNTSCJtoSRGB = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleInverseNTSCJtoSMPTEC = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleInverseNTSCJtoEBU = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleSRGBtoNTSCJ = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleSMPTECtoNTSCJ = BGFX_INVALID_HANDLE;
    bgfx::TextureHandle GLUTHandleEBUtoNTSCJ = BGFX_INVALID_HANDLE;

    bgfx::VertexLayout vertexLayout;

    std::array<bgfx::UniformHandle, RendererUniform::COUNT> bgfxUniformHandles;
    std::array<bgfx::UniformHandle, RendererTextureSlot::COUNT> bgfxTexUniformHandles;

    RendererState internalState;

    uint16_t viewOffsetX = 0;
    uint16_t viewOffsetY = 0;
    uint16_t viewWidth = 0;
    uint16_t viewHeight = 0;

    uint16_t framebufferWidth = 0;
    uint16_t framebufferHeight = 0;

    uint16_t scissorOffsetX = 0;
    uint16_t scissorOffsetY = 0;
    uint16_t scissorWidth = 0;
    uint16_t scissorHeight = 0;

    uint16_t framebufferVertexOffsetX = 0;
    uint16_t framebufferVertexWidth = 0;

    uint16_t scalingFactor = 0;

    uint32_t createBGRA(uint8_t r, uint8_t g, uint8_t b, uint8_t a);
    bgfx::RendererType::Enum getUserChosenRenderer();
    void updateRendererShaderPaths();
    bgfx::ShaderHandle getShader(const char* filePath);

    bgfx::UniformHandle createUniform(std::string uniformName, bgfx::UniformType::Enum uniformType);

    void destroyUniforms();
    void destroyAll();

    void resetState();

    void renderFrame();

    void printMatrix(char* name, float* mat);

    void recalcInternals();
    void calcBackendProjMatrix();
    void prepareFramebuffer();

    void AssignGamutLUT();

    bx::DefaultAllocator defaultAllocator;
    bx::FileWriter defaultWriter;
    Overlay overlay;

    bool doCaptureFrame = false;

    bgfx::Init bgfxInit;

public:
    std::string currentRenderer;

    // ---

    void init();
    void reset();
    void prepareFFNxLogo();
    void prepareShadowMap();
    void prepareSpecularIbl(char* fullpath = nullptr);
    void prepareDiffuseIbl(char* fullpath = nullptr);
    void prepareEnvBrdf();
    void prepareGamutLUTs();
	void LoadGamutLUT(GamutLUTIndexType whichLUT);
    void shutdown();

    void clearShadowMap();
    void drawToShadowMap(bool uniformsAlreadyAttached = false, bool texturesAlreadyAttached = false);
    void drawWithLighting(bool uniformsAlreadyAttached = false, bool texturesAlreadyAttached = false, bool keepBindings = false);
    void drawFieldShadow();
    void draw(bool uniformsAlreadyAttached = false, bool texturesAlreadyAttached = false, bool keepBindings = false);
    void discardAllBindings();
    void drawOverlay();
    void drawFFNxLogo(float fade);
    void show();

    void printText(uint16_t x, uint16_t y, uint32_t attr, const char* text);
    void toggleCaptureFrame();

    // ---

    const bgfx::Caps* getCaps();
    const bgfx::Stats* getStats();
    const bgfx::VertexLayout& GetVertexLayout();

    void bindVertexBuffer(struct nvertex* inVertex, vector3<float>* normals, uint32_t inCount);
    void bindIndexBuffer(WORD* inIndex, uint32_t inCount);

    bgfx::UniformHandle setUniform(RendererUniform uniform, const void* uniformValue);
    void setCommonUniforms();
    void setLightingUniforms();
    void bindTextures();

    void setScissor(uint16_t x, uint16_t y, uint16_t width, uint16_t height);
    void setClearFlags(bool doClearColor = false, bool doClearDepth = false);
    void setBackgroundColor(float r = 0.0f, float g = 0.0f, float b = 0.0f, float a = 0.0f);

    uint32_t createTexture(uint8_t* data, size_t width, size_t height, int stride = 0, RendererTextureType type = RendererTextureType::BGRA, bool isSrgb = true, bool copyData = true);
    uint32_t createTexture(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb = true);
    bimg::ImageContainer* createImageContainer(const char* filename, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Enum::Count);
    bimg::ImageContainer* createImageContainer(cmrc::file* file, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Enum::Count);
    bgfx::TextureHandle createTextureHandle(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb = true);
    bgfx::TextureHandle createTextureHandle(cmrc::file* file, char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb = true);
    uint32_t createTextureLibPng(char* filename, uint32_t* width, uint32_t* height, bool isSrgb = true);
    bool saveTexture(const char* filename, uint32_t width, uint32_t height, const void* data);
    void deleteTexture(uint16_t texId);
    void useTexture(uint16_t texId, uint32_t slot = 0);
    uint32_t createBlitTexture(uint32_t x, uint32_t y, uint32_t width, uint32_t height);
    void blitTexture(uint16_t dest, uint32_t x, uint32_t y, uint32_t width, uint32_t height);
    void zoomBackendFrameBuffer(int x, int y, int width, int height);
    void clearDepthBuffer();

    void isMovie(bool flag = false);
    void isTLVertex(bool flag = false);
    void setBlendMode(RendererBlendMode mode = RendererBlendMode::BLEND_NONE);
    void isTexture(bool flag = false);
    void isFBTexture(bool flag = false);
    void isFullRange(bool flag = false);
    void isYUV(bool flag = false);
    void doModulateAlpha(bool flag = false);
    void doTextureFiltering(bool flag = false);
    void doMirrorTextureWrap(bool flag = false);
    void isExternalTexture(bool flag = false);
    bool isHDR();
    void setColorMatrix(ColorMatrixType cmtype = COLORMATRIX_BT601);
    void setColorGamut(ColorGamutType cgtype = COLORGAMUT_SRGB);
    void setOverallColorGamut(ColorGamutType cgtype = COLORGAMUT_SRGB);
    void setGammaType(InverseGammaFunctionType gtype = GAMMAFUNCTION_SRGB);
    void setGamutOverride(bool flag = false);

    // Alpha mode emulation
    void setAlphaRef(RendererAlphaFunc func = RendererAlphaFunc::ALWAYS, float ref = 0.0f);
    void doAlphaTest(bool flag = false);

    // Internal states
    void setInterpolationQualifier(RendererInterpolationQualifier qualifier = RendererInterpolationQualifier::SMOOTH);
    void setPrimitiveType(RendererPrimitiveType type = RendererPrimitiveType::PT_TRIANGLES);
    void setCullMode(RendererCullMode mode = RendererCullMode::DISABLED);
    void doDepthTest(bool flag = false);
    void doDepthWrite(bool flag = false);

    // Scissor test
    void doScissorTest(bool flag = false);

    // Wireframe mode
    void setWireframeMode(bool flag = false);

    // Viewport
    void setViewMatrix(struct matrix* matrix);
    float* getViewMatrix();
    float* getInvViewMatrix();
    bool isViewMatrixSet();
    void resetViewMatrixFlag();
    void setWorldViewMatrix(struct matrix* matrix, bool calculateNormalMatrix = true);
    float* getWorldViewMatrix();
    float* getNormalMatrix();
    void setD3DViweport(struct matrix* matrix);
    void setD3DProjection(struct matrix* matrix);

    // Internal coord calculation
    uint16_t getInternalCoordX(uint16_t inX);
    uint16_t getInternalCoordY(uint16_t inY);

    // Internal scaling factor
    uint16_t getScalingFactor();

    // Day-night time cycle
    void setTimeColor(bx::Vec3 color);
    void setTimeEnabled(bool flag = false);
    void setTimeFilterEnabled(bool flag = false);
    bool isTimeFilterEnabled();

    // Worldmap
    void setSphericalWorldRate(float value = 0.0f);
    void setFogEnabled(bool flag = false);
    bool isFogEnabled();

    // Game lighting
    void setGameLightData(light_data* lightdata = nullptr);

    static bool doesItFitInMemory(size_t size);
};

extern Renderer newRenderer;
````

## File: src/saveload.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <stdio.h>
#include <direct.h>
#include "renderer.h"

#include "log.h"
#include "gl.h"
#include "utils.h"

#include <xxhash.h>

// TEMPORARY! WILL BE REMOVED AFTER MIGRATION.
#include <iostream>
#include <fstream>
#include <filesystem>
// -------------------------------------------

std::map<uint16_t, std::string> additional_textures = {
	{RendererTextureSlot::TEX_NML, "nml"},
	{RendererTextureSlot::TEX_PBR, "pbr"}
};

void make_path(const char *name)
{
	const char *next = name;

	while((next = strchr(next, '/')))
	{
		char tmp[128];

		while(next[0] == '/') next++;

		strncpy(tmp, name, next - name);
		tmp[next - name] = 0;

		_mkdir(tmp);
	}
}

void normalize_path(char *name)
{
	if (ff8)
	{
		int idx = 0;
		while (name[idx] != 0)
		{
			if (name[idx] == '\\') name[idx] = '/';
			idx++;
		}
	}
}

void save_texture(const void *data, uint32_t dataSize, uint32_t width, uint32_t height, uint32_t palette_index, const char *name, bool is_animated)
{
	char filename[sizeof(basedir) + 1024];
	uint64_t hash;

	if (!save_textures && !save_textures_legacy) {
		ffnx_warning("Save texture skipped because the option \"save_textures\" is disabled (name=%s).\n", name);

		return;
	}

	if (is_animated)
	{
		char xxhash_filename[sizeof(basedir) + 1024];
		hash = XXH3_64bits(data, dataSize);
		_snprintf(xxhash_filename, sizeof(xxhash_filename), "%s/%s/%s_%02i_%llx.png", basedir, mod_path.c_str(), name, palette_index, hash);
	}
	else if (palette_index == uint32_t(-1))
	{
		_snprintf(filename, sizeof(filename), "%s/%s/%s.png", basedir, mod_path.c_str(), name);
	}
	else if (palette_index & 0x40000000)
	{
		_snprintf(filename, sizeof(filename), "%s/%s/%s_%u_%u.png", basedir, mod_path.c_str(), name, (palette_index & 0x7FFF), ((palette_index & 0x3FFFFFFF) >> 15) & 0x7FFF);
	}
	else
	{
		_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i.png", basedir, mod_path.c_str(), name, palette_index);
	}

	normalize_path(filename);

	make_path(filename);

	if (!fileExists(filename))
	{
		if (!newRenderer.saveTexture(filename, width, height, data)) ffnx_error("Save texture failed for the file [ %s ].\n", filename);
	}
	else
		ffnx_warning("Save texture skipped because the file [ %s ] already exists.\n", filename);
}

uint32_t load_texture_helper(char* name, uint32_t* width, uint32_t* height, bool useLibPng, bool isSrgb)
{
	uint32_t ret = 0;

	normalize_path(name);

	if (useLibPng)
		ret = newRenderer.createTextureLibPng(name, width, height, isSrgb);
	else
	{
		uint32_t mipCount = 0;
		ret = newRenderer.createTexture(name, width, height, &mipCount, isSrgb);
	}

	if (ret)
	{
		if (trace_all || trace_loaders) ffnx_trace("Using texture: %s\n", name);
	}

	return ret;
}

uint32_t load_normal_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set, std::string tex_path)
{
	uint32_t ret = 0;
	char filename[sizeof(basedir) + 1024]{ 0 };

	for (int idx = 0; idx < mod_ext.size(); idx++)
	{
		if (palette_index == uint32_t(-1))
		{
			_snprintf(filename, sizeof(filename), "%s/%s/%s.%s", basedir, tex_path.c_str(), name, mod_ext[idx].c_str());
		}
		else if (palette_index & 0x40000000)
		{
			_snprintf(filename, sizeof(filename), "%s/%s/%s_%u_%u.%s", basedir, tex_path.c_str(), name, (palette_index & 0x7FFF), ((palette_index & 0x3FFFFFFF) >> 15) & 0x7FFF, mod_ext[idx].c_str());
		}
		else
		{
			_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i.%s", basedir, tex_path.c_str(), name, palette_index, mod_ext[idx].c_str());
		}

		ret = load_texture_helper(filename, width, height, mod_ext[idx] == "png", true);

		if(ret)
		{
			if (trace_all) ffnx_trace("Created external texture: %u from %s\n", ret, filename);
			break;
		}
	}

	if(!ret)
	{
		if(palette_index != uint32_t(-1) && (palette_index & 0x3FFFFFFF) != 0)
		{
			if(trace_all || show_missing_textures) ffnx_info("No external texture found [%s], falling back to palette 0\n", filename);
			if(gl_set->default_texture_id)
			{
				return gl_set->default_texture_id;
			}
			else
			{
				gl_set->default_texture_id = load_normal_texture(data, dataSize, name, (palette_index & 0xC0000000) == 0xC0000000 ? -1 : (palette_index & 0x40000000), width, height, gl_set, tex_path);

				return gl_set->default_texture_id;
			}
		}
		else
		{
			if(trace_all || show_missing_textures) ffnx_info("No external texture found [%s], switching back to the internal one.\n", filename);
			return 0;
		}
	}
	else
	{
		// Load additional textures
		for (const auto& it : additional_textures)
		{
			for (int idx = 0; idx < mod_ext.size(); idx++)
			{
				if (palette_index == uint32_t(-1))
				{
					_snprintf(filename, sizeof(filename), "%s/%s/%s_%s.%s", basedir, tex_path.c_str(), name, it.second.c_str(), mod_ext[idx].c_str());
				}
				else if (palette_index & 0x40000000)
				{
					_snprintf(filename, sizeof(filename), "%s/%s/%s_%u_%u_%s.%s", basedir, tex_path.c_str(), name, (palette_index & 0x7FFF), ((palette_index & 0x3FFFFFFF) >> 15) & 0x7FFF, it.second.c_str(), mod_ext[idx].c_str());
				}
				else
				{
					_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i_%s.%s", basedir, tex_path.c_str(), name, palette_index, it.second.c_str(), mod_ext[idx].c_str());
				}

				if (fileExists(filename))
				{
					if (gl_set->additional_textures.count(it.first)) newRenderer.deleteTexture(gl_set->additional_textures[it.first]);
					gl_set->additional_textures[it.first] = load_texture_helper(filename, width, height, mod_ext[idx] == "png", false);
					break;
				}
				else if (trace_all || show_missing_textures)
				{
					ffnx_trace("Could not find [ %s ].\n", filename);
				}
			}
		}
	}

	return ret;
}

uint32_t load_animated_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set, std::string tex_path)
{
	uint32_t ret = 0;
	char filename[sizeof(basedir) + 1024]{ 0 };
	uint64_t hash = XXH3_64bits(data, dataSize);
	char texture_key[1024] { 0 };
	_snprintf(texture_key, sizeof(texture_key), "%s_%02i_%llx", name, palette_index, hash);

	// If texture has been cached, return immediately its handler
	if (gl_set->animated_textures.contains(texture_key))
	{
		return gl_set->animated_textures[texture_key];
	}

	// Check for animated texture with hash
	for (int idx = 0; idx < mod_ext.size(); idx++)
	{
		_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i_%llx.%s", basedir, tex_path.c_str(), name, palette_index, hash, mod_ext[idx].c_str());

		ret = load_texture_helper(filename, width, height, mod_ext[idx] == "png", true);

		if(ret)
		{
			if(trace_all) ffnx_trace("Created animated external texture: %u from %s\n", ret, filename);
			gl_set->animated_textures[texture_key] = ret;
			return ret;
		}

		if (trace_all || show_missing_textures) ffnx_trace("Could not find animated texture [ %s ].\n", filename);
	}

	// If animated texture not found, check for base texture
	for (int idx = 0; idx < mod_ext.size(); idx++)
	{
		_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i.%s", basedir, tex_path.c_str(), name, palette_index, mod_ext[idx].c_str());

		ret = load_texture_helper(filename, width, height, mod_ext[idx] == "png", true);

		if(ret)
		{
			if(trace_all) ffnx_trace("Created external texture: %u from %s\n", ret, filename);
			gl_set->animated_textures[texture_key] = ret;
			return ret;
		}

		if (trace_all || show_missing_textures) ffnx_trace("Could not find base texture [ %s ].\n", filename);
	}

	// Finally, if everything fails, return the one with palette index 0 or no texture
	if(palette_index != 0)
	{
		if(trace_all || show_missing_textures) ffnx_info("No external texture found, falling back to palette 0\n");
		if(gl_set->default_texture_id)
		{
			ret = gl_set->default_texture_id;
		}
		else
		{
			ret = load_animated_texture(data, dataSize, name, 0, width, height, gl_set, tex_path);
			gl_set->default_texture_id = ret;
		}
		if(ret) gl_set->animated_textures[texture_key] = ret;
		return ret;
	}
	else
	{
		if(tex_path == mod_path) // Are we on the last lookup layer?
		{
			if(trace_all || show_missing_textures) ffnx_info("No external texture found, switching back to the internal one.\n");
			gl_set->animated_textures[texture_key] = 0; // short circuit and prevent further lookups
		}
		else if(trace_all || show_missing_textures) ffnx_info("No external texture found.\n");

		return 0;
	}

}

uint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)
{
	uint32_t ret = 0;

	if(gl_set->is_animated)
	{
		if (!override_mod_path.empty())
			ret = load_animated_texture(data, dataSize, name, palette_index, width, height, gl_set, override_mod_path);

		if (ret == 0)
			ret = load_animated_texture(data, dataSize, name, palette_index, width, height, gl_set, mod_path);
	}
	else
	{
		if (!override_mod_path.empty())
			ret = load_normal_texture(data, dataSize, name, palette_index, width, height, gl_set, override_mod_path);

		if (ret == 0)
			ret = load_normal_texture(data, dataSize, name, palette_index, width, height, gl_set, mod_path);
	}

	return ret;
}
````

## File: src/saveload.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>

void make_path(const char *name);
void normalize_path(char *name);
void save_texture(const void *data, uint32_t dataSize, uint32_t width, uint32_t height, uint32_t palette_index, const char *name, bool is_animated);
uint32_t load_texture(const void *data, uint32_t dataSize, const char *name, uint32_t palette_index, uint32_t *width, uint32_t *height, struct gl_texture_set* gl_set);
````

## File: src/sfx.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "audio.h"
#include "patch.h"
#include "ff7.h"

#include "sfx.h"

uint32_t sfx_volumes[5];
ff7_field_sfx_state sfx_buffers[4];
uint32_t real_volume;
ff7_field_sfx_state* sfx_state = nullptr;
ff7_channel_6_state sfx_channel_6_state;

constexpr auto FF8_MAX_CHANNEL_NUMBER = 0x1F;

//=============================================================================

void ff7_sfx_release(IDirectSoundBuffer *buffer)
{
	if (buffer) buffer->Release();
}

bool ff7_should_sfx_loop(int id)
{
	return ff7_externals.sfx_fmt_header[id-1].loop;
}

void ff7_sfx_stop_channel(int channel, double time = 0)
{
	nxAudioEngine.stopSFX(channel, time);

	sfx_state[channel-1].pan1 = 64;
	sfx_state[channel-1].sound_id = 0;
	sfx_state[channel-1].is_looped = false;
}

void ff8_sfx_stop_channel(int channel, double time = 0)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);

	if (channel <= FF8_MAX_CHANNEL_NUMBER)
	{
		nxAudioEngine.stopSFX(channel, time);
	}
}

int ff7_sfx_load(int id, DWORD dsound_flag)
{
	//if (trace_all || trace_sfx) ffnx_trace("%s: id=%d\n", __func__, id);

	return true;
}

unsigned int ff8_sfx_load(unsigned int channel, unsigned int id, int is_eax)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d id=%d is_eax=%d\n", __func__, channel, id, is_eax);

	return true;
}

void ff7_sfx_unload(int id, void* unk)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: id=%d\n", __func__, id);

	nxAudioEngine.unloadSFX(id);
}

void ff8_sfx_unload(int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);

	nxAudioEngine.unloadSFX(nxAudioEngine.getSFXIdFromChannel(channel));
}

void ff8_sfx_set_master_volume(uint32_t volume)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%d\n", __func__, volume);

	if (volume <= 100) {
		*common_externals.master_sfx_volume = volume;
		nxAudioEngine.setSFXMasterVolume(volume / 100.0);
	}
}

void ff7_sfx_set_volume_on_channel(byte volume, int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%d,channel=%d\n", __func__, volume, channel);

	sfx_state[channel].volume1 = volume;

	nxAudioEngine.setSFXVolume(channel, volume / 127.0f);
}

void ff8_sfx_set_volume(uint32_t channel, uint32_t volume, int32_t time)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d, volume=%d, time=%d\n", __func__, channel, volume, time);

	if (volume == 0)
		ff8_sfx_stop_channel(channel, time / 60.0f);
	else if (channel <= FF8_MAX_CHANNEL_NUMBER && volume <= 127)
		nxAudioEngine.setSFXVolume(channel, volume / 127.0f, time / 60.0f);
}

void ff7_sfx_set_volume_trans_on_channel(byte volume, int channel, int time)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%d,channel=%d,time=%d\n", __func__, volume, channel, time);

	if (volume == 0)
		ff7_sfx_stop_channel(channel, time / 60.0f);
	else
		nxAudioEngine.setSFXVolume(channel, volume / 127.0f, time / 60.0f);
}

void ff7_sfx_set_panning_on_channel(byte panning, int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: panning=%d,channel=%d\n", __func__, panning, channel);

	sfx_state[channel].pan1 = panning;

	if (panning <= 127)
		nxAudioEngine.setSFXPanning(channel, panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f);
}

void ff8_sfx_set_panning(uint32_t channel, uint32_t panning, int32_t time)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d, panning=%d, time=%d\n", __func__, channel, panning, time);

	if (channel <= FF8_MAX_CHANNEL_NUMBER && panning <= 127)
	{
		// TODO: inverted panning option ((Reg.SoundOptions >> 20) & 1)
		nxAudioEngine.setSFXPanning(channel, panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f);
		// TODO: 3D sfx
	}
}

void ff7_sfx_set_panning_trans_on_channel(byte panning, int channel, int time)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: panning=%d,channel=%d,time=%d\n", __func__, panning, channel, time);

	if (panning <= 127)
		nxAudioEngine.setSFXPanning(channel, panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f, time / 60.0f);
}

void ff7_sfx_set_frequency_on_channel(byte speed, int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: speed=%d,channel=%d\n", __func__, speed, channel);

	sfx_state[channel].frequency = speed;

	if (speed == -128) {
		speed = -127; // Prevent speed to be 0 (can crash with SoLoud)
	}

	nxAudioEngine.setSFXSpeed(channel, float(speed) / 128.0f + 1.0f);
}

void ff7_sfx_set_frequency_trans_on_channel(byte speed, int channel, int time)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: speed=%d,channel=%d,time=%d\n", __func__, speed, channel, time);

	if (speed == -128) {
		speed = -127; // Prevent speed to be 0 (can crash with SoLoud)
	}

	nxAudioEngine.setSFXSpeed(channel, float(speed) / 128.0f + 1.0f, time / 60.0f);
}

bool ff7_sfx_play_layered(float panning, int id, int channel)
{
	const struct game_mode* mode = getmode_cached();
	bool playing = false;
	char track_name[64];
	byte actor_id = 0xFF;

	switch(mode->driver_mode)
	{
	case MODE_FIELD:
		sprintf(track_name, "%s_%d_%d", get_current_field_name(), *common_externals.current_triangle_id, id);
		break;
	case MODE_MENU:
	case MODE_MAIN_MENU:
		sprintf(track_name, "menu_%d", id);
		break;
	case MODE_WORLDMAP:
		sprintf(track_name, "world_%d", id);
		break;
	case MODE_BATTLE:
		actor_id = ff7_externals.anim_event_queue[0].attackerID;
		if(actor_id >= 0 && actor_id <= 2)
			sprintf(track_name, "battle_char_%02X_%d", ff7_externals.battle_context->actor_vars[actor_id].index, id);
		else if(actor_id >= 4 && actor_id <= 9)
			sprintf(track_name, "battle_enemy_%04X_%d", ff7_externals.battle_context->actor_vars[actor_id].formationID, id);
		else
			sprintf(track_name, "%d", id);
		break;
	default:
		sprintf(track_name, "%d", id);
	}

	// If any overridden layer could not be played, fallback to default
	if (!(playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id))))
	{
		if (mode->driver_mode == MODE_FIELD)
		{
			sprintf(track_name, "%s_%d", get_current_field_name(), id);
			if (!(playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id))))
			{
				sprintf(track_name, "%d", id);
				playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id));
			}
		}
		else
		{
			sprintf(track_name, "%d", id);
			playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id));
		}
	}

	return playing;
}

bool ff8_sfx_play_layered(int channel, int id, int volume, float panning)
{
	const struct game_mode* mode = getmode_cached();
	bool playing = false;
	char track_name[64];
	float panningf = panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f;
	float volumef = volume / 127.0f;
	bool loop = false;

	// Get loop info from audio.fmt
	if (id <= *ff8_externals.sfx_sound_count) {
		loop = (*ff8_externals.sfx_audio_fmt)[id].loop;
	}

	// TODO: inverted panning option ((Reg.SoundOptions >> 20) & 1)

	switch(mode->driver_mode)
	{
	case MODE_FIELD:
		sprintf(track_name, "%s_%d_%d", get_current_field_name(), *common_externals.current_triangle_id, id);
		playing = nxAudioEngine.playSFX(track_name, id, channel, panningf, loop, volumef);
		if (!playing) sprintf(track_name, "%s_%d", get_current_field_name(), id);
		break;
	case MODE_MENU:
	case MODE_MAIN_MENU:
		sprintf(track_name, "menu_%d", id);
		break;
	case MODE_WORLDMAP:
		sprintf(track_name, "world_%d", id);
		break;
	case MODE_BATTLE:
		sprintf(track_name, "battle_%d", id);
		break;
	default:
		sprintf(track_name, "%d", id);
	}

	// If any overridden layer could not be played, fallback to default
	if (!(playing = nxAudioEngine.playSFX(track_name, id, channel, panningf, loop, volumef)))
	{
		sprintf(track_name, "%d", id);
		playing = nxAudioEngine.playSFX(track_name, id, channel, panningf, loop, volumef);
	}

	return playing;
}

void ff7_sfx_play_on_channel(byte panning, int id, int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: id=%d,channel=%d,panning=%d\n", __func__, id, channel, panning);

	ff7_field_sfx_state *currentState = &sfx_state[channel-1];

	if (id)
	{
		for (int chdx = 1; chdx <= 5; chdx++)
		{
			if(sfx_state[chdx-1].sound_id == id && sfx_state[chdx-1].is_looped && chdx != channel)
			{
				ff7_sfx_stop_channel(chdx);
				return;
			}
		}

		if (channel <= 5 && ((currentState->sound_id == id && !currentState->is_looped) || (currentState->sound_id != id))) ff7_sfx_stop_channel(channel);

		if (currentState->sound_id != id) currentState->is_looped = false;

		if (!currentState->is_looped)
		{
			ff7_sfx_play_layered(panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f, id, channel);
		}

		currentState->pan1 = panning;
		currentState->sound_id = id;
		currentState->is_looped = ff7_should_sfx_loop(id);
	}
	else if ( channel < 6) // normally all sounds that are non-channel aware must never be stopped by the engine
	{
		ff7_sfx_stop_channel(channel);
	}
}

int ff8_sfx_play_channel(unsigned int channel, unsigned int id, unsigned int volume, unsigned int panning, int pitch)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d, id=%d, volume=%d, panning=%d, pitch=%d\n", __func__, channel, id, volume, panning, pitch);

	if (channel > FF8_MAX_CHANNEL_NUMBER || volume > 127 || panning > 127)
	{
		return 0;
	}

	// pitch is always 100
	return ff8_sfx_play_layered(channel, id, volume, panning);
}

void ff7_sfx_play_on_channel_5(int id)
{
	ff7_sfx_play_on_channel(64, id, 5);
}

void ff7_sfx_load_and_play_with_speed(int id, byte panning, byte volume, byte speed)
{
	const int _channel = 6;

	if (trace_all || trace_sfx) ffnx_trace("%s: id=%d,volume=%d,panning=%d,speed=%d\n", __func__, id, volume, panning, speed);

	if (id)
	{
		ff7_sfx_set_volume_on_channel(volume, _channel);
		ff7_sfx_set_frequency_on_channel(speed, _channel);
		ff7_sfx_play_on_channel(panning, id, _channel);
	}
}

bool ff8_sfx_is_playing(int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);

	return channel <= FF8_MAX_CHANNEL_NUMBER ? nxAudioEngine.isSFXPlaying(channel) : false;
}

void ff7_sfx_pause()
{
	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);

	for (short channel = 1; channel <= 6; channel++) nxAudioEngine.pauseSFX(channel);
}

void ff8_sfx_pause_channel(int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);

	if (channel <= FF8_MAX_CHANNEL_NUMBER)
	{
		nxAudioEngine.pauseSFX(channel);
	}
}

void ff7_sfx_resume()
{
	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);

	for (short channel = 1; channel <= 6; channel++) nxAudioEngine.resumeSFX(channel);
}

void ff8_sfx_resume_channel(int channel)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);

	if (channel <= FF8_MAX_CHANNEL_NUMBER)
	{
		nxAudioEngine.resumeSFX(channel);
	}
}

void ff7_sfx_stop()
{
	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);

	for (short channel = 1; channel <= 6; channel++)
		ff7_sfx_stop_channel(channel);

	*ff7_externals.sfx_play_effects_id_channel_6 = 0;
}

// Channel 6 only

void ff7_sfx_set_frequency_on_channel_6(void* dsoundptr, DWORD frequency)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: frequency=%lu\n", __func__, frequency);

	// TODO: IMPLEMENT PITCH?
}

void ff7_sfx_set_panning_on_channel_6(void* dsoundptr, LONG panning)
{
	sfx_channel_6_state.panning = (panning / 10000.0f);

	if (trace_all || trace_sfx) ffnx_trace("%s: panning=%ld,calculated=%f\n", __func__, panning, sfx_channel_6_state.panning);
}

void ff7_sfx_set_volume_on_channel_6(void* dsoundptr, LONG volume)
{
	sfx_channel_6_state.volume = (volume / 10000.0f) + 1.0f;

	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%ld,calculated=%f\n", __func__, volume, sfx_channel_6_state.volume);
}

void ff7_sfx_play_on_channel_6(void* dsoundptr, int unk)
{
	if (trace_all || trace_sfx) ffnx_trace("%s: id=%lu,panning=%f\n", __func__, *ff7_externals.sfx_play_effects_id_channel_6, sfx_channel_6_state.panning);

	nxAudioEngine.setSFXVolume(6, sfx_channel_6_state.volume);
	ff7_sfx_play_layered(sfx_channel_6_state.panning, *ff7_externals.sfx_play_effects_id_channel_6, 6);
}

void ff7_sfx_stop_channel_6()
{
	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);

	nxAudioEngine.stopSFX(6);

	if (*ff7_externals.sfx_stop_channel_timer_handle) timeKillEvent(*ff7_externals.sfx_stop_channel_timer_handle);

	*ff7_externals.sfx_stop_channel_timer_handle = 0;
}

//=============================================================================

bool sfx_buffer_is_looped(IDirectSoundBuffer* buffer)
{
	if (buffer == nullptr) {
		return false;
	}

	DWORD status;
	buffer->GetStatus(&status);

	if (status & (DSBSTATUS_LOOPING | DSBSTATUS_PLAYING)) {
		return true;
	}

	return false;
}

uint32_t sfx_operation_battle_swirl_stop_sound(uint32_t type, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4, uint32_t param5)
{
	if (trace_all || trace_sfx) ffnx_info("%s: Battle swirl stop sound\n", __func__);

	for (int i = 0; i < 4; ++i) {
		sfx_buffers[i] = ff7_field_sfx_state();
		sfx_buffers[i].buffer1 = nullptr;
		sfx_buffers[i].buffer2 = nullptr;

		if (use_external_sfx)
		{
			// Check which SFX effects are still playing on channels before saving their state. If not, avoid playing them back.
			if (!nxAudioEngine.isSFXPlaying(i+1)) sfx_state[i].sound_id = 0;
		}

		// Save sfx state for looped sounds in channel 1 -> 4 (not channel 5)
		if (sfx_buffer_is_looped(sfx_state[i].buffer1) || sfx_buffer_is_looped(sfx_state[i].buffer2) || use_external_sfx) {
			memcpy(&sfx_buffers[i], &sfx_state[i], sizeof(ff7_field_sfx_state));
		}
	}

	return ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(type, param1, param2, param3, param4, param5);
}

uint32_t sfx_operation_resume_music(uint32_t type, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4, uint32_t param5)
{
	if (trace_all || trace_sfx) ffnx_info("%s: Field resume music after battle\n", __func__);

	for (int i = 0; i < 4; ++i) {
		if (use_external_sfx)
		{
			ff7_sfx_play_on_channel(sfx_buffers[i].pan1, sfx_buffers[i].sound_id, i + 1);
		}
		else
		{
			if (sfx_buffers[i].buffer1 != nullptr || sfx_buffers[i].buffer2 != nullptr) {
				uint32_t pan;
				if (sfx_buffers[i].buffer1 != nullptr) {
					pan = sfx_buffers[i].pan1;
				}
				else {
					pan = sfx_buffers[i].pan2;
				}

				((uint32_t(*)(uint32_t, uint32_t, uint32_t))common_externals.play_sfx_on_channel)(pan, sfx_buffers[i].sound_id, i + 1);

				sfx_buffers[i] = ff7_field_sfx_state();
				sfx_buffers[i].buffer1 = nullptr;
				sfx_buffers[i].buffer2 = nullptr;
			}
		}
	}

	return ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(type, param1, param2, param3, param4, param5);
}

void sfx_remember_volumes()
{
	if (trace_all || trace_sfx) ffnx_info("%s: Remember SFX volumes (master: %i)\n", __func__, *common_externals.master_sfx_volume);

	for (int i = 0; i < 5; ++i) {

		sfx_volumes[i] = use_external_sfx ? sfx_state[i].volume1 : (sfx_state[i].buffer1 != nullptr ? sfx_state[i].volume1 : sfx_state[i].volume2);

		if (sfx_volumes[i] > 127) {
			sfx_volumes[i] = 127;
		}

		if (trace_all || trace_sfx) ffnx_info("%s: SFX volume channel #%i: %i\n", __func__, i, sfx_volumes[i]);
	}
}

void sfx_menu_force_channel_5_volume(uint32_t volume, uint32_t channel)
{
	if (trace_all || trace_sfx) ffnx_info("%s: %d\n", __func__, volume);
	// Original call (set channel 5 volume to maximum)
	if (use_external_sfx)
		ff7_sfx_set_volume_on_channel(volume, channel);
	else
		common_externals.set_sfx_volume_on_channel(volume, channel);
	// Added by FFNx
	sfx_remember_volumes();
}

void sfx_update_volume(int modifier)
{
	if (trace_all || trace_sfx) ffnx_info("%s: Update SFX volumes %d\n", __func__, modifier);

	// Set master sfx volume
	BYTE** sfx_tmp_volume = (BYTE**)(ff7_externals.config_menu_sub + ff7_externals.call_menu_sound_slider_loop_sfx_down + 0xA);

	*common_externals.master_sfx_volume = **sfx_tmp_volume + modifier;

	if (use_external_sfx) nxAudioEngine.setSFXMasterVolume(*common_externals.master_sfx_volume / 100.0f);

	// Update sfx volume in real-time for all channel
	for (int channel = 1; channel <= 5; ++channel) {
		if (use_external_sfx)
			ff7_sfx_set_volume_on_channel(sfx_volumes[channel - 1], channel);
		else
			common_externals.set_sfx_volume_on_channel(sfx_volumes[channel - 1], channel);

		if (trace_all || trace_sfx) ffnx_info("%s: Set SFX volume for channel #%i: %i\n", __func__, channel, sfx_volumes[channel - 1]);
	}
}

void sfx_menu_play_sound_down(uint32_t id)
{
	// Added by FFNx
	sfx_update_volume(-1);

	// Original call (cursor sound)
	if (use_external_sfx)
		ff7_sfx_play_on_channel_5(id);
	else
		common_externals.play_sfx(id);
}

void sfx_menu_play_sound_up(uint32_t id)
{
	// Added by FFNx
	sfx_update_volume(1);

	// Original call (cursor sound)
	if (use_external_sfx)
		ff7_sfx_play_on_channel_5(id);
	else
		common_externals.play_sfx(id);
}

void sfx_clear_sound_locks()
{
	uint32_t** flags = (uint32_t**)(ff7_externals.battle_clear_sound_flags + 5);
	// The last uint32_t wasn't reset by the original sub
	memset((void*)*flags, 0, 5 * sizeof(uint32_t));
}

void sfx_fix_volume_values(char* log)
{
	if (trace_all || trace_sfx) ffnx_info("%s", log); // FF7 default log

	for (int i = 0; i < 5; ++i) {
		if (sfx_state[i].u1 == 0xFFFFFFFF) {
			if (trace_all || trace_sfx) ffnx_info("%s: SFX fix volume channel #%i: %i\n", __func__, i + 1, real_volume);

			sfx_state[i].volume1 = real_volume;
			sfx_state[i].volume2 = real_volume;
			sfx_state[i].u1 = 0; // Back to the correct value
		}
	}
}

int sfx_play_battle_specific(IDirectSoundBuffer* buffer, uint32_t flags)
{
	if (buffer == nullptr) {
		return 0;
	}

	// Added by FFNx: set buffer volume according to master_sfx_volume
	unsigned char volume = 127 * (*common_externals.master_sfx_volume) / 100;

	buffer->SetVolume(common_externals.dsound_volume_table[volume]);

	// Original behavior
	HRESULT res = buffer->Play(0, 0, flags);

	if (DSERR_BUFFERLOST == res) {
		res = buffer->Restore();

		return -1;
	}

	return res == DS_OK;
}

uint32_t sfx_fix_omnislash_sound_loading(int sound_id, int dsound_buffer)
{
	// Added by FFNx: Load sound 0x188
	((uint32_t(*)(int, int))common_externals.sfx_load)(0x188, dsound_buffer);

	// Original call (load sound 0x285)
	return ((uint32_t(*)(int, int))common_externals.sfx_load)(sound_id, dsound_buffer);
}

void sfx_fix_cait_sith_roulette(int sound_id)
{
	((uint32_t(*)(uint32_t, uint32_t, uint32_t))common_externals.play_sfx_on_channel)(64, sound_id, 4);
}

//=============================================================================

void sfx_process_footstep(bool is_player_moving)
{
	static time_t last_playback_time, current_playback_time;

	if (is_player_moving)
	{
		float pace = 0.5f;

		// If running change the pace
		if (*ff7_externals.input_run_button_status != 0 || gamepad_analogue_intent == INTENT_RUN) pace = 0.30f;

		qpc_get_time(&current_playback_time);
		if (qpc_diff_time(&current_playback_time, &last_playback_time, nullptr) >= ((ff7_game_obj*)common_externals.get_game_object())->countspersecond * pace)
		{
			if (use_external_sfx) ff7_sfx_play_layered(0.0f, 159, 7);
			else common_externals.play_sfx(159);
			qpc_get_time(&last_playback_time);
		}
	}
}

void sfx_process_wm_footstep(int player_model_id, int player_walkmap_type)
{
	static time_t last_playback_time, current_playback_time;
	float pace = 0.3f;
	constexpr int footstep_id = 159;
	bool playing;

	if(player_model_id == 4 || player_model_id == 19)
		pace = 0.5f;

	qpc_get_time(&current_playback_time);
	if (qpc_diff_time(&current_playback_time, &last_playback_time, nullptr) >= ((ff7_game_obj*)common_externals.get_game_object())->countspersecond * pace)
	{
		char track_name[64];
		if (use_external_sfx)
		{
			sprintf(track_name, "wm_footsteps_%d_%d_%d", player_model_id, player_walkmap_type, footstep_id);
			playing = nxAudioEngine.playSFX(track_name, footstep_id, 7, 0.0f);

			if(!playing)
			{
				sprintf(track_name, "wm_footsteps_%d_%d", player_walkmap_type, footstep_id);
				playing = nxAudioEngine.playSFX(track_name, footstep_id, 7, 0.0f);
			}
		}
		else
		{
			common_externals.play_sfx(footstep_id);
		}
		qpc_get_time(&last_playback_time);
	}
}

void sfx_process_wm_highwind(bool is_old_highwind, bool is_highwind_moving)
{
	static bool playing = false;

	constexpr int default_sfx_id = 493; // Tiny Bronco SFX
	constexpr int default_channel = 1;

	if (is_highwind_moving && !playing)
	{
		if (use_external_sfx)
		{
			char track_name[64];
			sprintf(track_name, "sfx_highwind_%d", (is_old_highwind) ? 0 : 1);
			playing = nxAudioEngine.playSFX(track_name, default_sfx_id, default_channel, 0.0f, true);
		}
		else
		{
			common_externals.play_sfx_effects(64, default_sfx_id, 0, 0, 0);
			playing = true;
		}
	}
	else if (!is_highwind_moving && playing)
	{
		for(int channel = 1; channel <= 5; channel++)
			common_externals.set_sfx_frequency_on_channel(0, channel);
		((void(*)())common_externals.sfx_stop)();
		playing = false;
	}
}

//=============================================================================

void sfx_init()
{
	// Add Global Focus flag to DirectSound Secondary Buffers
	patch_code_byte(common_externals.directsound_buffer_flags_1 + 0x4, 0x80); // DSBCAPS_GLOBALFOCUS & 0x0000FF00

	// SFX Patches
	if (!ff8) {
		// On volume change in main menu initialization
		replace_call(ff7_externals.menu_start + 0x17, sfx_menu_force_channel_5_volume);
		// On SFX volume change in config menu
		replace_call(ff7_externals.config_menu_sub + ff7_externals.call_menu_sound_slider_loop_sfx_down, sfx_menu_play_sound_down);
		replace_call(ff7_externals.config_menu_sub + ff7_externals.call_menu_sound_slider_loop_sfx_up, sfx_menu_play_sound_up);
		// Fix escape sound not played more than once
		replace_function(ff7_externals.battle_clear_sound_flags, sfx_clear_sound_locks);
		// On stop sound in battle swirl
		replace_call(ff7_externals.swirl_sound_effect + 0x26, sfx_operation_battle_swirl_stop_sound);
		// On resume music after a battle
		replace_call(ff7_externals.field_initialize_variables + 0xEB, sfx_operation_resume_music);

		// Leviathan fix
		patch_code_byte(ff7_externals.battle_summon_leviathan_loop + 0x3FA + 1, 0x2A);
		// Omnislash fix
		replace_call(ff7_externals.battle_limit_omnislash_loop + 0x5A, sfx_fix_omnislash_sound_loading);
		// Cait Sith Roulette fix
		replace_call_function(ff7_externals.battle_menu_state_fn_table[26] + 0xC7, sfx_fix_cait_sith_roulette);
		// Comet2 fix
		patch_code_byte(ff7_externals.comet2_unload_sub_5A4359 + 0xF1, 0x5A);

		if (use_external_sfx)
		{
			replace_function(common_externals.sfx_load, ff7_sfx_load);
			replace_function(common_externals.sfx_unload, ff7_sfx_unload);
			replace_function(common_externals.play_sfx_on_channel, ff7_sfx_play_on_channel);
			replace_function((uint32_t)common_externals.play_sfx, ff7_sfx_play_on_channel_5);
			replace_function((uint32_t)common_externals.set_sfx_volume_on_channel, ff7_sfx_set_volume_on_channel);
			replace_function((uint32_t)common_externals.set_sfx_volume_trans_on_channel, ff7_sfx_set_volume_trans_on_channel);
			replace_function((uint32_t)common_externals.set_sfx_panning_on_channel, ff7_sfx_set_panning_on_channel);
			replace_function((uint32_t)common_externals.set_sfx_panning_trans_on_channel, ff7_sfx_set_panning_trans_on_channel);
			replace_function((uint32_t)common_externals.set_sfx_frequency_on_channel, ff7_sfx_set_frequency_on_channel);
			replace_function((uint32_t)common_externals.set_sfx_frequency_trans_on_channel, ff7_sfx_set_frequency_trans_on_channel);
			replace_function(ff7_externals.sfx_load_and_play_with_speed, ff7_sfx_load_and_play_with_speed);
			replace_function(ff7_externals.sfx_play_summon, ff7_sfx_play_on_channel_5);
			replace_function(common_externals.sfx_pause, ff7_sfx_pause);
			replace_function(common_externals.sfx_resume, ff7_sfx_resume);
			replace_function(common_externals.sfx_stop, ff7_sfx_stop);
			replace_function(common_externals.sfx_release, ff7_sfx_release);
			// Replace partially some calls in ff7_sfx_play_effects
			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x183, ff7_sfx_set_frequency_on_channel_6);
			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x1A9, ff7_sfx_set_panning_on_channel_6);
			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x1D9, ff7_sfx_set_volume_on_channel_6);
			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x1E9, ff7_sfx_play_on_channel_6);
			// Required to stop channel 6 effects when required by the engine
			replace_function(ff7_externals.sfx_stop_channel_6, ff7_sfx_stop_channel_6);

			sfx_state = new ff7_field_sfx_state[5]{0};
			for (short i = 0; i < 5; i++) sfx_state[i].volume1 = 127;

			nxAudioEngine.setSFXTotalChannels(7); // Allocate 7 channels in total
			nxAudioEngine.setSFXReusableChannels(5); // The engine by default although re-uses up to 5 channels
			nxAudioEngine.addSFXLazyUnloadChannel(6); // Channel 6 will be lazy unloaded by the game engine
		}
		else
		{
			/*
			* Set sound volume on channel changes
			* When this sub is called, it set two fields of sfx_state,
			* but with the wrong value (computed with sfx_master_volume)
			*/

			// Replace a useless "volume & 0xFF" to "real_volume <- volume; nop"
			patch_code_byte(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x48, 0xA3); // mov
			patch_code_uint(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x48 + 1, uint32_t(&real_volume));
			patch_code_byte(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x48 + 5, 0x90); // nop
			// Use a field of sfx_state to flag the current channel
			patch_code_uint(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x70, 0xFFFFFFFF);
			// Replace log call to fix sfx_state volume values
			replace_call(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x183, sfx_fix_volume_values);

			// Fix volume on specific SFX
			replace_call(ff7_externals.sfx_play_summon + 0xA2, sfx_play_battle_specific);
			replace_call(ff7_externals.sfx_play_summon + 0xF2, sfx_play_battle_specific);

			// Store pointer to the SFX states
			sfx_state = ff7_externals.sound_states;
		}
	} else if (use_external_sfx) {
		replace_function(common_externals.sfx_load, ff8_sfx_load);
		replace_function(common_externals.sfx_unload, ff8_sfx_unload);
		replace_function(common_externals.play_sfx_on_channel, ff8_sfx_play_channel);
		replace_function(common_externals.sfx_stop, ff8_sfx_stop_channel);
		replace_function(common_externals.sfx_pause, ff8_sfx_pause_channel);
		replace_function(common_externals.sfx_resume, ff8_sfx_resume_channel);
		replace_function(uint32_t(ff8_externals.sfx_set_master_volume), ff8_sfx_set_master_volume);
		replace_function(ff8_externals.sfx_is_playing, ff8_sfx_is_playing);
		replace_function(ff8_externals.sfx_set_volume, ff8_sfx_set_volume);
		replace_function(ff8_externals.sfx_set_panning, ff8_sfx_set_panning);

		nxAudioEngine.setSFXTotalChannels(FF8_MAX_CHANNEL_NUMBER + 1); // Allocate 32 channels in total
		nxAudioEngine.setSFXReusableChannels(FF8_MAX_CHANNEL_NUMBER + 1); // The engine by default although re-uses up to 32 channels
	}
}
````

## File: src/sfx.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>

void sfx_process_footstep(bool is_player_moving);
void sfx_process_wm_footstep(int player_model_id, int player_walkmap_type);
void sfx_process_wm_highwind(bool is_old_highwind, bool is_highwind_motor_on);
void sfx_init();
````

## File: src/utils.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 myst6re                                            //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/
#include "utils.h"

#include "globals.h"
#include "log.h"

#include <sys/stat.h>
#include <filesystem>
#include <Softpub.h>
#include <wintrust.h>

#include <cryptopp/md5.h>
#include <cryptopp/sha.h>
#include <cryptopp/files.h>
#include <cryptopp/hex.h>

bool fileExists(const char *filename)
{
    struct stat dummy;

    // Use stat to keep compatibility with 7th Heaven
    return stat(filename, &dummy) == 0;
}

bool dirExists(const char *dirname)
{
    struct stat dummy;

    // Use stat to keep compatibility with 7th Heaven
    return stat(dirname, &dummy) == 0;
}

std::string getCopyrightInfoFromExe(const std::string& filePath)
{
    // Get the size of the version information
    DWORD handle = 0;
    DWORD versionInfoSize = GetFileVersionInfoSize(filePath.c_str(), &handle);
    if (versionInfoSize == 0) return "Failed to get version info size.";

    // Allocate memory to hold version information
    std::vector<char> versionData(versionInfoSize);
    if (!GetFileVersionInfo(filePath.c_str(), handle, versionInfoSize, versionData.data())) return "Failed to get version information.";

    // Query the translation table to locate the language and code page
    struct LANGANDCODEPAGE {
        WORD language;
        WORD codePage;
    } *translation = nullptr;

    UINT translationSize = 0;
    if (!VerQueryValue(versionData.data(), "\\VarFileInfo\\Translation", (LPVOID*)&translation, &translationSize)) return "Failed to query translation information.";

    if (translationSize == 0) return "No translation information available.";

    // Use the first language and code page in the translation table
    char subBlock[50];
    snprintf(subBlock, sizeof(subBlock), "\\StringFileInfo\\%04x%04x\\LegalCopyright", translation[0].language, translation[0].codePage);

    // Query the copyright information
    char* copyrightInfo = nullptr;
    UINT infoSize = 0;
    if (!VerQueryValue(versionData.data(), subBlock, (LPVOID*)&copyrightInfo, &infoSize) || infoSize == 0) return "Copyright information not found.";

    // Return the copyright information as a std::string
    return std::string(copyrightInfo, infoSize);
}

std::wstring GetErrorMessage(unsigned long errorCode)
{
    LPWSTR messageBuffer = nullptr;

    FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&messageBuffer,
        0,
        NULL
    );

    std::wstring message = messageBuffer ? messageBuffer : L"Unknown error";
    LocalFree(messageBuffer);
    return message;
}

bool isFileSigned(const wchar_t* dllPath)
{
    WINTRUST_FILE_INFO fileInfo = {};
    WINTRUST_DATA trustData = {};
    WINTRUST_SIGNATURE_SETTINGS signatureSettings = {};

    // Open the file with proper sharing flags
    fileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    fileInfo.pcwszFilePath = NULL;
    fileInfo.hFile = CreateFileW(dllPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);;
    fileInfo.pgKnownSubject = NULL;

    GUID actionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    trustData.cbStruct = sizeof(WINTRUST_DATA);
    trustData.dwUIChoice = WTD_UI_NONE;
    trustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    trustData.dwUnionChoice = WTD_CHOICE_FILE;
    trustData.pFile = &fileInfo;
    trustData.dwStateAction = WTD_STATEACTION_VERIFY;
    trustData.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;

    LONG status = WinVerifyTrust(NULL, &actionID, &trustData);

    if (status != ERROR_SUCCESS) ffnx_error("Unable to verify '%ls': %ls", dllPath, GetErrorMessage(status));

    trustData.dwStateAction = WTD_STATEACTION_CLOSE;
    WinVerifyTrust(NULL, &actionID, &trustData);

    CloseHandle(fileInfo.hFile);

    return status == ERROR_SUCCESS;
}

std::string sha1_file(const std::string& filename)
{
    CryptoPP::SHA1 hash;
    std::string digest;

    CryptoPP::FileSource(filename.c_str(), true,
        new CryptoPP::HashFilter(hash,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(digest), false)));

    return digest;
}

std::string md5_hash(const unsigned char* data, size_t length)
{
    using namespace CryptoPP;

    std::string digest;

    MD5 hash;
    StringSource(data, length, true,
        new HashFilter(hash,
            new HexEncoder(
                new StringSink(digest), false)));

    return digest;
}
````

## File: src/utils.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <regex>
#include <string>
#include <vector>
#include <chrono>
#include <random>

// Get the size of a vector in bytes
template<typename T>
size_t vectorSizeOf(const typename std::vector<T>& vec)
{
    return sizeof(T) * vec.size();
}

// trim from start (in place)
inline void ltrim(std::string& s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
        return !std::isspace(ch);
        }));
}

// trim from end (in place)
inline void rtrim(std::string& s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
        return !std::isspace(ch);
        }).base(), s.end());
}

// trim from both ends (in place)
inline void trim(std::string& s) {
    ltrim(s);
    rtrim(s);
}

inline bool contains(std::string const& value, std::string const& token)
{
    return value.find(token) != std::string::npos;
}

inline std::vector<std::string> split(const std::string& string, const std::string& regex)
{
    std::vector<std::string> result;
    std::string safeString(string);

    trim(safeString);

    const std::regex rgx(regex);
    std::sregex_token_iterator iter(safeString.begin(), safeString.end(), rgx, -1);

    for (std::sregex_token_iterator end; iter != end; ++iter)
    {
        result.push_back(iter->str());
    }

    return result;
}

inline bool starts_with(std::string const& value, std::string const& starting)
{
    if (starting.size() > value.size()) return false;
    return value.rfind(starting, 0) == 0;
}

inline bool ends_with(std::string const& value, std::string const& ending)
{
    if (ending.size() > value.size()) return false;
    return std::equal(ending.rbegin(), ending.rend(), value.rbegin());
}

inline bool replaceOnce(std::string& str, const std::string& from, const std::string& to)
{
    size_t start_pos = str.find(from);

    if (start_pos == std::string::npos)
        return false;

    str.replace(start_pos, from.length(), to);

    return true;
}

inline void replaceAll(std::string& str, const char from, const char to)
{
    std::replace(str.begin(), str.end(), from, to);
}

// Based on https://stackoverflow.com/a/13446015
inline int getRandomInt(int min, int max)
{
    std::random_device rd;
    std::mt19937::result_type seed = rd() ^ (
        (std::mt19937::result_type)
        std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count() +
        (std::mt19937::result_type)
        std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::high_resolution_clock::now().time_since_epoch()
        ).count()
    );

    std::mt19937 gen(seed);
    std::uniform_int_distribution<unsigned> distrib(min, max);

    return distrib(gen);
}

inline std::chrono::time_point<std::chrono::high_resolution_clock> highResolutionNow()
{
    return std::chrono::high_resolution_clock::now();
}

inline long double elapsedMicroseconds(std::chrono::time_point<std::chrono::high_resolution_clock> startTime)
{
    return std::chrono::duration<long double, std::micro>(highResolutionNow() - startTime).count();
}

bool fileExists(const char *filename);
bool dirExists(const char *dirname);
std::string getCopyrightInfoFromExe(const std::string& filePath);
std::wstring GetErrorMessage(unsigned long errorCode);
bool isFileSigned(const wchar_t* dllPath);
std::string sha1_file(const std::string& filename);
std::string md5_hash(const unsigned char* data, size_t length);
````

## File: src/vibration.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "vibration.h"

#include <vector>

#include "gamepad.h"
#include "joystick.h"
#include "globals.h"
#include "log.h"

NxVibrationEngine nxVibrationEngine;

NxVibrationEngine::NxVibrationEngine() :
	_leftMotorStopTimeFrame(0),
	_left(0), _right(0),
	_currentLeft(0), _currentRight(0)
{
}

NxVibrationEngine::~NxVibrationEngine()
{
	for (auto data: _vibrateData) {
		delete[] data.second;
	}
}

void NxVibrationEngine::setLeftMotorValue(uint8_t force)
{
	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s force=%d\n", __func__, force);

	if (force > 0)
	{
		_leftMotorStopTimeFrame = xinput_connected ? frame_counter + LEFT_MOTOR_DURATION_FRAMES : 0;
		_left = force;
	}
}

void NxVibrationEngine::setRightMotorValue(uint8_t force)
{
	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s force=%d\n", __func__, force);

	_right = force;
}

void NxVibrationEngine::stopAll()
{
	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s\n", __func__);

	_leftMotorStopTimeFrame = 0;
	_left = 0;
	_right = 0;

	rumbleUpdate();
}

bool NxVibrationEngine::hasChanged() const
{
	return _currentLeft != _left || _currentRight != _right;
}

void NxVibrationEngine::updateLeftMotorValue()
{
	if (xinput_connected && _leftMotorStopTimeFrame > 0 && frame_counter > _leftMotorStopTimeFrame)
	{
		if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s stop\n", __func__);
		_leftMotorStopTimeFrame = 0;
		_left = 0;
	}
	else if (!xinput_connected)
	{
		_leftMotorStopTimeFrame = 0;
	}
}

bool NxVibrationEngine::rumbleUpdate()
{
	updateLeftMotorValue();

	if (! hasChanged())
	{
		return false;
	}

	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s left=%d right=%d\n", __func__, _left, _right);

	const DWORD maxVibration = xinput_connected ? UINT16_MAX : joystick.GetMaxVibration();
	DWORD left = _left * maxVibration / LEFT_MOTOR_MAX_VALUE;
	DWORD right = _right * maxVibration / RIGHT_MOTOR_MAX_VALUE;

	if (left > maxVibration) {
		left = maxVibration;
	}
	if (right > maxVibration) {
		right = maxVibration;
	}

	if (xinput_connected)
	{
		gamepad.Vibrate(left, right);
	}
	else
	{
		joystick.Vibrate(left, right);
	}

	_currentLeft = _left;
	_currentRight = _right;

	return true;
}

bool NxVibrationEngine::canRumble() const
{
	if (xinput_connected)
	{
		return gamepad.GetPort() > 0;
	}

	return joystick.CheckConnection() && joystick.HasForceFeedback();
}

uint8_t *NxVibrationEngine::createVibrateDataFromConfig(const toml::parse_result &config)
{
	char sectionName[6] = "";
	uint32_t header[64] = {};
	std::vector<uint16_t> executionData;

	for (int set = 0; set < 64; ++set)
	{
		snprintf(sectionName, sizeof(sectionName), "set%d", set);
		const toml::array *leftMotor = config[sectionName]["left_motor"].as_array();
		const toml::array *rightMotor = config[sectionName]["right_motor"].as_array();
		if (leftMotor && rightMotor
			&& (leftMotor->empty() || leftMotor->is_homogeneous(toml::node_type::array))
			&& (rightMotor->empty() || rightMotor->is_homogeneous(toml::node_type::array))
		) {
			header[set] = sizeof(header) + executionData.size() * sizeof(uint16_t);

			uint16_t leftSize = leftMotor->empty() ? 0 : (leftMotor->size() + 1) * 2,
				rightSize = rightMotor->empty() ? 0 : (rightMotor->size() + 1) * 2;
			executionData.push_back(leftSize);
			executionData.push_back(rightSize);

			for (const toml::node& elem: *leftMotor)
			{
				const toml::array *values = elem.as_array();

				if (values && values->is_homogeneous(toml::node_type::integer) && values->size() == 2)
				{
					executionData.push_back(
						(((*values)[1].value_or(0) & 0xFF) << 8) | ((*values)[0].value_or(0) & 0xFF)
					);
				}
				else
				{
					ffnx_warning("NxVibrationEngine::%s: Invalid values in section %s/left_motor\n", __func__, sectionName);
				}
			}

			if (leftSize > 0) {
				// End of sequence
				executionData.push_back(0xFF00);
			}

			for (const toml::node& elem: *rightMotor)
			{
				const toml::array *values = elem.as_array();

				if (values && values->is_homogeneous(toml::node_type::integer) && values->size() == 2)
				{
					executionData.push_back(
						(((*values)[1].value_or(0) & 0xFF) << 8) | ((*values)[0].value_or(0) & 0xFF)
					);
				}
				else
				{
					ffnx_warning("NxVibrationEngine::%s: Invalid values in section %s/right_motor\n", __func__, sectionName);
				}
			}

			if (rightSize > 0) {
				// End of sequence
				executionData.push_back(0xFF00);
			}
		}
		else if (config[sectionName])
		{
			ffnx_warning("NxVibrationEngine::%s: Missing or invalid left_motor or right_motor in section %s\n", __func__, sectionName);
		}
	}

	if (executionData.empty())
	{
		return nullptr;
	}

	uint8_t *data = new uint8_t[sizeof(header) + executionData.size() * sizeof(uint16_t)];

	memcpy(data, header, sizeof(header));
	memcpy(data + sizeof(header), executionData.data(), executionData.size() * sizeof(uint16_t));

	return data;
}

const uint8_t *NxVibrationEngine::vibrateDataOverride(const char *name)
{
	char fullpath[MAX_PATH];
	snprintf(fullpath, sizeof(fullpath), "%s/%s/%s.toml", basedir, external_vibrate_path.c_str(), name);

	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s: looking for %s\n", __func__, fullpath);

	std::string nameStr(name);

	if (_vibrateData.contains(nameStr))
	{
		return _vibrateData[nameStr];
	}

	try
	{
		toml::parse_result result = toml::parse_file(fullpath);
		uint8_t *data = createVibrateDataFromConfig(result);
		if (data != nullptr)
		{
			if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s: data created\n", __func__, fullpath);
			_vibrateData[nameStr] = data;
		}

		return data;
	}
	catch (const toml::parse_error &err)
	{
		return nullptr;
	}

	return nullptr;
}
````

## File: src/vibration.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2023 myst6re                                            //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <stdint.h>
#include <unordered_map>
#include <string>
#include <toml++/toml.h>

constexpr int LEFT_MOTOR_DURATION_FRAMES = 5;
constexpr int LEFT_MOTOR_MAX_VALUE = 240;
constexpr int RIGHT_MOTOR_MAX_VALUE = 128;

class NxVibrationEngine {
public:
	NxVibrationEngine();
	~NxVibrationEngine();
	void setLeftMotorValue(uint8_t force);
	void setRightMotorValue(uint8_t force);
	void stopAll();
	bool rumbleUpdate();
	bool canRumble() const;
	const uint8_t *vibrateDataOverride(const char *name);
private:
	bool hasChanged() const;
	void updateLeftMotorValue();
	uint8_t *createVibrateDataFromConfig(const toml::parse_result &config);

	uint32_t _leftMotorStopTimeFrame;
	uint8_t _left, _right;
	uint8_t _currentLeft, _currentRight;
	std::unordered_map<std::string, uint8_t *> _vibrateData;
};

extern NxVibrationEngine nxVibrationEngine;
````

## File: src/voice.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include "voice.h"

#include "achievement.h"
#include "audio.h"
#include "field.h"
#include "globals.h"
#include "patch.h"
#include "utils.h"

#include "ff8/engine.h"

#include <queue>

enum class display_type
{
	NONE = 0,
	DIALOGUE,
	CHAR_CMD
};

enum class message_kind
{
	NONE = 0,
	ASK,
	MESSAGE,
	DRAWPOINT
};

struct battle_text_aux_data{
	bool has_started {false};
	bool follow_voice {false};
	display_type text_type {display_type::NONE};
	int page_count {0};
	uint16_t enemy_id;
	cmd_id command_id;
	byte char_id;
};

struct opcode_message_status
{
	opcode_message_status() :
		// Common
		message_page_count(0),
		message_last_opcode(0),
		is_voice_acting(false),
		message_last_transition(0),
		message_last_option(UCHAR_MAX),
		message_dialog_id(0),
		message_last_dialog_id(0),
		char_id(0),
		message_kind(message_kind::NONE),
		field_name("")
	{}
	byte message_page_count = 0;
	WORD message_last_opcode = 0;
	bool is_voice_acting = false;
	WORD message_last_transition = 0;
	byte message_last_option = UCHAR_MAX;
	int message_dialog_id = 0;
	int message_last_dialog_id = 0;
	byte char_id = 0;
	message_kind message_kind = message_kind::NONE;
	std::string field_name = "";
};

// FF7
int (*opcode_old_message)();
int (*opcode_old_ask)(int);
int (*opcode_old_wmode)();
int (*opcode_wm_old_message)(uint8_t,uint8_t);
int (*opcode_wm_old_ask)(uint8_t,uint8_t,uint8_t,uint8_t,WORD*);
int (*opcode_old_tutor)();
void (*ff7_set_master_music_volume)(uint32_t);

// FF8
int (*ff8_opcode_old_mes)(int);
int (*ff8_opcode_old_ames)(int);
int (*ff8_opcode_old_amesw)(int);
int (*ff8_opcode_old_ramesw)(int);
int (*ff8_opcode_old_ask)(int);
int (*ff8_opcode_old_aask)(int);
int (*ff8_opcode_old_drawpoint)(int);

int ff8_current_window_dialog_id = -1;
std::map<int, int> ff8_field_window_stack_count;
std::map<int, char*> ff8_battle_actor_name;

// COMMON
byte opcode_ask_current_option = UCHAR_MAX;

std::map<int,bool> simulate_OK_disabled;

DWORD previous_master_music_volume = 0x64; // Assume maximum by default
float voice_volume = -1.0f;

std::array<battle_text_aux_data, 64> other_battle_display_text_queue;
std::queue<short> display_string_actor_queue;
std::map<int, opcode_message_status> current_opcode_message_status;

//=============================================================================

void set_voice_volume()
{
	voice_volume = 2.0f + (100 - external_voice_music_fade_volume) / 100.0f;
}

void begin_voice(byte window_id = 0)
{
	current_opcode_message_status[window_id] = opcode_message_status();

	set_voice_volume();

	if (enable_voice_music_fade)
	{
		if (use_external_music)
		{
			float new_master_volume = external_voice_music_fade_volume / 100.0f;

			if (new_master_volume < nxAudioEngine.getMusicMasterVolume())
				nxAudioEngine.setMusicMasterVolume(new_master_volume, 1);
		}
		else
		{
			if (external_voice_music_fade_volume < *common_externals.master_midi_volume)
			{
				previous_master_music_volume = *common_externals.master_midi_volume;

				if (ff8)
					ff8_externals.dmusicperf_set_volume_sub_46C6F0(floor(127 * (external_voice_music_fade_volume / 100.0f)), 0);
				else
					ff7_set_master_music_volume(external_voice_music_fade_volume);
			}
		}
	}
}

bool play_voice(char* field_name, byte window_id, byte dialog_id, byte page_count)
{
	char name[MAX_PATH];

	char page = 'a' + page_count;
	if (page > 'z') page = 'z';

	sprintf(name, "%s/w%u_%u%c", field_name, window_id, dialog_id, page);

	if (!nxAudioEngine.canPlayVoice(name))
		sprintf(name, "%s/%u%c", field_name, dialog_id, page);

	if (!nxAudioEngine.canPlayVoice(name) && page_count == 0)
	{
		sprintf(name, "%s/w%u_%u", field_name, window_id, dialog_id);

		if (!nxAudioEngine.canPlayVoice(name))
			sprintf(name, "%s/%u", field_name, dialog_id);
	}

	return nxAudioEngine.playVoice(name, window_id, voice_volume, *common_externals.field_game_moment);
}

bool play_battle_dialogue_voice(short enemy_id, std::string tokenized_dialogue)
{
	char name[MAX_PATH];

	sprintf(name, "_battle/enemy_%04X/%s", enemy_id, tokenized_dialogue.c_str());

	return nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
}

bool play_battle_cmd_voice(byte char_id, cmd_id command_id, std::string tokenized_dialogue, int page_count)
{
	char name[MAX_PATH];
	bool playing;

	char page = 'a' + page_count;
	if (page > 'z') page = 'z';
	sprintf(name, "_battle/char_%02X/cmd_%02X_", char_id, command_id);

	switch(command_id)
	{
	case cmd_id::CMD_MANIPULATE:
		// 2 cases: manipulated, couldnt
	case cmd_id::CMD_STEAL:
	case cmd_id::CMD_MUG:
		// 3 cases: nothing, couldnt, stole
		sprintf(name + strlen(name), "%s", split(tokenized_dialogue, "_")[0].c_str());
		break;
	default:
		sprintf(name + strlen(name), "%c", page);
		break;
	}

	playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);

	if(!playing && page_count == 0)
	{
		sprintf(name, "_battle/char_%02X/cmd_%02X", char_id, command_id);
		playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
	}

	return playing;
}

bool play_battle_char_action_voice(byte char_id, byte command_id, short action_id)
{
	char name[MAX_PATH];
	bool playing;

	sprintf(name, "_battle/char_%02X/cmd_%02X_%04X", char_id, command_id, action_id);
	playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);

	if(!playing)
	{
		sprintf(name, "_battle/char_%02X/cmd_%02X", char_id, command_id);
		playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
	}

	return playing;
}

bool play_battle_enemy_action_voice(uint16_t enemy_id, byte command_id, short action_id)
{
	char name[MAX_PATH];
	bool playing;

	sprintf(name, "_battle/enemy_%04X/cmd_%02X_%04X", enemy_id, command_id, action_id);
	playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);

	if(!playing)
	{
		sprintf(name, "_battle/enemy_%04X/cmd_%02X", enemy_id, command_id);
		playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
	}

	return playing;
}

void play_option(char* field_name, byte window_id, byte dialog_id, byte option_count)
{
	char name[MAX_PATH];

	sprintf(name, "%s/%u_%u", field_name, dialog_id, option_count);

	nxAudioEngine.playVoice(name, window_id, voice_volume, *common_externals.field_game_moment);
}

void end_voice(byte window_id = 0, uint32_t time = 0)
{
	nxAudioEngine.stopVoice(window_id, time);

	if (enable_voice_music_fade)
	{
		if (use_external_music)
			nxAudioEngine.restoreMusicMasterVolume(time > 0 ? time : 1);
		else if (ff8)
			ff8_externals.dmusicperf_set_volume_sub_46C6F0(previous_master_music_volume, 0);
		else
			ff7_set_master_music_volume(previous_master_music_volume);
	}
}

//=============================================================================

bool is_dialog_opening(WORD code)
{
	return (code == 0);
}

bool is_dialog_starting(WORD old_code, WORD new_code)
{
	return (
		old_code == 0 && old_code != new_code
	);
}

bool is_dialog_paging(WORD old_code, WORD new_code)
{
	if (ff8)
		return (
			(old_code == 10 && new_code == 1)
		);
	else
		return (
			(old_code == 14 && new_code == 2) ||
			(old_code == 4 && new_code == 8)
		);
}

bool is_dialog_closing(WORD old_code, WORD new_code)
{
	if (ff8)
		return (
			new_code < old_code
		);
	else
		return (
			old_code != new_code && new_code == 7
		);
}

bool is_dialog_closed(WORD old_code, WORD new_code)
{
	if (ff8)
		return (
			new_code < old_code && new_code == 0
		);
	else
		return (
			old_code == 7 && new_code == 0
		);
}

byte get_dialog_opcode(byte window_id)
{
	return ff7_externals.opcode_message_loop_code[24 * window_id];
}

//=============================================================================

// -- FIELD --

byte get_field_dialog_char_id(byte window_id) {
	if (ff7_externals.field_entity_id_list[window_id] != *ff7_externals.current_entity_id) return 0;

	if (ff7_externals.field_entity_id_list[window_id] == 0x0) return 0;

	byte id = *(byte*)ff7_externals.current_dialog_string_pointer[window_id];

	switch(id) {
		case 0xEA: // CLOUD
		case 0xEB: // BARRET
		case 0xEC: // TIFA
		case 0xED: // AERITH
		case 0xEE: // RED XIII
		case 0xEF: // YUFFIE
		case 0xF0: // CAIT SITH
		case 0xF1: // VINCENT
		case 0xF2: // CID
			return id;
		default:
			return 0;
	}
}

void ff7_handle_wmode_reset()
{
	struct game_mode *mode = getmode_cached();
	static WORD last_field_id = 0;
	uint32_t last_driver_mode = 0;

	if (last_field_id != *ff7_externals.field_id)
	{
		last_field_id = *ff7_externals.field_id;

		simulate_OK_disabled.clear();
	}
	else if (last_driver_mode != mode->driver_mode)
	{
		last_driver_mode = mode->driver_mode;

		simulate_OK_disabled.clear();
	}
}

int opcode_wmode()
{
	byte window_id = get_field_parameter<byte>(0);
	byte window_permanent = get_field_parameter<byte>(2);

	simulate_OK_disabled[window_id] = window_permanent;

	return opcode_old_wmode();
}

int opcode_voice_message()
{
	byte window_id = get_field_parameter<byte>(0);
	byte dialog_id = get_field_parameter<byte>(1);
	byte message_current_opcode = get_dialog_opcode(window_id);
	char* field_name = get_current_field_name();

	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);

	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;

	if (_is_dialog_opening)
	{
		begin_voice(window_id);
	}
	else if (_is_dialog_starting || _is_dialog_paging)
	{
		if (_is_dialog_starting) current_opcode_message_status[window_id].char_id = get_field_dialog_char_id(window_id);
		if (trace_all || trace_opcodes) ffnx_trace("opcode[MESSAGE]: field=%s,window_id=%u,dialog_id=%u,paging_id=%u,char=%X\n", field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count, current_opcode_message_status[window_id].char_id);
		current_opcode_message_status[window_id].is_voice_acting = play_voice(field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
	}
	else if (_is_dialog_closing)
	{
		end_voice(window_id);
		simulate_OK_disabled[window_id] = false;
		current_opcode_message_status[window_id].is_voice_acting = false;
	}

	// Auto close the message if it was voice acted and the audio file has finished playing
	if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
	{
		current_opcode_message_status[window_id].is_voice_acting = false;
		if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
	}

	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;

	return opcode_old_message();
}

int opcode_voice_tutor()
{
	static const int window_id = 0;

	current_opcode_message_status[window_id].message_dialog_id = get_field_parameter<byte>(0);

	return opcode_old_tutor();
}

int opcode_voice_parse_options(uint8_t window_id, uint8_t dialog_id, uint8_t first_question_id, uint8_t last_question_id, WORD *current_question_id)
{
	opcode_ask_current_option = *current_question_id;

	return ff7_externals.field_opcode_ask_update_loop_6310A1(window_id, dialog_id, first_question_id, last_question_id, current_question_id);
}

int opcode_voice_ask(int unk)
{
	byte window_id = get_field_parameter<byte>(1);
	byte dialog_id = get_field_parameter<byte>(2);
	byte message_current_opcode = get_dialog_opcode(window_id);
	char* field_name = get_current_field_name();

	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_option_changed = (current_opcode_message_status[window_id].message_last_option != opcode_ask_current_option);

	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;

	if (_is_dialog_opening)
	{
		opcode_ask_current_option = UCHAR_MAX;
		begin_voice(window_id);
	}
	else if (_is_dialog_starting || _is_dialog_paging)
	{
		if (_is_dialog_starting) current_opcode_message_status[window_id].char_id = get_field_dialog_char_id(window_id);
		if (trace_all || trace_opcodes) ffnx_trace("opcode[ASK]: field=%s,window_id=%u,dialog_id=%u,paging_id=%u,char=%X\n", field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count, current_opcode_message_status[window_id].char_id);
		current_opcode_message_status[window_id].is_voice_acting = play_voice(field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
	}
	else if (_is_dialog_option_changed)
	{
		if (trace_all || trace_opcodes) ffnx_trace("opcode[ASK]: field=%s,window_id=%u,dialog_id=%u,option_id=%u,char=%X\n", field_name, window_id, dialog_id, opcode_ask_current_option,current_opcode_message_status[window_id].char_id);
		play_option(field_name, window_id, dialog_id, opcode_ask_current_option);
	}
	else if (_is_dialog_closing)
	{
		end_voice(window_id);
	}

	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
	current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;

	return opcode_old_ask(unk);
}

// -- WORLDMAP --

int opcode_wm_message(uint8_t window_id, uint8_t dialog_id) {
	byte message_current_opcode = get_dialog_opcode(window_id);

	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);

	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;

	if (_is_dialog_opening)
	{
		begin_voice(window_id);
		current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	}
	else if (_is_dialog_starting || _is_dialog_paging)
	{
		if (trace_all || trace_opcodes) ffnx_trace("wm_opcode[MESSAGE]: window_id=%u,dialog_id=%u,paging_id=%u\n", window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
		current_opcode_message_status[window_id].is_voice_acting = play_voice("_world", window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
	}
	else if (_is_dialog_closing)
	{
		end_voice(window_id);
		simulate_OK_disabled[window_id] = false;
		current_opcode_message_status[window_id].is_voice_acting = false;
	}

	// Auto close the message if it was voice acted and the audio file has finished playing
	if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
	{
		current_opcode_message_status[window_id].is_voice_acting = false;
		if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) (*ff7_externals.field_global_object_ptr)->field_80 |= 0x20;
	}

	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;

	return opcode_wm_old_message(window_id, dialog_id);
}

int opcode_wm_ask(uint8_t window_id, uint8_t dialog_id, uint8_t first_question_id, uint8_t last_question_id, WORD *current_question_id) {
	byte message_current_opcode = get_dialog_opcode(window_id);

	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_option_changed = (current_opcode_message_status[window_id].message_last_option != *current_question_id);

	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;

	if (_is_dialog_opening)
	{
		begin_voice(window_id);
	}
	else if (_is_dialog_starting || _is_dialog_paging)
	{
		if (trace_all || trace_opcodes) ffnx_trace("wm_opcode[ASK]: window_id=%u,dialog_id=%u,paging_id=%u\n", window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
		current_opcode_message_status[window_id].message_dialog_id = dialog_id;
		current_opcode_message_status[window_id].is_voice_acting = play_voice("_world", window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
	}
	else if (_is_dialog_option_changed)
	{
		if (trace_all || trace_opcodes) ffnx_trace("wm_opcode[ASK]: window_id=%u,dialog_id=%u,option_id=%u\n", window_id, current_opcode_message_status[window_id].message_dialog_id, *current_question_id);
		play_option("_world", window_id, current_opcode_message_status[window_id].message_dialog_id, *current_question_id);
	}
	else if (_is_dialog_closing)
	{
		end_voice(window_id);
	}

	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
	current_opcode_message_status[window_id].message_last_option = *current_question_id;

	return opcode_wm_old_ask(window_id, dialog_id, first_question_id, last_question_id, current_question_id);
}

// -- BATTLE --

std::string decode_ff7_text(const char *encoded_text)
{
	std::string decoded_text{};
	int index = 0;
	char current_char;
	while (current_char = encoded_text[index++], current_char != char(0xFF))
	{
		switch (current_char)
		{
		case 0xEB:
			decoded_text.append("{item_name}");
			index += 3;
			break;
		case 0xEC:
			decoded_text.append("{number}");
			index += 3;
			break;
		case 0xED:
			decoded_text.append("{target_name}");
			index += 3;
			break;
		case 0xEE:
			decoded_text.append("{attack_name}");
			index += 3;
			break;
		case 0xEF:
			decoded_text.append("{special_number}");
			index += 3;
			break;
		case 0xF0:
			decoded_text.append("{target_letter}");
			index += 3;
			break;
		case 0xF8:
			index += 2;
			break;
		default:
			decoded_text.push_back(current_char + 0x20);
			break;
		}
	}
	return decoded_text;
}

std::string tokenize_text(std::string decoded_text)
{
	transform(decoded_text.begin(), decoded_text.end(), decoded_text.begin(), tolower);

	std::string filename{};
	for(auto current_char : decoded_text)
	{
		if(current_char >= 'a' && current_char <= 'z')
			filename += current_char;
		else if(current_char >= '0' && current_char <= '9')
			filename += current_char;
		else if(current_char == ' ')
			filename += '_';
		else if(current_char == '{' || current_char == '}')
			filename += current_char;
	}
	return filename;
}

void ff7_enqueue_script_display_string(short actor_id, byte command_index, uint16_t rel_attack_index)
{
	display_string_actor_queue.push(actor_id);

	if (trace_all || trace_battle_text) ffnx_trace("Push display string for actorId: %d\n", actor_id);

	((void (*)(short, byte, uint16_t))ff7_externals.enqueue_script_action)(actor_id, command_index, rel_attack_index);
}

void ff7_add_text_to_display_queue(WORD buffer_idx, byte wait_frames, byte n_frames, WORD param_4)
{
	auto text_data = std::find_if(ff7_externals.battle_display_text_queue.begin(), ff7_externals.battle_display_text_queue.end(),
									[](const battle_text_data &data)
									{ return data.buffer_idx == -1; });

	if (text_data != ff7_externals.battle_display_text_queue.end())
	{
		text_data->buffer_idx = buffer_idx;
		text_data->field_2 = param_4;
		text_data->wait_frames = wait_frames * battle_frame_multiplier - 1;
		int n_frames_int = (n_frames == 0) ? ((int (*)())ff7_externals.get_n_frames_display_action_string)() : n_frames * battle_frame_multiplier;
		text_data->n_frames = std::min(n_frames_int, UCHAR_MAX); // safely cast int to unsigned char

		if (trace_all || trace_battle_text)
			ffnx_trace("Add text string to be displayed: (text_id: %d, field_2: %d, wait_frames: %d, n_frames: %d)\n", text_data->buffer_idx, text_data->field_2, text_data->wait_frames, text_data->n_frames);

		int index = std::distance(ff7_externals.battle_display_text_queue.begin(), text_data);
		byte attacker_id = ff7_externals.anim_event_queue[*ff7_externals.anim_event_index].attackerID;
		if (attacker_id == 10 && n_frames == 0 && buffer_idx >= 256)
		{
			other_battle_display_text_queue[index].has_started = false;
			other_battle_display_text_queue[index].follow_voice = true;
			other_battle_display_text_queue[index].text_type = display_type::DIALOGUE;
			if (!display_string_actor_queue.empty())
			{
				short actor_id = display_string_actor_queue.front();
				display_string_actor_queue.pop();
				other_battle_display_text_queue[index].enemy_id = ff7_externals.battle_context->actor_vars[actor_id].formationID;
			}
		}
		else
		{
			if (attacker_id == 10)
				attacker_id = ff7_externals.anim_event_queue[0].attackerID;

			other_battle_display_text_queue[index].has_started = false;
			other_battle_display_text_queue[index].follow_voice = false;
			other_battle_display_text_queue[index].page_count = index;
			other_battle_display_text_queue[index].command_id = static_cast<cmd_id>(ff7_externals.battle_context->lastCommandIdx);

			if (attacker_id >= 0 && attacker_id <= 2)
			{
				other_battle_display_text_queue[index].text_type = display_type::CHAR_CMD;
				other_battle_display_text_queue[index].char_id = ff7_externals.battle_context->actor_vars[attacker_id].index;
			}
			else
			{
				other_battle_display_text_queue[index].text_type = display_type::NONE;
			}
		}
	}
}

void ff7_update_display_text_queue()
{
	*ff7_externals.field_battle_word_BF2E08 = *ff7_externals.field_battle_word_BF2E08 | 2;
	auto &text_data_first = ff7_externals.battle_display_text_queue.front();
	auto &other_text_data_first = other_battle_display_text_queue.front();

	if (text_data_first.buffer_idx != -1)
	{
		if (text_data_first.wait_frames == 0)
		{
			// Begin voice
			if(!other_text_data_first.has_started)
			{
				const char *encoded_text = ff7_externals.get_kernel_text(8, text_data_first.buffer_idx, 8);
				std::string decoded_text = decode_ff7_text(encoded_text);
				std::string tokenized_dialogue;

				begin_voice();
				switch (other_text_data_first.text_type)
				{
				case display_type::DIALOGUE:
					tokenized_dialogue = tokenize_text(decoded_text);
					other_text_data_first.has_started = play_battle_dialogue_voice(other_text_data_first.enemy_id, tokenized_dialogue);

					if (trace_all || trace_battle_text)
						ffnx_trace("Begin voice of EnemyID: %04X for text: %s (filename: %s)\n", other_text_data_first.enemy_id, decoded_text.c_str(), tokenized_dialogue.c_str());

					break;
				case display_type::CHAR_CMD:
					tokenized_dialogue = tokenize_text(decoded_text);
					other_text_data_first.has_started = play_battle_cmd_voice(other_text_data_first.char_id, other_text_data_first.command_id,
																				tokenized_dialogue, other_text_data_first.page_count);

					if (trace_all || trace_battle_text)
						ffnx_trace("Begin voice for (character ID: %d; command ID: %X) [filename: %s]\n",
									 other_text_data_first.char_id, other_text_data_first.command_id, tokenized_dialogue.c_str());

					break;
				default:
					break;
				}

				other_text_data_first.text_type = (!other_text_data_first.has_started) ? display_type::NONE : other_text_data_first.text_type;
				if(!other_text_data_first.has_started)
					end_voice();
			}

			if (text_data_first.field_2 != 0)
			{
				((void (*)(uint16_t))ff7_externals.battle_sfx_play_effect_430D14)(0x2D7);
				text_data_first.field_2 = 0;
			}

			if (text_data_first.n_frames == 0)
			{
				text_data_first.buffer_idx = -1;

				// End voice
				if (other_text_data_first.has_started)
				{
					other_text_data_first.has_started = false;
					end_voice();
				}

				for (int i = 0; i < ff7_externals.battle_display_text_queue.size(); i++)
				{
					if (text_data_first.buffer_idx == -1)
					{
						for (int j = 0; j < ff7_externals.battle_display_text_queue.size() - 1; j++)
						{
							ff7_externals.battle_display_text_queue[j] = ff7_externals.battle_display_text_queue[j + 1];
							other_battle_display_text_queue[j] = other_battle_display_text_queue[j + 1];
						}
						*ff7_externals.field_battle_word_BF2032 = 0xFFFF;
					}
				}

				return;
			}

			int show_text = (ff7_externals.battle_sub_66C3BF)();
			if (show_text)
				((void (*)(short))ff7_externals.set_battle_text_active)(text_data_first.buffer_idx);

			if (*ff7_externals.g_is_battle_paused || !*ff7_externals.g_is_battle_running_9AD1AC)
				return;

			// Ending voice
			if (other_text_data_first.has_started && other_text_data_first.follow_voice)
			{
				if (!nxAudioEngine.isVoicePlaying())
				{
					text_data_first.n_frames = 0;
				}
			}
			else
			{
				text_data_first.n_frames--;
			}
			return;
		}
		if (!*ff7_externals.g_is_battle_paused && *ff7_externals.g_is_battle_running_9AD1AC)
			text_data_first.wait_frames--;
	}

	((void (*)(short))ff7_externals.set_battle_text_active)(-1);
	*ff7_externals.field_battle_word_BF2E08 = *ff7_externals.field_battle_word_BF2E08 & 0xFFFD;
}

void ff7_display_battle_action_text()
{
	auto &effect_data = ff7_externals.effect100_array_data[*ff7_externals.effect100_array_idx];
	constexpr short VOICE_STARTED = -2;
	constexpr short VOICE_NOT_STARTED = -1;

	if(effect_data.field_6 <= 0)
	{
		// Play voice
		if(effect_data.field_6 == 0)
		{
			byte actor_id = *ff7_externals.g_active_actor_id;
			bool hasStarted = false;
			if(actor_id >= 0 && actor_id <= 2)
			{
				byte char_id = ff7_externals.battle_context->actor_vars[actor_id].index;
				byte command_id = ff7_externals.g_battle_model_state[actor_id].commandID;
				uint16_t action_id = ff7_externals.g_small_battle_model_state[actor_id].actionIdx;

				set_voice_volume();
				hasStarted = play_battle_char_action_voice(char_id, command_id, action_id);
			}
			else if(actor_id >= 4 && actor_id < 10)
			{
				uint16_t enemy_id = ff7_externals.battle_context->actor_vars[actor_id].formationID;
				byte command_id = ff7_externals.g_battle_model_state[actor_id].commandID;
				uint16_t action_id = ff7_externals.g_small_battle_model_state[actor_id].actionIdx;

				set_voice_volume();
				hasStarted = play_battle_enemy_action_voice(enemy_id, command_id, action_id);
			}

			if(hasStarted)
				effect_data.field_6 = VOICE_STARTED;
			else
				effect_data.field_6 = VOICE_NOT_STARTED;
		}

		if(effect_data.n_frames == 0)
		{
			effect_data.field_0 = 0xFFFF;
		}
		else
		{
			int show_text = (ff7_externals.battle_sub_66C3BF)();
			if(show_text)
			{
				byte command_id = ff7_externals.g_battle_model_state[*ff7_externals.g_active_actor_id].commandID;
				uint16_t action_id = ff7_externals.g_small_battle_model_state[*ff7_externals.g_active_actor_id].actionIdx;
				((void(*)(short, short))ff7_externals.display_battle_action_text_sub_6D71FA)(command_id, action_id);
				if(*ff7_externals.g_is_battle_running_9AD1AC != 0)
					effect_data.n_frames--;
			}
		}
	}
	else
	{
		if(*ff7_externals.g_is_battle_running_9AD1AC != 0)
			effect_data.field_6--;
	}
}

// -- MENU --

int ff7_menu_tutorial_render()
{
	static const int window_id = 0;
	int dialog_id = current_opcode_message_status[window_id].message_dialog_id;

	byte message_current_opcode = *ff7_externals.menu_tutorial_window_state;

	bool _is_dialog_opening = (current_opcode_message_status[window_id].message_last_opcode == 0 && message_current_opcode == 1);
	bool _is_dialog_starting = (current_opcode_message_status[window_id].message_last_opcode == 1 && message_current_opcode == 2);
	bool _is_dialog_closing = (current_opcode_message_status[window_id].message_last_opcode == 3 && message_current_opcode == 0);

	if (_is_dialog_opening)
	{
		begin_voice(window_id);
		current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	}
	else if (_is_dialog_starting)
	{
		std::string decoded_text = decode_ff7_text((char*)*ff7_externals.menu_tutorial_window_text_ptr);
		std::string tokenized_dialogue = tokenize_text(decoded_text);

		if (trace_all || trace_opcodes) ffnx_trace("[TUTOR]: id=%d,text=%s\n", dialog_id, decoded_text.c_str());

		char voice_file[MAX_PATH];
		sprintf(voice_file, "_tutor/%04u/%s", dialog_id, tokenized_dialogue.c_str());
		current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
	}
	else if (_is_dialog_closing)
	{
		end_voice(window_id);
		simulate_OK_disabled[window_id] = false;
		current_opcode_message_status[window_id].is_voice_acting = false;
	}

	// Auto close the message if it was voice acted and the audio file has finished playing
	if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
	{
		current_opcode_message_status[window_id].is_voice_acting = false;
		if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) (*ff7_externals.field_global_object_ptr)->field_80 |= 0x20;
	}

	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;

	return ff7_externals.menu_tutorial_sub_6C49FD();
}

//=============================================================================

char* ff8_battle_get_monster_name(int idx)
{
	char* ret = *((char**)*(ff8_externals.battle_char_struct_dword_1D27B10 + 0x34 * idx));

	ff8_battle_actor_name[idx] = ret;

	return ret;
}

char* ff8_battle_get_actor_name(int idx)
{
	char* ret;
	BYTE actor_id = *(ff8_externals.byte_1CFF1C3 + 0x1D0 * idx);

	if ( !actor_id )
		ret = ff8_externals.unk_1CFDC70;
	else if ( actor_id == 4 )
		ret = ff8_externals.unk_1CFDC7C;
	else if ( *(ff8_externals.word_1CF75EC + 0x12 * *(ff8_externals.byte_1CFF1C3 + 0x1D0 * idx)) == -1 )
		ret = ff8_externals.unk_1CFF84C;
	else
		ret = ff8_externals.unk_1CF3E48 + *(ff8_externals.word_1CF75EC + 0x12 * *(ff8_externals.byte_1CFF1C3 + 0x1D0 * idx)) + *ff8_externals.dword_1CF3EE0;

	ff8_battle_actor_name[idx] = ret;

	return ret;
}

char *ff8_field_get_dialog_string(char *msg, int dialog_id)
{
	ff8_current_window_dialog_id = dialog_id;

	return msg + *(uint32_t *)(msg + 4 * dialog_id);
}

int ff8_world_dialog_assign_text(int idx, int dialog_id, char *text)
{
	int window_id = *(ff8_externals.worldmap_windows_idx_map + 0x10 * idx);

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;

	return ff8_externals.world_dialog_assign_text_sub_543790(idx, dialog_id, text);
}

int ff8_world_dialog_question_assign_text(int idx, int dialog_id, char *text, int first_question, int last_question, int current_choice, uint8_t default_option)
{
	int window_id = *(ff8_externals.worldmap_windows_idx_map + 0x10 * idx);

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::ASK;
	current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;

	return ff8_externals.world_dialog_question_assign_text_sub_5438D0(idx, dialog_id, text, first_question, last_question, current_choice, default_option);
}

int ff8_opcode_voice_drawpoint(int unk)
{
	byte idx = *(byte *)(unk + 388);

	int magic_id = *(DWORD *)(unk + 4 * idx--);
	static int window_id = 6;
	static int default_option = 2;
	ff8_win_obj *win = ff8_externals.windows + window_id;

	int ret = ff8_opcode_old_drawpoint(unk);

	current_opcode_message_status[window_id].message_page_count = magic_id;
	current_opcode_message_status[window_id].message_dialog_id = ff8_current_window_dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::DRAWPOINT;
	current_opcode_message_status[window_id].field_name = "_drawpoint";

	if (ff8_current_window_dialog_id == 4)
	{
		if (opcode_ask_current_option == UCHAR_MAX)
			current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;
		else
			opcode_ask_current_option = win->current_choice_question;
	}

	return ret;
}

int ff8_opcode_voice_mes(int unk)
{
	byte idx = *(byte *)(unk + 388);

	int dialog_id = *(DWORD *)(unk + 4 * idx--);
	int window_id = *(DWORD *)(unk + 4 * idx);
	ff8_win_obj *win = ff8_externals.windows + window_id;
	int message_current_opcode = win->state;
	char* field_name = get_current_field_name();

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
	current_opcode_message_status[window_id].field_name = get_current_field_name();

	return ff8_opcode_old_mes(unk);
}

int ff8_opcode_voice_ames(int unk)
{
	byte idx = *(byte *)(unk + 388);

	idx--; // Y Position of window
	idx--; // X position of window
	int dialog_id = *(DWORD *)(unk + 4 * idx--);
	int window_id = *(DWORD *)(unk + 4 * idx);
	ff8_win_obj *win = ff8_externals.windows + window_id;
	int message_current_opcode = win->state;
	char* field_name = get_current_field_name();

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
	current_opcode_message_status[window_id].field_name = get_current_field_name();

	return ff8_opcode_old_ames(unk);
}

int ff8_opcode_voice_amesw(int unk)
{
	byte idx = *(byte *)(unk + 388);

	idx--; // Y Position of window
	idx--; // X position of window
	int dialog_id = *(DWORD *)(unk + 4 * idx--);
	int window_id = *(DWORD *)(unk + 4 * idx);
	ff8_win_obj *win = ff8_externals.windows + window_id;
	int message_current_opcode = win->state;
	char* field_name = get_current_field_name();

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
	current_opcode_message_status[window_id].field_name = get_current_field_name();

	return ff8_opcode_old_amesw(unk);
}

int ff8_opcode_voice_ramesw(int unk)
{
	byte idx = *(byte *)(unk + 388);

	idx--; // Y Position of window
	idx--; // X position of window
	int dialog_id = *(DWORD *)(unk + 4 * idx--);
	int window_id = *(DWORD *)(unk + 4 * idx);
	ff8_win_obj *win = ff8_externals.windows + window_id;
	int message_current_opcode = win->state;
	char* field_name = get_current_field_name();

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
	current_opcode_message_status[window_id].field_name = get_current_field_name();

	return ff8_opcode_old_ramesw(unk);
}

int ff8_opcode_voice_ask(int unk)
{
	byte idx = *(byte *)(unk + 388);

	idx--; // Line of cancel option
	int default_option = *(DWORD *)(unk + 4 * idx--); // Line of default option
	idx--; // Line of last option
	idx--; // Line of first option
	int dialog_id = *(DWORD *)(unk + 4 * idx--);
	int window_id = *(DWORD *)(unk + 4 * idx);
	ff8_win_obj *win = ff8_externals.windows + window_id;
	int message_current_opcode = win->state;
	char* field_name = get_current_field_name();

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::ASK;
	current_opcode_message_status[window_id].field_name = get_current_field_name();

	if (opcode_ask_current_option == UCHAR_MAX)
		current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;
	else
		opcode_ask_current_option = win->current_choice_question;

	return ff8_opcode_old_ask(unk);
}

int ff8_opcode_voice_aask(int unk)
{
	byte idx = *(byte *)(unk + 388);

	idx--; // Y Position of window
	idx--; // X position of window
	idx--; // Line of cancel option
	int default_option = *(DWORD *)(unk + 4 * idx--); // Line of default option
	idx--; // Line of last option
	idx--; // Line of first option
	int dialog_id = *(DWORD *)(unk + 4 * idx--);
	int window_id = *(DWORD *)(unk + 4 * idx);
	ff8_win_obj *win = ff8_externals.windows + window_id;
	int message_current_opcode = win->state;
	char* field_name = get_current_field_name();

	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
	current_opcode_message_status[window_id].message_kind = message_kind::ASK;
	current_opcode_message_status[window_id].field_name = get_current_field_name();

	if (opcode_ask_current_option == UCHAR_MAX)
		current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;
	else
		opcode_ask_current_option = win->current_choice_question;

	int ret = ff8_opcode_old_aask(unk);

	if (steam_edition || enable_steam_achievements) {
		if (ret == 3) // aask exit
		{
			// --- Only for unlocking chocobo achievement (only way to implement it) ---
			int chosen_option = *(DWORD*)(unk + 240);
			WORD field_id = *common_externals.current_field_id;
			bool is_field_chocobo_forest = field_id >= 287 && field_id <= 293 && field_id != 290;
			if (is_field_chocobo_forest && dialog_id == 56 && chosen_option == 0) // capture chocobo
			{
				g_FF8SteamAchievements->unlockChocoboAchievement();
			}
		}
	}
	return ret;
}

int ff8_show_dialog(int window_id, int state, int a3)
{
	struct game_mode *mode = getmode_cached();

	int dialog_id = current_opcode_message_status[window_id].message_dialog_id;
	ff8_win_obj *win = ff8_externals.windows + window_id;
	uint32_t message_current_opcode = win->state;
	message_kind message_kind = current_opcode_message_status[window_id].message_kind;
	std::string field_name = current_opcode_message_status[window_id].field_name;
	byte message_page_count = current_opcode_message_status[window_id].message_page_count;
	if (mode->driver_mode == MODE_WORLDMAP && message_kind == message_kind::ASK) opcode_ask_current_option = win->current_choice_question;

	bool _is_dialog_opening = is_dialog_opening(win->open_close_transition);
	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_transition, win->open_close_transition);
	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
	bool _is_dialog_option_changed = (current_opcode_message_status[window_id].message_last_option != opcode_ask_current_option);
	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_transition, win->open_close_transition);
	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_transition, win->open_close_transition);
	bool _is_dialog_ask = (message_kind == message_kind::ASK) || (message_kind == message_kind::DRAWPOINT);

	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;

	// Skip voice over on Tutorials
	if (mode->driver_mode == MODE_FIELD)
	{
		if (_is_dialog_opening)
		{
			opcode_ask_current_option = UCHAR_MAX;
			begin_voice(window_id);
			current_opcode_message_status[window_id].message_dialog_id = dialog_id;
			current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;
			current_opcode_message_status[window_id].message_kind = message_kind;
			current_opcode_message_status[window_id].field_name = field_name;
			if (message_kind == message_kind::DRAWPOINT) current_opcode_message_status[window_id].message_page_count = message_page_count;
			if (message_kind == message_kind::MESSAGE)
			{
				if (ff8_field_window_stack_count.find(*common_externals.current_field_id) == ff8_field_window_stack_count.end())
					ff8_field_window_stack_count[*common_externals.current_field_id] = 0;

				ff8_field_window_stack_count[*common_externals.current_field_id]++;

				if (ff8_field_window_stack_count[*common_externals.current_field_id] > 1) simulate_OK_disabled[window_id] = true;
			}
		}
		else if (_is_dialog_starting || _is_dialog_paging)
		{
			if (_is_dialog_starting) current_opcode_message_status[window_id].char_id = 0; // TODO
			if (trace_all || trace_opcodes) ffnx_trace("[MESSAGE]: field=%s,window_id=%u,dialog_id=%u,paging_id=%u,char=%X\n", field_name.c_str(), window_id, dialog_id, current_opcode_message_status[window_id].message_page_count, current_opcode_message_status[window_id].char_id);
			current_opcode_message_status[window_id].is_voice_acting = play_voice((char*)field_name.c_str(), window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
		}
		else if (_is_dialog_option_changed && _is_dialog_ask)
		{
			if (trace_all || trace_opcodes) ffnx_trace("[ASK]: field=%s,window_id=%u,dialog_id=%u,option_id=%u,char=%X\n", field_name.c_str(), window_id, dialog_id, opcode_ask_current_option,current_opcode_message_status[window_id].char_id);
			play_option((char*)field_name.c_str(), window_id, dialog_id, opcode_ask_current_option);
		}
		else if (_is_dialog_closing)
		{
			end_voice(window_id);
			simulate_OK_disabled[window_id] = false;
			current_opcode_message_status[window_id].is_voice_acting = false;
			opcode_ask_current_option = UCHAR_MAX;
			ff8_current_window_dialog_id = -1;
			if (message_kind == message_kind::MESSAGE)
			{
				if (ff8_field_window_stack_count[*common_externals.current_field_id] > 0)
					ff8_field_window_stack_count[*common_externals.current_field_id]--;
			}
		}

		// Auto close the message if it was voice acted and the audio file has finished playing
		if (message_kind == message_kind::MESSAGE)
		{
			if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
			{
				current_opcode_message_status[window_id].is_voice_acting = false;
				if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
			}
		}
	}
	else if (mode->driver_mode == MODE_BATTLE)
	{
		bool _has_dialog_text_changed = win->field_30 != current_opcode_message_status[window_id].message_dialog_id;
		bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_transition, message_current_opcode);

		if (_is_dialog_opening)
		{
			begin_voice(window_id);
		}
		else if (_is_dialog_starting || _has_dialog_text_changed)
		{
			std::string decoded_text = ff8_decode_text(win->text_data1);
			std::string tokenized_dialogue = tokenize_text(decoded_text);
			std::string actor_name = ff8_decode_text(ff8_battle_actor_name[LOBYTE(*ff8_externals.battle_current_actor_talking)]);
			std::string tokenized_actor = tokenize_text(actor_name);

			if (trace_all || trace_opcodes || trace_battle_text) ffnx_trace("[BATTLE]: scene_id=%u,actor=%s,text=%s\n", *ff8_externals.battle_encounter_id, actor_name.c_str(), decoded_text.c_str());

			char voice_file[MAX_PATH];
			sprintf(voice_file, "_battle/%s/%s", tokenized_actor.c_str(), tokenized_dialogue.c_str());
			current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
		}
		else if (_is_dialog_closing)
		{
			end_voice(window_id);
			current_opcode_message_status[window_id].is_voice_acting = false;
		}

		current_opcode_message_status[window_id].message_dialog_id = win->field_30;
	}
	else if (mode->driver_mode == MODE_WORLDMAP)
	{
		bool _has_dialog_text_changed = dialog_id != current_opcode_message_status[window_id].message_last_dialog_id;

		if (_is_dialog_opening)
		{
			begin_voice(window_id);
			current_opcode_message_status[window_id].message_dialog_id = dialog_id;
			current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;
			current_opcode_message_status[window_id].message_kind = message_kind;
		}
		else if (_is_dialog_starting || _has_dialog_text_changed)
		{
			if (dialog_id < 0)
			{
				std::string decoded_text = ff8_decode_text(win->text_data1);
				std::string tokenized_dialogue = tokenize_text(decoded_text);
				if (trace_all || trace_opcodes) ffnx_trace("[WORLD]: window_id=%u,text=%s\n", window_id, decoded_text.c_str());

				char voice_file[MAX_PATH];
				sprintf(voice_file, "_world/text/%s", tokenized_dialogue.c_str());
				current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
			}
			else
			{
				if (trace_all || trace_opcodes) ffnx_trace("[WORLD]: window_id=%u,dialog_id=%d\n", window_id, current_opcode_message_status[window_id].message_dialog_id);
				current_opcode_message_status[window_id].is_voice_acting = play_voice("_world", window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
			}
		}
		else if (_is_dialog_option_changed && _is_dialog_ask)
		{
			if (trace_all || trace_opcodes) ffnx_trace("[WORLD]: window_id=%u,dialog_id=%u,option_id=%u,char=%X\n", window_id, dialog_id, opcode_ask_current_option,current_opcode_message_status[window_id].char_id);
			play_option("_world", window_id, dialog_id, opcode_ask_current_option);
		}
		else if (_is_dialog_closing)
		{
			end_voice(window_id);
			current_opcode_message_status[window_id].is_voice_acting = false;
		}

		// Auto close the message if it was voice acted and the audio file has finished playing
		if (message_kind == message_kind::MESSAGE)
		{
			if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
			{
				current_opcode_message_status[window_id].is_voice_acting = false;
				if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
			}
		}
	}
	else if (mode->mode == FF8_MODE_TUTO)
	{
		bool _has_dialog_text_changed = win->field_30 != current_opcode_message_status[window_id].message_dialog_id;
		bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_transition, message_current_opcode);

		if (_is_dialog_opening)
		{
			begin_voice(window_id);
		}
		else if (_is_dialog_starting || _has_dialog_text_changed)
		{
			std::string decoded_text = ff8_decode_text(win->text_data1);
			std::string tokenized_dialogue = tokenize_text(decoded_text);

			if (trace_all || trace_opcodes || trace_battle_text) ffnx_trace("[TUTO]: id=%u,text=%s\n", *ff8_externals.current_tutorial_id, decoded_text.c_str());

			char voice_file[MAX_PATH];
			sprintf(voice_file, "_tuto/%04u/%s", *ff8_externals.current_tutorial_id, tokenized_dialogue.c_str());
			current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
		}
		else if (_is_dialog_closing)
		{
			end_voice(window_id);
			simulate_OK_disabled[window_id] = false;
			current_opcode_message_status[window_id].is_voice_acting = false;
		}

		current_opcode_message_status[window_id].message_dialog_id = win->field_30;

		if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
		{
			current_opcode_message_status[window_id].is_voice_acting = false;
			if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
		}
	}

	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
	current_opcode_message_status[window_id].message_last_transition = win->open_close_transition;
	current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;
	current_opcode_message_status[window_id].message_last_dialog_id = dialog_id;

	return ff8_externals.show_dialog(window_id, state, a3);
}

//=============================================================================

void voice_init()
{
	// Prepare up to 10 voice slots
	nxAudioEngine.setVoiceMaxSlots(10);

	if (!ff8)
	{
		ff7_set_master_music_volume = (void (*)(uint32_t))common_externals.set_master_midi_volume;

		opcode_old_message = (int (*)())ff7_externals.opcode_message;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x40], (DWORD)&opcode_voice_message);

		opcode_old_ask = (int (*)(int))ff7_externals.opcode_ask;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x48], (DWORD)&opcode_voice_ask);
		replace_call_function((uint32_t)ff7_externals.opcode_ask + 0x8E, opcode_voice_parse_options);

		opcode_old_wmode = (int (*)())ff7_externals.opcode_wmode;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x52], (DWORD)&opcode_wmode);

		opcode_wm_old_message = (int (*)(uint8_t,uint8_t))ff7_externals.world_opcode_message;
		replace_call_function(ff7_externals.world_opcode_message_sub_75EE86 + 0x2B, opcode_wm_message);
		replace_call_function(ff7_externals.world_sub_75EF46 + 0x8C, opcode_wm_message);

		opcode_wm_old_ask = (int (*)(uint8_t,uint8_t,uint8_t,uint8_t,WORD*))ff7_externals.world_opcode_ask;
		replace_call_function(ff7_externals.world_opcode_ask_sub_75EEBB + 0x3C, opcode_wm_ask);
		replace_call_function(ff7_externals.world_sub_75EF46 + 0xAF, opcode_wm_ask);

		opcode_old_tutor = (int (*)())ff7_externals.opcode_tutor;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x21], (DWORD)&opcode_voice_tutor);

		replace_function(ff7_externals.add_text_to_display_queue, ff7_add_text_to_display_queue);
		replace_function(ff7_externals.update_display_text_queue, ff7_update_display_text_queue);
		replace_function(ff7_externals.display_battle_action_text_42782A, ff7_display_battle_action_text);
		replace_call_function(ff7_externals.run_enemy_ai_script + 0xB7F, ff7_enqueue_script_display_string);
		replace_call_function(ff7_externals.menu_sub_6CB56A + 0x2B7, ff7_menu_tutorial_render);
	}
	else
	{
		// == Field ==
		// All possible message and ask windows
		ff8_opcode_old_mes = (int (*)(int))ff8_externals.opcode_mes;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x47], (DWORD)&ff8_opcode_voice_mes);

		ff8_opcode_old_ames = (int (*)(int))ff8_externals.opcode_ames;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x65], (DWORD)&ff8_opcode_voice_ames);

		ff8_opcode_old_amesw = (int (*)(int))ff8_externals.opcode_amesw;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x64], (DWORD)&ff8_opcode_voice_amesw);

		ff8_opcode_old_ramesw = (int (*)(int))ff8_externals.opcode_ramesw;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x116], (DWORD)&ff8_opcode_voice_ramesw);

		ff8_opcode_old_ask = (int (*)(int))ff8_externals.opcode_ask;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x4A], (DWORD)&ff8_opcode_voice_ask);

		ff8_opcode_old_aask = (int (*)(int))ff8_externals.opcode_aask;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x6F], (DWORD)&ff8_opcode_voice_aask);

		ff8_opcode_old_drawpoint = (int (*)(int))ff8_externals.opcode_drawpoint;
		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x137], (DWORD)&ff8_opcode_voice_drawpoint);

		replace_function(ff8_externals.field_get_dialog_string, ff8_field_get_dialog_string);
		replace_call(ff8_externals.sub_4A0C00 + 0x5F, ff8_show_dialog);

		// == Battle ==
		replace_function(ff8_externals.battle_get_monster_name_sub_495100, ff8_battle_get_monster_name);
		replace_function(ff8_externals.battle_get_actor_name_sub_47EAF0, ff8_battle_get_actor_name);

		// == World Map ==
		replace_call_function(ff8_externals.sub_543CB0 + (FF8_US_VERSION ? 0x638 : (FF8_SP_VERSION || FF8_IT_VERSION) ? 0x61C : 0x605), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_5484B0 + (FF8_US_VERSION ? 0x524 : 0x4FD), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54A230 + (FF8_US_VERSION ? 0xF : 0xD), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54D7E0 + (FF8_US_VERSION ? 0x72 : 0x6F), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x206 : 0x20C), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x396 : 0x3A9), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x3D2 : 0x3E5), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x67D : (FF8_SP_VERSION ? 0x6CA : 0x68F)), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x6A6 : (FF8_SP_VERSION ? 0x6F7 : 0x6BC)), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0xEED : (FF8_SP_VERSION ? 0xFAD : 0xF72)), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54FDA0 + (FF8_US_VERSION ? 0xAE : 0xAC), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_54FDA0 + (FF8_US_VERSION ? 0x178 : 0x175), ff8_world_dialog_assign_text);
		replace_call_function(ff8_externals.sub_543CB0 + (FF8_US_VERSION ? 0x5EE : (FF8_SP_VERSION || FF8_IT_VERSION) ? 0x5D2 : 0x5BB), ff8_world_dialog_question_assign_text);
		replace_call_function(ff8_externals.sub_5484B0 + (FF8_US_VERSION ? 0xBD : 0x131), ff8_world_dialog_question_assign_text);
		replace_call_function(ff8_externals.sub_5484B0 + (FF8_US_VERSION ? 0x24F : 0x244), ff8_world_dialog_question_assign_text);
		replace_call_function(ff8_externals.sub_54D7E0 + (FF8_US_VERSION ? 0x119 : 0x116), ff8_world_dialog_question_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x621 : (FF8_SP_VERSION ? 0x66A : 0x62F)), ff8_world_dialog_question_assign_text);
		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0xBE4 : (FF8_SP_VERSION ? 0xC99 : 0xC5E)), ff8_world_dialog_question_assign_text);
	}
}
````

## File: src/voice.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

void voice_init();
void ff7_handle_wmode_reset();
````

## File: src/widescreen.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Tang-Tang Zhou                                     //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

int wide_viewport_x = -107;
int wide_viewport_y = 0;
int wide_viewport_width = 854;
int wide_viewport_height = 480;

int wide_game_x = 0;
int wide_game_y = 0;
int wide_game_width = 854;
int wide_game_height = 480;
````

## File: src/wine.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//    Copyright (C) 2023 Cosmos                                             //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

#include <windows.h>

typedef const char* (*WineVersionFunction)();
inline const char* GetWineVersion() {
    HMODULE hModule = LoadLibraryA("ntdll.dll");
    if (!hModule) {
        return "Wine is not detected.";
    }

    WineVersionFunction wine_get_version = (WineVersionFunction)GetProcAddress(hModule, "wine_get_version");
    if (!wine_get_version) {
        FreeLibrary(hModule);
        return "Wine is not detected.";
    }

    const char* version = wine_get_version();
    FreeLibrary(hModule);
    return version;
}
````

## File: src/world.cpp
````cpp
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2020 Marcin Gomulak                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#include <imgui.h>
#include <stdint.h>

#include "globals.h"
#include "common.h"
#include "patch.h"

#include "world.h"


//https://stackoverflow.com/a/19885112/4509036
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')


WORD* cameraZoom;
DWORD* playerPosX; //203EE80
DWORD* playerPosZ; //+1
DWORD* playerPosY; //+1; it's dword, but later in game it's &0xFFFF
BYTE* collisionTriangleGroundType; //0x2035D2E
BYTE* collisionTriangleTextureFlag; //+1

DWORD* currentCollideTriangle; //ESI+0x1C / 53CEE9
DWORD* bCollisionEnabled;

void world_init()
{
	if (ff8)
	{
		cameraZoom = (WORD*)get_absolute_value(ff8_externals.sub_4023D0, 0x10);
		playerPosX = (DWORD*)get_absolute_value(ff8_externals.sub_53BB90, 0x4C);
		playerPosZ = playerPosX+1;
		playerPosY = playerPosX+2;
		BYTE *wm_struct;
		if(FF8_US_VERSION)
		{
			wm_struct = (BYTE*)get_absolute_value(ff8_externals.sub_53C750, 0x633);
			bCollisionEnabled = (DWORD*)get_absolute_value(ff8_externals.sub_53E6B0, 0x4);
		}
		else
		{
			wm_struct = (BYTE*)get_absolute_value(ff8_externals.sub_53C750, 0x649);
			bCollisionEnabled = (DWORD*)get_absolute_value(ff8_externals.sub_53E6B0, 0x1);
		}
		collisionTriangleGroundType = wm_struct + 0x26;
		collisionTriangleTextureFlag = collisionTriangleGroundType + 1;

		currentCollideTriangle = (DWORD*)(wm_struct + 0x1C);
	}
}

void world_debug(bool* isOpen)
{
	if (!ImGui::Begin("World Debug", isOpen, ImGuiWindowFlags_::ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::End();
		return;
	}

	if (getmode_cached()->driver_mode != MODE_WORLDMAP)
	{
		ImGui::Text("Not currently on a worldmap.");
		ImGui::End();
		return;
	}

	ImGui::SliderInt("Camera zoom ", (int*)cameraZoom, 0, 9000);
	ImGui::Text("	Player position:"); //didn't use InputInt3 because it's XZ-Y not XYZ
	ImGui::InputInt("X", (int*)playerPosX, 10);
	ImGui::SameLine();
	ImGui::InputInt("Y", (int*)playerPosY, 10);
	ImGui::SameLine();
	ImGui::InputInt("Z", (int*)playerPosZ, 10);
	ImGui::Checkbox("Enable collision", (bool*)bCollisionEnabled);
	ImGui::Text("	Current collide triangle:");
	ImGui::Text("Ground type: %d, texture flag: 0b%c%c%c%c%c%c%c%c", //this is cool stuff
		*collisionTriangleGroundType,
		BYTE_TO_BINARY(*collisionTriangleTextureFlag)
		);
	ImGui::Text("triangle pointer: %08X:", *currentCollideTriangle);

	if (*currentCollideTriangle != 0) //this is to prevent nullptr crashes
	{
		ImU8 u8step = 1;
		ImU8 u8stepTen = 10;
		int tPage, clut, texFlags, vertFlags;
		bool texFlagsBool[8];
		bool vertFlagsBool[8];
		tPage = (*((BYTE*)*currentCollideTriangle + 12) >> 4) & 0x0F;
		clut = *((BYTE*)*currentCollideTriangle + 12) &0x0F;
		texFlags = *((BYTE*)*currentCollideTriangle + 14);
		vertFlags = *((BYTE*)*currentCollideTriangle + 15);

		for (int i = 0; i < 8; i++)
		{
			texFlagsBool[i] = ((texFlags >> 7 - i) & 0b1) == 1;
			vertFlagsBool[i] = ((vertFlags >> 7 - i) & 0b1) == 1;
		}

		ImGui::InputScalar("F1", ImGuiDataType_U8 ,(BYTE*)*currentCollideTriangle, &u8step, &u8stepTen, "%d");
		ImGui::SameLine();
		ImGui::InputScalar("F2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 1, &u8step, &u8stepTen, "%d");
		ImGui::SameLine();
		ImGui::InputScalar("F3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 2, &u8step, &u8stepTen, "%d");

		ImGui::InputScalar("N1", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 3, &u8step, &u8stepTen, "%d");
		ImGui::SameLine();
		ImGui::InputScalar("N2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 4, &u8step, &u8stepTen, "%d");
		ImGui::SameLine();
		ImGui::InputScalar("N3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 5, &u8step, &u8stepTen, "%d");

		ImGui::InputScalar("U1", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 6, &u8step, &u8stepTen, "%d");
		ImGui::SameLine();
		ImGui::InputScalar("V1", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 7, &u8step, &u8stepTen, "%d");
		ImGui::InputScalar("U2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 8, &u8step, &u8stepTen, "%d");
		ImGui::SameLine();
		ImGui::InputScalar("V2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 9, &u8step, &u8stepTen, "%d");
		ImGui::InputScalar("U3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 10, &u8step, &u8stepTen, "%d");
		ImGui::SameLine();
		ImGui::InputScalar("V3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 11, &u8step, &u8stepTen, "%d");

		ImGui::InputInt("TPage", &tPage);
		ImGui::InputInt("Clut", &clut);
		ImGui::InputScalar("Ground type", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 13, &u8step, &u8stepTen, "%d");

		ImGui::Text("TEXFLAGS:");
		ImGui::Checkbox("TEXFLAGS_MISC", &texFlagsBool[0]);
		ImGui::Checkbox("TEXFLAGS_WATER", &texFlagsBool[1]);
		ImGui::Checkbox("TEXFLAGS_ROAD", &texFlagsBool[2]);
		ImGui::Checkbox("TEXFLAGS_TRANSPARENT", &texFlagsBool[3]);
		ImGui::Checkbox("TEXFLAGS_ENTERABLE", &texFlagsBool[4]);
		ImGui::Checkbox("TEXFLAGS_UNK", &texFlagsBool[5]);
		ImGui::Checkbox("TEXFLAGS_SHADOW1", &texFlagsBool[6]);
		ImGui::Checkbox("TEXFLAGS_SHADOW2", &texFlagsBool[7]);
		texFlags = 0;
		texFlags |= texFlagsBool[0] ? 0x80 : 00;
		texFlags |= texFlagsBool[1] ? 0x40 : 00;
		texFlags |= texFlagsBool[2] ? 0x20 : 00;
		texFlags |= texFlagsBool[3] ? 0x10 : 00;
		texFlags |= texFlagsBool[4] ? 0x08 : 00;
		texFlags |= texFlagsBool[5] ? 0x04 : 00;
		texFlags |= texFlagsBool[6] ? 0x02 : 00;
		texFlags |= texFlagsBool[7] ? 0x01 : 00;

		ImGui::Text("VERTFLAGS:");
		ImGui::Checkbox("VERTFLAGS_WALKABLE", &vertFlagsBool[0]);
		ImGui::Checkbox("VERTFLAGS_UNK", &vertFlagsBool[1]);
		ImGui::Checkbox("VERTFLAGS_UNK2", &vertFlagsBool[2]);
		ImGui::Checkbox("VERTFLAGS_WALKABLECHOCOBO?", &vertFlagsBool[3]);
		ImGui::Checkbox("VERTFLAGS_UNK3", &vertFlagsBool[4]);
		ImGui::Checkbox("VERTFLAGS_UNK4", &vertFlagsBool[5]);
		ImGui::Checkbox("VERTFLAGS_UNK5", &vertFlagsBool[6]);
		ImGui::Checkbox("VERTFLAGS_UNK6", &vertFlagsBool[7]);
		vertFlags = 0;
		vertFlags |= vertFlagsBool[0] ? 0x80 : 00;
		vertFlags |= vertFlagsBool[1] ? 0x40 : 00;
		vertFlags |= vertFlagsBool[2] ? 0x20 : 00;
		vertFlags |= vertFlagsBool[3] ? 0x10 : 00;
		vertFlags |= vertFlagsBool[4] ? 0x08 : 00;
		vertFlags |= vertFlagsBool[5] ? 0x04 : 00;
		vertFlags |= vertFlagsBool[6] ? 0x02 : 00;
		vertFlags |= vertFlagsBool[7] ? 0x01 : 00;

		*((BYTE*)*currentCollideTriangle + 12) = (BYTE)(tPage<<4 | clut);
		*((BYTE*)*currentCollideTriangle + 14) = (BYTE)texFlags;
		*((BYTE*)*currentCollideTriangle + 15) = (BYTE)vertFlags;
	}


	ImGui::End();
}
````

## File: src/world.h
````
/****************************************************************************/
//    Copyright (C) 2009 Aali132                                            //
//    Copyright (C) 2018 quantumpencil                                      //
//    Copyright (C) 2018 Maxime Bacoux                                      //
//    Copyright (C) 2020 myst6re                                            //
//    Copyright (C) 2020 Chris Rizzitello                                   //
//    Copyright (C) 2020 John Pritchard                                     //
//    Copyright (C) 2020 Marcin Gomulak                                     //
//    Copyright (C) 2025 Julian Xhokaxhiu                                   //
//                                                                          //
//    This file is part of FFNx                                             //
//                                                                          //
//    FFNx is free software: you can redistribute it and/or modify          //
//    it under the terms of the GNU General Public License as published by  //
//    the Free Software Foundation, either version 3 of the License         //
//                                                                          //
//    FFNx is distributed in the hope that it will be useful,               //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
//    GNU General Public License for more details.                          //
/****************************************************************************/

#pragma once

void world_init();
void world_debug(bool* isOpen);
````

## File: .editorconfig
````
# EditorConfig is awesome: https://EditorConfig.org

root = true

[*]
end_of_line = lf
indent_size = 2
indent_style = space
insert_final_newline = true
trim_trailing_whitespace = true
````

## File: .gitignore
````
## Get latest from https://github.com/github/gitignore/blob/main/C%2B%2B.gitignore

# Prerequisites
*.d

# Compiled Object files
*.slo
*.lo
*.o
*.obj

# Precompiled Headers
*.gch
*.pch

# Compiled Dynamic libraries
*.so
*.dylib
*.dll

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai
*.la
*.a
*.lib

# Executables
*.exe
*.out
*.app

## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
# but not Directory.Build.rsp, as it configures directory-level build defaults
!Directory.Build.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml

## Get latest from https://github.com/github/gitignore/blob/main/CMake.gitignore

CMakeLists.txt.user
CMakeCache.txt
CMakeFiles
CMakeScripts
Testing
Makefile
cmake_install.cmake
install_manifest.txt
compile_commands.json
CTestTestfile.cmake
_deps
CMakeUserPresets.json

## Get latest from https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore

# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider
# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839

# User-specific stuff
.idea/**/workspace.xml
.idea/**/tasks.xml
.idea/**/usage.statistics.xml
.idea/**/dictionaries
.idea/**/shelf

# AWS User-specific
.idea/**/aws.xml

# Generated files
.idea/**/contentModel.xml

# Sensitive or high-churn files
.idea/**/dataSources/
.idea/**/dataSources.ids
.idea/**/dataSources.local.xml
.idea/**/sqlDataSources.xml
.idea/**/dynamic.xml
.idea/**/uiDesigner.xml
.idea/**/dbnavigator.xml

# Gradle
.idea/**/gradle.xml
.idea/**/libraries

# Gradle and Maven with auto-import
# When using Gradle or Maven with auto-import, you should exclude module files,
# since they will be recreated, and may cause churn.  Uncomment if using
# auto-import.
# .idea/artifacts
# .idea/compiler.xml
# .idea/jarRepositories.xml
# .idea/modules.xml
# .idea/*.iml
# .idea/modules
# *.iml
# *.ipr

# CMake
cmake-build-*/

# Mongo Explorer plugin
.idea/**/mongoSettings.xml

# File-based project format
*.iws

# IntelliJ
out/

# mpeltonen/sbt-idea plugin
.idea_modules/

# JIRA plugin
atlassian-ide-plugin.xml

# Cursive Clojure plugin
.idea/replstate.xml

# SonarLint plugin
.idea/sonarlint/
.idea/sonarlint.xml # see https://community.sonarsource.com/t/is-the-file-idea-idea-idea-sonarlint-xml-intended-to-be-under-source-control/121119

# Crashlytics plugin (for Android Studio and IntelliJ)
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties
fabric.properties

# Editor-based Rest Client
.idea/httpRequests

# Android studio 3.1+ serialized cache file
.idea/caches/build_file_checksums.ser

## Custom section

# Build directory
.build

# vcpkg
vcpkg_installed/
````

## File: .gitmodules
````
[submodule "vcpkg"]
	path = vcpkg
	url = https://github.com/microsoft/vcpkg.git
````

## File: .vsconfig
````
{
  "version": "1.0",
  "components": [
    "Microsoft.VisualStudio.Component.CoreEditor",
    "Microsoft.VisualStudio.Workload.CoreEditor",
    "Microsoft.Net.Component.4.8.SDK",
    "Microsoft.Net.Component.4.7.2.TargetingPack",
    "Microsoft.Net.ComponentGroup.DevelopmentPrerequisites",
    "Microsoft.VisualStudio.ComponentGroup.WebToolsExtensions",
    "Microsoft.VisualStudio.Component.Roslyn.Compiler",
    "Microsoft.Component.MSBuild",
    "Microsoft.VisualStudio.Component.Roslyn.LanguageServices",
    "Microsoft.VisualStudio.Component.TextTemplating",
    "Microsoft.VisualStudio.Component.NuGet",
    "Microsoft.VisualStudio.Component.SQL.CLR",
    "Microsoft.Component.ClickOnce",
    "Microsoft.VisualStudio.Component.ManagedDesktop.Core",
    "Microsoft.NetCore.Component.Runtime.6.0",
    "Microsoft.NetCore.Component.SDK",
    "Microsoft.VisualStudio.Component.FSharp",
    "Microsoft.ComponentGroup.ClickOnce.Publish",
    "Microsoft.NetCore.Component.DevelopmentTools",
    "Microsoft.Net.Component.4.8.TargetingPack",
    "Microsoft.Net.ComponentGroup.4.8.DeveloperTools",
    "Microsoft.VisualStudio.Component.DiagnosticTools",
    "Microsoft.VisualStudio.Component.EntityFramework",
    "Microsoft.VisualStudio.Component.Debugger.JustInTime",
    "Microsoft.VisualStudio.Component.IntelliCode",
    "Microsoft.Net.Component.4.6.2.TargetingPack",
    "Microsoft.Net.Component.4.7.TargetingPack",
    "Microsoft.Net.Component.4.7.1.TargetingPack",
    "Microsoft.VisualStudio.Component.VC.CoreIde",
    "Microsoft.VisualStudio.Component.Windows10SDK",
    "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
    "Microsoft.VisualStudio.Component.Graphics.Tools",
    "Microsoft.VisualStudio.Component.VC.DiagnosticTools",
    "Microsoft.VisualStudio.Component.Windows10SDK.19041",
    "Microsoft.VisualStudio.Component.ManagedDesktop.Prerequisites",
    "Microsoft.ComponentGroup.Blend",
    "Microsoft.VisualStudio.ComponentGroup.MSIX.Packaging",
    "Microsoft.VisualStudio.Workload.ManagedDesktop",
    "Microsoft.VisualStudio.Component.VC.Redist.14.Latest",
    "Microsoft.VisualStudio.ComponentGroup.NativeDesktop.Core",
    "Microsoft.VisualStudio.ComponentGroup.WebToolsExtensions.CMake",
    "Microsoft.VisualStudio.Component.VC.CMake.Project",
    "Microsoft.VisualStudio.Component.VC.ATL",
    "Microsoft.VisualStudio.Component.VC.TestAdapterForBoostTest",
    "Microsoft.VisualStudio.Component.VC.TestAdapterForGoogleTest",
    "Microsoft.VisualStudio.Component.VC.ASAN",
    "Microsoft.VisualStudio.Component.Windows10SDK.20348",
    "Microsoft.VisualStudio.Workload.NativeDesktop",
    "Microsoft.Net.ComponentGroup.TargetingPacks.Common",
    "Microsoft.Net.Component.4.6.TargetingPack",
    "Microsoft.Net.Component.4.6.1.TargetingPack"
  ]
}
````

## File: cmake-format.yaml
````yaml
# cmake-format yaml configuration file

format:
  dangle_align: prefix
  fractional_tab_policy: use-space
  line_width: 150

markup:
  enable_markup: false
````

## File: CMakeLists.txt
````
#*****************************************************************************#
#    Copyright (C) 2009 Aali132                                               #
#    Copyright (C) 2018 quantumpencil                                         #
#    Copyright (C) 2018 Maxime Bacoux                                         #
#    Copyright (C) 2020 myst6re                                               #
#    Copyright (C) 2020 Chris Rizzitello                                      #
#    Copyright (C) 2020 John Pritchard                                        #
#    Copyright (C) 2025 Julian Xhokaxhiu                                      #
#                                                                             #
#    This file is part of FFNx                                                #
#                                                                             #
#    FFNx is free software: you can redistribute it and/or modify             #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License            #
#                                                                             #
#    FFNx is distributed in the hope that it will be useful,                  #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#*****************************************************************************#

cmake_minimum_required(VERSION 3.25)
cmake_policy(SET CMP0091 NEW)

if(NOT DEFINED CMAKE_BUILD_TYPE)
  message(FATAL_ERROR "CMAKE_BUILD_TYPE must be set to continue building with cmake. \nExample: Add -DCMAKE_BUILD_TYPE=Release to your cmake command line.")
endif()
if (NOT DEFINED _DLL_VERSION OR NOT _DLL_VERSION)
  message(FATAL_ERROR "_DLL_VERSION must be set to continue building with cmake. \nExample: Add -D_DLL_VERSION=devel to your cmake command line.")
endif ()

set(VCPKG_DISABLE_COMPILER_TRACKING 1)
set(VCPKG_INSTALL_OPTIONS "--clean-after-build" "--allow-unsupported")

set(CMAKE_SHARED_LINKER_FLAGS
  "${CMAKE_SHARED_LINKER_FLAGS} /NODEFAULTLIB:MSVCRT /NODEFAULTLIB:MSVCRTD /DEBUG:FULL /FORCE:MULTIPLE /IGNORE:4006,4075,4099,4217"
)

if(CMAKE_BUILD_TYPE MATCHES Debug)
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /NODEFAULTLIB:LIBCMT")
else()
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded")
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /NODEFAULTLIB:LIBCMTD")
endif()

set(BGFX_SHADERC_OPENGL_FLAGS --profile 120)
set(BGFX_SHADERC_DIRECT3D_FLAGS --platform windows -p s_5_0)
set(BGFX_SHADERC_VULKAN_FLAGS --platform windows --profile spirv)

if(CMAKE_BUILD_TYPE MATCHES Release OR CMAKE_BUILD_TYPE MATCHES MinSizeRel)
  list(APPEND BGFX_SHADERC_DIRECT3D_FLAGS -O3)
else()
  list(APPEND BGFX_SHADERC_DIRECT3D_FLAGS --debug -O0)
  list(APPEND BGFX_SHADERC_VULKAN_FLAGS --debug -O0)
endif()

option(FORCEHEAP "Force all allocation to our heap" OFF)
if(FORCEHEAP)
  add_definitions(-DNO_EXT_HEAP)
endif()

option(TRACEHEAP "Trace and keep count of every allocation made by this program" OFF)
if(TRACEHEAP)
  add_definitions(-DHEAP_DEBUG)
endif()

option(PROFILING "Enable Profiling" OFF)
if(PROFILING)
  add_definitions(-DPROFILE)
endif()

project(FFNx)

find_package(ZLIB REQUIRED)
find_package(BX REQUIRED)
find_package(BIMG REQUIRED)
find_package(BGFX REQUIRED)
find_package(FFMPEG REQUIRED)
find_package(MPG123 REQUIRED)
find_package(Vorbis CONFIG REQUIRED)
find_package(VGMSTREAM REQUIRED)
find_package(STACKWALKER REQUIRED)
find_package(pugixml CONFIG REQUIRED)
find_package(PNG REQUIRED)
find_package(directxtex CONFIG REQUIRED)
find_package(mimalloc CONFIG REQUIRED)
find_package(imgui CONFIG REQUIRED)
find_package(SOLOUD REQUIRED)
find_package(OPENPSF REQUIRED)
find_package(STEAMWORKSSDK CONFIG REQUIRED)
find_package(xxHash CONFIG REQUIRED)
find_package(LZ4 REQUIRED)
find_package(CMakeRC CONFIG REQUIRED)
find_package(lfreist-hwinfo CONFIG REQUIRED)
find_package(cryptopp CONFIG REQUIRED)
find_package(tomlplusplus CONFIG REQUIRED)

set(RELEASE_NAME "FFNx")

if(_DLL_VERSION STREQUAL "devel" OR _DLL_VERSION MATCHES "-")
  set(_DLL_RCVERSION "0,0,0,0")
  set(_DLL_RCSTRVERSION "0.0.0.0")
  set(PATCH_COLLECT_DUPLICATES 1)
else()
  string(REPLACE "." "," _DLL_RCVERSION ${_DLL_VERSION})
  set(_DLL_RCSTRVERSION ${_DLL_VERSION})
endif()

# Choco driver
set(CHOCO_RELEASE_NAME "FFNx-Choco")
file(GLOB_RECURSE choco_source_files "${CMAKE_SOURCE_DIR}/choco/*.cpp")
add_library(${CHOCO_RELEASE_NAME} SHARED ${choco_source_files} ${CMAKE_CURRENT_BINARY_DIR}/version.rc)
target_include_directories(
  ${CHOCO_RELEASE_NAME}
  PRIVATE "${CMAKE_SOURCE_DIR}/choco"
)
target_link_libraries(
  ${CHOCO_RELEASE_NAME}
  shlwapi
)
target_compile_options(
  ${CHOCO_RELEASE_NAME}
  PRIVATE /DVERSION="${_DLL_VERSION}"
  PRIVATE /D_CRT_SECURE_NO_WARNINGS
  PRIVATE /DNOMINMAX
  PRIVATE /Zc:strictStrings-
  PRIVATE /Zc:__cplusplus
  PRIVATE /Zc:preprocessor
  PRIVATE /Qpar
  PRIVATE /MP
)
target_compile_features(${CHOCO_RELEASE_NAME}
  PRIVATE cxx_std_20
)
target_link_options(${CHOCO_RELEASE_NAME} PRIVATE /PDBALTPATH:${CHOCO_RELEASE_NAME}.pdb PRIVATE /DEF:${CMAKE_SOURCE_DIR}/misc/${CHOCO_RELEASE_NAME}.def)

# Include all the source code files
file(GLOB_RECURSE source_files "${CMAKE_SOURCE_DIR}/src/*.cpp")

configure_file(misc/version.rc.in ${CMAKE_CURRENT_BINARY_DIR}/version.rc @ONLY)

cmrc_add_resource_library(
  ${RELEASE_NAME}-resources
  ALIAS ${RELEASE_NAME}::rc
  NAMESPACE ${RELEASE_NAME}
  ${CMAKE_CURRENT_SOURCE_DIR}/.logo/logo_nobg.png
)

add_library(${RELEASE_NAME} SHARED ${source_files} ${CMAKE_CURRENT_BINARY_DIR}/version.rc)
add_dependencies(${RELEASE_NAME} ${CHOCO_RELEASE_NAME})
target_include_directories(
  ${RELEASE_NAME}
  PRIVATE "${CMAKE_SOURCE_DIR}/src"
  PRIVATE ${FFMPEG_INCLUDE_DIRS}
  PRIVATE ${BX_INCLUDE_DIRS}
  PRIVATE ${BIMG_INCLUDE_DIRS}
  PRIVATE ${BGFX_INCLUDE_DIRS}
  PRIVATE ${OPENPSF_INCLUDE_DIRS}
  PRIVATE ${SOLOUD_INCLUDE_DIRS}
  PRIVATE ${STACKWALKER_INCLUDE_DIRS}
  PRIVATE ${VGMSTREAM_INCLUDE_DIRS}
)
target_link_directories(
  ${RELEASE_NAME}
  PRIVATE ${FFMPEG_LIBRARY_DIRS}
)
target_link_libraries(
  ${RELEASE_NAME}
  ${RELEASE_NAME}::rc
  comctl32
  wintrust
  dbghelp
  shlwapi
  psapi
  dwmapi
  winmm
  dinput8
  dxguid
  XINPUT9_1_0
  strmiids
  ZLIB::ZLIB
  PNG::PNG
  Microsoft::DirectXTex
  mimalloc-static
  imgui::imgui
  pugixml::pugixml
  tomlplusplus::tomlplusplus
  STEAMWORKSSDK::STEAMWORKSSDK
  xxHash::xxhash
  lz4::lz4
  Vorbis::vorbisfile
  Vorbis::vorbis
  MPG123::libmpg123
  lfreist-hwinfo::hwinfo
  unofficial::stackwalker::StackWalker
  cryptopp::cryptopp
  ${BX_LIBRARIES}
  ${BIMG_LIBRARIES}
  ${BGFX_LIBRARIES}
  ${FFMPEG_LIBRARIES}
  ${OPENPSF_LIBRARIES}
  ${SOLOUD_LIBRARIES}
  ${VGMSTREAM_LIBRARIES}
)
target_compile_options(
  ${RELEASE_NAME}
  PRIVATE /DBX_CONFIG_DEBUG=1
  PRIVATE /DDIRECTINPUT_VERSION=0x0800
  PRIVATE /DVERSION="${_DLL_VERSION}"
  PRIVATE /D_CRT_SECURE_NO_WARNINGS
  PRIVATE /DNOMINMAX
  PRIVATE /Zc:strictStrings-
  PRIVATE /Zc:__cplusplus
  PRIVATE /Zc:preprocessor
  PRIVATE /Qpar
  PRIVATE /MP
)
if(PATCH_COLLECT_DUPLICATES)
  target_compile_definitions(${RELEASE_NAME}
    PRIVATE PATCH_COLLECT_DUPLICATES
  )
endif()
target_compile_features(${RELEASE_NAME}
  PRIVATE cxx_std_20
)
target_link_options(
  ${RELEASE_NAME}
  PRIVATE /PDBALTPATH:${RELEASE_NAME}.pdb
  PRIVATE /DEF:${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.def
  PRIVATE /MANIFESTDEPENDENCY:"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'"
)

# SHADER COMPILATION
set(FFNX_SHADERS "FFNx" "FFNx.lighting" "FFNx.shadowmap" "FFNx.field.shadow" "FFNx.overlay" "FFNx.post" "FFNx.blit")
foreach(FFNX_SHADER IN LISTS FFNX_SHADERS)
  foreach(BGFX_VARYING flat smooth)
    add_custom_command(
      TARGET ${RELEASE_NAME}
      POST_BUILD
      COMMAND echo Building ${FFNX_SHADER}.${BGFX_VARYING} vert/frag shaders...
      # ensure bin directory exists
      COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/bin/shaders
      # OpenGL
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.gl.frag --type f --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_OPENGL_FLAGS}
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.gl.vert --type v --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_OPENGL_FLAGS}
      # Vulkan
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.vk.frag --type f --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_VULKAN_FLAGS}
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.vk.vert --type v --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_VULKAN_FLAGS}
      # Direct3D 11
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d11.frag --type f --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS}
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d11.vert --type v --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS}
      # Direct3D 12
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d12.frag --type f --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS}
      COMMAND
        ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
        ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d12.vert --type v --varyingdef
        ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS})
  endforeach()
endforeach()

# List .gitkeep files to remove them on INSTALL
FILE(GLOB_RECURSE HEXT_GIT_KEEP_FILES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}/misc/ ${CMAKE_CURRENT_SOURCE_DIR}/misc/hext/ff8/**/.gitkeep)
LIST(TRANSFORM HEXT_GIT_KEEP_FILES PREPEND ${CMAKE_BINARY_DIR}/bin/)

# INSTALL
add_custom_command(
  TARGET ${RELEASE_NAME}
  POST_BUILD
  COMMAND echo Preparing ${RELEASE_NAME} ${_DLL_VERSION} release...
  # ensure bin directory exists
  COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/bin
  # License
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/COPYING.TXT
          ${CMAKE_BINARY_DIR}/bin
  # .dll
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/${RELEASE_NAME}.dll
          ${CMAKE_BINARY_DIR}/bin
  # choco .dll
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/${CHOCO_RELEASE_NAME}.dll
          ${CMAKE_BINARY_DIR}/bin
  # rename choco .dll to AF4DN.P
  COMMAND ${CMAKE_COMMAND} -E rename
          ${CMAKE_BINARY_DIR}/bin/${CHOCO_RELEASE_NAME}.dll
          ${CMAKE_BINARY_DIR}/bin/AF4DN.P
  # steam_api.dll
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/steamworkssdk/steam_api.dll
          ${CMAKE_BINARY_DIR}/bin
  # .pdb
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/${RELEASE_NAME}.pdb
          ${CMAKE_BINARY_DIR}/bin
  # .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.toml
          ${CMAKE_BINARY_DIR}/bin
  # FF7.reg
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/FF7.reg
          ${CMAKE_BINARY_DIR}/bin
  # FF8.reg
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/FF8.reg
          ${CMAKE_BINARY_DIR}/bin
  # hext
  COMMAND ${CMAKE_COMMAND} -E copy_directory
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/hext
          ${CMAKE_BINARY_DIR}/bin/hext
  COMMAND ${CMAKE_COMMAND} -E rm ${HEXT_GIT_KEEP_FILES}

  # ambient .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.ambient.toml
          ${CMAKE_BINARY_DIR}/bin/ambient/config.toml
  # lighting .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.lighting.toml
          ${CMAKE_BINARY_DIR}/bin/lighting/config.toml
  # SFX .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.SFX.toml
          ${CMAKE_BINARY_DIR}/bin/sfx/config.toml
  # Music .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.music.toml
          ${CMAKE_BINARY_DIR}/bin/music/vgmstream/config.toml
  # Voice .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.voice.toml
          ${CMAKE_BINARY_DIR}/bin/voice/config.toml
  # Vibrate field .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.vibrate.ff8.field.toml
          ${CMAKE_BINARY_DIR}/bin/vibrate/ff8/field.toml
  # Vibrate world .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.vibrate.ff8.world.toml
          ${CMAKE_BINARY_DIR}/bin/vibrate/ff8/world.toml
  # Vibrate battle .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.vibrate.ff8.battle.toml
          ${CMAKE_BINARY_DIR}/bin/vibrate/ff8/battle.toml
  # time cycle .toml
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.time.toml
          ${CMAKE_BINARY_DIR}/bin/time/config.toml
  # Gamut LUTS
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_ntscj_to_srgb.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_smptec_to_srgb.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_ebu_to_srgb.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_inverse_ntscj_to_srgb.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_inverse_ntscj_to_smptec.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_inverse_ntscj_to_ebu.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_srgb_to_ntscj.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_smptec_to_ntscj.png
          ${CMAKE_BINARY_DIR}/bin/shaders
  COMMAND ${CMAKE_COMMAND} -E copy
          ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_ebu_to_ntscj.png
          ${CMAKE_BINARY_DIR}/bin/shaders

)

# CPU INFO
add_custom_command(
  TARGET ${CHOCO_RELEASE_NAME}
  PRE_BUILD
  # Get CPU info
  COMMAND
    ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/cpuinfo/cpu-info
  # Get CPU ISA supported instructions
  COMMAND
    ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/cpuinfo/isa-info
)

# Copy FFNx release to FF7 1998 game path if installed
cmake_host_system_information(RESULT FF7_1998_GAME_PATH QUERY WINDOWS_REGISTRY "HKLM/SOFTWARE/Square Soft, Inc./Final Fantasy VII" VALUE "AppPath" ERROR_VARIABLE FF7_KEY_QUERY_RES)
if("${FF7_KEY_QUERY_RES}" STREQUAL "")
  cmake_path(CONVERT "${FF7_1998_GAME_PATH}" TO_CMAKE_PATH_LIST FF7_1998_GAME_PATH)
  # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
  if(NOT EXISTS "${FF7_1998_GAME_PATH}/FFNx.toml")
    # Copy file if it doesn't exist
    file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF7_1998_GAME_PATH}/")
  endif()
  add_custom_command(
    TARGET ${RELEASE_NAME}
    POST_BUILD
    COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF7_1998_GAME_PATH}...
    # Preserve the current FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF7_1998_GAME_PATH}/FFNx.toml
            ${FF7_1998_GAME_PATH}/FFNx.toml.bak
    # Copy all dist files
    COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${CMAKE_BINARY_DIR}/bin
            ${FF7_1998_GAME_PATH}
    # Delete the new copied FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E remove
            ${FF7_1998_GAME_PATH}/FFNx.toml
    # Bring back the existing FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF7_1998_GAME_PATH}/FFNx.toml.bak
            ${FF7_1998_GAME_PATH}/FFNx.toml
  )
endif()

# Copy FFNx release to FF8 2000 game path if installed
cmake_host_system_information(RESULT FF8_2000_GAME_PATH QUERY WINDOWS_REGISTRY "HKLM/SOFTWARE/Square Soft, Inc/FINAL FANTASY VIII/1.00" VALUE "AppPath" ERROR_VARIABLE FF8_KEY_QUERY_RES)
if("${FF8_KEY_QUERY_RES}" STREQUAL "")
  cmake_path(CONVERT "${FF8_2000_GAME_PATH}" TO_CMAKE_PATH_LIST FF8_2000_GAME_PATH)
  # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
  if(NOT EXISTS "${FF8_2000_GAME_PATH}/FFNx.toml")
    # Copy file if it doesn't exist
    file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF8_2000_GAME_PATH}/")
  endif()
  add_custom_command(
    TARGET ${RELEASE_NAME}
    POST_BUILD
    COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF8_2000_GAME_PATH}...
    # Preserve the current FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF8_2000_GAME_PATH}/FFNx.toml
            ${FF8_2000_GAME_PATH}/FFNx.toml.bak
    # Copy all dist files
    COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${CMAKE_BINARY_DIR}/bin
            ${FF8_2000_GAME_PATH}
    # Delete previous eax.dll
    COMMAND ${CMAKE_COMMAND} -E remove
            ${FF8_2000_GAME_PATH}/eax.dll
    # Rename FFNx.dll to eax.dll
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF8_2000_GAME_PATH}/FFNx.dll
            ${FF8_2000_GAME_PATH}/eax.dll
    # Delete the new copied FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E remove
            ${FF8_2000_GAME_PATH}/FFNx.toml
    # Bring back the existing FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF8_2000_GAME_PATH}/FFNx.toml.bak
            ${FF8_2000_GAME_PATH}/FFNx.toml
  )
endif()

# Copy FFNx release to FF7 Steam game path if installed
execute_process(
  COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/utils/FindSteamGamePath 39140
  OUTPUT_VARIABLE FF7_STEAM_GAME_PATH
  ERROR_VARIABLE FF7_STEAM_ERROR
  OUTPUT_STRIP_TRAILING_WHITESPACE
)
if(NOT "${FF7_STEAM_GAME_PATH}" STREQUAL "")
  cmake_path(CONVERT "${FF7_STEAM_GAME_PATH}" TO_CMAKE_PATH_LIST FF7_STEAM_GAME_PATH)
  # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
  if(NOT EXISTS "${FF7_STEAM_GAME_PATH}/FFNx.toml")
    # Copy file if it doesn't exist
    file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF7_STEAM_GAME_PATH}/")
  endif()
  add_custom_command(
    TARGET ${RELEASE_NAME}
    POST_BUILD
    COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF7_STEAM_GAME_PATH}...
    # Preserve the current FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF7_STEAM_GAME_PATH}/FFNx.toml
            ${FF7_STEAM_GAME_PATH}/FFNx.toml.bak
    # Copy all dist files
    COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${CMAKE_BINARY_DIR}/bin
            ${FF7_STEAM_GAME_PATH}
    # Delete previous AF3DN.P
    COMMAND ${CMAKE_COMMAND} -E remove
            ${FF7_STEAM_GAME_PATH}/AF3DN.P
    # Rename FFNx.dll to AF3DN.P
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF7_STEAM_GAME_PATH}/FFNx.dll
            ${FF7_STEAM_GAME_PATH}/AF3DN.P
    # Delete the new copied FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E remove
            ${FF7_STEAM_GAME_PATH}/FFNx.toml
    # Bring back the existing FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF7_STEAM_GAME_PATH}/FFNx.toml.bak
            ${FF7_STEAM_GAME_PATH}/FFNx.toml
  )
endif()

# Copy FFNx release to FF7 Steam game path if installed
execute_process(
  COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/utils/FindSteamGamePath 39150
  OUTPUT_VARIABLE FF8_STEAM_GAME_PATH
  ERROR_VARIABLE FF8_STEAM_ERROR
  OUTPUT_STRIP_TRAILING_WHITESPACE
)
if(NOT "${FF8_STEAM_GAME_PATH}" STREQUAL "")
  cmake_path(CONVERT "${FF8_STEAM_GAME_PATH}" TO_CMAKE_PATH_LIST FF8_STEAM_GAME_PATH)
  # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
  if(NOT EXISTS "${FF8_STEAM_GAME_PATH}/FFNx.toml")
    # Copy file if it doesn't exist
    file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF8_STEAM_GAME_PATH}/")
  endif()
  add_custom_command(
    TARGET ${RELEASE_NAME}
    POST_BUILD
    COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF8_STEAM_GAME_PATH}...
    # Preserve the current FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF8_STEAM_GAME_PATH}/FFNx.toml
            ${FF8_STEAM_GAME_PATH}/FFNx.toml.bak
    # Copy all dist files
    COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${CMAKE_BINARY_DIR}/bin
            ${FF8_STEAM_GAME_PATH}
    # Delete previous AF3DN.P
    COMMAND ${CMAKE_COMMAND} -E remove
            ${FF8_STEAM_GAME_PATH}/AF3DN.P
    # Rename FFNx.dll to AF3DN.P
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF8_STEAM_GAME_PATH}/FFNx.dll
            ${FF8_STEAM_GAME_PATH}/AF3DN.P
    # Delete the new copied FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E remove
            ${FF8_STEAM_GAME_PATH}/FFNx.toml
    # Bring back the existing FFNx.toml
    COMMAND ${CMAKE_COMMAND} -E rename
            ${FF8_STEAM_GAME_PATH}/FFNx.toml.bak
            ${FF8_STEAM_GAME_PATH}/FFNx.toml
  )
endif()
````

## File: CMakePresets.json
````json
{
  "version": 6,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 25,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "base",
      "hidden": true,
      "generator": "Visual Studio 17 2022",
      "architecture": {
        "value": "win32",
        "strategy": "set"
      },
      "toolset": {
        "value": "host=x86",
        "strategy": "set"
      },
      "environment": {
        "NUGET_CLI_LANGUAGE": "en-us",
        "VCPKG_ROOT": "${sourceDir}/vcpkg",
        "VCPKG_BINARY_SOURCES": "clear;nuget,github,readwrite;default,readwrite"
      },
      "binaryDir": "${sourceDir}/.build",
      "toolchainFile": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
      "cacheVariables": {
        "_DLL_VERSION": "devel",
        "CMAKE_C_COMPILER": "cl",
        "VCPKG_TARGET_TRIPLET": "x86-windows-static"
      }
    },
    {
      "name": "Release",
      "inherits": "base",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    },
    {
      "name": "RelWithDebInfo",
      "inherits": "base",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo"
      }
    },
    {
      "name": "Debug",
      "inherits": "base",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug"
      }
    },
    {
      "name": "MinSizeRel",
      "inherits": "base",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "MinSizeRel"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "Release",
      "displayName": "Default",
      "configurePreset": "Release",
      "configuration": "Release"
    },
    {
      "name": "RelWithDebInfo",
      "displayName": "Default",
      "configurePreset": "RelWithDebInfo",
      "configuration": "RelWithDebInfo"
    },
    {
      "name": "Debug",
      "displayName": "Default",
      "configurePreset": "Debug",
      "configuration": "Debug"
    },
    {
      "name": "MinSizeRel",
      "displayName": "Default",
      "configurePreset": "MinSizeRel",
      "configuration": "MinSizeRel"
    }
  ],
  "vendor": {
    "microsoft.com/VisualStudioSettings/CMake/1.0": {
      "hostOS": "Windows",
      "intelliSenseMode": "windows-msvc-x64"
    }
  }
}
````

## File: COPYING.TXT
````
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
````

## File: README.md
````markdown
![License](https://img.shields.io/github/license/julianxhokaxhiu/FFNx) ![Overall Downloads](https://img.shields.io/github/downloads/julianxhokaxhiu/FFNx/total?label=Overall%20Downloads) ![Latest Stable Downloads](https://img.shields.io/github/downloads/julianxhokaxhiu/FFNx/latest/total?label=Latest%20Stable%20Downloads&sort=semver) ![Latest Canary Downloads](https://img.shields.io/github/downloads/julianxhokaxhiu/FFNx/canary/total?label=Latest%20Canary%20Downloads) ![GitHub Actions Workflow Status](https://github.com/julianxhokaxhiu/FFNx/actions/workflows/main-1.23.0.yml/badge.svg?branch=master)

<div align="center">
  <img src="https://github.com/julianxhokaxhiu/FFNx/blob/master/.logo/logo_nobg.png" alt="">
  <br><strong><small>Kudos to <a href="https://www.instagram.com/aryaaiedail/">Cinzia Cancedda (aryaaiedail)</a></small></strong>
</div>

# FFNx

Next generation modding platform for Final Fantasy VII and Final Fantasy VIII (with native Steam 2013 release support)

## Introduction

FFNx is a continuing evolution of the [FF7_OpenGL](https://github.com/Aali132/ff7_opengl) driver, [made by Aali](http://forums.qhimm.com/index.php?topic=14922.0).

FFNx today in a nutshell:

- Uses an easy, drag-n-drop installation experience, see [How to Install](docs/how_to_install.md)
- Comes built-in with 7th Heaven v2.3 and higher
- Supports the newest video and audio codecs (WEBM, H.265, Ogg, etc.)
- Drastically enhances the gameplay experience compared to the vanilla experience
- Provides four stable rendering backends:
  - DirectX 11 (default)
  - DirectX 12
  - Vulkan
  - OpenGL

## The Team

FFNx is developed by a core team, currently composed of:

- [Julian Xhokaxhiu](https://github.com/julianxhokaxhiu) (TrueOdin,  Spain)
- [Tang-Tang Zhou](https://github.com/tangtang95) (vertex2995,  Italy)
- [Jrme Arzel](https://github.com/myst6re) (myst6re,  France)
- [CosmosXIII](https://github.com/CosmosXIII) (Cosmos,  Japan)

We are always open for contributions via PRs, and in case you want to join the core team, feel free to approach us on Discord and we will evaluate on a case-by-case basis.

## Features

### As a user

#### FF7/FF8

- [/LARGEADDRESSAWARE](https://docs.microsoft.com/en-us/cpp/build/reference/largeaddressaware-handle-large-addresses?view=vs-2019) support. Up to 3.5GB of RAM available for mods (this requires the [4GB Patch](https://ntcore.com/?page_id=371) in your ff7.exe).
- High DPI support
- HDR support
- Up to 16x anisotropic support
- Up to 16x antialiasing support
- 5.1/7.1 audio output support
- Steam support; no game converter required
- Steam savegame preservation (you no longer lose saves created while FFNx is active)
- XInput controller support (Xbox 360 and compatible) with D-Pad working out-of-the-box
- Native speedhack support
- External music loading to replace original MIDIs
- The game continues to run within an inactive window

#### FF7
- 60 FPS
- eStore support! No game converter required
- Vertical centering for fields and movies
- Fullscreen battle scenes
- Menu cursor vertically aligned on the center of words
- Movies continue to play while running in an inactive window
- Movie volume respects global sound volume
- Steam sound and music volume configuration preservation (configure at your pleasure and on the next run it will be inherited)
- Configurable background transparency in battle dialogs (by default set to 75%)
- SFX volume change applies in real-time, instead of requiring a game reload
- Support for animated textures (like Aerith's waterfall, light fading, etc.)
- Support for soft-reset while you're playing, just like the PSX
- Support for battle toggle (enable/disable at your own pleasure)
- **Voice acting**! [Echo-S](https://www.tsunamods.com/echo-s-7/) was the first mod to take advantage of this!
- Support for external SFX audio effects
- Support for external ambient audio effects
- Support for external movie audio files (allows multiple videos to share the same audio)
- Support for external movie voice acting (dedicated audio layer only for voice acting on top of movies)
- Steam achievements can be unlocked while playing within FFNx
- Real-time light engine - You can now feel the game visually like never before
- Real-time camera control in battles
- Analogue controls using the full axis of your left analog stick

#### FF8
- Vibration support
- Analog controls improved support
- **Voice acting**! [Echo-S](https://www.tsunamods.com/echo-s-8/) was the first mod to take advantage of this!
- Various graphical patches for worldmap included
- Enable the VRAM debug window while playing in order to see how the engine uploads textures
- Support for external SFX audio effects
- Support for external movie audio files (allows multiple videos to share the same audio)
- Support for external movie voice acting (dedicated audio layer only for voice acting on top of movies)
- Support for external music audio with music resume after battle and improved volume transitions

### As a modder

- Game rendering inspection through [RenderDoc](https://renderdoc.org/)
- [DDS Texture support](https://wiki.beyondskyrim.org/wiki/Arcane_University:DDS_Data_Format) up to BC7 format, with PNG support as fallback
- Support for configurable external textures path using [mod_path](misc/FFNx.toml#L100)
- Support for an override layer of the data directory using [override_path](misc/FFNx.toml#L116)
- Support for MINIPSF audio files using the emulated PSX/PS2 AKAO Engine
- Support for [Hext](https://forums.qhimm.com/index.php?topic=13574.0) patching files inside of the [hext_patching_path](misc/FFNx.toml#L113)
- Debug in-game engine data through [imgui](https://github.com/ocornut/imgui) integration

## Documentation

For a more in-depth documentation feel free to visit the [docs/](docs/) folder.

## Screenshots

|                       Vanilla/Steam                                                                  |
| :--------------------------------------------------------------------------------------------------: |
| ![Final Fantasy VII running on Vulkan](.screens/ff7.png)                                             |
| ![Final Fantasy VIII running on Vulkan](.screens/ff8.png)                                            |
| [![Final Fantasy VIII Worldmap graphical patches](.screens/ff8-worldmap-official-release-vs-ffnx.png)](https://imgsli.com/MTg5NjQ2) |

## Tech Stack

If you're curious to know, FFNx makes use of:

- C++ code base
- Latest MSVC available on [Visual Studio 2022 Community Edition](https://visualstudio.microsoft.com/vs/features/cplusplus/)
- [vcpkg](https://vcpkg.io/) (dependency manager)
- [CMake](https://cmake.org/) (make files)
- [BGFX](https://github.com/bkaradzic/bgfx) (backend renderer)
- [BIMG](https://github.com/bkaradzic/bimg) (custom textures)
- [FFMpeg](https://www.ffmpeg.org/) with H/W accelleration support
- [VGMStream](https://github.com/losnoco/vgmstream) using FFMpeg as backend (with loop support!)
- [tomlplusplus](https://github.com/marzer/tomlplusplus) (configuration management)
- [StackWalker](https://github.com/JochenKalmbach/StackWalker) (log file stack traces)
- [pugixml](https://github.com/zeux/pugixml) (Steam XML manifest)
- [md5](http://www.zedwood.com/article/cpp-md5-function) (Steam XML manifest)
- [libpng](http://www.libpng.org/pub/png/libpng.html) (better and faster PNG texture support)
- [imgui](https://github.com/ocornut/imgui) (DevTools in-game interface)
- [imgui_club](https://github.com/ocornut/imgui_club) (imgui Memory Editor Widget)
- [xxhash](https://github.com/Cyan4973/xxHash) (fast hash extraction from paletted game texture data, aka animated textures)
- [SoLoud](https://github.com/jarikomppa/soloud) (audio engine used to playback audio, music or voice files)
- [openpsf](https://github.com/myst6re/openpsf) (MINIPSF emulation engine to playback PSX/PS2 music files)
- [Steamworks SDK](https://github.com/julianxhokaxhiu/SteamworksSDKCI) (support achievements for the Steam editions of games)
- [mimalloc](https://github.com/microsoft/mimalloc) (a compact general purpose allocator with excellent performance)

## How to build

Available build profiles:

- x86-Release (default, the same used to release artifacts in this Github page)
- x86-RelWithDebInfo (used while developing to better debug some issues)
- x86-MinSizeRel
- x86-Debug (prefer it if you want to use a debugger attached to the game)

Once the project is built you can find the output in this path: `.build/bin`

### Preparation

> **Please note:**
>
> FFNx uses vcpkg as a package manager to resolve dependencies. Failing to follow these steps will result in build errors.

0. Clone this repository using the `--recursive` flag, eg. `git clone --recursive https://github.com/julianxhokaxhiu/FFNx.git`

### NuGet

> **Please note:**
>
> This step will speed up your compilation times by avoiding the vcpkg dependencies rebuild.

0. Make sure you have [NuGet CLI installed](https://learn.microsoft.com/en-us/nuget/install-nuget-client-tools?tabs=windows#install-nugetexe).
1. [Create a Personal Access token ( classic )](https://github.com/settings/tokens/new) with the `write:packages` permission.
2. Open a `cmd` window and run the following commands ( replace `YOUR_GITHUB_USERNAME` and `YOUR_GITHUB_PAT` accordingly ):
```pwsh
$ nuget sources add -Name github -Source "https://nuget.pkg.github.com/YOUR_GITHUB_USERNAME/index.json" -Username YOUR_GITHUB_USERNAME -Password YOUR_GITHUB_PAT -StorePasswordInClearText
$ nuget setApiKey YOUR_GITHUB_PAT -Source "https://nuget.pkg.github.com/YOUR_GITHUB_USERNAME/index.json"
```

### Visual Studio

> **Please note:**
>
> By default Visual Studio will pick the **x86-Release** build configuration, but you can choose any other profile available.
> FFNx uses vcpkg as a package manager to resolve dependencies. Failing to follow these steps will result in build errors.

0. Download the the latest [Visual Studio Community](https://visualstudio.microsoft.com/vs/community/) installer
1. Run the installer and import this [.vsconfig](.vsconfig) file in the installer to pick the components required to build this project
2. Make sure you select the English Language pack in the language list before clicking Install
3. Go inside the [`vcpkg`](./vcpkg) folder and double click `bootstrap-vcpkg.bat`
4. Open a `cmd` window in [`vcpkg`](./vcpkg) and run the following command: `vcpkg integrate install`
5. Once installed, open this repository **as a folder** in Visual Studio
6. Choose as preset in the status bar the one you desire
7. Click the `Build` button

### Visual Studio Code

0. **REQUIRED!** Follow up the steps to install Visual Studio, which will also install the MSVC toolchain
1. Download and install the latest [Visual Studio Code](https://code.visualstudio.com/) release
2. Install the following extensions:
   - https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools
   - https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools
3. Open this repository as a folder in Visual Studio Code
4. Choose as preset in the status bar the one you desire
5. Click the button on the status bar `Build`

### Neovim with clangd (optional)

0. **REQUIRED!** Follow up the steps to install Visual Studio, which will also install the MSVC toolchain
1. **REQUIRED!** Have [Neovim](https://neovim.io/) installed with [clangd](https://clangd.llvm.org/) as LSP
2. Install the extension `Clang Power Tools` in [Visual Studio Community](https://visualstudio.microsoft.com/vs/community/)
3. Open the solution `FFNx.sln` under the `.build` directory with **Visual Studio Community** (**sln** file is generated by the build process)
4. Right-click on **FFNx** solution (under the **Solution Explorer**) then click on **Clang Power Tools** -> **Export Compilation Database**
5. Copy the `compile_commands.json` generated file into the root of the repository
6. Open **Neovim** and enjoy!

To build from the terminal (example with *RelWithDebInfo*):
- For dependency use: `cmake --preset RelWithDebInfo`
- For building the project: `cmake --build --preset RelWithDebInfo`

**NOTE**: Make sure to use the `cmake` executable that comes from Visual Studio
(e.g. `C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe`)

## Auto-Formatting

### CMake Files

0. **REQUIRED!** Install [Python](https://www.python.org/)
1. Install [cmake-format](https://github.com/cheshirekow/cmake_format#installation) and make sure the binary is available in your PATH environment variable
2. **OPTIONAL!** Integrate it [in your own IDE](https://github.com/cheshirekow/cmake_format#integrations) (eg. for Visual Studio Code use [the relative extension](https://marketplace.visualstudio.com/items?itemName=cheshirekow.cmake-format))

## Support

FFNx offers multiple support channels, pick the one you prefer

### Forums

- Qhimm Forum: http://forums.qhimm.com/index.php?topic=19970.0
- Tsunamods Forum: https://forum.tsunamods.com/viewtopic.php?p=41#p41

### Discord

- Qhimm FFNx-FF7 (Final Fantasy VII only): https://discord.gg/N6M6pKS
- Qhimm FFNx-FF8 (Final Fantasy VIII only): https://discord.gg/u6M7DnY
- Tsunamods FFNx: https://discord.gg/Urq67Uz (remember to hit the Red Chocobo reaction!)

### Github

- Issues: https://github.com/julianxhokaxhiu/FFNx/issues

## Credits

This project could have not been a reality if those people would have not worked on FF7 and FF8 with their deep passion and knowledge.
FFNx makes use also of their work, and I will never be enough grateful to those people. The order is purely Alphabetical.

These people are:

- [Aali](http://forums.qhimm.com/index.php?action=profile;u=2862):
  - for the original Driver code FFNx is based on.
- [Chrysalis](http://forums.qhimm.com/index.php?action=profile;u=674):
  - for the battle fullscreen hext patch
  - for the menu cursor vertical centering in menu
- [CosmosXIII](https://github.com/CosmosXIII)
  - for the real-time light engine
  - for the real-time camera control in battles
  - for the analogue controls in FF7
- [DLPB](https://forums.qhimm.com/index.php?action=profile;u=6439):
  - for original Hext concept and specification that FFNx implemented as well
  - for the field vertical centering hext patch, which FFNx provides a default patch for
  - for the Soft-Reset original concept
  - for the no battle original concept
- [dziugo](http://forums.qhimm.com/index.php?action=profile;u=1660):
  - for the original FMV skip concept
- [ficedula](http://forums.qhimm.com/index.php?action=profile;u=68):
  - for 7h 1.x which FFNx provides support for
- [Iros](https://forums.qhimm.com/index.php?action=profile;u=21785):
  - for 7h 1.x which FFNx provides support for
- [JWP](http://forums.qhimm.com/index.php?action=profile;u=3772):
  - for imgui integration within FFNx
- [Kranmer](http://forums.qhimm.com/index.php?action=profile;u=4909)
  - for PHS save everywhere Hext patch
  - for the no battle original concept
- [Maki](http://forums.qhimm.com/index.php?action=profile;u=23937):
  - for FF8 UV Hext Patch in the world map, which FFNx provides a default patch for
  - for the help in getting the first iterations of FFNx running on FF8 2000/2013 release
- [myst6re](http://forums.qhimm.com/index.php?action=profile;u=4778):
  - for the great tools like Makou Reactor, Deling and many others he did which helped a lot in improving FF8 while working on the code
  - for the great help in the code implementing the MINIPSF emulation layer being present inside FFNx
  - for the heavy testing and lifting of a lot of bugs being catched in FFNx, for FF8
  - for the Steam savegame logic in the manifest.xml for FF8
  - for the real-time SFX volume change for FF7
- [quantumpencil](http://forums.qhimm.com/index.php?action=profile;u=23810) and [Nax](https://github.com/nax):
  - for the original CMake files FFNx has based its work upon
  - for all the help in getting some logics wired up in the game engine and a lot of hex addresses I would never been able to figure out myself
- [Satsuki](http://forums.qhimm.com/index.php?action=profile;u=24647):
  - for the heavy testing and lifting of a lot of bugs being catched in FFNx, for FF7
  - for the field vertical centering hext patch, which FFNx provides a default patch for
  - for a lot of hex addresses I would have never been able to figure out myself otherwise
  - for the original Speedhack concept and help in getting it natively into FFNx
- [Sebanisu](http://forums.qhimm.com/index.php?action=profile;u=22866):
  - for the help in getting the first iterations of FFNx running on FF8 2000/2013 release
  - for the heavy testing and lifting of a lot of bugs being catched in FFNx, for FF8
- [sithlord48](http://forums.qhimm.com/index.php?action=profile;u=6501):
  - for the Steam savegame logic in the manifest.xml for FF7
- [TurBoss](https://github.com/TurBoss):
  - for 7h 1.x source code release and FFNx enablement
- [unab0mb](https://forums.qhimm.com/index.php?action=profile;u=31071):
  - for the official integration of FFNx within 7thHeaven 2.3+
- [tangtang95](https://github.com/tangtang95)
  - for the 60FPS support in FF7
  - for the Steam achievements in FF7
- [Lord UrQuan](https://github.com/eve-atum)
  - for finding new and inventive ways to crash our test builds
  - for general documentation clean-up
- [LaZar00](https://github.com/LaZar00)
  - for the Snowboard TMD structures
- [ChthonVII](https://github.com/ChthonVII)
  - for the R&D needed to match modern display gamuts to the original PSX release

I'm sure I forgot many others. In case you feel you're missing here, feel free to open a PR! I'll be happy to include you because you deserve this.

## License

FFNx is released under GPLv3 license. You can get a copy of the license here: [COPYING.TXT](COPYING.TXT)

If you paid for FFNx, remember to ask for a refund from the person who sold you a copy. Also make sure you get a copy of the source code (if it was provided as binary only).

If the person who gave you this copy refuses to give you the source code, report it here: https://www.gnu.org/licenses/gpl-violation.html

All rights belong to their respective owners.
````

## File: vcpkg-configuration.json
````json
{
  "registries": [
    {
      "kind": "filesystem",
      "path": ".vcpkg",
      "packages": [
        "bx",
        "bimg",
        "bgfx",
        "hwinfo",
        "openpsf",
        "soloud",
        "vgmstream",
        "steamworkssdk"
      ]
    }
  ]
}
````

## File: vcpkg.json
````json
{
  "name": "ffnx",
  "version": "1.23.0",
  "builtin-baseline": "4334d8b4c8916018600212ab4dd4bbdc343065d1",
  "dependencies": [
    "bgfx",
    {
      "name": "ffmpeg",
      "default-features": false,
      "features": [
        "avcodec",
        "avdevice",
        "avfilter",
        "avformat",
        "avresample",
        "postproc",
        "swresample",
        "swscale",
        "amf",
        "nvcodec",
        "opencl",
        "qsv",
        "gpl",
        "version3",
        "dav1d",
        "opus",
        "speex",
        "theora",
        "vorbis",
        "vpx",
        "x264",
        "x265"
      ],
      "platform": "windows"
    },
    "imgui",
    "libpng",
    {
      "name": "directxtex",
      "default-features": false,
      "features": []
    },
    {
      "name": "mimalloc",
      "default-features": false,
      "features": [
        "override",
        "secure"
      ]
    },
    "openpsf",
    "pugixml",
    "soloud",
    "stackwalker",
    "tomlplusplus",
    "vgmstream",
    "steamworkssdk",
    "xxhash",
    "lz4",
    {
      "name": "cpuinfo",
      "default-features": false,
      "features": [
        "tools"
      ]
    },
    "cmakerc",
    "cgltf",
    "hwinfo",
    "cryptopp"
  ],
  "overrides": [
    {
      "name": "bgfx",
      "version": "1.0.0",
      "port-version": 0
    },
    {
      "name": "ffmpeg",
      "version": "7.1.1",
      "port-version": 5
    },
    {
      "name": "imgui",
      "version": "1.91.9",
      "port-version": 0
    },
    {
      "name": "libpng",
      "version": "1.6.50",
      "port-version": 0
    },
    {
      "name": "directxtex",
      "version": "2025-07-10",
      "port-version": 0
    },
    {
      "name": "mimalloc",
      "version": "2.2.3",
      "port-version": 1
    },
    {
      "name": "openpsf",
      "version": "1.3.0",
      "port-version": 0
    },
    {
      "name": "pugixml",
      "version": "1.15",
      "port-version": 0
    },
    {
      "name": "soloud",
      "version": "1.0.0",
      "port-version": 0
    },
    {
      "name": "stackwalker",
      "version": "2023-06-24",
      "port-version": 0
    },
    {
      "name": "tomlplusplus",
      "version": "3.4.0",
      "port-version": 1
    },
    {
      "name": "vgmstream",
      "version": "1.0.0",
      "port-version": 0
    },
    {
      "name": "steamworkssdk",
      "version": "1.23.0",
      "port-version": 0
    },
    {
      "name": "xxhash",
      "version": "0.8.3",
      "port-version": 0
    },
    {
      "name": "lz4",
      "version": "1.10.0",
      "port-version": 0
    },
    {
      "name": "cpuinfo",
      "version": "2022-07-19",
      "port-version": 3
    },
    {
      "name": "cmakerc",
      "version": "2023-07-24",
      "port-version": 0
    },
    {
      "name": "cgltf",
      "version": "1.14",
      "port-version": 0
    },
    {
      "name": "hwinfo",
      "version": "1.0.0",
      "port-version": 0
    },
    {
      "name": "cryptopp",
      "version": "8.9.0",
      "port-version": 1
    }
  ]
}
````
