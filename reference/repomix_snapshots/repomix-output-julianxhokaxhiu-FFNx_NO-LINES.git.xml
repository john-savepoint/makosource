This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where line numbers have been added, security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    alert.ps1
    build.ps1
    main-1.23.0.yml
  FUNDING.yml
  pull_request_template.md
.vcpkg/
  ports/
    bgfx/
      FindBGFX.cmake.in
      portfile.cmake
      usage
      vcpkg-cmake-wrapper.cmake
      vcpkg.json
    bimg/
      FindBIMG.cmake.in
      portfile.cmake
      usage
      vcpkg-cmake-wrapper.cmake
      vcpkg.json
    bx/
      FindBX.cmake.in
      portfile.cmake
      usage
      vcpkg-cmake-wrapper.cmake
      vcpkg.json
    hwinfo/
      portfile.cmake
      vcpkg.json
    openpsf/
      FindOPENPSF.cmake.in
      portfile.cmake
      usage
      vcpkg-cmake-wrapper.cmake
      vcpkg.json
    soloud/
      FindSOLOUD.cmake.in
      portfile.cmake
      usage
      vcpkg-cmake-wrapper.cmake
      vcpkg.json
    steamworkssdk/
      portfile.cmake
      STEAMWORKSSDKConfig.cmake.in
      usage
      vcpkg.json
    vgmstream/
      cmake.patch
      FindVGMSTREAM.cmake.in
      portfile.cmake
      usage
      vcpkg-cmake-wrapper.cmake
      vcpkg.json
  versions/
    b-/
      bgfx.json
      bimg.json
      bx.json
    h-/
      hwinfo.json
    o-/
      openpsf.json
    s-/
      soloud.json
      steamworkssdk.json
    v-/
      vgmstream.json
    baseline.json
choco/
  main.cpp
docs/
  ff8/
    mods/
      external_textures.md
    readme.md
    vram.md
  mods/
    audio_engine.md
    devtools.md
    direct_mode.md
    exe_data.md
    external_textures.md
    video_encoding_guide.md
  faq.md
  how_to_install.md
  readme.md
  shortcuts.md
misc/
  hext/
    ff7/
      de/
        FFNx._GLOBALS.txt
        FFNx.BATTLE.fullscreen.txt
        FFNx.BATTLE.restore_modals.txt
        FFNx.BATTLE.transparent_modals.txt
        FFNx.FIELD.transparent_modals.txt
        FFNx.MENU.cursor_vertical_center.txt
      en/
        FFNx._GLOBALS.txt
        FFNx.BATTLE.fullscreen.txt
        FFNx.BATTLE.restore_modals.txt
        FFNx.BATTLE.transparent_modals.txt
        FFNx.FIELD.transparent_modals.txt
        FFNx.MENU.cursor_vertical_center.txt
      es/
        FFNx._GLOBALS.txt
        FFNx.BATTLE.fullscreen.txt
        FFNx.BATTLE.restore_modals.txt
        FFNx.BATTLE.transparent_modals.txt
        FFNx.FIELD.transparent_modals.txt
        FFNx.MENU.cursor_vertical_center.txt
      fr/
        FFNx._GLOBALS.txt
        FFNx.BATTLE.fullscreen.txt
        FFNx.BATTLE.restore_modals.txt
        FFNx.BATTLE.transparent_modals.txt
        FFNx.FIELD.transparent_modals.txt
        FFNx.MENU.cursor_vertical_center.txt
  FF8.reg
  FFNx-Choco.def
  FFNx.ambient.toml
  FFNx.blit.frag
  FFNx.blit.vert
  FFNx.common.sh
  FFNx.def
  FFNx.field.shadow.frag
  FFNx.field.shadow.vert
  FFNx.frag
  FFNx.lighting.frag
  FFNx.lighting.sh
  FFNx.lighting.toml
  FFNx.lighting.vert
  FFNx.music.toml
  FFNx.overlay.frag
  FFNx.overlay.vert
  FFNx.pcf.sh
  FFNx.post.frag
  FFNx.post.vert
  FFNx.SFX.toml
  FFNx.shadowmap.frag
  FFNx.shadowmap.vert
  FFNx.time.toml
  FFNx.toml
  FFNx.varying.flat.def.sc
  FFNx.varying.smooth.def.sc
  FFNx.vert
  FFNx.vibrate.ff8.battle.toml
  FFNx.vibrate.ff8.field.toml
  FFNx.vibrate.ff8.world.toml
  FFNx.voice.toml
  version.rc.in
src/
  audio/
    memorystream/
      memorystream.cpp
      memorystream.h
    openpsf/
      openpsf.cpp
      openpsf.h
    vgmstream/
      vgmstream.cpp
      vgmstream.h
  ff7/
    battle/
      animations.cpp
      animations.h
      battle.cpp
      camera.cpp
      camera.h
      defs.h
      effect.cpp
      effect.h
      menu.cpp
      menu.h
    field/
      background.cpp
      background.h
      camera.cpp
      camera.h
      defs.h
      enter.h
      field.cpp
      model.cpp
      model.h
      opcode.cpp
      opcode.h
      utils.h
    world/
      camera.cpp
      camera.h
      defs.h
      player.cpp
      renderer.cpp
      renderer.h
      utils.h
      world.cpp
      world.h
    defs.h
    dsound.cpp
    file.cpp
    graphics.cpp
    kernel.cpp
    loaders.cpp
    menu.cpp
    minigames.cpp
    misc.cpp
    time.cpp
    time.h
    widescreen.cpp
    widescreen.h
  ff8/
    battle/
      effects.h
      stage.cpp
      stage.h
    field/
      background.cpp
      background.h
      chara_one.cpp
      chara_one.h
    world/
      chara_one.cpp
      chara_one.h
      wmset.cpp
      wmset.h
    ambient.cpp
    ambient.h
    engine.cpp
    engine.h
    file.cpp
    file.h
    mod.cpp
    mod.h
    save_data.h
    texture_packer.cpp
    texture_packer.h
    uv_patch.cpp
    uv_patch.h
    vibration.cpp
    vibration.h
    vram.cpp
    vram.h
  gl/
    deferred.cpp
    gl.cpp
    special_case.cpp
    texture.cpp
  image/
    image.cpp
    image.h
    tim.cpp
    tim.h
  imgui_club/
    imgui_memory_editor.h
  video/
    movies.cpp
    movies.h
  achievement.cpp
  achievement.h
  api.cpp
  api.h
  audio.cpp
  audio.h
  cfg.cpp
  cfg.h
  common_imports.h
  common.cpp
  common.h
  crashdump.cpp
  crashdump.h
  exe_data.cpp
  exe_data.h
  external_mesh.cpp
  external_mesh.h
  externals_102_de.h
  externals_102_fr.h
  externals_102_sp.h
  externals_102_us.h
  fake_dd.cpp
  fake_dd.h
  ff7_data.h
  ff7_opengl.cpp
  ff7.h
  ff8_data.cpp
  ff8_data.h
  ff8_opengl.cpp
  ff8.h
  field.cpp
  field.h
  game_cfg.cpp
  game_cfg.h
  gamehacks.cpp
  gamehacks.h
  gamepad.cpp
  gamepad.h
  gl.h
  globals.h
  hext.cpp
  hext.h
  input.cpp
  input.h
  joystick.cpp
  joystick.h
  lighting_debug.cpp
  lighting_debug.h
  lighting.cpp
  lighting.h
  log.cpp
  log.h
  macro.h
  matrix.cpp
  matrix.h
  metadata.cpp
  metadata.h
  movies.cpp
  movies.h
  music.cpp
  music.h
  overlay.cpp
  overlay.h
  patch.cpp
  patch.h
  redirect.cpp
  redirect.h
  renderer.cpp
  renderer.h
  saveload.cpp
  saveload.h
  sfx.cpp
  sfx.h
  utils.cpp
  utils.h
  vibration.cpp
  vibration.h
  voice.cpp
  voice.h
  widescreen.h
  wine.h
  world.cpp
  world.h
.editorconfig
.gitignore
.gitmodules
.vsconfig
Changelog.md
cmake-format.yaml
CMakeLists.txt
CMakePresets.json
COPYING.TXT
README.md
vcpkg-configuration.json
vcpkg.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
 1: ---
 2: name: Bug report üêû
 3: about: Create a report to help us improve. If you come here from a 7th Heaven crash, DO NOT open an issue, as it will be closed IMMEDIATELY. Consider opening a discussion thread instead!
 4: title: "[ GAME ] ISSUE"
 5: labels: bug
 6: assignees: ""
 7: ---
 8: 
 9: **PLEASE NOTE:** If you come here to report a crash while you were using 7th Heaven, please do on their relative support channels. NO SUPPORT will be provided, and your issue will be close immediately.
10: 
11: **Describe the bug**
12: A clear and concise description of what the bug is.
13: 
14: **To Reproduce**
15: Steps to reproduce the behavior:
16: 
17: 1. Go to '...'
18: 2. Click on '....'
19: 3. Scroll down to '....'
20: 4. See error
21: 
22: **Expected behavior**
23: A clear and concise description of what you expected to happen.
24: 
25: **Screenshots**
26: If applicable, add screenshots to help explain your problem.
27: 
28: **GPU (please complete the following information):**
29: 
30: - Brand [e.g. Nvidia]
31: - Driver Version [e.g. 27.21.14.5730]
32: 
33: **Additional context**
34: Add any other context about the problem here.
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.md">
 1: ---
 2: name: Feature Request üí°
 3: about: Suggest a new idea for the project.
 4: labels: enhancement
 5: ---
 6: 
 7: ## Summary
 8: 
 9: Brief explanation of the feature.
10: 
11: ### Basic example
12: 
13: If the proposal involves a new or changed API, include a basic code example. Omit this section if it's not applicable.
14: 
15: ### Motivation
16: 
17: Why are we doing this? What use cases does it support? What is the expected outcome?
</file>

<file path=".github/workflows/alert.ps1">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and\or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: $downloadUrl = "https://github.com/julianxhokaxhiu/FFNx/releases/latest"
23: 
24: if ($env:_IS_BUILD_CANARY -eq "true") {
25:   $downloadUrl = "https://github.com/julianxhokaxhiu/FFNx/releases/tag/canary"
26: }
27: 
28: # Initial template from https://discohook.org/
29: $discordPost = @"
30: {
31:   "username": "FFNx",
32:   "avatar_url": "https://github.com/julianxhokaxhiu/FFNx/raw/master/.logo/logo_whitebg.png",
33:   "content": "Release **${env:_RELEASE_VERSION}** has just been published!\n\nDownload Url: ${downloadUrl}\n\nIf you find something broken or unexpected, feel free to check existing ones first here https://github.com/julianxhokaxhiu/FFNx/issues.\nIf non existing, then report your issue here https://github.com/julianxhokaxhiu/FFNx/issues/new.\n\nThank you for using FFNx!",
34:   "embeds": [
35:     {
36:       "title": "How to install",
37:       "description": "Feel free to follow instructions at this link, depending on which version of the game you own: https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/how_to_install.md",
38:       "color": 7506394
39:     },
40:     {
41:       "title": "FFNx is FOSS Software!",
42:       "description": "FFNx is released under GPLv3 license. More info here: https://github.com/julianxhokaxhiu/FFNx#license",
43:       "color": 15746887
44:     }
45:   ]
46: }
47: "@
48: 
49: Invoke-RestMethod -Uri $env:_MAP_FFNX_QHIMM_FF7 -ContentType "application/json" -Method Post -Body $discordPost
50: Invoke-RestMethod -Uri $env:_MAP_FFNX_QHIMM_FF8 -ContentType "application/json" -Method Post -Body $discordPost
51: Invoke-RestMethod -Uri $env:_MAP_FFNX_TSUNAMODS_FF7 -ContentType "application/json" -Method Post -Body $discordPost
52: Invoke-RestMethod -Uri $env:_MAP_FFNX_TSUNAMODS_FF8 -ContentType "application/json" -Method Post -Body $discordPost
</file>

<file path=".github/workflows/build.ps1">
  1: #*****************************************************************************#
  2: #    Copyright (C) 2009 Aali132                                               #
  3: #    Copyright (C) 2018 quantumpencil                                         #
  4: #    Copyright (C) 2018 Maxime Bacoux                                         #
  5: #    Copyright (C) 2020 myst6re                                               #
  6: #    Copyright (C) 2020 Chris Rizzitello                                      #
  7: #    Copyright (C) 2020 John Pritchard                                        #
  8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
  9: #                                                                             #
 10: #    This file is part of FFNx                                                #
 11: #                                                                             #
 12: #    FFNx is free software: you can redistribute it and\or modify             #
 13: #    it under the terms of the GNU General Public License as published by     #
 14: #    the Free Software Foundation, either version 3 of the License            #
 15: #                                                                             #
 16: #    FFNx is distributed in the hope that it will be useful,                  #
 17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
 18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
 19: #    GNU General Public License for more details.                             #
 20: #*****************************************************************************#
 21: 
 22: Set-StrictMode -Version Latest
 23: 
 24: if ($env:_BUILD_BRANCH -eq "refs/heads/master" -Or $env:_BUILD_BRANCH -eq "refs/tags/canary")
 25: {
 26:   $env:_IS_BUILD_CANARY = "true"
 27:   $env:_IS_GITHUB_RELEASE = "true"
 28: }
 29: elseif ($env:_BUILD_BRANCH -like "refs/tags/*")
 30: {
 31:   $env:_CHANGELOG_VERSION = $env:_BUILD_VERSION.Substring(0,$env:_BUILD_VERSION.LastIndexOf('.')).Replace('.','')
 32:   $env:_BUILD_VERSION = $env:_BUILD_VERSION.Substring(0,$env:_BUILD_VERSION.LastIndexOf('.')) + ".0"
 33:   $env:_IS_GITHUB_RELEASE = "true"
 34: }
 35: $env:_RELEASE_VERSION = "v${env:_BUILD_VERSION}"
 36: 
 37: $vcpkgRoot = ".\vcpkg"
 38: $vcpkgBaseline = [string](jq --arg baseline "builtin-baseline" -r '.[$baseline]' vcpkg.json)
 39: $vcpkgOriginUrl = &"git" -C $vcpkgRoot remote get-url origin
 40: $vcpkgTagName = &"git" -C $vcpkgRoot describe --exact-match --tags
 41: 
 42: $releasePath = [string](jq -r '.configurePresets[0].binaryDir' CMakePresets.json).Replace('${sourceDir}/', '')
 43: 
 44: Write-Output "--------------------------------------------------"
 45: Write-Output "BUILD CONFIGURATION: $env:_RELEASE_CONFIGURATION"
 46: Write-Output "RELEASE VERSION: $env:_RELEASE_VERSION"
 47: Write-Output "VCPKG ORIGIN: $vcpkgOriginUrl"
 48: Write-Output "VCPKG TAG: $vcpkgTagName"
 49: Write-Output "VCPKG BASELINE: $vcpkgBaseline"
 50: Write-Output "--------------------------------------------------"
 51: 
 52: Write-Output "_BUILD_VERSION=${env:_BUILD_VERSION}" >> ${env:GITHUB_ENV}
 53: Write-Output "_RELEASE_VERSION=${env:_RELEASE_VERSION}" >> ${env:GITHUB_ENV}
 54: Write-Output "_IS_BUILD_CANARY=${env:_IS_BUILD_CANARY}" >> ${env:GITHUB_ENV}
 55: Write-Output "_IS_GITHUB_RELEASE=${env:_IS_GITHUB_RELEASE}" >> ${env:GITHUB_ENV}
 56: Write-Output "_CHANGELOG_VERSION=${env:_CHANGELOG_VERSION}" >> ${env:GITHUB_ENV}
 57: 
 58: # Install CMake
 59: Write-Output "Installing cmake v${env:_WINGET_CMAKE}..."
 60: winget install Kitware.CMake --version ${env:_WINGET_CMAKE} --silent --uninstall-previous --accept-source-agreements --accept-package-agreements --disable-interactivity --force | out-null
 61: cmake --version
 62: 
 63: # Install Visual Studio Enterprise
 64: Write-Output "Installing VisualStudio 2022 Enterprise v${env:_WINGET_VS2022}..."
 65: winget install Microsoft.VisualStudio.2022.Enterprise --version ${env:_WINGET_VS2022} --silent --accept-source-agreements --accept-package-agreements --disable-interactivity --force | out-null
 66: 
 67: # Load vcvarsall environment for x86
 68: $vcvarspath = &"${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -prerelease -latest -property InstallationPath
 69: cmd.exe /c "call `"$vcvarspath\VC\Auxiliary\Build\vcvarsall.bat`" x86 && set > %temp%\vcvars.txt"
 70: Get-Content "$env:temp\vcvars.txt" | Foreach-Object {
 71:   if ($_ -match "^(.*?)=(.*)$") {
 72:     Set-Content "env:\$($matches[1])" $matches[2]
 73:   }
 74: }
 75: 
 76: # Unset VCPKG_ROOT if set
 77: [Environment]::SetEnvironmentVariable('VCPKG_ROOT','')
 78: 
 79: # Add Github Packages registry
 80: nuget sources add -Name github -Source "https://nuget.pkg.github.com/julianxhokaxhiu/index.json" -Username ${env:GITHUB_REPOSITORY_OWNER} -Password ${env:GITHUB_PACKAGES_PAT} -StorePasswordInClearText
 81: nuget setApiKey ${env:GITHUB_PACKAGES_PAT} -Source "https://nuget.pkg.github.com/julianxhokaxhiu/index.json"
 82: nuget sources list
 83: 
 84: # Vcpkg setup
 85: cmd.exe /c "call $vcpkgRoot\bootstrap-vcpkg.bat"
 86: 
 87: vcpkg integrate install
 88: 
 89: # Start the build
 90: cmake --preset "${env:_RELEASE_CONFIGURATION}" -D_DLL_VERSION="$env:_BUILD_VERSION"
 91: cmake --build --preset "${env:_RELEASE_CONFIGURATION}"
 92: 
 93: # Start the packaging
 94: mkdir .dist\pkg\FF7_1998 | Out-Null
 95: mkdir .dist\pkg\FF8_2000 | Out-Null
 96: mkdir .dist\pkg\FFNx_Steam | Out-Null
 97: Copy-Item -R "$releasePath\bin\*" .dist\pkg\FF7_1998
 98: Copy-Item -R "$releasePath\bin\*" .dist\pkg\FF8_2000
 99: Copy-Item -R "$releasePath\bin\*" .dist\pkg\FFNx_Steam
100: Remove-Item .dist\pkg\FF7_1998\FF8.reg
101: Remove-Item .dist\pkg\FF8_2000\FF7.reg
102: Remove-Item .dist\pkg\FFNx_Steam\FF7.reg
103: Remove-Item .dist\pkg\FFNx_Steam\FF8.reg
104: Remove-Item .dist\pkg\FF7_1998\AF4DN.P
105: Remove-Item .dist\pkg\FF8_2000\AF4DN.P
106: Move-Item .dist\pkg\FF7_1998\FF7.reg .dist\pkg\FF7_1998\FFNx.reg
107: Move-Item .dist\pkg\FF8_2000\FF8.reg .dist\pkg\FF8_2000\FFNx.reg
108: Move-Item .dist\pkg\FF8_2000\FFNx.dll .dist\pkg\FF8_2000\eax.dll
109: Move-Item .dist\pkg\FFNx_Steam\FFNx.dll .dist\pkg\FFNx_Steam\AF3DN.P
110: 
111: 7z a ".\.dist\${env:_RELEASE_NAME}-FF7_1998-${env:_RELEASE_VERSION}.zip" ".\.dist\pkg\FF7_1998\*"
112: 7z a ".\.dist\${env:_RELEASE_NAME}-FF8_2000-${env:_RELEASE_VERSION}.zip" ".\.dist\pkg\FF8_2000\*"
113: 7z a ".\.dist\${env:_RELEASE_NAME}-Steam-${env:_RELEASE_VERSION}.zip" ".\.dist\pkg\FFNx_Steam\*"
114: 
115: Remove-Item -Recurse -Force .dist\pkg
</file>

<file path=".github/workflows/main-1.23.0.yml">
  1: name: FFNx
  2: 
  3: run-name: 1.23.0.${{ github.run_number }}
  4: 
  5: on:
  6:   workflow_dispatch:
  7:   push:
  8:     branches:
  9:     - master
 10:     tags:
 11:     - "*"
 12:   pull_request:
 13:     branches:
 14:     - master
 15: 
 16: env:
 17:   _IS_BUILD_CANARY: false
 18:   _IS_GITHUB_RELEASE: false
 19:   _RELEASE_NAME: FFNx
 20:   _RELEASE_VERSION: v0
 21:   _RELEASE_CONFIGURATION: Release
 22:   _BUILD_BRANCH: "${{ github.ref }}"
 23:   _CHANGELOG_VERSION: "0"
 24:   # GIT: Fix reporting from stderr to stdout
 25:   GIT_REDIRECT_STDERR: 2>&1
 26:   # Tools versions
 27:   _WINGET_CMAKE: 3.31.8
 28:   _WINGET_VS2022: 17.14.18
 29: 
 30: jobs:
 31:   FFNx:
 32:     runs-on: windows-latest
 33:     timeout-minutes: 1440
 34:     strategy:
 35:       max-parallel: 1
 36:     steps:
 37:     - name: Set Git Config
 38:       run: |
 39:         git config --global core.autocrlf false
 40:         git config --global core.filemode false
 41:         git config --global core.longpaths true
 42:     - name: Checkout
 43:       uses: actions/checkout@v4
 44:       with:
 45:         submodules: recursive
 46:         fetch-depth: 0
 47:     - name: Build
 48:       run: ".github/workflows/build.ps1"
 49:       shell: pwsh
 50:       env:
 51:         _BUILD_VERSION: "1.23.0.${{ github.run_number }}"
 52:         GITHUB_PACKAGES_PAT: ${{ secrets.GITHUB_TOKEN }}
 53:     - name: Upload vcpkg build logs
 54:       if: failure()
 55:       uses: actions/upload-artifact@v4
 56:       with:
 57:         name: vcpkg-logs
 58:         path: ${{ github.workspace }}/vcpkg/buildtrees/**/*.log
 59:     - name: Publish PR artifacts
 60:       if: env._IS_GITHUB_RELEASE == 'false' && success()
 61:       uses: actions/upload-artifact@v4.0.0
 62:       with:
 63:         name: "${{ env._RELEASE_NAME }}-${{ env._RELEASE_VERSION }}"
 64:         path: ".dist/*.zip"
 65:     - name: VirusTotal Scan
 66:       id: vt-scan
 67:       if: env._IS_GITHUB_RELEASE == 'true' && success()
 68:       uses: crazy-max/ghaction-virustotal@v4
 69:       with:
 70:         vt_api_key: ${{ secrets._VT_API_KEY }}
 71:         files: ".dist/*.zip"
 72:     - name: Parse VirusTotal Results
 73:       id: vt-res
 74:       if: env._IS_GITHUB_RELEASE == 'true' && success()
 75:       uses: actions/github-script@v7
 76:       with:
 77:         result-encoding: string
 78:         script: |
 79:           let ret = `${{ steps.vt-scan.outputs.analysis }}`;
 80: 
 81:           ret = '- ' + ret
 82:           .replaceAll('.dist/','')
 83:           .replaceAll('=h', ': h')
 84:           .replaceAll(',', "\n- ");
 85: 
 86:           console.log('Results:');
 87:           console.log(ret);
 88: 
 89:           return ret;
 90:     - name: Publish Canary release
 91:       uses: ncipollo/release-action@v1
 92:       if: env._IS_GITHUB_RELEASE == 'true' && env._IS_BUILD_CANARY == 'true' && success()
 93:       with:
 94:         artifacts: ".dist/*.zip"
 95:         allowUpdates: true
 96:         generateReleaseNotes: true
 97:         prerelease: true
 98:         removeArtifacts: true
 99:         tag: canary
100:         name: "${{ env._RELEASE_NAME }}-${{ env._RELEASE_VERSION }}"
101:         body: |
102:           See https://github.com/julianxhokaxhiu/FFNx/blob/master/Changelog.md#next
103: 
104:           This is a canary build. Please be aware it may be prone to crashing and is NOT tested by anyone. Use this build AT YOUR OWN RISK!
105: 
106:           üõ°Ô∏è **VirusTotal analysis:**
107:           ${{ steps.vt-res.outputs.result }}
108:     - name: Publish Stable release
109:       uses: ncipollo/release-action@v1
110:       if: env._IS_GITHUB_RELEASE == 'true' && env._IS_BUILD_CANARY == 'false' && success()
111:       with:
112:         artifacts: ".dist/*.zip"
113:         generateReleaseNotes: true
114:         makeLatest: true
115:         removeArtifacts: true
116:         name: "${{ env._RELEASE_NAME }}-${{ env._RELEASE_VERSION }}"
117:         body: |
118:           See https://github.com/julianxhokaxhiu/FFNx/blob/master/Changelog.md#${{ env._CHANGELOG_VERSION }}
119: 
120:           üõ°Ô∏è **VirusTotal analysis:**
121:           ${{ steps.vt-res.outputs.result }}
122:     - name: Send alerts
123:       if: env._IS_GITHUB_RELEASE == 'true' && success()
124:       env:
125:         _MAP_FFNX_TSUNAMODS_FF7: "${{ secrets._FFNX_TSUNAMODS_FF7 }}"
126:         _MAP_FFNX_TSUNAMODS_FF8: "${{ secrets._FFNX_TSUNAMODS_FF8 }}"
127:         _MAP_FFNX_QHIMM_FF7: "${{ secrets._FFNX_QHIMM_FF7 }}"
128:         _MAP_FFNX_QHIMM_FF8: "${{ secrets._FFNX_QHIMM_FF8 }}"
129:       run: ".github/workflows/alert.ps1"
130:       shell: pwsh
131:     - name: Cleanup previous release workflows
132:       uses: Mattraks/delete-workflow-runs@v2
133:       if: env._IS_GITHUB_RELEASE == 'true' && env._IS_BUILD_CANARY == 'false' && success()
134:       with:
135:         token: ${{ github.token }}
136:         repository: ${{ github.repository }}
137:         retain_days: 1
138:         keep_minimum_runs: 1
139:         delete_run_by_conclusion_pattern: >-
140:           ${{
141:             !contains(github.event.inputs.delete_run_by_name_pattern, '1.23.0')
142:             && github.event.inputs.delete_run_by_name_pattern
143:           }}
</file>

<file path=".github/FUNDING.yml">
 1: # These are supported funding model platforms
 2: 
 3: github: julianxhokaxhiu
 4: patreon: # Replace with a single Patreon username
 5: open_collective: # Replace with a single Open Collective username
 6: ko_fi: # Replace with a single Ko-fi username
 7: tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
 8: community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
 9: liberapay: # Replace with a single Liberapay username
10: issuehunt: # Replace with a single IssueHunt username
11: otechie: # Replace with a single Otechie username
12: custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
</file>

<file path=".github/pull_request_template.md">
 1: ## Summary
 2: 
 3: Brief explanation of the pull request.
 4: 
 5: ### Motivation
 6: 
 7: Why are you doing this? What use cases does it support? What is the expected outcome?
 8: 
 9: ### ACKs
10: 
11: - [ ] I have updated the [Changelog.md](https://github.com/julianxhokaxhiu/FFNx/blob/master/Changelog.md) file
12: - [ ] I did test my code on FF7
13: - [ ] I did test my code on FF8
</file>

<file path=".vcpkg/ports/bgfx/FindBGFX.cmake.in">
  1: # Distributed under the OSI-approved BSD 3-Clause License.
  2: #
  3: #.rst:
  4: # FindBGFX
  5: # --------
  6: #
  7: # Find the BGFX libraries
  8: #
  9: # Result Variables
 10: # ^^^^^^^^^^^^^^^^
 11: #
 12: # The following variables will be defined:
 13: #
 14: #  ``BGFX_FOUND``
 15: #    True if BGFX found on the local system
 16: #
 17: #  ``BGFX_INCLUDE_DIRS``
 18: #    Location of BGFX header files
 19: #
 20: #  ``BGFX_LIBRARY_DIRS``
 21: #    Location of BGFX libraries
 22: #
 23: #  ``BGFX_LIBRARIES``
 24: #    List of the BGFX libraries found
 25: #
 26: #
 27: 
 28: include(FindPackageHandleStandardArgs)
 29: include(SelectLibraryConfigurations)
 30: include(CMakeFindDependencyMacro)
 31: 
 32: if(NOT BGFX_FOUND)
 33: 
 34: # Compute the installation path relative to this file.
 35: get_filename_component(SEARCH_PATH "${CMAKE_CURRENT_LIST_FILE}" PATH)
 36: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 37: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 38: if(SEARCH_PATH STREQUAL "/")
 39:   set(SEARCH_PATH "")
 40: endif()
 41: 
 42: set(BGFX_VERSION "@BGFX_VERSION@")
 43: 
 44: function(append_dependencies out)
 45:     cmake_parse_arguments(PARSE_ARGV 1 "arg" "DEBUG" "NAMES" "")
 46:     if(${arg_DEBUG})
 47:         set(config DEBUG)
 48:         set(path "${CURRENT_INSTALLED_DIR}/debug/lib/")
 49:     else()
 50:         set(config RELEASE)
 51:         set(path "${CURRENT_INSTALLED_DIR}/lib/")
 52:     endif()
 53:     foreach(lib_name ${arg_NAMES})
 54:         if("${lib_name}" STREQUAL "-pthread")
 55:             list(APPEND ${out} "-pthread")
 56:         elseif("${lib_name}" STREQUAL "-pthreads")
 57:             list(APPEND ${out} "-pthreads")
 58:         elseif("${lib_name}" STREQUAL "gcc")
 59:             list(APPEND ${out} "-lgcc")
 60:         elseif("${lib_name}" STREQUAL "gcc_s")
 61:             list(APPEND ${out} "-lgcc_s")
 62:         elseif("${lib_name}" STREQUAL "stdc++")
 63:             list(APPEND ${out} "-lstdc++")
 64:         else()
 65:             # first look in ${path} specifically to ensure we find the right release/debug variant
 66:             find_library(BGFX_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" PATHS "${path}" NO_DEFAULT_PATH)
 67:             # if not found there, must be a system dependency, so look elsewhere
 68:             find_library(BGFX_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" REQUIRED)
 69:             list(APPEND ${out} "${BGFX_DEPENDENCY_${lib_name}_${config}}")
 70:         endif()
 71:     endforeach()
 72:     set("${out}" "${${out}}" PARENT_SCOPE)
 73: endfunction()
 74: 
 75: macro(BGFX_FIND libname shortname headername)
 76:   if(NOT BGFX_${libname}_INCLUDE_DIRS)
 77:     find_path(BGFX_${libname}_INCLUDE_DIRS NAMES ${headername} PATHS ${SEARCH_PATH}/include NO_DEFAULT_PATH)
 78:   endif()
 79:   if(NOT BGFX_${libname}_LIBRARY)
 80:     find_library(BGFX_${libname}_LIBRARY_RELEASE NAMES ${shortname}Release PATHS ${SEARCH_PATH}/lib/ NO_DEFAULT_PATH)
 81:     find_library(BGFX_${libname}_LIBRARY_DEBUG NAMES ${shortname}Debug PATHS ${SEARCH_PATH}/debug/lib/ NO_DEFAULT_PATH)
 82:     get_filename_component(BGFX_${libname}_LIBRARY_RELEASE_DIR ${BGFX_${libname}_LIBRARY_RELEASE} DIRECTORY)
 83:     get_filename_component(BGFX_${libname}_LIBRARY_DEBUG_DIR ${BGFX_${libname}_LIBRARY_DEBUG} DIRECTORY)
 84:     select_library_configurations(BGFX_${libname})
 85:     set(BGFX_${libname}_LIBRARY ${BGFX_${libname}_LIBRARY} CACHE STRING "")
 86:   endif()
 87:   if (BGFX_${libname}_LIBRARY AND BGFX_${libname}_INCLUDE_DIRS)
 88:     set(BGFX_${libname}_FOUND TRUE BOOL)
 89:     list(APPEND BGFX_INCLUDE_DIRS ${BGFX_${libname}_INCLUDE_DIRS})
 90:     list(APPEND BGFX_LIBRARIES ${BGFX_${libname}_LIBRARY})
 91:     list(APPEND BGFX_LIBRARY_DIRS ${BGFX_${libname}_LIBRARY_RELEASE_DIR} ${BGFX_${libname}_LIBRARY_DEBUG_DIR})
 92:   endif()
 93: endmacro(BGFX_FIND)
 94: 
 95: BGFX_FIND(bgfx bgfx bgfx/bgfx.h)
 96: 
 97: if (BGFX_bgfx_FOUND)
 98:   list(REMOVE_DUPLICATES BGFX_INCLUDE_DIRS)
 99:   list(REMOVE_DUPLICATES BGFX_LIBRARY_DIRS)
100:   set(BGFX_bgfx_VERSION "@BGFX_VERSION@" CACHE STRING "")
101: 
102:   append_dependencies(BGFX_DEPS_LIBRARY_RELEASE NAMES "@BGFX_DEPENDENCIES_RELEASE@")
103:   append_dependencies(BGFX_DEPS_LIBRARY_DEBUG   NAMES "@BGFX_DEPENDENCIES_DEBUG@" DEBUG)
104:   if(BGFX_DEPS_LIBRARY_RELEASE OR BGFX_DEPS_LIBRARY_DEBUG)
105:     select_library_configurations(BGFX_DEPS)
106:     list(APPEND BGFX_LIBRARIES ${BGFX_DEPS_LIBRARY})
107:   endif()
108: 
109:   set(BGFX_LIBRARY ${BGFX_LIBRARIES})
110: 
111:   set(BGFX_FOUND TRUE CACHE BOOL "")
112:   set(BGFX_LIBRARIES ${BGFX_LIBRARIES} CACHE STRING "")
113:   set(BGFX_INCLUDE_DIRS ${BGFX_INCLUDE_DIRS} CACHE STRING "")
114:   set(BGFX_LIBRARY_DIRS ${BGFX_LIBRARY_DIRS} CACHE STRING "")
115: endif()
116: 
117: find_package_handle_standard_args(BGFX REQUIRED_VARS BGFX_LIBRARIES BGFX_LIBRARY_DIRS BGFX_INCLUDE_DIRS)
118: 
119: endif()
</file>

<file path=".vcpkg/ports/bgfx/portfile.cmake">
  1: # For a list of common variables see https://github.com/microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md
  2: 
  3: # Download source packages
  4: # (bgfx requires bx and bimg source for building)
  5: 
  6: vcpkg_from_github(OUT_SOURCE_PATH BX_SOURCE_DIR
  7:     REPO "julianxhokaxhiu/bx"
  8:     HEAD_REF master
  9:     REF f3da9f2d061cdcda234c9c11cf6aac3dc4d76423
 10:     SHA512 f5f840ccaa6d9286eb2ce87cb547df6fef6e07ecba812afab97a9a2b866a3eb7e7dd8003c96eda2b73e1e8cde0b5a095386a73034dcdfcbc104f1beaaac94d83
 11: )
 12: 
 13: vcpkg_from_github(OUT_SOURCE_PATH BIMG_SOURCE_DIR
 14:     REPO "julianxhokaxhiu/bimg"
 15:     HEAD_REF master
 16:     REF a1a2ae3c129d8c33e765eecd91801bffd985c317
 17:     SHA512 568e91a739a8fdd190893b3cf5c7b923e25914fb00de24ad42fa85fd2318faab6b71bca373fba587080fef31a21445783a7f5b2d0f62e391c0d35ef279a5776e
 18: )
 19: 
 20: vcpkg_from_github(OUT_SOURCE_PATH SOURCE_DIR
 21:     REPO "julianxhokaxhiu/bgfx"
 22:     HEAD_REF master
 23:     REF 9f70dc3ddb15fc065b8a2ba635b9b9c397830480
 24:     SHA512 56fbe2cc45741f38a992a981b3bc6657be4f4a04a610afca35d757760d597f7f3b240f4a09a1cbd84a18dca7e04b7d77cffb65ff217ddbf939b8f6cd37a9b301
 25: )
 26: 
 27: # Move bx source inside bgfx source tree
 28: set(BX_DIR ${SOURCE_DIR}/.bx)
 29: file(RENAME ${BX_SOURCE_DIR} "${BX_DIR}")
 30: set(ENV{BX_DIR} ${BX_DIR})
 31: 
 32: # Move bimg source inside bgfx source tree
 33: set(BIMG_DIR ${SOURCE_DIR}/.bimg)
 34: file(RENAME ${BIMG_SOURCE_DIR} "${BIMG_DIR}")
 35: set(ENV{BIMG_DIR} ${BIMG_DIR})
 36: 
 37: # Set custom BGFX configuration
 38: math(EXPR BGFX_CONFIG_DYNAMIC_INDEX_BUFFER_SIZE "10<<20")
 39: math(EXPR BGFX_CONFIG_DYNAMIC_VERTEX_BUFFER_SIZE "30<<20")
 40: math(EXPR BGFX_CONFIG_MAX_RECT_CACHE "8<<10")
 41: math(EXPR BGFX_CONFIG_RENDERER_VULKAN_MAX_DESCRIPTOR_SETS_PER_FRAME "10240")
 42: set(ENV{BGFX_CONFIG} "DEBUG=1:PREFER_DISCRETE_GPU=0:DYNAMIC_INDEX_BUFFER_SIZE=${BGFX_CONFIG_DYNAMIC_INDEX_BUFFER_SIZE}:DYNAMIC_VERTEX_BUFFER_SIZE=${BGFX_CONFIG_DYNAMIC_VERTEX_BUFFER_SIZE}:MAX_RECT_CACHE=${BGFX_CONFIG_MAX_RECT_CACHE}:RENDERER_VULKAN_MAX_DESCRIPTOR_SETS_PER_FRAME=${BGFX_CONFIG_RENDERER_VULKAN_MAX_DESCRIPTOR_SETS_PER_FRAME}")
 43: 
 44: # Set up GENie (custom project generator)
 45: set(GENIE_OPTIONS --with-tools)
 46: 
 47: if(VCPKG_CRT_LINKAGE STREQUAL dynamic)
 48:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --with-dynamic-runtime)
 49: endif()
 50: if(VCPKG_LIBRARY_LINKAGE STREQUAL "dynamic")
 51:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --with-shared-lib)
 52: endif()
 53: 
 54: if(VCPKG_TARGET_ARCHITECTURE STREQUAL x86)
 55:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x32)
 56: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL x64)
 57:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x64)
 58: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL arm OR VCPKG_TARGET_ARCHITECTURE STREQUAL arm64)
 59:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=ARM)
 60: else()
 61:     message(WARNING "Architecture may be not supported: ${VCPKG_TARGET_ARCHITECTURE}")
 62:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=${VCPKG_TARGET_ARCHITECTURE})
 63: endif()
 64: 
 65: if(TARGET_TRIPLET MATCHES osx)
 66:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=macosx)
 67: elseif(TARGET_TRIPLET MATCHES linux)
 68:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=linux)
 69: elseif(TARGET_TRIPLET MATCHES windows)
 70:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=windows)
 71: elseif(TARGET_TRIPLET MATCHES uwp)
 72:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --vs=winstore100)
 73: endif()
 74: 
 75: # GENie does not allow cmake+msvc, so we use msbuild in windows
 76: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
 77:     if(VCPKG_PLATFORM_TOOLSET STREQUAL "v140")
 78:         set(GENIE_ACTION vs2015)
 79:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v141")
 80:         set(GENIE_ACTION vs2017)
 81:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v142")
 82:         set(GENIE_ACTION vs2019)
 83:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v143")
 84:         set(GENIE_ACTION vs2022)
 85:     else()
 86:         message(FATAL_ERROR "Unsupported Visual Studio toolset: ${VCPKG_PLATFORM_TOOLSET}")
 87:     endif()
 88:     set(PROJ_FOLDER ${GENIE_ACTION})
 89:     if(TARGET_TRIPLET MATCHES uwp)
 90:         set(PROJ_FOLDER ${PROJ_FOLDER}-winstore100)
 91:     endif()
 92: else()
 93:     set(GENIE_ACTION cmake)
 94:     set(PROJ_FOLDER ${GENIE_ACTION})
 95: endif()
 96: 
 97: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
 98:     set(GENIE "${BX_DIR}/tools/bin/windows/genie.exe")
 99: elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin")
100:     set(GENIE "${BX_DIR}/tools/bin/darwin/genie")
101: elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
102:     set(GENIE "${BX_DIR}/tools/bin/linux/genie")
103: else()
104:     message(FATAL_ERROR "Unsupported host platform: ${CMAKE_HOST_SYSTEM_NAME}")
105: endif()
106: 
107: # Run GENie
108: 
109: vcpkg_execute_required_process(
110:     COMMAND ${GENIE} ${GENIE_OPTIONS} ${GENIE_ACTION}
111:     WORKING_DIRECTORY "${SOURCE_DIR}"
112:     LOGNAME "genie-${TARGET_TRIPLET}"
113: )
114: 
115: if(GENIE_ACTION STREQUAL cmake)
116:     if(VCPKG_LIBRARY_LINKAGE STREQUAL "dynamic")
117:         set(PROJ bgfx-shared-lib)
118:     else()
119:         set(PROJ bgfx)
120:     endif()
121:     vcpkg_configure_cmake(
122:         SOURCE_PATH "${SOURCE_DIR}/.build/projects/${PROJ_FOLDER}"
123:         PREFER_NINJA
124:         OPTIONS_RELEASE -DCMAKE_BUILD_TYPE=Release
125:         OPTIONS_DEBUG -DCMAKE_BUILD_TYPE=Debug
126:     )
127:     vcpkg_install_cmake(TARGET ${PROJ}/all)
128:     file(INSTALL "${SOURCE_DIR}/include/bgfx" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
129:     file(GLOB instfiles
130:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/${PROJ}/*.a"
131:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/${PROJ}/*.so"
132:     )
133:     file(INSTALL ${instfiles} DESTINATION "${CURRENT_PACKAGES_DIR}/lib")
134:     file(GLOB instfiles
135:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/${PROJ}/*.a"
136:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/${PROJ}/*.so"
137:     )
138:     file(INSTALL ${instfiles} DESTINATION "${CURRENT_PACKAGES_DIR}/debug/lib")
139:     file(INSTALL "${SOURCE_DIR}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME "copyright")
140: else()
141:     vcpkg_msbuild_install(
142:         SOURCE_PATH "${SOURCE_DIR}"
143:         PROJECT_SUBPATH ".build/projects/${PROJ_FOLDER}/bgfx.sln"
144:     )
145:     file(INSTALL "${SOURCE_DIR}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME "copyright")
146:     file(INSTALL "${SOURCE_DIR}/include/" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
147:     # Install shader include file
148:     file(INSTALL "${SOURCE_DIR}/src/bgfx_shader.sh" DESTINATION "${CURRENT_PACKAGES_DIR}/include/bgfx" )
149:     # Remove redundant files
150:     foreach(a bx bimg bimg_decode bimg_encode)
151:         foreach(b Debug Release)
152:             foreach(c lib pdb)
153:                 if(b STREQUAL Debug)
154:                     file(REMOVE "${CURRENT_PACKAGES_DIR}/debug/lib/${a}${b}.${c}")
155:                 else()
156:                     file(REMOVE "${CURRENT_PACKAGES_DIR}/lib/${a}${b}.${c}")
157:                 endif()
158:             endforeach()
159:         endforeach()
160:     endforeach()
161: endif()
162: 
163: file(INSTALL "${CMAKE_CURRENT_LIST_DIR}/usage" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}")
164: configure_file(${CMAKE_CURRENT_LIST_DIR}/FindBGFX.cmake.in ${CURRENT_PACKAGES_DIR}/share/${PORT}/FindBGFX.cmake @ONLY)
165: file(COPY ${CMAKE_CURRENT_LIST_DIR}/vcpkg-cmake-wrapper.cmake DESTINATION ${CURRENT_PACKAGES_DIR}/share/${PORT})
</file>

<file path=".vcpkg/ports/bgfx/usage">
1: To use bgfx add the following to your CMake project:
2: 
3:     find_package(BGFX REQUIRED)
4:     target_include_directories(main PRIVATE ${BGFX_INCLUDE_DIRS})
5:     target_link_directories(main PRIVATE ${BGFX_LIBRARY_DIRS})
6:     target_link_libraries(main PRIVATE ${BGFX_LIBRARIES})
</file>

<file path=".vcpkg/ports/bgfx/vcpkg-cmake-wrapper.cmake">
1: set(BGFX_PREV_MODULE_PATH ${CMAKE_MODULE_PATH})
2: list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
3: 
4: cmake_policy(SET CMP0012 NEW)
5: 
6: _find_package(${ARGS})
7: 
8: set(CMAKE_MODULE_PATH ${BGFX_PREV_MODULE_PATH})
</file>

<file path=".vcpkg/ports/bgfx/vcpkg.json">
 1: {
 2:   "name": "bgfx",
 3:   "version": "1.0.0",
 4:   "description": "Cross-platform, graphics API agnostic, Bring Your Own Engine/Framework style rendering library.",
 5:   "homepage": "https://github.com/bkaradzic/bgfx",
 6:   "dependencies": [
 7:     "bx",
 8:     "bimg",
 9:     {
10:       "name": "vcpkg-msbuild",
11:       "host": true
12:     }
13:   ]
14: }
</file>

<file path=".vcpkg/ports/bimg/FindBIMG.cmake.in">
  1: # Distributed under the OSI-approved BSD 3-Clause License.
  2: #
  3: #.rst:
  4: # FindBIMG
  5: # --------
  6: #
  7: # Find the BIMG libraries
  8: #
  9: # Result Variables
 10: # ^^^^^^^^^^^^^^^^
 11: #
 12: # The following variables will be defined:
 13: #
 14: #  ``BIMG_FOUND``
 15: #    True if BIMG found on the local system
 16: #
 17: #  ``BIMG_INCLUDE_DIRS``
 18: #    Location of BIMG header files
 19: #
 20: #  ``BIMG_LIBRARY_DIRS``
 21: #    Location of BIMG libraries
 22: #
 23: #  ``BIMG_LIBRARIES``
 24: #    List of the BIMG libraries found
 25: #
 26: #
 27: 
 28: include(FindPackageHandleStandardArgs)
 29: include(SelectLibraryConfigurations)
 30: include(CMakeFindDependencyMacro)
 31: 
 32: if(NOT BIMG_FOUND)
 33: 
 34: # Compute the installation path relative to this file.
 35: get_filename_component(SEARCH_PATH "${CMAKE_CURRENT_LIST_FILE}" PATH)
 36: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 37: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 38: if(SEARCH_PATH STREQUAL "/")
 39:   set(SEARCH_PATH "")
 40: endif()
 41: 
 42: set(BIMG_VERSION "@BIMG_VERSION@")
 43: 
 44: function(append_dependencies out)
 45:     cmake_parse_arguments(PARSE_ARGV 1 "arg" "DEBUG" "NAMES" "")
 46:     if(${arg_DEBUG})
 47:         set(config DEBUG)
 48:         set(path "${CURRENT_INSTALLED_DIR}/debug/lib/")
 49:     else()
 50:         set(config RELEASE)
 51:         set(path "${CURRENT_INSTALLED_DIR}/lib/")
 52:     endif()
 53:     foreach(lib_name ${arg_NAMES})
 54:         if("${lib_name}" STREQUAL "-pthread")
 55:             list(APPEND ${out} "-pthread")
 56:         elseif("${lib_name}" STREQUAL "-pthreads")
 57:             list(APPEND ${out} "-pthreads")
 58:         elseif("${lib_name}" STREQUAL "gcc")
 59:             list(APPEND ${out} "-lgcc")
 60:         elseif("${lib_name}" STREQUAL "gcc_s")
 61:             list(APPEND ${out} "-lgcc_s")
 62:         elseif("${lib_name}" STREQUAL "stdc++")
 63:             list(APPEND ${out} "-lstdc++")
 64:         else()
 65:             # first look in ${path} specifically to ensure we find the right release/debug variant
 66:             find_library(BIMG_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" PATHS "${path}" NO_DEFAULT_PATH)
 67:             # if not found there, must be a system dependency, so look elsewhere
 68:             find_library(BIMG_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" REQUIRED)
 69:             list(APPEND ${out} "${BIMG_DEPENDENCY_${lib_name}_${config}}")
 70:         endif()
 71:     endforeach()
 72:     set("${out}" "${${out}}" PARENT_SCOPE)
 73: endfunction()
 74: 
 75: macro(BIMG_FIND libname shortname headername)
 76:   if(NOT BIMG_${libname}_INCLUDE_DIRS)
 77:     find_path(BIMG_${libname}_INCLUDE_DIRS NAMES ${headername} PATHS ${SEARCH_PATH}/include NO_DEFAULT_PATH)
 78:   endif()
 79:   if(NOT BIMG_${libname}_LIBRARY)
 80:     find_library(BIMG_${libname}_LIBRARY_RELEASE NAMES ${shortname}Release PATHS ${SEARCH_PATH}/lib/ NO_DEFAULT_PATH)
 81:     find_library(BIMG_${libname}_LIBRARY_DEBUG NAMES ${shortname}Debug PATHS ${SEARCH_PATH}/debug/lib/ NO_DEFAULT_PATH)
 82:     get_filename_component(BIMG_${libname}_LIBRARY_RELEASE_DIR ${BIMG_${libname}_LIBRARY_RELEASE} DIRECTORY)
 83:     get_filename_component(BIMG_${libname}_LIBRARY_DEBUG_DIR ${BIMG_${libname}_LIBRARY_DEBUG} DIRECTORY)
 84:     select_library_configurations(BIMG_${libname})
 85:     set(BIMG_${libname}_LIBRARY ${BIMG_${libname}_LIBRARY} CACHE STRING "")
 86:   endif()
 87:   if (BIMG_${libname}_LIBRARY AND BIMG_${libname}_INCLUDE_DIRS)
 88:     set(BIMG_${libname}_FOUND TRUE BOOL)
 89:     list(APPEND BIMG_INCLUDE_DIRS ${BIMG_${libname}_INCLUDE_DIRS})
 90:     list(APPEND BIMG_LIBRARIES ${BIMG_${libname}_LIBRARY})
 91:     list(APPEND BIMG_LIBRARY_DIRS ${BIMG_${libname}_LIBRARY_RELEASE_DIR} ${BIMG_${libname}_LIBRARY_DEBUG_DIR})
 92:   endif()
 93: endmacro(BIMG_FIND)
 94: 
 95: BIMG_FIND(bimg bimg bimg/bimg.h)
 96: BIMG_FIND(bimg_decode bimg_decode bimg/decode.h)
 97: BIMG_FIND(bimg_encode bimg_encode bimg/encode.h)
 98: 
 99: if (BIMG_bimg_FOUND)
100:   list(REMOVE_DUPLICATES BIMG_INCLUDE_DIRS)
101:   list(REMOVE_DUPLICATES BIMG_LIBRARY_DIRS)
102:   set(BIMG_bimg_VERSION "@BIMG_VERSION@" CACHE STRING "")
103: 
104:   append_dependencies(BIMG_DEPS_LIBRARY_RELEASE NAMES "@BIMG_DEPENDENCIES_RELEASE@")
105:   append_dependencies(BIMG_DEPS_LIBRARY_DEBUG   NAMES "@BIMG_DEPENDENCIES_DEBUG@" DEBUG)
106:   if(BIMG_DEPS_LIBRARY_RELEASE OR BIMG_DEPS_LIBRARY_DEBUG)
107:     select_library_configurations(BIMG_DEPS)
108:     list(APPEND BIMG_LIBRARIES ${BIMG_DEPS_LIBRARY})
109:   endif()
110: 
111:   set(BIMG_LIBRARY ${BIMG_LIBRARIES})
112: 
113:   set(BIMG_FOUND TRUE CACHE BOOL "")
114:   set(BIMG_LIBRARIES ${BIMG_LIBRARIES} CACHE STRING "")
115:   set(BIMG_INCLUDE_DIRS ${BIMG_INCLUDE_DIRS} CACHE STRING "")
116:   set(BIMG_LIBRARY_DIRS ${BIMG_LIBRARY_DIRS} CACHE STRING "")
117: endif()
118: 
119: find_package_handle_standard_args(BIMG REQUIRED_VARS BIMG_LIBRARIES BIMG_LIBRARY_DIRS BIMG_INCLUDE_DIRS)
120: 
121: endif()
</file>

<file path=".vcpkg/ports/bimg/portfile.cmake">
  1: # For a list of common variables see https://github.com/microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md
  2: 
  3: # Download source packages
  4: # (bimg requires bx source for building)
  5: 
  6: vcpkg_from_github(OUT_SOURCE_PATH BX_SOURCE_DIR
  7:     REPO "julianxhokaxhiu/bx"
  8:     HEAD_REF master
  9:     REF f3da9f2d061cdcda234c9c11cf6aac3dc4d76423
 10:     SHA512 f5f840ccaa6d9286eb2ce87cb547df6fef6e07ecba812afab97a9a2b866a3eb7e7dd8003c96eda2b73e1e8cde0b5a095386a73034dcdfcbc104f1beaaac94d83
 11: )
 12: 
 13: vcpkg_from_github(OUT_SOURCE_PATH SOURCE_DIR
 14:     REPO "julianxhokaxhiu/bimg"
 15:     HEAD_REF master
 16:     REF a1a2ae3c129d8c33e765eecd91801bffd985c317
 17:     SHA512 568e91a739a8fdd190893b3cf5c7b923e25914fb00de24ad42fa85fd2318faab6b71bca373fba587080fef31a21445783a7f5b2d0f62e391c0d35ef279a5776e
 18: )
 19: 
 20: # Move bx source inside bgfx source tree
 21: set(BX_DIR ${SOURCE_DIR}/.bx)
 22: file(RENAME ${BX_SOURCE_DIR} "${BX_DIR}")
 23: set(ENV{BX_DIR} ${BX_DIR})
 24: 
 25: # Set up GENie (custom project generator)
 26: 
 27: if(VCPKG_CRT_LINKAGE STREQUAL dynamic)
 28:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --with-dynamic-runtime)
 29: endif()
 30: if(VCPKG_LIBRARY_LINKAGE STREQUAL dynamic)
 31:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --with-shared-lib)
 32: endif()
 33: 
 34: if(VCPKG_TARGET_ARCHITECTURE STREQUAL x86)
 35:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x32)
 36: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL x64)
 37:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x64)
 38: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL arm OR VCPKG_TARGET_ARCHITECTURE STREQUAL arm64)
 39:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=ARM)
 40: else()
 41:     message(WARNING "Architecture may be not supported: ${VCPKG_TARGET_ARCHITECTURE}")
 42:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=${VCPKG_TARGET_ARCHITECTURE})
 43: endif()
 44: 
 45: if(TARGET_TRIPLET MATCHES osx)
 46:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=macosx)
 47: elseif(TARGET_TRIPLET MATCHES linux)
 48:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=linux)
 49: elseif(TARGET_TRIPLET MATCHES windows)
 50:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=windows)
 51: elseif(TARGET_TRIPLET MATCHES uwp)
 52:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --vs=winstore100)
 53: endif()
 54: 
 55: # GENie does not allow cmake+msvc, so we use msbuild in windows
 56: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
 57:     if(VCPKG_PLATFORM_TOOLSET STREQUAL "v140")
 58:         set(GENIE_ACTION vs2015)
 59:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v141")
 60:         set(GENIE_ACTION vs2017)
 61:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v142")
 62:         set(GENIE_ACTION vs2019)
 63:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v143")
 64:         set(GENIE_ACTION vs2022)
 65:     else()
 66:         message(FATAL_ERROR "Unsupported Visual Studio toolset: ${VCPKG_PLATFORM_TOOLSET}")
 67:     endif()
 68:     set(PROJ_FOLDER ${GENIE_ACTION})
 69:     if(TARGET_TRIPLET MATCHES uwp)
 70:         set(PROJ_FOLDER ${PROJ_FOLDER}-winstore100)
 71:     endif()
 72: else()
 73:     set(GENIE_ACTION cmake)
 74:     set(PROJ_FOLDER ${GENIE_ACTION})
 75: endif()
 76: 
 77: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
 78:     set(GENIE "${BX_DIR}/tools/bin/windows/genie.exe")
 79: elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin")
 80:     set(GENIE "${BX_DIR}/tools/bin/darwin/genie")
 81: elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
 82:     set(GENIE "${BX_DIR}/tools/bin/linux/genie")
 83: else()
 84:     message(FATAL_ERROR "Unsupported host platform: ${CMAKE_HOST_SYSTEM_NAME}")
 85: endif()
 86: 
 87: # Run GENie
 88: 
 89: vcpkg_execute_required_process(
 90:     COMMAND ${GENIE} ${GENIE_OPTIONS} ${GENIE_ACTION}
 91:     WORKING_DIRECTORY "${SOURCE_DIR}"
 92:     LOGNAME "genie-${TARGET_TRIPLET}"
 93: )
 94: 
 95: if(GENIE_ACTION STREQUAL cmake)
 96:     # Run CMake
 97:     vcpkg_configure_cmake(
 98:         SOURCE_PATH "${SOURCE_DIR}/.build/projects/${PROJ_FOLDER}"
 99:         PREFER_NINJA
100:         OPTIONS_RELEASE -DCMAKE_BUILD_TYPE=Release
101:         OPTIONS_DEBUG -DCMAKE_BUILD_TYPE=Debug
102:     )
103:     vcpkg_install_cmake(TARGET bimg/all)
104:     vcpkg_install_cmake(TARGET bimg_encode/all)
105:     vcpkg_install_cmake(TARGET bimg_decode/all)
106:     # GENie does not generate an install target, so we install explicitly
107:     file(INSTALL "${SOURCE_DIR}/include/bimg" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
108:     file(GLOB instfiles
109:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/bimg/*.a"
110:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/bimg/*.so"
111:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/bimg_encode/*.a"
112:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/bimg_encode/*.so"
113:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/bimg_decode/*.a"
114:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/bimg_decode/*.so"
115:     )
116:     file(INSTALL ${instfiles} DESTINATION "${CURRENT_PACKAGES_DIR}/lib")
117:     file(GLOB instfiles
118:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/bimg/*.a"
119:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/bimg/*.so"
120:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/bimg_encode/*.a"
121:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/bimg_encode/*.so"
122:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/bimg_decode/*.a"
123:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/bimg_decode/*.so"
124:     )
125:     file(INSTALL ${instfiles} DESTINATION "${CURRENT_PACKAGES_DIR}/debug/lib")
126:     file(INSTALL "${SOURCE_DIR}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME copyright)
127: else()
128:     # Run MSBuild for all 3 targets
129:     foreach(PROJ bimg bimg_decode bimg_encode)
130:         vcpkg_msbuild_install(
131:             SOURCE_PATH "${SOURCE_DIR}"
132:             PROJECT_SUBPATH ".build/projects/${PROJ_FOLDER}/${PROJ}.vcxproj"
133:         )
134:     endforeach()
135:     file(INSTALL "${SOURCE_DIR}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME "copyright")
136:     file(INSTALL "${SOURCE_DIR}/include/" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
137:     # Remove redundant files
138:     foreach(a bx)
139:         foreach(b Debug Release)
140:             foreach(c lib pdb)
141:                 if(b STREQUAL Debug)
142:                     file(REMOVE "${CURRENT_PACKAGES_DIR}/debug/lib/${a}${b}.${c}")
143:                 else()
144:                     file(REMOVE "${CURRENT_PACKAGES_DIR}/lib/${a}${b}.${c}")
145:                 endif()
146:             endforeach()
147:         endforeach()
148:     endforeach()
149: endif()
150: 
151: file(INSTALL "${CMAKE_CURRENT_LIST_DIR}/usage" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}")
152: configure_file(${CMAKE_CURRENT_LIST_DIR}/FindBIMG.cmake.in ${CURRENT_PACKAGES_DIR}/share/${PORT}/FindBIMG.cmake @ONLY)
153: file(COPY ${CMAKE_CURRENT_LIST_DIR}/vcpkg-cmake-wrapper.cmake DESTINATION ${CURRENT_PACKAGES_DIR}/share/${PORT})
</file>

<file path=".vcpkg/ports/bimg/usage">
1: To use bimg add the following to your CMake project:
2: 
3:     find_package(BIMG REQUIRED)
4:     target_include_directories(main PRIVATE ${BIMG_INCLUDE_DIRS})
5:     target_link_directories(main PRIVATE ${BIMG_LIBRARY_DIRS})
6:     target_link_libraries(main PRIVATE ${BIMG_LIBRARIES})
</file>

<file path=".vcpkg/ports/bimg/vcpkg-cmake-wrapper.cmake">
1: set(BIMG_PREV_MODULE_PATH ${CMAKE_MODULE_PATH})
2: list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
3: 
4: cmake_policy(SET CMP0012 NEW)
5: 
6: _find_package(${ARGS})
7: 
8: set(CMAKE_MODULE_PATH ${BIMG_PREV_MODULE_PATH})
</file>

<file path=".vcpkg/ports/bimg/vcpkg.json">
 1: {
 2:   "name": "bimg",
 3:   "version": "1.0.0",
 4:   "description": "Image library",
 5:   "homepage": "https://github.com/bkaradzic/bimg",
 6:   "dependencies": [
 7:     "bx",
 8:     {
 9:       "name": "vcpkg-msbuild",
10:       "host": true
11:     }
12:   ]
13: }
</file>

<file path=".vcpkg/ports/bx/FindBX.cmake.in">
  1: # Distributed under the OSI-approved BSD 3-Clause License.
  2: #
  3: #.rst:
  4: # FindBX
  5: # --------
  6: #
  7: # Find the BX libraries
  8: #
  9: # Result Variables
 10: # ^^^^^^^^^^^^^^^^
 11: #
 12: # The following variables will be defined:
 13: #
 14: #  ``BX_FOUND``
 15: #    True if BX found on the local system
 16: #
 17: #  ``BX_INCLUDE_DIRS``
 18: #    Location of BX header files
 19: #
 20: #  ``BX_LIBRARY_DIRS``
 21: #    Location of BX libraries
 22: #
 23: #  ``BX_LIBRARIES``
 24: #    List of the BX libraries found
 25: #
 26: #
 27: 
 28: include(FindPackageHandleStandardArgs)
 29: include(SelectLibraryConfigurations)
 30: include(CMakeFindDependencyMacro)
 31: 
 32: if(NOT BX_FOUND)
 33: 
 34: # Compute the installation path relative to this file.
 35: get_filename_component(SEARCH_PATH "${CMAKE_CURRENT_LIST_FILE}" PATH)
 36: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 37: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 38: if(SEARCH_PATH STREQUAL "/")
 39:   set(SEARCH_PATH "")
 40: endif()
 41: 
 42: set(BX_VERSION "@BX_VERSION@")
 43: 
 44: function(append_dependencies out)
 45:     cmake_parse_arguments(PARSE_ARGV 1 "arg" "DEBUG" "NAMES" "")
 46:     if(${arg_DEBUG})
 47:         set(config DEBUG)
 48:         set(path "${CURRENT_INSTALLED_DIR}/debug/lib/")
 49:     else()
 50:         set(config RELEASE)
 51:         set(path "${CURRENT_INSTALLED_DIR}/lib/")
 52:     endif()
 53:     foreach(lib_name ${arg_NAMES})
 54:         if("${lib_name}" STREQUAL "-pthread")
 55:             list(APPEND ${out} "-pthread")
 56:         elseif("${lib_name}" STREQUAL "-pthreads")
 57:             list(APPEND ${out} "-pthreads")
 58:         elseif("${lib_name}" STREQUAL "gcc")
 59:             list(APPEND ${out} "-lgcc")
 60:         elseif("${lib_name}" STREQUAL "gcc_s")
 61:             list(APPEND ${out} "-lgcc_s")
 62:         elseif("${lib_name}" STREQUAL "stdc++")
 63:             list(APPEND ${out} "-lstdc++")
 64:         else()
 65:             # first look in ${path} specifically to ensure we find the right release/debug variant
 66:             find_library(BX_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" PATHS "${path}" NO_DEFAULT_PATH)
 67:             # if not found there, must be a system dependency, so look elsewhere
 68:             find_library(BX_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" REQUIRED)
 69:             list(APPEND ${out} "${BX_DEPENDENCY_${lib_name}_${config}}")
 70:         endif()
 71:     endforeach()
 72:     set("${out}" "${${out}}" PARENT_SCOPE)
 73: endfunction()
 74: 
 75: macro(BX_FIND libname shortname headername)
 76:   if(NOT BX_${libname}_INCLUDE_DIRS)
 77:     find_path(BX_${libname}_INCLUDE_DIRS NAMES ${headername} PATHS ${SEARCH_PATH}/include NO_DEFAULT_PATH)
 78:   endif()
 79:   if(NOT BX_${libname}_LIBRARY)
 80:     find_library(BX_${libname}_LIBRARY_RELEASE NAMES ${shortname}Release PATHS ${SEARCH_PATH}/lib/ NO_DEFAULT_PATH)
 81:     find_library(BX_${libname}_LIBRARY_DEBUG NAMES ${shortname}Debug PATHS ${SEARCH_PATH}/debug/lib/ NO_DEFAULT_PATH)
 82:     get_filename_component(BX_${libname}_LIBRARY_RELEASE_DIR ${BX_${libname}_LIBRARY_RELEASE} DIRECTORY)
 83:     get_filename_component(BX_${libname}_LIBRARY_DEBUG_DIR ${BX_${libname}_LIBRARY_DEBUG} DIRECTORY)
 84:     select_library_configurations(BX_${libname})
 85:     set(BX_${libname}_LIBRARY ${BX_${libname}_LIBRARY} CACHE STRING "")
 86:   endif()
 87:   if (BX_${libname}_LIBRARY AND BX_${libname}_INCLUDE_DIRS)
 88:     set(BX_${libname}_FOUND TRUE BOOL)
 89:     list(APPEND BX_INCLUDE_DIRS ${BX_${libname}_INCLUDE_DIRS})
 90:     list(APPEND BX_LIBRARIES ${BX_${libname}_LIBRARY})
 91:     list(APPEND BX_LIBRARY_DIRS ${BX_${libname}_LIBRARY_RELEASE_DIR} ${BX_${libname}_LIBRARY_DEBUG_DIR})
 92:   endif()
 93: endmacro(BX_FIND)
 94: 
 95: BX_FIND(bx bx bx/bx.h)
 96: 
 97: if (BX_bx_FOUND)
 98:   list(APPEND BX_INCLUDE_DIRS "${SEARCH_PATH}/include/compat/msvc")
 99:   list(REMOVE_DUPLICATES BX_INCLUDE_DIRS)
100:   list(REMOVE_DUPLICATES BX_LIBRARY_DIRS)
101:   set(BX_bx_VERSION "@BX_VERSION@" CACHE STRING "")
102: 
103:   append_dependencies(BX_DEPS_LIBRARY_RELEASE NAMES "@BX_DEPENDENCIES_RELEASE@")
104:   append_dependencies(BX_DEPS_LIBRARY_DEBUG   NAMES "@BX_DEPENDENCIES_DEBUG@" DEBUG)
105:   if(BX_DEPS_LIBRARY_RELEASE OR BX_DEPS_LIBRARY_DEBUG)
106:     select_library_configurations(BX_DEPS)
107:     list(APPEND BX_LIBRARIES ${BX_DEPS_LIBRARY})
108:   endif()
109: 
110:   set(BX_LIBRARY ${BX_LIBRARIES})
111: 
112:   set(BX_FOUND TRUE CACHE BOOL "")
113:   set(BX_LIBRARIES ${BX_LIBRARIES} CACHE STRING "")
114:   set(BX_INCLUDE_DIRS ${BX_INCLUDE_DIRS} CACHE STRING "")
115:   set(BX_LIBRARY_DIRS ${BX_LIBRARY_DIRS} CACHE STRING "")
116: endif()
117: 
118: find_package_handle_standard_args(BX REQUIRED_VARS BX_LIBRARIES BX_LIBRARY_DIRS BX_INCLUDE_DIRS)
119: 
120: endif()
</file>

<file path=".vcpkg/ports/bx/portfile.cmake">
  1: # For a list of common variables see https://github.com/microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md
  2: 
  3: vcpkg_check_linkage(ONLY_STATIC_LIBRARY)
  4: 
  5: # Download source
  6: 
  7: vcpkg_from_github(OUT_SOURCE_PATH SOURCE_DIR
  8:     REPO "julianxhokaxhiu/bx"
  9:     HEAD_REF master
 10:     REF f3da9f2d061cdcda234c9c11cf6aac3dc4d76423
 11:     SHA512 f5f840ccaa6d9286eb2ce87cb547df6fef6e07ecba812afab97a9a2b866a3eb7e7dd8003c96eda2b73e1e8cde0b5a095386a73034dcdfcbc104f1beaaac94d83
 12: )
 13: 
 14: # Set up GENie (custom project generator)
 15: 
 16: if(VCPKG_CRT_LINKAGE STREQUAL dynamic)
 17:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --with-dynamic-runtime)
 18: endif()
 19: 
 20: if(VCPKG_TARGET_ARCHITECTURE STREQUAL x86)
 21:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x32)
 22: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL x64)
 23:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x64)
 24: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL arm OR VCPKG_TARGET_ARCHITECTURE STREQUAL arm64)
 25:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=ARM)
 26: else()
 27:     message(WARNING "Architecture may be not supported: ${VCPKG_TARGET_ARCHITECTURE}")
 28:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=${VCPKG_TARGET_ARCHITECTURE})
 29: endif()
 30: 
 31: if(TARGET_TRIPLET MATCHES osx)
 32:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=macosx)
 33: elseif(TARGET_TRIPLET MATCHES linux)
 34:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=linux)
 35: elseif(TARGET_TRIPLET MATCHES windows)
 36:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=windows)
 37: elseif(TARGET_TRIPLET MATCHES uwp)
 38:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --vs=winstore100)
 39: endif()
 40: 
 41: # GENie does not allow cmake+msvc, so we use msbuild in windows
 42: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
 43:     if(VCPKG_PLATFORM_TOOLSET STREQUAL "v140")
 44:         set(GENIE_ACTION vs2015)
 45:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v141")
 46:         set(GENIE_ACTION vs2017)
 47:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v142")
 48:         set(GENIE_ACTION vs2019)
 49:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v143")
 50:         set(GENIE_ACTION vs2022)
 51:     else()
 52:         message(FATAL_ERROR "Unsupported Visual Studio toolset: ${VCPKG_PLATFORM_TOOLSET}")
 53:     endif()
 54:     set(PROJ_FOLDER ${GENIE_ACTION})
 55:     if(TARGET_TRIPLET MATCHES uwp)
 56:         set(PROJ_FOLDER ${PROJ_FOLDER}-winstore100)
 57:     endif()
 58: else()
 59:     set(GENIE_ACTION cmake)
 60:     set(PROJ_FOLDER ${GENIE_ACTION})
 61: endif()
 62: 
 63: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
 64:     set(GENIE "${SOURCE_DIR}/tools/bin/windows/genie.exe")
 65: elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin")
 66:     set(GENIE "${SOURCE_DIR}/tools/bin/darwin/genie")
 67: elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
 68:     set(GENIE "${SOURCE_DIR}/tools/bin/linux/genie")
 69: else()
 70:     message(FATAL_ERROR "Unsupported host platform: ${CMAKE_HOST_SYSTEM_NAME}")
 71: endif()
 72: 
 73: # Run GENie
 74: 
 75: vcpkg_execute_required_process(
 76:     COMMAND ${GENIE} ${GENIE_OPTIONS} ${GENIE_ACTION}
 77:     WORKING_DIRECTORY "${SOURCE_DIR}"
 78:     LOGNAME "genie-${TARGET_TRIPLET}"
 79: )
 80: 
 81: if(GENIE_ACTION STREQUAL cmake)
 82:     # Run CMake
 83:     vcpkg_configure_cmake(
 84:         SOURCE_PATH "${SOURCE_DIR}/.build/projects/${PROJ_FOLDER}"
 85:         PREFER_NINJA
 86:         OPTIONS_RELEASE -DCMAKE_BUILD_TYPE=Release
 87:         OPTIONS_DEBUG -DCMAKE_BUILD_TYPE=Debug
 88:     )
 89:     vcpkg_install_cmake(TARGET bx/all)
 90:     # GENie does not generate an install target, so we install explicitly
 91:     file(INSTALL
 92:         "${SOURCE_DIR}/include/bx"
 93:         "${SOURCE_DIR}/include/compat"
 94:         "${SOURCE_DIR}/include/tinystl"
 95:         DESTINATION "${CURRENT_PACKAGES_DIR}/include")
 96:     file(GLOB instfiles
 97:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel/bx/*.a"
 98:     )
 99:     file(INSTALL ${instfiles} DESTINATION "${CURRENT_PACKAGES_DIR}/lib")
100:     file(GLOB instfiles
101:         "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-dbg/bx/*.a"
102:     )
103:     file(INSTALL ${instfiles} DESTINATION "${CURRENT_PACKAGES_DIR}/debug/lib")
104:     file(INSTALL "${SOURCE_DIR}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME copyright)
105: else()
106:     # Run MSBuild
107:     vcpkg_msbuild_install(
108:         SOURCE_PATH "${SOURCE_DIR}"
109:         PROJECT_SUBPATH ".build/projects/${PROJ_FOLDER}/bx.vcxproj"
110:     )
111:     file(INSTALL "${SOURCE_DIR}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME "copyright")
112:     file(INSTALL "${SOURCE_DIR}/include/" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
113: endif()
114: 
115: file(INSTALL "${CMAKE_CURRENT_LIST_DIR}/usage" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}")
116: configure_file(${CMAKE_CURRENT_LIST_DIR}/FindBX.cmake.in ${CURRENT_PACKAGES_DIR}/share/${PORT}/FindBX.cmake @ONLY)
117: file(COPY ${CMAKE_CURRENT_LIST_DIR}/vcpkg-cmake-wrapper.cmake DESTINATION ${CURRENT_PACKAGES_DIR}/share/${PORT})
</file>

<file path=".vcpkg/ports/bx/usage">
1: To use bx add the following to your CMake project:
2: 
3:     find_package(BX REQUIRED)
4:     target_include_directories(main PRIVATE ${BX_INCLUDE_DIRS})
5:     target_link_directories(main PRIVATE ${BX_LIBRARY_DIRS})
6:     target_link_libraries(main PRIVATE ${BX_LIBRARIES})
</file>

<file path=".vcpkg/ports/bx/vcpkg-cmake-wrapper.cmake">
1: set(BX_PREV_MODULE_PATH ${CMAKE_MODULE_PATH})
2: list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
3: 
4: cmake_policy(SET CMP0012 NEW)
5: 
6: _find_package(${ARGS})
7: 
8: set(CMAKE_MODULE_PATH ${BX_PREV_MODULE_PATH})
</file>

<file path=".vcpkg/ports/bx/vcpkg.json">
 1: {
 2:   "name": "bx",
 3:   "version": "1.0.0",
 4:   "description": "Base library used across multiple projects",
 5:   "homepage": "https://github.com/bkaradzic/bx",
 6:   "dependencies": [
 7:     {
 8:       "name": "vcpkg-msbuild",
 9:       "host": true
10:     }
11:   ]
12: }
</file>

<file path=".vcpkg/ports/hwinfo/portfile.cmake">
 1: vcpkg_check_linkage(ONLY_STATIC_LIBRARY)
 2: 
 3: vcpkg_from_github(
 4:     OUT_SOURCE_PATH SOURCE_PATH
 5:     REPO julianxhokaxhiu/hwinfo
 6:     REF 196c4a7313be90b49d1ef899998c32d462075e1d
 7:     SHA512 638e09932bde83381baea9c311c66a573cf63f517a94aab2205eb6f69046437df5fbbb712a389205a4e81f6109fa1dc28d3bb4da432aabb529bc6a6f4edc9fd3
 8: )
 9: 
10: vcpkg_cmake_configure(
11:     SOURCE_PATH "${SOURCE_PATH}"
12:     OPTIONS
13:         -DHWINFO_SHARED=OFF
14:         -DHWINFO_STATIC=ON
15: )
16: vcpkg_cmake_install()
17: vcpkg_cmake_config_fixup(
18:     CONFIG_PATH lib/cmake/hwinfo
19:     PACKAGE_NAME lfreist-hwinfo
20: )
21: 
22: file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/include")
23: 
24: vcpkg_install_copyright(FILE_LIST "${SOURCE_PATH}/LICENSE")
</file>

<file path=".vcpkg/ports/hwinfo/vcpkg.json">
 1: {
 2:   "name": "hwinfo",
 3:   "version": "1.0.0",
 4:   "description": "cross platform C++ library for hardware information (CPU, RAM, GPU, ...)",
 5:   "homepage": "https://github.com/lfreist/hwinfo",
 6:   "license": "MIT",
 7:   "supports": "(windows | linux) & !uwp",
 8:   "dependencies": [
 9:     "fmt",
10:     {
11:       "name": "vcpkg-cmake",
12:       "host": true
13:     },
14:     {
15:       "name": "vcpkg-cmake-config",
16:       "host": true
17:     }
18:   ]
19: }
</file>

<file path=".vcpkg/ports/openpsf/FindOPENPSF.cmake.in">
  1: # Distributed under the OSI-approved BSD 3-Clause License.
  2: #
  3: #.rst:
  4: # FindOPENPSF
  5: # --------
  6: #
  7: # Find the OPENPSF libraries
  8: #
  9: # Result Variables
 10: # ^^^^^^^^^^^^^^^^
 11: #
 12: # The following variables will be defined:
 13: #
 14: #  ``OPENPSF_FOUND``
 15: #    True if OPENPSF found on the local system
 16: #
 17: #  ``OPENPSF_INCLUDE_DIRS``
 18: #    Location of OPENPSF header files
 19: #
 20: #  ``OPENPSF_LIBRARY_DIRS``
 21: #    Location of OPENPSF libraries
 22: #
 23: #  ``OPENPSF_LIBRARIES``
 24: #    List of the OPENPSF libraries found
 25: #
 26: #
 27: 
 28: include(FindPackageHandleStandardArgs)
 29: include(SelectLibraryConfigurations)
 30: include(CMakeFindDependencyMacro)
 31: 
 32: if(NOT OPENPSF_FOUND)
 33: 
 34: # Compute the installation path relative to this file.
 35: get_filename_component(SEARCH_PATH "${CMAKE_CURRENT_LIST_FILE}" PATH)
 36: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 37: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 38: if(SEARCH_PATH STREQUAL "/")
 39:   set(SEARCH_PATH "")
 40: endif()
 41: 
 42: set(OPENPSF_VERSION "@OPENPSF_VERSION@")
 43: 
 44: function(append_dependencies out)
 45:     cmake_parse_arguments(PARSE_ARGV 1 "arg" "DEBUG" "NAMES" "")
 46:     if(${arg_DEBUG})
 47:         set(config DEBUG)
 48:         set(path "${CURRENT_INSTALLED_DIR}/debug/lib/")
 49:     else()
 50:         set(config RELEASE)
 51:         set(path "${CURRENT_INSTALLED_DIR}/lib/")
 52:     endif()
 53:     foreach(lib_name ${arg_NAMES})
 54:         if("${lib_name}" STREQUAL "-pthread")
 55:             list(APPEND ${out} "-pthread")
 56:         elseif("${lib_name}" STREQUAL "-pthreads")
 57:             list(APPEND ${out} "-pthreads")
 58:         elseif("${lib_name}" STREQUAL "gcc")
 59:             list(APPEND ${out} "-lgcc")
 60:         elseif("${lib_name}" STREQUAL "gcc_s")
 61:             list(APPEND ${out} "-lgcc_s")
 62:         elseif("${lib_name}" STREQUAL "stdc++")
 63:             list(APPEND ${out} "-lstdc++")
 64:         else()
 65:             # first look in ${path} specifically to ensure we find the right release/debug variant
 66:             find_library(OPENPSF_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" PATHS "${path}" NO_DEFAULT_PATH)
 67:             # if not found there, must be a system dependency, so look elsewhere
 68:             find_library(OPENPSF_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" REQUIRED)
 69:             list(APPEND ${out} "${OPENPSF_DEPENDENCY_${lib_name}_${config}}")
 70:         endif()
 71:     endforeach()
 72:     set("${out}" "${${out}}" PARENT_SCOPE)
 73: endfunction()
 74: 
 75: macro(OPENPSF_FIND libname shortname headername)
 76:   if(NOT OPENPSF_${libname}_INCLUDE_DIRS)
 77:     find_path(OPENPSF_${libname}_INCLUDE_DIRS NAMES ${headername} PATHS ${SEARCH_PATH}/include NO_DEFAULT_PATH)
 78:   endif()
 79:   if(NOT OPENPSF_${libname}_LIBRARY)
 80:     find_library(OPENPSF_${libname}_LIBRARY_RELEASE NAMES ${shortname} PATHS ${SEARCH_PATH}/lib/ NO_DEFAULT_PATH)
 81:     find_library(OPENPSF_${libname}_LIBRARY_DEBUG NAMES ${shortname} PATHS ${SEARCH_PATH}/debug/lib/ NO_DEFAULT_PATH)
 82:     get_filename_component(OPENPSF_${libname}_LIBRARY_RELEASE_DIR ${OPENPSF_${libname}_LIBRARY_RELEASE} DIRECTORY)
 83:     get_filename_component(OPENPSF_${libname}_LIBRARY_DEBUG_DIR ${OPENPSF_${libname}_LIBRARY_DEBUG} DIRECTORY)
 84:     select_library_configurations(OPENPSF_${libname})
 85:     set(OPENPSF_${libname}_LIBRARY ${OPENPSF_${libname}_LIBRARY} CACHE STRING "")
 86:   endif()
 87:   if (OPENPSF_${libname}_LIBRARY AND OPENPSF_${libname}_INCLUDE_DIRS)
 88:     set(OPENPSF_${libname}_FOUND TRUE BOOL)
 89:     list(APPEND OPENPSF_INCLUDE_DIRS ${OPENPSF_${libname}_INCLUDE_DIRS})
 90:     list(APPEND OPENPSF_LIBRARIES ${OPENPSF_${libname}_LIBRARY})
 91:     list(APPEND OPENPSF_LIBRARY_DIRS ${OPENPSF_${libname}_LIBRARY_RELEASE_DIR} ${OPENPSF_${libname}_LIBRARY_DEBUG_DIR})
 92:   endif()
 93: endmacro(OPENPSF_FIND)
 94: 
 95: OPENPSF_FIND(PSXCore PSXCore highly_experimental/bios.h)
 96: OPENPSF_FIND(psflib psflib psflib/psflib.h)
 97: OPENPSF_FIND(openpsf openpsf openpsf/openpsf.h)
 98: 
 99: if (OPENPSF_openpsf_FOUND)
100:   list(REMOVE_DUPLICATES OPENPSF_INCLUDE_DIRS)
101:   list(REMOVE_DUPLICATES OPENPSF_LIBRARY_DIRS)
102:   set(OPENPSF_openpsf_VERSION "@OPENPSF_VERSION@" CACHE STRING "")
103: 
104:   append_dependencies(OPENPSF_DEPS_LIBRARY_RELEASE NAMES "@OPENPSF_DEPENDENCIES_RELEASE@")
105:   append_dependencies(OPENPSF_DEPS_LIBRARY_DEBUG   NAMES "@OPENPSF_DEPENDENCIES_DEBUG@" DEBUG)
106:   if(OPENPSF_DEPS_LIBRARY_RELEASE OR OPENPSF_DEPS_LIBRARY_DEBUG)
107:     select_library_configurations(OPENPSF_DEPS)
108:     list(APPEND OPENPSF_LIBRARIES ${OPENPSF_DEPS_LIBRARY})
109:   endif()
110: 
111:   set(OPENPSF_LIBRARY ${OPENPSF_LIBRARIES})
112: 
113:   set(OPENPSF_FOUND TRUE CACHE BOOL "")
114:   set(OPENPSF_LIBRARIES ${OPENPSF_LIBRARIES} CACHE STRING "")
115:   set(OPENPSF_INCLUDE_DIRS ${OPENPSF_INCLUDE_DIRS} CACHE STRING "")
116:   set(OPENPSF_LIBRARY_DIRS ${OPENPSF_LIBRARY_DIRS} CACHE STRING "")
117: endif()
118: 
119: find_package_handle_standard_args(OPENPSF REQUIRED_VARS OPENPSF_LIBRARIES OPENPSF_LIBRARY_DIRS OPENPSF_INCLUDE_DIRS)
120: 
121: endif()
</file>

<file path=".vcpkg/ports/openpsf/portfile.cmake">
 1: # For a list of common variables see https://github.com/microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md
 2: 
 3: # Checkout dependencies
 4: 
 5: vcpkg_from_github(
 6:     OUT_SOURCE_PATH HE_SOURCE_DIR
 7:     REPO "julianxhokaxhiu/highly_experimental"
 8:     HEAD_REF master
 9:     REF 3600726c94b685a007ef9b6be2b31c29fbad08e9
10:     SHA512 c2a2504379b8e407d005dae8c28616f694892228ff25f0e39262bb4a0fe3f689552b6b93788f7d175338b2034b45b3059cd6050b7335d3c5ef83d6cf861dc2ba
11: )
12: 
13: vcpkg_from_github(
14:     OUT_SOURCE_PATH PSFLIB_SOURCE_DIR
15:     REPO "julianxhokaxhiu/psflib"
16:     HEAD_REF master
17:     REF 93d14f05f5943ca5437378a731be60f8525366be
18:     SHA512 a63ae8bfa3ea0b45fe957eebb5a0d0c4cb829e05c6255525a88a019c13f4bf1900234d0894be2bf75f5ecfd8f1783b188576a534f1e192e4cfc01aed9e041b86
19: )
20: 
21: # Checkout this project
22: 
23: vcpkg_from_github(
24:     OUT_SOURCE_PATH SOURCE_DIR
25:     REPO "julianxhokaxhiu/openpsf"
26:     HEAD_REF master
27:     REF 9b832c44ab57084f5e96aa6b78eb3a68e77e0cd9
28:     SHA512 77fe1bd888cd434f2fe61af972b6d406341b30571e4d6db5b3ad413de156c4e8b29068a9826c093b707bbd0e7cf12e658d515ee4cb02c98fb2e2a7e905ae8bc8
29: )
30: 
31: # Move dependencies inside the project directory
32: file(RENAME ${HE_SOURCE_DIR} "${SOURCE_DIR}/highly_experimental")
33: file(RENAME ${PSFLIB_SOURCE_DIR} "${SOURCE_DIR}/psflib")
34: 
35: # Run MSBuild
36: 
37: vcpkg_install_msbuild(
38:     SOURCE_PATH "${SOURCE_DIR}"
39:     PROJECT_SUBPATH "openpsf.sln"
40:     LICENSE_SUBPATH "LICENSE"
41:     INCLUDES_SUBPATH "include"
42:     USE_VCPKG_INTEGRATION
43: )
44: 
45: # Copy dependencies headers
46: file(INSTALL "${SOURCE_DIR}/highly_experimental/include/highly_experimental" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
47: file(INSTALL "${SOURCE_DIR}/psflib/include/psflib" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
48: 
49: # Copy cmake configuration files
50: configure_file(${CMAKE_CURRENT_LIST_DIR}/FindOPENPSF.cmake.in ${CURRENT_PACKAGES_DIR}/share/${PORT}/FindOPENPSF.cmake @ONLY)
51: file(COPY ${CMAKE_CURRENT_LIST_DIR}/vcpkg-cmake-wrapper.cmake DESTINATION ${CURRENT_PACKAGES_DIR}/share/${PORT})
</file>

<file path=".vcpkg/ports/openpsf/usage">
1: To use openpsf add the following to your CMake project:
2: 
3:     find_package(OPENPSF REQUIRED)
4:     target_include_directories(main PRIVATE ${OPENPSF_INCLUDE_DIRS})
5:     target_link_directories(main PRIVATE ${OPENPSF_LIBRARY_DIRS})
6:     target_link_libraries(main PRIVATE ${OPENPSF_LIBRARIES})
</file>

<file path=".vcpkg/ports/openpsf/vcpkg-cmake-wrapper.cmake">
1: set(OPENPSF_PREV_MODULE_PATH ${CMAKE_MODULE_PATH})
2: list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
3: 
4: cmake_policy(SET CMP0012 NEW)
5: 
6: _find_package(${ARGS})
7: 
8: set(CMAKE_MODULE_PATH ${OPENPSF_PREV_MODULE_PATH})
</file>

<file path=".vcpkg/ports/openpsf/vcpkg.json">
1: {
2:   "name": "openpsf",
3:   "version": "1.3.0",
4:   "description": "Tiny lib to stream PSF files (PlayStation Midi)",
5:   "homepage": "https://github.com/myst6re/openpsf",
6:   "dependencies": [
7:     "zlib"
8:   ]
9: }
</file>

<file path=".vcpkg/ports/soloud/FindSOLOUD.cmake.in">
  1: # Distributed under the OSI-approved BSD 3-Clause License.
  2: #
  3: #.rst:
  4: # FindSOLOUD
  5: # --------
  6: #
  7: # Find the SOLOUD libraries
  8: #
  9: # Result Variables
 10: # ^^^^^^^^^^^^^^^^
 11: #
 12: # The following variables will be defined:
 13: #
 14: #  ``SOLOUD_FOUND``
 15: #    True if SOLOUD found on the local system
 16: #
 17: #  ``SOLOUD_INCLUDE_DIRS``
 18: #    Location of SOLOUD header files
 19: #
 20: #  ``SOLOUD_LIBRARY_DIRS``
 21: #    Location of SOLOUD libraries
 22: #
 23: #  ``SOLOUD_LIBRARIES``
 24: #    List of the SOLOUD libraries found
 25: #
 26: #
 27: 
 28: include(FindPackageHandleStandardArgs)
 29: include(SelectLibraryConfigurations)
 30: include(CMakeFindDependencyMacro)
 31: 
 32: if(NOT SOLOUD_FOUND)
 33: 
 34: # Compute the installation path relative to this file.
 35: get_filename_component(SEARCH_PATH "${CMAKE_CURRENT_LIST_FILE}" PATH)
 36: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 37: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 38: if(SEARCH_PATH STREQUAL "/")
 39:   set(SEARCH_PATH "")
 40: endif()
 41: 
 42: # Compute target architecture
 43: set(architecture x86)
 44: if (CMAKE_GENERATOR_PLATFORM MATCHES Win64)
 45:   set(architecture x64)
 46: endif()
 47: 
 48: set(SOLOUD_VERSION "@SOLOUD_VERSION@")
 49: 
 50: function(append_dependencies out)
 51:     cmake_parse_arguments(PARSE_ARGV 1 "arg" "DEBUG" "NAMES" "")
 52:     if(${arg_DEBUG})
 53:         set(config DEBUG)
 54:         set(path "${CURRENT_INSTALLED_DIR}/debug/lib/")
 55:     else()
 56:         set(config RELEASE)
 57:         set(path "${CURRENT_INSTALLED_DIR}/lib/")
 58:     endif()
 59:     foreach(lib_name ${arg_NAMES})
 60:         if("${lib_name}" STREQUAL "-pthread")
 61:             list(APPEND ${out} "-pthread")
 62:         elseif("${lib_name}" STREQUAL "-pthreads")
 63:             list(APPEND ${out} "-pthreads")
 64:         elseif("${lib_name}" STREQUAL "gcc")
 65:             list(APPEND ${out} "-lgcc")
 66:         elseif("${lib_name}" STREQUAL "gcc_s")
 67:             list(APPEND ${out} "-lgcc_s")
 68:         elseif("${lib_name}" STREQUAL "stdc++")
 69:             list(APPEND ${out} "-lstdc++")
 70:         else()
 71:             # first look in ${path} specifically to ensure we find the right release/debug variant
 72:             find_library(SOLOUD_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" PATHS "${path}" NO_DEFAULT_PATH)
 73:             # if not found there, must be a system dependency, so look elsewhere
 74:             find_library(SOLOUD_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" REQUIRED)
 75:             list(APPEND ${out} "${SOLOUD_DEPENDENCY_${lib_name}_${config}}")
 76:         endif()
 77:     endforeach()
 78:     set("${out}" "${${out}}" PARENT_SCOPE)
 79: endfunction()
 80: 
 81: macro(SOLOUD_FIND libname shortname headername)
 82:   if(NOT SOLOUD_${libname}_INCLUDE_DIRS)
 83:     find_path(SOLOUD_${libname}_INCLUDE_DIRS NAMES ${headername} PATHS ${SEARCH_PATH}/include NO_DEFAULT_PATH)
 84:   endif()
 85:   if(NOT SOLOUD_${libname}_LIBRARY)
 86:     find_library(SOLOUD_${libname}_LIBRARY_RELEASE NAMES ${shortname}_${architecture} PATHS ${SEARCH_PATH}/lib/ NO_DEFAULT_PATH)
 87:     find_library(SOLOUD_${libname}_LIBRARY_DEBUG NAMES ${shortname}_${architecture}_d PATHS ${SEARCH_PATH}/debug/lib/ NO_DEFAULT_PATH)
 88:     get_filename_component(SOLOUD_${libname}_LIBRARY_RELEASE_DIR ${SOLOUD_${libname}_LIBRARY_RELEASE} DIRECTORY)
 89:     get_filename_component(SOLOUD_${libname}_LIBRARY_DEBUG_DIR ${SOLOUD_${libname}_LIBRARY_DEBUG} DIRECTORY)
 90:     select_library_configurations(SOLOUD_${libname})
 91:     set(SOLOUD_${libname}_LIBRARY ${SOLOUD_${libname}_LIBRARY} CACHE STRING "")
 92:   endif()
 93:   if (SOLOUD_${libname}_LIBRARY AND SOLOUD_${libname}_INCLUDE_DIRS)
 94:     set(SOLOUD_${libname}_FOUND TRUE BOOL)
 95:     list(APPEND SOLOUD_INCLUDE_DIRS ${SOLOUD_${libname}_INCLUDE_DIRS})
 96:     list(APPEND SOLOUD_LIBRARIES ${SOLOUD_${libname}_LIBRARY})
 97:     list(APPEND SOLOUD_LIBRARY_DIRS ${SOLOUD_${libname}_LIBRARY_RELEASE_DIR} ${SOLOUD_${libname}_LIBRARY_DEBUG_DIR})
 98:   endif()
 99: endmacro(SOLOUD_FIND)
100: 
101: SOLOUD_FIND(soloud soloud_static soloud.h)
102: 
103: if (SOLOUD_soloud_FOUND)
104:   list(REMOVE_DUPLICATES SOLOUD_INCLUDE_DIRS)
105:   list(REMOVE_DUPLICATES SOLOUD_LIBRARY_DIRS)
106:   set(SOLOUD_soloud_VERSION "@SOLOUD_VERSION@" CACHE STRING "")
107: 
108:   append_dependencies(SOLOUD_DEPS_LIBRARY_RELEASE NAMES "@SOLOUD_DEPENDENCIES_RELEASE@")
109:   append_dependencies(SOLOUD_DEPS_LIBRARY_DEBUG   NAMES "@SOLOUD_DEPENDENCIES_DEBUG@" DEBUG)
110:   if(SOLOUD_DEPS_LIBRARY_RELEASE OR SOLOUD_DEPS_LIBRARY_DEBUG)
111:     select_library_configurations(SOLOUD_DEPS)
112:     list(APPEND SOLOUD_LIBRARIES ${SOLOUD_DEPS_LIBRARY})
113:   endif()
114: 
115:   set(SOLOUD_LIBRARY ${SOLOUD_LIBRARIES})
116: 
117:   set(SOLOUD_FOUND TRUE CACHE BOOL "")
118:   set(SOLOUD_LIBRARIES ${SOLOUD_LIBRARIES} CACHE STRING "")
119:   set(SOLOUD_INCLUDE_DIRS ${SOLOUD_INCLUDE_DIRS} CACHE STRING "")
120:   set(SOLOUD_LIBRARY_DIRS ${SOLOUD_LIBRARY_DIRS} CACHE STRING "")
121: endif()
122: 
123: find_package_handle_standard_args(SOLOUD REQUIRED_VARS SOLOUD_LIBRARIES SOLOUD_LIBRARY_DIRS SOLOUD_INCLUDE_DIRS)
124: 
125: endif()
</file>

<file path=".vcpkg/ports/soloud/portfile.cmake">
 1: # For a list of common variables see https://github.com/microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md
 2: 
 3: # Download source packages
 4: 
 5: vcpkg_from_github(OUT_SOURCE_PATH SOURCE_DIR
 6:     REPO "julianxhokaxhiu/soloud"
 7:     HEAD_REF master
 8:     REF bbb2e0b24dc61a1983f32d962bcf7b25be8deeed
 9:     SHA512 c17bfe29334e4c2b0e7e5c0fc41eac5146fa29a15d024a6e74e178c6e4a0c75b9aef566a485a32397f43699f6ec7fb7d75f7e63d79bee34360dd0c460d128abc
10: )
11: 
12: # Set up GENie (custom project generator)
13: 
14: set(SOLOUD_PROJNAME Static)
15: set(GENIE_OPTIONS --with-miniaudio-only)
16: 
17: if(VCPKG_CRT_LINKAGE STREQUAL dynamic)
18:     set(SOLOUD_PROJNAME Dynamic)
19:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --with-dynamic-runtime)
20: endif()
21: if(VCPKG_LIBRARY_LINKAGE STREQUAL dynamic)
22:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --with-shared-lib)
23: endif()
24: 
25: if(VCPKG_TARGET_ARCHITECTURE STREQUAL x86)
26:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x32)
27: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL x64)
28:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=x64)
29: elseif(VCPKG_TARGET_ARCHITECTURE STREQUAL arm OR VCPKG_TARGET_ARCHITECTURE STREQUAL arm64)
30:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=ARM)
31: else()
32:     message(WARNING "Architecture may be not supported: ${VCPKG_TARGET_ARCHITECTURE}")
33:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --platform=${VCPKG_TARGET_ARCHITECTURE})
34: endif()
35: 
36: if(TARGET_TRIPLET MATCHES osx)
37:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=macosx)
38: elseif(TARGET_TRIPLET MATCHES linux)
39:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=linux)
40: elseif(TARGET_TRIPLET MATCHES windows)
41:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --os=windows)
42: elseif(TARGET_TRIPLET MATCHES uwp)
43:     set(GENIE_OPTIONS ${GENIE_OPTIONS} --vs=winstore100)
44: endif()
45: 
46: # GENie does not allow cmake+msvc, so we use msbuild in windows
47: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
48:     if(VCPKG_PLATFORM_TOOLSET STREQUAL "v140")
49:         set(GENIE_ACTION vs2015)
50:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v141")
51:         set(GENIE_ACTION vs2017)
52:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v142")
53:         set(GENIE_ACTION vs2019)
54:     elseif(VCPKG_PLATFORM_TOOLSET STREQUAL "v143")
55:         set(GENIE_ACTION vs2022)
56:     else()
57:         message(FATAL_ERROR "Unsupported Visual Studio toolset: ${VCPKG_PLATFORM_TOOLSET}")
58:     endif()
59:     set(PROJ_FOLDER ${GENIE_ACTION})
60:     if(TARGET_TRIPLET MATCHES uwp)
61:         set(PROJ_FOLDER ${PROJ_FOLDER}-winstore100)
62:     endif()
63: else()
64:     set(GENIE_ACTION cmake)
65:     set(PROJ_FOLDER ${GENIE_ACTION})
66: endif()
67: 
68: if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
69:     set(GENIE "${CURRENT_INSTALLED_DIR}/tools/bx/genie.exe")
70: else()
71:     message(FATAL_ERROR "Unsupported host platform: ${CMAKE_HOST_SYSTEM_NAME}")
72: endif()
73: 
74: # Run GENie
75: 
76: vcpkg_execute_required_process(
77:     COMMAND ${GENIE} ${GENIE_OPTIONS} ${GENIE_ACTION}
78:     WORKING_DIRECTORY "${SOURCE_DIR}/build"
79:     LOGNAME "genie-${TARGET_TRIPLET}"
80: )
81: 
82: # Run MSBuild
83: 
84: vcpkg_msbuild_install(
85:     SOURCE_PATH "${SOURCE_DIR}"
86:     PROJECT_SUBPATH "build/${GENIE_ACTION}/SoLoud${SOLOUD_PROJNAME}.vcxproj"
87: )
88: file(INSTALL "${SOURCE_DIR}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME "copyright")
89: file(INSTALL "${SOURCE_DIR}/include/" DESTINATION "${CURRENT_PACKAGES_DIR}/include")
90: 
91: # Copy cmake configuration files
92: configure_file(${CMAKE_CURRENT_LIST_DIR}/FindSOLOUD.cmake.in ${CURRENT_PACKAGES_DIR}/share/${PORT}/FindSOLOUD.cmake @ONLY)
93: file(COPY ${CMAKE_CURRENT_LIST_DIR}/vcpkg-cmake-wrapper.cmake DESTINATION ${CURRENT_PACKAGES_DIR}/share/${PORT})
</file>

<file path=".vcpkg/ports/soloud/usage">
1: To use soloud add the following to your CMake project:
2: 
3:     find_package(SOLOUD REQUIRED)
4:     target_include_directories(main PRIVATE ${SOLOUD_INCLUDE_DIRS})
5:     target_link_directories(main PRIVATE ${SOLOUD_LIBRARY_DIRS})
6:     target_link_libraries(main PRIVATE ${SOLOUD_LIBRARIES})
</file>

<file path=".vcpkg/ports/soloud/vcpkg-cmake-wrapper.cmake">
1: set(SOLOUD_PREV_MODULE_PATH ${CMAKE_MODULE_PATH})
2: list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
3: 
4: cmake_policy(SET CMP0012 NEW)
5: 
6: _find_package(${ARGS})
7: 
8: set(CMAKE_MODULE_PATH ${SOLOUD_PREV_MODULE_PATH})
</file>

<file path=".vcpkg/ports/soloud/vcpkg.json">
 1: {
 2:   "name": "soloud",
 3:   "version": "1.0.0",
 4:   "description": "Free, easy, portable audio engine for games",
 5:   "homepage": "https://github.com/julianxhokaxhiu/soloud",
 6:   "dependencies": [
 7:     "bx",
 8:     {
 9:       "name": "vcpkg-msbuild",
10:       "host": true
11:     }
12:   ]
13: }
</file>

<file path=".vcpkg/ports/steamworkssdk/portfile.cmake">
 1: # For a list of common variables see https://github.com/microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md
 2: 
 3: # Download source packages
 4: 
 5: set(VCPKG_POLICY_EMPTY_PACKAGE enabled)
 6: 
 7: vcpkg_from_github(
 8:     OUT_SOURCE_PATH SOURCE_PATH
 9:     REPO "julianxhokaxhiu/SteamworksSDKCI"
10:     HEAD_REF master
11:     REF d320d9566179684d4fc597e151f50ad0beaaa4d0
12:     SHA512 dc7d4ee95353737fa38b68204755ec3b0a7a2216cc60af6da20b491ba729b2a8003a6511b34690cb254a0db91c79b8df588a40e7e75aed9d00d10c35eb221583
13: )
14: 
15: file(TO_NATIVE_PATH "${CURRENT_PACKAGES_DIR}/include/steamworkssdk" INCLUDE_PATH)
16: file(TO_NATIVE_PATH "${CURRENT_PACKAGES_DIR}/tools/steamworkssdk" TOOLS_PATH)
17: 
18: file(MAKE_DIRECTORY
19:     "${INCLUDE_PATH}"
20: )
21: 
22: file(GLOB 
23:     HEADER_FILES
24:     "${SOURCE_PATH}/steamworks_sdk/public/steam/*.h"
25: )
26: 
27: file(COPY ${SOURCE_PATH}/steamworks_sdk/redistributable_bin/steam_api.lib DESTINATION ${CURRENT_PACKAGES_DIR}/lib)
28: file(COPY ${SOURCE_PATH}/steamworks_sdk/redistributable_bin/steam_api.lib DESTINATION ${CURRENT_PACKAGES_DIR}/debug/lib)
29: file(COPY ${SOURCE_PATH}/steamworks_sdk/redistributable_bin/steam_api.dll DESTINATION ${TOOLS_PATH})
30: file(COPY ${HEADER_FILES} DESTINATION ${INCLUDE_PATH})
31: 
32: # Copy cmake configuration files
33: configure_file(${CMAKE_CURRENT_LIST_DIR}/STEAMWORKSSDKConfig.cmake.in ${CURRENT_PACKAGES_DIR}/share/${PORT}/STEAMWORKSSDKConfig.cmake @ONLY)
</file>

<file path=".vcpkg/ports/steamworkssdk/STEAMWORKSSDKConfig.cmake.in">
 1: include(FindPackageHandleStandardArgs)
 2: 
 3: if (NOT STEAMWORKSSDK_FOUND)
 4: 	find_library(
 5: 		STEAMWORKSSDK_LIBRARY
 6: 		steam_api
 7: 		PATH_SUFFIXES
 8: 		lib
 9: 		vendor/lib
10: 	)
11: 
12: 	find_path(
13: 		STEAMWORKSSDK_INCLUDE_DIR
14: 		steamworkssdk
15: 		PATH_SUFFIXES
16: 		include
17: 		vendor/include
18: 	)
19: 
20: 	add_library(STEAMWORKSSDK::STEAMWORKSSDK STATIC IMPORTED)
21: 
22: 	set_target_properties(
23: 		STEAMWORKSSDK::STEAMWORKSSDK
24: 		PROPERTIES
25: 		IMPORTED_LOCATION
26: 		"${STEAMWORKSSDK_LIBRARY}"
27: 		INTERFACE_INCLUDE_DIRECTORIES
28: 		"${STEAMWORKSSDK_INCLUDE_DIR}"
29: 	)
30: 
31: 	find_package_handle_standard_args(STEAMWORKSSDK DEFAULT_MSG STEAMWORKSSDK_LIBRARY STEAMWORKSSDK_INCLUDE_DIR)
32: endif()
</file>

<file path=".vcpkg/ports/steamworkssdk/usage">
1: To use STEAMWORKSSDK add the following to your CMake project:
2: 
3:     find_package(STEAMWORKSSDK REQUIRED)
4:     target_link_libraries(main PRIVATE STEAMWORKSSDK::STEAMWORKSSDK)
</file>

<file path=".vcpkg/ports/steamworkssdk/vcpkg.json">
1: {
2:   "name": "steamworkssdk",
3:   "version": "1.23.0",
4:   "description": "CI builds of Steamworks SDK for CMake build systems",
5:   "homepage": "https://github.com/julianxhokaxhiu/SteamworksSDKCI"
6: }
</file>

<file path=".vcpkg/ports/vgmstream/cmake.patch">
 1: diff --git a/CMakeLists.txt b/CMakeLists.txt
 2: index d623860b..8b657d5e 100644
 3: --- a/CMakeLists.txt
 4: +++ b/CMakeLists.txt
 5: @@ -1,4 +1,5 @@
 6:  cmake_minimum_required(VERSION 3.6)
 7: +cmake_policy(SET CMP0091 NEW)
 8:  project(vgmstream NONE)
 9:  
10:  if(CMAKE_SYSTEM_NAME MATCHES Darwin)
11: diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
12: index 65768024..31d0b762 100644
13: --- a/src/CMakeLists.txt
14: +++ b/src/CMakeLists.txt
15: @@ -105,3 +105,30 @@ if(BUILD_SHARED_LIBS)
16:  		DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/vgmstream
17:  	)
18:  endif()
19: +
20: +if(MSVC)
21: +	target_compile_definitions(libvgmstream PRIVATE "USE_ALLOCA")
22: +	target_compile_options(libvgmstream PRIVATE /DVGM_DEBUG_OUTPUT)
23: +endif()
24: +
25: +# Install library
26: +install(TARGETS libvgmstream
27: +  RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
28: +  ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}"
29: +  LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}"
30: +)
31: +
32: +if(NOT SKIP_INSTALL_HEADERS)
33: +	# Install headers
34: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/vgmstream.h DESTINATION include/libvgmstream )
35: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/vgmstream_types.h DESTINATION include/libvgmstream )
36: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/base/plugins.h DESTINATION include/libvgmstream )
37: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/util.h DESTINATION include/libvgmstream )
38: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/util/log.h DESTINATION include/libvgmstream/util )
39: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/util/reader_get.h DESTINATION include/libvgmstream/util )
40: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/util/reader_put.h DESTINATION include/libvgmstream/util )
41: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/util/vgmstream_limits.h DESTINATION include/libvgmstream/util )
42: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/streamtypes.h DESTINATION include/libvgmstream )
43: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/streamfile.h DESTINATION include/libvgmstream )
44: +	install( FILES ${CMAKE_CURRENT_SOURCE_DIR}/coding/g72x_state.h DESTINATION include/libvgmstream/coding )
45: +endif()
46: diff --git a/src/base/streamfile_stdio.c b/src/base/streamfile_stdio.c
47: index 5e43ef8f..33886cb2 100644
48: --- a/src/base/streamfile_stdio.c
49: +++ b/src/base/streamfile_stdio.c
50: @@ -277,7 +277,10 @@ static STREAMFILE* open_stdio_streamfile_buffer_by_file(FILE* infile, const char
51:  
52:      this_sf->name_len = strlen(filename);
53:      if (this_sf->name_len >= sizeof(this_sf->name))
54: +    {
55: +        vgm_logi("STREAMFILE: filename length is longer than sizeof(this_sf->name).\n");
56:          goto fail;
57: +    }
58:      memcpy(this_sf->name, filename, this_sf->name_len);
59:      this_sf->name[this_sf->name_len] = '\0';
60:  
61: @@ -317,6 +320,7 @@ static STREAMFILE* open_stdio_streamfile_buffer_by_file(FILE* infile, const char
62:      return &this_sf->vt;
63:  
64:  fail:
65: +    vgm_logi("STREAMFILE: could not allocate stream because of memory exhaustion.\n");
66:      free(buf);
67:      free(this_sf);
68:      return NULL;
</file>

<file path=".vcpkg/ports/vgmstream/FindVGMSTREAM.cmake.in">
  1: # Distributed under the OSI-approved BSD 3-Clause License.
  2: #
  3: #.rst:
  4: # FindVGMSTREAM
  5: # --------
  6: #
  7: # Find the VGMSTREAM libraries
  8: #
  9: # Result Variables
 10: # ^^^^^^^^^^^^^^^^
 11: #
 12: # The following variables will be defined:
 13: #
 14: #  ``VGMSTREAM_FOUND``
 15: #    True if VGMSTREAM found on the local system
 16: #
 17: #  ``VGMSTREAM_INCLUDE_DIRS``
 18: #    Location of VGMSTREAM header files
 19: #
 20: #  ``VGMSTREAM_LIBRARY_DIRS``
 21: #    Location of VGMSTREAM libraries
 22: #
 23: #  ``VGMSTREAM_LIBRARIES``
 24: #    List of the VGMSTREAM libraries found
 25: #
 26: #
 27: 
 28: include(FindPackageHandleStandardArgs)
 29: include(SelectLibraryConfigurations)
 30: include(CMakeFindDependencyMacro)
 31: 
 32: if(NOT VGMSTREAM_FOUND)
 33: 
 34: # Compute the installation path relative to this file.
 35: get_filename_component(SEARCH_PATH "${CMAKE_CURRENT_LIST_FILE}" PATH)
 36: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 37: get_filename_component(SEARCH_PATH "${SEARCH_PATH}" PATH)
 38: if(SEARCH_PATH STREQUAL "/")
 39:   set(SEARCH_PATH "")
 40: endif()
 41: 
 42: set(VGMSTREAM_VERSION "@VGMSTREAM_VERSION@")
 43: 
 44: function(append_dependencies out)
 45:     cmake_parse_arguments(PARSE_ARGV 1 "arg" "DEBUG" "NAMES" "")
 46:     if(${arg_DEBUG})
 47:         set(config DEBUG)
 48:         set(path "${CURRENT_INSTALLED_DIR}/debug/lib/")
 49:     else()
 50:         set(config RELEASE)
 51:         set(path "${CURRENT_INSTALLED_DIR}/lib/")
 52:     endif()
 53:     foreach(lib_name ${arg_NAMES})
 54:         if("${lib_name}" STREQUAL "-pthread")
 55:             list(APPEND ${out} "-pthread")
 56:         elseif("${lib_name}" STREQUAL "-pthreads")
 57:             list(APPEND ${out} "-pthreads")
 58:         elseif("${lib_name}" STREQUAL "gcc")
 59:             list(APPEND ${out} "-lgcc")
 60:         elseif("${lib_name}" STREQUAL "gcc_s")
 61:             list(APPEND ${out} "-lgcc_s")
 62:         elseif("${lib_name}" STREQUAL "stdc++")
 63:             list(APPEND ${out} "-lstdc++")
 64:         else()
 65:             # first look in ${path} specifically to ensure we find the right release/debug variant
 66:             find_library(VGMSTREAM_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" PATHS "${path}" NO_DEFAULT_PATH)
 67:             # if not found there, must be a system dependency, so look elsewhere
 68:             find_library(VGMSTREAM_DEPENDENCY_${lib_name}_${config} NAMES "${lib_name}" REQUIRED)
 69:             list(APPEND ${out} "${VGMSTREAM_DEPENDENCY_${lib_name}_${config}}")
 70:         endif()
 71:     endforeach()
 72:     set("${out}" "${${out}}" PARENT_SCOPE)
 73: endfunction()
 74: 
 75: macro(VGMSTREAM_FIND libname shortname headername)
 76:   if(NOT VGMSTREAM_${libname}_INCLUDE_DIRS)
 77:     find_path(VGMSTREAM_${libname}_INCLUDE_DIRS NAMES ${headername} PATHS ${SEARCH_PATH}/include NO_DEFAULT_PATH)
 78:   endif()
 79:   if(NOT VGMSTREAM_${libname}_LIBRARY)
 80:     find_library(VGMSTREAM_${libname}_LIBRARY_RELEASE NAMES ${shortname} PATHS ${SEARCH_PATH}/lib/ NO_DEFAULT_PATH)
 81:     find_library(VGMSTREAM_${libname}_LIBRARY_DEBUG NAMES ${shortname} PATHS ${SEARCH_PATH}/debug/lib/ NO_DEFAULT_PATH)
 82:     get_filename_component(VGMSTREAM_${libname}_LIBRARY_RELEASE_DIR ${VGMSTREAM_${libname}_LIBRARY_RELEASE} DIRECTORY)
 83:     get_filename_component(VGMSTREAM_${libname}_LIBRARY_DEBUG_DIR ${VGMSTREAM_${libname}_LIBRARY_DEBUG} DIRECTORY)
 84:     select_library_configurations(VGMSTREAM_${libname})
 85:     set(VGMSTREAM_${libname}_LIBRARY ${VGMSTREAM_${libname}_LIBRARY} CACHE STRING "")
 86:   endif()
 87:   if (VGMSTREAM_${libname}_LIBRARY AND VGMSTREAM_${libname}_INCLUDE_DIRS)
 88:     set(VGMSTREAM_${libname}_FOUND TRUE BOOL)
 89:     list(APPEND VGMSTREAM_INCLUDE_DIRS ${VGMSTREAM_${libname}_INCLUDE_DIRS})
 90:     list(APPEND VGMSTREAM_LIBRARIES ${VGMSTREAM_${libname}_LIBRARY})
 91:     list(APPEND VGMSTREAM_LIBRARY_DIRS ${VGMSTREAM_${libname}_LIBRARY_RELEASE_DIR} ${VGMSTREAM_${libname}_LIBRARY_DEBUG_DIR})
 92:   endif()
 93: endmacro(VGMSTREAM_FIND)
 94: 
 95: VGMSTREAM_FIND(vgmstream libvgmstream libvgmstream/vgmstream.h)
 96: 
 97: if (VGMSTREAM_vgmstream_FOUND)
 98:   list(APPEND VGMSTREAM_INCLUDE_DIRS "${SEARCH_PATH}/include/libvgmstream")
 99:   list(REMOVE_DUPLICATES VGMSTREAM_INCLUDE_DIRS)
100:   list(REMOVE_DUPLICATES VGMSTREAM_LIBRARY_DIRS)
101:   set(VGMSTREAM_vgmstream_VERSION "@VGMSTREAM_VERSION@" CACHE STRING "")
102: 
103:   append_dependencies(VGMSTREAM_DEPS_LIBRARY_RELEASE NAMES "@VGMSTREAM_DEPENDENCIES_RELEASE@")
104:   append_dependencies(VGMSTREAM_DEPS_LIBRARY_DEBUG   NAMES "@VGMSTREAM_DEPENDENCIES_DEBUG@" DEBUG)
105:   if(VGMSTREAM_DEPS_LIBRARY_RELEASE OR VGMSTREAM_DEPS_LIBRARY_DEBUG)
106:     select_library_configurations(VGMSTREAM_DEPS)
107:     list(APPEND VGMSTREAM_LIBRARIES ${VGMSTREAM_DEPS_LIBRARY})
108:   endif()
109: 
110:   set(VGMSTREAM_LIBRARY ${VGMSTREAM_LIBRARIES})
111: 
112:   set(VGMSTREAM_FOUND TRUE CACHE BOOL "")
113:   set(VGMSTREAM_LIBRARIES ${VGMSTREAM_LIBRARIES} CACHE STRING "")
114:   set(VGMSTREAM_INCLUDE_DIRS ${VGMSTREAM_INCLUDE_DIRS} CACHE STRING "")
115:   set(VGMSTREAM_LIBRARY_DIRS ${VGMSTREAM_LIBRARY_DIRS} CACHE STRING "")
116: endif()
117: 
118: find_package_handle_standard_args(VGMSTREAM REQUIRED_VARS VGMSTREAM_LIBRARIES VGMSTREAM_LIBRARY_DIRS VGMSTREAM_INCLUDE_DIRS)
119: 
120: endif()
</file>

<file path=".vcpkg/ports/vgmstream/portfile.cmake">
 1: # For a list of common variables see https://github.com/microsoft/vcpkg/blob/master/docs/maintainers/vcpkg_common_definitions.md
 2: 
 3: # Download source packages
 4: # (bgfx requires bx and bimg source for building)
 5: 
 6: vcpkg_from_github(
 7:     OUT_SOURCE_PATH SOURCE_PATH
 8:     REPO "vgmstream/vgmstream"
 9:     HEAD_REF master
10:     REF 9db666eb0c2275334ac68a2537a6a689aee792f2
11:     SHA512 6af36bd947d6dd56351734587394d30640d3ea3a9e596caf4ec6c8ed0439193e0bc62b4a90cbabbe9ed115eb3d2edfd62d833141febfb84cefa65fbea4bc1edf
12:     PATCHES cmake.patch
13: )
14: 
15: SET(USE_FFMPEG OFF)
16: SET(USE_MPEG OFF)
17: SET(USE_VORBIS OFF)
18: 
19: if("ffmpeg" IN_LIST FEATURES)
20:     SET(USE_FFMPEG ON)
21: endif()
22: 
23: if("mpg123" IN_LIST FEATURES)
24:     SET(USE_MPEG ON)
25: endif()
26: 
27: if("vorbis" IN_LIST FEATURES)
28:     SET(USE_VORBIS ON)
29: endif()
30: 
31: vcpkg_configure_cmake(
32:     SOURCE_PATH ${SOURCE_PATH}
33:     OPTIONS
34:         -DUSE_ATRAC9=OFF
35:         -DUSE_CELT=OFF
36:         -DUSE_FFMPEG=${USE_FFMPEG}
37:         -DAVCODEC_VERSION=61
38:         -DAVUTIL_VERSION=59
39:         -DAVFORMAT_VERSION=61
40:         -DSWRESAMPLE_VERSION=5
41:         -DUSE_G719=OFF
42:         -DUSE_G7221=ON
43:         -DUSE_MPEG=${USE_MPEG}
44:         -DUSE_VORBIS=${USE_VORBIS}
45:         -DBUILD_AUDACIOUS=OFF
46:         -DBUILD_CLI=OFF
47:         -DBUILD_FB2K=OFF
48:         -DBUILD_XMPLAY=OFF
49:         -DBUILD_WINAMP=OFF
50:     OPTIONS_DEBUG
51:         -DSKIP_INSTALL_HEADERS=ON
52: )
53: 
54: vcpkg_install_cmake()
55: 
56: vcpkg_copy_pdbs()
57: 
58: file(INSTALL "${CMAKE_CURRENT_LIST_DIR}/usage" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}")
59: file(INSTALL ${SOURCE_PATH}/COPYING DESTINATION ${CURRENT_PACKAGES_DIR}/share/${PORT} RENAME copyright)
60: 
61: # Copy cmake configuration files
62: configure_file(${CMAKE_CURRENT_LIST_DIR}/FindVGMSTREAM.cmake.in ${CURRENT_PACKAGES_DIR}/share/${PORT}/FindVGMSTREAM.cmake @ONLY)
63: file(COPY ${CMAKE_CURRENT_LIST_DIR}/vcpkg-cmake-wrapper.cmake DESTINATION ${CURRENT_PACKAGES_DIR}/share/${PORT})
</file>

<file path=".vcpkg/ports/vgmstream/usage">
1: To use vgmstream add the following to your CMake project:
2: 
3:     find_package(VGMSTREAM REQUIRED)
4:     target_include_directories(main PRIVATE ${VGMSTREAM_INCLUDE_DIRS})
5:     target_link_directories(main PRIVATE ${VGMSTREAM_LIBRARY_DIRS})
6:     target_link_libraries(main PRIVATE ${VGMSTREAM_LIBRARIES})
</file>

<file path=".vcpkg/ports/vgmstream/vcpkg-cmake-wrapper.cmake">
1: set(VGMSTREAM_PREV_MODULE_PATH ${CMAKE_MODULE_PATH})
2: list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
3: 
4: cmake_policy(SET CMP0012 NEW)
5: 
6: _find_package(${ARGS})
7: 
8: set(CMAKE_MODULE_PATH ${VGMSTREAM_PREV_MODULE_PATH})
</file>

<file path=".vcpkg/ports/vgmstream/vcpkg.json">
 1: {
 2:   "name": "vgmstream",
 3:   "version": "1.0.0",
 4:   "description": "A library for playback of various streamed audio formats used in video games.",
 5:   "homepage": "https://github.com/vgmstream/vgmstream",
 6:   "default-features": [
 7:     "ffmpeg",
 8:     "mpg123",
 9:     "vorbis"
10:   ],
11:   "features": {
12:     "ffmpeg": {
13:       "description": "Use ffmpeg to decode audio files",
14:       "dependencies": [
15:         {
16:           "name": "ffmpeg",
17:           "default-features": false,
18:           "features": [
19:             "avresample",
20:             "gpl"
21:           ]
22:         }
23:       ]
24:     },
25:     "mpg123": {
26:       "description": "Use mpg123 to decode MPEG audio files",
27:       "dependencies": [
28:         "mpg123"
29:       ]
30:     },
31:     "vorbis": {
32:       "description": "Use libvorbis to decode OGG audio files",
33:       "dependencies": [
34:         "libvorbis"
35:       ]
36:     }
37:   }
38: }
</file>

<file path=".vcpkg/versions/b-/bgfx.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.0.0",
5:       "path": "$/ports/bgfx"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/b-/bimg.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.0.0",
5:       "path": "$/ports/bimg"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/b-/bx.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.0.0",
5:       "path": "$/ports/bx"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/h-/hwinfo.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.0.0",
5:       "path": "$/ports/hwinfo"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/o-/openpsf.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.3.0",
5:       "path": "$/ports/openpsf"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/s-/soloud.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.0.0",
5:       "path": "$/ports/soloud"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/s-/steamworkssdk.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.23.0",
5:       "path": "$/ports/steamworkssdk"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/v-/vgmstream.json">
1: {
2:   "versions": [
3:     {
4:       "version": "1.0.0",
5:       "path": "$/ports/vgmstream"
6:     }
7:   ]
8: }
</file>

<file path=".vcpkg/versions/baseline.json">
 1: {
 2:   "default": {
 3:     "bx": {
 4:       "baseline": "1.0.0",
 5:       "port-version": 0
 6:     },
 7:     "bimg": {
 8:       "baseline": "1.0.0",
 9:       "port-version": 0
10:     },
11:     "bgfx": {
12:       "baseline": "1.0.0",
13:       "port-version": 0
14:     },
15:     "soloud": {
16:       "baseline": "1.0.0",
17:       "port-version": 0
18:     },
19:     "vgmstream": {
20:       "baseline": "1.0.0",
21:       "port-version": 0
22:     },
23:     "openpsf": {
24:       "baseline": "1.3.0",
25:       "port-version": 0
26:     },
27:     "steamworkssdk": {
28:       "baseline": "1.23.0",
29:       "port-version": 0
30:     },
31:     "hwinfo": {
32:       "baseline": "1.0.0",
33:       "port-version": 0
34:     }
35:   }
36: }
</file>

<file path="choco/main.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2020 Marcin Gomulak                                     //
  9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 10: //    Copyright (C) 2023 Cosmos                                             //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include <windows.h>
 25: #include <Shlwapi.h>
 26: #include <ShlObj_core.h>
 27: 
 28: void get_userdata_path(PCHAR buffer, size_t bufSize, bool isSavegameFile)
 29: {
 30: 	PWSTR outPath = NULL;
 31: 
 32: 	HRESULT hr = SHGetKnownFolderPath(FOLDERID_Documents, KF_FLAG_DEFAULT, NULL, &outPath);
 33: 
 34: 	if (SUCCEEDED(hr))
 35: 	{
 36: 		wcstombs(buffer, outPath, bufSize);
 37: 
 38: 		CoTaskMemFree(outPath);
 39: 		PathAppendA(buffer, R"(Square Enix\FINAL FANTASY VIII Steam)");
 40: 
 41: 		if (isSavegameFile)
 42: 		{
 43:       // Search for the first "user_" match in the game path
 44:       CHAR searchPath[MAX_PATH];
 45:       WIN32_FIND_DATA pathFound;
 46:       HANDLE hFind;
 47: 
 48:       strcpy(searchPath, buffer);
 49:       strcat(searchPath, R"(\user_*)");
 50:       if (hFind = FindFirstFileA(searchPath, &pathFound))
 51:       {
 52:         PathAppendA(buffer, pathFound.cFileName);
 53:         FindClose(hFind);
 54:       }
 55: 		}
 56: 	}
 57: }
 58: 
 59: BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 60: {
 61:   return TRUE;
 62: }
 63: 
 64: __declspec(dllexport) HANDLE __stdcall dotemuCreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
 65: {
 66:   HANDLE ret = INVALID_HANDLE_VALUE;
 67: 
 68:   if (StrStrIA(lpFileName, R"(SAVE\)") != NULL) // SAVE\SLOTX\saveN or save\chocorpg
 69: 	{
 70: 		CHAR newPath[MAX_PATH]{ 0 };
 71: 		CHAR saveFileName[50]{ 0 };
 72: 
 73: 		// Search for the next character pointer after "SAVE\"
 74: 		const char* pos = StrStrIA(lpFileName, R"(SAVE\)") + 5;
 75: 		strcpy(saveFileName, pos);
 76: 		_strlwr(saveFileName);
 77: 		char* posSeparator = strstr(saveFileName, R"(\)");
 78: 		if (posSeparator != NULL)
 79: 		{
 80: 			*posSeparator = '_';
 81: 		}
 82: 		strcat(saveFileName, R"(.ff8)");
 83: 
 84: 		get_userdata_path(newPath, sizeof(newPath), true);
 85: 		PathAppendA(newPath, saveFileName);
 86: 
 87: 		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
 88: 	}
 89:   else
 90:   {
 91:     ret = CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
 92:   }
 93: 
 94:   return ret;
 95: }
 96: 
 97: __declspec(dllexport) HANDLE __stdcall dotemuCreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
 98: {
 99:   return CreateMutexA(lpMutexAttributes, bInitialOwner, lpName);
100: }
</file>

<file path="docs/ff8/mods/external_textures.md">
  1: # List of external textures names in FF8
  2: 
  3: Texture names pattern in FF8 mostly follows the paths used in FS/FL/FI archives in the original game.
  4: 
  5: It is recommended to use uncompressed DDS for improved loading times.
  6: 
  7: There are two types of override:
  8: - By texture: the easiest for modders, but with a little loading penalty
  9: - By VRAM page: the fastest, but textures are split into chunks of 256x256, and animation are more difficult to handle
 10: 
 11: The menu module is only available by VRAM page, since source textures are already splitted by VRAM page,
 12: the game pass thoses textures directly to the GPU.
 13: 
 14: If you mod __by texture__, file names look like this:<br>
 15: `{mod_path}\cardgame\cards_{palette index}.dds` (palette index is zero padded)<br>
 16: If not specified, the game will always fallback to the path with palette index equals to 00:<br>
 17: `{mod_path}\cardgame\cards_00.dds`<br>
 18: You can add the language at the beginning of the path for localization:<br>
 19: `{mod_path}\fre\cardgame\cards_00.dds`
 20: 
 21: Available language suffixes: eng (English), fre (French), ger (German), ita (Italian), jp (Japanese), spa (Spanish).
 22: 
 23: If you mod __by VRAM page__, file names look like this:<br>
 24: `{mod_path}\cardgame\cards_{relative vram page}_{palette x}_{palette y}.dds`<br>
 25: If a texture is not found, the game will always fallback to the path with zeroed palette x and palette y:<br>
 26: `{mod_path}\cardgame\cards_{relative vram page}_0_0.dds`
 27: For animations, unlike replacement __by texture__, you must override each frame.
 28: 
 29: When there are both files for the two types of mods, the VRAM page image takes priority over the other one.
 30: 
 31: Again, use [`trace_loaders`](../../mods/external_textures.md) option to see in the logs the paths the game try to lookup.
 32: 
 33: ## Triple Triad
 34: 
 35: Path: `{mod_path}\cardgame`
 36: 
 37: | File name | Description             | Animated | Multi palettes |
 38: | --------- | ----------------------- | -------- | -------------- |
 39: | cards_00  | Cards front and back    | No       | No             |
 40: | game_00   | Game background         | No       | No             |
 41: | icons_00  | Numbers, icons and text | No       | No             |
 42: | intro_00  | Intro/outro background  | No       | No             |
 43: | font_00   | Font (unused)           | No       | Yes (2)        |
 44: 
 45: ## Battle
 46: 
 47: Path: `{mod_path}\battle\{filename with extension in FS archive}-0_00`
 48: 
 49: Example: `.\mods\Textures\battle\A0STG101.X-0_00.dds`
 50: 
 51: ## Worldmap
 52: 
 53: Path: `{mod_path}\world`
 54: 
 55: ### wmsetxx.obj
 56: 
 57: Path: `{mod_path}\world\dat\wmset\section{section number}\texture{texture number}_00`
 58: 
 59: #### Section 17
 60: 
 61: Worldmap texture animations, replace `section38/texture21` and `section38/texture22`.
 62: 
 63: #### Section 38
 64: 
 65: | Section                    | Description                  | Animated       | Multi palettes |
 66: | -------------------------- | ---------------------------- | -------------- | -------------- |
 67: | texture0_00 -> texture7_00 | Main textures                | No             | No             |
 68: | texture7_00                | Water texture (maybe unused) | No             | Not sure       |
 69: | texture9_00                | Moon                         | No             | No             |
 70: | texture10_00               | Sky                          | No             | No             |
 71: | texture11_00               | Map                          | No             | Yes (2)        |
 72: | texture12_00               | Circle Shadow                | No             | No             |
 73: | texture13_00               | Square Shadow                | No             | No             |
 74: | texture14_00               | Effect                       | No             | Not sure       |
 75: | texture15_00               | Forest particles effect      | No             | Yes (6)        |
 76: | texture16_00               | Sea                          | Yes            | Yes (6)        |
 77: | texture17_00               | Shallow water                | Yes            | Yes (6)        |
 78: | texture18_00               | Sea                          | Yes            | Yes (6)        |
 79: | texture19_00               | River                        | Yes            | Yes (6)        |
 80: | texture20_00 texture23_00  | Sea                          | No             | No             |
 81: | texture21_00 texture22_00  | Beaches                      | See section 17 | No             |
 82: | texture24_00               | Map field of view            | No             | No             |
 83: | texture25_00               | Map character orientation    | No             | No             |
 84: | texture26_00               | Effect                       | No             | No             |
 85: | texture27_00               | Effect                       | No             | No             |
 86: | texture28_00               | Effect                       | No             | No             |
 87: | texture29_00               | Effect                       | No             | No             |
 88: | texture30_00               | Effect                       | No             | No             |
 89: | texture31_00               | Effect                       | No             | No             |
 90: | texture32_00               | Effect                       | No             | No             |
 91: | texture33_00               | Effect                       | No             | No             |
 92: | texture34_00               | Effect                       | No             | No             |
 93: | texture35_00               | City barrier disk 4          | No             | No             |
 94: 
 95: #### Section 39
 96: 
 97: Rails and roads.
 98: 
 99: #### Section 40
100: 
101: | File name   | Description           | Animated | Multi palettes |
102: | ----------- | --------------------- | -------- | -------------- |
103: | texture0_00 | Esthar extra texture  | No       | No             |
104: 
105: #### Section 42
106: 
107: Some mobile models.
108: 
109: | File name    | Description             |
110: | ------------ | ----------------------- |
111: | texture0_00  | BGU                     |
112: | texture1_00  | BGU (copy)              |
113: | texture2_00  | Luxury blue locomotive  |
114: | texture3_00  | Luxury blue wagon       |
115: | texture4_00  | Luxury green locomotive |
116: | texture5_00  | Luxury green wagon      |
117: | texture6_00  | Old locomotive          |
118: | texture7_00  | Old wagon               |
119: | texture8_00  | Grey Freight Wagon      |
120: | texture9_00  | Yellow car              |
121: | texture10_00 | Galbadia military car   |
122: | texture11_00 | Galbadia military car   |
123: | texture12_00 | Unknown                 |
124: | texture13_00 | Unknown                 |
125: | texture14_00 | Unknown                 |
126: | texture15_00 | Unknown                 |
127: | texture16_00 | Unknown                 |
128: | texture17_00 | Green car               |
129: | texture18_00 | Brown car               |
130: | texture19_00 | Blue car                |
131: | texture20_00 | Mint car                |
132: | texture21_00 | Pink car                |
133: | texture22_00 | Yellow Esthar car       |
134: | texture23_00 | Blue Esthar car         |
135: | texture24_00 | Unknown                 |
136: | texture25_00 | Lunatic Pandora         |
137: | texture26_00 | Lunatic Pandora         |
138: | texture27_00 | Lunatic Pandora         |
139: | texture28_00 | Disk 4 doors            |
140: | texture29_00 | City barrier disk 4     |
141: | texture30_00 | Jumbo Cactuar           |
142: | texture31_00 | Rocks                   |
143: | texture32_00 | City barrier disk 4     |
144: 
145: ### texl.obj
146: 
147: Path: `{mod_path}\world\dat\texl\texture{texture number}_00`
148: 
149: High res version of `wmset\section38\texture{0,7}_00`. Will be loaded by the game as you travel the worldmap.
150: 
151: **Note:** Ideally, for a smooth experience, do not use texl, instead use `world\dat\wmset\section38\texture0_texture1_16_0_0.dds`
152: which is GPU accelerated.
153: 
154: ### chara.one
155: 
156: Path: `{mod_path}\world\esk\chara_one\model{model number}-{texture number}_00`
157: 
158: | File name                  | Description      |
159: | -------------------------- | ---------------- |
160: | model0-0_00 -> model0-1_00 | Squall           |
161: | model1-0_00 -> model1-3_00 | Ragnarok         |
162: | model2-0_00 -> model3-1_00 | Chocobos         |
163: | model4-0_00 -> model4-1_00 | Squall (Student) |
164: | model5-0_00 -> model5-1_00 | Zell             |
165: | model6-0_00 -> model6-1_00 | Selphie          |
166: 
167: ## Menu
168: 
169: Path: `{mod_path}\data\{lang}\menu`
170: 
171: **Note:** this can change in the future for more consistency with other modules.
172: 
173: ## Field
174: 
175: Path: `{mod_path}\field`
176: 
177: ### Maps
178: 
179: One texture per map.
180: 
181: Path: `{mod_path}\field\mapdata\{map name}\{map name}.png`
182: 
183: Example: `mods\Textures\field\mapdata\bccent_1\bccent_1.png`
184: 
185: #### Legacy support for Tonberry's mods
186: 
187: There is an alternative way to override maps, but on some edge cases it can be buggy.
188: This is compatible with mods made for [Tonberry](https://forums.qhimm.com/index.php?topic=15945.0).
189: 
190: Path: `{mod_path}\field\mapdata\{first two letters of map name}\{map name}\{map name}_{number}.png`
191: 
192: Example: `mods\Textures\field\mapdata\bc\bccent_1\bccent_1_0.png`
193: 
194: ### Models
195: 
196: Path: `{mod_path}\field\model`
197: 
198:  - main_chr: textures that come from field/model/main_chr.fs subarchive
199:  - second_chr: textures that come from field/mapdata/.../chara.one files,
200:    merged together in one directory and named with theirs original identifiers (o001 for object, p001 for persona)
</file>

<file path="docs/ff8/readme.md">
1: # FF8
2: 
3:  - [VRAM](vram.md)
4:  - [List of external textures](mods/external_textures.md)
</file>

<file path="docs/ff8/vram.md">
1: # FF8 VRAM
2: 
3: ![VRAM Game Flow](assets/ff8-vram-game-flow.png)
4: ![VRAM to Tex transformation](assets/ff8-vram-to-tex.png)
</file>

<file path="docs/mods/audio_engine.md">
  1: ## Audio Engine
  2: 
  3: The new FFNx Audio Engine is completely configurable by you! Every audio layer can now have its own `config.toml` file, which through it you can customize the Audio Engine behavior when a track is going to be played.
  4: 
  5: The `config.toml` MUST BE within the relative configured `external_*_path` entry in the [FFNx.toml](misc/FFNx.toml) file.
  6: For example, for the SFX layer on default configuration, the file should be placed in `sfx/config.toml`.
  7: 
  8: Feel free to check the example configuration included in each FFNx release.
  9: 
 10: ### Audio Engine Layers
 11: 
 12: The current supported Audio Engine layers are:
 13: 
 14: - [SFX](misc/FFNx.SFX.toml): in-game audio sound effects ( menu cursor sound, battle sword slash sound, etc. )
 15: - [Music](misc/FFNx.music.toml): in-game audio music ( world theme, field theme, etc. )
 16: - Voice: in-game audio voice acting ( dialog voice acting )
 17: - Ambient: in-game audio atmosphere effects
 18: 
 19: ## Music List
 20: 
 21: > Courtesy of [myst6re](https://github.com/myst6re)
 22: 
 23: Following below, you can find a list of file names that you can replace when using the external music layer, depending on the game you target.
 24: 
 25: Those filenames can be used directly within the relative Music folder and also within the Music TOML configuration file.
 26: 
 27: ### FF7
 28: 
 29: | File name | Description                                    |
 30: | --------- | ---------------------------------------------- |
 31: | aseri     | Hurry!                                         |
 32: | aseri2    | Hurry Faster!                                  |
 33: | ayasi     | Lurking in the Darkness                        |
 34: | barret    | Barret's Theme                                 |
 35: | bat       | Fighting                                       |
 36: | bee       | Honeybee Manor                                 |
 37: | bokujo    | Farm Boy                                       |
 38: | boo       | Life Stream                                    |
 39: | cannon    | The Makou Cannon Fires                         |
 40: | canyon    | Cosmo Canyon                                   |
 41: | cephiros  | Those Chosen by the Planet                     |
 42: | chase     | Crazy Motorcycle                               |
 43: | chu       | Still More Fighting                            |
 44: | chu2      | J-E-N-O-V-A                                    |
 45: | cinco     | Cinco de Chocobo                               |
 46: | cintro    | Those chosen by the planet (intro)             |
 47: | comical   | Comical (deleted song)                         |
 48: | condor    | Fortress of the Condor                         |
 49: | corel     | Mining Town                                    |
 50: | corneo    | Don of the Slums                               |
 51: | costa     | Costa del Sol                                  |
 52: | crlost    | Tango of Tears                                 |
 53: | crwin     | A Great Success                                |
 54: | date      | Interrupted by Fireworks                       |
 55: | dokubo    | Underneath the Rotting Pizza                   |
 56: | dun2      | Chasing the Black-Caped Man                    |
 57: | earis     | Aerith's Theme                                 |
 58: | earislo   | Flowers Blooming in the Church                 |
 59: | elec      | Electric de Chocobo                            |
 60: | fan2      | Fanfare                                        |
 61: | fanfare   | Fanfare (alternate)                            |
 62: | fiddle    | Fiddle de Chocobo                              |
 63: | fin       | World Crisis                                   |
 64: | geki      | Debut                                          |
 65: | gold1     | Gold Saucer                                    |
 66: | guitar2   | On the Other Side of the Mountain              |
 67: | gun       | ShinRa Army Wages a Full-Scale Attack          |
 68: | hen       | Who Am I                                       |
 69: | hiku      | Highwind Takes to the Skies                    |
 70: | horror    | Trail of Blood                                 |
 71: | iseki     | You Can Hear the Cry of the Planet             |
 72: | jukai     | Forest Temple                                  |
 73: | junon     | Off the Edge of Despair                        |
 74: | jyro      | Steal the Tiny Bronco!                         |
 75: | ketc      | Cait Sith's Theme                              |
 76: | kita      | The Great Northern Cave                        |
 77: | kurai     | Anxious Heart                                  |
 78: | lb1       | The Birth of God                               |
 79: | lb2       | A One-Winged Angel                             |
 80: | ld        | Judgement Day                                  |
 81: | makoro    | Makou Reactor                                  |
 82: | mati      | Ahead on Our Way                               |
 83: | mekyu     | Reunion                                        |
 84: | mogu      | Highwind Takes to the Skies (Moggle version)   |
 85: | mura1     | Parochial Town                                 |
 86: | nointro   | Sephiroth intro                                |
 87: | oa        | Opening - Bombing Mission                      |
 88: | ob        | Bombing Mission                                |
 89: | odds      | Racing Chocobos                                |
 90: | over2     | Continue                                       |
 91: | parade    | Rufus' Welcoming Ceremony                      |
 92: | pj        | Jenova Absolute                                |
 93: | pre       | Prelude                                        |
 94: | red       | Red XIII's Theme                               |
 95: | rhythm    | Turk's Theme                                   |
 96: | riku      | unknown                                        |
 97: | ro        | The Countdown Begins                           |
 98: | rocket    | Oppressed People                               |
 99: | roll      | Staff Roll                                     |
100: | rukei     | Sandy Badlands                                 |
101: | sadbar    | Mark of the Traitor                            |
102: | sadsid    | Sending a Dream Into the Universe              |
103: | sea       | A Secret, Sleeping in the Deep Sea             |
104: | seto      | Great Warrior                                  |
105: | si        | unknown                                        |
106: | sid2      | Cid's Theme                                    |
107: | sido      | It's Difficult to Stand on Both Feet, Isn't It |
108: | siera     | If You Open Your Heart                         |
109: | sinra     | ShinRa Corporation                             |
110: | sinraslo  | Infiltrating ShinRa Tower                      |
111: | snow      | Buried in the Snow                             |
112: | ta        | FF VII Main Theme                              |
113: | tb        | FF VII Main Theme (alternate)                  |
114: | tender    | Holding My Thoughts In My Heart                |
115: | tifa      | Tifa's Theme                                   |
116: | tm        | On That Day, 5 Years Ago                       |
117: | utai      | Wutai                                          |
118: | vincent   | The Nightmare's Beginning                      |
119: | walz      | Waltz de Chocobo                               |
120: | weapon    | Weapon Raid                                    |
121: | wind      | Wind                                           |
122: | yado      | Good Night, Until Tomorrow                     |
123: | yufi      | Descendant of Shinobi                          |
124: | yufi2     | Stolen Materia                                 |
125: | yume      | Who Are You                                    |
126: | heart     |                                                |
127: | sato      |                                                |
128: | sensui    |                                                |
129: | wind      |                                                |
130: 
131: ### FF8
132: 
133: | File name    | Description                            |
134: | ------------ | -------------------------------------- |
135: | lose         | The Loser                              |
136: | win          | The Winner                             |
137: | run          | Never Look Back                        |
138: | battle       | Don't Be Afraid                        |
139: | end          | Dead End                               |
140: | antena       | Starting Up                            |
141: | waiting      | Intruders                              |
142: | kani         | Don't Be Afraid (Alternate)            |
143: | battle2      | Force Your Way                         |
144: | Parade2      | Fithos Lusec Wecos Vinosec (Variation) |
145: | fuan2        | Unrest                                 |
146: | march2       | The Stage Is Set                       |
147: | joriku       | The Landing                            |
148: | julia        | Love Grows                             |
149: | waltz        | Waltz For the Moon                     |
150: | friend       | Ami                                    |
151: | dangeon      | Find Your Way                          |
152: | pianosol     | Julia                                  |
153: | Parade       | FITHOS LUSEC WECOS VINOSEC             |
154: | march1       | SeeD                                   |
155: | himitsu      | Tell Me                                |
156: | garden       | Balamb Garden                          |
157: | fuan         | Fear                                   |
158: | polka2       | Dance with the Balamb-Fish             |
159: | anthem       | Cactus Jack (Galbadian Anthem)         |
160: | m7f5         | The Mission                            |
161: | majo         | Succession of Witches                  |
162: | field        | Blue Fields                            |
163: | guitar       | Breezy                                 |
164: | resistan     | Timber Owls                            |
165: | kaiso        | Fragments of Memories                  |
166: | horizon      | Fisherman's Horizon                    |
167: | master       | Heresy                                 |
168: | rinoa        | My Mind                                |
169: | travia       | Where I Belong                         |
170: | antena2      | Starting Up (Variation)                |
171: | truth        | Truth                                  |
172: | jail         | Trust Me                               |
173: | gargarde     | Galbadia Garden                        |
174: | timber       | Martial Law                            |
175: | garbadia     | Under Her Control                      |
176: | pinch        | Only a Plank Between One and Perdition |
177: | scene1       | Junction                               |
178: | pub          | Roses And Wine                         |
179: | bat3         | The Man With the Machine Gun           |
180: | stage        | A Sacrifice                            |
181: | choco        | Odeka ke Chocobo                       |
182: | white        | Drifting                               |
183: | majomv       | Wounded                                |
184: | musho        | Jailed                                 |
185: | missile      | Retaliation                            |
186: | enzetu       | The Oath                               |
187: | card         | Shuffle Or Boogie                      |
188: | gomon        | Rivals                                 |
189: | soto         | Blue Sky                               |
190: | majobat      | Premonition                            |
191: | Gar3         | Galbadia Garden (Variation)            |
192: | Bossbat2     | Maybe I'm a Lion                       |
193: | lasdun       | The Castle                             |
194: | gafly        | Movin'                                 |
195: | demo         | Overture                               |
196: | spy          | The Spy                                |
197: | mods         | Mods de Chocobo                        |
198: | salt         | The Salt Flats                         |
199: | alien        | Residents                              |
200: | sekichu      | Lunatic Pandora                        |
201: | esta         | Silence and Motion                     |
202: | moonmv       | Tears of the Moon                      |
203: | hikutei      | Ride On                                |
204: | bossbat1     | The Legendary Beast                    |
205: | rag1         | Slide Show Part 1                      |
206: | rag2         | Slide Show Part 2                      |
207: | lasboss      | The Extreme (no effects)               |
208: | lasbossintro | The Extreme (intro)                    |
209: | keisho       | The Successor                          |
210: | ashuku       | Compression of Time                    |
211: | joriku2      | The Landing                            |
212: | combat       |                                        |
213: | funsui       |                                        |
214: | ante         |                                        |
215: | wind         |                                        |
216: | Flangchorus  |                                        |
217: | dubchorus    |                                        |
218: | Solochorus   |                                        |
219: | Femalechorus |                                        |
220: | chorus       |                                        |
221: | reet         |                                        |
222: | soyo         |                                        |
223: | rouka        |                                        |
224: | night        |                                        |
225: | sea          |                                        |
226: | train        |                                        |
227: | mdmotor      |                                        |
228: | laswhite     |                                        |
229: | lasbl        |                                        |
</file>

<file path="docs/mods/devtools.md">
 1: # DevTools
 2: 
 3: If you're a modder and you want to test some of your changes faster than usually playing the game, this section may be of your interest.
 4: 
 5: FFNx brings a whole new game changer tooling that will allow you to explore more of the game engine, while playing everytime you prefer.
 6: 
 7: In order to use it, you must enable the relative flag on your [`FFNx.toml` config file](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L259).
 8: 
 9: ## Field Debug
10: 
11: This tool will allow you to jump from field to field. It is actually supported on both FF7 and FF8.
12: 
13: ## World Debug
14: 
15: This will will allow you to futher investigate the World geometry and much more. Currently supported on FF8 only.
</file>

<file path="docs/mods/direct_mode.md">
 1: # Direct mode
 2: 
 3: The Direct mode allows modders to bypass game archives
 4: (LGP for FF7 or FS/FI/FL for FF8) and read files directly from the directory
 5: pointed by the `direct_mode_path` configuration entry.
 6: 
 7: For example: if FF7 is looking for aaab.rsd in char.lgp, this mode will make it open direct/char/aaab.rsd first,
 8: If this file doesn't exist it will look for the original in the LGP archive
 9: Another example: if FF8 is looking for c:/data/en/FIELD/mapdata/bc/bccent12/bccent12.msd in field.fs,
10: this mode will make it open direct/FIELD/mapdata/bc/bccent12/bccent12.msd if it exists.
</file>

<file path="docs/mods/exe_data.md">
 1: # EXE data
 2: 
 3: Sometimes texts and textures are stored inside the EXE, instead in the data directory.
 4: In this case it is harder for modders to mod the game.
 5: 
 6: This feature allows modders to override data from the EXE via the
 7: (Direct Mode)[direct_mode.md] feature.
 8: 
 9: Use the `save_exe_data` option to dump files to the direct/exe/ directory.
10: And then FFNx will look for those files directly instead of data from the EXE.
11: 
12: ## Supported data
13: 
14: ### FF8
15: 
16: - `battle_scans.msd`: Texts in battle scans. Note: this is not exactly the same
17:   format in the EXE, the msd format is used because it is a well documented format
18:   of FF8.
19: - `card_names.msd`: Card names. Note: this is not exactly the same
20:   format in the EXE, the msd format is used because it is a well documented format
21:   of FF8.
22: - `card_texts.msd`: Card module texts. Note: this is not exactly the same
23:   format in the EXE, the msd format is used because it is a well documented format
24:   of FF8.
25: - `draw_point.msd`: Draw point and Disc error messages
</file>

<file path="docs/mods/external_textures.md">
 1: # External textures
 2: 
 3: You can override game's textures with images in DDS (recommended) or PNG format.
 4: To know where to put your custom textures, set the option `trace_loaders` to `true` and look at the content of FFNx.log
 5: when the game is running.
 6: 
 7: It is also possible to dump textures on runtime in PNG format by setting the option `save_textures` to true.
 8: 
 9: By default, FFNx looks for textures relatively to the `./mods/Textures` directory, this path can be changed via the option `mod_path`.
10: 
11: ## FF8
12: 
13: [List of external textures](../ff8/mods/external_textures.md)
</file>

<file path="docs/mods/video_encoding_guide.md">
  1: # Video Encoding Guide
  2: 
  3: This guide explains how to edit and encode FMV videos for high quality and proper playback within FFNx. For the most part, FFNx behaves like a generic ffmpeg-based video player. However, some default behavior differs in order to correctly play back Playstation 1 videos, upscales of Playstation 1 videos, FF7 PC release videos, and FF8 Steam release videos. **Therefore, videos of other provenance that are missing colorimetry metadata may play back with incorrect colors.** Additionally, FFNx does not handle the full range of exotic inputs that a media player like VLC might.
  4: 
  5: 1. [Container Format](#container-format)
  6: 2. [Video Codec](#video-codec)
  7: 3. [Audio Codec](#audio-codec)
  8: 4. [Suggested Workflow](#suggested-workflow)
  9: 5. [Pixel Format](#pixel-format)
 10: 6. [Bit Depth](#bit-depth)
 11: 7. [Color Matrix](#color-matrix)
 12: 8. [Color Primaries (Color Gamut)](#color-primaries-color-gamut)
 13: 9. [Color Range](#color-range)
 14: 10. [Transfer Characteristics (Gamma)](#transfer-characteristics-gamma)
 15: 11. [Full Colorimetry Conversion Example](#full-colorimetry-conversion-example)
 16: 11. [Editing Metadata without Re-Encoding](#editing-metadata-without-re-encoding)
 17: 
 18: ### Container Format
 19: **Recommended:** mkv  
 20: **Permitted:** Anything ffmpeg can decode  
 21: **Notes:**
 22: - Simply rename your file to end with .avi, regardless of its actual type.
 23: 
 24: ### Video Codec
 25: **Recommended:** x264  
 26: **Permitted:** Anything ffmpeg can decode  
 27: **Notes:**  
 28: - x264 is recommended because it is widely used and well tested.
 29: - The standalone x264 command-line encoder is recommended over ffmpeg or GUI-based tools.
 30: 
 31: ### Audio Codec
 32: **Recommended:** opus  
 33: **Permitted:** Anything ffmpeg can decode  
 34: **Notes:**  
 35: - The audio for the Playstation 1 videos has an odd sample rate. It is recommended to resample to 48kHz using soxr before encoding. E.g.: `ffmpeg -i input.wav -af aresample=resampler=soxr -ar 48000 output.wav` (It's better to do a high-quality upsample at encode time and potentially downsample at playback time than to upsample at playback time.) 
 36: - Since the additional space required is trivial relative to a typical FF7 + 7th Heaven install, encoding audio at a bitrate comfortably above "transparency" is recommended. (Consider 256 for opus, 320 for aac, `-q 9` for vorbis.) 
 37: - If encoding to opus, the standalone opusenc encoder is recommended.
 38: - If encoding to aac, it is strongly recommended to use Apple's encoder (see [qaac](https://github.com/nu774/qaac/wiki)) because ffmpeg's aac encoders are terrible.
 39: - Be careful with vorbis encoders. Some will downsample to 22050Hz by default. This is undesirable because it distorts frequencies above [11025Hz](https://www.rapidtables.com/tools/tone-generator.html?f=11025), which are not only audible to humans, but also musically relevant. (See [Nyquist-Shannon theorem](https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem).)
 40: 
 41: 
 42: ### Suggested Workflow
 43: - Extract videos from Playstation disks to a series of .png images using [jPSXdec](https://github.com/m35/jpsxdec).
 44:      - Also extract to any avi format to get wav audio. (Must be demuxed later.) 
 45: - Do pre-processing with a frameserver and save output back to a series of .png images.
 46:      - VapourSynth is recommended over AviSynth(+) because it has better performance, better stability, and does not have functions with undesirable "gotcha" default parameters like AviSynth does (e.g., ConvertToYUV() does a PC->TV range conversion by default).
 47:      - [fmtconv](https://github.com/EleonoreMizo/fmtconv) is recommended for all color, bit-depth, and pixel format conversions, for both VapourSynth and AviSynth.
 48: - Batch process your .png images through your AI upscaler program.
 49: - Do post-processing with a frameserver, piping output to your encoder.
 50: - Encode with the standalone x264 command-line encoder.
 51: - Mux audio and video using mkvtoolsnix.
 52: - Rename mkv file to avi.
 53: 
 54: ### Pixel Format
 55: **Recommended:** yuv420 family (yuv420p10le in specific)   
 56: **Permitted:** Anything ffmpeg can decode  
 57: **Notes:**  
 58: - yuv420 is standard for digital video because the human vision has about half the resolving power for chroma as for luma.
 59: - FFNx resamples to yuv444 internally. So, if you use yuv422 or yuv444, the extra chroma data won't be "wasted."
 60:      - (Exception: BGR24 is not converted to yuv444; rather the RGB values are used directly. This pixel format is used by the avi files in the PC release of FF7.) 
 61: 
 62: ### Bit Depth
 63: **Recommended:** 10 bits per color  
 64: **Permitted:** Anything ffmpeg can decode  
 65: **Notes:**  
 66: - FFNx converts to 8 bits per color internally, as it must for display on standard 8-bit monitors.
 67: - Nevertheless, 10-bit encoding is recommended, even for 8-bit source material destined for an 8-bit monitor, because it reduces banding and compression artifacts and yields better quality at the same file size (or smaller file size at the same quality).
 68: - Generally, the first thing your frameserver script should do is increase the bit depth to at least 16, and the last thing it should do is reduce the bit depth to 10. Working in a high bit depth prevents banding and other color errors caused by rounding.
 69: - Depending on your operating system and the age of your x264 encoder, you might have separate binaries for 8-bit and 10-bit encoding, or a single binary that can do both. The relevant parameters for the dual-depth binary are `--input-depth` and `--output-depth` both of which should be 10. 
 70: 
 71: ### Color Matrix
 72: **Background Info:** The color matrix is used to convert between YUV and RGB. The same matrix must be used for playback as was used at encoding time.  
 73: **x264 encoder parameter:** `--colormatrix` Possible values are `undef`, `bt709`, `fcc`, `bt470bg`, `smpte170m`, `smpte240m`, `GBR`, `YCgCo`, `bt2020nc`, `bt2020c`, `smpte2085`, `chroma-derived-nc`,         `chroma-derived-c`, and `ICtCp`. This parameter only sets the metadata used for playback; it does not do a color matrix conversion.  
 74: **Recommended:** `bt709` for new material or if doing a color matrix and gamut conversion in a frameserver. Otherwise retain the source material's matrix.  
 75: **Permitted:** Anything ffmpeg can decode  
 76: **FFNx default behavior:** If the color matrix metadata is absent or `undef`, `smpte170m` (bt601) is assumed. Except `bt709` is assumed for FF8 when the video has HD dimensions and no colorimetry metadata.  
 77: **Notes:**
 78: - The original Playstation 1 videos use the bt601 color matrix. (See [jpsxdec documentation](https://github.com/m35/jpsxdec/blob/readme/jpsxdec/PlayStation1_STR_format.txt)).
 79:      - There are some small errors in the Playstation 1's matrix values (rounding errors? electrical engineering compromises?), but jpsxdec accounts for them, so a standard matrix should be used thereafter.
 80: - The avi video files from the PC edition of FF7 use an RGB pixel format, and thus no YUV->RGB color matrix is needed.
 81: - The avi video files from the Steam edition of FF8 appear to use the bt709 color matrix.
 82: - FFNx handles bt601 and bt709 natively. Anything else will be converted to bt601 using ffmpeg's swscale component. In this case, the metadata for color matrix, color primaries, and transfer properties must be set correctly. Otherwise ffmpeg must guess about these values when converting, and may guess incorrectly.
 83: - The color matrix of an unlabeled video is almost always either bt601 or bt709. Which one can usually be ascertained by "eyeballing" it using a tool that can swap which matrix is used for display (such as [vsedit](https://github.com/YomikoR/VapourSynth-Editor)). [This page](http://avisynth.nl/index.php/Colorimetry) explains how greens and reds will look wrong when the incorrect matrix is used. For live-action content, you can usually tell by looking at a tree or bush. For animated and computer-generated content it can be more difficult to distinguish incorrect color from artistic intent.
 84: 
 85: ### Color Primaries (Color Gamut)
 86: **Background Info:** The color gamut is the range of visible light that a playback device is physically capable of producing. Video is "mastered" with a particular class of playback device in mind (e.g., American CRT television sets with SMPTE-C phospors). To correctly play back video mastered for one gamut on a device with a different gamut, a conversion must be made so that the second device will produce the same visible colors as the first, to the extent it's physically able to.  
 87: **x264 encoder parameter:** `--colorprim` Possible values are `undef`, `bt709`, `bt470m`, `bt470bg`, `smpte170m`, `smpte240m`, `film`, `bt2020`, `smpte428`, `smpte431`, `smpte432`. This parameter only sets the metadata used for playback; it does not do a color gamut conversion.  
 88: **Recommended:** `undef` for NTSC-J material, otherwise the color gamut of the source material (likely `bt709` when color matrix is bt709 and `smpte170m` or `bt470bg` when color matrix is bt601).   
 89: **Permitted:** `undef`, `bt709`, `bt470m`, `smpte170m`, `smpte240m`, `bt470bg` _If video metadata specifies unsupported color primaries, the video will fail to play._  
 90: **FFNx default behavior:** If the color primary metadata is absent or `undef`, the NTSC-J color gamut is generally assumed. Except that `bt709` is assumed when (1) the color matrix is bt709, or (2) for FF8 when the video has HD dimensions and no colorimetry metadata, or (3) if the file name is eidoslogo.avi or sqlogo.avi.  
 91: **Notes:**
 92: - The original Playstation 1 videos were mastered for playback using the "NTSC-J" gamut from the Japanese television standard in force in the 1990s.  
 93:      - Unfortunately, neither the x264 encoder nor ffmpeg have an enum for this color gamut. So FFNx must hijack `undef` to mean "NTSC-J." **Therefore, unless the exceptions noted above apply, a video that is not NTSC-J will play back with (very) incorrect colors in FFNx if the `--colorprim` metadata is absent.**
 94:      - fmtconv is capable of doing conversions to/from the NTSC-J color gamut.
 95: - In the absence of metadata, `bt709` (sRGB) is assumed for eidoslogo.avi and sqlogo.avi because these files don't exist on the Playstation discs, and were presumably created for the PC release, presumably using the sRGB gamut.
 96: - The avi video files from the Steam edition of FF8 appear to use the bt709 color gamut. (Gamut conversion from NTSC-J was already done when these videos were encoded.)
 97: - The `bt709` color gamut is the same as sRGB, used by modern computer monitors. FFNx will ultimately convert everything to this color gamut. (Except if HDR is enabled, everything will instead be converted to the rec2020 color gamut used by HDR monitors.)
 98: - Due to some compromises necessary for rendering gameplay, videos are subject to two sequential color gamut conversions in some circumstances. This is not ideal, but it cannot be avoided. Sequential color gamut conversions happen when:
 99:      - When NTSC-J mode is enabled, and the video's color gamut is not NTSC-J.
100:      - When HDR is enabled, and NTSC-J mode is disabled, and the video's color gamut is not `bt709` (sRGB).
101: - The `bt470m` color gamut was deprecated in television standards in 1979. If `bt470m` metadata is encountered, FFNx will assume it's an error and that `smpte170m` was intended.
102: - `smpte170m` is SMPTE-C, the North American standard for standard definition television. `smpte240m` is identical.
103: - `bt470bg` is EBU (PAL), the European standard for standard definition television.
104: - The color primaries of an unlabeled video likely match its color matrix, as follows: `bt709` for bt709, `smpte170m` for NTSC bt601, `bt470bg` for PAL bt601. NTSC-J is limited to material mastered for playback on Japanese CRT television sets. Videos created from still images created in image editing software like Photoshop and GIMP likely use the sRGB (`bt709`) gamut.
105: 
106: ### Color Range
107: **Background Info:** Whether or not the full bit depth is used. If not, color values must be shifted and scaled for playback. See first note below for details.  
108: **x264 encoder parameters:** `--input-range` and `--range` Possible values are `pc`, `tv`, and `auto`. The latter parameter sets the metadata used for playback. If the former parameter differs, the encoder will perform a conversion. However, converting in the framesever is preferrable.  
109: **Recommended:** `pc` (full range)   
110: **Permitted:** `pc`, `tv`, unspecified  
111: **FFNx default behavior:** If the color range metadata is absent, tv range is assumed. (Except for pixel formats that are inherently full range.)  
112: **Notes:**  
113: - Full range (PC range) uses the entire bit depth available. (0-255 for 8 bits per color.) TV range is compressed and shifted to avoid using the upper and lower ~9% of the bit depth. (16-235 luma and 16-240 chroma for 8 bits per color.) TV range was devised as a workaround for the unavoidable over- and undershoots in analog singal processing. (See [Gibbs phenomenon](https://en.wikipedia.org/wiki/Gibbs_phenomenon).) TV range persisted into the age of digital video for purposes of backwards compatibility with analog television sets. It serves little purpose today, and none whatsoever with respect to content destined for a computer monitor.  
114: - Conversion from full range to tv range should be avoided because color data is irreparably discarded. This tends to cause [color banding](https://en.wikipedia.org/wiki/Colour_banding).
115: - When playing back tv-range videos, FFNx shifts and scales color values up to full range, with dithering.
116:      - (Dithering is not performed on the DirectX 9 experimental backend because a necessary shader function isn't supported.)
117: - For a limited class of high-bit-depth, tv-range videos, it's theoretically possible to recover 8 bits of full-range data. However, FFNx does not attempt this because doing so would mean giving up dithering for _all_ high-bit-depth, tv-range videos. (In particular, the extremely popular SYW upscale videos are high bit depth and tv range, but aren't in this limited class, and therefore benefit only from dithering.)
118: - The original Playstation 1 videos are full range.
119: - The avi video files from the PC edition of FF7 are full range.
120: - The avi video files from the Steam edition of FF8 are tv range. (Surprising and disappointing.)
121: - Several ffmpeg-based video players (notably including VLC) suffer from a bug in which, under certain circumstances, they apply an unnecessary and incorrect tv->pc range conversion to video that is already full range. FFNx does **_NOT_** have this bug.
122: - The color range of an unlabeled video can be ascertained using the [histogram filter for VapourSynth](https://vsdb.top/plugins/hist) or [AviSynth](http://avisynth.nl/index.php/Histogram). (See the AviSynth link for useful documentation.)
123: 
124: ### Transfer Characteristics (Gamma)
125: **Background Info:** The gamma function used to convert between linear RGB and gamma-encoded RGB. (See [gamma correction](https://en.wikipedia.org/wiki/Gamma_correction).) At playback time, the inverse of whatever gamma function was previously used must be used to recover linear RGB, which can then be re-gamma-encoded using the inverse of the playback device's gamma function.  
126: **x264 encoder parameter:** `--transfer` Possible values are `undef`, `bt709`, `bt470m`, `bt470bg`, `smpte170m`, `smpte240m`, `linear`, `log100`, `log316`, `iec61966-2-4`, `bt1361e`, `iec61966-2-1`, `bt2020-10`, `bt2020-12`, `smpte2084`, `smpte428`, and `arib-std-b67`. This parameter only sets the metadata used for playback; it does not do a gamma conversion.  
127: **Recommended:** The inverse of whatever gamma function was previously used to convert from linear RGB to gamma-encoded RGB. If you didn't do such a conversion, then retain the source material's transfer characteristics.  
128: **Permitted:** `undef`, `bt709`, `bt470bg`, `iec61966-2-1`, `smpte170m`, `bt2020-10`, `bt2020-12`, `iec61966-2-4`, `bt1361e` (ffmpeg's AVCOL_TRC_GAMMA22 is also supported, but there's no way to flag that in x264's metadata.)  _If video metadata specifies unsupported transfer characteristics, the video will fail to play._  
129: **FFNx default behavior:** If the transfer characteristics metadata is absent or `undef`, FFNx will generally use custom gamma function that's been tweaked to look good with Playstation movies (orginal and upscaled). Except `bt709` is assumed when the color matrix is bt709 or for FF8 when the video has HD dimensions and no colorimetry metadata, and `bt470bg` is assumed when the color gamut is bt470bg.  
130: **Notes:**
131: - The gamma function used for the original Playstation 1 videos is a bit of a mystery. One would assume compliance with the applicable television standard, and thus `smpte170m`. However, using SMPTE170M, or any other piecewise function, for playback results in noticeable banding near black within the "toe slope." (Also, the SMPTE170M function is deliberately overbright in order to counteract other factors with playback on CRT television sets.) The nominal gamma for NTSC television was 2.2. However, using a pure 2.2 curve causes details in shadowy areas to be lost to darkness. A pure curve around 1.9 or 2.0 better preserves details in shadows, but blows out highlights. In sum, we don't know what gamma function was used originally, and all of the likely candidates have flaws. Given this uncertainty, in the absence of metadata, FFNx defaults to a custom gamma function (which we call "toeless sRGB") that avoids each of these flaws. It's certainly not the real inverse of the original gamma function, but the results look very good.
132: - `iec61966-2-1` is the sRGB gamma function. Computer monitors use this gamma function. FFNx will ultimately convert everything to this. The average of this function is roughly equivalent to a pure 2.2 curve. (Except if HDR is enabled, everything will instead be converted to the rec2084 ("PQ") gamma function used by HDR monitors.)
133: - `smpte170m`, `bt709`, `bt2020-10`, `bt2020-12`, `iec61966-2-4`, and `bt1361e` are all functionally identical. This is the gamma function used in the NTSC and HD television standards. The average of this function is roughly equivalent to a pure 1.9 curve (though 2.0 is often cited). This is deliberately overbright in order to counteract other factors with playback on CRT television sets.
134: - `bt470bg` is the gamma function for PAL standard definition television. It's a pure 2.8 gamma curve. (Though, the actual behavior of PAL CRT television sets was not really as high as 2.8.) 
135: -  Aside from Playstation 1 videos (see above), the transfer characteristics of an unlabeled video are most likely `smpte170m`.
136: 
137: ### Full Colorimetry Conversion Example
138: The correct frameserver procedure for completely converting all colorimetry properties is somewhat complicated. Therefore, an example is provided here. The steps are:
139: 1. Increase working bit depth to (at least) 16 bits per color. If the input is tv range, do a range conversion in the same operation.
140: 2. Convert to (gamma encoded) RGB using the source color matrix.
141: 3. Convert to linear RGB using the source gamma function.
142: 4. Convert from the source color gamut to the destination color gamut.
143: 5. Convert to gamma encoded RGB using the destination gamma function.
144:     - However, if you want to use FFNx's custom gamma function at playback, then instead just use the inverse of step 3 and set the `--transfer` metadata to `undef`.
145: 6. Convert to YUV using the destination color matrix.
146: 7. Downsample to 10 bits per color for output.
147: 8. Set metadata encoder parameters correctly for the destination color properties.
148: 
149: Here is a sample VapourSynth script converting a Playstation video to bt709:
150: ```
151: import vapoursynth as vs
152: core = vs.core
153: video = core.ffms2.Source('path/to/input.avi')
154: video = core.fmtc.bitdepth(video, bits=16, fulls=True, fulld=True) #use fulls=False if the source is tv range
155: video = core.std.SetFrameProp(video, prop='_ColorRange', intval=0) # 0 means full range
156: video = core.fmtc.resample(video,css='444', fulls=True, fulld=True) # YUV->RGB conversion will require 444
157: video = core.fmtc.matrix(video, mats="601", matd="RGB", fulls=True, fulld=True)
158: # assume 2.2 pure gamma curve for playstation videos; would normally use transs/transd instead of gcor, but there's no 2.2 option
159: video = core.fmtc.transfer(video, transs="linear", transd="linear", gcor=2.2, fulls=True, fulld=True) 
160: video = core.fmtc.primaries(video, prims="ntscj", primd="709")
161: # Because we want to use FFNx's custom gamma function, rather than converting to bt709's gamma function, invert the earlier step and set metadata to undef
162: # Again, would normally use transs/transd instead of gcor, but there's no 2.2 option
163: video = core.fmtc.transfer(video, transs="linear", transd="linear", gcor=1.0/2.2, fulls=True, fulld=True)
164: # If we wanted to convert the gamma function to bt709, we'd use this instead
165: # video = core.fmtc.transfer(video, transs="linear", transd="bt709", fulls=True, fulld=True)
166: video = core.fmtc.matrix(video, mats="RGB", matd="709", fulls=True, fulld=True)
167: video = core.fmtc.resample(video,css='420', fulls=True, fulld=True)
168: video = core.fmtc.bitdepth(video, bits=10, fulls=True, fulld=False)
169: video.set_output() 
170: # remember to set encoder parameters --input depth 10 --output-depth 10 --colormatrix bt709 --colorprim 709 --input-range pc --range pc --transfer undef (so that FFNx will use its custom gamma function)
171: ```
172: 
173: ### Editing Metadata without Re-Encoding
174: Because FFNx often interprets missing or undefined metadata in unusual ways in order to correctly play back its most common inputs (Playstation 1 videos, upscales of Playstation 1 videos, FF7 PC release videos, and FF8 Steam release videos), there will be circumstances where videos of other provenance that are missing colorimetry metadata will play back with incorrect colors. Such videos can be made to play back correctly in FFNx by editing their metadata to correctly describe their colorimetry.
175: 
176: It is possible to edit the metadata of a video stream using ffmpeg without re-encoding it. Please consult [ffmpeg's bitstream filters documentation](https://ffmpeg.org/ffmpeg-bitstream-filters.html). Assuming your video is x264, you will also need the tables in Annex E of [the h264 spec](https://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-H.264-201602-S!!PDF-E&type=items).
177: 
178: Note that ffmpeg is confused by renaming other containers (e.g., mkv) to avi, so the input file name should be changed back to the correct extension first.
179: 
180: Here is an example command that changes the video metadata to bt601 color matrix, undefined color primaries, undefined transfer characteristics, and full range:
181: ```
182: ffmpeg -i input.mkv -c:v copy -bsf:v h264_metadata=matrix_coefficients=6:colour_primaries=2:transfer_characteristics=2:video_full_range_flag=1 -c:a copy output.mkv
183: ```
</file>

<file path="docs/faq.md">
 1: # FAQ
 2: 
 3: ## Common
 4: 
 5: ### I have an AMD GPU and the game has weird visual artifacts while playing
 6: 
 7: If you own an AMD GPU, chances are you have some settings in your GPU which makes the rendering not optimal or with visual artifacts.
 8: 
 9: You can try the following steps to fix ( not 100% guarantee but worth a try ):
10: 
11: 1. Download the latest AMD Drivers https://www.amd.com/en/support
12: 2. Install the drivers and remember to pick the option **Restore settings to Factory default** while installing
13: 3. When opening the AMD Control Panel for the first time, remember to choose the **Standard** profile.
14: 4. Set `renderer_backend = 4` on the [FFNx.toml](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L20) config file.
15: 
16: After doing those steps, you should be able to play normally without any visible visual artifact.
17: 
18: ## Final Fantasy VII
19: 
20: ### Game crashed, now what?
21: 
22: Don't panic. FFNx creates an emergency save for you automatically, located next to your own `ff7.exe` file, located in `saves\crash.ff7`. You can rename this file to for eg. `save00.ff7` and load the first slot on the new game screen.
23: 
24: BE AWARE that this is an emergency save and not everything might have been saved. **Use at your own risk.**
25: 
26: #### If you ARE NOT using 7th Heaven / any third party mod pack
27: 
28: You may open an issue here: https://github.com/julianxhokaxhiu/FFNx/issues
29: 
30: Remember to include:
31: - the `FFNx.log` file you got immediately after the crash ( if you run the game again, it will be overwritten and precious information to understand the issue will be lost forever )
32: - the `crash.ff7` file you can find under `saves\` directory
33: - a description of the issue and how to replicate it
34: - a proof ( picture or video ) that shows the intended issue
35: 
36: #### If you ARE using 7th Heaven / any third party mod pack
37: 
38: Please approach relative Mod Authors through the support links that you can find here: https://github.com/julianxhokaxhiu/FFNx#support
39: 
40: DO NOT attempt to open an issue in this repository. It will be closed immediately without further explainations.
41: 
42: ### I installed the 1998 edition from CDs but movies are not playing
43: 
44: In order to fix that behavior you need to:
45: 
46: - Find the path where `ff7.exe` is installed ( for eg. `C:\Games\Final Fantasy VII` )
47: - Open `RegEdit.exe` and go to this key:
48:   - x32: `HKEY_LOCAL_MACHINE\SOFTWARE\Square Soft, Inc.\Final Fantasy VII`
49:   - x64: `HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Square Soft, Inc.\Final Fantasy VII`
50: - Update the key named `MoviePath` value to `c:\games\final fantasy vii\Data\Movies\`
51: - Copy the movie files from all your CDs into `c:\games\final fantasy vii\Data\Movies\`
52: 
53: You should now be able to play vanilla movies as well as the one distributed via mods.
54: 
55: ## Final Fantasy VIII
56: 
57: ### Game crashed, now what?
58: 
59: You may open an issue here: https://github.com/julianxhokaxhiu/FFNx/issues
60: 
61: Remember to include:
62: - the `FFNx.log` file you got immediately after the crash ( if you run the game again, it will be overwritten and precious information to understand the issue will be lost forever )
63: - a save file of the nearest location required to replicate the issue
64: - a description of the issue and how to replicate it
65: - a proof ( picture or video ) that shows the intended issue
66: 
67: ### After installing the game on Windows 10, when I attempt to run it, it starts as a process but shows nothing
68: 
69: This might happen because your game installation might have got corrupted. There might be many issues affecting this.
70: 
71: One of the possible fixes you can try is:
72: - Pick the CD-ROM drive letter on your Windows installation ( say E: )
73: - Open `RegEdit.exe` and go to this key:
74:   - x32: `HKEY_LOCAL_MACHINE\SOFTWARE\Square Soft, Inc\FINAL FANTASY VIII\1.00`
75:   - x64: `HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Square Soft, Inc\FINAL FANTASY VIII\1.00`
76: - Update the key named `DataDrive` value to `e:`
77: 
78: Try to run again the game. If everything was done correctly, the game should start fine.
</file>

<file path="docs/how_to_install.md">
  1: # How-to: Install
  2: 
  3: Independently of the way you decide to install FFNx, in order to use it you MUST have a legal copy of the game. Support will NOT be provided if the game will NOT be detected as genuine.
  4: 
  5: ## Canary vs Stable
  6: 
  7: FFNx comes in two flavors, resembling the Google Chrome release names. Unlike this one though, we don't need all the others.
  8: 
  9: - **Stable:** this is a fully tested, and hopefully, bug free release.
 10:   > It is commonly accepted for long gameplay sessions and generic users. If in doubt, use this one first.
 11: - **Canary:** this is like a nightly release, but untested. Feel free to use it at your own risk.
 12:   > This is what users need to try before reporting any issue encountered in this channel, or if you want to try the latest development updates going on in FFNx.
 13: 
 14: ## Standalone
 15: 
 16: ### Final Fantasy VII
 17: 
 18: **Supported Languages:** EN, DE, FR, SP, JP\*
 19: 
 20: > \*: Japanese support is currently work in progress. The game starts fine but font is not rendering properly and battles do crash sometimes.
 21: 
 22: #### [1998 Eidos Release](https://www.mobygames.com/game/windows/final-fantasy-vii)
 23: 
 24: 0. Install the game on this path: `C:\Games\Final Fantasy VII`
 25: 1. Update your game to v1.02 ( https://www.gamefront.com/games/final-fantasy-7-advent-children/file/final-fantasy-7-retail-v1-02-patch )
 26: 2. Download the latest `FFNx-FF7_1998` release here: https://github.com/julianxhokaxhiu/FFNx/releases
 27: 3. Extract the ZIP content next to `ff7.exe` file
 28: 4. Double click on [`FFNx.reg`](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FF7.reg)
 29: 5. Click on Yes.
 30: 6. Enjoy!
 31: 
 32: #### [2013 Steam Release](https://store.steampowered.com/app/39140/FINAL_FANTASY_VII/)
 33: 
 34: 0. Install the game using the Steam Client
 35: 1. Make sure you run at least your game once ( until the new game screen )
 36: 2. Open the installation directory of the game ( see [How to access game files](https://steamcommunity.com/sharedfiles/filedetails/?id=760447682) )
 37: 3. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
 38: 4. Extract the ZIP content next to your `ff7_*.exe` file ( for eg. for EN language `ff7_en.exe`)
 39: 5. Replace all files when asked.
 40: 6. Enjoy!
 41: 
 42: #### [2013 eStore Release](http://www.jp.square-enix.com/ffvii-pc-jp/)
 43: 
 44: 0. Install the game using the eStore installer.
 45: 1. Open the installation directory of the game
 46: 2. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
 47: 3. Extract the ZIP content next to your `ff7_*.exe` file ( for eg. for EN language `ff7_en.exe`)
 48: 4. Replace all files when asked.
 49: 5. Enjoy!
 50: 
 51: #### [Android Release](https://play.google.com/store/apps/details?id=com.square_enix.android_googleplay.FFVII)
 52: 
 53: 0. Install the game in your Android device.
 54: 1. Locate the OBB file ( usually in `Android/obb` or `/obb` in your internal storage )
 55: 2. Save the OBB file in your Windows desktop
 56: 3. Rename the OBB file extension from `.obb` to `.zip` and extract it
 57: 4. In the extracted folder, go to `ff7_1.02` directory
 58: 5. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
 59: 6. Extract the ZIP content next to the `ff7_*.exe` files
 60: 7. Update `FFNx.toml` flags with these values:
 61: 
 62: ```toml
 63: ffmpeg_video_ext = "webm"
 64: external_music_path = "data/music_2"
 65: external_music_ext = "akb"
 66: ```
 67: 
 68: 9. You can now run any `ff7_*.exe` file you prefer. Enjoy!
 69: 
 70: ### Final Fantasy VIII
 71: 
 72: **Supported Languages:** EN, DE, FR, SP, IT, JP
 73: 
 74: #### [2000 Squaresoft Release](https://www.mobygames.com/game/windows/final-fantasy-viii)
 75: 
 76: 0. Install the game on this path: `C:\Games\Final Fantasy VIII`
 77: 1. Update your game to v1.2 ( you can find a collection here: https://www.ff8.fr/telechargements/programmes )
 78: 2. Download the latest `FFNx-FF8_2000` release here: https://github.com/julianxhokaxhiu/FFNx/releases
 79: 3. Extract the ZIP content next to `ff8.exe` file
 80: 4. Double click on [`FFNx.reg`](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FF8.reg)
 81: 5. Enjoy!
 82: 
 83: #### [2013 Steam Release](https://store.steampowered.com/app/39150/FINAL_FANTASY_VIII/)
 84: 
 85: 0. Install the game using Steam Client
 86: 1. Make sure you run at least your game once ( until the new game screen )
 87: 2. Open the installation directory of the game ( see [How to access game files](https://steamcommunity.com/sharedfiles/filedetails/?id=760447682) )
 88: 3. Download the latest `FFNx-Steam` release here: https://github.com/julianxhokaxhiu/FFNx/releases
 89: 4. Extract the ZIP content next to your `ff8_*.exe` file ( for eg. for EN language `ff8_en.exe`)
 90: 5. Replace all files when asked.
 91: 6. Enjoy!
 92: 
 93: ## Mod Launchers
 94: 
 95: ### 7thHeaven 2.4.0+
 96: 
 97: 0. Install Final Fantasy VII using the Steam Client
 98: 1. Download and install the latest 7th Heaven release here: https://github.com/tsunamods-codes/7th-Heaven/releases
 99: 2. Launch `7th Heaven` and click Play on the top left
100: 3. Enjoy!
101: 
102: ### SYW Steam all in one
103: 
104: 0. Install Final Fantasy VII using the Steam Client
105: 1. Follow installation instructions here: http://forum.tsunamods.com/viewtopic.php?f=69&p=716&sid=a91d0f964f413cc24c649298cf6f764b#p716
106: 2. Enjoy!
</file>

<file path="docs/readme.md">
 1: # FFNx documentation
 2: 
 3: Welcome to the FFNx documentation!
 4: 
 5: ## Common
 6: 
 7: - [How To Install](how_to_install.md)
 8: - [FAQ - Frequently Asked Questions](faq.md)
 9: - [Built-In Shortcuts](shortcuts.md)
10: 
11: ## FF7
12: 
13: ## FF8
14: 
15:  - [FF8 Specific documentation](ff8/readme.md)
16: 
17: ## Modding
18: 
19: - [DevTools](mods/devtools.md)
20: - [Direct Mode](mods/direct_mode.md)
21: - [EXE Data](mods/exe_data.md)
22: - [Audio Engine](mods/audio_engine.md)
23: - [Video Encoding Guide](mods/video_encoding_guide.md)
24: - [External textures](mods/external_textures.md)
</file>

<file path="docs/shortcuts.md">
  1: # Shortcuts
  2: 
  3: FFNx comes with various built-in shortcuts which would allow you to boost or enjoy your gameplay experience.
  4: 
  5: ### Fullscreen
  6: 
  7: You can toggle the fullscreen mode in any moment while playing by using the related shortcuts.
  8: 
  9: Shortcuts:
 10: 
 11: - Keyboard Shortcut: `Alt + Enter`
 12: 
 13: ### Borderless
 14: 
 15: You can toggle the borderless mode in any moment while playing by using the related shortcuts.
 16: 
 17: Shortcuts:
 18: 
 19: - Keyboard Shortcut: `Shift + Enter`
 20: 
 21: ### Aspect Ratio
 22: 
 23: You can toggle the aspect ratio ( 4:3 or 16:9 ) in any moment while playing by using the related shortcuts.
 24: 
 25: Shortcuts:
 26: 
 27: - Keyboard Shortcut: `Shift + Arrow Left/Right`
 28: 
 29: ### FMV Skip
 30: 
 31: This cheat will allow you to skip movies in-game.
 32: 
 33: Shortcuts:
 34: 
 35: - Keyboard Shortcut: `CTRL + S`
 36: - Gamepad Shortcut: `L3` THEN `SQUARE` (XInput: `LSB` THEN `X`)
 37: 
 38: ### Battle mode toggle
 39: 
 40: This cheat will allow you to disable battle encounters while in the worldmap or in field.
 41: 
 42: Shortcuts:
 43: 
 44: - Keyboard Shortcut: `CTRL + B`
 45: - Gamepad Shortcut: `L3` THEN `CIRCLE` (XInput: `LSB` THEN `B`)
 46: 
 47: ### Speedhack
 48: 
 49: This cheat will allow you to boost the gameplay timing up to 8x ( by default, [you can configure this](<(https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L200)>) up to your pleasure ).
 50: 
 51: Shortcuts:
 52: 
 53: - Keyboard Shortcut: `CTRL + Arrow Up/Down`
 54: - Gamepad Shortcut: `L3` THEN `L1/R1` (XInput: `LSB` THEN `LB/RB`)
 55: 
 56: You can toggle the speedhack (enable/disable) when you want by using these Shortcuts:
 57: 
 58: - Keyboard Shortcut: `CTRL + Arrow Left/Right`
 59: - Gamepad Shortcut: `L3` THEN `L2/R2` (XInput: `LSB` THEN `LT/RT`)
 60: 
 61: ### Soft Reset
 62: 
 63: This cheat will allow you to reset the game like on PSX, by triggering the game over screen wherever you are.
 64: 
 65: Shortcuts:
 66: 
 67: - Keyboard Shortcut: `CTRL + R`
 68: - Gamepad Shortcut: `L3` THEN `START + SELECT` (XInput: `LSB` THEN `BACK + START`)
 69: 
 70: ### Auto-Attack ( FF7 only! )
 71: 
 72: This cheat will allow you to auto-attack the enemies in battle, instead of pressing the action button continously.
 73: 
 74: Shortcuts:
 75: 
 76: - Keyboard Shortcut: `CTRL + A`
 77: - Gamepad Shortcut: `L3` THEN `TRIANGLE` (XInput: `LSB` THEN `Y`)
 78: 
 79: ### Toggle Music on Battle pause ( FF7 only! )
 80: 
 81: This cheat will allow you to resume the music playback while battle is on pause. By pressing the key combination you will be able to toggle the playback ( pause/resume ).
 82: 
 83: Shortcuts:
 84: 
 85: - Keyboard Shortcut: `CTRL + M`
 86: 
 87: ### Voice Auto-Text
 88: 
 89: This cheat will allow you to toggle the voice auto text feature while playing the game. By pressing the key combination you will be able to toggle the auto advance of text boxes as voice line finishes to play.
 90: 
 91: Shortcuts:
 92: 
 93: - Keyboard Shortcut: `CTRL + T`
 94: 
 95: ### Quit Game ( FF8 only! )
 96: 
 97: Shortcuts:
 98: 
 99: - Keyboard Shortcut: `CTRL + Q` (For Qwerty keyboards)
100: - Keyboard Shortcut: `CTRL + A` (For Azerty keyboards)
</file>

<file path="misc/hext/ff7/de/FFNx._GLOBALS.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Transparency value for ALL dialogs
23: # Suggested range of values: 00 - E6 ( 0% - 90%)
24: # Default: BF ( 75% )
25: +8ABD0
26: 6E6C53 = BF
</file>

<file path="misc/hext/ff7/de/FFNx.BATTLE.fullscreen.txt">
  1: #*****************************************************************************#
  2: #    Copyright (C) 2009 Aali132                                               #
  3: #    Copyright (C) 2018 quantumpencil                                         #
  4: #    Copyright (C) 2018 Maxime Bacoux                                         #
  5: #    Copyright (C) 2020 myst6re                                               #
  6: #    Copyright (C) 2020 Chris Rizzitello                                      #
  7: #    Copyright (C) 2020 John Pritchard                                        #
  8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
  9: #                                                                             #
 10: #    This file is part of FFNx                                                #
 11: #                                                                             #
 12: #    FFNx is free software: you can redistribute it and/or modify             #
 13: #    it under the terms of the GNU General Public License as published by     #
 14: #    the Free Software Foundation, either version 3 of the License            #
 15: #                                                                             #
 16: #    FFNx is distributed in the hope that it will be useful,                  #
 17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
 18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
 19: #    GNU General Public License for more details.                             #
 20: #*****************************************************************************#
 21: 
 22: # Fullscreen battle scenes
 23: 41B51A = E0
 24: 41B4E8 = 00
 25: 
 26: +8ABE0
 27: 6CF639 = F4
 28: 6CF6CB = F4
 29: 6CF852 = 1A
 30: 6CF8D7 = 82
 31: 6CF934 = 82
 32: 6CF977 = 82
 33: 6CF9D5 = 82
 34: 
 35: +8ABDD
 36: 6D7A8F = 0D
 37: 6D7B0F = 0F
 38: 
 39: +8ABDD
 40: 6D0B45 = 90 90 90 90 90
 41: 
 42: +8ABD0
 43: 6DC991 = 92
 44: 6DCA16 = 92
 45: 
 46: +8ABD0
 47: 6DD06F = 77
 48: 6DD096 = 77
 49: 6DD0BE = 77
 50: 6DD0E0 = 77
 51: 6DD105 = 77
 52: 6DD12A = 77
 53: 6DD14F = 77
 54: 6DD3BA = 80
 55: 6DD49A = 80
 56: 6DD44D = 80
 57: 6DD539 = 84
 58: 6DD584 = 84
 59: 6DD5D6 = 84
 60: 6DD603 = 82
 61: 6DD6BD = 84
 62: 6DD6EB = 82
 63: 6DD750 = 84
 64: 6DD78F = 8E
 65: 6DD7C0 = 82
 66: 6DD86F = 82
 67: 6DD8A4 = 82
 68: 6DD8D4 = 82
 69: 6DD956 = 82
 70: 6DD9C3 = 82
 71: 6DD9F8 = 82
 72: 
 73: +8ABD0
 74: 6DE5E1 = 78
 75: 6DE66D = 78
 76: 6DE6B4 = 78
 77: 6DE71C = 78
 78: 6DE7BC = 7A
 79: 6DEC56 = 76
 80: 6DED78 = 7A
 81: 6DEDA3 = 84
 82: 6DEDA9 = A0
 83: 6DEDDE = 82
 84: 6DEDE4 = B0
 85: 6DEECB = 7E
 86: 
 87: +8ABD0
 88: 6DF4E2 = 77
 89: 6DF492 = 86
 90: 6DF4BA = 77
 91: 6DF533 = 73
 92: 6DFA14 = 76
 93: 6DFB51 = 7E
 94: 6DFC1C = 84
 95: 6DFC46 = 76
 96: 
 97: +8ABD0
 98: 6E0723 = 76
 99: 6E080C = 7E
100: 6E0823 = 74
101: 6E0A0F = F6
102: 6E0A15 = 76
103: 6E0B2D = 7E
104: 6E0B54 = 76
105: 6E0B59 = 1A
106: 6E0D3B = 79
107: 6E0D40 = 70
108: 6E0D74 = A6
109: 6E0D79 = 82
110: 6E0D92 = C2
111: 6E0D97 = 82
112: 6E0DB3 = 8E
113: 6E0DDB = AA
114: 6E0DFD = C6
115: 6E0E18 = 76
116: 
117: +8ABD0
118: 6E13A1 = 82
119: 6E148C = 82
120: 6E14C1 = 82
121: 6E14F1 = 82
122: 6E1535 = 82
123: 6E1555 = 94
124: 6E162B = 82
125: 6E1660 = 82
126: 6E1690 = 82
127: 6E16D4 = 82
128: 6E16F4 = 94
129: 6E1863 = 82
130: 6E1891 = 76
131: 6E18D4 = 76
132: 6E18FB = 76
133: 
134: +8ABD0
135: 6E2014 = 7E
136: 6E2189 = 76
137: 6E2429 = 18
138: 
139: +8ABD0
140: 6E316D = 76
141: 6E325A = 58
142: 6E3892 = 80
143: 6E38AD = A6
144: 6E38F9 = 80
145: 6E3918 = 9C
146: 6E3964 = 76
147: 6E3A35 = 08 01
148: 6E3B8D = 9A
149: 6E3BBB = AC
150: 6E3C31 = 8A
151: 6E3C59 = 9A
152: 
153: +76A68
154: 91C342 = 70
155: 91C3DA = 70
156: 91C472 = 70
157: 91C50A = 70
158: 91C5A2 = 70
159: 91C5B6 = 10 02
160: 91C5BA = 10 02
161: 91C63A = 70
162: 91C6D2 = 70
163: 91C76A = 70
164: 91CE8A = 70
165: 91CF22 = 70
166: 91CF38 = 70
167: 91CFBA = 70
168: 
169: +76A68
170: 91D0EA = 40
171: 91D182 = 70
172: 91D2B2 = 70
173: 91D34A = 70
174: 91D3E2 = 70
175: 
176: +76AE8
177: 91E7FC = 54
178: 91E990 = 48 6A
</file>

<file path="misc/hext/ff7/de/FFNx.BATTLE.restore_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_QUIT
23: 
24: # Add transparency support for BATTLE dialogs
25: +8ABD0
26: 6E9475 = 0F 84 B3 01 00 00
</file>

<file path="misc/hext/ff7/de/FFNx.BATTLE.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_INITIALIZE
23: 
24: # Add transparency support for BATTLE dialogs
25: +8ABD0
26: 6E9475 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/de/FFNx.FIELD.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Add transparency support for FIELD dialogs
23: +8ABD0
24: 6EB022 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/de/FFNx.MENU.cursor_vertical_center.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Fix Main Menu cursor position ( vcenter relative to text entry )
23: +8B250
24: 715240 = 14
25: 71526B = 14
</file>

<file path="misc/hext/ff7/en/FFNx._GLOBALS.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Transparency value for ALL dialogs
23: # Suggested range of values: 00 - E6 ( 0% - 90%)
24: # Default: BF ( 75% )
25: 6E6C53 = BF
</file>

<file path="misc/hext/ff7/en/FFNx.BATTLE.fullscreen.txt">
  1: #*****************************************************************************#
  2: #    Copyright (C) 2009 Aali132                                               #
  3: #    Copyright (C) 2018 quantumpencil                                         #
  4: #    Copyright (C) 2018 Maxime Bacoux                                         #
  5: #    Copyright (C) 2020 myst6re                                               #
  6: #    Copyright (C) 2020 Chris Rizzitello                                      #
  7: #    Copyright (C) 2020 John Pritchard                                        #
  8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
  9: #                                                                             #
 10: #    This file is part of FFNx                                                #
 11: #                                                                             #
 12: #    FFNx is free software: you can redistribute it and/or modify             #
 13: #    it under the terms of the GNU General Public License as published by     #
 14: #    the Free Software Foundation, either version 3 of the License            #
 15: #                                                                             #
 16: #    FFNx is distributed in the hope that it will be useful,                  #
 17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
 18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
 19: #    GNU General Public License for more details.                             #
 20: #*****************************************************************************#
 21: 
 22: # Fullscreen battle scenes
 23: 41B51A = E0
 24: 41B4E8 = 00
 25: 
 26: 6CF639 = F4
 27: 6CF6CB = F4
 28: 6CF852 = 1A
 29: 6CF8D7 = 82
 30: 6CF934 = 82
 31: 6CF977 = 82
 32: 6CF9D5 = 82
 33: 
 34: 6D7A8F = 0D
 35: 6D7B0F = 0F
 36: 
 37: 6D0B45 = 90 90 90 90 90
 38: 
 39: 6DC991 = 92
 40: 6DCA16 = 92
 41: 
 42: 6DD06F = 77
 43: 6DD096 = 77
 44: 6DD0BE = 77
 45: 6DD0E0 = 77
 46: 6DD105 = 77
 47: 6DD12A = 77
 48: 6DD14F = 77
 49: 6DD3BA = 80
 50: 6DD49A = 80
 51: 6DD44D = 80
 52: 6DD539 = 84
 53: 6DD584 = 84
 54: 6DD5D6 = 84
 55: 6DD603 = 82
 56: 6DD6BD = 84
 57: 6DD6EB = 82
 58: 6DD750 = 84
 59: 6DD78F = 8E
 60: 6DD7C0 = 82
 61: 6DD86F = 82
 62: 6DD8A4 = 82
 63: 6DD8D4 = 82
 64: 6DD956 = 82
 65: 6DD9C3 = 82
 66: 6DD9F8 = 82
 67: 
 68: 6DE5E1 = 78
 69: 6DE66D = 78
 70: 6DE6B4 = 78
 71: 6DE71C = 78
 72: 6DE7BC = 7A
 73: 6DEC56 = 76
 74: 6DED78 = 7A
 75: 6DEDA3 = 84
 76: 6DEDA9 = A0
 77: 6DEDDE = 82
 78: 6DEDE4 = B0
 79: 6DEECB = 7E
 80: 
 81: 6DF4E2 = 77
 82: 6DF492 = 86
 83: 6DF4BA = 77
 84: 6DF533 = 73
 85: 6DFA14 = 76
 86: 6DFB51 = 7E
 87: 6DFC1C = 84
 88: 6DFC46 = 76
 89: 
 90: 6E0723 = 76
 91: 6E080C = 7E
 92: 6E0823 = 74
 93: 6E0A0F = F6
 94: 6E0A15 = 76
 95: 6E0B2D = 7E
 96: 6E0B54 = 76
 97: 6E0B59 = 1A
 98: 6E0D3B = 79
 99: 6E0D40 = 70
100: 6E0D74 = A6
101: 6E0D79 = 82
102: 6E0D92 = C2
103: 6E0D97 = 82
104: 6E0DB3 = 8E
105: 6E0DDB = AA
106: 6E0DFD = C6
107: 6E0E18 = 76
108: 
109: 6E13A1 = 82
110: 6E148C = 82
111: 6E14C1 = 82
112: 6E14F1 = 82
113: 6E1535 = 82
114: 6E1555 = 94
115: 6E162B = 82
116: 6E1660 = 82
117: 6E1690 = 82
118: 6E16D4 = 82
119: 6E16F4 = 94
120: 6E1863 = 82
121: 6E1891 = 76
122: 6E18D4 = 76
123: 6E18FB = 76
124: 
125: 6E2014 = 7E
126: 6E2189 = 76
127: 6E2429 = 18
128: 
129: 6E316D = 76
130: 6E325A = 58
131: 6E3892 = 80
132: 6E38AD = A6
133: 6E38F9 = 80
134: 6E3918 = 9C
135: 6E3964 = 76
136: 6E3A35 = 08 01
137: 6E3B8D = 9A
138: 6E3BBB = AC
139: 6E3C31 = 8A
140: 6E3C59 = 9A
141: 
142: 91C342 = 70
143: 91C3DA = 70
144: 91C472 = 70
145: 91C50A = 70
146: 91C5A2 = 70
147: 91C5B6 = 10 02
148: 91C5BA = 10 02
149: 91C63A = 70
150: 91C6D2 = 70
151: 91C76A = 70
152: 91CE8A = 70
153: 91CF22 = 70
154: 91CF38 = 70
155: 91CFBA = 70
156: 
157: 91D0EA = 40
158: 91D182 = 70
159: 91D2B2 = 70
160: 91D34A = 70
161: 91D3E2 = 70
162: 
163: 91E7FC = 54
164: 91E990 = 48 6A
</file>

<file path="misc/hext/ff7/en/FFNx.BATTLE.restore_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_QUIT
23: 
24: # Add transparency support for BATTLE dialogs
25: 6E9475 = 0F 84 B3 01 00 00
</file>

<file path="misc/hext/ff7/en/FFNx.BATTLE.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_INITIALIZE
23: 
24: # Add transparency support for BATTLE dialogs
25: 6E9475 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/en/FFNx.FIELD.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Add transparency support for FIELD dialogs
23: 6EB022 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/en/FFNx.MENU.cursor_vertical_center.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Fix Main Menu cursor position ( vcenter relative to text entry )
23: 715240 = 14
24: 71526B = 14
</file>

<file path="misc/hext/ff7/es/FFNx._GLOBALS.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Transparency value for ALL dialogs
23: # Suggested range of values: 00 - E6 ( 0% - 90%)
24: # Default: BF ( 75% )
25: +8AFC0
26: 6E6C53 = BF
</file>

<file path="misc/hext/ff7/es/FFNx.BATTLE.fullscreen.txt">
  1: #*****************************************************************************#
  2: #    Copyright (C) 2009 Aali132                                               #
  3: #    Copyright (C) 2018 quantumpencil                                         #
  4: #    Copyright (C) 2018 Maxime Bacoux                                         #
  5: #    Copyright (C) 2020 myst6re                                               #
  6: #    Copyright (C) 2020 Chris Rizzitello                                      #
  7: #    Copyright (C) 2020 John Pritchard                                        #
  8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
  9: #                                                                             #
 10: #    This file is part of FFNx                                                #
 11: #                                                                             #
 12: #    FFNx is free software: you can redistribute it and/or modify             #
 13: #    it under the terms of the GNU General Public License as published by     #
 14: #    the Free Software Foundation, either version 3 of the License            #
 15: #                                                                             #
 16: #    FFNx is distributed in the hope that it will be useful,                  #
 17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
 18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
 19: #    GNU General Public License for more details.                             #
 20: #*****************************************************************************#
 21: 
 22: # Fullscreen battle scenes
 23: +10
 24: 41B51A = E0
 25: 41B4E8 = 00
 26: 
 27: +8AFC0
 28: 6CF639 = F4
 29: 6CF6CB = F4
 30: 6CF852 = 1A
 31: 6CF8D7 = 82
 32: 6CF934 = 82
 33: 6CF977 = 82
 34: 6CF9D5 = 82
 35: 
 36: +8AFC0
 37: 6D7A8F = 0D
 38: 6D7B0F = 0F
 39: 
 40: +8AFC0
 41: 6D0B45 = 90 90 90 90 90
 42: 
 43: +8AFC0
 44: 6DC991 = 92
 45: 6DCA16 = 92
 46: 
 47: +8AFC0
 48: 6DD06F = 77
 49: 6DD096 = 77
 50: 6DD0BE = 77
 51: 6DD0E0 = 77
 52: 6DD105 = 77
 53: 6DD12A = 77
 54: 6DD14F = 77
 55: 6DD3BA = 80
 56: 6DD49A = 80
 57: 6DD44D = 80
 58: 6DD539 = 84
 59: 6DD584 = 84
 60: 6DD5D6 = 84
 61: 6DD603 = 82
 62: 6DD6BD = 84
 63: 6DD6EB = 82
 64: 6DD750 = 84
 65: 6DD78F = 8E
 66: 6DD7C0 = 82
 67: 6DD86F = 82
 68: 6DD8A4 = 82
 69: 6DD8D4 = 82
 70: 6DD956 = 82
 71: 6DD9C3 = 82
 72: 6DD9F8 = 82
 73: 
 74: +8AFC0
 75: 6DE5E1 = 78
 76: 6DE66D = 78
 77: 6DE6B4 = 78
 78: 6DE71C = 78
 79: 6DE7BC = 7A
 80: 6DEC56 = 76
 81: 6DED78 = 7A
 82: 6DEDA3 = 84
 83: 6DEDA9 = A0
 84: 6DEDDE = 82
 85: 6DEDE4 = B0
 86: 6DEECB = 7E
 87: 
 88: +8AFC0
 89: 6DF4E2 = 77
 90: 6DF492 = 86
 91: 6DF4BA = 77
 92: 6DF533 = 73
 93: 6DFA14 = 76
 94: 6DFB51 = 7E
 95: 6DFC1C = 84
 96: 6DFC46 = 76
 97: 
 98: +8AFC0
 99: 6E0723 = 76
100: 6E080C = 7E
101: 6E0823 = 74
102: 6E0A0F = F6
103: 6E0A15 = 76
104: 6E0B2D = 7E
105: 6E0B54 = 76
106: 6E0B59 = 1A
107: 6E0D3B = 79
108: 6E0D40 = 70
109: 6E0D74 = A6
110: 6E0D79 = 82
111: 6E0D92 = C2
112: 6E0D97 = 82
113: 6E0DB3 = 8E
114: 6E0DDB = AA
115: 6E0DFD = C6
116: 6E0E18 = 76
117: 
118: +8AFC0
119: 6E13A1 = 82
120: 6E148C = 82
121: 6E14C1 = 82
122: 6E14F1 = 82
123: 6E1535 = 82
124: 6E1555 = 94
125: 6E162B = 82
126: 6E1660 = 82
127: 6E1690 = 82
128: 6E16D4 = 82
129: 6E16F4 = 94
130: 6E1863 = 82
131: 6E1891 = 76
132: 6E18D4 = 76
133: 6E18FB = 76
134: 
135: +8AFC0
136: 6E2014 = 7E
137: 6E2189 = 76
138: 6E2429 = 18
139: 
140: +8AFC0
141: 6E316D = 76
142: 6E325A = 58
143: 6E3892 = 80
144: 6E38AD = A6
145: 6E38F9 = 80
146: 6E3918 = 9C
147: 6E3964 = 76
148: 6E3A35 = 08 01
149: 6E3B8D = 9A
150: 6E3BBB = AC
151: 6E3C31 = 8A
152: 6E3C59 = 9A
153: 
154: +77CE8
155: 91C342 = 70
156: 91C3DA = 70
157: 91C472 = 70
158: 91C50A = 70
159: 91C5A2 = 70
160: 91C5B6 = 10 02
161: 91C5BA = 10 02
162: 91C63A = 70
163: 91C6D2 = 70
164: 91C76A = 70
165: 91CE8A = 70
166: 91CF22 = 70
167: 91CF38 = 70
168: 91CFBA = 70
169: 
170: +77CE8
171: 91D0EA = 40
172: 91D182 = 70
173: 91D2B2 = 70
174: 91D34A = 70
175: 91D3E2 = 70
176: 
177: +77CE8
178: 91E7FC = 54
179: 91E990 = 48 6A
</file>

<file path="misc/hext/ff7/es/FFNx.BATTLE.restore_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_QUIT
23: 
24: # Add transparency support for BATTLE dialogs
25: +8AFC0
26: 6E9475 = 0F 84 B3 01 00 00
</file>

<file path="misc/hext/ff7/es/FFNx.BATTLE.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_INITIALIZE
23: 
24: # Add transparency support for BATTLE dialogs
25: +8AFC0
26: 6E9475 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/es/FFNx.FIELD.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Add transparency support for FIELD dialogs
23: +8AFC0
24: 6EB022 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/es/FFNx.MENU.cursor_vertical_center.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Fix Main Menu cursor position ( vcenter relative to text entry )
23: +8B6A0
24: 715240 = 14
25: 71526B = 14
</file>

<file path="misc/hext/ff7/fr/FFNx._GLOBALS.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Transparency value for ALL dialogs
23: # Suggested range of values: 00 - E6 ( 0% - 90%)
24: # Default: BF ( 75% )
25: +8AEB0
26: 6E6C53 = BF
</file>

<file path="misc/hext/ff7/fr/FFNx.BATTLE.fullscreen.txt">
  1: #*****************************************************************************#
  2: #    Copyright (C) 2009 Aali132                                               #
  3: #    Copyright (C) 2018 quantumpencil                                         #
  4: #    Copyright (C) 2018 Maxime Bacoux                                         #
  5: #    Copyright (C) 2020 myst6re                                               #
  6: #    Copyright (C) 2020 Chris Rizzitello                                      #
  7: #    Copyright (C) 2020 John Pritchard                                        #
  8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
  9: #                                                                             #
 10: #    This file is part of FFNx                                                #
 11: #                                                                             #
 12: #    FFNx is free software: you can redistribute it and/or modify             #
 13: #    it under the terms of the GNU General Public License as published by     #
 14: #    the Free Software Foundation, either version 3 of the License            #
 15: #                                                                             #
 16: #    FFNx is distributed in the hope that it will be useful,                  #
 17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
 18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
 19: #    GNU General Public License for more details.                             #
 20: #*****************************************************************************#
 21: 
 22: # Fullscreen battle scenes
 23: +10
 24: 41B51A = E0
 25: 41B4E8 = 00
 26: 
 27: +8AEB0
 28: 6CF639 = F4
 29: 6CF6CB = F4
 30: 6CF852 = 1A
 31: 6CF8D7 = 82
 32: 6CF934 = 82
 33: 6CF977 = 82
 34: 6CF9D5 = 82
 35: 
 36: +8AEB0
 37: 6D7A8F = 0D
 38: 6D7B0F = 0F
 39: 
 40: +8AEB0
 41: 6D0B45 = 90 90 90 90 90
 42: 
 43: +8AEB0
 44: 6DC991 = 92
 45: 6DCA16 = 92
 46: 
 47: +8AEB0
 48: 6DD06F = 77
 49: 6DD096 = 77
 50: 6DD0BE = 77
 51: 6DD0E0 = 77
 52: 6DD105 = 77
 53: 6DD12A = 77
 54: 6DD14F = 77
 55: 6DD3BA = 80
 56: 6DD49A = 80
 57: 6DD44D = 80
 58: 6DD539 = 84
 59: 6DD584 = 84
 60: 6DD5D6 = 84
 61: 6DD603 = 82
 62: 6DD6BD = 84
 63: 6DD6EB = 82
 64: 6DD750 = 84
 65: 6DD78F = 8E
 66: 6DD7C0 = 82
 67: 6DD86F = 82
 68: 6DD8A4 = 82
 69: 6DD8D4 = 82
 70: 6DD956 = 82
 71: 6DD9C3 = 82
 72: 6DD9F8 = 82
 73: 
 74: +8AEB0
 75: 6DE5E1 = 78
 76: 6DE66D = 78
 77: 6DE6B4 = 78
 78: 6DE71C = 78
 79: 6DE7BC = 7A
 80: 6DEC56 = 76
 81: 6DED78 = 7A
 82: 6DEDA3 = 84
 83: 6DEDA9 = A0
 84: 6DEDDE = 82
 85: 6DEDE4 = B0
 86: 6DEECB = 7E
 87: 
 88: +8AEB0
 89: 6DF4E2 = 77
 90: 6DF492 = 86
 91: 6DF4BA = 77
 92: 6DF533 = 73
 93: 6DFA14 = 76
 94: 6DFB51 = 7E
 95: 6DFC1C = 84
 96: 6DFC46 = 76
 97: 
 98: +8AEB0
 99: 6E0723 = 76
100: 6E080C = 7E
101: 6E0823 = 74
102: 6E0A0F = F6
103: 6E0A15 = 76
104: 6E0B2D = 7E
105: 6E0B54 = 76
106: 6E0B59 = 1A
107: 6E0D3B = 79
108: 6E0D40 = 70
109: 6E0D74 = A6
110: 6E0D79 = 82
111: 6E0D92 = C2
112: 6E0D97 = 82
113: 6E0DB3 = 8E
114: 6E0DDB = AA
115: 6E0DFD = C6
116: 6E0E18 = 76
117: 
118: +8AEB0
119: 6E13A1 = 82
120: 6E148C = 82
121: 6E14C1 = 82
122: 6E14F1 = 82
123: 6E1535 = 82
124: 6E1555 = 94
125: 6E162B = 82
126: 6E1660 = 82
127: 6E1690 = 82
128: 6E16D4 = 82
129: 6E16F4 = 94
130: 6E1863 = 82
131: 6E1891 = 76
132: 6E18D4 = 76
133: 6E18FB = 76
134: 
135: +8AEB0
136: 6E2014 = 7E
137: 6E2189 = 76
138: 6E2429 = 18
139: 
140: +8AEB0
141: 6E316D = 76
142: 6E325A = 58
143: 6E3892 = 80
144: 6E38AD = A6
145: 6E38F9 = 80
146: 6E3918 = 9C
147: 6E3964 = 76
148: 6E3A35 = 08 01
149: 6E3B8D = 9A
150: 6E3BBB = AC
151: 6E3C31 = 8A
152: 6E3C59 = 9A
153: 
154: +76DF8
155: 91C342 = 70
156: 91C3DA = 70
157: 91C472 = 70
158: 91C50A = 70
159: 91C5A2 = 70
160: 91C5B6 = 10 02
161: 91C5BA = 10 02
162: 91C63A = 70
163: 91C6D2 = 70
164: 91C76A = 70
165: 91CE8A = 70
166: 91CF22 = 70
167: 91CF38 = 70
168: 91CFBA = 70
169: 
170: +76DF8
171: 91D0EA = 40
172: 91D182 = 70
173: 91D2B2 = 70
174: 91D34A = 70
175: 91D3E2 = 70
176: 
177: +76F38
178: 91E7FC = 54
179: 91E990 = 48 6A
</file>

<file path="misc/hext/ff7/fr/FFNx.BATTLE.restore_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_QUIT
23: 
24: # Add transparency support for BATTLE dialogs
25: +8AEB0
26: 6E9475 = 0F 84 B3 01 00 00
</file>

<file path="misc/hext/ff7/fr/FFNx.BATTLE.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: ![BATTLE] Entering FRAME_INITIALIZE
23: 
24: # Add transparency support for BATTLE dialogs
25: +8AEB0
26: 6E9475 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/fr/FFNx.FIELD.transparent_modals.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Add transparency support for FIELD dialogs
23: +8AEB0
24: 6EB022 = 90 90 90 90 90 90
</file>

<file path="misc/hext/ff7/fr/FFNx.MENU.cursor_vertical_center.txt">
 1: #*****************************************************************************#
 2: #    Copyright (C) 2009 Aali132                                               #
 3: #    Copyright (C) 2018 quantumpencil                                         #
 4: #    Copyright (C) 2018 Maxime Bacoux                                         #
 5: #    Copyright (C) 2020 myst6re                                               #
 6: #    Copyright (C) 2020 Chris Rizzitello                                      #
 7: #    Copyright (C) 2020 John Pritchard                                        #
 8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
 9: #                                                                             #
10: #    This file is part of FFNx                                                #
11: #                                                                             #
12: #    FFNx is free software: you can redistribute it and/or modify             #
13: #    it under the terms of the GNU General Public License as published by     #
14: #    the Free Software Foundation, either version 3 of the License            #
15: #                                                                             #
16: #    FFNx is distributed in the hope that it will be useful,                  #
17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
19: #    GNU General Public License for more details.                             #
20: #*****************************************************************************#
21: 
22: # Fix Main Menu cursor position ( vcenter relative to text entry )
23: +8B560
24: 715240 = 14
25: 71526B = 14
</file>

<file path="misc/FF8.reg">
 1: Windows Registry Editor Version 5.00
 2: 
 3: #*****************************************************************************#
 4: #    Copyright (C) 2009 Aali132                                               #
 5: #    Copyright (C) 2018 quantumpencil                                         #
 6: #    Copyright (C) 2018 Maxime Bacoux                                         #
 7: #    Copyright (C) 2020 myst6re                                               #
 8: #    Copyright (C) 2020 Chris Rizzitello                                      #
 9: #    Copyright (C) 2020 John Pritchard                                        #
10: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
11: #                                                                             #
12: #    This file is part of FFNx                                                #
13: #                                                                             #
14: #    FFNx is free software: you can redistribute it and/or modify             #
15: #    it under the terms of the GNU General Public License as published by     #
16: #    the Free Software Foundation, either version 3 of the License            #
17: #                                                                             #
18: #    FFNx is distributed in the hope that it will be useful,                  #
19: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
20: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
21: #    GNU General Public License for more details.                             #
22: #*****************************************************************************#
23: 
24: [HKEY_LOCAL_MACHINE\SOFTWARE\Square Soft, Inc\FINAL FANTASY VIII\1.00]
25: "Graphics"=dword:00100021
26: 
27: [HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Square Soft, Inc\FINAL FANTASY VIII\1.00]
28: "Graphics"=dword:00100021
29: 
30: [HKEY_CURRENT_USER\VirtualStore\Machine\SOFTWARE\Square Soft, Inc\FINAL FANTASY VIII\1.00]
31: "Graphics"=dword:00100021
32: 
33: [HKEY_CURRENT_USER\VirtualStore\Machine\SOFTWARE\Wow6432Node\Square Soft, Inc\FINAL FANTASY VIII\1.00]
34: "Graphics"=dword:00100021
35: 
36: [HKEY_CLASSES_ROOT\VirtualStore\MACHINE\SOFTWARE\Wow6432Node\Square Soft, Inc\FINAL FANTASY VIII\1.00]
37: "Graphics"=dword:00100021
38: 
39: [HKEY_CURRENT_USER\Software\Classes\VirtualStore\MACHINE\SOFTWARE\Wow6432Node\Square Soft, Inc\FINAL FANTASY VIII\1.00]
40: "Graphics"=dword:00100021
41: 
42: # Disable compatibility flags
43: 
44: [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags]
45: "{e1af58c2-e896-4640-bb34-d9fa0b8260a3}"=dword:00000077
46: 
47: [HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags]
48: "{e1af58c2-e896-4640-bb34-d9fa0b8260a3}"=dword:00000077
</file>

<file path="misc/FFNx-Choco.def">
 1: ;*****************************************************************************;
 2: ;    Copyright (C) 2009 Aali132                                               ;
 3: ;    Copyright (C) 2018 quantumpencil                                         ;
 4: ;    Copyright (C) 2018 Maxime Bacoux                                         ;
 5: ;    Copyright (C) 2020 myst6re                                               ;
 6: ;    Copyright (C) 2020 Chris Rizzitello                                      ;
 7: ;    Copyright (C) 2020 John Pritchard                                        ;
 8: ;    Copyright (C) 2025 Julian Xhokaxhiu                                      ;
 9: ;                                                                             ;
10: ;    This file is part of FFNx                                                ;
11: ;                                                                             ;
12: ;    FFNx is free software: you can redistribute it and/or modify             ;
13: ;    it under the terms of the GNU General Public License as published by     ;
14: ;    the Free Software Foundation, either version 3 of the License            ;
15: ;                                                                             ;
16: ;    FFNx is distributed in the hope that it will be useful,                  ;
17: ;    but WITHOUT ANY WARRANTY; without even the implied warranty of           ;
18: ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            ;
19: ;    GNU General Public License for more details.                             ;
20: ;*****************************************************************************;
21: 
22: LIBRARY AF4DN.P
23: EXPORTS
24: ; Required for the Steam driver injection
25: dotemuCreateFileA
26: dotemuCreateMutexA
</file>

<file path="misc/FFNx.ambient.toml">
 1: # FFNx Audio Engine config file - Ambient layer
 2: 
 3: ### HOW TO: ###################################################################
 4: # Sections may be commented by default with an initial # character.
 5: # Remove the initial # character to set the entire sections block and its flags
 6: # -----------------------------------------------------------------------------
 7: # Syntax:
 8: # [ID]
 9: # flag = value
10: # another_flag = value
11: ###############################################################################
12: 
13: ### SUPPORTED FLAGS: ##########################################################
14: # shuffle: Shuffle an SFX ID with one of the given IDs in the array. IDs MUST
15: # be numbers ONLY and MUST NOT contain any special character like - or _.
16: # This flag MUST NOT be used in pair with 'sequential'.
17: # -----------------------------------------------------------------------------
18: # sequential: Sequentially playback an SFX ID with the ones provided in the
19: # array. IDs MUST be numbers ONLY and MUST NOT contain any special character
20: # like - or _. This flag MUST NOT be used in pair with 'shuffle'.
21: # -----------------------------------------------------------------------------
22: # fade_in: Fade in the track on play. The value MUST be a floating point
23: # number and if 0.0 ( default ) then the track will NOT fade.
24: # -----------------------------------------------------------------------------
25: # fade_out: Fade out the track on stop. The value MUST be a floating point
26: # number and if 0.0 ( default ) then the track will NOT fade.
27: # -----------------------------------------------------------------------------
28: # volume: Allow volume to be adjusted for a specific track.
29: ###############################################################################
30: 
31: # Example
32: # -----------------------------------------------------------------------------
33: #[field_123]
34: #shuffle = [ "field_121", "field_122", "field_124" ]
35: #sequential = [ "field_121", "field_122", "field_124" ]
36: #fade_in = 0.0
37: #fade_out = 0.0
38: #volume = 50
</file>

<file path="misc/FFNx.blit.frag">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: $input v_texcoord0
17: 
18: #include <bgfx/bgfx_shader.sh>
19: #include "FFNx.common.sh"
20: 
21: SAMPLER2D(tex_0, 0);
22: 
23: void main()
24: {
25: 	gl_FragColor = texture2D(tex_0, v_texcoord0.xy);
26: }
</file>

<file path="misc/FFNx.blit.vert">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: $input a_position, a_texcoord0
17: $output v_texcoord0
18: 
19: #include <bgfx/bgfx_shader.sh>
20: 
21: void main()
22: {
23:     vec4 pos = a_position;
24: 
25:     pos.w = 1.0 / pos.w;
26:     pos.xyz *= pos.w;
27:     pos = mul(u_proj, pos);
28: 
29:     gl_Position = pos;
30:     v_texcoord0 = a_texcoord0;
31: }
</file>

<file path="misc/FFNx.common.sh">
  1: /****************************************************************************/
  2: //    Copyright (C) 2023 Cosmos                                             //
  3: //                                                                          //
  4: //    This file is part of FFNx                                             //
  5: //                                                                          //
  6: //    FFNx is free software: you can redistribute it and/or modify          //
  7: //    it under the terms of the GNU General Public License as published by  //
  8: //    the Free Software Foundation, either version 3 of the License         //
  9: //                                                                          //
 10: //    FFNx is distributed in the hope that it will be useful,               //
 11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 13: //    GNU General Public License for more details.                          //
 14: /****************************************************************************/
 15: 
 16: // Gamut LUT
 17: SAMPLER2D(tex_10, 10);
 18: 
 19: // YUV to RGB ---------------------------------------------------------
 20: // tv-range functions include implicit range expansion
 21: 
 22: vec3 toRGB_bt601_fullrange(vec3 yuv_input)
 23: {
 24: 	const mat3 jpeg_rgb_transform = mat3(
 25: 		vec3(+1.000, +1.000, +1.000),
 26: 		vec3(+0.000, -0.202008 / 0.587, +1.772),
 27: 		vec3(+1.402, -0.419198 / 0.587, +0.000)
 28: 	);
 29: 	return saturate(instMul(jpeg_rgb_transform, yuv_input));
 30: }
 31: 
 32: vec3 toRGB_bt601_tvrange(vec3 yuv_input)
 33: {
 34: 	const mat3 mpeg_rgb_transform = mat3(
 35: 		vec3(+255.0 / 219.0, +255.0 / 219.0, +255.0 / 219.0),
 36: 		vec3(+0.000, -25.75602 / 65.744 , +225.93 / 112.0),
 37: 		vec3(+178.755 / 112.0, -53.447745 / 65.744 , +0.000)
 38: 	);
 39: 	return saturate(instMul(mpeg_rgb_transform, yuv_input));
 40: }
 41: 
 42: vec3 toRGB_bt709_fullrange(vec3 yuv_input)
 43: {
 44: 	const mat3 bt709full_rgb_transform = mat3(
 45: 		vec3(+1.000, +1.000, +1.000),
 46: 		vec3(+0.000, -0.13397432 / 0.7152, +1.8556),
 47: 		vec3(+1.5748, -0.33480248 / 0.7152 , +0.000)
 48: 	);
 49: 	return saturate(instMul(bt709full_rgb_transform, yuv_input));
 50: }
 51: 
 52: vec3 toRGB_bt709_tvrange(vec3 yuv_input)
 53: {
 54: 	const mat3 bt709tv_rgb_transform = mat3(
 55: 		vec3(+255.0 / 219.0, +255.0 / 219.0, +255.0 / 219.0),
 56: 		vec3(+0.000, -17.0817258 / 80.1024 , +236.589 / 112.0),
 57: 		vec3(+200.787 / 112.0, -42.6873162 / 80.1024 , +0.000)
 58: 	);
 59: 	return saturate(instMul(bt709tv_rgb_transform, yuv_input));
 60: }
 61: 
 62: 
 63: // Gamma functions ------------------------------------------------
 64: 
 65: // gamma encoded --> linear:
 66: 
 67: // sRGB
 68: vec3 toLinear(vec3 _rgb)
 69: {
 70: 	bvec3 cutoff = lessThan(_rgb.rgb, vec3_splat(0.04045));
 71: 	vec3 higher = pow((_rgb.rgb + vec3_splat(0.055)) / vec3_splat(1.055), vec3_splat(2.4));
 72: 	vec3 lower = _rgb.rgb / vec3_splat(12.92);
 73: 
 74: 	return saturate(mix(higher, lower, cutoff));
 75: }
 76: 
 77: vec3 toLinearSMPTE170M(vec3 _rgb)
 78: {
 79: 	bvec3 cutoff = lessThan(_rgb.rgb, vec3_splat(0.0812));
 80: 	vec3 higher = pow((_rgb.rgb + vec3_splat(0.099)) / vec3_splat(1.099), (vec3_splat(1.0) / vec3_splat(0.45)));
 81: 	vec3 lower = _rgb.rgb / vec3_splat(4.5);
 82: 
 83: 	return saturate(mix(higher, lower, cutoff));
 84: }
 85: 
 86: vec3 toLinear2pt2(vec3 _rgb)
 87: {
 88: 	return saturate(pow(_rgb.rgb, vec3_splat(2.2)));
 89: }
 90: 
 91: // Microsoft says PAL uses a pure 2.8 gamma curve. See: https://learn.microsoft.com/en-us/windows/win32/api/mfobjects/ne-mfobjects-mfvideotransferfunction
 92: // ffmpeg thinks there *should* be a linear toe slope, but uses a pure curve since they cannot find any documentation for it. See: https://github.com/FFmpeg/FFmpeg/blob/master/libavfilter/vf_colorspace.c#L162
 93: // In any event, Poynton says 2.8 is "unrealistically high" and PAL CRT units did not really behave like that.
 94: // PAL switched to the SMPTE170M function in 2005 (see BT1700)
 95: vec3 toLinear2pt8(vec3 _rgb)
 96: {
 97: 	return saturate(pow(_rgb.rgb, vec3_splat(2.8)));
 98: }
 99: 
100: // This is an unprincipled, bespoke gamma function that "looks good" with FF7 videos, while all other options are problematic:
101: //   - Functions with toe slopes cause banding near black in these videos.
102: //   - A pure 2.2 power function loses details in shadow to darkness.
103: //   - A pure 2.0 power function blows out highlights.
104: // While unmoored from any theoretical or mathematical justification, this function avoids all those problems.
105: vec3 toLinearToelessSRGB(vec3 _rgb)
106: {
107: 	vec3 twoPtwo = toLinear2pt2(_rgb);
108: 	vec3 sRGB = toLinear(_rgb);
109: 	bvec3 useSRGB = lessThan(sRGB, twoPtwo);
110: 	vec3 proportion = pow(_rgb / vec3_splat(0.389223), vec3_splat(1.0 / 2.2));
111: 	vec3 merged = mix(twoPtwo, sRGB, proportion);
112: 	return saturate(mix(merged, sRGB, useSRGB));
113: }
114: 
115: // linear --> gamma encoded:
116: 
117: // sRGB
118: vec3 toGamma(vec3 _rgb)
119: {
120: 	bvec3 cutoff = lessThan(_rgb.rgb, vec3_splat(0.0031308));
121: 	vec3 higher = vec3_splat(1.055) * pow(_rgb.rgb, vec3_splat(1.0/2.4)) - vec3_splat(0.055);
122: 	vec3 lower = _rgb.rgb * vec3_splat(12.92);
123: 
124: 	return saturate(mix(higher, lower, cutoff));
125: }
126: 
127: // See https://github.com/Microsoft/DirectX-Graphics-Samples/blob/master/MiniEngine/Core/Shaders/ColorSpaceUtility.hlsli#L75
128: // max_nits should be "the brightness level that SDR 'white' is rendered at within an HDR monitor" (probably 100-200ish)
129: // Google Chrome uses a default of 200 if autodetection fails.
130: vec3 ApplyREC2084Curve(vec3 _color, float max_nits)
131: {
132: 	// reference PQ OETF will yield reference OOTF when
133: 	// displayed on  a reference monitor employing EOTF
134: 
135: 	float m1 = 2610.0 / 4096.0 * 1.0 / 4;
136: 	float m2 = 2523.0 / 4096.0 * 128;
137: 	float c1 = 3424.0 / 4096.0;
138: 	float c2 = 2413.0 / 4096.0 * 32;
139: 	float c3 = 2392.0 / 4096.0 * 32;
140: 
141: 	vec3 Lp = pow(_color * (vec3_splat(max_nits)/vec3_splat(10000.0)), vec3_splat(m1));
142: 	return saturate(pow((c1 + c2 * Lp) / (vec3_splat(1.0) + c3 * Lp), vec3_splat(m2)));
143: }
144: 
145: 
146: // Gamut conversions ---------------------------------------------
147: // These functions all take a linear RGB input and produce a linear RGB output.
148: // Mathematically, they are equivalent to:
149: //   1. Convert linear RGB to XYZ using the source gamut's red/green/blue points
150: //   2. Do a gamut conversion from the source gamut to the destination gamut
151: //   3. Covert XYZ to linear RGB using the destination gamut's red/green/blue points
152: // But all of that has been pre-computed into a single matrix multiply operation.
153: 
154: // Note: sRGB is the same gamut as rec709 video.
155: 
156: // Note: High precision values are used for the "D65" whitepoint. (x=0.312713, y=0.329016)
157: 
158: // Note: There are (at least) three different whitepoints that are all referred to as "D93"/"9300K."
159: // The one used here is 9300K+27mpcd (x=0.281, y=0.311), which is what NTSC-J television sets used.
160: 
161: // Most of the gamut conversion matrices have been replacved with LUTs.
162: // We will want to bring them back for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
163: 
164: // To rec2020:
165: // See https://github.com/Microsoft/DirectX-Graphics-Samples/blob/master/MiniEngine/Core/Shaders/ColorSpaceUtility.hlsli#L120
166: vec3 convertGamut_SRGBtoREC2020(vec3 rgb_input)
167: {
168: 	mat3 toRec2020 = mat3(
169: 		vec3(+0.628252390228217, +0.069018748494509, +0.016358741846493),
170: 		vec3(+0.329243684863216, +0.9191169021082, +0.087837787397663),
171: 		vec3(+0.042503924908568, +0.011864349397292, +0.895803470755843)
172: 	);
173: 	return saturate(instMul(toRec2020, rgb_input));
174: }
175: 
176: vec3 convertGamut_NTSCJtoREC2020(vec3 rgb_input)
177: {
178: 	mat3 NTSCJtoRec2020 = mat3(
179: 		vec3(+0.835314787642499, +0.064086581191406, -0.00258827855966),
180: 		vec3(+0.139190018780176, +0.859494098117681, +0.036362217824334),
181: 		vec3(+0.025495200617381, +0.076419362630435, +0.966226011255509)
182: 	);
183: 	return saturate(instMul(NTSCJtoRec2020, rgb_input));
184: }
185: 
186: 
187: // This is a generic 3D LUT function.
188: // We're using it to do gamut conversions when a gamut compression mapping algorithm is necessary to avoid losing detail to clipping.
189: // Since that's waaaay too compute heavy, we precompute it, then use a LUT.
190: // Renderer::AssignGamutLUT() in renderer.cpp is in charge of making sure the correct LUT is bound.
191: // Expects:
192: // - coords 0,0 in the upper left corner
193: // - 4096x64 dimensions
194: // - linear rgb (unlike most other textures BGFX is NOT doing a linearize for us; we expect the image is linear to start with)
195: // - black in the upper left corner
196: // - green on the vertical axis
197: // - red on the small horizontal axis
198: // - blue on the large horizontal axis
199: 
200: vec3 GamutLUT(vec3 rgb_input)
201: {
202: 	vec3 temp = saturate(rgb_input) * vec3_splat(63.0);
203: 	vec3 floors = floor(temp);
204: 	vec3 ceils = ceil(temp);
205: 	vec3 ceilweights = saturate(temp - floors);
206: 
207: 	// driver might not correctly sample a 1.0 coordinate
208: 	// so we are going to add a just-under-half-step offset to red and green, then increase their divisors by 1
209: 	// This should get us a slightly lower coordinate within the same pixel
210: 	floors = floors + vec3(0.4999, 0.4999, 0.0);
211: 	ceils = ceils + vec3(0.4999, 0.4999, 0.0);
212: 	floors = floors / vec3(4096.0, 64.0, 64.0);
213: 	ceils = ceils / vec3(4096.0, 64.0, 64.0);
214: 
215: 	vec3 RfGfBf = (texture2D(tex_10, vec2(floors.b + floors.r, floors.g))).xyz;
216: 	vec3 RfGfBc = (texture2D(tex_10, vec2(ceils.b + floors.r, floors.g))).xyz;
217: 	vec3 RfGcBf = (texture2D(tex_10, vec2(floors.b + floors.r, ceils.g))).xyz;
218: 	vec3 RfGcBc = (texture2D(tex_10, vec2(ceils.b + floors.r, ceils.g))).xyz;
219: 	vec3 RcGfBf = (texture2D(tex_10, vec2(floors.b + ceils.r, floors.g))).xyz;
220: 	vec3 RcGfBc = (texture2D(tex_10, vec2(ceils.b + ceils.r, floors.g))).xyz;
221: 	vec3 RcGcBf = (texture2D(tex_10, vec2(floors.b + ceils.r, ceils.g))).xyz;
222: 	vec3 RcGcBc = (texture2D(tex_10, vec2(ceils.b + ceils.r, ceils.g))).xyz;
223: 
224: 	vec3 RfGf = mix(RfGfBf, RfGfBc, vec3_splat(ceilweights.b));
225: 	vec3 RfGc = mix(RfGcBf, RfGcBc, vec3_splat(ceilweights.b));
226: 	vec3 RcGf = mix(RcGfBf, RcGfBc, vec3_splat(ceilweights.b));
227: 	vec3 RcGc = mix(RcGcBf, RcGcBc, vec3_splat(ceilweights.b));
228: 
229: 	vec3 Rf = mix(RfGf, RfGc, vec3_splat(ceilweights.g));
230: 	vec3 Rc = mix(RcGf, RcGc, vec3_splat(ceilweights.g));
231: 
232: 	vec3 outcolor = mix(Rf, Rc, vec3_splat(ceilweights.r));
233: 
234: 	return outcolor;
235: }
236: 
237: // Dithering ---------------------------------------------
238: 
239: // Apply Martin Roberts' quasirandom dithering scaled below a specified level of precision.
240: // See https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
241: // pixelval: float (range 0-1) pixel color trio.
242: // coords: float (range 0-1) pixel coordinates, i.e., v_texcoord0.xy
243: // ydims: integer dimensions of first channel's texture
244: // udims & vdims: integer dimensions of first second and third channels' textures (may differ from ydim for various yuv formats)
245: // scale_divisor: step size divisor to scale the dithering to fit within. E.g., use 255.0 for dithering 8-bit values.
246: // xyoffset: value to add to x & y coords. Should be at least 1 to avoid x=0 and y=0. Should be different if the same input is dithered twice.
247: // (This function will be used twice if TV-range video is dithered for range expansion, then again for HDR bit depth increase.)
248: vec3 QuasirandomDither(vec3 pixelval, vec2 coords, ivec2 ydims, ivec2 udims, ivec2 vdims, float scale_divisor, float xyoffset)
249: {
250: 	// get integer range x,y coords for this pixel
251: 	// invert one axis for u and the other axis for v to decouple dither patterns across channels
252: 	// see https://blog.kaetemi.be/2015/04/01/practical-bayer-dithering/
253: 	// add 1 to avoid x=0 and y=0
254: 	vec3 xpos = vec3(
255: 		round(float(ydims.x) * coords.x)  + xyoffset,
256: 		round(float(udims.x) * (1.0 - coords.x)) + xyoffset,
257: 		round(float(vdims.x) * coords.x)  + xyoffset
258: 	);
259: 	vec3 ypos = vec3(
260: 		round(float(ydims.y) * coords.y) + xyoffset,
261: 		round(float(udims.y) * coords.y) + xyoffset,
262: 		round(float(vdims.y) * (1.0 - coords.y)) + xyoffset
263: 	);
264: 	// R series magic
265: 	vec3 dither = fract((xpos * vec3_splat(0.7548776662)) + (ypos * vec3_splat(0.56984029)));
266: 	// triangular wave function
267: 	// if exactly 0.5, then pass through so we don't get a 1.0
268: 	bvec3 smallcutoff = lessThan(dither, vec3_splat(0.5));
269: 	bvec3 bigcutoff = greaterThan(dither, vec3_splat(0.5));
270: 	dither = mix(dither, dither * vec3_splat(2.0), smallcutoff);
271: 	dither = mix(dither, vec3_splat(2.0) - (dither * vec3_splat(2.0)), bigcutoff);
272: 	// shift down by half
273: 	dither = dither - vec3_splat(0.5);
274: 	// scale down below the specified step size
275: 	dither = dither / vec3_splat(scale_divisor);
276: 	// add to input
277: 	vec3 tempout = saturate(pixelval + dither);
278: 
279: 	// don't dither colors so close to 0 or 1 that dithering is asymmetric
280: 	bvec3 highcutoff = greaterThan(pixelval, vec3_splat(1.0 - (0.5 / scale_divisor)));
281: 	bvec3 lowcutoff = lessThan(pixelval, vec3_splat(0.5 / scale_divisor));
282: 	vec3 outcolor = mix(tempout, pixelval, highcutoff);
283: 	outcolor = mix(outcolor, pixelval, lowcutoff);
284: 	return outcolor;
285: }
286: 
287: // Fog ---------------------------------------------
288: vec3 ApplyWorldFog(vec3 color, vec3 viewPosition)
289: {
290: 	float d = sqrt(dot(viewPosition, viewPosition));
291: 	float s0 = 0;
292: 	float e0 = 10000;
293: 
294: 	float density = 0.00025;
295: 	float t = 1 / exp (d * density);
296: 
297: 	vec3 fogColor0 = vec3(0.1, 0.1, 0.2);
298: 	vec3 outColor = mix(color * fogColor0, color, t);
299: 
300: 	float e1 = 15000;
301: 	float t2 = 1.0 - saturate((d - e0) / e1);
302: 	outColor *= t2;
303: 
304: 	return outColor;
305: }
306: 
307: // Spherical world  ---------------------------------------------
308: #define cplx vec2
309: #define cplx_new(re, im) vec2(re, im)
310: #define cplx_re(z) z.x
311: #define cplx_im(z) z.y
312: #define cplx_exp(z) (exp(z.x) * cplx_new(cos(z.y), sin(z.y)))
313: #define cplx_scale(z, scalar) (z * scalar)
314: #define cplx_abs(z) (sqrt(z.x * z.x + z.y * z.y))
315: 
316: vec3 ApplySphericalWorld(vec3 viewPosition, float radiusScale)
317: {
318: 	vec3 outResult = vec3(0.0, 0.0, 0.0);
319: 
320: 	float rp = -250000 * radiusScale;
321: 
322: 	vec2 planedir = normalize(vec2(viewPosition.x, viewPosition.z));
323: 	cplx plane = cplx_new(viewPosition.y, sqrt((viewPosition.x) * (viewPosition.x) + (viewPosition.z) * (viewPosition.z)));
324: 	cplx circle = rp * cplx_exp(cplx_scale(plane, 1.0 / rp)) - cplx_new(rp, 0);
325: 	outResult.x = cplx_im(circle) * planedir.x;
326: 	outResult.z = cplx_im(circle) * planedir.y;
327: 	outResult.y = cplx_re(circle);
328: 
329: 	return outResult;
330: }
</file>

<file path="misc/FFNx.def">
 1: ;*****************************************************************************;
 2: ;    Copyright (C) 2009 Aali132                                               ;
 3: ;    Copyright (C) 2018 quantumpencil                                         ;
 4: ;    Copyright (C) 2018 Maxime Bacoux                                         ;
 5: ;    Copyright (C) 2020 myst6re                                               ;
 6: ;    Copyright (C) 2020 Chris Rizzitello                                      ;
 7: ;    Copyright (C) 2020 John Pritchard                                        ;
 8: ;    Copyright (C) 2025 Julian Xhokaxhiu                                      ;
 9: ;                                                                             ;
10: ;    This file is part of FFNx                                                ;
11: ;                                                                             ;
12: ;    FFNx is free software: you can redistribute it and/or modify             ;
13: ;    it under the terms of the GNU General Public License as published by     ;
14: ;    the Free Software Foundation, either version 3 of the License            ;
15: ;                                                                             ;
16: ;    FFNx is distributed in the hope that it will be useful,                  ;
17: ;    but WITHOUT ANY WARRANTY; without even the implied warranty of           ;
18: ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            ;
19: ;    GNU General Public License for more details.                             ;
20: ;*****************************************************************************;
21: 
22: LIBRARY FFNx.dll
23: EXPORTS
24: ; Required by FF8 2000 injection. Ordinal 5 is required in order to inject as eax.dll
25: EAXDirectSoundCreate @5
26: ; Required for the Steam driver injection
27: dotemuRegOpenKeyExA
28: dotemuRegCloseKey
29: dotemuRegFlushKey
30: dotemuRegDeleteValueA
31: dotemuRegSetValueExA
32: dotemuRegQueryValueExA
33: dotemuCreateFileA
34: dotemuGetDriveTypeA
35: dotemuDeleteFileA
36: ; Required by FF7 DLL load injection
37: new_dll_graphics_driver
38: ; FFNx APIs
39: nxRegisterMouseListener
40: nxRegisterKeyListener
</file>

<file path="misc/FFNx.field.shadow.frag">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: $input v_position0, v_color0, v_shadow0
17: 
18: #include <bgfx/bgfx_shader.sh>
19: #define FIELD_SHADOW 1
20: #include "FFNx.pcf.sh"
21: 
22: uniform vec4 lightingDebugData;
23: 
24: // ---
25: #define isShowWalkmeshEnabled lightingDebugData.y > 0.0
26: 
27: void main()
28: {
29:     // Shadow UV
30:     vec4 shadowUv = v_shadow0  / v_shadow0.w;
31: 
32:     // Shadow Factor
33:     float shadowFactor = sampleShadowMapPCF7x7(shadowUv.xyz, v_position0.xyz);
34:     float shadowOcclusion = fieldShadowData.x;
35:     shadowFactor = shadowOcclusion + (1.0 - shadowOcclusion) * shadowFactor;
36: 
37:     if(isShowWalkmeshEnabled)
38:     {
39:         gl_FragColor = vec4(v_color0.rgb * shadowFactor, 1.0);
40:     }
41:     else
42:     {
43:         gl_FragColor = vec4(0.0, 0.0, 0.0, mix(0.0, 1.0 -  shadowFactor, v_color0.a));
44:     }
45: 
46: #if BGFX_SHADER_LANGUAGE_HLSL > 400
47:     // Offsets depth to prevent some weird occlusion problems with field 2D tiles
48:     float depthOffset = 0.0075;
49:     gl_FragDepth =  (1.0 + depthOffset) * gl_FragCoord.z - depthOffset;
50: #endif
51: }
</file>

<file path="misc/FFNx.field.shadow.vert">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: $input a_position, a_color0
17: $output v_position0, v_color0, v_shadow0
18: 
19: #include <bgfx/bgfx_shader.sh>
20: 
21: uniform mat4 d3dViewport;
22: uniform mat4 d3dProjection;
23: uniform mat4 worldView;
24: uniform mat4 lightViewProjTexMatrix;
25: 
26: void main()
27: {
28:     v_position0 = vec4(a_position.xyz, 1.0);
29:     v_color0 = a_color0;
30:     v_shadow0 = mul(mul(lightViewProjTexMatrix, worldView), v_position0);
31:     gl_Position = mul(mul(d3dViewport, mul(d3dProjection, worldView)), v_position0);
32: }
</file>

<file path="misc/FFNx.frag">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: $input v_color0, v_texcoord0, v_position0, v_normal0
 24: 
 25: #include <bgfx/bgfx_shader.sh>
 26: #include "FFNx.common.sh"
 27: 
 28: SAMPLER2D(tex_0, 0);
 29: SAMPLER2D(tex_1, 1);
 30: SAMPLER2D(tex_2, 2);
 31: 
 32: uniform mat4 invViewMatrix;
 33: 
 34: uniform vec4 VSFlags;
 35: uniform vec4 FSAlphaFlags;
 36: uniform vec4 FSMiscFlags;
 37: uniform vec4 FSHDRFlags;
 38: uniform vec4 FSTexFlags;
 39: uniform vec4 WMFlags;
 40: uniform vec4 FSMovieFlags;
 41: uniform vec4 TimeColor;
 42: uniform vec4 TimeData;
 43: uniform vec4 gameLightingFlags;
 44: uniform vec4 gameGlobalLightColor;
 45: uniform vec4 gameLightColor1;
 46: uniform vec4 gameLightColor2;
 47: uniform vec4 gameLightColor3;
 48: uniform vec4 gameLightDir1;
 49: uniform vec4 gameLightDir2;
 50: uniform vec4 gameLightDir3;
 51: uniform vec4 gameScriptedLightColor;
 52: 
 53: #define isTLVertex VSFlags.x > 0.0
 54: #define isFBTexture VSFlags.z > 0.0
 55: #define isTexture VSFlags.w > 0.0
 56: // ---
 57: #define inAlphaRef FSAlphaFlags.x
 58: 
 59: #define isAlphaNever abs(FSAlphaFlags.y - 0.0) < 0.00001
 60: #define isAlphaLess abs(FSAlphaFlags.y - 1.0) < 0.00001
 61: #define isAlphaEqual abs(FSAlphaFlags.y - 2.0) < 0.00001
 62: #define isAlphaLEqual abs(FSAlphaFlags.y - 3.0) < 0.00001
 63: #define isAlphaGreater abs(FSAlphaFlags.y - 4.0) < 0.00001
 64: #define isAlphaNotEqual abs(FSAlphaFlags.y - 5.0) < 0.00001
 65: #define isAlphaGEqual abs(FSAlphaFlags.y - 6.0) < 0.00001
 66: 
 67: #define doAlphaTest FSAlphaFlags.z > 0.0
 68: 
 69: 
 70: // ---
 71: #define isFullRange FSMiscFlags.x > 0.0
 72: #define isYUV FSMiscFlags.y > 0.0
 73: #define modulateAlpha FSMiscFlags.z > 0.0
 74: #define isMovie FSMiscFlags.w > 0.0
 75: 
 76: #define isHDR FSHDRFlags.x > 0.0
 77: #define monitorNits FSHDRFlags.y
 78: 
 79: #define doGamutOverride FSHDRFlags.z > 0.0
 80: 
 81: 
 82: #define isBT601ColorMatrix abs(FSMovieFlags.x - 0.0) < 0.00001
 83: #define isBT709ColorMatrix abs(FSMovieFlags.x - 1.0) < 0.00001
 84: #define isBRG24ColorMatrix abs(FSMovieFlags.x - 2.0) < 0.00001
 85: 
 86: #define isSRGBColorGamut abs(FSMovieFlags.y - 0.0) < 0.00001
 87: #define isNTSCJColorGamut abs(FSMovieFlags.y - 1.0) < 0.00001
 88: #define isSMPTECColorGamut abs(FSMovieFlags.y - 2.0) < 0.00001
 89: #define isEBUColorGamut abs(FSMovieFlags.y - 3.0) < 0.00001
 90: 
 91: #define isSRGBGamma abs(FSMovieFlags.z - 0.0) < 0.00001
 92: #define is2pt2Gamma abs(FSMovieFlags.z - 1.0) < 0.00001
 93: #define is170MGamma abs(FSMovieFlags.z - 2.0) < 0.00001
 94: #define isToelessSRGBGamma abs(FSMovieFlags.z - 3.0) < 0.00001
 95: #define is2pt8Gamma abs(FSMovieFlags.z - 4.0) < 0.00001
 96: 
 97: #define isOverallSRGBColorGamut abs(FSMovieFlags.w - 0.0) < 0.00001
 98: #define isOverallNTSCJColorGamut abs(FSMovieFlags.w - 1.0) < 0.00001
 99: 
100: #define isTimeEnabled TimeData.x > 0.0
101: #define isTimeFilterEnabled TimeData.x > 0.0 && TimeData.y > 0.0
102: 
103: #define gameLightingMode gameLightingFlags.x
104: #define GAME_LIGHTING_PER_PIXEL 2
105: 
106: #define isFogEnabled WMFlags.y > 0.0
107: 
108: void main()
109: {
110:     vec4 color = vec4(toLinear(v_color0.rgb), v_color0.a);
111: 
112:     if (isTexture)
113:     {
114:         if (isYUV)
115:         {
116:             vec3 yuv = vec3(
117:                 texture2D(tex_0, v_texcoord0.xy).r,
118:                 texture2D(tex_1, v_texcoord0.xy).r,
119:                 texture2D(tex_2, v_texcoord0.xy).r
120:             );
121: 
122:             if (!(isFullRange)){
123:                 // dither prior to range conversion
124:                 ivec2 ydimensions = textureSize(tex_0, 0);
125:                 ivec2 udimensions = textureSize(tex_1, 0);
126:                 ivec2 vdimensions = textureSize(tex_2, 0);
127:                 yuv = QuasirandomDither(yuv, v_texcoord0.xy, ydimensions, udimensions, vdimensions, 255.0, 1.0);
128:                 // clamp back to tv range
129:                 yuv = clamp(yuv, vec3_splat(16.0/255.0), vec3(235.0/255.0, 240.0/255.0, 240.0/255.0));
130:             }
131: 
132:             if (isBT601ColorMatrix){
133:                 yuv.g = yuv.g - (128.0/255.0);
134:                 yuv.b = yuv.b - (128.0/255.0);
135:                 if (isFullRange){
136:                     color.rgb = toRGB_bt601_fullrange(yuv);
137:                 }
138:                 else {
139:                     yuv.r = saturate(yuv.r - (16.0/255.0));
140:                     color.rgb = toRGB_bt601_tvrange(yuv);
141:                 }
142:             }
143:             else if (isBT709ColorMatrix){
144:                 yuv.g = yuv.g - (128.0/255.0);
145:                 yuv.b = yuv.b - (128.0/255.0);
146:                 if (isFullRange){
147:                     color.rgb = toRGB_bt709_fullrange(yuv);
148:                 }
149:                 else {
150:                     yuv.r = saturate(yuv.r - (16.0/255.0));
151:                     color.rgb = toRGB_bt709_tvrange(yuv);
152:                 }
153:             }
154:             else if (isBRG24ColorMatrix){
155:                 color.rgb = yuv;
156:             }
157:             // default should be unreachable
158:             else {
159:                 color.rgb = vec3_splat(0.5);
160:             }
161: 
162:             // Use a different inverse gamma function depending on the FMV's metadata
163:             if (isToelessSRGBGamma){
164:                 color.rgb = toLinearToelessSRGB(color.rgb);
165:             }
166:             else if (is2pt2Gamma){
167:                 color.rgb = toLinear2pt2(color.rgb);
168:             }
169:             else if (is170MGamma){
170:                 color.rgb = toLinearSMPTE170M(color.rgb);
171:             }
172:             else if (is2pt8Gamma){
173:                 color.rgb = toLinear2pt8(color.rgb);
174:             }
175:             else {
176:                 color.rgb = toLinear(color.rgb);
177:             }
178: 
179:             // Convert gamut to BT709/SRGB or NTSC-J, depending on what we're going to do in post.
180:             // This approach has the unfortunate drawback of resulting in two gamut conversions for some inputs.
181:             // But it seems to be the only way to avoid breaking stuff that has expectations about the texture colors (like animated field textures).
182:             // Use of NTSC-J as the source gamut  for the original videos and their derivatives is a *highly* probable guess:
183:             // It looks correct, is consistent with the PS1's movie decoder chip's known use of BT601 color matrix, and conforms with Japanese TV standards of the time.
184:             if (isOverallNTSCJColorGamut){
185:                 // do nothing for NTSC-J
186:                 if ((isSRGBColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
187:                     color.rgb = GamutLUT(color.rgb);
188:                     // dither after the LUT operation
189:                     ivec2 dimensions = textureSize(tex_0, 0);
190:                     color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
191:                 }
192:                 // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
193:             }
194:             // overall sRGB
195:             else {
196:                 // do nothing for sRGB
197:                 if ((isNTSCJColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
198:                     color.rgb = GamutLUT(color.rgb);
199:                     // dither after the LUT operation
200:                     ivec2 dimensions = textureSize(tex_0, 0);
201:                     color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
202:                 }
203:                 // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
204:             }
205: 
206:             color.a = 1.0;
207:         }
208:         else
209:         {
210:             vec4 texture_color = texture2D(tex_0, v_texcoord0.xy);
211: 
212:             if (doAlphaTest)
213:             {
214:                 //NEVER
215:                 if (isAlphaNever) discard;
216: 
217:                 //LESS
218:                 if (isAlphaLess)
219:                 {
220:                     if (!(texture_color.a < inAlphaRef)) discard;
221:                 }
222: 
223:                 //EQUAL
224:                 if (isAlphaEqual)
225:                 {
226:                     if (!(texture_color.a == inAlphaRef)) discard;
227:                 }
228: 
229:                 //LEQUAL
230:                 if (isAlphaLEqual)
231:                 {
232:                     if (!(texture_color.a <= inAlphaRef)) discard;
233:                 }
234: 
235:                 //GREATER
236:                 if (isAlphaGreater)
237:                 {
238:                     if (!(texture_color.a > inAlphaRef)) discard;
239:                 }
240: 
241:                 //NOTEQUAL
242:                 if (isAlphaNotEqual)
243:                 {
244:                     if (!(texture_color.a != inAlphaRef)) discard;
245:                 }
246: 
247:                 //GEQUAL
248:                 if (isAlphaGEqual)
249:                 {
250:                     if (!(texture_color.a >= inAlphaRef)) discard;
251:                 }
252:             }
253: 
254:             if (isFBTexture)
255:             {
256:                 if(all(equal(texture_color.rgb,vec3_splat(0.0)))) discard;
257: 
258:                 // This was previously in gamma space, so linearize again.
259:                 texture_color.rgb = toLinear(texture_color.rgb);
260:             }
261:             // This stanza currently does nothing because there's no way to set doGamutOverride.
262:             // Hopefully the future will bring a way to set this for types of textures (e.g., world, model, field, spell, etc.) or even for individual textures based on metadata.
263:             else if (doGamutOverride){
264:                 texture_color.rgb = GamutLUT(texture_color.rgb);
265:                 ivec2 dimensions = textureSize(tex_0, 0);
266:                 texture_color.rgb = QuasirandomDither(texture_color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 1.0);
267:                 // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
268:             }
269: 
270:             if (isMovie) texture_color.a = 1.0;
271: 
272:             if (texture_color.a == 0.0) discard;
273: 
274:             if (modulateAlpha) color *= texture_color;
275:             else
276:             {
277:                 color.rgb *= texture_color.rgb;
278: 			    color.a = texture_color.a;
279:             }
280:         }
281:     }
282: 
283:     if (isTimeFilterEnabled) color.rgb *= TimeColor.rgb;
284: 
285:     if (!(isTLVertex) && isFogEnabled) color.rgb = ApplyWorldFog(color.rgb, v_position0.xyz);
286: 
287:     // return to gamma space so we can do alpha blending the same way FF7/8 did.
288:     color.rgb = toGamma(color.rgb);
289: 
290:     // In this default shader, lighting is applied in gamma space so that it does better match the original lighting
291:     if (gameLightingMode == GAME_LIGHTING_PER_PIXEL)
292:     {
293:         vec3 normal = normalize(v_normal0);
294:         vec3 worldNormal = mul(invViewMatrix, vec4(normal, 0)).xyz;
295:         float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
296:         float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
297:         float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
298:         vec3 light1Ambient = gameLightColor1.rgb * dotLight1 * dotLight1;
299:         vec3 light2Ambient = gameLightColor2.rgb * dotLight2 * dotLight2;
300:         vec3 light3Ambient = gameLightColor3.rgb * dotLight3 * dotLight3;
301:         vec3 lightAmbient = gameScriptedLightColor.rgb * (gameGlobalLightColor.rgb + light1Ambient + light2Ambient + light3Ambient);
302:         color.rgb *= gameGlobalLightColor.w * lightAmbient;
303:     }
304:     
305:     gl_FragColor = color;
306: }
</file>

<file path="misc/FFNx.lighting.frag">
  1: /****************************************************************************/
  2: //    Copyright (C) 2023 Cosmos                                             //
  3: //                                                                          //
  4: //    This file is part of FFNx                                             //
  5: //                                                                          //
  6: //    FFNx is free software: you can redistribute it and/or modify          //
  7: //    it under the terms of the GNU General Public License as published by  //
  8: //    the Free Software Foundation, either version 3 of the License         //
  9: //                                                                          //
 10: //    FFNx is distributed in the hope that it will be useful,               //
 11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 13: //    GNU General Public License for more details.                          //
 14: /****************************************************************************/
 15: 
 16: $input v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0
 17: 
 18: #include <bgfx/bgfx_shader.sh>
 19: #include "FFNx.lighting.sh"
 20: 
 21: // TEX_YUV
 22: SAMPLER2D(tex_0, 0); // Y
 23: SAMPLER2D(tex_1, 1); // U
 24: SAMPLER2D(tex_2, 2); // V
 25: // TEX_NML
 26: SAMPLER2D(tex_5, 5);
 27: // TEX_PBR
 28: SAMPLER2D(tex_6, 6);
 29: 
 30: uniform vec4 VSFlags;
 31: uniform vec4 FSAlphaFlags;
 32: uniform vec4 FSMiscFlags;
 33: uniform vec4 FSHDRFlags;
 34: uniform vec4 FSTexFlags;
 35: uniform vec4 WMFlags;
 36: uniform vec4 FSMovieFlags;
 37: 
 38: uniform vec4 lightingSettings;
 39: uniform vec4 lightingDebugData;
 40: uniform vec4 materialData;
 41: uniform vec4 materialScaleData;
 42: uniform vec4 iblData;
 43: uniform vec4 gameLightingFlags;
 44: uniform vec4 gameGlobalLightColor;
 45: uniform vec4 gameLightColor1;
 46: uniform vec4 gameLightColor2;
 47: uniform vec4 gameLightColor3;
 48: uniform vec4 gameLightDir1;
 49: uniform vec4 gameLightDir2;
 50: uniform vec4 gameLightDir3;
 51: uniform vec4 gameScriptedLightColor;
 52: 
 53: #define isTLVertex VSFlags.x > 0.0
 54: #define isFBTexture VSFlags.z > 0.0
 55: #define isTexture VSFlags.w > 0.0
 56: // ---
 57: #define inAlphaRef FSAlphaFlags.x
 58: 
 59: #define isAlphaNever abs(FSAlphaFlags.y - 0.0) < 0.00001
 60: #define isAlphaLess abs(FSAlphaFlags.y - 1.0) < 0.00001
 61: #define isAlphaEqual abs(FSAlphaFlags.y - 2.0) < 0.00001
 62: #define isAlphaLEqual abs(FSAlphaFlags.y - 3.0) < 0.00001
 63: #define isAlphaGreater abs(FSAlphaFlags.y - 4.0) < 0.00001
 64: #define isAlphaNotEqual abs(FSAlphaFlags.y - 5.0) < 0.00001
 65: #define isAlphaGEqual abs(FSAlphaFlags.y - 6.0) < 0.00001
 66: 
 67: #define doAlphaTest FSAlphaFlags.z > 0.0
 68: 
 69: // ---
 70: #define isFullRange FSMiscFlags.x > 0.0
 71: #define isYUV FSMiscFlags.y > 0.0
 72: #define modulateAlpha FSMiscFlags.z > 0.0
 73: #define isMovie FSMiscFlags.w > 0.0
 74: 
 75: #define isHDR FSHDRFlags.x > 0.0
 76: #define monitorNits FSHDRFlags.y
 77: 
 78: #define doGamutOverride FSHDRFlags.z > 0.0
 79: 
 80: #define isBT601ColorMatrix abs(FSMovieFlags.x - 0.0) < 0.00001
 81: #define isBT709ColorMatrix abs(FSMovieFlags.x - 1.0) < 0.00001
 82: #define isBRG24ColorMatrix abs(FSMovieFlags.x - 2.0) < 0.00001
 83: 
 84: #define isSRGBColorGamut abs(FSMovieFlags.y - 0.0) < 0.00001
 85: #define isNTSCJColorGamut abs(FSMovieFlags.y - 1.0) < 0.00001
 86: #define isSMPTECColorGamut abs(FSMovieFlags.y - 2.0) < 0.00001
 87: #define isEBUColorGamut abs(FSMovieFlags.y - 3.0) < 0.00001
 88: 
 89: #define isSRGBGamma abs(FSMovieFlags.z - 0.0) < 0.00001
 90: #define is2pt2Gamma abs(FSMovieFlags.z - 1.0) < 0.00001
 91: #define is170MGamma abs(FSMovieFlags.z - 2.0) < 0.00001
 92: #define isToelessSRGBGamma abs(FSMovieFlags.z - 3.0) < 0.00001
 93: #define is2pt8Gamma abs(FSMovieFlags.z - 4.0) < 0.00001
 94: 
 95: #define isOverallSRGBColorGamut abs(FSMovieFlags.w - 0.0) < 0.00001
 96: #define isOverallNTSCJColorGamut abs(FSMovieFlags.w - 1.0) < 0.00001
 97: 
 98: // ---
 99: #define debugOutput lightingDebugData.z
100: #define DEBUG_OUTPUT_DISABLED 0
101: #define DEBUG_OUTPUT_COLOR 1
102: #define DEBUG_OUTPUT_NORMAL 2
103: #define DEBUG_OUTPUT_ROUGHNESS 3
104: #define DEBUG_OUTPUT_METALLIC 4
105: #define DEBUG_OUTPUT_AO 5
106: #define DEBUG_OUTPUT_SPECULAR 6
107: #define DEBUG_OUTPUT_IBL_SPECULAR 7
108: #define DEBUG_OUTPUT_IBL_DIFFUSE 8
109: 
110: #define isPbrTextureEnabled lightingSettings.x > 0.0
111: #define isEnvironmentLightingEnabled lightingSettings.y > 0.0
112: 
113: #define isFogEnabled WMFlags.y > 0.0
114: 
115: #define isNmlTextureLoaded FSTexFlags.x > 0.0
116: #define isPbrTextureLoaded FSTexFlags.y > 0.0
117: #define isIblTextureLoaded FSTexFlags.z > 0.0
118: 
119: #define gameLightingMode gameLightingFlags.x
120: #define GAME_LIGHTING_PER_PIXEL 2
121: 
122: void main()
123: {
124:     vec4 color = v_color0;
125:     vec4 color_nml = vec4(0.0, 0.0, 0.0, 0.0);
126:     vec4 color_pbr = vec4(0.0, 0.0, 0.0, 0.0);
127: 
128:     if (isTexture)
129:     {
130:         if (isYUV)
131:         {
132:             vec3 yuv = vec3(
133:                 texture2D(tex_0, v_texcoord0.xy).r,
134:                 texture2D(tex_1, v_texcoord0.xy).r,
135:                 texture2D(tex_2, v_texcoord0.xy).r
136:             );
137: 
138:             if (!(isFullRange)){
139:                 // dither prior to range conversion
140:                 ivec2 ydimensions = textureSize(tex_0, 0);
141:                 ivec2 udimensions = textureSize(tex_1, 0);
142:                 ivec2 vdimensions = textureSize(tex_2, 0);
143:                 yuv = QuasirandomDither(yuv, v_texcoord0.xy, ydimensions, udimensions, vdimensions, 255.0, 1.0);
144:                 // clamp back to tv range
145:                 yuv = clamp(yuv, vec3_splat(16.0/255.0), vec3(235.0/255.0, 240.0/255.0, 240.0/255.0));
146:             }
147: 
148:             if (isBT601ColorMatrix){
149:                 yuv.g = yuv.g - (128.0/255.0);
150:                 yuv.b = yuv.b - (128.0/255.0);
151:                 if (isFullRange){
152:                     color.rgb = toRGB_bt601_fullrange(yuv);
153:                 }
154:                 else {
155:                     yuv.r = saturate(yuv.r - (16.0/255.0));
156:                     color.rgb = toRGB_bt601_tvrange(yuv);
157:                 }
158: 
159:             }
160:             else if (isBT709ColorMatrix){
161:                 yuv.g = yuv.g - (128.0/255.0);
162:                 yuv.b = yuv.b - (128.0/255.0);
163:                 if (isFullRange){
164:                     color.rgb = toRGB_bt709_fullrange(yuv);
165:                 }
166:                 else {
167:                     yuv.r = saturate(yuv.r - (16.0/255.0));
168:                     color.rgb = toRGB_bt709_tvrange(yuv);
169:                 }
170: 
171:             }
172:             else if (isBRG24ColorMatrix){
173:                 color.rgb = yuv;
174:             }
175:             // default should be unreachable
176:             else {
177:                 color.rgb = vec3_splat(0.5);
178:             }
179: 
180:             // Use a different inverse gamma function depending on the FMV's metadata
181:             if (isToelessSRGBGamma){
182:                 color.rgb = toLinearToelessSRGB(color.rgb);
183:             }
184:             else if (is2pt2Gamma){
185:                 color.rgb = toLinear2pt2(color.rgb);
186:             }
187:             else if (is170MGamma){
188:                 color.rgb = toLinearSMPTE170M(color.rgb);
189:             }
190:             else if (is2pt8Gamma){
191:                 color.rgb = toLinear2pt8(color.rgb);
192:             }
193:             else {
194:                 color.rgb = toLinear(color.rgb);
195:             }
196: 
197:             // Convert gamut to BT709/SRGB or NTSC-J, depending on what we're going to do in post.
198:             // This approach has the unfortunate drawback of resulting in two gamut conversions for some inputs.
199:             // But it seems to be the only way to avoid breaking stuff that has expectations about the texture colors (like animated field textures).
200:             // Use of NTSC-J as the source gamut  for the original videos and their derivatives is a *highly* probable guess:
201:             // It looks correct, is consistent with the PS1's movie decoder chip's known use of BT601 color matrix, and conforms with Japanese TV standards of the time.
202:             if (isOverallNTSCJColorGamut){
203:                 // do nothing for NTSC-J
204:                 if ((isSRGBColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
205:                     color.rgb = GamutLUT(color.rgb);
206:                     // dither after the LUT operation
207:                     ivec2 dimensions = textureSize(tex_0, 0);
208:                     color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
209:                 }
210:                 // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
211:             }
212:             // overall sRGB
213:             else {
214:                 // do nothing for sRGB
215:                 if ((isNTSCJColorGamut) || (isSMPTECColorGamut) || (isEBUColorGamut)){
216:                     color.rgb = GamutLUT(color.rgb);
217:                     // dither after the LUT operation
218:                     ivec2 dimensions = textureSize(tex_0, 0);
219:                     color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 4320.0);
220:                 }
221:                 // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
222:             }
223: 
224:             color.a = 1.0;
225:         }
226:         else
227:         {
228:             vec4 texture_color = texture2D(tex_0, v_texcoord0.xy);
229: 
230:             if (isNmlTextureLoaded) color_nml = texture2D(tex_5, v_texcoord0.xy);
231:             if (isPbrTextureLoaded) color_pbr = texture2D(tex_6, v_texcoord0.xy);
232: 
233:             if (doAlphaTest)
234:             {
235:                 //NEVER
236:                 if (isAlphaNever) discard;
237: 
238:                 //LESS
239:                 if (isAlphaLess)
240:                 {
241:                     if (!(texture_color.a < inAlphaRef)) discard;
242:                 }
243: 
244:                 //EQUAL
245:                 if (isAlphaEqual)
246:                 {
247:                     if (!(texture_color.a == inAlphaRef)) discard;
248:                 }
249: 
250:                 //LEQUAL
251:                 if (isAlphaLEqual)
252:                 {
253:                     if (!(texture_color.a <= inAlphaRef)) discard;
254:                 }
255: 
256:                 //GREATER
257:                 if (isAlphaGreater)
258:                 {
259:                     if (!(texture_color.a > inAlphaRef)) discard;
260:                 }
261: 
262:                 //NOTEQUAL
263:                 if (isAlphaNotEqual)
264:                 {
265:                     if (!(texture_color.a != inAlphaRef)) discard;
266:                 }
267: 
268:                 //GEQUAL
269:                 if (isAlphaGEqual)
270:                 {
271:                     if (!(texture_color.a >= inAlphaRef)) discard;
272:                 }
273:             }
274: 
275:             if (isFBTexture)
276:             {
277:                 if(all(equal(texture_color.rgb,vec3_splat(0.0)))) discard;
278: 
279:                 // This was previously in gamma space, so linearize again.
280:                 texture_color.rgb = toLinear(texture_color.rgb);
281:             }
282:             // This stanza currently does nothing because there's no way to set doGamutOverride.
283:             // Hopefully the future will bring a way to set this for types of textures (e.g., world, model, field, spell, etc.) or even for individual textures based on metadata.
284:             else if (doGamutOverride){
285:                 texture_color.rgb = GamutLUT(texture_color.rgb);
286:                 ivec2 dimensions = textureSize(tex_0, 0);
287:                 texture_color.rgb = QuasirandomDither(texture_color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 1.0);
288:                 // Note: Bring back matrix-based conversions for HDR *if* we can find a way to left potentially out-of-bounds values linger until post processing.
289:             }
290: 
291:             if (isMovie) texture_color.a = 1.0;
292: 
293:             if (texture_color.a == 0.0) discard;
294: 
295:             if (modulateAlpha) color *= texture_color;
296:             else
297:             {
298:                 color.rgb *= texture_color.rgb;
299: 			    color.a = texture_color.a;
300:             }
301:         }
302:     }
303: 
304:     vec3 normal = vec3(0.0, 0.0, 0.0);
305:     if(isTLVertex)
306:     {
307:         gl_FragColor = color;
308:         if(isTimeFilterEnabled)
309:         {
310:             gl_FragColor.rgb *= TimeColor.rgb;
311:         }
312:     }
313:     else
314:     {
315:         // Shadow UV
316:         vec3 shadowUv = v_shadow0.xyz / v_shadow0.w;
317: 
318:         // View Direction
319:         vec3 viewDir = normalize(-v_position0.xyz);
320: 
321:         // Normal
322:         normal = normalize(v_normal0);
323:         if(isNmlTextureLoaded && isPbrTextureEnabled) normal = perturb_normal(normal, v_position0.xyz, color_nml.rgb, v_texcoord0.xy );
324: 
325:         // Roughness
326:         float perceptualRoughness = materialData.x;
327:         if(isPbrTextureLoaded && isPbrTextureEnabled) perceptualRoughness = color_pbr.r * materialScaleData.x;
328:         float roughness = min(max(0.001, perceptualRoughness * perceptualRoughness), 1.0);
329: 
330:         // Metallic
331:         float metallic = materialData.y;
332:         if(isPbrTextureLoaded && isPbrTextureEnabled) metallic = color_pbr.g * materialScaleData.y;
333:         metallic = min(1.0, metallic);
334: 
335:         // Specular (dielectric)
336:         float specular = materialData.z;
337:         if(isPbrTextureLoaded && isPbrTextureEnabled) specular = color_pbr.b * materialScaleData.z;
338:         specular = min(1.0, specular);
339: 
340:         // Ambient Occlusion
341:         float ao = 1.0;
342:         if(isPbrTextureLoaded && isPbrTextureEnabled) ao = color_pbr.a;
343: 
344:         // Luminance
345:         vec3 luminance = calcLuminance(color.rgb, v_position0.xyz, viewDir, normal, perceptualRoughness, roughness, metallic, specular, shadowUv);
346: 
347:         // Indirect Luminance
348:         vec3 indirectLuminance = vec3_splat(0.0);
349:         vec3 specularIbl = vec3_splat(0.0);
350:         vec3 diffuseIbl = vec3_splat(0.0);
351:         if(isIblTextureLoaded && isEnvironmentLightingEnabled)
352:         {
353:             // Specular IBL
354:             vec3 R = mul(invViewMatrix, vec4(reflect(-viewDir, normal), 0)).xyz;
355:             float iblMipCount = iblData.x;
356:             float iblLod = CalcMipmapFromRoughness(roughness, iblMipCount);
357:             specularIbl = textureCubeLod(tex_7, R, iblLod).rgb;
358: 
359:             // Diffuse IBL
360:             vec3 worldNormal = mul(invViewMatrix, vec4(normal, 0)).xyz;
361:             diffuseIbl = textureCube(tex_8, worldNormal).rgb;
362: 
363:             indirectLuminance = CalcIblIndirectLuminance(color.rgb, specularIbl, diffuseIbl, viewDir, normal, roughness, metallic, specular, ao);
364:         }
365:         else
366:         {
367:             indirectLuminance = CalcConstIndirectLuminance(color.rgb);
368:         }
369: 
370:         if(debugOutput == DEBUG_OUTPUT_COLOR)
371:         {
372:             gl_FragColor = color;
373:         }
374:         else if(debugOutput == DEBUG_OUTPUT_NORMAL)
375:         {
376:             gl_FragColor = vec4(0.5 * normal + 0.5, 1.0);
377:         }
378:         else if(debugOutput == DEBUG_OUTPUT_ROUGHNESS)
379:         {
380:             gl_FragColor = vec4(vec3_splat(perceptualRoughness), 1.0);
381:         }
382:         else if(debugOutput == DEBUG_OUTPUT_METALLIC)
383:         {
384:             gl_FragColor = vec4(vec3_splat(metallic), 1.0);
385:         }
386:         else if(debugOutput == DEBUG_OUTPUT_AO)
387:         {
388:             gl_FragColor = vec4(vec3_splat(ao), 1.0);
389:         }
390:         else if(debugOutput == DEBUG_OUTPUT_SPECULAR)
391:         {
392:             gl_FragColor = vec4(vec3_splat(specular), 1.0);
393:         }
394:         else if(debugOutput == DEBUG_OUTPUT_IBL_SPECULAR)
395:         {
396:             gl_FragColor = vec4(specularIbl, 1.0);
397:         }
398:         else if(debugOutput == DEBUG_OUTPUT_IBL_DIFFUSE)
399:         {
400:             gl_FragColor = vec4(diffuseIbl, 1.0);
401:         }
402:         else
403:         {
404:             gl_FragColor = vec4(luminance + indirectLuminance, color.a);
405:         }
406: 
407:         if (isFogEnabled && debugOutput == DEBUG_OUTPUT_DISABLED ) gl_FragColor.rgb = ApplyWorldFog(gl_FragColor.rgb, v_position0.xyz);
408:     }
409: 
410:     if(!(isTLVertex) && gameLightingMode == GAME_LIGHTING_PER_PIXEL && debugOutput == DEBUG_OUTPUT_DISABLED)
411:     {
412:         vec3 worldNormal = mul(invViewMatrix, vec4(normal, 0)).xyz;
413:         float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
414:         float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
415:         float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
416:         vec3 light1Ambient = toLinear(gameLightColor1.rgb) * dotLight1 * dotLight1;
417:         vec3 light2Ambient = toLinear(gameLightColor2.rgb) * dotLight2 * dotLight2;
418:         vec3 light3Ambient = toLinear(gameLightColor3.rgb) * dotLight3 * dotLight3;
419:         vec3 lightAmbient = toLinear(gameScriptedLightColor.rgb) * (toLinear(gameGlobalLightColor.rgb) + light1Ambient + light2Ambient + light3Ambient);
420:         gl_FragColor.rgb *= gameGlobalLightColor.w * lightAmbient;
421:     }
422: 
423:     // return to gamma space so we can do alpha blending the same way FF7/8 did.
424:     gl_FragColor.rgb = toGamma(gl_FragColor.rgb);
425: }
</file>

<file path="misc/FFNx.lighting.sh">
  1: /****************************************************************************/
  2: //    Copyright (C) 2023 Cosmos                                             //
  3: //                                                                          //
  4: //    This file is part of FFNx                                             //
  5: //                                                                          //
  6: //    FFNx is free software: you can redistribute it and/or modify          //
  7: //    it under the terms of the GNU General Public License as published by  //
  8: //    the Free Software Foundation, either version 3 of the License         //
  9: //                                                                          //
 10: //    FFNx is distributed in the hope that it will be useful,               //
 11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 13: //    GNU General Public License for more details.                          //
 14: /****************************************************************************/
 15: 
 16: #include "FFNx.pcf.sh"
 17: #include "FFNx.common.sh"
 18: 
 19: // Specular IBL cubemap
 20: SAMPLERCUBE(tex_7, 7);
 21: // Diffuse IBL cubemap
 22: SAMPLERCUBE(tex_8, 8);
 23: // BRDF
 24: SAMPLER2D(tex_9, 9);
 25: 
 26: uniform vec4 lightDirData;
 27: uniform vec4 lightData;
 28: uniform vec4 ambientLightData;
 29: uniform vec4 TimeColor;
 30: uniform vec4 TimeData;
 31: 
 32: #define isTimeEnabled TimeData.x > 0.0
 33: #define isTimeFilterEnabled TimeData.x > 0.0 && TimeData.y > 0.0
 34: 
 35: #define INV_PI 0.31831
 36: 
 37: // Normal Mapping Without Precomputed Tangents
 38: // http://www.thetenthplanet.de/archives/1180
 39: mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
 40: {
 41:     // get edge vectors of the pixel triangle
 42:     vec3 dp1 = dFdx( p );
 43:     vec3 dp2 = dFdy( p );
 44:     vec2 duv1 = dFdx( uv );
 45:     vec2 duv2 = dFdy( uv );
 46: 
 47:     // solve the linear system
 48:     vec3 dp2perp = cross( dp2, N );
 49:     vec3 dp1perp = cross( N, dp1 );
 50:     vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
 51:     vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 52: 
 53:     // construct a scale-invariant frame
 54:     float invmax = inversesqrt(max( dot(T,T), dot(B,B)));
 55: 
 56:     return transpose(mat3(T * invmax, B * invmax, N));
 57: }
 58: 
 59: vec3 perturb_normal(vec3 N, vec3 V, vec3 normalmap, vec2 texcoord)
 60: {
 61:     // assume N, the interpolated vertex normal and
 62:     // V, the view vector (vertex to eye)
 63:     vec3 normalMapRemapped = normalmap * 255.0/127.0 - 128.0/127.0;
 64: 
 65:     // Blend tangent space normal at uv mirror edges to prevent discontinuities
 66:     float blendRange = 0.1;
 67:     float borderCoeff_u = fract(texcoord.x);
 68:     float borderCoeff_v = fract(texcoord.y);
 69:     borderCoeff_u = borderCoeff_u < 0.5 ? borderCoeff_u : 1.0 - borderCoeff_u;
 70:     borderCoeff_v = borderCoeff_v < 0.5 ? borderCoeff_v : 1.0 - borderCoeff_v;
 71:     float t_u = min(1.0, borderCoeff_u / blendRange);
 72:     float t_v = min(1.0, borderCoeff_v / blendRange);
 73:     float newNormalMapX = mix(0.0, normalMapRemapped.x, smoothstep(0.0, 1.0, t_u));
 74:     float newNormalMapY = mix(0.0, normalMapRemapped.y, smoothstep(0.0, 1.0, t_v));
 75:     normalMapRemapped = vec3(newNormalMapX, newNormalMapY, sqrt(1.0 - newNormalMapX * newNormalMapX + newNormalMapY * newNormalMapY));
 76: 
 77:     // Build matrix to transform from tangent to view space
 78:     mat3 TBN = cotangent_frame(N, -V, texcoord);
 79: 
 80:     return normalize(mul(TBN, normalMapRemapped));
 81: }
 82: 
 83: vec3 fresnelSchlick(vec3 F0, float cosTheta)
 84: {
 85:     float Fc = pow( 1 - cosTheta, 5 );
 86: 	return saturate( 50.0 * F0.g ) * Fc + (1 - Fc) * F0;
 87: }
 88: 
 89: float normalDistributionGgx(vec3 N, vec3 H, float perceptualRoughness)
 90: {
 91:     float a2     = perceptualRoughness*perceptualRoughness;
 92:     float NdotH  = max(dot(N, H), 0.0);
 93:     float NdotH2 = NdotH * NdotH;
 94: 
 95:     float num   = a2;
 96:     float denom = (NdotH2 * (a2 - 1.0) + 1.0);
 97:     denom = M_PI * denom * denom;
 98: 
 99:     return num / denom;
100: }
101: 
102: float visiblilitySchlick(float perceptualRoughness, float NoV, float NoL)
103: {
104: 	float k = (perceptualRoughness + 1) / 8.0;
105: 	float visSchlickV = NoV * (1 - k) + k;
106: 	float visSchlickL = NoL * (1 - k) + k;
107: 	return 0.25 / (visSchlickV * visSchlickL);
108: }
109: 
110: vec3 specularCookTorranceBrdf(vec3 F0, vec3 N, vec3 V, vec3 L, float perceptualRoughness, float roughness)
111: {
112:     vec3 H = normalize(V + L);
113:     float dotNV = saturate(dot(N, V)) + 1e-5;
114:     float dotNL = saturate(dot(N, L));
115:     float dotVH = saturate(dot(V, H));
116:     float d = normalDistributionGgx(N, H, roughness);
117:     float g = visiblilitySchlick(perceptualRoughness, dotNV, dotNL);
118:     vec3 f = fresnelSchlick(F0, dotVH);
119:     return d * g * f;
120: }
121: 
122: float CalcMipmapFromRoughness(float roughness, float mipCount)
123: {
124: 	float level = 3.0 - 1.15 * log2( roughness );
125: 	return mipCount - 1.0 - level;
126: }
127: 
128: // Calculates luminance using Physically-Based Rendering (PBR)
129: // https://learnopengl.com/PBR/Theory
130: vec3 calcLuminance(vec3 albedo, vec3 viewSpacePosition, vec3 viewDir, vec3 normal, float perceptualRoughness, float roughness, float metallic, float specular, vec3 shadowUv)
131: {
132:     float shadowFactor = sampleShadowMapPCF7x7(shadowUv.xyz, viewSpacePosition.xyz);
133: 
134:     // Light
135:     float lightIntensity = lightData.w;
136:     vec3 lightColor = toLinear(lightData.rgb);
137:     if(isTimeEnabled)
138:     {
139:         lightColor *= TimeColor.rgb;
140:     }
141: 
142:     vec3 lightDir = normalize(lightDirData.xyz);
143: 
144:     vec3 F0 = mix(specular * vec3_splat(0.08), albedo, metallic);
145: 
146:     vec3 H = normalize(viewDir + lightDir);
147:     float dotVH = saturate(dot(viewDir, H));
148: 
149:     // Diffuse
150:     vec3 diffuseLuminance = (1.0 - metallic) * INV_PI * albedo;
151: 
152:     // Specular
153:     vec3 specularLuminance = specularCookTorranceBrdf(F0, normal, viewDir, lightDir, perceptualRoughness, roughness);
154: 
155:     // Lambert cosine
156:     float NdotL = max(0.0, dot(normal, lightDir));
157: 
158:     return shadowFactor * lightIntensity * lightColor * (diffuseLuminance + specularLuminance) * NdotL;
159: }
160: 
161: vec3 CalcIblIndirectLuminance(vec3 albedo, vec3 specularIbl, vec3 diffuseIbl, vec3 V, vec3 N, float roughness, float metallic, float specular, float ao)
162: {
163:     float dotNV = saturate(dot(N, V));
164:     vec2 envBRDF = texture2D(tex_9, vec2(dotNV, 1.0 - roughness)).xy;
165: 
166:     vec3 F0 = mix(specular * vec3_splat(0.08), albedo, metallic);
167:     vec3 indirectSpecular = specularIbl * (F0 * envBRDF.x + envBRDF.y);
168: 
169:     vec3 diffuse = diffuseIbl * albedo;
170:     vec3 indirectDiffuse = (1.0 - metallic) * diffuse;
171: 
172:     vec3 ambientLightColor = toLinear(ambientLightData.rgb);
173:     float ambientLightIntensity = ambientLightData.w;
174: 
175:     return (indirectDiffuse + indirectSpecular) * ambientLightColor * ambientLightIntensity * ao;
176: }
177: 
178: vec3 CalcConstIndirectLuminance(vec3 albedo)
179: {
180:     // Ambient
181:     vec3 ambientLightColor = toLinear(ambientLightData.rgb);
182:     if(isTimeEnabled)
183:     {
184:         ambientLightColor *= TimeColor.rgb;
185:     }
186: 
187:     float ambientLightIntensity = ambientLightData.w;
188:     vec3 ambient = ambientLightIntensity * ambientLightColor * INV_PI * albedo.rgb;
189: 
190:     return ambient;
191: }
</file>

<file path="misc/FFNx.lighting.toml">
  1: # FFNx Lighting config file
  2: 
  3: ### HOW TO: ###################################################################
  4: # Sections may be commented by default with an initial # character.
  5: # Remove the initial # character to set the entire sections block and its flags
  6: # -----------------------------------------------------------------------------
  7: ###############################################################################
  8: 
  9: ### SUPPORTED FLAGS: ##########################################################
 10: # disable_lighting_textures : disables lighting for models using the given
 11: # texture names
 12: ###############################################################################
 13: 
 14: light_rotation_vertical = 60.0
 15: light_rotation_horizontal = 60.0
 16: light_intensity = 4.0
 17: light_color = [ 1.0, 1.0, 1.0 ]
 18: ambient_light_intensity = 1.0
 19: ambient_light_color = [ 1.0, 1.0, 1.0 ]
 20: material_roughness = 0.7
 21: material_metallic = 0.5
 22: material_specular = 0.1
 23: 
 24: disable_lighting_textures = [
 25:   "STAGE01_T05", "STAGE02_T01", "STAGE02_T02", "STAGE03_T01", "STAGE04_T01",
 26:   "STAGE05_T01", "STAGE05_T02", "STAGE06_T01", "STAGE06_T02", "STAGE07_T01",
 27:   "STAGE07_T02", "STAGE08_T01", "STAGE08_T02", "STAGE19_T01", "STAGE19_T02",
 28:   "STAGE19_T03", "STAGE20_T01", "STAGE20_T02", "STAGE23_T01", "STAGE23_T02",
 29:   "STAGE33_T01", "STAGE33_T02", "STAGE34_T01", "STAGE34_T02", "STAGE36_T01",
 30:   "STAGE36_T02", "STAGE38_T01", "STAGE39_T01", "STAGE40_T02", "STAGE40_T03",
 31:   "STAGE44_T01", "STAGE47_T01", "STAGE47_T02", "STAGE53_T01", "STAGE58_T01",
 32:   "STAGE58_T02", "STAGE59_T01", "STAGE61_T01", "STAGE61_T02", "STAGE62_T01",
 33:   "STAGE62_T02", "STAGE63_T01", "STAGE63_T02", "STAGE64_T01", "STAGE64_T02",
 34:   "STAGE65_T01", "STAGE66_T01", "STAGE66_T02", "STAGE67_T01", "STAGE67_T02",
 35:   "STAGE68_T06", "STAGE69_T04", "STAGE70_T01", "STAGE70_T02", "STAGE71_T01",
 36:   "STAGE71_T02", "STAGE72_T01", "STAGE72_T02", "STAGE79_T01", "STAGE80_T01",
 37:   "STAGE80_T02", "STAGE81_T01", "STAGE81_T02", "STAGE84_T01", "STAGE84_T02",
 38:   "STAGE84_T03", "STAGE87_T01", "STAGE87_T02", "STAGE88_T01", "STAGE88_T02",
 39:   "STAGE89_T01"
 40: ]
 41: 
 42: [field_ancnt1]
 43: shadowmap_fade_start_distance = 200.0
 44: 
 45: [field_anfrst_3]
 46: shadowmap_fade_start_distance = 200.0
 47: 
 48: [field_blin66_5]
 49: shadowmap_fade_start_distance = 200.0
 50: 
 51: [field_blin68_1]
 52: shadowmap_fade_start_distance = 100.0
 53: 
 54: [field_blinst_1]
 55: shadowmap_fade_start_distance = 200.0
 56: 
 57: [field_blinst_2]
 58: shadowmap_fade_start_distance = 200.0
 59: 
 60: [field_blinst_3]
 61: shadowmap_fade_start_distance = 200.0
 62: 
 63: [field_blue_1]
 64: shadowmap_area = 6000.0
 65: 
 66: [field_convil_1]
 67: shadowmap_fade_start_distance = 200.0
 68: 
 69: [field_cos_btm]
 70: shadowmap_fade_start_distance = 200.0
 71: 
 72: [field_cos_top]
 73: shadowmap_fade_start_distance = 200.0
 74: 
 75: [field_del1]
 76: shadowmap_area = 3500.0
 77: 
 78: [field_del12]
 79: shadowmap_area = 3500.0
 80: 
 81: [field_del2]
 82: shadowmap_fade_start_distance = 100.0
 83: 
 84: [field_fship_4]
 85: shadowmap_fade_start_distance = 200.0
 86: 
 87: [field_fship_42]
 88: shadowmap_fade_start_distance = 200.0
 89: 
 90: [field_gaia_2]
 91: shadowmap_fade_start_distance = 200.0
 92: 
 93: [field_gaiafoot]
 94: shadowmap_area = 3500.0
 95: 
 96: [field_gaiin_1]
 97: shadowmap_fade_range = 100.0
 98: shadowmap_fade_start_distance = 100.0
 99: 
100: [field_gnmkf]
101: shadowmap_area = 3800.0
102: 
103: [field_holu_2]
104: shadowmap_fade_start_distance = 100.0
105: 
106: [field_junair]
107: shadowmap_area = 3600.0
108: 
109: [field_junonr1]
110: shadowmap_area = 4000.0
111: 
112: [field_las0_1]
113: shadowmap_fade_start_distance = 200.0
114: 
115: [field_las1_2]
116: shadowmap_fade_start_distance = 200.0
117: 
118: [field_losin1]
119: shadowmap_fade_start_distance = 100.0
120: 
121: [field_losin2]
122: shadowmap_fade_start_distance = 200.0
123: 
124: [field_losin3]
125: shadowmap_fade_start_distance = 100.0
126: 
127: [field_loslake1]
128: shadowmap_fade_start_distance = 200.0
129: 
130: [field_lost1]
131: shadowmap_area = 3100.0
132: 
133: [field_md8_32]
134: shadowmap_fade_start_distance = 200.0
135: 
136: [field_md8_b1]
137: shadowmap_fade_start_distance = 200.0
138: 
139: [field_md8_b2]
140: shadowmap_fade_start_distance = 200.0
141: 
142: [field_mds7st32]
143: shadowmap_area = 3500.0
144: 
145: [field_mtcrl_3]
146: shadowmap_fade_start_distance = 200.0
147: 
148: [field_mtcrl_9]
149: shadowmap_area = 5100.0
150: 
151: [field_rcktbas1]
152: shadowmap_fade_start_distance = 200.0
153: 
154: [field_sandun_1]
155: shadowmap_fade_start_distance = 200.0
156: 
157: [field_sango1]
158: shadowmap_fade_start_distance = 100.0
159: 
160: [field_sango2]
161: shadowmap_area = 6000.0
162: 
163: [field_sango3]
164: shadowmap_fade_start_distance = 200.0
165: 
166: [field_shpin_2]
167: shadowmap_fade_start_distance = 200.0
168: 
169: [field_shpin_22]
170: shadowmap_fade_start_distance = 200.0
171: 
172: [field_sinin3]
173: shadowmap_fade_start_distance = 200.0
174: 
175: [field_trnad_3]
176: shadowmap_area = 3750.0
</file>

<file path="misc/FFNx.lighting.vert">
  1: /****************************************************************************/
  2: //    Copyright (C) 2023 Cosmos                                             //
  3: //                                                                          //
  4: //    This file is part of FFNx                                             //
  5: //                                                                          //
  6: //    FFNx is free software: you can redistribute it and/or modify          //
  7: //    it under the terms of the GNU General Public License as published by  //
  8: //    the Free Software Foundation, either version 3 of the License         //
  9: //                                                                          //
 10: //    FFNx is distributed in the hope that it will be useful,               //
 11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 13: //    GNU General Public License for more details.                          //
 14: /****************************************************************************/
 15: 
 16: $input a_position, a_color0, a_texcoord0, a_normal
 17: $output v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0
 18: 
 19: #include <bgfx/bgfx_shader.sh>
 20: #include "FFNx.common.sh"
 21: 
 22: uniform mat4 d3dViewport;
 23: uniform mat4 d3dProjection;
 24: uniform mat4 viewMatrix;
 25: uniform mat4 worldView;
 26: uniform mat4 normalMatrix;
 27: uniform mat4 lightViewProjTexMatrix;
 28: uniform mat4 invViewMatrix;
 29: 
 30: uniform vec4 VSFlags;
 31: uniform vec4 WMFlags;
 32: uniform vec4 lightingDebugData;
 33: uniform vec4 gameLightingFlags;
 34: uniform vec4 gameGlobalLightColor;
 35: uniform vec4 gameLightColor1;
 36: uniform vec4 gameLightColor2;
 37: uniform vec4 gameLightColor3;
 38: uniform vec4 gameLightDir1;
 39: uniform vec4 gameLightDir2;
 40: uniform vec4 gameLightDir3;
 41: uniform vec4 gameScriptedLightColor;
 42: 
 43: #define isTLVertex VSFlags.x > 0.0
 44: #define blendMode VSFlags.y
 45: #define isFBTexture VSFlags.z > 0.0
 46: #define isNotTexture VSFlags.w == 0.0
 47: 
 48: #define isApplySphericalWorld WMFlags.x > 0.0
 49: #define sphericaWorldRadiusScale WMFlags.x
 50: 
 51: #define isHide2dEnabled lightingDebugData.x > 0.0
 52: 
 53: #define gameLightingMode gameLightingFlags.x
 54: #define GAME_LIGHTING_PER_VERTEX 1
 55: 
 56: void main()
 57: {
 58: 	vec4 pos = a_position;
 59:     vec4 color = a_color0;
 60:     vec2 coords = a_texcoord0;
 61: 
 62:     color.rgb = toLinear(color.bgr);
 63: 
 64:     if (isTLVertex)
 65:     {
 66:         pos.w = 1.0 / pos.w;
 67:         pos.xyz *= pos.w;
 68:         pos = mul(u_proj, pos);
 69: 
 70:         if (isHide2dEnabled) pos = vec4_splat(0.0);
 71:     }
 72:     else
 73:     {
 74:         v_position0 = mul(worldView, vec4(pos.xyz, 1.0));
 75: 
 76:         if (isApplySphericalWorld) pos.xyz = ApplySphericalWorld(v_position0.xyz, sphericaWorldRadiusScale);
 77:         else pos = v_position0;
 78: 
 79:         v_shadow0 = mul(lightViewProjTexMatrix, v_position0);
 80:         v_normal0 = mul(normalMatrix, vec4(a_normal, 0.0)).xyz;
 81:         pos = mul(mul(d3dViewport, d3dProjection), vec4(pos.xyz, 1.0));
 82: 
 83:         if (gameLightingMode == GAME_LIGHTING_PER_VERTEX)
 84:         {
 85:             vec3 worldNormal = mul(invViewMatrix, vec4(v_normal0, 0)).xyz;
 86:             float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
 87:             float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
 88:             float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
 89:             vec3 light1Ambient = toLinear(gameLightColor1.rgb) * dotLight1 * dotLight1;
 90:             vec3 light2Ambient = toLinear(gameLightColor2.rgb) * dotLight2 * dotLight2;
 91:             vec3 light3Ambient = toLinear(gameLightColor3.rgb) * dotLight3 * dotLight3;
 92:             vec3 lightAmbient = toLinear(gameScriptedLightColor.rgb) * (toLinear(gameGlobalLightColor.rgb) + light1Ambient + light2Ambient + light3Ambient);
 93:             color.rgb *= gameGlobalLightColor.w * lightAmbient;
 94:         }
 95: 
 96:         if (color.a > 0.5) color.a = 0.5;
 97:     }
 98: 
 99:     if (blendMode == 4.0) color.a = 1.0;
100:     else if (blendMode == 3.0) color.a = 0.25;
101: 
102: #if BGFX_SHADER_LANGUAGE_HLSL
103: #else
104:     #if BGFX_SHADER_LANGUAGE_SPIRV
105:     #else
106:         if (isFBTexture) coords.y = 1.0 - coords.y;
107:     #endif
108: #endif
109: 
110:     gl_Position = pos;
111:     v_color0 = color;
112:     v_texcoord0 = coords;
113: }
</file>

<file path="misc/FFNx.music.toml">
 1: # FFNx Audio Engine config file - Music layer
 2: 
 3: ### HOW TO: ###################################################################
 4: # Sections may be commented by default with an initial # character.
 5: # Remove the initial # character to set the entire sections block and its flags
 6: # -----------------------------------------------------------------------------
 7: # Syntax:
 8: # [MUSIC_NAME]
 9: # flag = value
10: # another_flag = value
11: ###############################################################################
12: 
13: ### SUPPORTED FLAGS: ##########################################################
14: # offset_seconds: Offset in seconds. Plays the music at this value instead of
15: # from the begining. Set this value to "sync" to play the music at
16: # the current offset of the previous playing music (can be slow).
17: # -----------------------------------------------------------------------------
18: # no_intro_track: [FF8 Only] Name of the "no intro" music. When the "no intro"
19: # version is detected, plays this music instead.
20: # -----------------------------------------------------------------------------
21: # intro_seconds: [FF8 Only] Offset in seconds. When the "no intro" version is
22: # detected, skips the beginning of the music.
23: # -----------------------------------------------------------------------------
24: # shuffle: Shuffle an SFX ID with one of the given IDs in the array.
25: # -----------------------------------------------------------------------------
26: # disabled: Set this flag to true to never play this music and act like it was
27: # never triggered by the game.
28: # -----------------------------------------------------------------------------
29: # relative_speed: Set the music relative speed, with 1.0 is the normal speed,
30: # between 0.0 and 1.0 (not included) the music is slowed down, and above 1.0
31: # the music is sped up.
32: ###############################################################################
33: 
34: # This entry will shuffle "battle" with "battle2", "bossbat1" and "bossbat2".
35: # Everytime the game engine will try to playback 1, one of the entries in the
36: # array will be picked randomly.
37: # -----------------------------------------------------------------------------
38: #[battle]
39: #shuffle = [ "battle2", "bossbat1", "bossbat2" ]
40: 
41: # Plays gar3 when gargade (GGU theme) is played but the "no intro" flag is set
42: # -----------------------------------------------------------------------------
43: #[gargarde]
44: #no_intro_track = "gar3"
45: 
46: # Skip 20.5 seconds of hikutei (Ragnarok theme) if the "no intro" flag is set
47: # -----------------------------------------------------------------------------
48: #[hikutei]
49: #intro_seconds = 20.5
</file>

<file path="misc/FFNx.overlay.frag">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: $input v_color0, v_texcoord0
23: 
24: #include <bgfx/bgfx_shader.sh>
25: 
26: SAMPLER2D(s_tex, 0);
27: 
28: void main()
29: {
30: 	vec4 texel = texture2D(s_tex, v_texcoord0);
31: 	gl_FragColor = texel * v_color0;
32: }
</file>

<file path="misc/FFNx.overlay.vert">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: $input a_position, a_texcoord0, a_color0
23: $output v_color0, v_texcoord0
24: 
25: #include <bgfx/bgfx_shader.sh>
26: #include "FFNx.common.sh"
27: 
28: void main()
29: {
30: 	vec2 pos = 2.0*a_position.xy*u_viewTexel.xy;
31: 	gl_Position = vec4(pos.x - 1.0, 1.0 - pos.y, 0.0, 1.0);
32: 	v_texcoord0 = a_texcoord0;
33: 	v_color0    = a_color0;
34: }
</file>

<file path="misc/FFNx.pcf.sh">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2023 Cosmos                                             //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: // TEX_S
 23: SAMPLER2DSHADOW(tex_3, 3);
 24: // TEX_D
 25: SAMPLER2D(tex_4, 4);
 26: 
 27: uniform mat4 invViewMatrix;
 28: uniform mat4 lightInvViewProjTexMatrix;
 29: uniform vec4 fieldShadowData;
 30: uniform vec4 shadowData;
 31: 
 32: float sampleShadowMap(vec2 base_uv, float u, float v, float shadowMapSizeInv, float lightDepth, vec3 worldSpacePos)
 33: {
 34:     vec2 uv = base_uv + vec2(u, v) * shadowMapSizeInv;
 35: 
 36:     vec3 shadowUv = vec3(uv, lightDepth);
 37:     if(shadowUv.x < 0.0 || shadowUv.x > 1.0 || shadowUv.y < 0.0 || shadowUv.y > 1.0 || lightDepth < 0.0 || lightDepth > 1.0) return 1.0;
 38: 
 39:     float shadowFactor = shadow2D(tex_3, shadowUv);
 40: 
 41: #ifdef FIELD_SHADOW
 42: #if BGFX_SHADER_LANGUAGE_HLSL > 400
 43:     // Fade out shadows as the vertical distance between occluder and walkmesh increases
 44:     // This is to prevent shadows being projected to multiple floors
 45: 
 46:     float shadowDistance = 0.0;
 47:     vec4 lightDepths = textureGather(tex_4, shadowUv.xy, 0);
 48:     for(int i = 0; i < 4; ++i)
 49:     {
 50:         vec4 shadowPos = vec4(shadowUv.xy, lightDepths[i], 1.0);
 51:         vec4 worldSpaceShadowPos = mul(mul(invViewMatrix, lightInvViewProjTexMatrix), shadowPos);
 52:         worldSpaceShadowPos.xyz /= worldSpaceShadowPos.w;
 53: 
 54:         shadowDistance = max(shadowDistance, worldSpaceShadowPos.z - worldSpacePos.z);
 55:     }
 56: 
 57:     float shadowFadeStartDistance = fieldShadowData.y;
 58:     float fadeRange = fieldShadowData.z;
 59:     float fadeFactor = max(0.0, min(1.0, (shadowDistance - shadowFadeStartDistance) / fadeRange));
 60: 
 61:     shadowFactor = mix(shadowFactor, 1.0, fadeFactor);
 62: #endif
 63: #endif
 64: 
 65:     return shadowFactor;
 66: }
 67: 
 68: // Shadow filtering (OptimizedPCF)
 69: // https://github.com/TheRealMJP/Shadows/blob/master/Shadows/Mesh.hlsl
 70: float sampleShadowMapPCF7x7(vec3 shadowPos, vec3 worldSpacePos)
 71: {
 72:     float lightDepth = shadowPos.z;
 73:     lightDepth -= shadowData.x;
 74: 
 75:     float shadowMapSize = shadowData.w;
 76:     float shadowMapSizeInv = 1.0 / shadowMapSize;
 77: 
 78:     vec2 uv = shadowPos.xy * shadowMapSize;
 79: 
 80:     vec2 base_uv;
 81:     base_uv.x = floor(uv.x + 0.5);
 82:     base_uv.y = floor(uv.y + 0.5);
 83: 
 84:     float s = (uv.x + 0.5 - base_uv.x);
 85:     float t = (uv.y + 0.5 - base_uv.y);
 86: 
 87:     base_uv -= vec2(0.5, 0.5);
 88:     base_uv *= shadowMapSizeInv;
 89: 
 90:     float uw0 = (5 * s - 6);
 91:     float uw1 = (11 * s - 28);
 92:     float uw2 = -(11 * s + 17);
 93:     float uw3 = -(5 * s + 1);
 94: 
 95:     float u0 = (4 * s - 5) / uw0 - 3;
 96:     float u1 = (4 * s - 16) / uw1 - 1;
 97:     float u2 = -(7 * s + 5) / uw2 + 1;
 98:     float u3 = -s / uw3 + 3;
 99: 
100:     float vw0 = (5 * t - 6);
101:     float vw1 = (11 * t - 28);
102:     float vw2 = -(11 * t + 17);
103:     float vw3 = -(5 * t + 1);
104: 
105:     float v0 = (4 * t - 5) / vw0 - 3;
106:     float v1 = (4 * t - 16) / vw1 - 1;
107:     float v2 = -(7 * t + 5) / vw2 + 1;
108:     float v3 = -t / vw3 + 3;
109: 
110:     float sum = 0.0;
111: 
112:     sum += uw0 * vw0 * sampleShadowMap(base_uv, u0, v0, shadowMapSizeInv, lightDepth, worldSpacePos);
113:     sum += uw1 * vw0 * sampleShadowMap(base_uv, u1, v0, shadowMapSizeInv, lightDepth, worldSpacePos);
114:     sum += uw2 * vw0 * sampleShadowMap(base_uv, u2, v0, shadowMapSizeInv, lightDepth, worldSpacePos);
115:     sum += uw3 * vw0 * sampleShadowMap(base_uv, u3, v0, shadowMapSizeInv, lightDepth, worldSpacePos);
116: 
117:     sum += uw0 * vw1 * sampleShadowMap(base_uv, u0, v1, shadowMapSizeInv, lightDepth, worldSpacePos);
118:     sum += uw1 * vw1 * sampleShadowMap(base_uv, u1, v1, shadowMapSizeInv, lightDepth, worldSpacePos);
119:     sum += uw2 * vw1 * sampleShadowMap(base_uv, u2, v1, shadowMapSizeInv, lightDepth, worldSpacePos);
120:     sum += uw3 * vw1 * sampleShadowMap(base_uv, u3, v1, shadowMapSizeInv, lightDepth, worldSpacePos);
121: 
122:     sum += uw0 * vw2 * sampleShadowMap(base_uv, u0, v2, shadowMapSizeInv, lightDepth, worldSpacePos);
123:     sum += uw1 * vw2 * sampleShadowMap(base_uv, u1, v2, shadowMapSizeInv, lightDepth, worldSpacePos);
124:     sum += uw2 * vw2 * sampleShadowMap(base_uv, u2, v2, shadowMapSizeInv, lightDepth, worldSpacePos);
125:     sum += uw3 * vw2 * sampleShadowMap(base_uv, u3, v2, shadowMapSizeInv, lightDepth, worldSpacePos);
126: 
127:     sum += uw0 * vw3 * sampleShadowMap(base_uv, u0, v3, shadowMapSizeInv, lightDepth, worldSpacePos);
128:     sum += uw1 * vw3 * sampleShadowMap(base_uv, u1, v3, shadowMapSizeInv, lightDepth, worldSpacePos);
129:     sum += uw2 * vw3 * sampleShadowMap(base_uv, u2, v3, shadowMapSizeInv, lightDepth, worldSpacePos);
130:     sum += uw3 * vw3 * sampleShadowMap(base_uv, u3, v3, shadowMapSizeInv, lightDepth, worldSpacePos);
131: 
132:     vec2 baseUvShifted = abs(base_uv * 2.0 - 1.0);
133:     float fadeCoeff = saturate(max(baseUvShifted.x, baseUvShifted.y) - 0.9) / 0.1;
134: 
135:     return mix(sum * 1.0 / 2704.0, 1.0, fadeCoeff);
136: }
</file>

<file path="misc/FFNx.post.frag">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: $input v_color0, v_texcoord0
23: 
24: #include <bgfx/bgfx_shader.sh>
25: #include "FFNx.common.sh"
26: 
27: SAMPLER2D(tex_0, 0);
28: 
29: uniform vec4 FSHDRFlags;
30: uniform vec4 FSMovieFlags;
31: 
32: #define isHDR FSHDRFlags.x > 0.0
33: #define monitorNits FSHDRFlags.y
34: 
35: #define isOverallSRGBColorGamut abs(FSMovieFlags.w - 0.0) < 0.00001
36: #define isOverallNTSCJColorGamut abs(FSMovieFlags.w - 1.0) < 0.00001
37: 
38: void main()
39: {
40: 	vec4 color = texture2D(tex_0, v_texcoord0.xy);
41: 
42: 	if (isHDR) {
43: 		// back to linear for gamut conversion and PQ gamma curve
44: 		color.rgb = toLinear(color.rgb);
45: 
46: 		// TODO: If/when a full 10-bit pathway is available for 10-bit FMVs, don't dither those
47: 		ivec2 dimensions = textureSize(tex_0, 0);
48: 		color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 2160.0);
49: 		if (isOverallNTSCJColorGamut){
50: 			color.rgb = convertGamut_NTSCJtoREC2020(color.rgb);
51: 		}
52: 		else {
53: 			color.rgb = convertGamut_SRGBtoREC2020(color.rgb);
54: 		}
55: 		color.rgb = ApplyREC2084Curve(color.rgb, monitorNits);
56: 	}
57: 	else if (isOverallNTSCJColorGamut){
58: 		color.rgb = toLinear(color.rgb);
59: 		color.rgb = GamutLUT(color.rgb);
60: 		// dither after the LUT operation
61: 		ivec2 dimensions = textureSize(tex_0, 0);
62: 		color.rgb = QuasirandomDither(color.rgb, v_texcoord0.xy, dimensions, dimensions, dimensions, 255.0, 2160.0);
63: 		color.rgb = toGamma(color.rgb);
64: 	}
65: 
66: 	gl_FragColor = color;
67: }
</file>

<file path="misc/FFNx.post.vert">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: $input a_position, a_color0, a_texcoord0
23: $output v_color0, v_texcoord0
24: 
25: #include <bgfx/bgfx_shader.sh>
26: 
27: void main()
28: {
29: 	vec4 pos = a_position;
30:     vec4 color = a_color0;
31:     vec2 coords = a_texcoord0;
32: 
33:     color.rgba = color.bgra;
34: 
35:     pos.w = 1.0 / pos.w;
36:     pos.xyz *= pos.w;
37:     pos = mul(u_proj, pos);
38: 
39:     gl_Position = pos;
40:     v_color0 = color;
41:     v_texcoord0 = coords;
42: }
</file>

<file path="misc/FFNx.SFX.toml">
 1: # FFNx Audio Engine config file - SFX layer
 2: 
 3: ### HOW TO: ###################################################################
 4: # Sections may be commented by default with an initial # character.
 5: # Remove the initial # character to set the entire sections block and its flags
 6: # -----------------------------------------------------------------------------
 7: # Syntax:
 8: # [ID]
 9: # flag = value
10: # another_flag = value
11: ###############################################################################
12: 
13: ### SUPPORTED FLAGS: ##########################################################
14: # shuffle: Shuffle an SFX ID with one of the given IDs in the array. IDs MUST
15: # be numbers ONLY and MUST NOT contain any special character like - or _.
16: # This flag MUST NOT be used in pair with 'sequential'.
17: # -----------------------------------------------------------------------------
18: # sequential: Sequentially playback an SFX ID with the ones provided in the
19: # array. IDs MUST be numbers ONLY and MUST NOT contain any special character
20: # like - or _. This flag MUST NOT be used in pair with 'shuffle'.
21: # -----------------------------------------------------------------------------
22: # loop: Enable loop for the requested SFX ID
23: # -----------------------------------------------------------------------------
24: # skip: Enable this flag to skip playing the SFX ID and have silence instead.
25: # PLEASE NOTE: this flag will "fake a match" on the engine, to ensure silent
26: # playback so it will not be a "skip" in the sense of moving on to the
27: # next match.
28: ###############################################################################
29: 
30: # This entry will shuffle the SFX ID 1 ( menu cursor ) with the ID 2, 3 or 4.
31: # Everytime the game engine will try to playback 1, one of the entries in the
32: # array will be picked randomly.
33: # -----------------------------------------------------------------------------
34: #[1]
35: #shuffle = [ 2, 3, 4 ]
36: #sequential = [ 2, 3, 4 ]
37: #loop = true
38: #skip = false
</file>

<file path="misc/FFNx.shadowmap.frag">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: $input v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0
17: 
18: #include <bgfx/bgfx_shader.sh>
19: 
20: SAMPLER2D(tex_0, 0);
21: 
22: uniform vec4 VSFlags;
23: uniform vec4 FSAlphaFlags;
24: uniform vec4 FSTexFlags;
25: 
26: #define isTexture VSFlags.w > 0.0
27: // ---
28: #define inAlphaRef FSAlphaFlags.x
29: 
30: #define isAlphaNever abs(FSAlphaFlags.y - 0.0) < 0.00001
31: #define isAlphaLess abs(FSAlphaFlags.y - 1.0) < 0.00001
32: #define isAlphaEqual abs(FSAlphaFlags.y - 2.0) < 0.00001
33: #define isAlphaLEqual abs(FSAlphaFlags.y - 3.0) < 0.00001
34: #define isAlphaGreater abs(FSAlphaFlags.y - 4.0) < 0.00001
35: #define isAlphaNotEqual abs(FSAlphaFlags.y - 5.0) < 0.00001
36: #define isAlphaGEqual abs(FSAlphaFlags.y - 6.0) < 0.00001
37: 
38: #define doAlphaTest FSAlphaFlags.z > 0.0
39: 
40: void main()
41: {
42: 	vec4 color = v_color0;
43: 
44:     if (isTexture)
45:     {
46:         vec4 texture_color = texture2D(tex_0, v_texcoord0.xy);
47: 
48:         if (doAlphaTest)
49:         {
50:             //NEVER
51:             if (isAlphaNever) discard;
52: 
53:             //LESS
54:             if (isAlphaLess)
55:             {
56:                 if (!(texture_color.a < inAlphaRef)) discard;
57:             }
58: 
59:             //EQUAL
60:             if (isAlphaEqual)
61:             {
62:                 if (!(texture_color.a == inAlphaRef)) discard;
63:             }
64: 
65:             //LEQUAL
66:             if (isAlphaLEqual)
67:             {
68:                 if (!(texture_color.a <= inAlphaRef)) discard;
69:             }
70: 
71:             //GREATER
72:             if (isAlphaGreater)
73:             {
74:                 if (!(texture_color.a > inAlphaRef)) discard;
75:             }
76: 
77:             //NOTEQUAL
78:             if (isAlphaNotEqual)
79:             {
80:                 if (!(texture_color.a != inAlphaRef)) discard;
81:             }
82: 
83:             //GEQUAL
84:             if (isAlphaGEqual)
85:             {
86:                 if (!(texture_color.a >= inAlphaRef)) discard;
87:             }
88:         }
89: 
90:         if (texture_color.a == 0.0) discard;
91: 
92:     }
93:     else if(color.a < 0.0 && color.r + color.g + color.b == 0.0)
94: 	{
95:         discard;
96:     }
97: 
98:     gl_FragColor = vec4_splat(0.0);
99: }
</file>

<file path="misc/FFNx.shadowmap.vert">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: $input a_position, a_color0, a_texcoord0, a_normal
17: $output v_color0, v_texcoord0, v_position0, v_shadow0, v_normal0
18: 
19: #include <bgfx/bgfx_shader.sh>
20: 
21: uniform mat4 worldView;
22: uniform mat4 lightViewProjMatrix;
23: 
24: void main()
25: {
26: 	vec4 pos = a_position;
27:     vec4 color = a_color0;
28:     vec2 coords = a_texcoord0;
29: 
30:     color.rgba = color.bgra;
31: 
32:     if (color.a > 0.5) color.a = 0.5;
33:     else if(color.r + color.g + color.b == 0.0)
34:     {
35:         color.a = -1;
36:     }
37: 
38:     pos = mul(mul(lightViewProjMatrix, worldView), vec4(pos.xyz, 1.0));
39: 
40:     gl_Position = pos;
41:     v_color0 = color;
42:     v_texcoord0 = coords;
43: }
</file>

<file path="misc/FFNx.time.toml">
  1: # FFNx Time Cycle config file
  2: 
  3: ### HOW TO: ###################################################################
  4: # Sections may be commented by default with an initial # character.
  5: # Remove the initial # character to set the entire sections block and its flags
  6: # -----------------------------------------------------------------------------
  7: ###############################################################################
  8: 
  9: ### SUPPORTED FLAGS: ##########################################################
 10: # sunrise_time : sunrise time in hours
 11: # morning_time : morning time in hours
 12: # midday_time : midday time in hours
 13: # afternoon_time : afternoon time in hours
 14: # night_time : night time in hours
 15: 
 16: # frames_per_minute : frames per minutes
 17: # (e.g. 5 results in a 8 min cycle, 10 in a 16 min cycle, 15 in 24 min cycle)
 18: 
 19: # morning_color : RGB filter values for the morning color
 20: # midday_color : RGB filter values for the midday color
 21: # afternoon_color : RGB filter values for the afternoon color
 22: # night_color : RGB filter values for the night color
 23: 
 24: # options_address : address for pointer to unused game data to store time related options
 25: # (BIT 0: global time cycle flag, BIT 1: update timer flag, BIT 2: Outdoor field flag)
 26: 
 27: # minutes_address : address for pointer to unused game data to store the minutes
 28: # hours_address : address for pointer to unused game data to store the hours
 29: # days_address : address for pointer to unused game data to store the days
 30: # months_address : address for pointer to unused game data to store the months
 31: 
 32: # month_char_0_address : address to the first character of the month string
 33: # month_char_1_address : address to the second character of the month string
 34: # month_char_2_address : address to the third character of the month string
 35: 
 36: # month_x_char_0 : value of first character of month x (replace x by month index between 0 and 11)
 37: # month_x_char_1 : value of first character of month x (replace x by month index between 0 and 11)
 38: # month_x_char_2 : value of first character of month x (replace x by month index between 0 and 11)
 39: ###############################################################################
 40: 
 41: #sunrise_time = 6.0
 42: #morning_time = 7.0
 43: #midday_time = 15.0
 44: #afternoon_time = 19.0
 45: #night_time = 20.0
 46: 
 47: #frames_per_minute = 5
 48: 
 49: #morning_color = [ 0.75, 0.5, 0.5 ]
 50: #midday_color = [ 1.0, 1.0, 1.0 ]
 51: #afternoon_color = [ 0.9, 0.4, 0.3 ]
 52: #night_color = [ 0.075, 0.075, 0.25 ]
 53: 
 54: #options_address = "DC08E6"
 55: #minutes_address = "DC08E8"
 56: #hours_address = "DC08EB"
 57: #days_address = "DC08EA"
 58: #months_address = "DC08E9"
 59: 
 60: #month_char_0_address = "DC0BFC"
 61: #month_char_1_address = "DC0BFD"
 62: #month_char_2_address = "DC0BFE"
 63: 
 64: #month_0_char_0 = 42
 65: #month_0_char_1 = 65
 66: #month_0_char_2 = 78
 67: 
 68: #month_1_char_0 = 38
 69: #month_1_char_1 = 69
 70: #month_1_char_2 = 66
 71: 
 72: #month_2_char_0 = 45
 73: #month_2_char_1 = 65
 74: #month_2_char_2 = 82
 75: 
 76: #month_3_char_0 = 33
 77: #month_3_char_1 = 65
 78: #month_3_char_2 = 89
 79: 
 80: #month_4_char_0 = 45
 81: #month_4_char_1 = 65
 82: #month_4_char_2 = 89
 83: 
 84: #month_5_char_0 = 42
 85: #month_5_char_1 = 85
 86: #month_5_char_2 = 78
 87: 
 88: #month_6_char_0 = 42
 89: #month_6_char_1 = 85
 90: #month_6_char_2 = 76
 91: 
 92: #month_7_char_0 = 33
 93: #month_7_char_1 = 85
 94: #month_7_char_2 = 71
 95: 
 96: #month_8_char_0 = 51
 97: #month_8_char_1 = 69
 98: #month_8_char_2 = 80
 99: 
100: #month_9_char_0 = 47
101: #month_9_char_1 = 67
102: #month_9_char_2 = 84
103: 
104: #month_10_char_0 = 46
105: #month_10_char_1 = 79
106: #month_10_char_2 = 86
107: 
108: #month_11_char_0 = 36
109: #month_11_char_1 = 69
110: #month_11_char_2 = 67
</file>

<file path="misc/FFNx.toml">
  1: # FFNx config file
  2: 
  3: ###############################################################################
  4: # COMMON OPTIONS FOR BOTH FF7 AND FF8
  5: ###############################################################################
  6: 
  7: #########################
  8: ## DISPLAY
  9: #########################
 10: 
 11: #[DISPLAY INDEX]
 12: # The display where you want the game to run. By default the window will be created on the primary display.
 13: # NOTE: If the value is set lower than 1, it will pick the primary display. If the value is set higher to the maximum number of screens, it will pick the last one.
 14: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 15: display_index = -1
 16: 
 17: #[RENDERING BACKEND]
 18: # Available choices are:
 19: # - 0: Auto ( default, will pick the best rendering backend for your GPU )
 20: # - 1: OpenGL ( works fine on Intel/Nvidia, MAY break on AMD )
 21: # - 2: UNUSED ( used to be Direct3D9, no more supported )
 22: # - 3: Direct3D11 ( works fine under any GPU on Windows )
 23: # - 4: Direct3D12
 24: # - 5: Vulkan
 25: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 26: renderer_backend = 0
 27: 
 28: #[FULLSCREEN]
 29: # If off, it will run in window mode.
 30: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 31: fullscreen = false
 32: 
 33: #[BORDERLESS]
 34: # If off, it will run using the default window style.
 35: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 36: borderless = false
 37: 
 38: #[RESOLUTION]
 39: # Resolution of the game.
 40: # Default (value = 0):
 41: # - Window mode will use 640x480
 42: # - Fullscreen mode will use your desktop resolution
 43: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 44: window_size_x = 0
 45: window_size_y = 0
 46: 
 47: #[INTERNAL RESOLUTION SCALE]
 48: # The scale is in multiples of 640x480
 49: # The scale factor is used to multiply the internally used resolution to a given size before it is scaled to the final screen or window resolution.
 50: # This is required to avoid visual glitches that may happen when the game is not rendered in a 4:3 aspect ratio.
 51: # This is optional for native 4:3 resolutions, but it can enhance visual quality at values higher than the current screen or window resolution ( like Nvidia DSR ).
 52: # A setting of 0 will attempt to find a scale factor that most closely matches the current screen or window resolution.
 53: # Default = 0
 54: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 55: internal_resolution_scale = 0
 56: 
 57: #[ASPECT RATIO]
 58: # Preserve original game aspect ratio of (4:3) by adding black bars on the left and right side (if needed)
 59: # When off the game will be stretched to fit the window's aspect ratio; Be aware the game may look wrong though.
 60: # 0: Preserves original game aspect ratio of (4:3) by adding black bars on the left and right side (if needed)
 61: # 1: Stretched to fit the window's aspect ratio; Be aware the game may look wrong though.
 62: # 2: New 16:9 aspect ratio mode without stretching the image. Fields that lack horizontal scrolling will show black bars on the left and right side.
 63: # 3: New 16:10 aspect ratio which crops the left and right edges of the image so that it can stretch to fill a 16:10 screen.
 64: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 65: aspect_ratio = 0
 66: 
 67: #[UNCROP]
 68: # Uncrops the image to remove the black bars on the top and bottom of the screen.
 69: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 70: enable_uncrop = false
 71: 
 72: #[ENABLE VSYNC]
 73: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 74: enable_vsync = true
 75: 
 76: #[REFRESH RATE]
 77: # Screen refresh rate.
 78: # Default is 0 = use current screen refresh rate
 79: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 80: refresh_rate = 0
 81: 
 82: #[ANTIALIASING]
 83: # Enable antialiasing filtering, this is done in the last pass when downsampling from the current supersampled rendering ( based on internal_resolution_scale logic )
 84: # Available choices are:
 85: # - 0: Disabled ( Default )
 86: # - 2: 2x
 87: # - 4: 4x
 88: # - 8: 8x
 89: # - 16: 16x
 90: # If you set any value that is different than those, it will pick the higher option ( eg. if you pick 6 it will be 8, if you pick 1 it will be 2, and so on ).
 91: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 92: enable_antialiasing = 0
 93: 
 94: #[ANISOTROPIC]
 95: # Enable anisotropic filtering, for high-res textures and overall rendering
 96: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
 97: enable_anisotropic = true
 98: 
 99: #[BILINEAR]
100: # Enable bilinear filtering on 3D textures. For FF7, textures in menu are also filtered.
101: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
102: enable_bilinear = false
103: 
104: #[LIGHTING]
105: # Enable advanced lighting mode with real-time shadows.
106: # NOTICE: Parameters such as light direction and color can be edited on the lighting debug window in the FFNx DevTools.
107: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
108: enable_lighting = false
109: 
110: #[PREFER LIGHTING CPU CALCULATIONS]
111: # Prefer lighting CPU calculations.
112: # If disabled, the driver will try to inherit models normal data first although this process might bring some artifacts visually.
113: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
114: prefer_lighting_cpu_calculations = true
115: 
116: #[GAME LIGHTING]
117: # This flag sets the method used to calculate the original game lighting.
118: # Available choices are:
119: # - 0: Original ( will inherit the default original CPU-based lighting of the PC version )
120: # - 1: Per-Vertex ( will calculate lighting in the GPU per-vertex and closely match the look of the PSX version )
121: # - 2: Per-Pixel ( same as above but calculates lighting per-pixel for a smoother result )
122: # This flag only works with FF7 and will be set automatically to Original mode for FF8.
123: # This option is automatically set to Per-Vertex mode when advanced lighting is enabled.
124: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
125: game_lighting = 1
126: 
127: #[EXTERNAL IBL PATH]
128: # Path for external lighting files.
129: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
130: external_lighting_path = "lighting"
131: 
132: #[DAY-NIGHT TIME CYCLE]
133: # Enable day-night time cycle.
134: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
135: enable_time_cycle = false
136: 
137: #[EXTERNAL DAY NIGHT CYCLE PATH]
138: # Path for external day-night time files.
139: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
140: external_time_cycle_path = "time"
141: 
142: #[EXTERNAL WORLDMAP MESH]
143: # Enable worldmap external meshes.
144: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
145: enable_worldmap_external_mesh = false
146: 
147: #[EXTERNAL MESH PATH]
148: # Path for external mesh files.
149: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
150: external_mesh_path = "mesh"
151: 
152: #[HDR]
153: # This flag will set the brightness level that SDR "white" is rendered at within an HDR monitor.
154: # By default is set to 0, which means to attempt autodetection of the correct value for your monitor via software.
155: # Autodetection may fail on some monitor models.
156: # Autodetection WILL fail on Windows older than Win10 Fall Creators Update (version 1709).
157: # Autodetection WILL fail on WINE (at least as of WINE version 7.22).
158: # If autodetection is attempted and fails, a default value of 200 nits will be used.
159: # NOTE: FFNx.log will tell you if autodetection succeeded, and what value was autodetected.
160: # NOTE: The autodetected (or default) value MIGHT be wrong sometimes; use this flag if brightness does not look correct.
161: # Sane values are likely in the range 100-200 nits.
162: hdr_max_nits = 0
163: 
164: #[COLOR GAMUT]
165: # If enabled, performs a conversion to simulate the color gamut of the 1990s Japanese television sets that FF7 and FF8 were originally designed for.
166: # The resulting colors are generally brighter and more vivid.
167: # This mode is appropriate for:
168: # (1) Vanilla FF7/FF8.
169: # (2) Mod assets that are upscales of the original assets.
170: # (3) Mod assets made from scratch where the modder used the original assets as a color reference without doing a gamut conversion.
171: # This mode is not appropriate for mod assets made from scratch that truly use the sRGB color gamut.
172: # Such assets can be made suitable for this mode using this converter program: https://github.com/ChthonVII/gamutthingy
173: enable_ntscj_gamut_mode = false
174: 
175: #########################
176: # Audio Player Options
177: #########################
178: 
179: #[NUMBER OF CHANNELS]
180: # This flag will set the number of channels you want to use.
181: # You can force a Stereo output ( 2.0 ) on a 7.1 system for example, by setting this flag to 2.
182: # The number MUST always be EVEN ( eg. 2, 4, 6, 8). If you have 5.1 set, then use 6 ( 5+1 ). If you have 7.1 set, then use 8 ( 7+1 ).
183: # NOTE: 0 = Autodetect. It will use the number of channels set in your audio card and/or inherited through audio software enhancements suites.
184: # WARNING: This flag WILL impact the OVERALL external audio layer ( Music, SFX, Voice, Ambient, etc.)!
185: external_audio_number_of_channels = 2
186: 
187: #[SAMPLE RATE]
188: # This flag will set the sample rate you want to use.
189: # The number MUST be one of the known sample rates values ( 44100, 48000, etc. )
190: # NOTE: 0 = Autodetect. It will use the sample rate set in your audio card and/or inherited through audio software enhancements suites.
191: # WARNING: This flag WILL impact the OVERALL external audio layer ( Music, SFX, Voice, Ambient, etc.)!
192: external_audio_sample_rate = 44100
193: 
194: #[USE EXTERNAL SFX]
195: # This flag will enable/disable the support of an enhanced audio layer to reproduce sounds in-game.
196: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
197: use_external_sfx = false
198: 
199: #[EXTERNAL SFX VOLUME]
200: # This setting will allow you to configure the volume of the SFX layer.
201: # Possible values: 0..100
202: # If -1, the engine will try to detect the volume by other meanings:
203: # - FF7 1998: It will attempt to use the original game registry paths
204: # - FF7 Steam: It will attempt to read it from the ff7sound.cfg file
205: # - FF8 2000: It will be set to 100% by default
206: # - FF8 Steam: It will be set to 100% by default
207: external_sfx_volume = -1
208: 
209: #[EXTERNAL SFX PATH]
210: # Path of the external sound files
211: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
212: external_sfx_path = "sfx"
213: 
214: #[EXTERNAL SFX EXTENSION]
215: # The type of file to search for. By default is ogg.
216: # You can use a list to specify multiple extensions, ordered by priority.
217: # Example: ["ogg", "flac"]
218: # Supported extensions:
219: # - https://github.com/losnoco/vgmstream#supported-file-types
220: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
221: external_sfx_ext = "ogg"
222: 
223: #[EXTERNAL SFX ALWAYS CENTERED]
224: # This flag will force the external SFX sounds to be played always on the center position instead of inheriting the left/center/right original logic.
225: external_sfx_always_centered = false
226: 
227: #[USE EXTERNAL MUSIC]
228: # This flag will enable/disable the support of an enhanced audio layer to reproduce music in-game.
229: # If you leave out the default configuration FFNx will autodetect your environment and will set it to the best available option.
230: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
231: use_external_music = false
232: 
233: #[EXTERNAL MUSIC VOLUME]
234: # This setting will allow you to configure the volume of the Music layer.
235: # Possible values: 0..100
236: # If -1, the engine will try to detect the volume by other meanings:
237: # - FF7 1998: It will attempt to use the original game registry paths
238: # - FF7 Steam: It will attempt to read it from the ff7sound.cfg file
239: # - FF8 2000: It will be set to 100% by default
240: # - FF8 Steam: It will be set to 100% by default
241: external_music_volume = -1
242: 
243: #[EXTERNAL MUSIC RESUME]
244: # This flag will enable the support for music resume on known areas of the game ( for eg. World-Map ).
245: # If you enable this flag, instead of starting the OST for a known area from the beginning everytime, it will resume where you left it off the last time you visited it.
246: external_music_resume = true
247: 
248: #[EXTERNAL MUSIC SYNCHRONIZATION]
249: # This flag will enable the support for music synchronization.
250: # If you enable this flag, music mods can use the "sync" feature to start a music at the time offset of the previous playing music.
251: external_music_sync = false
252: 
253: #[EXTERNAL MUSIC PATH]
254: # Path of the external music files
255: # Will try to load from this path before using the default for your Version of the game
256: # Defaults:
257: # - FF7 1998: music/vgmstream ( 7h-era compatibility )
258: # - FF7 eStore: data/music_ogg
259: # - FF7 Steam: data/music_ogg
260: # - FF8 2000/Steam: data/music/dmusic/ogg
261: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
262: external_music_path = ""
263: 
264: #[EXTERNAL MUSIC EXTENSION]
265: # The type of file to search for. By default is ogg.
266: # You can use a list to specify multiple extensions, ordered by priority.
267: # Example: ["minipsf", "ogg"]
268: # Supported extensions:
269: # - https://github.com/losnoco/vgmstream#supported-file-types
270: # - psf, psf2, minipsf, minipsf2 (PSF and PSF2) if you provide the Highly Experimental BIOS
271: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
272: external_music_ext = "ogg"
273: 
274: #[EXTERNAL MUSIC HIGHLY EXPERIMENTAL BIOS]
275: # This flag will enable support to PSF and PSF2 formats.
276: # You need to provide a BIOS generated for the Highly Experimental project (hebios.bin).
277: # To find one compiled BIOS: https://git.lopez-snowhill.net/chris/foo_psf
278: # To generate one: https://git.lopez-snowhill.net/chris/highly_experimental
279: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
280: he_bios_path = ""
281: 
282: #[EXTERNAL VOICE PATH]
283: # Path of the external voice files
284: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
285: external_voice_path = "voice"
286: 
287: #[EXTERNAL VOICE EXTENSION]
288: # The type of file to search for. By default is ogg.
289: # You can use a list to specify multiple extensions, ordered by priority.
290: # Example: ["ogg", "flac"]
291: # Supported extensions:
292: # - https://github.com/losnoco/vgmstream#supported-file-types
293: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
294: external_voice_ext = "ogg"
295: 
296: #[EXTERNAL VOICE VOLUME]
297: # This setting will allow you to configure the volume of the Voice layer.
298: # Possible values: 0..100
299: # If -1, the engine will try to detect the volume by other meanings:
300: # - FF7 1998: It will attempt to use the FFNx registry paths ( also used by 7th Heaven )
301: # - FF7 Steam: It will be set to 100% by default
302: # - FF8 2000: It will be set to 100% by default
303: # - FF8 Steam: It will be set to 100% by default
304: external_voice_volume = -1
305: 
306: #[ENABLE VOICE MUSIC FADE]
307: # This flag will enable the music volume fade out and fade in, when a voice acting is being played back.
308: # Please note this flag will take effect ONLY when "use_external_music" is enabled.
309: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
310: enable_voice_music_fade = false
311: 
312: #[EXTERNAL VOICE MUSIC FADE VOLUME]
313: # This flag will set to how much the volume will be lowered down when a voice acting is going to be played back. When the voice file will be finished, the music volume will be then restored to its previous value.
314: # Range: 0-100 ( Min = 0, Max = 100)
315: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
316: external_voice_music_fade_volume = 25
317: 
318: #[ENABLE VOICE AUTO TEXT]
319: # This will allow you to enable or disable the Voice Auto-Text feature. When enabled the game will automatically close the dialogue as soon as the voice acting is finished for that line.
320: enable_voice_auto_text = true
321: 
322: #[EXTERNAL AMBIENT PATH]
323: # Path of the external ambient files
324: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
325: external_ambient_path = "ambient"
326: 
327: #[EXTERNAL AMBIENT EXTENSION]
328: # The type of file to search for. By default is ogg.
329: # You can use a list to specify multiple extensions, ordered by priority.
330: # Example: ["ogg", "flac"]
331: # Supported extensions:
332: # - https://github.com/losnoco/vgmstream#supported-file-types
333: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
334: external_ambient_ext = "ogg"
335: 
336: #[EXTERNAL AMBIENT VOLUME]
337: # This setting will allow you to configure the volume of the Ambient layer.
338: # Possible values: 0..100
339: # If -1, the engine will try to detect the volume by other meanings:
340: # - FF7 1998: It will attempt to use the FFNx registry paths ( also used by 7th Heaven )
341: # - FF7 Steam: It will be set to 100% by default
342: # - FF8 2000: It will be set to 100% by default
343: # - FF8 Steam: It will be set to 100% by default
344: external_ambient_volume = -1
345: 
346: ###########################
347: # Video Player Options
348: ###########################
349: 
350: #[ENABLE FFMPEG VIDEOS]
351: # This flag will enable/disable the support of FFMpeg layer to reproduce movies in-game.
352: # Default Value (-1) sets the flag, depending on the game version.
353: # - FF7 1998 - true
354: # - FF7/FF8 Steam - true
355: # - FF8 2000 - false
356: # It is suggested to keep the default behavior unless you really know what are you doing.
357: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
358: enable_ffmpeg_videos = -1
359: 
360: #[FFMPEG VIDEO VOLUME]
361: # This setting will allow you to configure the volume of the FFMpeg Video layer.
362: # Possible values: 0..100
363: # If -1, the engine will try to detect the volume by other meanings:
364: # - FF7 1998: It will attempt to use the FFNx registry paths ( also used by 7th Heaven )
365: # - FF7 Steam: It will be set to 100% by default
366: # - FF8 2000: NOT SUPPORTED!
367: # - FF8 Steam: It will be set to 100% by default
368: ffmpeg_video_volume = -1
369: 
370: #[FFMPEG VIDEO FILE EXTENSION]
371: # The type of file that the ffmpeg layer will search for. Default is avi.
372: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
373: ffmpeg_video_ext = "avi"
374: 
375: #[EXTERNAL MOVIE AUDIO FILE EXTENSION]
376: # The type of audio file to search for. Default is ogg.
377: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
378: external_movie_audio_ext = "ogg"
379: 
380: ###########################
381: # Controller Options
382: ###########################
383: 
384: #[ANALOGUE CONTROLS]
385: # FF7: This flag will enable analogue joystick input for controlling the player in fields and the camera in battles.
386: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
387: enable_analogue_controls = false
388: 
389: #[INVERT VERTICAL CAMERA CONTROLS]
390: # FF7: This flag will enable inverted camera vertical movement when controlling the camera in battles.
391: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
392: enable_inverted_vertical_camera_controls = false
393: 
394: #[INVERT HORIZONTAL CAMERA CONTROLS]
395: # FF7: This flag will enable inverted camera horizontal movement when controlling the camera in battles.
396: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
397: enable_inverted_horizontal_camera_controls = false
398: 
399: #[LEFT ANALOG STICK DEADZONE]
400: # FF7: Sets the deadzone for the left analog stick. Values are from 0 to 1.
401: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
402: left_analog_stick_deadzone = 0.1
403: 
404: #[RIGHT ANALOG STICK DEADZONE]
405: # FF7: Sets the deadzone for the right analog stick. Values are from 0 to 1.
406: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
407: right_analog_stick_deadzone = 0.1
408: 
409: #[LEFT ANALOG TRIGGER DEADZONE]
410: # FF7: Sets the deadzone for the left analog trigger. Values are from 0 to 1.
411: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
412: left_analog_trigger_deadzone = 0.1
413: 
414: #[RIGHT ANALOG TRIGGER DEADZONE]
415: # FF7: Sets the deadzone for the right analog trigger. Values are from 0 to 1.
416: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
417: right_analog_trigger_deadzone = 0.1
418: 
419: #[AUTO RUN]
420: # FF7: This flag enables mode to walk or run depending on how much the left analog stick is tilt.
421: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
422: enable_auto_run = false
423: 
424: #[EXTERNAL VIBRATE PATH]
425: # Path of the external vibrate files
426: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
427: external_vibrate_path = "vibrate"
428: 
429: ###############################
430: # MUST SET FOR VERSIONS BELOW
431: # FF7 2012   FF7 STEAM
432: # FF8 2013   FF8 STEAM
433: ###############################
434: # The folder name in your game Documents path ( for eg. for FF7 is "C:\Users\JohnDoe\Documents\Square Enix\FINAL FANTASY VII Steam\user_XXXXXXX")
435: # Use this only if you have MORE THAN ONE user_* directories. If not, just leave this commented as the driver will autodetect the directory.
436: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
437: steam_game_userdata = ""
438: 
439: ###########################
440: # Steam Achievement Options
441: ###########################
442: 
443: #[STEAM ACHIEVEMENTS EXTENSION]
444: # This flag will enable steam overlay and steam achievements (Steam MUST be running and you must be online and
445: # connected to the Internet to unlock achievement).
446: # Note: incompatible with mods that change dramatically the gameplay (for example, New Threat mod), use it at your own risk
447: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
448: enable_steam_achievements = false
449: 
450: ########################
451: ## MODDER OPTIONS
452: ########################
453: 
454: #[TEXTURE PATH]
455: # Mod directory where textures will be loaded from
456: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
457: mod_path = "mods/Textures"
458: 
459: # Mod extension
460: # You can change the extension list, ordered by priority. DO NOT add new extensions, driver will become unstable.
461: # Default: ["dds", "png"]
462: # Additionally available supported extensions: [ "psd", "tga", "exr" ]
463: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
464: mod_ext = ["dds", "png"]
465: 
466: # Show every failed attempt at loading a .png or .dds texture
467: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
468: show_missing_textures = false
469: 
470: # Dump internal textures to PNG files in the mod_path
471: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
472: save_textures = false
473: 
474: # Dump internal legacy textures to PNG files in the mod_path
475: # FF7: There is currently no legacy format
476: # FF8: Field backgrounds will be saved in Tonberry's format, instead of FFNx one
477: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
478: save_textures_legacy = false
479: 
480: # Dump identified data from EXE to "<direct_mode_path>/exe/"
481: # List of files dumped here: https://github.com/julianxhokaxhiu/FFNx/tree/master/docs/mods/exe_data.md
482: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
483: save_exe_data = false
484: 
485: # This path is where the Hext patching layer will look for txt files.
486: # The path will ALWAYS have appended:
487: # 1. The game name ( if FF7 it will be "ff7/", if FF8 will be "ff8/")
488: # 2. The game language ( for eg. if ff7_en it will be "en" )
489: # The resulting path will then be "<hext_patching_path>/ff7/en", if you run for eg. FF7 English
490: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
491: hext_patching_path = "hext"
492: 
493: # This is the path where files where be read directly, instead then reading them inside the LGP/FS archives.
494: # For example: if FF7 is looking for aaab.rsd in char.lgp, this option will make it open direct/char/aaab.rsd first,
495: # If this file doesn't exist it will look for the original in the LGP archive
496: # Another example: if FF8 is looking for c:/data/en/FIELD/mapdata/bc/bccent12/bccent12.msd in field.fs,
497: # this option will make it open direct/FIELD/mapdata/bc/bccent12/bccent12.msd if it exists
498: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
499: direct_mode_path = "direct"
500: 
501: # This path will define where the driver will look first, allowing you to override core game files, if needed
502: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
503: override_path = "override"
504: 
505: # This path will define where the driver will look for mod_path textures first, allowing you to override mod_path textures, if needed-
506: # This flag is empty by default to ensure performance is not dropped.
507: override_mod_path = ""
508: 
509: #[SPEEDHACK]
510: # Set the step when increasing the speedhack speed
511: #~~~~~~~~~~~~~~~~~~~~~~~~~~
512: speedhack_step = 0.5
513: 
514: # Set the limit of the speedhack multiplier
515: #~~~~~~~~~~~~~~~~~~~~~~~~~~
516: speedhack_max = 8.0
517: speedhack_min = 1.0
518: 
519: #[EXPERIMENTAL]
520: # Enable support for animated textures.
521: # WARNING: This flag MAY degrade the gameplay performance. Enable at your own risk.
522: #~~~~~~~~~~~~~~~~~~~~~~~~~~
523: enable_animated_textures = false
524: 
525: # Disable animated textures on the fields listed below.
526: # This field can be a single field name, or an array of field names.
527: # NOTE: This is an actual BLACKLIST and it will have an impact ONLY when 'enable_animated_textures = true'
528: disable_animated_textures_on_field = ""
529: 
530: ##########################
531: # DEBUGGING OPTIONS
532: # These options are mostly useful for developers or people reporting crashes.
533: # Please do enable them only when required.
534: ##########################
535: 
536: # Enable FFNx DevTools
537: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
538: enable_devtools = false
539: 
540: # Set hotkey to toggle the DevTools window.
541: # This is specified by a virtual-key code hexadecimal value, see: https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
542: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
543: # Default: 0x7B ( VK_F12 )
544: devtools_hotkey = 0x7B
545: 
546: # Display the verion of FFNx in upper right corner ( when fullscreen ) or in the title bar ( when windowed )
547: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
548: show_version = true
549: 
550: # Display frames per second counter in upper right corner ( when fullscreen ) or in the title bar ( when windowed )
551: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
552: show_fps = false
553: 
554: # Display Rendering backend in upper right corner ( when fullscreen ) or in the title bar ( when windowed )
555: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
556: show_renderer_backend = true
557: 
558: # Display some real-time debug information
559: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
560: show_stats = false
561: 
562: # Enable logging
563: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
564: show_applog = true
565: 
566: # Dump in the logs more verbose error messages coming directly from the engine
567: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
568: more_debug = false
569: 
570: # Show on screen error messages ( only on fullscreen )
571: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
572: show_error_popup = false
573: 
574: # Enable this flag if you want to see more verbose output from the backend renderer.
575: # Usually useful for debug pruposes. Do not enable otherwise.
576: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
577: renderer_debug = false
578: 
579: # Enable this flag if you want to go into debug mode for steam achievements (open popup window for achievements).
580: # Useful for debug purposes. Do not enable otherwise.
581: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
582: steam_achievements_debug_mode = false
583: 
584: # Creates a full crashdump file if the game crashes. Useful to be analyzed with WinDbg when reporting issues.
585: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
586: create_crash_dump = false
587: 
588: # Various flags which will help in further debugging the game engine logics.
589: # Some flags may not generate any output depending on the game you play.
590: 
591: # trace_all - Dump in the logs whatever APIs is being called from the Engine in FFNx. Overrides all the others below.
592: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
593: trace_all = false
594: 
595: # trace_renderer - Dump in the logs only APIs that has to do with the rendering engine
596: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
597: trace_renderer = false
598: 
599: # trace_movies - Dump in the logs only APIs that has to do with movie playback
600: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
601: trace_movies = false
602: 
603: # trace_music - Dump in the logs only APIs that has to do with music playback
604: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
605: trace_music = false
606: 
607: # trace_sfx - Dump in the logs only APIs that has to do with sfx playback
608: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
609: trace_sfx = false
610: 
611: # trace_fake_dx - Dump in the logs only APIs that has to do with directdraw emulation
612: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
613: trace_fake_dx = false
614: 
615: # trace_direct - Dump in the logs only APIs that has to do with Archive loading
616: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
617: trace_direct = false
618: 
619: # trace_files - Dump in the logs only APIs that has to do with filesystem operations
620: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
621: trace_files = false
622: 
623: # trace_loaders - Dump in the logs only APIs that has to do with internal textures overrides
624: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
625: trace_loaders = false
626: 
627: # trace_vram - Dump in the logs only APIs that has to do with FF8 VRAM
628: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
629: trace_vram = false
630: 
631: # trace_opcodes - Dump in the logs only APIs that has to do with field opcodes
632: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
633: trace_opcodes = false
634: 
635: # trace_voice - Dump in the logs only APIs that has to do with voice playback
636: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
637: trace_voice = false
638: 
639: # trace_ambient - Dump in the logs only APIs that has to do with ambient playback
640: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
641: trace_ambient = false
642: 
643: # trace_gamepad - Dump in the logs only APIs that has to do with gamepad
644: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
645: trace_gamepad = false
646: 
647: # trace_achievement - Dump in the logs only APIs that has to do with steam achievements
648: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
649: trace_achievement = false
650: 
651: # trace_battle_animation - Dump in the logs only APIs that has to do with battle animation
652: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
653: trace_battle_animation = false
654: 
655: # trace_battle_text - Dump in the logs only APIs that has to do with battle text (dialogue, ...)
656: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
657: trace_battle_text = false
658: 
659: # vertex_log - Dump in the logs current engine vertex data being passed to the GPU for drawing
660: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
661: vertex_log = false
662: 
663: # uniform_log - Dump in the logs current engine uniform data being passed to the GPU shaders
664: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
665: uniform_log = false
666: 
667: ###############################################################################
668: # OPTIONS ONLY FOR FF7
669: ###############################################################################
670: 
671: ## ENHANCEMENTS
672: 
673: # FPS Limiter
674: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
675: # This flag will overwrite the internal FPS limiter of the game.
676: # Available choices are:
677: # - 0: Original ( will inherit the default vanilla game behavior, some bugs may appear )
678: # - 1: Default ( an hybrid mode that fixes most of the known game limiter bugs while preserving the original FPS )
679: # - 2: 30 FPS ( it will bump Battle mode to 30 FPS, everything else will run in vanilla mode )
680: # - 3: 60 FPS ( all the game will run in 60 FPS, use this option at your own risk )
681: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
682: ff7_fps_limiter = 1
683: 
684: # Allow the sfx footstep sound to be played everytime you move in fields
685: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
686: ff7_footsteps = false
687: 
688: # Include armor in magic defense calculation
689: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
690: mdef_fix = true
691: 
692: # Play opening music via external music, the opening movie needs to be modified to not play the music
693: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
694: ff7_external_opening_music = false
695: 
696: # FIELD mode vertical center
697: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
698: # This flag will center vertically the game when in FIELD mode
699: # NOTE: Previously this was done via a hext file
700: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
701: ff7_field_center = true
702: 
703: ## MODDER OPTIONS - These options are mostly useful to modders and should not be enabled during normal play.
704: 
705: # This is the path where your savefiles will be read.
706: # Notice that the path will be relative to your FF7 Game install directory, where usually the "save" directory is stored.
707: # PLEASE NOTE: THIS IS A VALID OPTION ONLY FOR FF7 1998/eStore edition. It will NOT work on the Steam edition!
708: save_path = "save"
709: 
710: # FIELD advanced blinking
711: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
712: # This flag will enable advanced blinking for Field models.
713: # NOTE: Models have to be patched to support this feature. Vanilla models work out of the box.
714: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
715: ff7_advanced_blinking = false
716: 
717: ###############################################################################
718: # OPTIONS ONLY FOR FF8
719: ###############################################################################
720: 
721: ## ENHANCEMENTS
722: 
723: # Load higher resolution textures on worldmap
724: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
725: ff8_worldmap_internal_highres_textures = true
726: 
727: # Attempt to fix texturing holes by restoring full precision from the game data
728: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
729: ff8_fix_uv_coords_precision = true
730: 
731: # Always use original filenames when looking for external music files.
732: # Example: `005s-battle.ogg` instead of `battle.ogg`.
733: # Use this option if you want to use OGG files from Remastered Edition directly in external music
734: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
735: ff8_external_music_force_original_filenames = false
736: 
737: # Use icon textures for gamepad buttons instead of "B1", "B2", etc...
738: # By default the PS1 icons are used from the game data.
739: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
740: ff8_use_gamepad_icons = false
741: 
742: # Allows the windows to not be focused but still get controller inputs
743: # By default this is false
744: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
745: ff8_always_capture_input = false
746: 
747: # FPS Limiter
748: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
749: # This flag will overwrite the internal FPS limiter of the game.
750: # Available choices are:
751: # - 0: Original ( will inherit the default vanilla game behavior, some bugs may appear )
752: # - 1: Default ( an hybrid mode that fixes most of the known game limiter bugs while preserving the original FPS )
753: # - 2: 30 FPS ( it will bump Battle mode to 30 FPS, everything else will run in vanilla mode )
754: # - 3: 60 FPS ( all the game will run in 60 FPS, use this option at your own risk )
755: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
756: ff8_fps_limiter = 1
757: 
758: ## GAME INSTALLATION OPTIONS
759: 
760: #[APP PATH]
761: # Overrides the app path if set, can be relative
762: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
763: app_path = ""
764: 
765: #[DATA DRIVE]
766: # Overrides the data drive to read disks if set. Ignored in the Steam edition.
767: # Example: "F:"
768: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
769: data_drive = ""
770: 
771: ## DEBUGGING OPTIONS - These options are mostly useful for developers or people reporting crashes. Please do enable them only when required.
772: 
773: # Show the PSX SSIGPU VRAM window
774: #~~~~~~~~~~~~~~~~~~~~~~~~~~~
775: ff8_ssigpu_debug = false
</file>

<file path="misc/FFNx.varying.flat.def.sc">
 1: flat vec4 v_color0    : COLOR0    = vec4(0.0, 0.0, 0.0, 0.0);
 2: centroid vec2 v_texcoord0 : TEXCOORD0 = vec2(0.0, 0.0);
 3: vec4 v_position0 : TEXCOORD4 = vec4(0.0, 0.0, 0.0, 0.0);
 4: vec4 v_shadow0 : TEXCOORD5 = vec4(0.0, 0.0, 0.0, 0.0);
 5: vec3 v_normal0 : NORMAL = vec3(0.0, 0.0, 0.0);
 6: 
 7: vec4 a_position  : POSITION;
 8: vec4 a_color0    : COLOR0;
 9: vec2 a_texcoord0 : TEXCOORD0;
10: vec3 a_normal : NORMAL;
</file>

<file path="misc/FFNx.varying.smooth.def.sc">
 1: smooth vec4 v_color0    : COLOR0    = vec4(0.0, 0.0, 0.0, 0.0);
 2: centroid vec2 v_texcoord0 : TEXCOORD0 = vec2(0.0, 0.0);
 3: vec4 v_position0 : TEXCOORD4 = vec4(0.0, 0.0, 0.0, 0.0);
 4: vec4 v_shadow0 : TEXCOORD5 = vec4(0.0, 0.0, 0.0, 0.0);
 5: vec3 v_normal0 : NORMAL = vec3(0.0, 0.0, 0.0);
 6: 
 7: vec4 a_position  : POSITION;
 8: vec4 a_color0    : COLOR0;
 9: vec2 a_texcoord0 : TEXCOORD0;
10: vec3 a_normal : NORMAL;
</file>

<file path="misc/FFNx.vert">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: $input a_position, a_color0, a_texcoord0, a_normal
 23: $output v_color0, v_texcoord0, v_position0, v_normal0
 24: 
 25: #include <bgfx/bgfx_shader.sh>
 26: #include "FFNx.common.sh"
 27: 
 28: uniform mat4 d3dViewport;
 29: uniform mat4 d3dProjection;
 30: uniform mat4 worldView;
 31: uniform mat4 normalMatrix;
 32: uniform mat4 invViewMatrix;
 33: uniform vec4 gameLightingFlags;
 34: uniform vec4 gameGlobalLightColor;
 35: uniform vec4 gameLightColor1;
 36: uniform vec4 gameLightColor2;
 37: uniform vec4 gameLightColor3;
 38: uniform vec4 gameLightDir1;
 39: uniform vec4 gameLightDir2;
 40: uniform vec4 gameLightDir3;
 41: uniform vec4 gameScriptedLightColor;
 42: 
 43: uniform vec4 VSFlags;
 44: uniform vec4 WMFlags;
 45: 
 46: #define isTLVertex VSFlags.x > 0.0
 47: #define blendMode VSFlags.y
 48: #define isFBTexture VSFlags.z > 0.0
 49: 
 50: #define isApplySphericalWorld WMFlags.x > 0.0
 51: #define sphericaWorldRadiusScale  WMFlags.x
 52: 
 53: #define gameLightingMode gameLightingFlags.x
 54: #define GAME_LIGHTING_PER_VERTEX 1
 55: 
 56: void main()
 57: {
 58:     vec4 pos = a_position;
 59:     vec4 color = a_color0;
 60:     vec2 coords = a_texcoord0;
 61: 
 62:     color.rgb = color.bgr;
 63: 
 64:     if (isTLVertex)
 65:     {
 66:         pos.w = 1.0 / pos.w;
 67:         pos.xyz *= pos.w;
 68:         pos = mul(u_proj, pos);
 69:     }
 70:     else
 71:     {
 72:         v_position0 = mul(worldView, vec4(pos.xyz, 1.0));
 73: 
 74:         if (isApplySphericalWorld) pos.xyz = ApplySphericalWorld(v_position0.xyz, sphericaWorldRadiusScale);
 75:         else pos = v_position0;
 76: 
 77:         pos = mul(mul(d3dViewport, d3dProjection), vec4(pos.xyz, 1.0));
 78:         v_normal0 = mul(normalMatrix, vec4(a_normal, 0.0)).xyz;
 79: 
 80:         // In this default shader, lighting is applied in gamma space so that it does better match the original lighting
 81:         if (gameLightingMode == GAME_LIGHTING_PER_VERTEX)
 82:         {
 83:             vec3 worldNormal = mul(invViewMatrix, vec4(v_normal0, 0)).xyz;
 84:             float dotLight1 = saturate(dot(worldNormal, gameLightDir1.xyz));
 85:             float dotLight2 = saturate(dot(worldNormal, gameLightDir2.xyz));
 86:             float dotLight3 = saturate(dot(worldNormal, gameLightDir3.xyz));
 87:             vec3 light1Ambient = gameLightColor1.rgb * dotLight1 * dotLight1;
 88:             vec3 light2Ambient = gameLightColor2.rgb * dotLight2 * dotLight2;
 89:             vec3 light3Ambient = gameLightColor3.rgb * dotLight3 * dotLight3;
 90:             vec3 lightAmbient = gameScriptedLightColor.rgb * (gameGlobalLightColor.rgb + light1Ambient + light2Ambient + light3Ambient);
 91:             color.rgb *= gameGlobalLightColor.w * lightAmbient;
 92:         }
 93: 
 94:         if (color.a > 0.5) color.a = 0.5;
 95:     }
 96: 
 97:     if (blendMode == 4.0) color.a = 1.0;
 98:     else if (blendMode == 3.0) color.a = 0.25;
 99: 
100: #if BGFX_SHADER_LANGUAGE_HLSL
101: #else
102:     #if BGFX_SHADER_LANGUAGE_SPIRV
103:     #else
104:         if (isFBTexture) coords.y = 1.0 - coords.y;
105:     #endif
106: #endif
107: 
108:     gl_Position = pos;
109:     v_color0 = color;
110:     v_texcoord0 = coords;
111: }
</file>

<file path="misc/FFNx.vibrate.ff8.battle.toml">
  1: # FFNx Vibration Engine config file - FF8 Battle module
  2: 
  3: ### HOW TO: ###################################################################
  4: # Sections may be commented by default with an initial # character.
  5: # Remove the initial # character to set the entire sections block and its flags
  6: # -----------------------------------------------------------------------------
  7: # Syntax:
  8: # [ID]
  9: # flag = value
 10: # another_flag = value
 11: ###############################################################################
 12: 
 13: ### SUPPORTED FLAGS: ##########################################################
 14: # left_motor: An array of arrays, where each tuple MUST contain the relative
 15: # values. This vibration values will impact the LEFT motor of the gamepad.
 16: # The first value of the tuple is the motor force, the second value is the
 17: # number of frames to repeat this force.
 18: # -----------------------------------------------------------------------------
 19: # right_motor: An array of arrays, where each tuple MUST contain the relative
 20: # values. This vibration values will impact the RIGHT motor of the gamepad.
 21: # The first value of the tuple is the motor force, the second value is the
 22: # number of frames to repeat this force.
 23: ###############################################################################
 24: 
 25: # These entries will define LEFT and RIGHT motor forces for a set of
 26: # scenes setX.
 27: # setX: A scene ID where X is set between 0 to 63.
 28: # -----------------------------------------------------------------------------
 29: 
 30: [set2]
 31: left_motor = [
 32: 	[0x40, 0],
 33: 	[0x39, 1]
 34: ]
 35: right_motor = [
 36: 	[0x40, 1],
 37: 	[0x40, 0]
 38: ]
 39: 
 40: [set3]
 41: left_motor = [
 42: 	[0x78, 0],
 43: 	[0x78, 3],
 44: 	[0x50, 0],
 45: 	[0x01, 0]
 46: ]
 47: right_motor = [
 48: 	[0x60, 0],
 49: 	[0x6B, 0],
 50: 	[0x6B, 2]
 51: ]
 52: 
 53: [set4]
 54: left_motor = [
 55: 	[0x2F, 14],
 56: 	[0x0A, 14],
 57: 	[0x1E, 13],
 58: 	[0x0C, 15],
 59: 	[0x1E, 14],
 60: 	[0x0C, 14],
 61: 	[0x1E, 14],
 62: 	[0x0C, 14],
 63: 	[0x1E, 29],
 64: 	[0x0D, 14],
 65: 	[0x1F, 12],
 66: 	[0x10, 10],
 67: 	[0x20, 46],
 68: 	[0x0C, 6],
 69: 	[0x40, 2],
 70: 	[0x40, 12],
 71: 	[0x10, 0],
 72: 	[0x37, 16],
 73: 	[0x20, 0],
 74: 	[0x40, 14],
 75: 	[0x28, 7],
 76: 	[0x4A, 12],
 77: 	[0x51, 7],
 78: 	[0x2F, 9],
 79: 	[0x18, 31],
 80: 	[0x00, 22],
 81: 	[0x41, 5],
 82: 	[0x10, 24],
 83: 	[0x48, 9],
 84: 	[0x23, 23],
 85: 	[0x55, 6],
 86: 	[0x2E, 19],
 87: 	[0x63, 15],
 88: 	[0x5A, 18],
 89: 	[0x42, 15],
 90: 	[0x1C, 27]
 91: ]
 92: right_motor = [
 93: ]
 94: 
 95: [set7]
 96: left_motor = [
 97: 	[0x00, 14],
 98: 	[0x00, 0],
 99: 	[0x38, 1],
100: 	[0x38, 1],
101: 	[0x00, 1],
102: 	[0x00, 2],
103: 	[0x38, 1],
104: 	[0x38, 4],
105: 	[0x11, 5],
106: 	[0x00, 0],
107: 	[0x40, 0],
108: 	[0x40, 0],
109: 	[0x00, 1],
110: 	[0x00, 0],
111: 	[0x40, 1],
112: 	[0x40, 7],
113: 	[0x00, 31],
114: 	[0x00, 4],
115: 	[0x45, 1],
116: 	[0x3C, 3],
117: 	[0x45, 1],
118: 	[0x40, 11],
119: 	[0x29, 8],
120: 	[0x08, 3]
121: ]
122: right_motor = [
123: ]
124: 
125: [set11]
126: left_motor = [
127: 	[0x20, 4],
128: 	[0x3F, 24],
129: 	[0x20, 0],
130: 	[0x00, 23],
131: 	[0x3C, 4],
132: 	[0x28, 0]
133: ]
134: right_motor = [
135: ]
</file>

<file path="misc/FFNx.vibrate.ff8.field.toml">
  1: # FFNx Vibration Engine config file - FF8 Field module
  2: 
  3: ### HOW TO: ###################################################################
  4: # Sections may be commented by default with an initial # character.
  5: # Remove the initial # character to set the entire sections block and its flags
  6: # -----------------------------------------------------------------------------
  7: # Syntax:
  8: # [ID]
  9: # flag = value
 10: # another_flag = value
 11: ###############################################################################
 12: 
 13: ### SUPPORTED FLAGS: ##########################################################
 14: # left_motor: An array of arrays, where each tuple MUST contain the relative
 15: # values. This vibration values will impact the LEFT motor of the gamepad.
 16: # The first value of the tuple is the motor force, the second value is the
 17: # number of frames to repeat this force.
 18: # -----------------------------------------------------------------------------
 19: # right_motor: An array of arrays, where each tuple MUST contain the relative
 20: # values. This vibration values will impact the RIGHT motor of the gamepad.
 21: # The first value of the tuple is the motor force, the second value is the
 22: # number of frames to repeat this force.
 23: ###############################################################################
 24: 
 25: # These entries will define LEFT and RIGHT motor forces for a set of
 26: # scenes setX.
 27: # setX: A scene ID where X is set between 0 to 63.
 28: # -----------------------------------------------------------------------------
 29: 
 30: [set0]
 31: left_motor = [
 32: 	[0x60, 0],
 33: 	[0x60, 0],
 34: 	[0x5C, 3],
 35: 	[0x42, 6],
 36: 	[0x18, 17]
 37: ]
 38: right_motor = [
 39: 	[0x00, 29]
 40: ]
 41: 
 42: [set1]
 43: left_motor = [
 44: 	[0x50, 0],
 45: 	[0x50, 12]
 46: ]
 47: right_motor = [
 48: 	[0x40, 0],
 49: 	[0x40, 0],
 50: 	[0x00, 11]
 51: ]
 52: 
 53: [set2]
 54: left_motor = [
 55: 	[0x41, 16]
 56: ]
 57: right_motor = [
 58: 	[0x00, 10]
 59: ]
 60: 
 61: [set3]
 62: left_motor = [
 63: 	[0x60, 0],
 64: 	[0x60, 1],
 65: 	[0x41, 0],
 66: 	[0x50, 0],
 67: 	[0x50, 39],
 68: 	[0x01, 0]
 69: ]
 70: right_motor = [
 71: 	[0x00, 44]
 72: ]
 73: 
 74: [set4]
 75: left_motor = [
 76: 	[0x59, 0],
 77: 	[0x59, 0],
 78: 	[0x45, 0],
 79: 	[0x41, 0],
 80: 	[0x50, 0],
 81: 	[0x50, 14]
 82: ]
 83: right_motor = [
 84: 	[0x00, 19]
 85: ]
 86: 
 87: [set5]
 88: left_motor = [
 89: 	[0x5F, 0],
 90: 	[0x5F, 0],
 91: 	[0x40, 0],
 92: 	[0x57, 2],
 93: 	[0x40, 0],
 94: 	[0x50, 3],
 95: 	[0x30, 0],
 96: 	[0x46, 34]
 97: ]
 98: right_motor = [
 99: 	[0x00, 45]
100: ]
101: 
102: [set6]
103: left_motor = [
104: 	[0x50, 0],
105: 	[0x50, 0],
106: 	[0x30, 0],
107: 	[0x30, 0],
108: 	[0x50, 0],
109: 	[0x50, 0],
110: 	[0x30, 0],
111: 	[0x30, 0],
112: 	[0x50, 0],
113: 	[0x50, 0],
114: 	[0x30, 0],
115: 	[0x30, 0],
116: 	[0x50, 0],
117: 	[0x50, 0],
118: 	[0x30, 0],
119: 	[0x30, 0],
120: 	[0x50, 0],
121: 	[0x50, 8],
122: 	[0x23, 18]
123: ]
124: right_motor = [
125: 	[0x00, 44]
126: ]
127: 
128: [set7]
129: left_motor = [
130: 	[0x41, 0],
131: 	[0x48, 0],
132: 	[0x4F, 0],
133: 	[0x55, 7]
134: ]
135: right_motor = [
136: 	[0x00, 10]
137: ]
138: 
139: [set8]
140: left_motor = [
141: 	[0x42, 3],
142: 	[0x54, 0],
143: 	[0x3C, 0],
144: 	[0x48, 2],
145: 	[0x54, 0],
146: 	[0x43, 4],
147: 	[0x50, 0],
148: 	[0x40, 0],
149: 	[0x3B, 0],
150: 	[0x35, 0],
151: 	[0x32, 0],
152: 	[0x30, 0],
153: 	[0x2C, 0],
154: 	[0x2E, 0],
155: 	[0x30, 0],
156: 	[0x34, 0],
157: 	[0x36, 0],
158: 	[0x3A, 0],
159: 	[0x30, 0],
160: 	[0x32, 0],
161: 	[0x35, 0],
162: 	[0x3A, 0],
163: 	[0x31, 0],
164: 	[0x31, 0],
165: 	[0x60, 0],
166: 	[0x60, 0],
167: 	[0x5A, 0],
168: 	[0x52, 0],
169: 	[0x47, 0],
170: 	[0x40, 0],
171: 	[0x40, 0],
172: 	[0x60, 0],
173: 	[0x60, 0],
174: 	[0x5C, 0],
175: 	[0x5C, 0],
176: 	[0x5C, 0],
177: 	[0x59, 45]
178: ]
179: right_motor = [
180: 	[0x00, 33],
181: 	[0x00, 0],
182: 	[0x40, 0],
183: 	[0x40, 0],
184: 	[0x00, 4],
185: 	[0x00, 0],
186: 	[0x40, 0],
187: 	[0x40, 0],
188: 	[0x00, 0],
189: 	[0x40, 0],
190: 	[0x40, 0],
191: 	[0x31, 41]
192: ]
193: 
194: [set9]
195: left_motor = [
196: 	[0x59, 1],
197: 	[0x53, 10]
198: ]
199: right_motor = [
200: 	[0x00, 0],
201: 	[0x50, 0],
202: 	[0x00, 10]
203: ]
204: 
205: [set10]
206: left_motor = [
207: 	[0x49, 1],
208: 	[0x44, 0],
209: 	[0x25, 0],
210: 	[0x23, 0],
211: 	[0x31, 0],
212: 	[0x2E, 6]
213: ]
214: right_motor = [
215: 	[0x00, 0],
216: 	[0x40, 0],
217: 	[0x00, 10]
218: ]
219: 
220: [set11]
221: left_motor = [
222: 	[0x48, 1],
223: 	[0x48, 0]
224: ]
225: right_motor = [
226: 	[0x00, 0],
227: 	[0x48, 0]
228: ]
229: 
230: [set12]
231: left_motor = [
232: 	[0x5F, 1],
233: 	[0x5F, 0],
234: 	[0x50, 0],
235: 	[0x50, 0],
236: 	[0x5F, 3],
237: 	[0x5F, 66]
238: ]
239: right_motor = [
240: 	[0x40, 0],
241: 	[0x40, 10],
242: 	[0x00, 63]
243: ]
244: 
245: [set13]
246: left_motor = [
247: 	[0x50, 1],
248: 	[0x50, 0],
249: 	[0x30, 0],
250: 	[0x30, 0],
251: 	[0x47, 0],
252: 	[0x45, 0],
253: 	[0x3B, 0],
254: 	[0x34, 0],
255: 	[0x30, 0],
256: 	[0x38, 0],
257: 	[0x41, 0],
258: 	[0x46, 0],
259: 	[0x4D, 0],
260: 	[0x48, 0],
261: 	[0x44, 0],
262: 	[0x2F, 0],
263: 	[0x3B, 2],
264: 	[0x54, 0],
265: 	[0x54, 3],
266: 	[0x32, 0],
267: 	[0x34, 0],
268: 	[0x46, 6],
269: 	[0x40, 1],
270: 	[0x3C, 54]
271: ]
272: right_motor = [
273: 	[0x00, 90]
274: ]
275: 
276: [set14]
277: left_motor = [
278: 	[0x60, 1],
279: 	[0x5F, 0],
280: 	[0x4E, 3],
281: 	[0x40, 0],
282: 	[0x4C, 11],
283: 	[0x2B, 0],
284: 	[0x23, 34]
285: ]
286: right_motor = [
287: 	[0x00, 55]
288: ]
289: 
290: [set15]
291: left_motor = [
292: 	[0x00, 1]
293: ]
294: right_motor = [
295: 	[0x60, 0],
296: 	[0x60, 0],
297: 	[0x01, 0]
298: ]
299: 
300: [set16]
301: left_motor = [
302: 	[0x4F, 1],
303: 	[0x48, 0],
304: 	[0x31, 0],
305: 	[0x31, 2],
306: 	[0x60, 0],
307: 	[0x60, 0],
308: 	[0x4C, 4],
309: 	[0x40, 0],
310: 	[0x4F, 1],
311: 	[0x4B, 0],
312: 	[0x3F, 0],
313: 	[0x3F, 87]
314: ]
315: right_motor = [
316: 	[0x00, 105]
317: ]
318: 
319: [set17]
320: left_motor = [
321: 	[0x51, 2],
322: 	[0x51, 0],
323: 	[0x40, 1],
324: 	[0x55, 0],
325: 	[0x30, 0],
326: 	[0x52, 1],
327: 	[0x2F, 0],
328: 	[0x55, 0],
329: 	[0x4C, 0],
330: 	[0x35, 1],
331: 	[0x53, 2],
332: 	[0x3F, 0],
333: 	[0x49, 3],
334: 	[0x3D, 0],
335: 	[0x4B, 4],
336: 	[0x38, 0],
337: 	[0x46, 22]
338: ]
339: right_motor = [
340: 	[0x00, 52]
341: ]
342: 
343: [set18]
344: left_motor = [
345: 	[0x2F, 0],
346: 	[0x58, 0],
347: 	[0x5F, 0],
348: 	[0x60, 0],
349: 	[0x41, 0],
350: 	[0x41, 0],
351: 	[0x53, 0],
352: 	[0x50, 0],
353: 	[0x4A, 0],
354: 	[0x3F, 0],
355: 	[0x24, 0],
356: 	[0x26, 0],
357: 	[0x4A, 0],
358: 	[0x45, 3],
359: 	[0x20, 0],
360: 	[0x29, 0],
361: 	[0x46, 0],
362: 	[0x40, 0],
363: 	[0x40, 0],
364: 	[0x2C, 0],
365: 	[0x28, 0],
366: 	[0x24, 0],
367: 	[0x3F, 0],
368: 	[0x40, 0],
369: 	[0x35, 27]
370: ]
371: right_motor = [
372: 	[0x00, 54]
373: ]
374: 
375: [set19]
376: left_motor = [
377: 	[0x50, 0],
378: 	[0x50, 0],
379: 	[0x4C, 0],
380: 	[0x40, 0],
381: 	[0x40, 0],
382: 	[0x48, 0],
383: 	[0x48, 0],
384: 	[0x40, 0],
385: 	[0x40, 21]
386: ]
387: right_motor = [
388: 	[0x00, 29]
389: ]
390: 
391: [set20]
392: left_motor = [
393: 	[0x23, 9],
394: 	[0x56, 0],
395: 	[0x55, 0],
396: 	[0x54, 0],
397: 	[0x53, 0],
398: 	[0x3E, 0],
399: 	[0x3D, 0],
400: 	[0x51, 6],
401: 	[0x43, 8],
402: 	[0x25, 0],
403: 	[0x41, 0],
404: 	[0x40, 20]
405: ]
406: right_motor = [
407: 	[0x00, 31],
408: 	[0x00, 0],
409: 	[0x40, 0],
410: 	[0x40, 5],
411: 	[0x00, 14]
412: ]
413: 
414: [set21]
415: left_motor = [
416: 	[0x5F, 1],
417: 	[0x5F, 0],
418: 	[0x52, 1],
419: 	[0x4B, 6],
420: 	[0x30, 7],
421: 	[0x19, 11]
422: ]
423: right_motor = [
424: 	[0x00, 31]
425: ]
426: 
427: [set22]
428: left_motor = [
429: 	[0x60, 0],
430: 	[0x60, 0],
431: 	[0x52, 0],
432: 	[0x40, 0],
433: 	[0x3C, 0],
434: 	[0x2B, 8]
435: ]
436: right_motor = [
437: 	[0x5C, 2],
438: 	[0x00, 10]
439: ]
440: 
441: [set23]
442: left_motor = [
443: 	[0x61, 0],
444: 	[0x60, 0],
445: 	[0x31, 0],
446: 	[0x3A, 0],
447: 	[0x55, 0],
448: 	[0x56, 0],
449: 	[0x30, 0],
450: 	[0x39, 0],
451: 	[0x60, 0],
452: 	[0x60, 0],
453: 	[0x30, 0],
454: 	[0x38, 0],
455: 	[0x54, 0],
456: 	[0x55, 0],
457: 	[0x2F, 0],
458: 	[0x3C, 0],
459: 	[0x5C, 0],
460: 	[0x5D, 0],
461: 	[0x30, 0],
462: 	[0x3C, 0],
463: 	[0x51, 0],
464: 	[0x53, 0],
465: 	[0x3B, 23]
466: ]
467: right_motor = [
468: 	[0x00, 45]
469: ]
470: 
471: [set24]
472: left_motor = [
473: 	[0x40, 0],
474: 	[0x40, 0],
475: 	[0x20, 0],
476: 	[0x40, 0],
477: 	[0x40, 0],
478: 	[0x20, 0],
479: 	[0x40, 0],
480: 	[0x40, 0],
481: 	[0x20, 0],
482: 	[0x40, 0],
483: 	[0x40, 0],
484: 	[0x20, 0],
485: 	[0x40, 0],
486: 	[0x40, 0],
487: 	[0x34, 0],
488: 	[0x2C, 8]
489: ]
490: right_motor = [
491: 	[0x40, 0],
492: 	[0x00, 0],
493: 	[0x40, 0],
494: 	[0x00, 0],
495: 	[0x40, 0],
496: 	[0x00, 0],
497: 	[0x40, 0],
498: 	[0x00, 0],
499: 	[0x40, 0],
500: 	[0x00, 0],
501: 	[0x40, 0],
502: 	[0x00, 0],
503: 	[0x40, 0],
504: 	[0x00, 0],
505: 	[0x41, 0],
506: 	[0x00, 8]
507: ]
508: 
509: [set25]
510: left_motor = [
511: 	[0x61, 0],
512: 	[0x60, 1],
513: 	[0x50, 0],
514: 	[0x57, 0],
515: 	[0x55, 0],
516: 	[0x46, 0],
517: 	[0x40, 0],
518: 	[0x52, 0],
519: 	[0x4F, 0],
520: 	[0x42, 0],
521: 	[0x3F, 0],
522: 	[0x4E, 0],
523: 	[0x4D, 47]
524: ]
525: right_motor = [
526: 	[0x00, 60]
527: ]
528: 
529: [set26]
530: left_motor = [
531: 	[0x60, 29]
532: ]
533: right_motor = [
534: 	[0x00, 29]
535: ]
536: 
537: [set27]
538: left_motor = [
539: 	[0x00, 23]
540: ]
541: right_motor = [
542: 	[0x40, 9],
543: 	[0x40, 13]
544: ]
545: 
546: [set28]
547: left_motor = [
548: 	[0x40, 1],
549: 	[0x40, 0],
550: 	[0x00, 0],
551: 	[0x00, 0],
552: 	[0x60, 1],
553: 	[0x60, 0]
554: ]
555: right_motor = [
556: 	[0x00, 7]
557: ]
558: 
559: [set29]
560: left_motor = [
561: 	[0x40, 1],
562: 	[0x40, 0],
563: 	[0x00, 0],
564: 	[0x00, 0],
565: 	[0x5F, 1],
566: 	[0x5F, 0]
567: ]
568: right_motor = [
569: 	[0x00, 1],
570: 	[0x00, 0],
571: 	[0x40, 0],
572: 	[0x40, 0],
573: 	[0x00, 2]
574: ]
575: 
576: [set30]
577: left_motor = [
578: 	[0x5F, 0],
579: 	[0x5F, 0],
580: 	[0x50, 0],
581: 	[0x3F, 0],
582: 	[0x34, 0],
583: 	[0x29, 0],
584: 	[0x24, 3],
585: 	[0x24, 0],
586: 	[0x30, 0],
587: 	[0x38, 0],
588: 	[0x48, 0],
589: 	[0x52, 0],
590: 	[0x5B, 0],
591: 	[0x60, 14]
592: ]
593: right_motor = [
594: 	[0x00, 30]
595: ]
596: 
597: [set31]
598: left_motor = [
599: 	[0x5F, 0],
600: 	[0x53, 0],
601: 	[0x48, 0],
602: 	[0x3C, 0],
603: 	[0x34, 0],
604: 	[0x28, 0],
605: 	[0x24, 3],
606: 	[0x24, 0],
607: 	[0x2B, 0],
608: 	[0x35, 0],
609: 	[0x40, 0],
610: 	[0x4C, 0],
611: 	[0x58, 0],
612: 	[0x5F, 14]
613: ]
614: right_motor = [
615: 	[0x40, 2],
616: 	[0x40, 0],
617: 	[0x30, 7],
618: 	[0x30, 0],
619: 	[0x40, 2],
620: 	[0x40, 13]
621: ]
622: 
623: [set32]
624: left_motor = [
625: 	[0x60, 0],
626: 	[0x60, 0],
627: 	[0x30, 0],
628: 	[0x55, 0],
629: 	[0x55, 0],
630: 	[0x30, 0],
631: 	[0x5B, 0],
632: 	[0x5B, 0],
633: 	[0x40, 0],
634: 	[0x50, 0],
635: 	[0x50, 34]
636: ]
637: right_motor = [
638: 	[0x00, 44]
639: ]
640: 
641: [set33]
642: left_motor = [
643: 	[0x60, 0],
644: 	[0x60, 0],
645: 	[0x59, 3],
646: 	[0x2C, 15]
647: ]
648: right_motor = [
649: 	[0x00, 21]
650: ]
651: 
652: [set34]
653: left_motor = [
654: 	[0x50, 2],
655: 	[0x47, 0],
656: 	[0x4F, 2],
657: 	[0x3F, 0],
658: 	[0x48, 3],
659: 	[0x33, 0],
660: 	[0x38, 3],
661: 	[0x29, 0],
662: 	[0x30, 16]
663: ]
664: right_motor = [
665: 	[0x00, 34]
666: ]
667: 
668: [set35]
669: left_motor = [
670: 	[0x61, 0],
671: 	[0x56, 0],
672: 	[0x55, 0],
673: 	[0x49, 0],
674: 	[0x48, 26]
675: ]
676: right_motor = [
677: 	[0x00, 29]
678: ]
679: 
680: [set36]
681: left_motor = [
682: 	[0x41, 0],
683: 	[0x41, 0],
684: 	[0x60, 0],
685: 	[0x60, 0]
686: ]
687: right_motor = [
688: 	[0x50, 0],
689: 	[0x50, 0],
690: 	[0x00, 1]
691: ]
692: 
693: [set37]
694: left_motor = [
695: 	[0x5F, 0],
696: 	[0x5E, 0],
697: 	[0x00, 0],
698: 	[0x00, 0],
699: 	[0x43, 0],
700: 	[0x38, 0]
701: ]
702: right_motor = [
703: 	[0x50, 0],
704: 	[0x40, 0],
705: 	[0x00, 3]
706: ]
707: 
708: [set38]
709: left_motor = [
710: 	[0x58, 0],
711: 	[0x58, 0],
712: 	[0x44, 0],
713: 	[0x44, 0],
714: 	[0x50, 0],
715: 	[0x50, 0],
716: 	[0x38, 0],
717: 	[0x38, 22]
718: ]
719: right_motor = [
720: 	[0x00, 29]
721: ]
722: 
723: [set39]
724: left_motor = [
725: 	[0x57, 1],
726: 	[0x52, 0],
727: 	[0x36, 0],
728: 	[0x35, 0],
729: 	[0x44, 0],
730: 	[0x3D, 0],
731: 	[0x31, 0],
732: 	[0x2B, 10],
733: 	[0x03, 0]
734: ]
735: right_motor = [
736: 	[0x00, 18]
737: ]
738: 
739: [set40]
740: left_motor = [
741: 	[0x34, 13],
742: 	[0x1A, 0],
743: 	[0x3F, 7],
744: 	[0x23, 11],
745: 	[0x1C, 0],
746: 	[0x40, 20],
747: 	[0x1C, 0],
748: 	[0x3E, 12],
749: 	[0x1B, 0],
750: 	[0x3A, 13],
751: 	[0x1A, 0],
752: 	[0x3A, 23],
753: 	[0x1F, 0],
754: 	[0x3A, 25]
755: ]
756: right_motor = [
757: 	[0x00, 137]
758: ]
759: 
760: [set41]
761: left_motor = [
762: 	[0x2F, 14],
763: 	[0x10, 239],
764: 	[0x38, 44],
765: 	[0x40, 14]
766: ]
767: right_motor = [
768: 	[0x00, 239],
769: 	[0x00, 74]
770: ]
771: 
772: [set42]
773: left_motor = [
774: 	[0x68, 0],
775: 	[0x68, 0],
776: 	[0x68, 0],
777: 	[0x67, 7],
778: 	[0x35, 2],
779: 	[0x2B, 6],
780: 	[0x34, 7],
781: 	[0x2A, 7],
782: 	[0x33, 13],
783: 	[0x28, 99]
784: ]
785: right_motor = [
786: 	[0x50, 1],
787: 	[0x50, 7],
788: 	[0x00, 140]
789: ]
790: 
791: [set43]
792: left_motor = [
793: 	[0x33, 0],
794: 	[0x38, 0],
795: 	[0x3C, 0],
796: 	[0x40, 0],
797: 	[0x43, 0],
798: 	[0x49, 0],
799: 	[0x52, 0],
800: 	[0x5A, 0],
801: 	[0x5F, 0],
802: 	[0x5F, 0],
803: 	[0x59, 0],
804: 	[0x52, 4],
805: 	[0x38, 4],
806: 	[0x30, 4],
807: 	[0x38, 0],
808: 	[0x3E, 0],
809: 	[0x43, 0],
810: 	[0x48, 0],
811: 	[0x49, 0],
812: 	[0x47, 0],
813: 	[0x43, 0],
814: 	[0x3E, 0],
815: 	[0x37, 0],
816: 	[0x34, 0],
817: 	[0x30, 0],
818: 	[0x30, 2],
819: 	[0x3C, 0],
820: 	[0x43, 0],
821: 	[0x44, 0],
822: 	[0x3E, 0],
823: 	[0x30, 29],
824: 	[0x21, 0],
825: 	[0x1E, 0],
826: 	[0x18, 0],
827: 	[0x16, 0],
828: 	[0x1A, 0],
829: 	[0x20, 0],
830: 	[0x2A, 0],
831: 	[0x31, 0],
832: 	[0x37, 0],
833: 	[0x3C, 0],
834: 	[0x41, 0],
835: 	[0x45, 0],
836: 	[0x46, 0],
837: 	[0x46, 0],
838: 	[0x44, 0],
839: 	[0x42, 0],
840: 	[0x40, 0],
841: 	[0x3A, 0],
842: 	[0x2F, 0],
843: 	[0x22, 0],
844: 	[0x21, 0],
845: 	[0x27, 0],
846: 	[0x34, 0],
847: 	[0x3E, 0],
848: 	[0x45, 0],
849: 	[0x46, 0],
850: 	[0x47, 0],
851: 	[0x45, 0],
852: 	[0x3E, 0],
853: 	[0x32, 0],
854: 	[0x2B, 0],
855: 	[0x22, 0],
856: 	[0x24, 0],
857: 	[0x2A, 4],
858: 	[0x48, 0],
859: 	[0x4C, 0],
860: 	[0x4F, 2],
861: 	[0x4F, 8],
862: 	[0x27, 0],
863: 	[0x23, 0],
864: 	[0x26, 5],
865: 	[0x5D, 3],
866: 	[0x5E, 4],
867: 	[0x31, 0],
868: 	[0x36, 0],
869: 	[0x3B, 0],
870: 	[0x3B, 0],
871: 	[0x35, 0],
872: 	[0x2B, 0],
873: 	[0x26, 0],
874: 	[0x21, 0],
875: 	[0x20, 0],
876: 	[0x21, 0],
877: 	[0x23, 0],
878: 	[0x28, 0],
879: 	[0x31, 0],
880: 	[0x42, 0],
881: 	[0x49, 0],
882: 	[0x49, 0],
883: 	[0x45, 0],
884: 	[0x40, 0],
885: 	[0x37, 0],
886: 	[0x2D, 0],
887: 	[0x25, 0],
888: 	[0x25, 0],
889: 	[0x25, 0],
890: 	[0x28, 0],
891: 	[0x2F, 0],
892: 	[0x35, 2],
893: 	[0x36, 0],
894: 	[0x33, 0],
895: 	[0x2C, 0],
896: 	[0x26, 0],
897: 	[0x23, 0],
898: 	[0x22, 0],
899: 	[0x20, 0],
900: 	[0x21, 0],
901: 	[0x24, 0],
902: 	[0x2A, 0],
903: 	[0x31, 0],
904: 	[0x36, 3],
905: 	[0x36, 0],
906: 	[0x31, 0],
907: 	[0x2A, 0],
908: 	[0x26, 0],
909: 	[0x22, 0],
910: 	[0x23, 0],
911: 	[0x27, 0],
912: 	[0x2C, 0],
913: 	[0x31, 0],
914: 	[0x35, 2],
915: 	[0x35, 0],
916: 	[0x32, 0],
917: 	[0x2C, 0],
918: 	[0x24, 0],
919: 	[0x20, 0],
920: 	[0x22, 0],
921: 	[0x27, 0],
922: 	[0x2F, 0],
923: 	[0x32, 2],
924: 	[0x32, 0],
925: 	[0x30, 4],
926: 	[0x21, 24],
927: 	[0x01, 0]
928: ]
929: right_motor = [
930: 	[0x00, 239]
931: ]
932: 
933: [set44]
934: left_motor = [
935: 	[0x50, 0],
936: 	[0x54, 0],
937: 	[0x50, 2],
938: 	[0x30, 5],
939: 	[0x1F, 0],
940: 	[0x1F, 7],
941: 	[0x31, 0],
942: 	[0x40, 0],
943: 	[0x44, 0],
944: 	[0x40, 2],
945: 	[0x30, 5],
946: 	[0x20, 0],
947: 	[0x20, 7],
948: 	[0x30, 0],
949: 	[0x38, 0],
950: 	[0x3D, 0],
951: 	[0x38, 2],
952: 	[0x31, 5],
953: 	[0x20, 0],
954: 	[0x20, 6],
955: 	[0x29, 0],
956: 	[0x2D, 0],
957: 	[0x30, 0],
958: 	[0x2B, 3],
959: 	[0x1C, 51]
960: ]
961: right_motor = [
962: 	[0x00, 119]
963: ]
964: 
965: [set45]
966: left_motor = [
967: 	[0x30, 20],
968: 	[0x1F, 18],
969: 	[0x2E, 21],
970: 	[0x14, 24],
971: 	[0x2D, 33]
972: ]
973: right_motor = [
974: 	[0x00, 120]
975: ]
</file>

<file path="misc/FFNx.vibrate.ff8.world.toml">
 1: # FFNx Vibration Engine config file - FF8 World module
 2: 
 3: ### HOW TO: ###################################################################
 4: # Sections may be commented by default with an initial # character.
 5: # Remove the initial # character to set the entire sections block and its flags
 6: # -----------------------------------------------------------------------------
 7: # Syntax:
 8: # [ID]
 9: # flag = value
10: # another_flag = value
11: ###############################################################################
12: 
13: ### SUPPORTED FLAGS: ##########################################################
14: # left_motor: An array of arrays, where each tuple MUST contain the relative
15: # values. This vibration values will impact the LEFT motor of the gamepad.
16: # The first value of the tuple is the motor force, the second value is the
17: # number of frames to repeat this force.
18: # -----------------------------------------------------------------------------
19: # right_motor: An array of arrays, where each tuple MUST contain the relative
20: # values. This vibration values will impact the RIGHT motor of the gamepad.
21: # The first value of the tuple is the motor force, the second value is the
22: # number of frames to repeat this force.
23: ###############################################################################
24: 
25: # These entries will define LEFT and RIGHT motor forces for a set of
26: # scenes setX.
27: # setX: A scene ID where X is set between 0 to 63.
28: # -----------------------------------------------------------------------------
29: 
30: [set0]
31: left_motor = [
32: 	[0x38, 0],
33: 	[0x31, 0],
34: 	[0x30, 0],
35: 	[0x1C, 0],
36: 	[0x16, 0],
37: 	[0x11, 0],
38: 	[0x0D, 0],
39: 	[0x08, 0],
40: 	[0x04, 0]
41: ]
42: right_motor = [
43: ]
44: 
45: [set1]
46: left_motor = [
47: 	[0x38, 0],
48: 	[0x31, 0],
49: 	[0x30, 0],
50: 	[0x1C, 0],
51: 	[0x16, 0],
52: 	[0x11, 0],
53: 	[0x0D, 0],
54: 	[0x08, 0],
55: 	[0x04, 0]
56: ]
57: right_motor = [
58: ]
59: 
60: [set2]
61: left_motor = [
62: 	[0x38, 0],
63: 	[0x31, 0],
64: 	[0x30, 0],
65: 	[0x1C, 0],
66: 	[0x16, 0],
67: 	[0x11, 0],
68: 	[0x0D, 0],
69: 	[0x08, 0],
70: 	[0x04, 0]
71: ]
72: right_motor = [
73: ]
74: 
75: [set3]
76: left_motor = [
77: 	[0x38, 0],
78: 	[0x31, 0],
79: 	[0x30, 0],
80: 	[0x1C, 0],
81: 	[0x16, 0],
82: 	[0x11, 0],
83: 	[0x0D, 0],
84: 	[0x08, 0],
85: 	[0x04, 0]
86: ]
87: right_motor = [
88: ]
</file>

<file path="misc/FFNx.voice.toml">
 1: # FFNx Audio Engine config file - Voice layer
 2: 
 3: ### HOW TO: ###################################################################
 4: # Sections may be commented by default with an initial # character.
 5: # Remove the initial # character to set the entire sections block and its flags
 6: # -----------------------------------------------------------------------------
 7: # Syntax:
 8: # [FIELDNAME/FILENAME(.GAME_MOMENT)]
 9: # flag = value
10: # another_flag = value
11: # -----------------------------------------------------------------------------
12: # where:
13: # - FIELDNAME: the current field name, for eg. 'md1stin'
14: # - FILENAME: the filename as you have it in your own folder,
15: #             for eg. '6' for 6.ogg
16: # - GAME_MOMENT: OPTIONAL attribute to assign a flag only when game moment
17: #                matches the ID given, for eg. 'gm-123'
18: ###############################################################################
19: 
20: ### SUPPORTED FLAGS: ##########################################################
21: # volume: Allow volume to be adjusted for a specific track.
22: # -----------------------------------------------------------------------------
23: # shuffle: Shuffle a voice track with any of the given one in the array. Each
24: # item MUST be a string. This flag MUST NOT be used in pair with 'sequential'.
25: # -----------------------------------------------------------------------------
26: # sequential: Sequentially playback a voice track with the ones provided in the
27: # array. Each item MUST be a string. This flag MUST NOT be used in pair with
28: # 'shuffle'.
29: ###############################################################################
30: 
31: # This entry will set the volume to 50%
32: # -----------------------------------------------------------------------------
33: #[md1stin-6]
34: #volume = 50
35: #shuffle = [ "foo", "bar" ]
36: #sequential = [ "foo", "bar" ]
37: 
38: # This entry will set the volume to 0% only when game moment is 123
39: # -----------------------------------------------------------------------------
40: #[md1stin-6.gm-123]
41: #volume = 50
42: #shuffle = [ "foo", "bar" ]
43: #sequential = [ "foo", "bar" ]
</file>

<file path="misc/version.rc.in">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #include <windows.h>
23: 
24: #define VER_FILEVERSION             @_DLL_RCVERSION@
25: #define VER_FILEVERSION_STR         "@_DLL_RCSTRVERSION@\0"
26: 
27: #define VER_PRODUCTVERSION          @_DLL_RCVERSION@
28: #define VER_PRODUCTVERSION_STR      "@_DLL_RCSTRVERSION@\0"
29: 
30: #define VER_INTERNALNAME            "@RELEASE_NAME@"
31: #define VER_PRODUCTNAME             "@RELEASE_NAME@"
32: #define VER_ORIGINALFILENAME        "@RELEASE_NAME@.dll"
33: 
34: VS_VERSION_INFO VERSIONINFO
35: FILEVERSION     VER_FILEVERSION
36: PRODUCTVERSION  VER_PRODUCTVERSION
37: FILEOS          VOS__WINDOWS32
38: FILETYPE        VFT_DLL
39: FILESUBTYPE     VFT2_UNKNOWN
40: BEGIN
41:     BLOCK "StringFileInfo"
42:     BEGIN
43:         BLOCK "040904E4"
44:         BEGIN
45:             VALUE "CompanyName",      "Julian Xhokaxhiu"
46:             VALUE "FileDescription",  "Next generation driver for Final Fantasy VII and Final Fantasy VIII ( with native Steam 2013 release support! )"
47:             VALUE "FileVersion",      VER_FILEVERSION_STR
48:             VALUE "InternalName",     VER_INTERNALNAME
49:             VALUE "LegalCopyright",   "GPLv3"
50:             VALUE "LegalTrademarks1", ""
51:             VALUE "LegalTrademarks2", ""
52:             VALUE "OriginalFilename", VER_ORIGINALFILENAME
53:             VALUE "ProductName",      VER_PRODUCTNAME
54:             VALUE "ProductVersion",   VER_PRODUCTVERSION_STR
55:         END
56:     END
57: 
58:     BLOCK "VarFileInfo"
59:     BEGIN
60:         /* The following line should only be modified for localized versions.     */
61:         /* It consists of any number of WORD,WORD pairs, with each pair           */
62:         /* describing a language,codepage combination supported by the file.      */
63:         /*                                                                        */
64:         /* For example, a file might have values "0x409,1252" indicating that it  */
65:         /* supports English language (0x409) in the Windows ANSI codepage (1252). */
66: 
67:         VALUE "Translation", 0x409, 1252
68: 
69:     END
70: END
</file>

<file path="src/audio/memorystream/memorystream.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "memorystream.h"
 23: 
 24: namespace SoLoud
 25: {
 26: 	MemoryStreamInstance::MemoryStreamInstance(MemoryStream* aParent)
 27: 	{
 28: 		mParent = aParent;
 29: 		mOffset = 0;
 30: 	}
 31: 
 32: 	uint32_t MemoryStreamInstance::getAudio(float* aBuffer, uint32_t aSamplesToRead, uint32_t aBufferSize)
 33: 	{
 34: 		uint32_t j, k;
 35: 		uint32_t future_offset = mOffset + (aSamplesToRead * mChannels), current_offset = mParent->mPushOffset / sizeof(float);
 36: 
 37: 		if (future_offset <= current_offset)
 38: 		{
 39: 			for (j = 0; j < aSamplesToRead; j++)
 40: 			{
 41: 				for (k = 0; k < mChannels; k++)
 42: 				{
 43: 					aBuffer[k * aSamplesToRead + j] = mParent->mData[mOffset + (j * mChannels) + k];
 44: 				}
 45: 			}
 46: 
 47: 			mOffset += aSamplesToRead * mChannels;
 48: 
 49: 			return aSamplesToRead;
 50: 		}
 51: 
 52: 		return 0;
 53: 	}
 54: 
 55: 	bool MemoryStreamInstance::hasEnded()
 56: 	{
 57: 		if (mOffset >= mParent->mSampleCount)
 58: 		{
 59: 			return 1;
 60: 		}
 61: 		return 0;
 62: 	}
 63: 
 64: 	MemoryStream::MemoryStream(float sampleRate, uint32_t sampleCount, uint32_t channels)
 65: 	{
 66: 		mBaseSamplerate = sampleRate;
 67: 		mSampleCount = sampleCount;
 68: 		mChannels = channels;
 69: 
 70:     mData = new float[mSampleCount]{ NULL };
 71:     mPushLength = mSampleCount * sizeof(float);
 72:     mPushOffset = 0;
 73: 	}
 74: 
 75: 	MemoryStream::~MemoryStream()
 76: 	{
 77: 		stop();
 78: 
 79: 		delete[] mData;
 80: 	}
 81: 
 82:   result MemoryStream::push(uint8_t* data, uint32_t size)
 83:   {
 84:     uint32_t leftSpace = mPushLength - mPushOffset;
 85: 
 86:     if ( size > leftSpace ) size = leftSpace;
 87: 
 88:     memcpy((uint8_t*)mData + mPushOffset, data, size);
 89: 
 90:     mPushOffset += size;
 91: 
 92:     return SO_NO_ERROR;
 93:   }
 94: 
 95: 	AudioSourceInstance* MemoryStream::createInstance()
 96: 	{
 97: 		return new MemoryStreamInstance(this);
 98: 	}
 99: 
100: 	double MemoryStream::getLength()
101: 	{
102: 		if (mBaseSamplerate == 0)
103: 			return 0;
104: 
105: 		return mSampleCount / mBaseSamplerate;
106: 	}
107: };
</file>

<file path="src/audio/memorystream/memorystream.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <stdint.h>
25: #include <soloud.h>
26: 
27: namespace SoLoud
28: {
29: 	class MemoryStream : public AudioSource
30: 	{
31: 	public:
32: 		uint32_t mPushLength;
33: 		uint32_t mPushOffset;
34: 		uint32_t mSampleCount;
35: 		float* mData;
36: 
37: 		MemoryStream(float sampleRate, uint32_t sampleCount, uint32_t channels);
38: 		virtual ~MemoryStream();
39: 
40:     result push(uint8_t* data, uint32_t size);
41: 
42: 		virtual AudioSourceInstance* createInstance();
43: 		time getLength();
44: 	};
45: 
46: 	class MemoryStreamInstance : public AudioSourceInstance
47: 	{
48: 		MemoryStream* mParent;
49: 		uint32_t mOffset;
50: 	public:
51: 		MemoryStreamInstance(MemoryStream* aParent);
52: 		virtual uint32_t getAudio(float* aBuffer, uint32_t aSamplesToRead, uint32_t aBufferSize);
53: 		virtual bool hasEnded();
54: 	};
55: };
</file>

<file path="src/audio/openpsf/openpsf.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "openpsf.h"
 23: #include "utils.h"
 24: #include "log.h"
 25: 
 26: constexpr auto SOLOUD_OPENPSF_VOLUME_SCALE = float(3.2f / double(0x8000));
 27: 
 28: namespace SoLoud
 29: {
 30: 	OpenPsfInstance::OpenPsfInstance(OpenPsf* aParent)
 31: 	{
 32: 		ended = false;
 33: 		mParent = aParent;
 34: 		mOffset = 0;
 35: 		mStreamBufferSize = SAMPLE_GRANULARITY * aParent->mChannels;
 36: 		mStreamBuffer = new int16_t[mStreamBufferSize];
 37: 		mStreamBufferSize *= sizeof(int16_t);
 38: 	}
 39: 
 40: 	OpenPsfInstance::~OpenPsfInstance()
 41: 	{
 42: 		delete[] mStreamBuffer;
 43: 	}
 44: 
 45: 	unsigned int OpenPsfInstance::getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
 46: 	{
 47: 		unsigned int offset = 0;
 48: 		unsigned int i, j, k;
 49: 
 50: 		for (i = 0; i < aSamplesToRead; i += SAMPLE_GRANULARITY)
 51: 		{
 52: 			memset(mStreamBuffer, 0, mStreamBufferSize);
 53: 			unsigned int blockSize = aSamplesToRead - i > SAMPLE_GRANULARITY ? SAMPLE_GRANULARITY : aSamplesToRead - i;
 54: 			int r = mParent->stream->decode(mStreamBuffer, blockSize);
 55: 
 56: 			if (r == 0) {
 57: 				ended = true;
 58: 				break;
 59: 			}
 60: 			else if (r < 0) {
 61: 				ffnx_error("OpenPsfInstance::%s Decoding error: %s\n%s\n", __func__, mParent->stream->get_last_error(), mParent->stream->get_last_status());
 62: 				break;
 63: 			}
 64: 
 65: 			offset += r;
 66: 
 67: 			for (j = 0; j < blockSize; j++)
 68: 			{
 69: 				for (k = 0; k < mChannels; k++)
 70: 				{
 71: 					aBuffer[k * aSamplesToRead + i + j] = mStreamBuffer[j * mChannels + k] * SOLOUD_OPENPSF_VOLUME_SCALE;
 72: 				}
 73: 			}
 74: 		}
 75: 
 76: 		mOffset += offset;
 77: 
 78: 		return offset;
 79: 	}
 80: 
 81: 	result OpenPsfInstance::rewind()
 82: 	{
 83: 		mParent->stream->rewind();
 84: 
 85: 		ended = false;
 86: 		mOffset = 0;
 87: 		mStreamPosition = 0.0f;
 88: 		return SO_NO_ERROR;
 89: 	}
 90: 
 91: 	result OpenPsfInstance::seek(double aSeconds, float *mScratch, unsigned int mScratchSize)
 92: 	{
 93: 		double offset = aSeconds - mStreamPosition;
 94: 
 95: 		if (offset <= 0)
 96: 		{
 97: 			if (rewind() != SO_NO_ERROR)
 98: 			{
 99: 				// can't do generic seek backwards unless we can rewind.
100: 				return NOT_IMPLEMENTED;
101: 			}
102: 			offset = aSeconds;
103: 		}
104: 
105: 		int samples_to_discard = int(floor(mSamplerate * offset));
106: 
107: 		mOffset = samples_to_discard;
108: 
109: 		while (samples_to_discard)
110: 		{
111: 			samples_to_discard -= mParent->stream->decode(nullptr, samples_to_discard);
112: 		}
113: 
114: 		mStreamPosition = aSeconds;
115: 		return SO_NO_ERROR;
116: 	}
117: 
118: 	bool OpenPsfInstance::hasEnded()
119: 	{
120: 		return !(mFlags & AudioSourceInstance::LOOPING) && (ended || mOffset >= mParent->mSampleCount);
121: 	}
122: 
123: 	OpenPsf::OpenPsf() :
124: 		stream(nullptr), mSampleCount(0)
125: 	{
126: 	}
127: 
128: 	OpenPsf::~OpenPsf()
129: 	{
130: 		stop();
131: 
132: 		if (stream != nullptr) {
133: 			delete stream;
134: 		}
135: 	}
136: 
137: 	bool OpenPsf::is_our_path(const char* aFilename)
138: 	{
139: 		const char* ext = strrchr(aFilename, '.');
140: 		if (!ext) {
141: 			return Psf::is_our_path(aFilename, aFilename);
142: 		}
143: 		return Psf::is_our_path(aFilename, ext + 1);
144: 	}
145: 
146: 	result OpenPsf::load(const char* aFilename, bool suppressOpeningSilence)
147: 	{
148: 		mBaseSamplerate = 0;
149: 
150: 		if (aFilename == nullptr) {
151: 			return INVALID_PARAMETER;
152: 		}
153: 
154: 		if (! fileExists(aFilename)) {
155: 			return FILE_NOT_FOUND;
156: 		}
157: 
158: 		stop();
159: 
160: 		stream = new Psf(suppressOpeningSilence ? PsfFlags::SuppressOpeningSilence : PsfFlags::PsfDefaults, 0);
161: 		if (!stream->open(aFilename, true)) {
162: 			ffnx_error("Cannot open file %s: %s\n%s\n", aFilename, stream->get_last_error(), stream->get_last_status());
163: 			return FILE_LOAD_FAILED;
164: 		}
165: 
166: 		mBaseSamplerate = float(stream->get_sample_rate());
167: 		mSampleCount = stream->get_sample_count();
168: 		mChannels = stream->get_channel_count();
169: 		setLooping(true);
170: 
171: 		if (trace_all || trace_music) ffnx_info("Opening file %s with openPSF (samplerate: %i, samplecount: %i, channels: %i):\n%s\n",
172: 			aFilename, int(mBaseSamplerate), stream->get_sample_count(), mChannels, stream->get_last_status());
173: 
174: 		return SO_NO_ERROR;
175: 	}
176: 
177: 	AudioSourceInstance* OpenPsf::createInstance()
178: 	{
179: 		return new OpenPsfInstance(this);
180: 	}
181: 
182: 	double OpenPsf::getLength()
183: 	{
184: 		if (mBaseSamplerate == 0) {
185: 			return 0;
186: 		}
187: 
188: 		return mSampleCount / mBaseSamplerate;
189: 	}
190: };
</file>

<file path="src/audio/openpsf/openpsf.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <soloud.h>
25: #include <stdint.h>
26: #include <openpsf/openpsf.h>
27: 
28: namespace SoLoud
29: {
30: 	class OpenPsf : public AudioSource
31: 	{
32: 	public:
33: 		Psf* stream;
34: 		unsigned int mSampleCount;
35: 
36: 		OpenPsf();
37: 		virtual ~OpenPsf();
38: 		static bool is_our_path(const char* aFilename);
39: 		result load(const char* aFilename, bool suppressOpeningSilence = false);
40: 
41: 		virtual AudioSourceInstance* createInstance();
42: 		time getLength();
43: 	};
44: 
45: 	class OpenPsfInstance : public AudioSourceInstance
46: 	{
47: 		size_t mStreamBufferSize;
48: 		int16_t* mStreamBuffer;
49: 		OpenPsf* mParent;
50: 		unsigned int mOffset;
51: 		bool ended;
52: 	public:
53: 		OpenPsfInstance(OpenPsf* aParent);
54: 		virtual ~OpenPsfInstance();
55: 		virtual unsigned int getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
56: 		virtual result rewind();
57: 		virtual result seek(double aSeconds, float *mScratch, unsigned int mScratchSize);
58: 		virtual bool hasEnded();
59: 	};
60: };
</file>

<file path="src/audio/vgmstream/vgmstream.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "vgmstream.h"
 23: #include "../../utils.h"
 24: 
 25: namespace SoLoud
 26: {
 27: 	VGMStreamInstance::VGMStreamInstance(VGMStream* aParent)
 28: 	{
 29: 		mParent = aParent;
 30: 		mStreamBuffer = new sample_t[SAMPLE_GRANULARITY * aParent->mChannels];
 31: 
 32: 		rewind();
 33: 	}
 34: 
 35: 	VGMStreamInstance::~VGMStreamInstance()
 36: 	{
 37: 		delete[] mStreamBuffer;
 38: 	}
 39: 
 40: 	unsigned int VGMStreamInstance::getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize)
 41: 	{
 42: 		memset(mStreamBuffer, 0, sizeof(sample_t) * SAMPLE_GRANULARITY * mChannels);
 43: 		int sample_count = render_vgmstream2(mStreamBuffer, aSamplesToRead, mParent->mStream);
 44: 
 45: 		for (int j = 0; j < sample_count; j++)
 46: 		{
 47: 			for (unsigned int k = 0; k < mChannels; k++)
 48: 			{
 49: 				aBuffer[k * aSamplesToRead + j] = mStreamBuffer[(j * mChannels) + k] / (float)INT16_MAX;
 50: 			}
 51: 		}
 52: 
 53: 		mOffset += sample_count;
 54: 
 55: 		// If the song is looping, recalculate the offset correctly
 56: 		if (mFlags & AudioSourceInstance::LOOPING) {
 57: 			if (mOffset >= mParent->mStream->loop_end_sample)
 58: 			{
 59: 				mOffset = mOffset - mParent->mSampleCount + mParent->mStream->loop_start_sample;
 60: 			}
 61: 		}
 62: 
 63: 		return sample_count;
 64: 	}
 65: 
 66: 	result VGMStreamInstance::rewind()
 67: 	{
 68: 		reset_vgmstream(mParent->mStream);
 69: 
 70: 		mOffset = 0;
 71: 		mStreamPosition = 0.0f;
 72: 		return SO_NO_ERROR;
 73: 	}
 74: 
 75: 	result VGMStreamInstance::seek(double aSeconds, float* mScratch, unsigned int mScratchSize)
 76: 	{
 77: 		mOffset = int(floor(mSamplerate * aSeconds));
 78: 
 79: 		seek_vgmstream(mParent->mStream, mOffset);
 80: 
 81: 		mStreamPosition = aSeconds;
 82: 		return SO_NO_ERROR;
 83: 	}
 84: 
 85: 	bool VGMStreamInstance::hasEnded()
 86: 	{
 87: 		if (!(mFlags & AudioSourceInstance::LOOPING) && mOffset >= mParent->mSampleCount)
 88: 		{
 89: 			return 1;
 90: 		}
 91: 		return 0;
 92: 	}
 93: 
 94: 	VGMStream::VGMStream()
 95: 	{
 96: 		mSampleCount = 0;
 97: 	}
 98: 
 99: 	VGMStream::~VGMStream()
100: 	{
101: 		stop();
102: 
103: 		close_vgmstream(mStream);
104: 	}
105: 
106: 	VGMSTREAM* VGMStream::init_vgmstream_with_extension(const char* aFilename, const char* ext)
107: 	{
108: 		STREAMFILE* streamFile = open_stdio_streamfile(aFilename);
109: 		if (streamFile == nullptr) {
110: 			return nullptr;
111: 		}
112: 		// Force extension
113: 		streamFile = open_fakename_streamfile_f(streamFile, nullptr, ext);
114: 		if (streamFile == nullptr) {
115: 			return nullptr;
116: 		}
117: 		VGMSTREAM* stream = init_vgmstream_from_STREAMFILE(streamFile);
118: 		close_streamfile(streamFile);
119: 		return stream;
120: 	}
121: 
122: 	result VGMStream::load(const char* aFilename, const char* ext)
123: 	{
124: 		mBaseSamplerate = 0;
125: 
126: 		if (aFilename == 0)
127: 			return INVALID_PARAMETER;
128: 
129: 		if (! fileExists(aFilename))
130: 			return FILE_NOT_FOUND;
131: 
132: 		stop();
133: 
134: 		if (ext && ext[0] != '\0') {
135: 			mStream = init_vgmstream_with_extension(aFilename, ext);
136: 		}
137: 		else {
138: 			mStream = init_vgmstream(aFilename);
139: 		}
140: 
141: 		if (mStream == nullptr) {
142: 			return FILE_LOAD_FAILED;
143: 		}
144: 
145: 		mBaseSamplerate = (float)mStream->sample_rate;
146: 		mSampleCount = (unsigned int)mStream->num_samples;
147: 		mChannels = mStream->channels;
148: 
149: 		// Autodetect looping from the file itself and just inform SoLoud about it
150: 		if (mStream->loop_flag) setLooping(true);
151: 		// If the file has no loop tags, but the users wants to loop, force a basic start to end loop
152: 		else if (mFlags & AudioSourceInstance::LOOPING) vgmstream_force_loop(mStream, true, 0, mStream->num_samples);
153: 
154: 		return SO_NO_ERROR;
155: 	}
156: 
157: 	AudioSourceInstance* VGMStream::createInstance()
158: 	{
159: 		return new VGMStreamInstance(this);
160: 	}
161: 
162: 	double VGMStream::getLength()
163: 	{
164: 		if (mBaseSamplerate == 0)
165: 			return 0;
166: 
167: 		return mSampleCount / mBaseSamplerate;
168: 	}
169: };
</file>

<file path="src/audio/vgmstream/vgmstream.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <soloud.h>
25: 
26: #if defined(__cplusplus)
27: extern "C" {
28: #endif
29: 
30: #include <libvgmstream/vgmstream.h>
31: 
32: #if defined(__cplusplus)
33: }
34: #endif
35: 
36: namespace SoLoud
37: {
38: 	class VGMStream : public AudioSource
39: 	{
40: 		static VGMSTREAM* init_vgmstream_with_extension(const char* aFilename, const char* ext);
41: 	public:
42: 		VGMSTREAM* mStream;
43: 		unsigned int mSampleCount;
44: 
45: 		sample_t* mData;
46: 
47: 		VGMStream();
48: 		virtual ~VGMStream();
49: 		result load(const char* aFilename, const char* ext = nullptr);
50: 
51: 		virtual AudioSourceInstance* createInstance();
52: 		time getLength();
53: 	};
54: 
55: 	class VGMStreamInstance : public AudioSourceInstance
56: 	{
57: 		sample_t* mStreamBuffer;
58: 		VGMStream* mParent;
59: 		unsigned int mOffset;
60: 	public:
61: 		VGMStreamInstance(VGMStream* aParent);
62: 		virtual ~VGMStreamInstance();
63: 		virtual unsigned int getAudio(float* aBuffer, unsigned int aSamplesToRead, unsigned int aBufferSize);
64: 		virtual result rewind();
65: 		virtual result seek(double aSeconds, float *mScratch, unsigned int mScratchSize);
66: 		virtual bool hasEnded();
67: 	};
68: };
</file>

<file path="src/ff7/battle/animations.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
  10: //                                                                          //
  11: //    This file is part of FFNx                                             //
  12: //                                                                          //
  13: //    FFNx is free software: you can redistribute it and/or modify          //
  14: //    it under the terms of the GNU General Public License as published by  //
  15: //    the Free Software Foundation, either version 3 of the License         //
  16: //                                                                          //
  17: //    FFNx is distributed in the hope that it will be useful,               //
  18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  20: //    GNU General Public License for more details.                          //
  21: /****************************************************************************/
  22: 
  23: #include <unordered_set>
  24: #include <unordered_map>
  25: #include <intrin.h>
  26: #include <algorithm>
  27: 
  28: #include "../../ff7.h"
  29: #include "../../log.h"
  30: #include "../../patch.h"
  31: #include "../../globals.h"
  32: 
  33: #include "animations.h"
  34: #include "defs.h"
  35: #include "effect.h"
  36: #include "menu.h"
  37: #include "../widescreen.h"
  38: 
  39: namespace ff7::battle
  40: {
  41:     byte y_pos_offset_display_damage_30[] = {0, 1, 2, 3, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 7, 7, 6, 6, 5, 4, 3, 2};
  42:     byte y_pos_offset_display_damage_60[] = {0, 1, 2, 3, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7, 6, 6, 5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, 4, 4, 3, 2, 1, 0, 0, 1, 1, 0, 0, 0};
  43:     WORD ff7_odin_steel_frames_AEEC14;
  44:     std::map<uint32_t, std::set<short>> kotr_excluded_frames;
  45:     std::map<uint32_t, int> camera_thresholds_by_address, model_thresholds_by_address;
  46:     std::set<uint32_t> fixed_effect100_addresses, one_call_effect100_addresses, camera_effect100_addresses, model_effect100_addresses;
  47: 
  48:     std::array<AuxiliaryEffectHandler, 100> aux_effect100_handler;
  49:     std::array<AuxiliaryEffectHandler, 60> aux_effect60_handler;
  50:     std::array<AuxiliaryEffectHandler, 10> aux_effect10_handler;
  51: 
  52:     std::shared_ptr<EffectDecorator> currentEffectDecorator;
  53:     bool isAddFunctionDisabled = false;
  54: 
  55:     byte getActorIdleAnimScript(byte actorID)
  56:     {
  57:         return ff7_externals.g_actor_idle_scripts[actorID];
  58:     }
  59: 
  60:     battle_model_state *getBattleModelState(byte actorID)
  61:     {
  62:         return &(ff7_externals.g_battle_model_state[actorID]);
  63:     }
  64: 
  65:     battle_model_state_small *getSmallBattleModelState(byte actorID)
  66:     {
  67:         return &(ff7_externals.g_small_battle_model_state[actorID]);
  68:     }
  69: 
  70:     byte *getAnimScriptPointer(byte **ptrToScriptTable, battle_model_state &ownerModelState)
  71:     {
  72:         byte *scriptPtr = ptrToScriptTable[ownerModelState.animScriptIndex];
  73:         if (ownerModelState.animScriptIndex >= 0x2E && ownerModelState.animScriptIndex <= 0x3B && ownerModelState.animScriptIndex != 0x33)
  74:         {
  75:             if (ownerModelState.animScriptIndex == 0x39)
  76:                 ownerModelState.field_25 |= 0x80u;
  77:             scriptPtr = ff7_externals.animation_script_pointers[ownerModelState.animScriptIndex - 0x2E];
  78:         }
  79:         return scriptPtr;
  80:     }
  81: 
  82:     void run_animation_script(byte actorID, byte **ptrToScriptTable)
  83:     {
  84:         // creates copy of model states
  85:         battle_model_state ownerModelState = *getBattleModelState(actorID);
  86:         battle_model_state_small smallModelState = *getSmallBattleModelState(actorID);
  87: 
  88:         byte script_wait_frames = *ff7_externals.g_script_wait_frames;
  89:         bool hasSetWaitFrames = false;
  90: 
  91:         if (!*ff7_externals.g_is_battle_paused)
  92:         {
  93:             bool isScriptActive = true;
  94:             byte *scriptPtr = getAnimScriptPointer(ptrToScriptTable, ownerModelState);
  95: 
  96:             if (ownerModelState.modelEffectFlags & 1)
  97:             {
  98:                 ownerModelState.isScriptExecuting = 1;
  99:                 ownerModelState.currentScriptPosition = 0;
 100:                 ownerModelState.waitFrames = 0;
 101:             }
 102:             if (ownerModelState.isScriptExecuting)
 103:             {
 104:                 ownerModelState.playedAnimFrames = 0;
 105:                 while (isScriptActive)
 106:                 {
 107:                     byte currentOpCode = scriptPtr[ownerModelState.currentScriptPosition++];
 108: 
 109:                     switch (currentOpCode)
 110:                     {
 111:                     case 0xC5:
 112:                         ownerModelState.waitFrames = script_wait_frames;
 113:                         hasSetWaitFrames = true;
 114:                         break;
 115:                     case 0xC6:
 116:                         script_wait_frames = std::min(scriptPtr[ownerModelState.currentScriptPosition++] * battle_frame_multiplier, 255);
 117:                         break;
 118:                     case 0x9E:
 119:                         if (actorID == *ff7_externals.special_actor_id)
 120:                         {
 121:                             if (*ff7_externals.effect100_counter != 0)
 122:                                 ownerModelState.currentScriptPosition--;
 123:                         }
 124:                         else if (!(getBattleModelState(*ff7_externals.special_actor_id)->actorIsNotActing == 1 && *ff7_externals.effect100_counter == 0))
 125:                         {
 126:                             ownerModelState.currentScriptPosition--;
 127:                         }
 128:                         isScriptActive = false;
 129:                         break;
 130:                     case 0xB3:
 131:                         if ((smallModelState.field_0 & 0x1000) != 0)
 132:                         {
 133:                             byte position;
 134:                             do
 135:                                 position = scriptPtr[ownerModelState.currentScriptPosition++];
 136:                             while (position != 0xB2);
 137:                         }
 138:                         break;
 139:                     case 0xC1:
 140:                         ownerModelState.currentScriptPosition = 0;
 141:                         byte position;
 142:                         do
 143:                             position = scriptPtr[ownerModelState.currentScriptPosition++];
 144:                         while (position != 0xC9);
 145:                         break;
 146:                     case 0xCA:
 147:                         if (*ff7_externals.g_is_effect_loading)
 148:                         {
 149:                             ownerModelState.currentScriptPosition = 0;
 150:                             byte position;
 151:                             do
 152:                                 position = scriptPtr[ownerModelState.currentScriptPosition++];
 153:                             while (position != 0xC9);
 154:                         }
 155:                         break;
 156:                     case 0xCE:
 157:                         if (actorID >= 4)
 158:                         {
 159:                             byte position;
 160:                             do
 161:                                 position = scriptPtr[ownerModelState.currentScriptPosition++];
 162:                             while (position != 0xCD);
 163:                         }
 164:                         break;
 165:                     case 0xEB:
 166:                     case 0xEC:
 167:                         if (*ff7_externals.g_is_effect_loading)
 168:                         {
 169:                             ownerModelState.currentScriptPosition--;
 170:                             isScriptActive = false;
 171:                         }
 172:                         break;
 173:                     case 0xF3:
 174:                         if (ownerModelState.waitFrames != 0)
 175:                         {
 176:                             ownerModelState.waitFrames--;
 177:                             ownerModelState.currentScriptPosition--;
 178:                             isScriptActive = false;
 179:                         }
 180:                         break;
 181:                     case 0xF4:
 182:                         ownerModelState.waitFrames = std::min(scriptPtr[ownerModelState.currentScriptPosition++] * battle_frame_multiplier, 255);
 183:                         hasSetWaitFrames = true;
 184:                         break;
 185:                     case 0xFE:
 186:                         if (ownerModelState.waitFrames == 0)
 187:                         {
 188:                             currentOpCode = scriptPtr[ownerModelState.currentScriptPosition];
 189:                             if (currentOpCode == 0xC0)
 190:                             {
 191:                                 ownerModelState.currentScriptPosition = 0;
 192:                                 ownerModelState.waitFrames = 0;
 193:                                 ownerModelState.isScriptExecuting = 0;
 194:                                 ownerModelState.runningAnimIdx = *scriptPtr;
 195:                                 ownerModelState.animScriptIndex = getActorIdleAnimScript(actorID);
 196:                                 scriptPtr = ptrToScriptTable[ownerModelState.animScriptIndex];
 197:                             }
 198:                         }
 199:                         break;
 200:                     case 0xEE:
 201:                     case 0xFF:
 202:                         ownerModelState.actorIsNotActing = 1;
 203:                         ownerModelState.currentScriptPosition = 0;
 204:                         ownerModelState.isScriptExecuting = 0;
 205:                         ownerModelState.waitFrames = 0;
 206:                         ownerModelState.animScriptIndex = getActorIdleAnimScript(actorID);
 207:                         scriptPtr = ptrToScriptTable[ownerModelState.animScriptIndex];
 208:                         break;
 209:                     default:
 210:                         if (numArgsOpCode.contains(currentOpCode))
 211:                         {
 212:                             ownerModelState.currentScriptPosition += numArgsOpCode.at(currentOpCode);
 213:                             if (endingOpCode.contains(currentOpCode))
 214:                                 isScriptActive = false;
 215:                         }
 216:                         else
 217:                         {
 218:                             isScriptActive = false;
 219:                         }
 220:                         break;
 221:                     }
 222:                 }
 223:             }
 224:         }
 225: 
 226:         // execute original run animation script
 227:         ((void (*)(byte, byte **))ff7_externals.run_animation_script)(actorID, ptrToScriptTable);
 228: 
 229:         if(hasSetWaitFrames)
 230:             getBattleModelState(actorID)->waitFrames = ownerModelState.waitFrames;
 231:     }
 232: 
 233:     int add_fn_to_effect100_fn(uint32_t function)
 234:     {
 235:         int idx;
 236:         for (idx = 0; idx < ff7_externals.effect100_array_fn.size(); idx++)
 237:         {
 238:             if (ff7_externals.effect100_array_fn[idx] == 0 && *ff7_externals.effect100_array_idx <= idx)
 239:                 break;
 240:         }
 241:         if (idx >= ff7_externals.effect100_array_fn.size())
 242:             return 0xFFFF;
 243:         if (isAddFunctionDisabled)
 244:             return idx;
 245: 
 246:         ff7_externals.effect100_array_fn[idx] = function;
 247:         ff7_externals.effect100_array_data[idx].field_0 = *ff7_externals.effect100_array_idx;
 248:         *ff7_externals.effect100_counter = *ff7_externals.effect100_counter + 1;
 249: 
 250:         aux_effect100_handler[idx] = AuxiliaryEffectHandler();
 251:         return idx;
 252:     }
 253: 
 254:     void add_kotr_camera_fn_to_effect100_fn(DWORD param_1, DWORD param_2, WORD param_3)
 255:     {
 256:         ff7_externals.add_kotr_camera_fn_to_effect100_fn_476AAB(param_1, param_2, param_3);
 257: 
 258:         int kotr_camera_idx = ff7_externals.effect100_array_fn.size() - 1;
 259:         aux_effect100_handler[kotr_camera_idx] = AuxiliaryEffectHandler();
 260:     }
 261: 
 262:     void execute_effect100_fn()
 263:     {
 264:         uint16_t &fn_index = *ff7_externals.effect100_array_idx;
 265:         for (fn_index = 0; fn_index < ff7_externals.effect100_array_fn.size(); fn_index++)
 266:         {
 267:             if(ff7_externals.effect100_array_fn[fn_index] && *ff7_externals.g_is_battle_running_9AD1AC)
 268:             {
 269:                 if (aux_effect100_handler[fn_index].isFirstFrame())
 270:                 {
 271:                     if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.display_battle_action_text_42782A)
 272:                     {
 273:                         ff7_externals.effect100_array_data[fn_index].field_6 *= battle_frame_multiplier;
 274:                     }
 275:                     else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.battle_sub_425D29)
 276:                     {
 277:                         ff7_externals.effect100_array_data[fn_index].n_frames *= battle_frame_multiplier;
 278:                     }
 279:                     else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.battle_sub_5BDA0F)
 280:                     {
 281:                         ff7_externals.effect100_array_data[fn_index].field_2 /= battle_frame_multiplier;
 282:                         ff7_externals.effect100_array_data[fn_index].n_frames *= battle_frame_multiplier;
 283:                     }
 284:                     else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.tifa_limit_1_2_sub_4E3D51 ||
 285:                             ff7_externals.effect100_array_fn[fn_index] == ff7_externals.tifa_limit_2_1_sub_4E48D4)
 286:                     {
 287:                         ff7_externals.effect100_array_data[fn_index].field_1A *= battle_frame_multiplier;
 288:                     }
 289:                     else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.run_odin_steel_sub_4A9908)
 290:                     {
 291:                         ff7_odin_steel_frames_AEEC14 = *ff7_externals.field_odin_frames_AEEC14 * battle_frame_multiplier;
 292:                     }
 293:                     else if (fixed_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
 294:                     {
 295:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<NoEffectDecorator>());
 296:                     }
 297:                     else if (one_call_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
 298:                     {
 299:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<OneCallEffectDecorator>(battle_frame_multiplier));
 300:                     }
 301:                     else if (ff7_externals.effect100_array_fn[fn_index] == ff7_externals.run_chocobuckle_main_loop_560C32)
 302:                     {
 303:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<ModelInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, false,
 304:                                                                                                                             &ff7_externals.effect100_array_data[fn_index].field_0, 3, 10000));
 305:                     }
 306:                     else if(ff7_externals.effect100_array_fn[fn_index] == ff7_externals.barret_limit_4_1_model_movement_4698EF)
 307:                     {
 308:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<ModelInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, false,
 309:                                                                                                                             &ff7_externals.effect100_array_data[fn_index].field_0, *ff7_externals.barret_limit_4_1_actor_id, 3000));
 310:                     }
 311:                     else if (model_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
 312:                     {
 313:                         int threshold = 1000;
 314:                         if (model_thresholds_by_address.contains(ff7_externals.effect100_array_fn[fn_index]))
 315:                             threshold = model_thresholds_by_address[ff7_externals.effect100_array_fn[fn_index]];
 316:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<ModelInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, true,
 317:                                                                                                                             &ff7_externals.effect100_array_data[fn_index].field_0, 3, threshold));
 318:                     }
 319:                     else if (camera_effect100_addresses.contains(ff7_externals.effect100_array_fn[fn_index]))
 320:                     {
 321:                         int threshold = 1500;
 322:                         if (camera_thresholds_by_address.contains(ff7_externals.effect100_array_fn[fn_index]))
 323:                             threshold = camera_thresholds_by_address[ff7_externals.effect100_array_fn[fn_index]];
 324:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<CameraInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, &ff7_externals.effect100_array_data[fn_index].field_0, threshold));
 325:                     }
 326:                     else if (kotr_excluded_frames.contains(ff7_externals.effect100_array_fn[fn_index]))
 327:                     {
 328:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<FixCounterExceptionEffectDecorator>(battle_frame_multiplier, &ff7_externals.effect100_array_data[fn_index].field_0,
 329:                                                                                                                                 &ff7_externals.effect100_array_data[fn_index].field_2, &isAddFunctionDisabled, kotr_excluded_frames[ff7_externals.effect100_array_fn[fn_index]]));
 330:                     }
 331:                     else
 332:                     {
 333:                         aux_effect100_handler[fn_index].setEffectDecorator(std::make_shared<InterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused));
 334:                     }
 335: 
 336:                     if (trace_all || trace_battle_animation)
 337:                         ffnx_trace("%s - begin function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
 338:                                 ff7_externals.effect100_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
 339:                                 ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);
 340: 
 341:                     aux_effect100_handler[fn_index].disableFirstFrame();
 342:                 }
 343: 
 344:                 currentEffectDecorator = aux_effect100_handler[fn_index].getEffectDecorator();
 345:                 aux_effect100_handler[fn_index].executeEffectFunction(ff7_externals.effect100_array_fn[fn_index]);
 346:                 currentEffectDecorator = nullptr;
 347: 
 348:                 if (ff7_externals.effect100_array_data[fn_index].field_0 == (uint16_t)-1)
 349:                 {
 350:                     if (trace_all || trace_battle_animation)
 351:                         ffnx_trace("%s - end function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
 352:                                 ff7_externals.effect100_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
 353:                                 ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);
 354: 
 355:                     ff7_externals.effect100_array_data[fn_index].field_0 = 0;
 356:                     ff7_externals.effect100_array_data[fn_index].field_2 = 0;
 357:                     ff7_externals.effect100_array_fn[fn_index] = 0;
 358:                     *ff7_externals.effect100_counter = *ff7_externals.effect100_counter - 1;
 359:                 }
 360:             }
 361:             else if(ff7_externals.effect100_array_fn[fn_index] == ff7_externals.display_battle_action_text_42782A)
 362:             {
 363:                 if (aux_effect100_handler[fn_index].isFirstFrame())
 364:                 {
 365:                     ff7_externals.effect100_array_data[fn_index].field_6 *= battle_frame_multiplier;
 366:                     aux_effect100_handler[fn_index].disableFirstFrame();
 367:                 }
 368: 
 369:                 ((void (*)())ff7_externals.effect100_array_fn[fn_index])();
 370:             }
 371:         }
 372:         fn_index = 0;
 373:     }
 374: 
 375:     int add_fn_to_effect10_fn(uint32_t function)
 376:     {
 377:         int idx;
 378:         for (idx = 0; idx < ff7_externals.effect10_array_fn.size(); idx++)
 379:         {
 380:             if (ff7_externals.effect10_array_fn[idx] == 0 && *ff7_externals.effect10_array_idx <= idx)
 381:                 break;
 382:         }
 383:         if (idx >= ff7_externals.effect10_array_fn.size())
 384:             return 0xFFFF;
 385:         if (isAddFunctionDisabled)
 386:             return idx;
 387: 
 388:         ff7_externals.effect10_array_fn[idx] = function;
 389:         ff7_externals.effect10_array_data[idx].field_0 = *ff7_externals.effect10_array_idx;
 390:         *ff7_externals.effect10_counter = *ff7_externals.effect10_counter + 1;
 391: 
 392:         aux_effect10_handler[idx] = AuxiliaryEffectHandler();
 393:         return idx;
 394:     }
 395: 
 396:     void execute_effect10_fn()
 397:     {
 398:         uint16_t &fn_index = *ff7_externals.effect10_array_idx;
 399:         for (fn_index = 0; fn_index < ff7_externals.effect10_array_fn.size(); fn_index++)
 400:         {
 401:             auto &effect10_data = ff7_externals.effect10_array_data[fn_index];
 402:             if (ff7_externals.effect10_array_fn[fn_index] != 0)
 403:             {
 404:                 if (aux_effect10_handler[fn_index].isFirstFrame())
 405:                 {
 406:                     if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_426DE3)
 407:                     {
 408:                         // Related to resting positions
 409:                         effect10_data.n_frames *= battle_frame_multiplier;
 410:                         effect10_data.field_18 *= battle_frame_multiplier;
 411:                         effect10_data.field_C /= battle_frame_multiplier;
 412:                         effect10_data.field_E /= battle_frame_multiplier;
 413:                         effect10_data.field_6 /= battle_frame_multiplier;
 414:                     }
 415:                     else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_426941)
 416:                     {
 417:                         // Increment model position X and Z for n_frames
 418:                         // Used by Tonberry to set the position after its moving animation
 419:                         if(effect10_data.n_frames > 1)
 420:                         {
 421:                             effect10_data.n_frames *= battle_frame_multiplier;
 422:                             effect10_data.field_A /= battle_frame_multiplier;
 423:                             effect10_data.field_C /= battle_frame_multiplier;
 424:                         }
 425:                     }
 426:                     else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_426899)
 427:                     {
 428:                         // Related to resting Y rotation
 429:                         effect10_data.n_frames *= battle_frame_multiplier;
 430:                         effect10_data.field_E /= battle_frame_multiplier;
 431:                     }
 432:                     else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_sub_4267F1)
 433:                     {
 434:                         // Related to resting Y position
 435:                         effect10_data.n_frames *= battle_frame_multiplier;
 436:                         effect10_data.field_A /= battle_frame_multiplier;
 437:                     }
 438:                     else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_426A26)
 439:                     {
 440:                         // Animation of moving characters from attacker to attacked
 441:                         effect10_data.n_frames *= battle_frame_multiplier;
 442:                         effect10_data.field_18 *= battle_frame_multiplier;
 443:                         effect10_data.field_C /= battle_frame_multiplier;
 444:                         effect10_data.field_E /= battle_frame_multiplier;
 445:                     }
 446:                     else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_42739D)
 447:                     {
 448:                         // Animation of moving characters from attacker to attacked
 449:                         effect10_data.n_frames *= battle_frame_multiplier;
 450:                         effect10_data.field_19 *= battle_frame_multiplier;
 451:                         effect10_data.field_1A *= battle_frame_multiplier;
 452:                         effect10_data.field_C /= battle_frame_multiplier;
 453:                         effect10_data.field_E /= battle_frame_multiplier;
 454:                     }
 455:                     else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_426F58)
 456:                     {
 457:                         effect10_data.n_frames *= battle_frame_multiplier;
 458:                         // Do not modify the others, already done elsewhere
 459:                     }
 460:                     else if (ff7_externals.effect10_array_fn[fn_index] == ff7_externals.battle_move_character_sub_4270DE)
 461:                     {
 462:                         // Animation of moving characters for some limit breaks from attacker to attacked
 463:                         effect10_data.n_frames *= battle_frame_multiplier;
 464:                         effect10_data.field_19 *= battle_frame_multiplier;
 465:                         effect10_data.field_1A *= battle_frame_multiplier;
 466:                         effect10_data.field_C /= battle_frame_multiplier;
 467:                         effect10_data.field_E /= battle_frame_multiplier;
 468:                         effect10_data.field_14 /= battle_frame_multiplier;
 469:                     }
 470:                     if (trace_all || trace_battle_animation)
 471:                         ffnx_trace("%s - begin function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
 472:                                 ff7_externals.effect10_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
 473:                                 ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);
 474: 
 475:                     aux_effect10_handler[fn_index].disableFirstFrame();
 476:                 }
 477: 
 478:                 ((void (*)())ff7_externals.effect10_array_fn[fn_index])();
 479: 
 480:                 if (effect10_data.field_0 == (uint16_t)-1)
 481:                 {
 482:                     if (trace_all || trace_battle_animation)
 483:                         ffnx_trace("%s - end function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
 484:                                 ff7_externals.effect10_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
 485:                                 ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);
 486: 
 487:                     effect10_data.field_0 = 0;
 488:                     effect10_data.field_2 = 0;
 489:                     ff7_externals.effect10_array_fn[fn_index] = 0;
 490:                     *ff7_externals.effect10_counter = *ff7_externals.effect10_counter - 1;
 491:                 }
 492:             }
 493:         }
 494:         fn_index = 0;
 495:     }
 496: 
 497:     int add_fn_to_effect60_fn(uint32_t function)
 498:     {
 499:         int idx;
 500:         for (idx = 0; idx < ff7_externals.effect60_array_fn.size(); idx++)
 501:         {
 502:             if (ff7_externals.effect60_array_fn[idx] == 0 && *ff7_externals.effect60_array_idx <= idx)
 503:                 break;
 504:         }
 505:         if (idx >= ff7_externals.effect60_array_fn.size())
 506:             return 0xFFFF;
 507:         if (isAddFunctionDisabled)
 508:             return idx;
 509: 
 510:         ff7_externals.effect60_array_fn[idx] = function;
 511:         ff7_externals.effect60_array_data[idx].field_0 = *ff7_externals.effect60_array_idx;
 512:         *ff7_externals.effect60_counter = *ff7_externals.effect60_counter + 1;
 513: 
 514:         aux_effect60_handler[idx] = AuxiliaryEffectHandler();
 515:         return idx;
 516:     }
 517: 
 518:     void execute_effect60_fn()
 519:     {
 520:         uint16_t &fn_index = *ff7_externals.effect60_array_idx;
 521:         for (fn_index = 0; fn_index < ff7_externals.effect60_array_fn.size(); fn_index++)
 522:         {
 523:             if (ff7_externals.effect60_array_fn[fn_index] != 0)
 524:             {
 525:                 if (aux_effect60_handler[fn_index].isFirstFrame())
 526:                 {
 527:                     if (ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_4276B6 ||
 528:                         ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_4255B7 ||
 529:                         ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_427737 ||
 530:                         ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_425AAD ||
 531:                         ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_427AF1 ||
 532:                         ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_4277B1)
 533:                     {
 534:                         ff7_externals.effect60_array_data[fn_index].n_frames *= battle_frame_multiplier;
 535:                     }
 536:                     else if (ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5BD96D)
 537:                     {
 538:                         ff7_externals.effect60_array_data[fn_index].n_frames *= battle_frame_multiplier;
 539:                         ff7_externals.effect60_array_data[fn_index].field_2 /= battle_frame_multiplier;
 540:                     }
 541:                     else if (ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_425E5F ||
 542:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5C1C8F ||
 543:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5BCF9D ||
 544:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.handle_aura_effects_425520 ||
 545:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_boss_death_sub_5BC5EC ||
 546:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5BCD42 ||
 547:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.display_battle_damage_5BB410 ||
 548:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.limit_break_aura_effects_5C0572 ||
 549:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.enemy_skill_aura_effects_5C06BF ||
 550:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.summon_aura_effects_5C0953 ||
 551:                             ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_sub_5C18BC)
 552:                     {
 553:                         aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<NoEffectDecorator>());
 554:                     }
 555:                     else if(ff7_externals.effect60_array_fn[fn_index] == ff7_externals.battle_smoke_move_handler_5BE4E2)
 556:                     {
 557:                         aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<OneCallEffectDecorator>(battle_frame_multiplier));
 558:                     }
 559:                     else if(ff7_externals.effect60_array_fn[fn_index] == ff7_externals.vincent_limit_satan_slam_camera_45CF2A)
 560:                     {
 561:                         aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<CameraInterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused, &ff7_externals.effect60_array_data[fn_index].field_0));
 562:                     }
 563:                     else
 564:                     {
 565:                         aux_effect60_handler[fn_index].setEffectDecorator(std::make_shared<InterpolationEffectDecorator>(battle_frame_multiplier, ff7_externals.g_is_battle_paused));
 566:                     }
 567: 
 568:                     if (trace_all || trace_battle_animation)
 569:                         ffnx_trace("%s - begin function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
 570:                                 ff7_externals.effect60_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
 571:                                 ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);
 572: 
 573:                     aux_effect60_handler[fn_index].disableFirstFrame();
 574:                 }
 575: 
 576:                 currentEffectDecorator = aux_effect60_handler[fn_index].getEffectDecorator();
 577:                 aux_effect60_handler[fn_index].executeEffectFunction(ff7_externals.effect60_array_fn[fn_index]);
 578:                 currentEffectDecorator = nullptr;
 579: 
 580:                 if (ff7_externals.effect60_array_data[fn_index].field_0 == (uint16_t)-1)
 581:                 {
 582:                     if (trace_all || trace_battle_animation)
 583:                         ffnx_trace("%s - end function[%d]: 0x%x (actor_id: %d,last command: 0x%02X, 0x%04X)\n", __func__, fn_index,
 584:                                 ff7_externals.effect60_array_fn[fn_index], ff7_externals.anim_event_queue[0].attackerID,
 585:                                 ff7_externals.battle_context->lastCommandIdx, ff7_externals.battle_context->lastActionIdx);
 586: 
 587:                     ff7_externals.effect60_array_data[fn_index].field_0 = 0;
 588:                     ff7_externals.effect60_array_data[fn_index].field_2 = 0;
 589:                     ff7_externals.effect60_array_fn[fn_index] = 0;
 590:                     *ff7_externals.effect60_counter = *ff7_externals.effect60_counter - 1;
 591:                 }
 592:             }
 593:         }
 594:         fn_index = 0;
 595:     }
 596: 
 597:     void run_boss_death_animation_5BC5EC()
 598:     {
 599:         auto &fn_data = ff7_externals.effect60_array_data[*ff7_externals.effect60_array_idx];
 600:         if (fn_data.n_frames == 0)
 601:         {
 602:             fn_data.field_0 = 0xFFFF;
 603:         }
 604:         else
 605:         {
 606:             if (fn_data.n_frames == (58 * battle_frame_multiplier) || fn_data.n_frames == (64 * battle_frame_multiplier))
 607:                 *ff7_externals.field_battle_BFB2E0 = ((uint32_t(*)(byte, byte, byte))ff7_externals.battle_boss_death_call_5BD436)(0xFA, 0xFA, 0xFA);
 608: 
 609:             std::array<short, 8> offset_z_position{64, 32, 0, -32, -64, -32, 0, 32};
 610:             int index = ((fn_data.n_frames * (4 / battle_frame_multiplier)) % offset_z_position.size());
 611:             getBattleModelState(fn_data.field_8)->modelPosition.z = fn_data.field_A + offset_z_position[index];
 612:             fn_data.n_frames--;
 613:         }
 614:     }
 615: 
 616:     int get_n_frames_display_action_string()
 617:     {
 618:         int shiftValue = 2 - battle_frame_multiplier / 2;
 619:         return ((int)*ff7_externals.field_byte_DC0E11 >> shiftValue) + 4 * battle_frame_multiplier;
 620:     }
 621: 
 622:     void run_disintegrate_1_death_sub_5BC04D(byte effect10_array_idx)
 623:     {
 624:         auto &fn_data = ff7_externals.effect10_array_data[effect10_array_idx];
 625:         auto &battle_model_state = *getBattleModelState(fn_data.field_8);
 626:         if (fn_data.n_frames == 0)
 627:         {
 628:             fn_data.field_0 = 0xFFFF;
 629:             battle_model_state.field_25 &= 0x7F;
 630:             battle_model_state.field_C &= 0xFFDF;
 631:             battle_model_state.actorIsNotActing = 1;
 632:             ((void (*)(byte))ff7_externals.battle_sub_42C0A7)(fn_data.field_8);
 633:         }
 634:         else
 635:         {
 636:             battle_model_state.field_14 += 0x80 / battle_frame_multiplier;
 637:             if (battle_model_state.field_28 > 0)
 638:                 battle_model_state.field_28 -= 0x10 / battle_frame_multiplier;
 639: 
 640:             battle_model_state.field_1AC8 = 1;
 641: 
 642:             // effect10_array_data_8FE1F6 is a short array of 15 size. To avoid overflowing, divide also the index
 643:             battle_model_state.field_1ADC += (float)(int)ff7_externals.effect10_array_data_8FE1F6[(int)(fn_data.n_frames / battle_frame_multiplier)] / battle_frame_multiplier;
 644:             battle_model_state.field_1ACC += 22.5f / battle_frame_multiplier;
 645:             battle_model_state.field_1AD0 += 22.5f / battle_frame_multiplier;
 646:             battle_model_state.field_1AD4 += 22.5f / battle_frame_multiplier;
 647:             fn_data.n_frames--;
 648:         }
 649:     }
 650: 
 651:     void battle_move_character_sub_426F58()
 652:     {
 653:         auto &fn_data = ff7_externals.effect10_array_data[*ff7_externals.effect10_array_idx];
 654:         if (fn_data.n_frames == 0)
 655:         {
 656:             fn_data.field_0 = 0xFFFF;
 657:         }
 658:         else
 659:         {
 660:             *ff7_externals.g_script_args[2] = fn_data.field_A;
 661:             *ff7_externals.g_script_args[3] = fn_data.field_8;
 662:             *ff7_externals.g_script_args[4] = fn_data.field_10;
 663:             getBattleModelState(*ff7_externals.g_script_args[3])->modelPosition.x += fn_data.field_C / battle_frame_multiplier;
 664:             getBattleModelState(*ff7_externals.g_script_args[3])->modelPosition.z += fn_data.field_E / battle_frame_multiplier;
 665: 
 666:             int index = (int)(fn_data.field_18 / battle_frame_multiplier) + *ff7_externals.g_script_args[4] * 8; // to avoid overflow
 667:             getBattleModelState(*ff7_externals.g_script_args[3])->modelPosition.y += ff7_externals.resting_Y_array_data[index] / battle_frame_multiplier;
 668:             fn_data.field_18++;
 669:             fn_data.n_frames--;
 670:         }
 671:     }
 672: 
 673:     void battle_play_sfx_delayed_427737()
 674:     {
 675:         constexpr byte cid_id = 0x08;
 676:         constexpr short cloud_sfx_attack_id = 18;
 677: 
 678:         byte actor_id = ff7_externals.anim_event_queue[0].attackerID;
 679:         auto &fn_data = ff7_externals.effect60_array_data[*ff7_externals.effect60_array_idx];
 680: 
 681:         // Disable bugged battle SFX when Cid is attacking, but SFX ID is cloud's one
 682:         if(ff7_externals.battle_context->actor_vars[actor_id].index == cid_id && fn_data.field_6 == cloud_sfx_attack_id)
 683:         {
 684:             fn_data.field_0 = 0xFFFF;
 685:         }
 686:         else
 687:         {
 688:             if ( fn_data.n_frames )
 689:             {
 690:                 fn_data.n_frames--;
 691:             }
 692:             else
 693:             {
 694:                 ff7_externals.battle_play_sfx_sound_430D32(fn_data.field_6, *ff7_externals.g_active_actor_id, 0);
 695:                 fn_data.field_0 = 0xFFFF;
 696:             }
 697:         }
 698:     }
 699: 
 700:     void run_ifrit_movement_596702()
 701:     {
 702:         auto &effect_data = ff7_externals.effect100_array_data[*ff7_externals.effect100_array_idx];
 703:         vector3<short> &ifrit_position = *ff7_externals.battle_ifrit_model_position;
 704: 
 705:         int frames = effect_data.field_2;
 706:         if((*ff7_externals.byte_BCC788 & 1) == 0)
 707:         {
 708:             *ff7_externals.byte_BCC788 |= 1u;
 709:             *ff7_externals.ifrit_vector3_int_ptr_BCC6A8 = ff7_externals.battle_sub_661000(0);
 710:         }
 711:         std::vector<int> ifrit_og_phases = {0, 30, 131, 146, 149, 169};
 712:         std::vector<int> ifrit_new_phases;
 713:         std::transform(ifrit_og_phases.begin(), ifrit_og_phases.end(), std::back_inserter(ifrit_new_phases), [](int value){return value * battle_frame_multiplier;});
 714:         if(!*ff7_externals.g_is_battle_paused)
 715:         {
 716:             if(frames >= ifrit_new_phases[0] && frames < ifrit_new_phases[1])
 717:             {
 718:                 int internal_frames = frames - ifrit_new_phases[0];
 719:                 ifrit_position.y = -2000 * internal_frames / (ifrit_new_phases[1] - ifrit_new_phases[0]);
 720:             }
 721:             else if(frames >= ifrit_new_phases[2] && frames < ifrit_new_phases[3])
 722:             {
 723:                 short previous_position = -2000 * (ifrit_new_phases[1] - 1) / (ifrit_new_phases[1] - ifrit_new_phases[0]);
 724:                 int internal_frames = frames - ifrit_new_phases[2];
 725:                 ifrit_position.y = previous_position - 150 * (internal_frames + 1) / (ifrit_new_phases[3] - ifrit_new_phases[2]);
 726:                 ifrit_position.z -= 20 / battle_frame_multiplier;
 727:             }
 728:             else if(frames >= ifrit_new_phases[3] && frames < ifrit_new_phases[4])
 729:             {
 730:                 ifrit_position.y += 1000 / battle_frame_multiplier;
 731:                 ifrit_position.z += 2000 / battle_frame_multiplier;
 732:             }
 733:             else if(frames >= ifrit_new_phases[4] && frames < ifrit_new_phases[5])
 734:             {
 735:                 int internal_frames = frames - ifrit_new_phases[4];
 736:                 ifrit_position.x = 0;
 737:                 ifrit_position.y = 500;
 738:                 ifrit_position.z = 30000 * internal_frames / (ifrit_new_phases[5] - ifrit_new_phases[4]) - 5000;
 739:             }
 740:             else if(frames >= ifrit_new_phases[5])
 741:             {
 742:                 effect_data.field_0 = (uint16_t)-1;
 743:                 return;
 744:             }
 745: 
 746:             ff7_externals.engine_set_game_engine_rot_matrix_663673(ff7_externals.ifrit_rot_matrix_BCC768);
 747:             ff7_externals.engine_set_game_engine_position_663707(ff7_externals.ifrit_rot_matrix_BCC768);
 748:             ff7_externals.engine_apply_translation_with_delta_662ECC(ff7_externals.battle_ifrit_model_position, *ff7_externals.ifrit_vector3_int_ptr_BCC6A8, &(*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)[1].y);
 749:             getBattleModelState(3)->modelPosition.x = (*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)->x;
 750:             getBattleModelState(3)->modelPosition.y = (*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)->y;
 751:             getBattleModelState(3)->modelPosition.z = (*ff7_externals.ifrit_vector3_int_ptr_BCC6A8)->z;
 752:             effect_data.field_2++;
 753:         }
 754:     }
 755: 
 756:     int battle_animate_material_texture(material_anim_ctx *materialCtx, int a2, int a3, int retVal)
 757:     {
 758:         float field_8_float, field_8_float_shifted;
 759:         int alpha, only_color_no_alpha, field_C;
 760:         p_hundred *aux_gfx;
 761:         struc_173 *palette_aux;
 762:         color_ui8 color;
 763:         rotation_matrix *rot_matrix;
 764:         struc_84 *draw_chain;
 765:         ff7_game_obj *game_object;
 766:         ff7_polygon_set *poly_set;
 767:         uint32_t *materialRSD;
 768: 
 769:         palette_extra &palette_extra_data = *ff7_externals.palette_extra_data_C06A00;
 770: 
 771:         // Interpolation of material texture with previous frame data if available
 772:         std::shared_ptr<InterpolationEffectDecorator> effectDecorator = std::dynamic_pointer_cast<InterpolationEffectDecorator>(currentEffectDecorator);
 773:         if (effectDecorator)
 774:         {
 775:             uint32_t uniqueID = (uint32_t)_ReturnAddress();
 776:             if (!effectDecorator->doInterpolation())
 777:             {
 778:                 interpolationable_data currData;
 779:                 currData.rot_matrix = *ff7_externals.get_global_model_matrix_buffer_66100D();
 780:                 currData.material_ctx = *materialCtx;
 781:                 currData.color = ff7_externals.get_stored_color_66101A();
 782:                 currData.palette = *ff7_externals.palette_extra_data_C06A00;
 783:                 effectDecorator->saveInterpolationData(std::move(currData), uniqueID);
 784:             }
 785:             else
 786:             {
 787:                 effectDecorator->interpolateRotationMatrix(ff7_externals.get_global_model_matrix_buffer_66100D(), uniqueID);
 788:                 effectDecorator->interpolateMaterialContext(*materialCtx, uniqueID);
 789:                 effectDecorator->interpolateColor(&(*ff7_externals.global_game_engine_data)->secondary_color, uniqueID);
 790:                 effectDecorator->interpolatePalette(palette_extra_data, uniqueID);
 791:             }
 792:             effectDecorator->addTextureIndex();
 793:         }
 794:         // -----------------------------------------------
 795: 
 796:         if (!ff7_externals.battle_sub_66C3BF())
 797:         {
 798:             palette_extra_data.field_1C = 0;
 799:             palette_extra_data.field_20 = 0;
 800:             palette_extra_data.scroll_v = 0;
 801:             palette_extra_data.field_28 = 0;
 802:             return retVal;
 803:         }
 804:         materialRSD = materialCtx->materialRSD;
 805:         if (materialCtx->materialRSD)
 806:         {
 807:             if (materialRSD[1])
 808:             {
 809:                 rot_matrix = ff7_externals.get_global_model_matrix_buffer_66100D();
 810:                 game_object = (ff7_game_obj *)common_externals.get_game_object();
 811:                 poly_set = (ff7_polygon_set*) materialRSD[1];
 812:                 draw_chain = ff7_externals.get_draw_chain_68F860(&poly_set->field_14, poly_set->field_14.graphics_instance);
 813:                 if (draw_chain)
 814:                 {
 815:                     draw_chain->field_4 = 1;
 816:                     aux_gfx = ff7_externals.battle_sub_5D1AAA(0, poly_set);
 817:                     palette_aux = &draw_chain->struc_173;
 818:                     if ((materialCtx->negateColumnFlags & 0x80) != 0)
 819:                     {
 820:                         alpha = ff7_externals.get_alpha_from_transparency_429343(materialCtx->transparency);
 821:                     }
 822:                     else if (materialCtx->transparency >= 128)
 823:                     {
 824:                         alpha = 255;
 825:                     }
 826:                     else
 827:                     {
 828:                         alpha = 2 * materialCtx->transparency;
 829:                     }
 830:                     color = ff7_externals.get_stored_color_66101A();
 831:                     if (game_object->current_gfx_driver != 1)
 832:                     {
 833:                         if (*(DWORD*)&color == -16777216)
 834:                             ff7_externals.battle_sub_68CF75(10, palette_aux);
 835:                         else
 836:                             ff7_externals.battle_sub_68CF75(9, palette_aux);
 837:                         draw_chain->struc_173.color = color;
 838:                         draw_chain->struc_173.color.a = alpha;
 839:                         goto ANIMATE_MATERIAL_2;
 840:                     }
 841:                     only_color_no_alpha = *(DWORD *)&color & 0xFFFFFF;
 842:                     if ((materialCtx->negateColumnFlags & 0x10) != 0)
 843:                     {
 844:                         if (only_color_no_alpha)
 845:                         {
 846:                             ff7_externals.battle_sub_68CF75(11, palette_aux);
 847:                         ANIMATE_MATERIAL_1:
 848:                             draw_chain->struc_173.color = color;
 849:                             draw_chain->struc_173.color.a = alpha;
 850:                         ANIMATE_MATERIAL_2:
 851:                             field_C = materialCtx->field_C & 0xFFFFFFDF;
 852:                             if (field_C && field_C < 2)
 853:                             {
 854:                                 draw_chain->struc_173.setrenderstate = 1;
 855:                                 aux_gfx = (p_hundred*)*((DWORD*)&poly_set->struc_173 + field_C);
 856:                             }
 857:                             if (palette_extra_data.field_28)
 858:                             {
 859:                                 draw_chain->struc_173.setrenderstate = 1;
 860:                                 aux_gfx = palette_extra_data.aux_gfx_ptr;
 861:                                 palette_extra_data.field_28 = 0;
 862:                             }
 863:                             if (materialCtx->field_8)
 864:                             {
 865:                                 draw_chain->struc_173.scroll_uv = 2;
 866:                                 field_8_float = (byte)materialCtx->field_8;
 867:                                 field_8_float_shifted = ((int)materialCtx->field_8 >> 8);
 868:                                 draw_chain->struc_173.u_offset = field_8_float * 0.00390625;
 869:                                 draw_chain->struc_173.v_offset = field_8_float_shifted * 0.00390625;
 870:                             }
 871:                             else
 872:                             {
 873:                                 draw_chain->struc_173.scroll_uv = 1;
 874:                             }
 875:                             if (materialCtx->paletteIdx)
 876:                             {
 877:                                 draw_chain->struc_173.change_palette = 1;
 878:                                 draw_chain->struc_173.palette_index = materialCtx->paletteIdx >> 6;
 879:                             }
 880:                             else
 881:                             {
 882:                                 draw_chain->struc_173.change_palette = 0;
 883:                                 draw_chain->struc_173.palette_index = 0;
 884:                             }
 885:                             if (palette_extra_data.field_1C)
 886:                             {
 887:                                 draw_chain->struc_173.add_offsets = 1;
 888:                                 draw_chain->struc_173.x_offset = palette_extra_data.x_offset;
 889:                                 draw_chain->struc_173.y_offset = palette_extra_data.y_offset;
 890:                                 draw_chain->struc_173.z_offset = palette_extra_data.z_offset;
 891:                                 palette_extra_data.field_1C = 0;
 892:                             }
 893:                             if (palette_extra_data.field_20)
 894:                             {
 895:                                 draw_chain->struc_173.field_7 = palette_extra_data.field_24;
 896:                                 draw_chain->struc_173.z_offset2 = palette_extra_data.z_offset_2;
 897:                                 palette_extra_data.field_20 = 0;
 898:                             }
 899:                             if (palette_extra_data.scroll_v)
 900:                             {
 901:                                 draw_chain->struc_173.scroll_v = palette_extra_data.scroll_v;
 902:                                 draw_chain->struc_173.v_offset = palette_extra_data.v_offset;
 903:                                 palette_extra_data.scroll_v = 0;
 904:                             }
 905:                             draw_chain->struc_173.hundred_data = aux_gfx;
 906:                             ff7_externals.create_rot_matrix_from_word_matrix_6617E9(rot_matrix, &draw_chain->matrix);
 907:                             if ((materialCtx->negateColumnFlags & 7) != 0)
 908:                             {
 909:                                 if ( (materialCtx->negateColumnFlags & 1) != 0 )
 910:                                 {
 911:                                     draw_chain->matrix.m[0][0] = -draw_chain->matrix.m[0][0];
 912:                                     draw_chain->matrix.m[0][1] = -draw_chain->matrix.m[0][1];
 913:                                     draw_chain->matrix.m[0][2] = -draw_chain->matrix.m[0][2];
 914:                                 }
 915:                                 if ( (materialCtx->negateColumnFlags & 2) != 0 )
 916:                                 {
 917:                                     draw_chain->matrix.m[1][0] = -draw_chain->matrix.m[1][0];
 918:                                     draw_chain->matrix.m[1][1] = -draw_chain->matrix.m[1][1];
 919:                                     draw_chain->matrix.m[1][2] = -draw_chain->matrix.m[1][2];
 920:                                 }
 921:                                 if ( (materialCtx->negateColumnFlags & 4) != 0 )
 922:                                 {
 923:                                     draw_chain->matrix.m[2][0] = -draw_chain->matrix.m[2][0];
 924:                                     draw_chain->matrix.m[2][1] = -draw_chain->matrix.m[2][1];
 925:                                     draw_chain->matrix.m[2][2] = -draw_chain->matrix.m[2][2];
 926:                                 }
 927:                             }
 928:                             return retVal;
 929:                         }
 930:                     }
 931:                     else if (only_color_no_alpha && alpha != 255)
 932:                     {
 933:                         ff7_externals.battle_sub_68CF75(13, palette_aux);
 934:                         goto ANIMATE_MATERIAL_1;
 935:                     }
 936:                     ff7_externals.battle_sub_68CF75(12, palette_aux);
 937:                     goto ANIMATE_MATERIAL_1;
 938:                 }
 939:             }
 940:         }
 941:         return retVal;
 942:     }
 943: 
 944:     int battle_animate_texture_spt(texture_spt_anim_ctx *texture_ctx, int a2, int a3, int retVal)
 945:     {
 946:         bool flag;
 947:         color_ui8 color_rgba;
 948:         WORD texture_field_C;
 949:         byte blue_color;
 950:         byte green_color;
 951:         byte red_color;
 952:         int page_idx, tex_page_idx, palette_idx;
 953:         float x_left, y_top;
 954:         float u_right, u_left, u_left_1, u_left_2, u_scale;
 955:         float v_top, v_bottom, v_top_1, v_top_2, v_scale;
 956:         float quad_width, quad_height;
 957:         struc_84 *draw_chain;
 958:         struc_186 *drawable_state;
 959:         page_spt *page_spt_ptr;
 960:         tex_page_list *page_list;
 961:         rotation_matrix *rot_matrix;
 962:         ff7_graphics_object *drawable;
 963:         texture_spt *effect_spt;
 964: 
 965:         // Interpolation of texture SPT with previous frame data if available
 966:         std::shared_ptr<InterpolationEffectDecorator> effectDecorator = std::dynamic_pointer_cast<InterpolationEffectDecorator>(currentEffectDecorator);
 967:         if (effectDecorator && effectDecorator->getTextureNumCalls() == 1)
 968:         {
 969:             uint32_t uniqueID = (uint32_t)_ReturnAddress();
 970:             if (!effectDecorator->doInterpolation())
 971:             {
 972:                 interpolationable_data currData;
 973:                 currData.rot_matrix = *ff7_externals.get_global_model_matrix_buffer_66100D();
 974:                 currData.color = texture_ctx->color;
 975:                 effectDecorator->saveInterpolationData(std::move(currData), uniqueID);
 976:             }
 977:             else
 978:             {
 979:                 effectDecorator->interpolateRotationMatrix(ff7_externals.get_global_model_matrix_buffer_66100D(), uniqueID);
 980:                 effectDecorator->interpolateColor(&texture_ctx->color, uniqueID);
 981:             }
 982:             effectDecorator->addTextureIndex();
 983:         }
 984:         // -----------------------------------------------
 985: 
 986:         if (!ff7_externals.battle_sub_66C3BF())
 987:             return retVal;
 988: 
 989:         rot_matrix = ff7_externals.get_global_model_matrix_buffer_66100D();
 990:         effect_spt = texture_ctx->effect_spt;
 991:         drawable = texture_ctx->effectDrawable;
 992:         if (texture_ctx->effect_spt && drawable && drawable->hundred_data && drawable->hundred_data->texture_set)
 993:         {
 994:             flag = (texture_ctx->field_C & 0x8000u) != 0;
 995:             page_idx = texture_ctx->field_C & 0x7FFF;
 996:             if (page_idx >= effect_spt->spt_handle_copy[1])
 997:                 page_idx = effect_spt->spt_handle_copy[1] - 1;
 998:             if (page_idx >= 0 && page_idx < effect_spt->spt_handle_copy[1])
 999:             {
1000:                 page_list = &effect_spt->pages[page_idx];
1001:                 page_spt_ptr = page_list->page_spt_ptr;
1002:                 for (int i = page_list->field_0[1]; i > 0; --i)
1003:                 {
1004:                     if (effect_spt->tex_page_count > 1)
1005:                     {
1006:                         drawable = 0;
1007:                         tex_page_idx = 0;
1008:                         while (effect_spt->tex_page_count)
1009:                         {
1010:                             if (page_spt_ptr->field_C == effect_spt->field_10[tex_page_idx])
1011:                             {
1012:                                 drawable = effect_spt->game_drawable[tex_page_idx];
1013:                                 draw_chain = ff7_externals.get_draw_chain_671C71(drawable);
1014:                                 goto ANIMATE_TEXTURE;
1015:                             }
1016:                             ++tex_page_idx;
1017:                         }
1018:                     }
1019:                     draw_chain = ff7_externals.get_draw_chain_671C71(drawable);
1020:                 ANIMATE_TEXTURE:
1021:                     if (draw_chain)
1022:                     {
1023:                         if (texture_ctx->color.r < 128u)
1024:                             red_color = 2 * texture_ctx->color.r;
1025:                         else
1026:                             red_color = -1;
1027:                         if (texture_ctx->color.g < 128u)
1028:                             green_color = 2 * texture_ctx->color.g;
1029:                         else
1030:                             green_color = -1;
1031:                         if (texture_ctx->color.b < 128u)
1032:                             blue_color = 2 * texture_ctx->color.b;
1033:                         else
1034:                             blue_color = -1;
1035:                         color_rgba.r = red_color;
1036:                         color_rgba.g = green_color;
1037:                         color_rgba.b = blue_color;
1038:                         color_rgba.a = ((ff7_polygon_set*)drawable->polygon_set)->hundred_data->vertex_alpha;
1039:                         x_left = (8 * page_spt_ptr->field_4);
1040:                         y_top = (8 * page_spt_ptr->field_6);
1041:                         quad_width = (8 * (byte)page_spt_ptr->field_10);
1042:                         quad_height = (8 * (byte)page_spt_ptr->field_12);
1043:                         u_left_1 = page_spt_ptr->uScale * drawable->u_offset + drawable->u_offset / 2.0;
1044:                         v_top_1 = page_spt_ptr->vScale * drawable->v_offset + drawable->v_offset / 2.0;
1045:                         u_scale = ((byte)page_spt_ptr->field_10 - 1);
1046:                         v_scale = ((byte)page_spt_ptr->field_12 - 1);
1047:                         u_left_2 = drawable->u_offset * u_scale;
1048:                         v_top_2 = drawable->v_offset * v_scale;
1049:                         drawable_state = draw_chain->struc_186;
1050:                         if ((page_spt_ptr->field_0 & 1) != 0)
1051:                         {
1052:                             u_right = page_spt_ptr->uScale * drawable->u_offset + drawable->u_offset / 2.0;
1053:                             u_left = u_left_1 + u_left_2;
1054:                         }
1055:                         else
1056:                         {
1057:                             u_left = page_spt_ptr->uScale * drawable->u_offset + drawable->u_offset / 2.0;
1058:                             u_right = u_left_1 + u_left_2;
1059:                         }
1060:                         if ((page_spt_ptr->field_0 & 2) != 0)
1061:                         {
1062:                             v_bottom = page_spt_ptr->vScale * drawable->v_offset + drawable->v_offset / 2.0;
1063:                             v_top = v_top_1 + v_top_2;
1064:                         }
1065:                         else
1066:                         {
1067:                             v_top = page_spt_ptr->vScale * drawable->v_offset + drawable->v_offset / 2.0;
1068:                             v_bottom = v_top_1 + v_top_2;
1069:                         }
1070: 
1071:                         // Temporary fix for Pollensalta cold breath bg widescreen fix 
1072:                         // (The correct solution should be to edit the file `magic/ff7/data/battle/special/hubuki/kemu.s` to edit the texture page)
1073:                         if(widescreen_enabled && (uint32_t)texture_ctx == ff7_externals.pollensalta_cold_breath_bg_texture_ctx)
1074:                         {
1075:                             float widescreen_multiplier = ((float)wide_viewport_width / (float)wide_viewport_height) / (4 / 3.f);
1076:                             quad_width *= widescreen_multiplier;
1077:                             quad_height *= widescreen_multiplier;
1078:                         }
1079: 
1080:                         drawable_state->vertices[0].x = x_left;
1081:                         drawable_state->vertices[0].y = y_top;
1082:                         drawable_state->vertices[0].z = 0.0;
1083:                         drawable_state->colors[0] = color_rgba;
1084:                         drawable_state->texcoords[0].u = u_left;
1085:                         drawable_state->texcoords[0].v = v_top;
1086:                         drawable_state->vertices[1].x = x_left;
1087:                         drawable_state->vertices[1].y = y_top + quad_height;
1088:                         drawable_state->vertices[1].z = 0.0;
1089:                         drawable_state->colors[1] = color_rgba;
1090:                         drawable_state->texcoords[1].u = u_left;
1091:                         drawable_state->texcoords[1].v = v_bottom;
1092:                         drawable_state->vertices[2].x = x_left + quad_width;
1093:                         drawable_state->vertices[2].y = y_top;
1094:                         drawable_state->vertices[2].z = 0.0;
1095:                         drawable_state->colors[2] = color_rgba;
1096:                         drawable_state->texcoords[2].u = u_right;
1097:                         drawable_state->texcoords[2].v = v_top;
1098:                         drawable_state->vertices[3].x = x_left + quad_width;
1099:                         drawable_state->vertices[3].y = y_top + quad_height;
1100:                         drawable_state->vertices[3].z = 0.0;
1101:                         drawable_state->colors[3] = color_rgba;
1102:                         drawable_state->texcoords[3].u = u_right;
1103:                         drawable_state->texcoords[3].v = v_bottom;
1104:                         if (flag)
1105:                         {
1106:                             drawable_state->palette_index = texture_ctx->field_E >> 6;
1107:                         }
1108:                         else
1109:                         {
1110:                             palette_idx = (page_spt_ptr->palette_something >> 6) - ((ff7_tex_header*)((ff7_texture_set*)(drawable->hundred_data->texture_set))->tex_header)->field_E0;
1111:                             if (palette_idx < 0)
1112:                                 palette_idx = 0;
1113:                             drawable_state->palette_index = palette_idx;
1114:                         }
1115:                         ff7_externals.create_rot_matrix_from_word_matrix_6617E9(rot_matrix, &draw_chain->matrix);
1116:                     }
1117:                     ++page_spt_ptr;
1118:                 }
1119:             }
1120:         }
1121:         return retVal;
1122:     }
1123: 
1124:     void battle_sub_6CE81E()
1125:     {
1126:         // Gun effect uses a variable that is toggle true and false each frame in 15 FPS. With greater FPS, this should change less frequently
1127:         if(frame_counter % battle_frame_multiplier == 0)
1128:         {
1129:             ff7_externals.battle_sub_6CE81E();
1130:         }
1131:     }
1132: 
1133:     void battleground_shake_train()
1134:     {
1135:         if(frame_counter % battle_frame_multiplier == 0)
1136:         {
1137:             ff7_externals.battleground_shake_train_42F088();
1138:         }
1139:     }
1140: 
1141: 
1142: 
1143:     void animations_hook_init()
1144:     {
1145:         // 3d model animation
1146:         if(ff7_fps_limiter == FPS_LIMITER_30FPS)
1147:         {
1148:             patch_multiply_code<byte>(ff7_externals.battle_update_3d_model_data + 0x13E, battle_frame_multiplier);
1149:             patch_multiply_code<byte>(ff7_externals.battle_update_3d_model_data + 0x316, battle_frame_multiplier);
1150:         }
1151: 
1152:         replace_call_function(ff7_externals.battle_sub_42A5EB + 0xB8, run_animation_script);
1153:         replace_call_function(ff7_externals.battle_sub_42E275 + 0xB2, run_animation_script);
1154:         replace_call_function(ff7_externals.battle_sub_42E34A + 0x76, run_animation_script);
1155:         replace_call_function(ff7_externals.battle_sub_5BD5E9 + 0x22F, run_animation_script);
1156:         replace_call_function(ff7_externals.run_summon_animations_script_sub_5C1D9A + 0x4A, run_animation_script);
1157:         replace_function(ff7_externals.add_fn_to_effect100_fn, add_fn_to_effect100_fn);
1158:         replace_function(ff7_externals.add_fn_to_effect10_fn, add_fn_to_effect10_fn);
1159:         replace_function(ff7_externals.add_fn_to_effect60_fn, add_fn_to_effect60_fn);
1160:         replace_function(ff7_externals.execute_effect100_fn, execute_effect100_fn);
1161:         replace_function(ff7_externals.execute_effect10_fn, execute_effect10_fn);
1162:         replace_function(ff7_externals.execute_effect60_fn, execute_effect60_fn);
1163: 
1164:         // Normal enemy death
1165:         patch_multiply_code<WORD>(ff7_externals.battle_enemy_death_5BBD24 + 0x40, battle_frame_multiplier);
1166:         patch_divide_code<WORD>(ff7_externals.battle_enemy_death_sub_5BBE32 + 0xA8, battle_frame_multiplier);
1167:         patch_divide_code<byte>(ff7_externals.battle_enemy_death_sub_5BBE32 + 0xCB, battle_frame_multiplier);
1168: 
1169:         // Enemy death - iainuki
1170:         patch_multiply_code<WORD>(ff7_externals.battle_iainuki_death_5BCAAA + 0x40, battle_frame_multiplier);
1171:         patch_divide_code<WORD>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0x9F, battle_frame_multiplier);
1172:         patch_divide_code<byte>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0xC2, battle_frame_multiplier);
1173:         patch_divide_code<byte>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0xE3, battle_frame_multiplier);
1174:         patch_divide_code<byte>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0x104, battle_frame_multiplier);
1175:         patch_divide_code<WORD>(ff7_externals.battle_iainuki_death_sub_5BCBB8 + 0x154, battle_frame_multiplier);
1176: 
1177:         // Boss death
1178:         patch_multiply_code<WORD>(ff7_externals.battle_boss_death_5BC48C + 0x40, battle_frame_multiplier);
1179:         patch_multiply_code<WORD>(ff7_externals.battle_boss_death_5BC48C + 0xCF, battle_frame_multiplier);
1180:         patch_divide_code<byte>(ff7_externals.battle_boss_death_sub_5BC6ED + 0xCF, battle_frame_multiplier);
1181:         patch_divide_code<byte>(ff7_externals.battle_boss_death_sub_5BC6ED + 0xF1, battle_frame_multiplier);
1182:         replace_function(ff7_externals.battle_boss_death_sub_5BC5EC, run_boss_death_animation_5BC5EC);
1183: 
1184:         // Enemy death - melting
1185:         patch_multiply_code<WORD>(ff7_externals.battle_melting_death_5BC21F + 0x40, battle_frame_multiplier);
1186:         patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0xAB, battle_frame_multiplier);
1187:         patch_divide_code<byte>(ff7_externals.battle_melting_death_sub_5BC32D + 0xCE, battle_frame_multiplier);
1188:         patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0xEE, battle_frame_multiplier);
1189:         patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0x10D, battle_frame_multiplier);
1190:         patch_divide_code<WORD>(ff7_externals.battle_melting_death_sub_5BC32D + 0x12C, battle_frame_multiplier);
1191: 
1192:         // Enemy death - disintegrate 2
1193:         patch_multiply_code<WORD>(ff7_externals.battle_disintegrate_2_death_5BBA82 + 0x40, battle_frame_multiplier);
1194:         patch_divide_code<WORD>(ff7_externals.battle_disintegrate_2_death_sub_5BBBDE + 0xB9, battle_frame_multiplier);
1195:         patch_divide_code<byte>(ff7_externals.battle_disintegrate_2_death_sub_5BBBDE + 0xDB, battle_frame_multiplier);
1196:         patch_divide_code<float>((uint32_t)ff7_externals.field_float_battle_7B7680, battle_frame_multiplier); // float value used also elsewhere
1197: 
1198:         // Enemy death - morph
1199:         patch_multiply_code<WORD>(ff7_externals.battle_morph_death_5BC812 + 0x40, battle_frame_multiplier);
1200:         patch_divide_code<WORD>(ff7_externals.battle_morph_death_sub_5BC920 + 0x9F, battle_frame_multiplier);
1201:         patch_divide_code<byte>(ff7_externals.battle_morph_death_sub_5BC920 + 0xC2, battle_frame_multiplier);
1202:         patch_divide_code<byte>(ff7_externals.battle_morph_death_sub_5BC920 + 0xE3, battle_frame_multiplier);
1203:         patch_divide_code<byte>(ff7_externals.battle_morph_death_sub_5BC920 + 0x104, battle_frame_multiplier);
1204:         patch_divide_code<WORD>(ff7_externals.battle_morph_death_sub_5BC920 + 0x154, battle_frame_multiplier);
1205: 
1206:         // Enemy death - disintegrate 1
1207:         patch_multiply_code<WORD>(ff7_externals.battle_disintegrate_1_death_5BBF31 + 0x40, battle_frame_multiplier);
1208:         replace_function(ff7_externals.battle_disintegrate_1_death_sub_5BC04D, run_disintegrate_1_death_sub_5BC04D);
1209: 
1210:         // Display string related
1211:         replace_function(ff7_externals.get_n_frames_display_action_string, get_n_frames_display_action_string);
1212:         patch_multiply_code<WORD>(ff7_externals.battle_sub_434C8B + 0x4F, battle_frame_multiplier); // unknown display text frame to keep
1213:         patch_multiply_code<WORD>(ff7_externals.battle_sub_435D81 + 0x6A8, battle_frame_multiplier); // all lucky 7s frame to keep the text
1214: 
1215:         // Character movement (e.g. movement animation for attacks)
1216:         replace_function(ff7_externals.battle_move_character_sub_426F58, battle_move_character_sub_426F58);
1217: 
1218:         // Character fade in/out (i.e. multiply g_script_wait_frames and other things)
1219:         patch_multiply_code<byte>(ff7_externals.battle_sub_42A72D + 0x11A, battle_frame_multiplier);
1220:         patch_multiply_code<WORD>(ff7_externals.vincent_limit_fade_effect_sub_5D4240 + 0x24, battle_frame_multiplier);
1221:         patch_multiply_code<WORD>(ff7_externals.vincent_limit_fade_effect_sub_5D4240 + 0x57, battle_frame_multiplier);
1222:         patch_multiply_code<byte>(ff7_externals.vincent_limit_fade_effect_sub_5D4240 + 0x6E, battle_frame_multiplier);
1223:         patch_multiply_code<WORD>(ff7_externals.battle_sub_5C18BC + 0xDC, battle_frame_multiplier);
1224:         patch_multiply_code<byte>(ff7_externals.battle_sub_5C18BC + 0xE4, battle_frame_multiplier);
1225:         patch_multiply_code<WORD>(ff7_externals.battle_sub_5C1C8F + 0x55, battle_frame_multiplier);
1226:         patch_multiply_code<byte>(ff7_externals.battle_sub_5C1C8F + 0x5D, battle_frame_multiplier);
1227: 
1228:         // Summons
1229:         patch_multiply_code<byte>(ff7_externals.run_summon_animations_5C0E4B + 0x75, battle_frame_multiplier);
1230:         patch_multiply_code<byte>(ff7_externals.run_summon_animations_5C0E4B + 0x6D, battle_frame_multiplier);
1231:         patch_multiply_code<byte>(ff7_externals.run_summon_animations_5C0E4B + 0x15B, battle_frame_multiplier);
1232:         memset_code(ff7_externals.run_shiva_camera_58E60D + 0xC2D, 0x90, 6);
1233:         patch_code_dword(ff7_externals.run_ramuh_camera_597206 + 0x44, 0x000B9585);
1234:         memset_code(ff7_externals.run_odin_gunge_camera_4A0F52 + 0xC0C, 0x90, 6);
1235:         patch_multiply_code<DWORD>(ff7_externals.run_odin_steel_sub_4A9908 + 0x5E, battle_frame_multiplier);
1236:         patch_multiply_code<DWORD>(ff7_externals.run_odin_steel_sub_4A9908 + 0x25D, battle_frame_multiplier);
1237:         patch_multiply_code<byte>(ff7_externals.run_odin_steel_sub_4A9908 + 0x265, battle_frame_multiplier);
1238:         patch_code_dword(ff7_externals.run_odin_steel_sub_4A9908 + 0x316, (DWORD)&ff7_odin_steel_frames_AEEC14);
1239:         replace_call_function(ff7_externals.run_summon_kotr_sub_476857 + 0x1C6, add_kotr_camera_fn_to_effect100_fn);
1240:         replace_function(ff7_externals.run_ifrit_movement_596702, run_ifrit_movement_596702);
1241:         patch_code_byte(ff7_externals.run_shiva_movement_592538 + 0x14D, 92);
1242:         patch_code_byte(ff7_externals.run_shiva_movement_592538 + 0x153, 91);
1243:         patch_code_int(ff7_externals.run_bahamut_neo_movement_48D7BC + 0x62, 206);
1244:         patch_code_byte(ff7_externals.run_bahamut_movement_49ADEC + 0x69, 83);
1245:         patch_code_byte(ff7_externals.run_odin_gunge_movement_4A584D + 0x1D0, 26);
1246: 
1247:         // Show Damage
1248:         patch_multiply_code<WORD>(ff7_externals.display_battle_damage_5BB410 + 0x54, battle_frame_multiplier);
1249:         if(battle_frame_multiplier == 2)
1250:         {
1251:             patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x1E2, (DWORD)y_pos_offset_display_damage_30);
1252:             patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x2D7, (DWORD)y_pos_offset_display_damage_30);
1253:         }
1254:         else if(battle_frame_multiplier == 4)
1255:         {
1256:             patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x1E2, (DWORD)y_pos_offset_display_damage_60);
1257:             patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x2D7, (DWORD)y_pos_offset_display_damage_60);
1258:         }
1259: 
1260:         // Aura animation (magic, limit break, enemy skill, summon)
1261:         patch_divide_code<DWORD>(ff7_externals.limit_break_aura_effects_5C0572 + 0x4C, battle_frame_multiplier);
1262:         patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0x6E, battle_frame_multiplier);
1263:         patch_divide_code<DWORD>(ff7_externals.limit_break_aura_effects_5C0572 + 0x7A, battle_frame_multiplier);
1264:         patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0x98, battle_frame_multiplier);
1265:         patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0xAD, battle_frame_multiplier);
1266:         patch_code_byte(ff7_externals.limit_break_aura_effects_5C0572 + 0xB0, 0x9 - battle_frame_multiplier / 2);
1267:         patch_multiply_code<byte>(ff7_externals.limit_break_aura_effects_5C0572 + 0x13E, battle_frame_multiplier);
1268:         patch_multiply_code<DWORD>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x5C, battle_frame_multiplier);
1269:         patch_code_byte(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x64, 0x7 - battle_frame_multiplier / 2);
1270:         patch_multiply_code<DWORD>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x81, battle_frame_multiplier);
1271:         patch_code_byte(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x89, 0xA - battle_frame_multiplier / 2);
1272:         patch_multiply_code<byte>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xA7, battle_frame_multiplier);
1273:         patch_divide_code<int>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xB3, battle_frame_multiplier);
1274:         patch_multiply_code<byte>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xD6, battle_frame_multiplier);
1275:         patch_code_byte(ff7_externals.enemy_skill_aura_effects_5C06BF + 0xD9, 0xC - battle_frame_multiplier / 2);
1276:         patch_multiply_code<byte>(ff7_externals.enemy_skill_aura_effects_5C06BF + 0x182, battle_frame_multiplier);
1277:         patch_code_byte(ff7_externals.summon_aura_effects_5C0953 + 0x4D, 0xC - battle_frame_multiplier / 2);
1278:         patch_multiply_code<byte>(ff7_externals.summon_aura_effects_5C0953 + 0x19D, battle_frame_multiplier);
1279: 
1280:         // Limit break effects
1281:         patch_multiply_code<byte>(ff7_externals.tifa_limit_2_1_sub_4E48D4 + 0x1FE, battle_frame_multiplier);
1282:         memset_code(ff7_externals.aerith_limit_2_1_sub_45B0CF + 0xCE, 0x90, 6);
1283:         patch_multiply_code<byte>(ff7_externals.aerith_limit_2_1_sub_45B0CF + 0xE2, battle_frame_multiplier);
1284: 
1285:         // Magics
1286:         patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x3B, battle_frame_multiplier);
1287:         patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x2FB, battle_frame_multiplier);
1288:         patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x302, battle_frame_multiplier);
1289:         patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x8F0, battle_frame_multiplier);
1290:         patch_multiply_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x8F7, battle_frame_multiplier);
1291:         patch_divide_code<byte>(ff7_externals.battle_escape_magic_loop_5D602A + 0x4A, battle_frame_multiplier);
1292:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_loop_5D602A + 0xC1, battle_frame_multiplier);
1293:         patch_code_byte(ff7_externals.battle_escape_magic_loop_5D602A + 0x6A8, 4 + battle_frame_multiplier / 2);
1294:         patch_divide_code<WORD>(ff7_externals.battle_escape_magic_loop_5D602A + 0x6CF, battle_frame_multiplier);
1295:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x12C, battle_frame_multiplier);
1296:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x131, battle_frame_multiplier);
1297:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x148, battle_frame_multiplier);
1298:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x14D, battle_frame_multiplier);
1299:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x164, battle_frame_multiplier);
1300:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x169, battle_frame_multiplier);
1301:         byte lea_eax_ecx_15[] = {0x8D, 0x54, 0x08, 0xEB};
1302:         byte lea_eax_ecx_10[] = {0x8D, 0x54, 0x08, 0xF0};
1303:         memcpy_code(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1B2, lea_eax_ecx_15, sizeof(lea_eax_ecx_15));
1304:         memcpy_code(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1CE, lea_eax_ecx_10, sizeof(lea_eax_ecx_10));
1305:         patch_divide_code<byte>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1E6, battle_frame_multiplier);
1306:         patch_divide_code<DWORD>(ff7_externals.battle_escape_magic_init_data_5D59B0 + 0x1E8, battle_frame_multiplier);
1307: 
1308:         // Effect60 related
1309:         patch_multiply_code<WORD>(ff7_externals.battle_sub_425E5F + 0x3A, battle_frame_multiplier);
1310: 
1311:         // Bad workaround to fix ESUI compatibility with 30fps when no widescreen mod is enabled
1312:         if (ff7_fps_limiter == FPS_LIMITER_60FPS || (ff7_fps_limiter == FPS_LIMITER_30FPS && widescreen_enabled)) 
1313:         {
1314:             patch_multiply_code<WORD>(ff7_externals.battle_sub_5BCF9D + 0x3A, battle_frame_multiplier);
1315:         }
1316:         patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x1DC, 0x2 - battle_frame_multiplier / 2);
1317:         patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x203, 0x2 - battle_frame_multiplier / 2);
1318: 
1319:         patch_multiply_code<WORD>(ff7_externals.battle_sub_5BCD42 + 0x5B, battle_frame_multiplier);
1320:         patch_divide_code<WORD>(ff7_externals.battle_sub_5BCD42 + 0x6E, battle_frame_multiplier);
1321: 
1322:         replace_function(ff7_externals.battle_sub_427737, battle_play_sfx_delayed_427737);
1323: 
1324:         // Tifa slots speed patch (bitwise and with 0x7 changed to 0x3)
1325:         patch_code_byte((uint32_t)ff7_externals.display_tifa_slots_handler_6E3135 + 0x168, 0x3);
1326:         patch_code_byte((uint32_t)ff7_externals.display_tifa_slots_handler_6E3135 + 0x16B, 0xCA);
1327: 
1328:         // Texture material animation
1329:         replace_function(ff7_externals.battle_animate_material_texture, battle_animate_material_texture);
1330:         replace_function(ff7_externals.battle_animate_texture_spt, battle_animate_texture_spt);
1331: 
1332:         // Toggle variable related to gun effect
1333:         replace_call_function(ff7_externals.battle_sub_42D808 + 0x117, battle_sub_6CE81E);
1334: 
1335:         // 3D Battleground (mesh: horizontal, vertical, rotating, midgar flashback rain)
1336:         // Lifestream final battle with sephiroth cannot be interpolated, it will be left like this which is still good
1337:         replace_call_function(ff7_externals.update_3d_battleground + 0xBF, battleground_shake_train);
1338:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x1D4, battle_frame_multiplier);
1339:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x1ED, battle_frame_multiplier);
1340:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x206, battle_frame_multiplier);
1341:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x21C, battle_frame_multiplier);
1342:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x232, battle_frame_multiplier);
1343:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x24B, battle_frame_multiplier);
1344:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x264, battle_frame_multiplier);
1345:         patch_divide_code<int>(ff7_externals.update_3d_battleground + 0x27D, battle_frame_multiplier);
1346:         patch_divide_code<WORD>(ff7_externals.update_3d_battleground + 0x617, battle_frame_multiplier);
1347:         patch_divide_code<WORD>(ff7_externals.update_3d_battleground + 0x6CE, battle_frame_multiplier);
1348:         patch_multiply_code<byte>(ff7_externals.battleground_vertical_scrolling_42F126 + 0x10, battle_frame_multiplier);
1349:         patch_divide_code<WORD>(ff7_externals.battleground_vertical_scrolling_42F126 + 0x22, battle_frame_multiplier);
1350:         patch_divide_code<WORD>(ff7_externals.battleground_vertical_scrolling_42F126 + 0x42, battle_frame_multiplier);
1351:         patch_code_word(ff7_externals.battleground_vertical_scrolling_42F126 + 0x78, (0x1F + 1) * battle_frame_multiplier - 1);
1352:         patch_divide_code<WORD>(ff7_externals.update_3d_battleground + 0x881, battle_frame_multiplier);
1353:         patch_divide_code<byte>(ff7_externals.update_3d_battleground + 0x8C7, battle_frame_multiplier);
1354:         patch_divide_code<byte>(ff7_externals.update_3d_battleground + 0x90C, battle_frame_multiplier);
1355:         patch_multiply_code<byte>(ff7_externals.battleground_midgar_flashback_rain_5BDC4F + 0x44, battle_frame_multiplier);
1356:         patch_divide_code<WORD>(ff7_externals.battleground_midgar_flashback_rain_5BDC4F + 0x71, battle_frame_multiplier);
1357:         patch_divide_code<byte>(ff7_externals.battleground_midgar_flashback_rain_5BDC4F + 0x156, battle_frame_multiplier);
1358: 
1359:         // Other animations (Status effects: confusion, sleep, and silence; and player mark on top of head)
1360:         // And fixes for manipulate, poison and regen color effect on characters 3d models
1361:         patch_divide_code<WORD>(ff7_externals.battle_sub_5B9EC2 + 0x1CB, battle_frame_multiplier);
1362:         patch_multiply_code<byte>(ff7_externals.battle_sub_5B9EC2 + 0x292, battle_frame_multiplier);
1363:         patch_divide_code<WORD>(ff7_externals.battle_sub_5B9EC2 + 0x2A8, battle_frame_multiplier);
1364:         patch_divide_code<WORD>(ff7_externals.battle_sub_5B9EC2 + 0x2D0, battle_frame_multiplier);
1365:         patch_code_byte(ff7_externals.battle_sub_5B9EC2 + 0x316, (0x1F + 1) * battle_frame_multiplier - 1);
1366:         patch_code_byte(ff7_externals.battle_handle_status_effect_anim_5BA7C0 + 0x97, 0x3 + battle_frame_multiplier / 2);
1367:         patch_divide_code<WORD>(ff7_externals.battle_handle_player_mark_5B9C8E + 0x6A, battle_frame_multiplier);
1368: 
1369:         if(ff7_fps_limiter == FPS_LIMITER_60FPS)
1370:         {
1371:             // Speed up window menu closing speed to fix Bizarro menu box softlock
1372:             patch_code_byte(ff7_externals.battle_menu_closing_window_box_6DAEF0 + 0x29, 0x2 - 1);
1373:             patch_code_byte(ff7_externals.battle_menu_closing_window_box_6DAEF0 + 0x72, 0x2 - 1);
1374:         }
1375: 
1376:         // Delay animation of battle target pointer
1377:         replace_call_function(ff7_externals.battle_update_targeting_info_6E6291 + 0x682, delay_battle_target_pointer_animation_type);
1378:         memset_code(ff7_externals.battle_update_targeting_info_6E6291 + 0x687, 0x90, 10);
1379:         replace_call_function(ff7_externals.battle_update_targeting_info_6E6291 + 0x752, delay_battle_target_pointer_animation_type);
1380:         memset_code(ff7_externals.battle_update_targeting_info_6E6291 + 0x757, 0x90, 10);
1381:         replace_call_function(ff7_externals.battle_update_targeting_info_6E6291 + 0x81C, delay_battle_target_pointer_animation_type);
1382:         memset_code(ff7_externals.battle_update_targeting_info_6E6291 + 0x821, 0x90, 10);
1383: 
1384:         // Populate map and set data for better performance with decorators initialization
1385:         fixed_effect100_addresses.insert(ff7_externals.battle_enemy_death_5BBD24);
1386:         fixed_effect100_addresses.insert(ff7_externals.battle_iainuki_death_5BCAAA);
1387:         fixed_effect100_addresses.insert(ff7_externals.battle_boss_death_5BC48C);
1388:         fixed_effect100_addresses.insert(ff7_externals.battle_melting_death_5BC21F);
1389:         fixed_effect100_addresses.insert(ff7_externals.battle_disintegrate_2_death_5BBA82);
1390:         fixed_effect100_addresses.insert(ff7_externals.battle_morph_death_5BC812);
1391:         fixed_effect100_addresses.insert(ff7_externals.run_summon_animations_5C0E4B);
1392:         fixed_effect100_addresses.insert(ff7_externals.run_summon_animations_script_5C1B81);
1393:         fixed_effect100_addresses.insert(ff7_externals.goblin_punch_flash_573291);
1394:         fixed_effect100_addresses.insert(ff7_externals.run_ifrit_movement_596702);
1395:         fixed_effect100_addresses.insert(ff7_externals.vincent_limit_fade_effect_sub_5D4240);
1396:         fixed_effect100_addresses.insert(ff7_externals.cloud_limit_2_2_sub_467256);
1397:         fixed_effect100_addresses.insert(ff7_externals.battle_escape_magic_loop_5D602A);
1398:         one_call_effect100_addresses.insert(ff7_externals.run_bahamut_zero_main_loop_484A16);
1399:         one_call_effect100_addresses.insert(ff7_externals.death_sentence_main_loop_5661A0);
1400:         one_call_effect100_addresses.insert(ff7_externals.roulette_skill_main_loop_566287);
1401:         one_call_effect100_addresses.insert(ff7_externals.bomb_blast_black_bg_effect_537427);
1402:         one_call_effect100_addresses.insert(ff7_externals.run_confu_main_loop_5600BE);
1403:         one_call_effect100_addresses.insert(ff7_externals.death_kill_sub_loop_5624A5);
1404:         one_call_effect100_addresses.insert(ff7_externals.death_kill_sub_loop_562C60);
1405:         model_thresholds_by_address[ff7_externals.run_alexander_movement_5078D8] = 3000;
1406:         camera_thresholds_by_address[ff7_externals.run_ramuh_camera_597206] = 5000;
1407:         camera_thresholds_by_address[ff7_externals.run_typhoon_camera_4D594C] = 5000;
1408:         camera_thresholds_by_address[ff7_externals.run_kotr_camera_476AFB] = 5000;
1409:         camera_thresholds_by_address[ff7_externals.run_kujata_camera_4F9A4D] = 5000;
1410:         camera_thresholds_by_address[ff7_externals.run_bahamut_zero_camera_483866] = 4000;
1411:         camera_thresholds_by_address[ff7_externals.barret_limit_4_1_camera_4688A2] = 4000;
1412:         camera_effect100_addresses.insert(ff7_externals.run_chocomog_camera_509B10);
1413:         camera_effect100_addresses.insert(ff7_externals.run_fat_chocobo_camera_507CA4);
1414:         camera_effect100_addresses.insert(ff7_externals.run_ifrit_camera_592A36);
1415:         camera_effect100_addresses.insert(ff7_externals.run_shiva_camera_58E60D);
1416:         camera_effect100_addresses.insert(ff7_externals.run_ramuh_camera_597206);
1417:         camera_effect100_addresses.insert(ff7_externals.run_alexander_camera_501637);
1418:         camera_effect100_addresses.insert(ff7_externals.run_bahamut_camera_497A37);
1419:         camera_effect100_addresses.insert(ff7_externals.run_phoenix_camera_515238);
1420:         camera_effect100_addresses.insert(ff7_externals.run_titan_camera_59B4B0);
1421:         camera_effect100_addresses.insert(ff7_externals.run_hades_camera_4B65A8);
1422:         camera_effect100_addresses.insert(ff7_externals.run_leviathan_camera_5B0716);
1423:         camera_effect100_addresses.insert(ff7_externals.run_odin_gunge_camera_4A0F52);
1424:         camera_effect100_addresses.insert(ff7_externals.run_odin_steel_camera_4A5D3C);
1425:         camera_effect100_addresses.insert(ff7_externals.run_bahamut_neo_camera_48C75D);
1426:         camera_effect100_addresses.insert(ff7_externals.run_kujata_camera_4F9A4D);
1427:         camera_effect100_addresses.insert(ff7_externals.run_typhoon_camera_4D594C);
1428:         camera_effect100_addresses.insert(ff7_externals.run_bahamut_zero_camera_483866);
1429:         camera_effect100_addresses.insert(ff7_externals.run_kotr_camera_476AFB);
1430:         camera_effect100_addresses.insert(ff7_externals.barret_limit_4_1_camera_4688A2);
1431:         camera_effect100_addresses.insert(ff7_externals.aerith_limit_4_1_camera_473CC2);
1432:         camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_439EE0);
1433:         camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_44A7D2);
1434:         camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_44EDC0);
1435:         camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_4522AD);
1436:         camera_effect100_addresses.insert(ff7_externals.enemy_atk_camera_sub_457C60);
1437:         model_effect100_addresses.insert(ff7_externals.run_fat_chocobo_movement_509692);
1438:         model_effect100_addresses.insert(ff7_externals.run_bahamut_movement_49ADEC);
1439:         model_effect100_addresses.insert(ff7_externals.run_bahamut_neo_movement_48D7BC);
1440:         model_effect100_addresses.insert(ff7_externals.run_odin_gunge_movement_4A584D);
1441:         model_effect100_addresses.insert(ff7_externals.run_odin_steel_movement_4A6CB8);
1442:         model_effect100_addresses.insert(ff7_externals.run_phoenix_movement_518AFF);
1443:         model_effect100_addresses.insert(ff7_externals.run_chocomog_movement_50B1A3);
1444:         model_effect100_addresses.insert(ff7_externals.run_bahamut_zero_movement_48BBFC);
1445:         model_effect100_addresses.insert(ff7_externals.run_shiva_movement_592538);
1446:         model_effect100_addresses.insert(ff7_externals.run_alexander_movement_5078D8);
1447:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[0]] = {50};
1448:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[1]] = {50};
1449:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[2]] = {};
1450:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[3]] = {52};
1451:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[4]] = {35};
1452:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[5]] = {14};
1453:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[6]] = {};
1454:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[7]] = {26};
1455:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[8]] = {71};
1456:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[9]] = {51};
1457:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[10]] = {56};
1458:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[11]] = {56};
1459:         kotr_excluded_frames[ff7_externals.run_summon_kotr_knight_script[12]] = {112};
1460:     }
1461: }
</file>

<file path="src/ff7/battle/animations.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <unordered_map>
 26: #include <unordered_set>
 27: #include <stdint.h>
 28: #include <windows.h>
 29: 
 30: namespace ff7::battle
 31: {
 32:     const std::unordered_map<byte, int> numArgsOpCode = {
 33:         {0x8E, 0},
 34:         {0x8F, 0},
 35:         {0x90, 3},
 36:         {0x91, 1}, // Function added
 37:         {0x92, 0},
 38:         {0x93, 0}, // Function added
 39:         {0x94, 5}, // Function added
 40:         {0x95, 0},
 41:         {0x96, 2}, // effect60 fn added (barret gun)
 42:         {0x97, 2}, // Run enemy death animations
 43:         {0x98, 1}, // Display action text
 44:         {0x99, 6},
 45:         {0x9A, 4},
 46:         {0x9B, 0},
 47:         {0x9C, 0},
 48:         {0x9D, 1}, // Dispatches Tifa limit breaks
 49:         {0x9E, 0xFF},
 50:         {0x9F, 0},
 51:         {0xA0, 1},
 52:         {0xA1, 2},
 53:         {0xA2, 1},
 54:         {0xA3, 1},
 55:         {0xA4, 0}, // Spell aura related
 56:         {0xA5, 0}, // Spell aura related
 57:         {0xA6, 0},
 58:         {0xA7, 1},
 59:         {0xA8, 2}, // Move actor to resting position
 60:         {0xA9, 2},
 61:         {0xAA, 0},
 62:         {0xAB, 4},
 63:         {0xAC, 1}, // Vincent related
 64:         {0xAD, 5}, // Barret related machine gun effect
 65:         {0xAE, 0}, // Resting position related
 66:         {0xAF, 1}, // Resting position reset
 67:         {0xB0, 0}, // Resting position related
 68:         {0xB1, 0}, // Resting position related
 69:         {0xB2, 0}, // nop
 70:         {0xB3, 0xFF},
 71:         {0xB4, 0}, // Y rotation
 72:         {0xB5, 11},
 73:         {0xB6, 1}, // running animation related
 74:         {0xB7, 0}, // death effects
 75:         {0xB8, 0},
 76:         {0xB9, 1}, // setup animation camera data
 77:         {0xBA, 2}, // resting Y rotation
 78:         {0xBC, 1}, // Idle camera index
 79:         {0xBD, 4}, // rotate to target animation
 80:         {0xBE, 1}, // not Tifa stuff
 81:         {0xBF, 2},
 82:         {0xC1, 0xFF},
 83:         {0xC2, 1}, // display damage
 84:         {0xC3, 0}, // some effects
 85:         {0xC4, 3}, // resting Y rotation (inverting direction)
 86:         {0xC5, 0}, // set frames to wait to 0xBFD0F0
 87:         {0xC6, 1}, // set 0xBFD0F0 frames to wait
 88:         {0xC7, 3}, // enemy animation thing
 89:         {0xC8, 5}, // effects thing
 90:         {0xC9, 0}, // nop
 91:         {0xCA, 0xFF},
 92:         {0xCB, 8},
 93:         {0xCC, 1}, // move effects thing
 94:         {0xCE, 1},
 95:         {0xCF, 8}, // 3d move effects
 96:         {0xD0, 3}, // move effects
 97:         {0xD1, 5}, // move effects
 98:         {0xD2, 0},
 99:         {0xD3, 0},
100:         {0xD4, 3}, // move effects
101:         {0xD5, 8}, // move effects
102:         {0xD6, 1}, // effects thing
103:         {0xD7, 2}, // effects thing
104:         {0xD8, 3}, // effects thing
105:         {0xDA, 1},
106:         {0xDB, 4}, // effect machine gun
107:         {0xDC, 3}, // rotation stuff
108:         {0xDD, 2}, // machine gun effects
109:         {0xDE, 2}, // machine gun stuff
110:         {0xDF, 0}, // resting Y rotation
111:         {0xE0, 0}, // spell aura related
112:         {0xE1, 0}, // appear model
113:         {0xE2, 0}, // vanish model
114:         {0xE3, 0}, // position actor
115:         {0xE4, 0}, // resting stuff
116:         {0xE5, 0}, // rotation stuff
117:         {0xE6, 0}, // spell aura stuff
118:         {0xE7, 1},
119:         {0xE8, 0},
120:         {0xE9, 3}, // move effects
121:         {0xEA, 0}, // display action string effect
122:         {0xEB, 0xFF},
123:         {0xEC, 0xFF},
124:         {0xED, 0}, // resting stuff
125:         {0xEE, 0xFF},
126:         {0xF0, 0}, // foot dust effect
127:         {0xF1, -1},
128:         {0xF2, 0}, // nop
129:         {0xF3, 0xFF},
130:         {0xF4, 0xFF},
131:         {0xF5, 1}, // game init enemies
132:         {0xF6, 0}, // Run normal enemy death animation effects
133:         {0xF7, 1}, // delay damage display effect
134:         {0xF8, 1}, // effect stuff
135:         {0xF9, 0}, // resets actor orientation
136:         {0xFA, 0},
137:         {0xFB, 4},
138:         {0xFC, 0}, // setting orientation for target-all action
139:         {0xFD, 6}, // set resting position
140:         {0xFE, 0xFF},
141:         {0xFF, 0xFF},
142:     };
143: 
144:     const std::unordered_set<byte> endingOpCode{{0xA2, 0xA7, 0xA9, 0xB6, 0xF1}};
145: }
</file>

<file path="src/ff7/battle/battle.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #include "../../globals.h"
23: #include "../../log.h"
24: #include "../../achievement.h"
25: 
26: #include "defs.h"
27: 
28: namespace ff7::battle
29: {
30: 	void magic_thread_start(void (*func)())
31: 	{
32: 		ff7_externals.destroy_magic_effects();
33: 
34: 		/*
35: 		* Original function creates a separate thread but the code is not thread
36: 		* safe in any way! Luckily modern PCs are fast enough to load magic
37: 		* effects synchronously.
38: 		*/
39: 		func();
40: 	}
41: 
42: 	void load_battle_stage(int param_1, int battle_location_id, int **param_3){
43: 		((void(*)(int, int, int **)) ff7_externals.load_battle_stage)(param_1, battle_location_id, param_3);
44: 
45: 		g_FF7SteamAchievements->initCharStatsBeforeBattle(ff7_externals.savemap->chars);
46: 		g_FF7SteamAchievements->unlockBattleSquareAchievement(battle_location_id);
47: 	}
48: 
49: 	void battle_sub_5C7F94(int param_1, int param_2){
50: 		((void(*)(int, int)) ff7_externals.battle_sub_5C7F94)(param_1, param_2);
51: 
52: 		if (trace_all || trace_achievement)
53: 			ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);
54: 		g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil);
55: 	}
56: 
57: 	void display_battle_action_text_sub_6D71FA(short command_id, short action_id){
58: 		ff7_externals.battle_actor_data->formation_entry = 1;
59: 		ff7_externals.battle_actor_data->command_index = command_id;
60: 		ff7_externals.battle_actor_data->action_index = action_id;
61: 
62: 		g_FF7SteamAchievements->unlockFirstLimitBreakAchievement(command_id, action_id);
63: 	}
64: 
65: 	int load_scene_bin_chunk(char *filename, int offset, int size, char **out_buffer, void (*callback)(void))
66: 	{
67: 		int ret = ff7_externals.engine_load_bin_file_sub_419210(filename, offset, size, out_buffer, callback);
68: 
69: 		char chunk_file[1024]{0};
70: 		uint32_t chunk_size = 0;
71: 		FILE* fd;
72: 
73: 		_snprintf(chunk_file, sizeof(chunk_file), "%s/%s/battle/scene.bin.chunk.%i", basedir, direct_mode_path.c_str(), ff7_externals.modules_global_object->battle_id / 4);
74: 
75: 		if ((fd = fopen(chunk_file, "rb")) != NULL)
76: 		{
77: 			fseek(fd, 0L, SEEK_END);
78: 			chunk_size = ftell(fd);
79: 			fseek(fd, 0L, SEEK_SET);
80: 			fread(*out_buffer, sizeof(byte), chunk_size, fd);
81: 
82: 			ffnx_trace("%s: scene overridden using %s\n", __func__, chunk_file);
83: 			fclose(fd);
84: 		}
85: 		else if (trace_direct)
86: 			ffnx_trace("%s: could not find %s\n", __func__, chunk_file);
87: 
88: 		return ret;
89: 	}
90: }
</file>

<file path="src/ff7/battle/camera.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //    Copyright (C) 2023 Cosmos                                             //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: #include "camera.h"
 24: #include "defs.h"
 25: 
 26: #include <unordered_set>
 27: #include <unordered_map>
 28: #include <span>
 29: 
 30: #include "../../patch.h"
 31: #include "../../globals.h"
 32: 
 33: #include <bx/math.h>
 34: 
 35: namespace ff7::battle
 36: {
 37:     Camera camera;
 38: 
 39:     const std::unordered_map<byte, int> numArgsPositionOpCode{{0xD5, 2}, {0xD6, 0}, {0xD7, 2}, {0xD8, 9}, {0xD9, 0}, {0xDA, 0}, {0xDB, 0}, {0xDC, 0}, {0xDD, 1}, {0xDE, 1}, {0xDF, 0}, {0xE0, 2}, {0xE1, 0}, {0xE2, 1}, {0xE3, 9}, {0xE4, 8}, {0xE5, 8}, {0xE6, 7}, {0xE7, 8}, {0xE9, 8}, {0xEB, 9}, {0xEF, 8}, {0xF0, 7}, {0xF1, 0}, {0xF2, 5}, {0xF3, 5}, {0xF4, -1}, {0xF5, 1}, {0xF7, 7}, {0xF8, 12}, {0xF9, 6}, {0xFE, 0}, {0xFF, -1}};
 40:     const std::unordered_map<byte, int> numArgsOpCode{{0xD8, 9}, {0xD9, 0}, {0xDB, 0}, {0xDC, 0}, {0xDD, 1}, {0xDE, 1}, {0xDF, 0}, {0xE0, 2}, {0xE1, 0}, {0xE2, 1}, {0xE3, 9}, {0xE4, 8}, {0xE5, 8}, {0xE6, 7}, {0xE8, 8}, {0xEA, 8}, {0xEC, 9}, {0xF0, 8}, {0xF4, -1}, {0xF5, 1}, {0xF8, 7}, {0xF9, 7}, {0xFA, 6}, {0xFE, 0}, {0xFF, -1}};
 41:     const std::unordered_set<byte> endingFocalOpCodes{0xF0, 0xF8, 0xF9, 0xFF};
 42:     const std::unordered_set<byte> endingPositionOpCodes{0xEF, 0xF0, 0xF7, 0xFF};
 43:     constexpr int CAMERA_ARRAY_SIZE = 16;
 44:     std::array<bool, CAMERA_ARRAY_SIZE> isNewCameraFunction{};
 45: 
 46:     byte *getCameraScriptPointer(char variationIndex, short cameraScriptIdx, bool isCameraFocalPoint)
 47:     {
 48:         int internalOffset = isCameraFocalPoint ? 4 : 0;
 49:         if (cameraScriptIdx == -1)
 50:             return isCameraFocalPoint ? ff7_externals.battle_camera_focal_scripts_8FEE30 : ff7_externals.battle_camera_position_scripts_8FEE2C;
 51:         else if (cameraScriptIdx == -2)
 52:             return isCameraFocalPoint ? (byte *)ff7_externals.battle_camera_focal_scripts_901270[*ff7_externals.battle_camera_script_index] : (byte *)ff7_externals.battle_camera_position_scripts_9010D0[*ff7_externals.battle_camera_script_index];
 53:         else if (cameraScriptIdx == -3)
 54:         {
 55:             int outerOffset = variationIndex * 4 + *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + 0x8 + internalOffset) - *ff7_externals.battle_camera_script_offset;
 56:             int finalOffset = *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + outerOffset) - *ff7_externals.battle_camera_script_offset;
 57:             return (byte *)(*ff7_externals.battle_camera_global_scripts_9A13BC + finalOffset);
 58:         }
 59:         int outerOffset = (3 * cameraScriptIdx + variationIndex) * 4 + *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + internalOffset) - *ff7_externals.battle_camera_script_offset;
 60:         int finalOffset = *(int *)(*ff7_externals.battle_camera_global_scripts_9A13BC + outerOffset) - *ff7_externals.battle_camera_script_offset;
 61:         return (byte *)(*ff7_externals.battle_camera_global_scripts_9A13BC + finalOffset);
 62:     }
 63: 
 64:     bool simulateCameraScript(byte *scriptPtr, short &currentPosition, short &framesToWait, const std::unordered_map<byte, int> &numArgsOpCode,
 65:                             const std::unordered_set<byte> &endingOpCodes)
 66:     {
 67:         bool executedOpCodeF5 = false;
 68:         bool isScriptActive = true;
 69:         while (isScriptActive)
 70:         {
 71:             byte currentOpCode = scriptPtr[currentPosition++];
 72: 
 73:             switch (currentOpCode)
 74:             {
 75:             case 0xF4:
 76:                 if (framesToWait != 0)
 77:                 {
 78:                     framesToWait--;
 79:                     currentPosition--;
 80:                     isScriptActive = false;
 81:                 }
 82:                 break;
 83:             case 0xF5:
 84:                 if(scriptPtr[currentPosition] == 0xFF)
 85:                 {
 86:                     framesToWait = -1;
 87:                     currentPosition++;
 88:                 }
 89:                 else
 90:                 {
 91:                     executedOpCodeF5 = true;
 92:                     framesToWait = scriptPtr[currentPosition++] * battle_frame_multiplier;
 93:                 }
 94:                 break;
 95:             case 0xFE:
 96:                 if (framesToWait == 0)
 97:                 {
 98:                     currentOpCode = scriptPtr[currentPosition];
 99: 
100:                     if (currentOpCode == 192)
101:                     {
102:                         framesToWait = 0;
103:                         currentPosition = 0;
104:                     }
105:                 }
106:                 break;
107:             default:
108:                 if (numArgsOpCode.contains(currentOpCode))
109:                 {
110:                     currentPosition += numArgsOpCode.at(currentOpCode);
111: 
112:                     if (endingOpCodes.contains(currentOpCode))
113:                         isScriptActive = false;
114:                 }
115:                 else
116:                 {
117:                     isScriptActive = false;
118:                 }
119:                 break;
120:             }
121:         }
122: 
123:         return executedOpCodeF5;
124:     }
125: 
126:     int add_fn_to_camera_fn(uint32_t function)
127:     {
128:         auto element = std::find(ff7_externals.camera_fn_array.begin(), ff7_externals.camera_fn_array.end(), 0);
129:         if (element != ff7_externals.camera_fn_array.end())
130:         {
131:             int index = std::distance(ff7_externals.camera_fn_array.begin(), element);
132:             ff7_externals.camera_fn_array[index] = function;
133:             ff7_externals.camera_fn_data[index].field_0 = *ff7_externals.camera_fn_index;
134:             *ff7_externals.camera_fn_counter = *ff7_externals.camera_fn_counter + 1;
135: 
136:             isNewCameraFunction[index] = true;
137:             return index;
138:         }
139:         return 0xFFFF;
140:     }
141: 
142:     void execute_camera_functions()
143:     {
144:         uint16_t &fn_index = *ff7_externals.camera_fn_index;
145:         for (fn_index = 0; fn_index < CAMERA_ARRAY_SIZE; fn_index++)
146:         {
147:             if (ff7_externals.camera_fn_array[fn_index] != 0)
148:             {
149:                 if (isNewCameraFunction[fn_index])
150:                 {
151:                     if (ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_position_sub_5C5B9C ||
152:                         ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_focal_sub_5C5F5E ||
153:                         ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_position_sub_5C557D ||
154:                         ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_focal_sub_5C5714)
155:                     {
156:                         ff7_externals.camera_fn_data[fn_index].n_frames *= battle_frame_multiplier;
157:                     }
158:                     else if (ff7_externals.camera_fn_array[fn_index] == ff7_externals.battle_camera_position_sub_5C3D0D)
159:                     {
160:                         ff7_externals.camera_fn_data[fn_index].n_frames *= battle_frame_multiplier;
161:                         ff7_externals.camera_fn_data[fn_index].field_8 /= battle_frame_multiplier;
162:                         ff7_externals.camera_fn_data[fn_index].field_6 /= battle_frame_multiplier;
163:                         ff7_externals.camera_fn_data[fn_index].field_E /= battle_frame_multiplier;
164:                     }
165: 
166:                     isNewCameraFunction[fn_index] = false;
167:                 }
168: 
169:                 ((void (*)())ff7_externals.camera_fn_array[fn_index])();
170:                 if (ff7_externals.camera_fn_data[fn_index].field_0 == (uint16_t)-1)
171:                 {
172:                     ff7_externals.camera_fn_data[fn_index].field_0 = 0;
173:                     ff7_externals.camera_fn_data[fn_index].field_2 = 0;
174:                     ff7_externals.camera_fn_array[fn_index] = 0;
175:                     *ff7_externals.camera_fn_counter = *ff7_externals.camera_fn_counter - 1;
176:                 }
177:             }
178:         }
179:         fn_index = 0;
180:     }
181: 
182:     void run_camera_focal_position_script(char variationIndex, DWORD param_2, short cameraScriptIdx)
183:     {
184:         auto cameraPosition = ff7_externals.battle_camera_focal_point;
185: 
186:         byte *scriptPtr = getCameraScriptPointer(variationIndex, cameraScriptIdx, true);
187:         short currentPosition = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].current_position;
188:         short framesToWait = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].frames_to_wait;
189: 
190:         bool executedOpCodeF5 = simulateCameraScript(scriptPtr, currentPosition, framesToWait, numArgsOpCode, endingFocalOpCodes);
191: 
192:         ((void (*)(char, DWORD, short))ff7_externals.set_camera_focal_position_scripts)(variationIndex, param_2, cameraScriptIdx);
193: 
194:         if (executedOpCodeF5)
195:             cameraPosition[variationIndex].frames_to_wait = framesToWait;
196:     }
197: 
198:     void run_camera_position_script(char variationIndex, DWORD param_2, short cameraScriptIdx)
199:     {
200:         auto cameraPosition = ff7_externals.battle_camera_position;
201: 
202:         byte *scriptPtr = getCameraScriptPointer(variationIndex, cameraScriptIdx, false);
203:         short currentPosition = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].current_position;
204:         short framesToWait = (cameraPosition[variationIndex].current_position == 255) ? 0 : cameraPosition[variationIndex].frames_to_wait;
205: 
206:         bool executedOpCodeF5 = simulateCameraScript(scriptPtr, currentPosition, framesToWait, numArgsPositionOpCode, endingPositionOpCodes);
207: 
208:         ((void (*)(char, DWORD, short))ff7_externals.set_camera_position_scripts)(variationIndex, param_2, cameraScriptIdx);
209: 
210:         if (executedOpCodeF5)
211:             cameraPosition[variationIndex].frames_to_wait = framesToWait;
212:     }
213: 
214:     void compute_interpolation_to_formation_camera()
215:     {
216:         ff7_externals.battle_camera_position[3].point = *ff7_externals.g_battle_camera_position;
217:         ff7_externals.battle_camera_focal_point[3].point = *ff7_externals.g_battle_camera_focal_point;
218:         int frame_steps = 2 * battle_frame_multiplier;
219:         vector3<short> delta_position, delta_focal_point;
220:         if (*ff7_externals.is_camera_moving_BFB2DC)
221:         {
222:             delta_position.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.x - ff7_externals.battle_camera_position[3].point.x) / frame_steps;
223:             if(delta_position.x == 0)
224:                 delta_position.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.x - ff7_externals.battle_camera_position[3].point.x) % frame_steps;
225:             ff7_externals.battle_camera_position[3].point.x += delta_position.x;
226: 
227:             delta_position.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.y - ff7_externals.battle_camera_position[3].point.y) / frame_steps;
228:             if(delta_position.y == 0)
229:                 delta_position.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.y - ff7_externals.battle_camera_position[3].point.y) % frame_steps;
230:             ff7_externals.battle_camera_position[3].point.y += delta_position.y;
231: 
232:             delta_position.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.z - ff7_externals.battle_camera_position[3].point.z) / frame_steps;
233:             if(delta_position.z == 0)
234:                 delta_position.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position.z - ff7_externals.battle_camera_position[3].point.z) % frame_steps;
235:             ff7_externals.battle_camera_position[3].point.z += delta_position.z;
236: 
237:             delta_focal_point.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.x - ff7_externals.battle_camera_focal_point[3].point.x) / frame_steps;
238:             if(delta_focal_point.x == 0)
239:                 delta_focal_point.x = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.x - ff7_externals.battle_camera_focal_point[3].point.x) % frame_steps;
240:             ff7_externals.battle_camera_focal_point[3].point.x += delta_focal_point.x;
241: 
242:             delta_focal_point.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.y - ff7_externals.battle_camera_focal_point[3].point.y) / frame_steps;
243:             if(delta_focal_point.y == 0)
244:                 delta_focal_point.y = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.y - ff7_externals.battle_camera_focal_point[3].point.y) % frame_steps;
245:             ff7_externals.battle_camera_focal_point[3].point.y += delta_focal_point.y;
246: 
247:             delta_focal_point.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.z - ff7_externals.battle_camera_focal_point[3].point.z) / frame_steps;
248:             if(delta_focal_point.z == 0)
249:                 delta_focal_point.z = (ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point.z - ff7_externals.battle_camera_focal_point[3].point.z) % frame_steps;
250:             ff7_externals.battle_camera_focal_point[3].point.z += delta_focal_point.z;
251: 
252:             if (!delta_position.x && !delta_position.y && !delta_position.z && !delta_focal_point.x && !delta_focal_point.y && !delta_focal_point.z)
253:                 *ff7_externals.is_camera_moving_BFB2DC = 0;
254:         }
255:     }
256: 
257:     void update_battle_camera(short cameraScriptIndex)
258:     {
259:         vector3<short>* pGlobalCameraPos = ff7_externals.g_battle_camera_position;
260:         vector3<short>* pCameraPosition = &ff7_externals.battle_camera_position[*ff7_externals.g_variation_index].point;
261:         vector3<short>* pFormationCameraPos = &ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position;
262: 
263:         ((void(*)(short))ff7_externals.update_battle_camera_sub_5C20CE)(cameraScriptIndex);
264: 
265:         byte battle_enter_frames_to_wait = *ff7_externals.battle_enter_frames_to_wait;
266:         if(cameraScriptIndex == -2 && battle_enter_frames_to_wait > 5)
267:         {
268:             camera.reset();
269:             camera.setupInitialCamera();
270:         }
271: 
272:         if((std::abs(pGlobalCameraPos->x - pFormationCameraPos->x) <= 1 &&
273:             std::abs(pGlobalCameraPos->y - pFormationCameraPos->y) <= 1 &&
274:             std::abs(pGlobalCameraPos->z - pFormationCameraPos->z) <= 1))
275:         {
276:             camera.controlCamera(pGlobalCameraPos);
277:             *pFormationCameraPos = *pGlobalCameraPos;
278:             *pCameraPosition = *pGlobalCameraPos;
279:         }
280: 
281:         if(cameraScriptIndex == -3) camera.reset();
282:     }
283: 
284:     void camera_hook_init()
285:     {
286:         replace_function(ff7_externals.execute_camera_functions, execute_camera_functions);
287:         replace_function(ff7_externals.add_fn_to_camera_fn_array, add_fn_to_camera_fn);
288:         replace_call_function(ff7_externals.handle_camera_functions + 0x35, run_camera_focal_position_script);
289:         replace_call_function(ff7_externals.handle_camera_functions + 0x4B, run_camera_position_script);
290: 
291:         // Battle outro camera frame fix: patch DAT_009AE138 (frames to wait before closing battle mode)
292:         patch_multiply_code<DWORD>(ff7_externals.battle_sub_430DD0 + 0x3DE, battle_frame_multiplier);
293:         patch_multiply_code<DWORD>(ff7_externals.battle_sub_430DD0 + 0x361, battle_frame_multiplier);
294:         patch_multiply_code<DWORD>(ff7_externals.battle_sub_430DD0 + 0x326, battle_frame_multiplier);
295: 
296:         // Battle outro fading speed fix
297:         patch_multiply_code<byte>(ff7_externals.battle_sub_430DD0 + 0x60E, battle_frame_multiplier);
298: 
299:         // Battle intro camera frame fix: patch DAT_00BFD0F4 (frames to wait before atb starts)
300:         patch_multiply_code<byte>(ff7_externals.battle_sub_429AC0 + 0x152, battle_frame_multiplier);
301:         patch_multiply_code<byte>(ff7_externals.battle_sub_429D8A + 0x1D8, battle_frame_multiplier);
302: 
303:         // Move camera back to formation camera FPS fix
304:         replace_function(ff7_externals.compute_interpolation_to_formation_camera, compute_interpolation_to_formation_camera);
305:     }
306: 
307:     void Camera::setRotationSpeed(float rotX, float rotY, float rotZ)
308:     {
309:         rotationSpeed.x = rotX / static_cast<float>(battle_frame_multiplier);
310:         rotationSpeed.y = rotY / static_cast<float>(battle_frame_multiplier);
311:         rotationSpeed.z = rotZ / static_cast<float>(battle_frame_multiplier);
312:     }
313: 
314:     void Camera::setZoomSpeed(float speed)
315:     {
316:         zoomSpeed = speed / static_cast<float>(battle_frame_multiplier);
317:     }
318: 
319:     void Camera::reset()
320:     {
321:         rotationOffset.x = 0.0f;
322:         rotationOffset.y = 0.0f;
323:         zoomOffset = 0.0f;
324:     }
325: 
326:     void  Camera::setupInitialCamera()
327:     {
328:         vector3<short>* pFormationCameraPos = &ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].position;
329:         vector3<short>* pFormationCameraFocusPos = &ff7_externals.formation_camera[*ff7_externals.curr_formation_camera_idx].focal_point;
330: 
331:         initialCameraPos.x = pFormationCameraPos->x;
332:         initialCameraPos.y = pFormationCameraPos->y;
333:         initialCameraPos.z = pFormationCameraPos->z;
334: 
335:         initialCameraFocusPos.x = pFormationCameraFocusPos->x;
336:         initialCameraFocusPos.y = pFormationCameraFocusPos->y;
337:         initialCameraFocusPos.z = pFormationCameraFocusPos->z;
338:     }
339: 
340:     void Camera::controlCamera(vector3<short>* cameraPosition)
341:     {
342:         static WORD last_battle_id = 0;
343: 
344:         bx::Vec3 cameraPos = {
345:             static_cast<float>(initialCameraPos.x),
346:             static_cast<float>(initialCameraPos.y),
347:             static_cast<float>(initialCameraPos.z)};
348:         bx::Vec3 cameraFocusPos = {
349:             static_cast<float>(initialCameraFocusPos.x),
350:             static_cast<float>(initialCameraFocusPos.y),
351:             static_cast<float>(initialCameraFocusPos.z)};
352: 
353:         float dist = bx::distance(cameraFocusPos, cameraPos);
354:         float candidateDist = dist - (zoomOffset + zoomSpeed);
355:         if(candidateDist < maxZoomDist && candidateDist > minZoomDist)
356:         {
357:             zoomOffset = zoomOffset + zoomSpeed;
358:         }
359: 
360:         bx::Vec3 up = { 0, 1, 0 };
361:         bx::Vec3 forward =  { cameraFocusPos.x - cameraPos.x,
362:                             cameraFocusPos.y - cameraPos.y,
363:                             cameraFocusPos.z - cameraPos.z};
364:         forward  = bx::normalize(forward);
365:         bx::Vec3 right = bx::cross(forward, up);
366: 
367:         cameraPos = bx::add(cameraPos, bx::mul(forward, zoomOffset));
368: 
369:         float dot = bx::dot(bx::mul(forward, 1.0), up);
370:         float angle = 180.0f * std::acosf(dot) / M_PI;
371:         float candidateAngle = angle + rotationOffset.x + rotationSpeed.x;
372:         rotationOffset.x += rotationSpeed.x;
373:         if(candidateAngle < minVerticalAngle)
374:             rotationOffset.x += minVerticalAngle - candidateAngle;
375:         if(candidateAngle > maxVerticalAngle)
376:             rotationOffset.x -= candidateAngle - maxVerticalAngle;
377: 
378:         rotationOffset.y = std::remainder(rotationOffset.y + rotationSpeed.y, 360.0f);
379: 
380:         auto quaternionH = bx::fromAxisAngle(up, M_PI * rotationOffset.y / 180.0f);
381:         auto quaternionV = bx::fromAxisAngle(right, M_PI * rotationOffset.x / 180.0f);
382: 
383:         auto quaternion = bx::mul(quaternionV, quaternionH);
384:         quaternion = bx::normalize(quaternion);
385: 
386:         float focusToOriginMatrix[16];
387:         bx::mtxTranslate(focusToOriginMatrix, -cameraFocusPos.x, -cameraFocusPos.y, -cameraFocusPos.z);
388: 
389:         float originToFocusMatrix[16];
390:         bx::mtxTranslate(originToFocusMatrix, cameraFocusPos.x, cameraFocusPos.y, cameraFocusPos.z);
391: 
392:         float rotMat[16];
393:         bx::mtxFromQuaternion(rotMat, quaternion);
394: 
395:         float tmp[16];
396:         bx::mtxMul(tmp, focusToOriginMatrix, rotMat);
397: 
398:         float tmp2[16];
399:         bx::mtxMul(tmp2, tmp, originToFocusMatrix);
400: 
401:         // Get new camera pos
402:         float newCameraPos[4] =  { 0.0f, 0.0f, 0.0f , 1.0f};
403:         float oldCameraPos[4] =  { cameraPos.x, cameraPos.y, cameraPos.z, 1.0f};
404:         bx::vec4MulMtx(newCameraPos, oldCameraPos, tmp2);
405: 
406:         cameraPosition->x = newCameraPos[0];
407:         cameraPosition->y = newCameraPos[1];
408:         cameraPosition->z = newCameraPos[2];
409:     }
410: }
</file>

<file path="src/ff7/battle/camera.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: #pragma once
17: 
18: #include "matrix.h"
19: 
20: namespace ff7::battle
21: {
22:     class Camera
23:     {
24:         public:
25:             Camera() = default;
26:             ~Camera() = default;
27: 
28:             void setRotationSpeed(float rotX, float rotY, float rotZ);
29:             vector3<float> getRotationSpeed();
30:             void setZoomSpeed(float speed);
31:             float getZoomSpeed();
32:             void reset();
33:             void setupInitialCamera();
34: 
35:             void controlCamera(vector3<short>* cameraPosition);
36:         private:
37:             vector3<float> rotationSpeed = { 0.0, 0.0, 0.0 };
38:             vector3<float> rotationOffset = { 0.0, 0.0, 0.0 };
39:             vector3<float> initialCameraPos = { 0.0, 0.0, 0.0 };
40:             vector3<float> initialCameraFocusPos = { 0.0, 0.0, 0.0 };
41:             float zoomSpeed = 0.0f;
42:             float zoomOffset = 0.0f;
43:             const float minZoomDist = 5000.0f;
44:             const float maxZoomDist = 30000.0f;
45:             const float minVerticalAngle = 5.0f;
46:             const float maxVerticalAngle = 85.0f;
47:     };
48: 
49:     inline vector3<float> Camera::getRotationSpeed()
50:     {
51:         return rotationSpeed;
52:     }
53: 
54:     inline float Camera::getZoomSpeed()
55:     {
56:         return zoomSpeed;
57:     }
58: 
59:     extern Camera camera;
60: }
</file>

<file path="src/ff7/battle/defs.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: namespace ff7::battle
27: {
28:     // Camera
29:     void camera_hook_init();
30:     void update_battle_camera(short cameraScriptIndex);
31:     void update_idle_battle_camera();
32: 
33:     // Animations
34:     void animations_hook_init();
35: 
36:     // Battle
37:     void magic_thread_start(void (*func)());
38:     void load_battle_stage(int param_1, int battle_location_id, int **param_3);
39:     void battle_sub_5C7F94(int param_1, int param_2);
40:     void display_battle_action_text_sub_6D71FA(short command_id, short action_id);
41:     int load_scene_bin_chunk(char *filename, int offset, int size, char **out_buffer, void (*callback)(void));
42: 
43:     // Menu
44:     void battle_menu_enter();
45:     void draw_ui_graphics_objects_wrapper(int flag, int type);
46: }
</file>

<file path="src/ff7/battle/effect.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "effect.h"
 25: 
 26: #include "../../globals.h"
 27: 
 28: namespace ff7::battle
 29: {
 30:     AuxiliaryEffectHandler::AuxiliaryEffectHandler()
 31:     {
 32:         this->isFirstTimeRunning = true;
 33:         this->effectDecorator = std::make_shared<NoEffectDecorator>();
 34:     }
 35: 
 36:     void NoEffectDecorator::callEffectFunction(uint32_t function)
 37:     {
 38:         ((void(*)())function)();
 39:     }
 40: 
 41:     void OneCallEffectDecorator::callEffectFunction(uint32_t function)
 42:     {
 43:         if(this->frameCounter % this->frequency == 0)
 44:         {
 45:             ((void(*)())function)();
 46:         }
 47:         this->frameCounter++;
 48:     }
 49: 
 50:     void PauseEffectDecorator::callEffectFunction(uint32_t function)
 51:     {
 52:         byte wasPaused = *this->isBattlePaused;
 53:         if(this->frameCounter % this->frequency != 0)
 54:         {
 55:             *this->isBattlePaused = 1;
 56:         }
 57: 
 58:         ((void(*)())function)();
 59: 
 60:         if(this->frameCounter % this->frequency != 0)
 61:         {
 62:             *this->isBattlePaused = wasPaused;
 63:         }
 64:         this->frameCounter++;
 65:     }
 66: 
 67:     void FixCounterEffectDecorator::callEffectFunction(uint32_t function)
 68:     {
 69:         uint16_t currentEffectActive = *this->effectActive;
 70:         short currentCounter = *this->effectCounter;
 71:         if(this->frameCounter % this->frequency == 0)
 72:         {
 73:             ((void(*)())function)();
 74:         }
 75:         else
 76:         {
 77:             *this->isAddFunctionDisabled = true;
 78:             ((void(*)())function)();
 79:             *this->isAddFunctionDisabled = false;
 80:             *this->effectCounter = currentCounter;
 81:         }
 82: 
 83:         // Change active status of the function only at the last repeated frame
 84:         if(this->frameCounter % this->frequency != this->frequency - 1)
 85:         {
 86:             *this->effectActive = currentEffectActive;
 87:         }
 88: 
 89:         this->frameCounter++;
 90:     }
 91: 
 92:     void FixCounterExceptionEffectDecorator::callEffectFunction(uint32_t function)
 93:     {
 94:         uint16_t currentEffectActive = *this->effectActive;
 95:         short currentCounter = *this->effectCounter;
 96: 
 97:         if(this->frameCounter % this->frequency == 0)
 98:         {
 99:             ((void(*)())function)();
100:         }
101:         else
102:         {
103:             *this->isAddFunctionDisabled = true;
104:             if(!this->excludedFrames.contains(currentCounter)){
105:                 ((void(*)())function)();
106:             }
107:             else
108:             {
109:                 *this->effectCounter = *this->effectCounter + 1;
110:                 ((void(*)())function)();
111:             }
112:             *this->effectCounter = currentCounter;
113:             *this->isAddFunctionDisabled = false;
114:         }
115: 
116:         // Change active status of the function only at the last repeated frame
117:         if(this->frameCounter % this->frequency != this->frequency - 1)
118:         {
119:             *this->effectActive = currentEffectActive;
120:         }
121: 
122:         this->frameCounter++;
123:     }
124: 
125:     InterpolationEffectDecorator::InterpolationEffectDecorator(int frequency, byte* isBattlePausedExt)
126:     {
127:         this->frameCounter = 0;
128:         this->frequency = frequency;
129:         this->isBattlePaused = isBattlePausedExt;
130:         this->textureCallIdx = 0;
131:     }
132: 
133:     uint64_t InterpolationEffectDecorator::getCantorHash(uint32_t x, uint32_t y)
134:     {
135:         return ((x + y) * (x + y + 1)) / 2 + y;
136:     }
137: 
138:     void InterpolationEffectDecorator::callEffectFunction(uint32_t function)
139:     {
140:         byte wasPaused = *this->isBattlePaused;
141:         this->textureCallIdx = 0;
142: 
143:         if(this->frameCounter % this->frequency == 0)
144:         {
145:             this->previousFrameDataMap.clear();
146:             this->_doInterpolation = false;
147:             ((void(*)())function)();
148:             this->textureNumCalls = this->textureCallIdx;
149:         }
150:         else
151:         {
152:             this->_doInterpolation = true;
153:             *this->isBattlePaused = 1;
154:             ((void(*)())function)();
155:             *this->isBattlePaused = wasPaused;
156:         }
157: 
158:         this->frameCounter++;
159:     }
160: 
161:     void InterpolationEffectDecorator::saveInterpolationData(interpolationable_data &&currData, uint32_t returnAddress)
162:     {
163:         uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
164:         this->previousFrameDataMap[hash] = std::move(currData);
165:     }
166: 
167:     void InterpolationEffectDecorator::interpolateRotationMatrix(rotation_matrix* nextRotationMatrix, uint32_t returnAddress)
168:     {
169:         uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
170:         if(this->previousFrameDataMap.contains(hash))
171:         {
172:             int interpolationStep = this->frameCounter % this->frequency;
173:             const rotation_matrix &previousMatrix = this->previousFrameDataMap[hash].rot_matrix;
174:             for(int i = 0; i < 3; i++)
175:                 for(int j = 0; j < 3; j++)
176:                     nextRotationMatrix->r3_sub_matrix[i][j] = interpolateValue(previousMatrix.r3_sub_matrix[i][j],nextRotationMatrix->r3_sub_matrix[i][j], interpolationStep, this->frequency);
177: 
178:             for(int i = 0; i < 3; i++)
179:                 nextRotationMatrix->position[i] = interpolateValue(previousMatrix.position[i], nextRotationMatrix->position[i], interpolationStep, this->frequency);
180:         }
181:     }
182: 
183:     void InterpolationEffectDecorator::interpolateMaterialContext(material_anim_ctx &nextMaterialCtx, uint32_t returnAddress)
184:     {
185:         uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
186:         if(this->previousFrameDataMap.contains(hash))
187:         {
188:             int interpolationStep = this->frameCounter % this->frequency;
189:             const material_anim_ctx &previousMaterialCtx = this->previousFrameDataMap[hash].material_ctx;
190:             nextMaterialCtx.transparency = interpolateValue(previousMaterialCtx.transparency, nextMaterialCtx.transparency, interpolationStep, this->frequency);
191:             nextMaterialCtx.field_8 = interpolateValue(previousMaterialCtx.field_8, nextMaterialCtx.field_8, interpolationStep, this->frequency);
192:         }
193:     }
194: 
195:     void InterpolationEffectDecorator::interpolateColor(color_ui8 *nextColor, uint32_t returnAddress)
196:     {
197:         uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
198:         if(this->previousFrameDataMap.contains(hash))
199:         {
200:             int interpolationStep = this->frameCounter % this->frequency;
201:             const color_ui8 previousColor = this->previousFrameDataMap[hash].color;
202:             nextColor->b = interpolateValue(previousColor.b, nextColor->b, interpolationStep, this->frequency);
203:             nextColor->g = interpolateValue(previousColor.g, nextColor->g, interpolationStep, this->frequency);
204:             nextColor->r = interpolateValue(previousColor.r, nextColor->r, interpolationStep, this->frequency);
205:             nextColor->a = interpolateValue(previousColor.a, nextColor->a, interpolationStep, this->frequency);
206:         }
207:     }
208: 
209:     void InterpolationEffectDecorator::interpolatePalette(palette_extra &nextPalette, uint32_t returnAddress)
210:     {
211:         uint64_t hash = this->getCantorHash(returnAddress, this->textureCallIdx);
212:         if(this->previousFrameDataMap.contains(hash))
213:         {
214:             int interpolationStep = this->frameCounter % this->frequency;
215:             const palette_extra &previousPalette = this->previousFrameDataMap[hash].palette;
216:             nextPalette.x_offset = interpolateValue(previousPalette.x_offset, nextPalette.x_offset, interpolationStep, this->frequency);
217:             nextPalette.y_offset = interpolateValue(previousPalette.y_offset, nextPalette.y_offset, interpolationStep, this->frequency);
218:             nextPalette.z_offset = interpolateValue(previousPalette.z_offset, nextPalette.z_offset, interpolationStep, this->frequency);
219:             nextPalette.field_24 = interpolateValue(previousPalette.field_24, nextPalette.field_24, interpolationStep, this->frequency);
220:             nextPalette.z_offset_2 = interpolateValue(previousPalette.z_offset_2, nextPalette.z_offset_2, interpolationStep, this->frequency);
221:             nextPalette.scroll_v = interpolateValue(previousPalette.scroll_v, nextPalette.scroll_v, interpolationStep, this->frequency);
222:             nextPalette.v_offset = interpolateValue(previousPalette.v_offset, nextPalette.v_offset, interpolationStep, this->frequency);
223:         }
224:     }
225: 
226:     bool ModelInterpolationEffectDecorator::isSmoothMovement(vector3<short> previous, vector3<short> next)
227:     {
228:         double distance = std::sqrt(std::pow(next.x - previous.x, 2) + std::pow(next.y - previous.y, 2) + std::pow(next.z - previous.z, 2));
229:         return distance < this->threshold;
230:     }
231: 
232:     void ModelInterpolationEffectDecorator::callEffectFunction(uint32_t function)
233:     {
234:         byte wasPaused = *this->isBattlePaused;
235:         uint16_t currentEffectActive = *this->effectActive;
236: 
237:         if(this->frameCounter == 0)
238:         {
239:             ((void(*)())function)();
240:             this->nextPosition = ff7_externals.g_battle_model_state[this->actorID].modelPosition;
241:         }
242:         else
243:         {
244:             int interpolationStep = this->frameCounter % this->frequency;
245:             if((this->frameCounter - 1) % this->frequency == 0)
246:             {
247:                 this->previousPosition = this->nextPosition;
248:                 ((void(*)())function)();
249:                 this->nextPosition = ff7_externals.g_battle_model_state[this->actorID].modelPosition;
250: 
251:                 if(isSmoothMovement(this->previousPosition, this->nextPosition))
252:                 {
253:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition.x = interpolateValue(this->previousPosition.x, this->nextPosition.x, interpolationStep, this->frequency);
254:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition.y = interpolateValue(this->previousPosition.y, this->nextPosition.y, interpolationStep, this->frequency);
255:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition.z = interpolateValue(this->previousPosition.z, this->nextPosition.z, interpolationStep, this->frequency);
256:                 }
257:                 else
258:                 {
259:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition = this->previousPosition;
260:                 }
261: 
262:                 if(*this->effectActive == (uint16_t)-1 && currentEffectActive != *this->effectActive)
263:                 {
264:                     *this->effectActive = currentEffectActive;
265:                     this->finalFrame = this->frameCounter + this->frequency - 1;
266:                 }
267:             }
268:             else if((this->frameCounter - 1) % this->frequency == this->frequency - 1)
269:             {
270:                 if(usePauseTrick)
271:                 {
272:                     *this->isBattlePaused = 1;
273:                     ((void(*)())function)();
274:                     *this->isBattlePaused = wasPaused;
275:                 }
276: 
277:                 ff7_externals.g_battle_model_state[this->actorID].modelPosition = this->nextPosition;
278:             }
279:             else
280:             {
281:                 if(usePauseTrick)
282:                 {
283:                     *this->isBattlePaused = 1;
284:                     ((void(*)())function)();
285:                     *this->isBattlePaused = wasPaused;
286:                 }
287: 
288:                 if(isSmoothMovement(this->previousPosition, this->nextPosition))
289:                 {
290:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition.x = interpolateValue(this->previousPosition.x, this->nextPosition.x, interpolationStep, this->frequency);
291:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition.y = interpolateValue(this->previousPosition.y, this->nextPosition.y, interpolationStep, this->frequency);
292:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition.z = interpolateValue(this->previousPosition.z, this->nextPosition.z, interpolationStep, this->frequency);
293:                 }
294:                 else
295:                 {
296:                     ff7_externals.g_battle_model_state[this->actorID].modelPosition = this->previousPosition;
297:                 }
298:             }
299:         }
300: 
301:         if(this->finalFrame == this->frameCounter)
302:         {
303:             *this->effectActive = (uint16_t)-1;
304:         }
305: 
306:         this->frameCounter++;
307:     }
308: 
309:     bool CameraInterpolationEffectDecorator::isSmoothMovement(vector3<short> previous, vector3<short> next)
310:     {
311:         double distance = std::sqrt(std::pow(next.x - previous.x, 2) + std::pow(next.y - previous.y, 2) + std::pow(next.z - previous.z, 2));
312:         return distance < this->threshold;
313:     }
314: 
315:     void CameraInterpolationEffectDecorator::callEffectFunction(uint32_t function)
316:     {
317:         byte wasPaused = *this->isBattlePaused;
318:         uint16_t currentEffectActive = *this->effectActive;
319: 
320:         if(this->frameCounter == 0)
321:         {
322:             ((void(*)())function)();
323:             this->nextCameraPosition = *ff7_externals.g_battle_camera_position;
324:             this->nextCameraFocalPoint = *ff7_externals.g_battle_camera_focal_point;
325:         }
326:         else
327:         {
328:             int interpolationStep = this->frameCounter % this->frequency;
329:             if((this->frameCounter - 1) % this->frequency == 0)
330:             {
331:                 this->previousCameraPosition = this->nextCameraPosition;
332:                 this->previousCameraFocalPoint = this->nextCameraFocalPoint;
333:                 ((void(*)())function)();
334:                 this->nextCameraPosition = *ff7_externals.g_battle_camera_position;
335:                 this->nextCameraFocalPoint = *ff7_externals.g_battle_camera_focal_point;
336: 
337:                 if(isSmoothMovement(this->previousCameraPosition, this->nextCameraPosition) && isSmoothMovement(this->previousCameraFocalPoint, this->nextCameraFocalPoint))
338:                 {
339:                     ff7_externals.g_battle_camera_position->x = interpolateValue(this->previousCameraPosition.x, this->nextCameraPosition.x, interpolationStep, this->frequency);
340:                     ff7_externals.g_battle_camera_position->y = interpolateValue(this->previousCameraPosition.y, this->nextCameraPosition.y, interpolationStep, this->frequency);
341:                     ff7_externals.g_battle_camera_position->z = interpolateValue(this->previousCameraPosition.z, this->nextCameraPosition.z, interpolationStep, this->frequency);
342:                     ff7_externals.g_battle_camera_focal_point->x = interpolateValue(this->previousCameraFocalPoint.x, this->nextCameraFocalPoint.x, interpolationStep, this->frequency);
343:                     ff7_externals.g_battle_camera_focal_point->y = interpolateValue(this->previousCameraFocalPoint.y, this->nextCameraFocalPoint.y, interpolationStep, this->frequency);
344:                     ff7_externals.g_battle_camera_focal_point->z = interpolateValue(this->previousCameraFocalPoint.z, this->nextCameraFocalPoint.z, interpolationStep, this->frequency);
345:                 }
346:                 else
347:                 {
348:                     *ff7_externals.g_battle_camera_position = this->previousCameraPosition;
349:                     *ff7_externals.g_battle_camera_focal_point = this->previousCameraFocalPoint;
350:                 }
351: 
352:                 if(*this->effectActive == (uint16_t)-1 && currentEffectActive != *this->effectActive)
353:                 {
354:                     *this->effectActive = currentEffectActive;
355:                     this->finalFrame = this->frameCounter + this->frequency - 1;
356:                 }
357:             }
358:             else if((this->frameCounter - 1) % this->frequency == this->frequency - 1)
359:             {
360:                 *this->isBattlePaused = 1;
361:                 ((void(*)())function)();
362:                 *this->isBattlePaused = wasPaused;
363: 
364:                 *ff7_externals.g_battle_camera_position = this->nextCameraPosition;
365:                 *ff7_externals.g_battle_camera_focal_point = this->nextCameraFocalPoint;
366:             }
367:             else
368:             {
369:                 *this->isBattlePaused = 1;
370:                 ((void(*)())function)();
371:                 *this->isBattlePaused = wasPaused;
372: 
373:                 if(isSmoothMovement(this->previousCameraPosition, this->nextCameraPosition) && isSmoothMovement(this->previousCameraFocalPoint, this->nextCameraFocalPoint))
374:                 {
375:                     ff7_externals.g_battle_camera_position->x = interpolateValue(this->previousCameraPosition.x, this->nextCameraPosition.x, interpolationStep, this->frequency);
376:                     ff7_externals.g_battle_camera_position->y = interpolateValue(this->previousCameraPosition.y, this->nextCameraPosition.y, interpolationStep, this->frequency);
377:                     ff7_externals.g_battle_camera_position->z = interpolateValue(this->previousCameraPosition.z, this->nextCameraPosition.z, interpolationStep, this->frequency);
378:                     ff7_externals.g_battle_camera_focal_point->x = interpolateValue(this->previousCameraFocalPoint.x, this->nextCameraFocalPoint.x, interpolationStep, this->frequency);
379:                     ff7_externals.g_battle_camera_focal_point->y = interpolateValue(this->previousCameraFocalPoint.y, this->nextCameraFocalPoint.y, interpolationStep, this->frequency);
380:                     ff7_externals.g_battle_camera_focal_point->z = interpolateValue(this->previousCameraFocalPoint.z, this->nextCameraFocalPoint.z, interpolationStep, this->frequency);
381:                 }
382:                 else
383:                 {
384:                     *ff7_externals.g_battle_camera_position = this->previousCameraPosition;
385:                     *ff7_externals.g_battle_camera_focal_point = this->previousCameraFocalPoint;
386:                 }
387:             }
388:         }
389: 
390:         if(this->finalFrame == this->frameCounter)
391:         {
392:             *this->effectActive = (uint16_t)-1;
393:         }
394: 
395:         this->frameCounter++;
396:     }
397: }
</file>

<file path="src/ff7/battle/effect.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #pragma once
 25: 
 26: #include "../../ff7.h"
 27: 
 28: #include <set>
 29: #include <unordered_map>
 30: #include <memory>
 31: 
 32: namespace ff7::battle
 33: {
 34:     struct interpolationable_data
 35:     {
 36:         rotation_matrix rot_matrix;
 37:         material_anim_ctx material_ctx;
 38:         color_ui8 color;
 39:         palette_extra palette;
 40:     };
 41: 
 42:     class EffectDecorator
 43:     {
 44:     public:
 45:         virtual void callEffectFunction(uint32_t function) = 0;
 46:     };
 47: 
 48:     class NoEffectDecorator: public EffectDecorator
 49:     {
 50:     public:
 51:         NoEffectDecorator() = default;
 52:         void callEffectFunction(uint32_t function) override;
 53:     };
 54: 
 55:     class OneCallEffectDecorator: public EffectDecorator
 56:     {
 57:     protected:
 58:         int frameCounter;
 59:         int frequency;
 60:         OneCallEffectDecorator() = default;
 61: 
 62:     public:
 63:         OneCallEffectDecorator(int frequency): frameCounter(0), frequency(frequency) {};
 64:         void callEffectFunction(uint32_t function) override;
 65:     };
 66: 
 67:     class PauseEffectDecorator: public EffectDecorator
 68:     {
 69:     protected:
 70:         int frameCounter;
 71:         int frequency;
 72:         byte* isBattlePaused;
 73:         PauseEffectDecorator() = default;
 74: 
 75:     public:
 76:         PauseEffectDecorator(int frequency, byte* isBattlePausedExt): frameCounter(0), frequency(frequency), isBattlePaused(isBattlePausedExt) {};
 77:         void callEffectFunction(uint32_t function) override;
 78:     };
 79: 
 80:     class FixCounterEffectDecorator: public EffectDecorator
 81:     {
 82:     protected:
 83:         int frameCounter;
 84:         int frequency;
 85:         uint16_t *effectActive;
 86:         short *effectCounter;
 87:         bool *isAddFunctionDisabled;
 88:         FixCounterEffectDecorator() = default;
 89: 
 90:     public:
 91:         FixCounterEffectDecorator(int frequency, uint16_t* effectActive, short* effectCounter, bool* isAddFunctionDisabled): frameCounter(0),
 92:                                                                                                         frequency(frequency),
 93:                                                                                                         effectActive(effectActive),
 94:                                                                                                         effectCounter(effectCounter),
 95:                                                                                                         isAddFunctionDisabled(isAddFunctionDisabled) {};
 96:         void callEffectFunction(uint32_t function) override;
 97:     };
 98: 
 99:     class FixCounterExceptionEffectDecorator: public FixCounterEffectDecorator
100:     {
101:     protected:
102:         std::set<short> excludedFrames;
103: 
104:     public:
105:         inline FixCounterExceptionEffectDecorator(int frequency, uint16_t* effectActive, short* effectCounter,
106:                                                 bool* isAddFunctionDisabled, std::set<short> excludedFrames) : FixCounterEffectDecorator(frequency, effectActive, effectCounter, isAddFunctionDisabled)
107:         {
108:             this->excludedFrames = excludedFrames;
109:         }
110:         void callEffectFunction(uint32_t function) override;
111:     };
112: 
113:     class InterpolationEffectDecorator: public PauseEffectDecorator
114:     {
115:     protected:
116:         std::unordered_map<uint64_t, interpolationable_data> previousFrameDataMap;
117:         int textureCallIdx;
118:         int textureNumCalls;
119:         bool _doInterpolation;
120: 
121:     public:
122:         InterpolationEffectDecorator(int frequency, byte* isBattlePausedExt);
123:         void callEffectFunction(uint32_t function) override;
124:         uint64_t getCantorHash(uint32_t x, uint32_t y);
125: 
126:         inline bool doInterpolation(){return _doInterpolation;}
127:         inline void addTextureIndex(){textureCallIdx++;}
128:         inline int getTextureNumCalls(){return textureNumCalls;}
129: 
130:         void saveInterpolationData(interpolationable_data &&currData, uint32_t materialAddress);
131:         void interpolateRotationMatrix(rotation_matrix* nextRotationMatrix, uint32_t materialAddress);
132:         void interpolateMaterialContext(material_anim_ctx &nextMaterialCtx, uint32_t materialAddress);
133:         void interpolateColor(color_ui8 *color, uint32_t materialAddress);
134:         void interpolatePalette(palette_extra &paletteExtraData, uint32_t materialAddress);
135:     };
136: 
137:     class ModelInterpolationEffectDecorator: public PauseEffectDecorator
138:     {
139:     protected:
140:         uint16_t *effectActive;
141:         int actorID;
142:         int finalFrame = -1;
143:         bool usePauseTrick = true;
144:         int threshold = 1000;
145: 
146:         vector3<short> previousPosition;
147:         vector3<short> nextPosition;
148: 
149:         bool isSmoothMovement(vector3<short> previous, vector3<short> next);
150: 
151:     public:
152:         ModelInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, bool usePauseTrick, uint16_t* effectActive,
153:                                         int actorID) : PauseEffectDecorator(frequency, isBattlePausedExt), usePauseTrick(usePauseTrick),
154:                                                         effectActive(effectActive), actorID(actorID) {};
155: 
156:         ModelInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, bool usePauseTrick, uint16_t* effectActive,
157:                                         int actorID, int threshold) : PauseEffectDecorator(frequency, isBattlePausedExt), usePauseTrick(usePauseTrick),
158:                                                                         effectActive(effectActive), actorID(actorID), threshold(threshold) {};
159: 
160:         void callEffectFunction(uint32_t function) override;
161:     };
162: 
163:     class CameraInterpolationEffectDecorator: public PauseEffectDecorator
164:     {
165:     protected:
166:         uint16_t *effectActive;
167:         int finalFrame = -1;
168:         int threshold = 1500;
169: 
170:         vector3<short> previousCameraPosition;
171:         vector3<short> previousCameraFocalPoint;
172:         vector3<short> nextCameraPosition;
173:         vector3<short> nextCameraFocalPoint;
174: 
175:         bool isSmoothMovement(vector3<short> previous, vector3<short> next);
176: 
177:     public:
178:         CameraInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, uint16_t* effectActive): PauseEffectDecorator(frequency, isBattlePausedExt),
179:                                                                                                             effectActive(effectActive) {};
180: 
181:         CameraInterpolationEffectDecorator(int frequency, byte* isBattlePausedExt, uint16_t* effectActive, int threshold): PauseEffectDecorator(frequency, isBattlePausedExt),
182:                                                                                                                         effectActive(effectActive),
183:                                                                                                                         threshold(threshold) {};
184: 
185:         void callEffectFunction(uint32_t function) override;
186:     };
187: 
188:     class AuxiliaryEffectHandler
189:     {
190:     private:
191:         bool isFirstTimeRunning;
192:         std::shared_ptr<EffectDecorator> effectDecorator;
193: 
194:     public:
195:         AuxiliaryEffectHandler();
196: 
197:         inline std::shared_ptr<EffectDecorator> getEffectDecorator() {return effectDecorator;}
198:         inline bool isFirstFrame() {return isFirstTimeRunning;}
199: 
200:         inline void setEffectDecorator(std::shared_ptr<EffectDecorator> effectDecorator) {this->effectDecorator = std::move(effectDecorator);}
201:         inline void disableFirstFrame() {this->isFirstTimeRunning = false;}
202:         inline void executeEffectFunction(uint32_t effectFunction) {effectDecorator->callEffectFunction(effectFunction);}
203:     };
204: 
205:     template <typename T>
206:     T interpolateValue(T previous, T next, int step, int n_steps)
207:     {
208:         return previous + ((next - previous) * step) / n_steps;
209:     }
210: }
</file>

<file path="src/ff7/battle/menu.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #include "../../globals.h"
25: #include "../../renderer.h"
26: 
27: #include "menu.h"
28: #include "cfg.h"
29: #include "defs.h"
30: #include "gl.h"
31: 
32: namespace ff7::battle
33: {
34:     void battle_menu_enter()
35:     {
36:         *ff7_externals.g_do_render_menu = 0;
37:         battle_depth_clear();
38: 
39:         if (enable_time_cycle) newRenderer.setTimeFilterEnabled(false);
40:     }
41: 
42:     void battle_depth_clear()
43:     {
44:         if(gl_defer_battle_depth_clear()) return;
45: 
46:         newRenderer.clearDepthBuffer();
47:     }
48: 
49:     void delay_battle_target_pointer_animation_type()
50:     {
51:         if(frame_counter % battle_frame_multiplier == 0)
52:         {
53:             (*ff7_externals.targeting_actor_id_DC3C98)++;
54:         }
55:     }
56: 
57:     void draw_ui_graphics_objects_wrapper(int flag, int type)
58:     {
59:         if (enable_time_cycle) newRenderer.setTimeFilterEnabled(false);
60: 
61:         ff7_externals.battle_draw_call_42908C(flag, type);
62: 
63:         if (enable_time_cycle) newRenderer.setTimeFilterEnabled(true);
64:     }
65: }
</file>

<file path="src/ff7/battle/menu.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: namespace ff7::battle
27: {
28:     void delay_battle_target_pointer_animation_type();
29:     void battle_depth_clear();
30: }
</file>

<file path="src/ff7/field/background.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //    Copyright (C) 2023 Cosmos                                             //
  10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
  11: //                                                                          //
  12: //    This file is part of FFNx                                             //
  13: //                                                                          //
  14: //    FFNx is free software: you can redistribute it and/or modify          //
  15: //    it under the terms of the GNU General Public License as published by  //
  16: //    the Free Software Foundation, either version 3 of the License         //
  17: //                                                                          //
  18: //    FFNx is distributed in the hope that it will be useful,               //
  19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  21: //    GNU General Public License for more details.                          //
  22: /****************************************************************************/
  23: 
  24: #include "../../common.h"
  25: #include "../../globals.h"
  26: #include "../widescreen.h"
  27: 
  28: #include "../../renderer.h"
  29: 
  30: #include "background.h"
  31: #include "defs.h"
  32: #include "utils.h"
  33: #include "camera.h"
  34: 
  35: #include <functional>
  36: 
  37: namespace ff7::field
  38: {
  39:     constexpr float MIN_STEP_INVERSE = 10.f;
  40: 
  41:     // ##################################################################
  42:     // ----------------- DRAW GRAPHICS RELATED --------------------------
  43:     // ##################################################################
  44: 
  45:     void field_layer1_pick_tiles(short bg_position_x, short bg_position_y)
  46:     {
  47:         int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
  48:         vector2<float> bg_position, initial_pos, tile_position;
  49:         field_tile* layer1_tiles = *ff7_externals.field_layer1_tiles;
  50: 
  51:         bg_position.x = bg_position_x;
  52:         bg_position.y = bg_position_y;
  53:         if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
  54:         {
  55:             if(is_position_valid(bg_main_layer_pos))
  56:             {
  57:                 bg_position.x = bg_main_layer_pos.x;
  58:                 bg_position.y = bg_main_layer_pos.y;
  59:             }
  60:         }
  61: 
  62:         initial_pos.x = field_bg_multiplier * (320 - bg_position.x);
  63:         initial_pos.y = field_bg_multiplier * ((ff7_field_center ? 232 : 224) - bg_position.y);
  64: 
  65:         if(*ff7_externals.field_special_y_offset > 0 && bg_position.y <= 6)
  66:             initial_pos.y -= field_bg_multiplier * (*ff7_externals.field_special_y_offset);
  67: 
  68:         for(int i = 0; i < *ff7_externals.field_layer1_tiles_num; i++)
  69:         {
  70:             uint32_t tile_index = (*ff7_externals.field_layer1_palette_sort)[i];
  71:             layer1_tiles[tile_index].field_1044 = 1;
  72: 
  73:             tile_position.x = initial_pos.x + field_bg_multiplier * layer1_tiles[tile_index].x;
  74:             tile_position.y = initial_pos.y + field_bg_multiplier * layer1_tiles[tile_index].y;
  75:             ff7_externals.add_page_tile(tile_position.x, tile_position.y, 0.9997, layer1_tiles[tile_index].u,
  76:                                         layer1_tiles[tile_index].v, layer1_tiles[tile_index].palette_index, layer1_tiles[tile_index].page);
  77:         }
  78:     }
  79: 
  80:     void field_layer2_pick_tiles(short bg_position_x, short bg_position_y)
  81:     {
  82:         int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
  83:         field_tile *layer2_tiles = *ff7_externals.field_layer2_tiles;
  84:         vector2<float> bg_position, initial_pos;
  85: 
  86:         bg_position.x = bg_position_x;
  87:         bg_position.y = bg_position_y;
  88:         if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
  89:         {
  90:             if(is_position_valid(bg_main_layer_pos))
  91:             {
  92:                 bg_position.x = bg_main_layer_pos.x;
  93:                 bg_position.y = bg_main_layer_pos.y;
  94:             }
  95:         }
  96: 
  97:         initial_pos.x = (320 - bg_position.x) * field_bg_multiplier;
  98:         initial_pos.y = ((ff7_field_center ? 232 : 224) - bg_position.y) * field_bg_multiplier;
  99:         if(*ff7_externals.field_special_y_offset > 0 && bg_position.y <= 8)
 100:             initial_pos.y -= (*ff7_externals.field_special_y_offset) * field_bg_multiplier;
 101: 
 102:         for(int i = 0; i < *ff7_externals.field_layer2_tiles_num; i++)
 103:         {
 104:             uint32_t tile_index = (*ff7_externals.field_layer2_palette_sort)[i];
 105:             vector2<float> tile_position;
 106: 
 107:             char anim_group = layer2_tiles[tile_index].anim_group;
 108:             if(anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer2_tiles[tile_index].anim_bitmask))
 109:                 continue;
 110: 
 111:             layer2_tiles[tile_index].field_1040 = 1;
 112: 
 113:             tile_position.x = layer2_tiles[tile_index].x * field_bg_multiplier + initial_pos.x;
 114:             tile_position.y = layer2_tiles[tile_index].y * field_bg_multiplier + initial_pos.y;
 115: 
 116:             uint32_t page = (layer2_tiles[tile_index].use_fx_page) ? layer2_tiles[tile_index].fx_page : layer2_tiles[tile_index].page;
 117: 
 118:             if(layer2_tiles[tile_index].use_fx_page && layer2_tiles[tile_index].blend_mode == 2) page += 14;
 119:             if(layer2_tiles[tile_index].use_fx_page && layer2_tiles[tile_index].blend_mode == 3) page += 18;
 120: 
 121:             ff7_externals.add_page_tile(tile_position.x, tile_position.y, layer2_tiles[tile_index].z, layer2_tiles[tile_index].u,
 122:                                         layer2_tiles[tile_index].v, layer2_tiles[tile_index].palette_index, page);
 123:         }
 124:     }
 125: 
 126:     void field_layer3_shift_tile_position(vector2<float>* tile_position, vector2<float>* bg_position, int layer3_width, int layer3_height)
 127:     {
 128:         const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
 129:         const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
 130:         const int top_offset = 256 + (enable_uncrop ? 8 : 0);
 131:         const int bottom_offset = enable_uncrop ? 8 : 0;
 132:         const int half_width = is_fieldmap_wide() ? ceil(wide_viewport_width / 4) : 160;
 133:         const int half_height = enable_uncrop ? 120 : 112;
 134: 
 135:         if(tile_position->x <= bg_position->x - left_offset || tile_position->x >= bg_position->x + right_offset)
 136:             tile_position->x += (tile_position->x >= bg_position->x - half_width) ? -layer3_width : layer3_width;
 137: 
 138:         if(tile_position->y <= bg_position->y - top_offset || tile_position->y >= bg_position->y + bottom_offset)
 139:             tile_position->y += (tile_position->y >= bg_position->y - half_height) ? -layer3_height : layer3_height;
 140:     }
 141: 
 142:     void field_layer3_pick_tiles(short bg_position_x, short bg_position_y)
 143:     {
 144:         if(!*ff7_externals.do_draw_layer3_CFFE3C)
 145:             return;
 146: 
 147:         float z_value;
 148:         int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
 149:         field_tile *layer3_tiles = *ff7_externals.field_layer3_tiles;
 150:         vector2<float> bg_position, initial_pos;
 151: 
 152:         bg_position.x = bg_position_x;
 153:         bg_position.y = bg_position_y;
 154:         if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
 155:         {
 156:             if(is_position_valid(bg_layer3_pos))
 157:             {
 158:                 bg_position.x = bg_layer3_pos.x;
 159:                 bg_position.y = bg_layer3_pos.y;
 160:             }
 161:         }
 162: 
 163:         initial_pos.x = (320 - bg_position.x) * field_bg_multiplier;
 164:         initial_pos.y = ((ff7_field_center ? 232 : 224) - bg_position.y) * field_bg_multiplier;
 165:         if(ff7_externals.modules_global_object->field_B0 < 0xFFF)
 166:             z_value = ff7_externals.field_layer_sub_623C0F(ff7_externals.field_camera_rotation_matrix_CFF3D8, ff7_externals.modules_global_object->field_B0, 0, 0);
 167:         else
 168:             z_value = 0.9998;
 169: 
 170:         const bool do_increase_height = enable_uncrop;
 171:         const bool do_increase_width = is_fieldmap_wide() && (*ff7_externals.field_triggers_header)->bg3_width < ceil(wide_viewport_width / 2);
 172:         const int layer3_width = (*ff7_externals.field_triggers_header)->bg3_width * (do_increase_width ? 2 : 1);
 173:         const int layer3_height = (*ff7_externals.field_triggers_header)->bg3_height * (do_increase_height ? 2 : 1);
 174:         const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
 175:         const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
 176:         const int top_offset = 256 + (enable_uncrop ? 8 : 0);
 177:         const int bottom_offset = enable_uncrop ? 8 : 0;
 178: 
 179:         for(int i = 0; i < *ff7_externals.field_layer3_tiles_num; i++)
 180:         {
 181:             uint32_t tile_index = (*ff7_externals.field_layer3_palette_sort)[i];
 182:             vector2<float> tile_position = {
 183:                 static_cast<float>(layer3_tiles[tile_index].x),
 184:                 static_cast<float>(layer3_tiles[tile_index].y)
 185:             };
 186: 
 187:             field_layer3_shift_tile_position(&tile_position, &bg_position, layer3_width, layer3_height);
 188: 
 189:             char anim_group = layer3_tiles[tile_index].anim_group;
 190:             if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
 191:                 tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
 192:                 (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer3_tiles[tile_index].anim_bitmask)))
 193:                 continue;
 194: 
 195:             layer3_tiles[tile_index].field_1040 = 1;
 196:             tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
 197:             tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;
 198: 
 199:             uint32_t page = (layer3_tiles[tile_index].use_fx_page) ? layer3_tiles[tile_index].fx_page : layer3_tiles[tile_index].page;
 200: 
 201:             ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer3_tiles[tile_index].u,
 202:                                         layer3_tiles[tile_index].v, layer3_tiles[tile_index].palette_index, page);
 203:         }
 204: 
 205:         if(widescreen_enabled || enable_uncrop)
 206:         {
 207:             // Apply repeat x-y for background layer 4 tiles
 208:             std::vector<vector2<int>> tile_offsets;
 209:             if(do_increase_height)
 210:                 tile_offsets.push_back(vector2<int>{0, layer3_height /2});
 211: 
 212:             if(do_increase_width){
 213:                 tile_offsets.push_back(vector2<int>{layer3_width / 2, 0});
 214:                 tile_offsets.push_back(vector2<int>{layer3_width / 2, layer3_height / 2});
 215:             }
 216: 
 217:             for(vector2<int> tile_offset: tile_offsets)
 218:             {
 219:                 for(int i = 0; i < *ff7_externals.field_layer3_tiles_num; i++)
 220:                 {
 221:                     uint32_t tile_index = (*ff7_externals.field_layer3_palette_sort)[i];
 222:                     vector2<float> tile_position = {
 223:                         static_cast<float>(layer3_tiles[tile_index].x + tile_offset.x),
 224:                         static_cast<float>(layer3_tiles[tile_index].y + tile_offset.y)
 225:                     };
 226: 
 227:                     field_layer3_shift_tile_position(&tile_position, &bg_position, layer3_width, layer3_height);
 228: 
 229:                     char anim_group = layer3_tiles[tile_index].anim_group;
 230:                     if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
 231:                         tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
 232:                         (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer3_tiles[tile_index].anim_bitmask)))
 233:                         continue;
 234: 
 235:                     layer3_tiles[tile_index].field_1040 = 1;
 236:                     tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
 237:                     tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;
 238: 
 239:                     uint32_t page = (layer3_tiles[tile_index].use_fx_page) ? layer3_tiles[tile_index].fx_page : layer3_tiles[tile_index].page;
 240: 
 241:                     ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer3_tiles[tile_index].u,
 242:                                                 layer3_tiles[tile_index].v, layer3_tiles[tile_index].palette_index, page);
 243:                 }
 244:             }
 245:         }
 246:         *ff7_externals.field_layer3_flag_CFFE40 = 1;
 247:     }
 248: 
 249:     void field_layer4_shift_tile_position(vector2<float>* tile_position, vector2<float>* bg_position, int layer4_width, int layer4_height)
 250:     {
 251:         const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
 252:         const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
 253:         const int top_offset = 256 + (enable_uncrop ? 8 : 0);
 254:         const int bottom_offset = enable_uncrop ? 8 : 0;
 255:         const int half_width = is_fieldmap_wide() ? ceil(wide_viewport_width / 4) : 160;
 256: 
 257:         if(tile_position->x <= bg_position->x - left_offset || tile_position->x >= bg_position->x + right_offset)
 258:             tile_position->x += (tile_position->x >= bg_position->x - half_width) ? -layer4_width : layer4_width;
 259: 
 260:         if(tile_position->y <= bg_position->y - top_offset || tile_position->y >= bg_position->y + bottom_offset)
 261:             tile_position->y += (tile_position->y >= bg_position->y + bottom_offset) ? -layer4_height : layer4_height;
 262: 
 263:         if(widescreen_enabled && is_fieldmap_wide())
 264:         {
 265:             tile_position->x -= widescreen.getHorizontalOffset();
 266:         }
 267:     }
 268: 
 269:     void field_layer4_pick_tiles(short bg_position_x, short bg_position_y)
 270:     {
 271:         if(*ff7_externals.do_draw_layer4_CFFEA4)
 272:         {
 273:             int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
 274:             field_tile *layer4_tiles = *ff7_externals.field_layer4_tiles;
 275:             vector2<float> bg_position, initial_pos;
 276: 
 277:             bg_position.x = bg_position_x;
 278:             bg_position.y = bg_position_y;
 279:             if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
 280:             {
 281:                 if(is_position_valid(bg_layer4_pos))
 282:                 {
 283:                     bg_position.x = bg_layer4_pos.x;
 284:                     bg_position.y = bg_layer4_pos.y;
 285:                 }
 286:             }
 287: 
 288:             initial_pos.x = (320 - bg_position.x) * field_bg_multiplier;
 289:             initial_pos.y = ((ff7_field_center ? 232 : 224) - bg_position.y) * field_bg_multiplier;
 290:             float z_value = ff7_externals.field_layer_sub_623C0F(ff7_externals.field_camera_rotation_matrix_CFF3D8, ff7_externals.modules_global_object->field_AE, 0, 0);
 291: 
 292:             const bool do_increase_height = enable_uncrop;
 293:             const bool do_increase_width = is_fieldmap_wide() && (*ff7_externals.field_triggers_header)->bg4_width < ceil(wide_viewport_width / 2);
 294:             const int layer4_width = (*ff7_externals.field_triggers_header)->bg4_width * (do_increase_width ? 2 : 1);
 295:             const int layer4_height = (*ff7_externals.field_triggers_header)->bg4_height * (do_increase_height ? 2 : 1);
 296:             const int left_offset = 352 + (is_fieldmap_wide() ? abs(wide_viewport_x) : 0);
 297:             const int right_offset = is_fieldmap_wide() ? abs(wide_viewport_x) : 0;
 298:             const int top_offset = 256 + (enable_uncrop ? 8 : 0);
 299:             const int bottom_offset = enable_uncrop ? 8 : 0;
 300: 
 301:             for(int i = 0; i < *ff7_externals.field_layer4_tiles_num; i++)
 302:             {
 303:                 uint32_t tile_index = (*ff7_externals.field_layer4_palette_sort)[i];
 304:                 vector2<float> tile_position = {
 305:                     static_cast<float>(layer4_tiles[tile_index].x),
 306:                     static_cast<float>(layer4_tiles[tile_index].y)
 307:                 };
 308: 
 309:                 field_layer4_shift_tile_position(&tile_position, &bg_position, layer4_width, layer4_height);
 310: 
 311:                 char anim_group = layer4_tiles[tile_index].anim_group;
 312:                 if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
 313:                     tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
 314:                     (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer4_tiles[tile_index].anim_bitmask)))
 315:                     continue;
 316: 
 317:                 layer4_tiles[tile_index].field_1040 = 1;
 318:                 tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
 319:                 tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;
 320: 
 321:                 if(!*ff7_externals.field_layer_CFF1D8 || layer4_tiles[tile_index].palette_index != (*ff7_externals.field_palette_D00088) + 1)
 322:                 {
 323:                     uint32_t page = (layer4_tiles[tile_index].use_fx_page) ? layer4_tiles[tile_index].fx_page : layer4_tiles[tile_index].page;
 324:                     ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer4_tiles[tile_index].u,
 325:                                                 layer4_tiles[tile_index].v, layer4_tiles[tile_index].palette_index, page);
 326:                 }
 327:             }
 328: 
 329:             if(widescreen_enabled || enable_uncrop)
 330:             {
 331:                 // Apply repeat x-y for background layer 4 tiles
 332:                 std::vector<vector2<int>> tile_offsets;
 333:                 if(do_increase_height)
 334:                     tile_offsets.push_back(vector2<int>{0, layer4_height /2});
 335: 
 336:                 if(do_increase_width){
 337:                     tile_offsets.push_back(vector2<int>{layer4_width / 2, 0});
 338:                     tile_offsets.push_back(vector2<int>{layer4_width / 2, layer4_height / 2});
 339:                 }
 340:                 for(vector2<int> tile_offset: tile_offsets){
 341:                     for(int i = 0; i < *ff7_externals.field_layer4_tiles_num; i++)
 342:                     {
 343:                         uint32_t tile_index = (*ff7_externals.field_layer4_palette_sort)[i];
 344:                         vector2<float> tile_position = {
 345:                             static_cast<float>(layer4_tiles[tile_index].x + tile_offset.x),
 346:                             static_cast<float>(layer4_tiles[tile_index].y + tile_offset.y)
 347:                         };
 348: 
 349:                         field_layer4_shift_tile_position(&tile_position, &bg_position, layer4_width, layer4_height);
 350: 
 351:                         char anim_group = layer4_tiles[tile_index].anim_group;
 352:                         if(tile_position.x <= bg_position.x - left_offset || tile_position.x >= bg_position.x + right_offset ||
 353:                             tile_position.y <= bg_position.y - top_offset || tile_position.y >= bg_position.y + bottom_offset ||
 354:                             (anim_group && !(ff7_externals.modules_global_object->background_sprite_layer[anim_group] & layer4_tiles[tile_index].anim_bitmask)))
 355:                             continue;
 356: 
 357:                         layer4_tiles[tile_index].field_1040 = 1;
 358:                         tile_position.x = tile_position.x * field_bg_multiplier + initial_pos.x;
 359:                         tile_position.y = tile_position.y * field_bg_multiplier + initial_pos.y;
 360: 
 361:                         if(!*ff7_externals.field_layer_CFF1D8 || layer4_tiles[tile_index].palette_index != (*ff7_externals.field_palette_D00088) + 1)
 362:                         {
 363:                             uint32_t page = (layer4_tiles[tile_index].use_fx_page) ? layer4_tiles[tile_index].fx_page : layer4_tiles[tile_index].page;
 364:                             ff7_externals.add_page_tile(tile_position.x, tile_position.y, z_value, layer4_tiles[tile_index].u,
 365:                                                         layer4_tiles[tile_index].v, layer4_tiles[tile_index].palette_index, page);
 366:                         }
 367:                     }
 368:                 }
 369:             }
 370: 
 371:             *ff7_externals.field_layer4_flag_CFFEA8 = 1;
 372:         }
 373:     }
 374: 
 375: 
 376:     void ff7_field_submit_draw_arrow(field_arrow_graphics_data* arrow_data)
 377:     {
 378:         // Add delta world position lost due to non-float calculation
 379:         if(is_position_valid(field_3d_world_pos))
 380:         {
 381:             int view_multiplier = *ff7_externals.field_bg_multiplier;
 382:             vector2<float> delta;
 383:             delta.x = field_3d_world_pos.x - *ff7_externals.field_world_pos_x * view_multiplier;
 384:             delta.y = field_3d_world_pos.y - *ff7_externals.field_world_pos_y * view_multiplier;
 385:             for(int i = 0; i < 4; i++)
 386:             {
 387:                 arrow_data->vertices[i].x += delta.x;
 388:                 arrow_data->vertices[i].y += delta.y;
 389:             }
 390:         }
 391: 
 392:         ff7_externals.field_submit_draw_arrow_63A171(arrow_data);
 393:     }
 394: 
 395:     void ff7_field_submit_draw_cursor(field_arrow_graphics_data* arrow_data)
 396:     {
 397:         // Add delta position lost due to non-float calculation
 398:         if(is_position_valid(cursor_position))
 399:         {
 400:             vector2<float> delta;
 401:             delta.x = cursor_position.x - *ff7_externals.field_cursor_pos_x;
 402:             delta.y = cursor_position.y - *ff7_externals.field_cursor_pos_y;
 403:             for(int i = 0; i < 4; i++)
 404:             {
 405:                 arrow_data->vertices[i].x += delta.x;
 406:                 arrow_data->vertices[i].y += delta.y;
 407:             }
 408:         }
 409: 
 410:         ff7_externals.field_submit_draw_arrow_63A171(arrow_data);
 411:     }
 412: 
 413:     // ##################################################################
 414:     // ##################################################################
 415:     // ##################################################################
 416: 
 417:     void field_clip_with_camera_range_float(vector2<float>* point)
 418:     {
 419:         field_trigger_header* field_triggers_header_ptr = *ff7_externals.field_triggers_header;
 420:         float half_width = 160;
 421:         auto camera_range = field_triggers_header_ptr->camera_range;
 422: 
 423:         if(widescreen_enabled || enable_uncrop)
 424:         {
 425:             camera_range = widescreen.getCameraRange();
 426:         }
 427: 
 428:         if(is_fieldmap_wide())
 429:         {
 430:             // Adjustment to prevent scrolling stopping one pixel too early
 431:             camera_range.left += 1;
 432:             camera_range.right -= 1;
 433: 
 434:             // This centers the background if necessary
 435:             int cameraRangeSize = camera_range.right - camera_range.left;
 436:             half_width = 160 + std::min(53, cameraRangeSize / 2 - 160);
 437: 
 438:             point->x += widescreen.getHorizontalOffset();
 439:             if(widescreen.isResetVerticalPos()) point->y = 0;
 440:             point->y += widescreen.getVerticalOffset();
 441:         }
 442: 
 443:         if (point->x > camera_range.right - half_width)
 444:             point->x = camera_range.right - half_width;
 445:         if (point->x < camera_range.left + half_width)
 446:             point->x = camera_range.left + half_width;
 447:         if (point->y > camera_range.bottom - 120)
 448:             point->y = camera_range.bottom - 120;
 449:         if (point->y < camera_range.top + 120)
 450:             point->y = camera_range.top + 120;
 451: 
 452:         if (enable_analogue_controls)
 453:         {
 454:             float accelCoeff = 0.1f / static_cast<float>(common_frame_multiplier);
 455:             float maxScroll = 120;
 456:             float maxScrollY = maxScroll * camera.getScrollingDirY();
 457:             float maxScrollX = maxScroll * camera.getScrollingDirX();
 458: 
 459:             if (maxScrollX > 0.0) maxScrollX = std::min(maxScrollX, (camera_range.right - half_width - point->x));
 460:             else maxScrollX = std::max(maxScrollX, camera_range.left + half_width - point->x);
 461:             if (maxScrollY > 0.0) maxScrollY =  std::min(maxScrollY, (camera_range.bottom - 120 - point->y));
 462:             else maxScrollY =  std::max(maxScrollY, camera_range.top + 120 - point->y);
 463: 
 464:             camera.setScrollingOffset(camera.getScrollingOffsetX() + accelCoeff * (maxScrollX - camera.getScrollingOffsetX()),
 465:                                       camera.getScrollingOffsetY() + accelCoeff * (maxScrollY - camera.getScrollingOffsetY()));
 466: 
 467:             point->x += camera.getScrollingOffsetX();
 468:             point->y += camera.getScrollingOffsetY();
 469: 
 470:             if (point->x > camera_range.right - half_width)
 471:                 point->x = camera_range.right - half_width;
 472:             if (point->x < camera_range.left + half_width)
 473:                 point->x = camera_range.left + half_width;
 474:             if (point->y > camera_range.bottom - 120)
 475:                 point->y = camera_range.bottom - 120;
 476:             if (point->y < camera_range.top + 120)
 477:                 point->y = camera_range.top + 120;
 478:         }
 479:     }
 480: 
 481:     void float_sub_643628(field_trigger_header *trigger_header, vector2<float> *delta_position)
 482:     {
 483:         float half_width = 160;
 484:         auto camera_range = trigger_header->camera_range;
 485: 
 486:         if (enable_uncrop || widescreen_enabled)
 487:         {
 488:             camera_range = widescreen.getCameraRange();
 489:         }
 490: 
 491:         if(is_fieldmap_wide())
 492:         {
 493:             // This centers the background if necessary
 494:             int cameraRangeSize = camera_range.right - camera_range.left;
 495:             half_width = 160 + std::min(53, cameraRangeSize / 2 - 160);
 496:         }
 497: 
 498:         if (trigger_header->field_14[0] == 1)
 499:         {
 500:             float diff_top_bottom = camera_range.bottom - 120 - (camera_range.top + 120);
 501:             float diff_right_left = camera_range.right - half_width - (camera_range.left + half_width);
 502:             float temp_1 = -(diff_top_bottom * (camera_range.top + 120 - delta_position->y) + diff_right_left * (camera_range.left + half_width - delta_position->x));
 503:             float temp_square_value = (diff_top_bottom * diff_top_bottom + diff_right_left * diff_right_left) / 256.f;
 504:             delta_position->x = ((diff_right_left * temp_1 / temp_square_value) / 256.f) + camera_range.left + half_width;
 505:             delta_position->y = ((diff_top_bottom * temp_1 / temp_square_value) / 256.f) + camera_range.top + 120;
 506:         }
 507:         if (trigger_header->field_14[0] == 2)
 508:         {
 509:             float diff_bottom_top = camera_range.top + 120 - (camera_range.bottom - 120);
 510:             float diff_right_left = camera_range.right - half_width - (camera_range.left + half_width);
 511:             float temp_1 = -((diff_bottom_top) * (camera_range.bottom - 120 - delta_position->y) + diff_right_left * (camera_range.left + half_width - delta_position->x));
 512:             float temp_square_value = (diff_bottom_top * diff_bottom_top + diff_right_left * diff_right_left) / 256.f;
 513:             delta_position->x = ((diff_right_left * temp_1 / temp_square_value) / 256.f) + camera_range.left + half_width;
 514:             delta_position->y = ((diff_bottom_top * temp_1 / temp_square_value) / 256.f) + camera_range.bottom - 120;
 515:         }
 516:     }
 517: 
 518:     void ff7_field_clip_with_camera_range(vector2<short>* point)
 519:     {
 520:         vector2<float> proxy_point = {(float)point->x, (float)point->y};
 521:         field_clip_with_camera_range_float(&proxy_point);
 522:         point->x = round(proxy_point.x);
 523:         point->y = round(proxy_point.y);
 524:     }
 525: 
 526:     void ff7_field_layer3_clip_with_camera_range(field_trigger_header* trigger_header, vector2<short>* point)
 527:     {
 528:         vector2<float> proxy_point = {(float)point->x, (float)point->y};
 529:         float_sub_643628(*ff7_externals.field_triggers_header, &proxy_point);
 530:         point->x = round(proxy_point.x);
 531:         point->y = round(proxy_point.y);
 532:     }
 533: 
 534:     void field_widescreen_width_clip_with_camera_range(vector2<short>* point)
 535:     {
 536:         if(!widescreen.isScriptedClipEnabled())
 537:         {
 538:             return;
 539:         }
 540: 
 541:         auto camera_range = widescreen.getCameraRange();
 542: 
 543:         // Adjustment to prevent scrolling stopping one pixel too early
 544:         camera_range.left += 1;
 545:         camera_range.right -= 1;
 546: 
 547:         // This centers the background if necessary
 548:         int cameraRangeSize = camera_range.right - camera_range.left;
 549:         float half_width = 160 + std::min(53, cameraRangeSize / 2 - 160);
 550: 
 551:         point->x += widescreen.getHorizontalOffset();
 552: 
 553:         if (point->x > camera_range.right - half_width)
 554:             point->x = camera_range.right - half_width;
 555:         if (point->x < camera_range.left + half_width)
 556:             point->x = camera_range.left + half_width;
 557:     }
 558: 
 559:     void field_uncropped_height_clip_with_camera_range(vector2<short>* point)
 560:     {
 561:         if(!widescreen.isScriptedClipEnabled())
 562:         {
 563:             return;
 564:         }
 565: 
 566:         auto camera_range = widescreen.getCameraRange();
 567: 
 568:         point->y += widescreen.getVerticalOffset();
 569: 
 570:         if(widescreen.isScriptedVerticalClipEnabled())
 571:         {
 572:             if (point->y > camera_range.bottom - 120)
 573:                 point->y = camera_range.bottom - 120;
 574:             if (point->y < camera_range.top + 120)
 575:                 point->y = camera_range.top + 120;
 576:         }
 577:     }
 578: 
 579:     void engine_set_game_engine_world_coord_float_661B23(int field_world_x, int field_world_y)
 580:     {
 581:         ff7_externals.engine_set_game_engine_world_coord_661B23(field_world_x, field_world_y);
 582: 
 583:         // Override field_9A8 and field_9AC values with accurate field world coordinates position when possible
 584:         ff7_game_obj* game_obj = (ff7_game_obj*)common_externals.get_game_object();
 585:         if(game_obj)
 586:         {
 587:             if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
 588:             {
 589:                 if(is_position_valid(field_3d_world_pos))
 590:                 {
 591:                     *(float*)&game_obj->field_9A8 = field_3d_world_pos.x;
 592:                     *(float*)&game_obj->field_9AC = field_3d_world_pos.y;
 593:                 }
 594:             }
 595:         }
 596:     }
 597: 
 598:     void engine_sub_661B68(int field_world_x, int field_world_y)
 599:     {
 600:         ff7_game_obj* game_obj = (ff7_game_obj*)common_externals.get_game_object();
 601:         if(game_obj)
 602:         {
 603:             engine_set_game_engine_world_coord_float_661B23(field_world_x, field_world_y);
 604:             ff7_externals.engine_sub_67CCDE(*(float*)&game_obj->field_99C, *(float*)&game_obj->field_9A0, *(float*)&game_obj->field_9A4,
 605:                 *(float*)&game_obj->field_9A8, *(float*)&game_obj->field_9AC, (float)(int)game_obj->_res_w, (float)(int)game_obj->_res_h, game_obj);
 606:         }
 607:     }
 608: 
 609:     void ff7_field_set_world_coordinate_640EB7()
 610:     {
 611:         if(is_position_valid(field_3d_world_pos) || *ff7_externals.field_world_pos_x != *ff7_externals.field_prev_world_pos_x || *ff7_externals.field_world_pos_y != *ff7_externals.field_prev_world_pos_y)
 612:         {
 613:             *ff7_externals.field_prev_world_pos_x = *ff7_externals.field_world_pos_x;
 614:             *ff7_externals.field_prev_world_pos_y = *ff7_externals.field_world_pos_y;
 615:             engine_sub_661B68((*ff7_externals.field_bg_multiplier) * (*ff7_externals.field_world_pos_x), (*ff7_externals.field_bg_multiplier) * (*ff7_externals.field_world_pos_y));
 616:         }
 617:     }
 618: 
 619:     void field_apply_player_position_2D_translation_float(vector2<float>* point, int model_id)
 620:     {
 621:         vector3<float> player_position;
 622:         field_event_data* field_event_data_ptr = *ff7_externals.field_event_data_ptr;
 623: 
 624:         player_position.x = field_event_data_ptr[model_id].model_pos.x / 4096.f;
 625:         player_position.y = field_event_data_ptr[model_id].model_pos.y / 4096.f;
 626:         player_position.z = ff7_externals.modules_global_object->field_16 + (field_event_data_ptr[model_id].model_pos.z / 4096.f);
 627:         field_apply_2D_translation_float_64314F(&player_position, point);
 628:         point->x -= ff7_externals.field_viewport_xy_CFF204->x;
 629:         point->y -= ff7_externals.field_viewport_xy_CFF204->y;
 630:     }
 631: 
 632:     void field_init_scripted_bg_movement()
 633:     {
 634:         vector2<short> world_pos;
 635:         if ( !ff7_externals.modules_global_object->world_move_status )
 636:         {
 637:             last_valid_scripted_field_delta_world_pos = {INVALID_VALUE, INVALID_VALUE};
 638: 
 639:             switch ( ff7_externals.modules_global_object->world_move_mode )
 640:             {
 641:             case 0:
 642:                 *ff7_externals.field_bg_flag_CC15E4 = 0;
 643:                 *ff7_externals.field_curr_delta_world_pos_x = 0;
 644:                 *ff7_externals.field_curr_delta_world_pos_y = 0;
 645:                 ff7_externals.modules_global_object->world_move_status = 2;
 646: 
 647:                 last_valid_scripted_field_delta_world_pos = field_curr_delta_world_pos;
 648:                 break;
 649:             case 1:
 650:                 *ff7_externals.field_bg_flag_CC15E4 = 1;
 651:                 ff7_externals.modules_global_object->world_move_status = 1;
 652:                 break;
 653:             case 2:
 654:             case 3:
 655:                 *ff7_externals.field_bg_flag_CC15E4 = 1;
 656:                 *ff7_externals.scripted_world_move_n_steps = ff7_externals.modules_global_object->field_20;
 657:                 *ff7_externals.scripted_world_move_step_index = 0;
 658:                 world_pos = {-(*ff7_externals.field_curr_delta_world_pos_x), -(*ff7_externals.field_curr_delta_world_pos_y)};
 659: 
 660:                 if(is_fieldmap_wide())
 661:                     field_widescreen_width_clip_with_camera_range(&world_pos);
 662:                 if(is_fieldmap_uncropped())
 663:                     field_uncropped_height_clip_with_camera_range(&world_pos);
 664:                 
 665: 
 666:                 *ff7_externals.scripted_world_initial_pos_x = -world_pos.x;
 667:                 *ff7_externals.scripted_world_initial_pos_y = -world_pos.y;
 668:                 ff7_externals.modules_global_object->world_move_status = 1;
 669:                 break;
 670:             case 4:
 671:                 *ff7_externals.field_bg_flag_CC15E4 = 1;
 672: 
 673:                 world_pos = {-(ff7_externals.modules_global_object->field_A), -(ff7_externals.modules_global_object->field_C)};
 674:                 if(is_fieldmap_wide())
 675:                     field_widescreen_width_clip_with_camera_range(&world_pos);
 676:                 if(is_fieldmap_uncropped())
 677:                     field_uncropped_height_clip_with_camera_range(&world_pos);
 678: 
 679:                 *ff7_externals.field_curr_delta_world_pos_x = -world_pos.x;
 680:                 *ff7_externals.field_curr_delta_world_pos_y = -world_pos.y;
 681:                 ff7_externals.modules_global_object->world_move_status = 2;
 682:                 break;
 683:             case 5:
 684:             case 6:
 685:                 *ff7_externals.field_bg_flag_CC15E4 = 1;
 686:                 *ff7_externals.scripted_world_move_n_steps = ff7_externals.modules_global_object->field_20;
 687:                 *ff7_externals.scripted_world_move_step_index = 0;
 688: 
 689:                 world_pos = {(-*ff7_externals.field_curr_delta_world_pos_x), -(*ff7_externals.field_curr_delta_world_pos_y)};
 690:                 if(is_fieldmap_wide())
 691:                     field_widescreen_width_clip_with_camera_range(&world_pos);
 692:                 if(is_fieldmap_uncropped())
 693:                     field_uncropped_height_clip_with_camera_range(&world_pos);
 694: 
 695:                 *ff7_externals.scripted_world_initial_pos_x = -world_pos.x;
 696:                 *ff7_externals.scripted_world_initial_pos_y = -world_pos.y;
 697: 
 698:                 world_pos = {-(ff7_externals.modules_global_object->field_A), -(ff7_externals.modules_global_object->field_C)};
 699:                 if(is_fieldmap_wide())
 700:                     field_widescreen_width_clip_with_camera_range(&world_pos);
 701:                 if(is_fieldmap_uncropped())
 702:                     field_uncropped_height_clip_with_camera_range(&world_pos);
 703: 
 704:                 *ff7_externals.scripted_world_final_pos_x = -world_pos.x;
 705:                 *ff7_externals.scripted_world_final_pos_y = -world_pos.y;
 706:                 ff7_externals.modules_global_object->world_move_status = 1;
 707:                 break;
 708:             default:
 709:                 return;
 710:             }
 711:         }
 712:     }
 713: 
 714:     void field_update_scripted_bg_movement()
 715:     {
 716:         vector2<short> world_pos;
 717:         vector2<float> world_pos_float;
 718: 
 719:         field_curr_delta_world_pos = {INVALID_VALUE, INVALID_VALUE};
 720:         if(ff7_externals.modules_global_object->world_move_status == 1)
 721:         {
 722:             switch(ff7_externals.modules_global_object->world_move_mode)
 723:             {
 724:             case 1:
 725:                 ff7_externals.set_world_pos_based_on_player_pos_643C86(&world_pos);
 726:                 ff7_field_clip_with_camera_range(&world_pos);
 727:                 *ff7_externals.field_curr_delta_world_pos_x = -world_pos.x;
 728:                 *ff7_externals.field_curr_delta_world_pos_y = -world_pos.y;
 729: 
 730:                 // Smooth background movement with floating point
 731:                 if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
 732:                 {
 733:                     field_apply_player_position_2D_translation_float(&world_pos_float, ff7_externals.modules_global_object->world_move_follow_model_id);
 734:                     field_clip_with_camera_range_float(&world_pos_float);
 735:                     field_curr_delta_world_pos.x = -world_pos_float.x;
 736:                     field_curr_delta_world_pos.y = -world_pos_float.y;
 737:                 }
 738:                 break;
 739:             case 2:
 740:             case 3:
 741:                 if(*ff7_externals.scripted_world_move_n_steps)
 742:                 {
 743:                     ff7_externals.set_world_pos_based_on_player_pos_643C86(&world_pos);
 744:                     ff7_field_clip_with_camera_range(&world_pos);
 745:                     std::function<int(int, int, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 2 ?
 746:                         ff7_externals.field_get_linear_interpolated_value : ff7_externals.field_get_smooth_interpolated_value;
 747:                     *ff7_externals.field_curr_delta_world_pos_x = field_get_interpolated_value(
 748:                         *ff7_externals.scripted_world_initial_pos_x,
 749:                         -world_pos.x,
 750:                         *ff7_externals.scripted_world_move_n_steps,
 751:                         *ff7_externals.scripted_world_move_step_index
 752:                     );
 753:                     *ff7_externals.field_curr_delta_world_pos_y = field_get_interpolated_value(
 754:                         *ff7_externals.scripted_world_initial_pos_y,
 755:                         -world_pos.y,
 756:                         *ff7_externals.scripted_world_move_n_steps,
 757:                         *ff7_externals.scripted_world_move_step_index
 758:                     );
 759: 
 760:                     // Smooth background movement with floating point
 761:                     if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
 762:                     {
 763:                         field_apply_player_position_2D_translation_float(&world_pos_float, ff7_externals.modules_global_object->world_move_follow_model_id);
 764:                         field_clip_with_camera_range_float(&world_pos_float);
 765:                         std::function<float(float, float, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 2 ?
 766:                             field_get_linear_interpolated_value_float : field_get_smooth_interpolated_value_float;
 767:                         field_curr_delta_world_pos.x = field_get_interpolated_value(
 768:                             *ff7_externals.scripted_world_initial_pos_x,
 769:                             -world_pos_float.x,
 770:                             *ff7_externals.scripted_world_move_n_steps,
 771:                             *ff7_externals.scripted_world_move_step_index
 772:                         );
 773:                         field_curr_delta_world_pos.y = field_get_interpolated_value(
 774:                             *ff7_externals.scripted_world_initial_pos_y,
 775:                             -world_pos_float.y,
 776:                             *ff7_externals.scripted_world_move_n_steps,
 777:                             *ff7_externals.scripted_world_move_step_index
 778:                         );
 779:                     }
 780: 
 781:                     if(*ff7_externals.scripted_world_move_n_steps == *ff7_externals.scripted_world_move_step_index)
 782:                         ff7_externals.modules_global_object->world_move_status = 2;
 783:                     else
 784:                         (*ff7_externals.scripted_world_move_step_index)++;
 785:                 }
 786:                 else
 787:                 {
 788:                     ff7_externals.modules_global_object->world_move_status = 2;
 789:                 }
 790:                 break;
 791:             case 5:
 792:             case 6:
 793:                 if(*ff7_externals.scripted_world_move_n_steps)
 794:                 {
 795:                     if(is_fieldmap_wide())
 796:                     {
 797:                         world_pos = {-(*ff7_externals.scripted_world_final_pos_x), -(*ff7_externals.scripted_world_final_pos_y)};
 798:                         field_widescreen_width_clip_with_camera_range(&world_pos);
 799:                         *ff7_externals.scripted_world_final_pos_x = -world_pos.x;
 800: 
 801:                         world_pos = {-(*ff7_externals.scripted_world_initial_pos_x), -(*ff7_externals.scripted_world_initial_pos_y)};
 802:                         field_widescreen_width_clip_with_camera_range(&world_pos);
 803:                         *ff7_externals.scripted_world_initial_pos_x = -world_pos.x;
 804:                     }
 805:                     if(is_fieldmap_uncropped())
 806:                         field_uncropped_height_clip_with_camera_range(&world_pos);
 807: 
 808:                     std::function<int(int, int, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 5 ?
 809:                         ff7_externals.field_get_linear_interpolated_value : ff7_externals.field_get_smooth_interpolated_value;
 810:                     *ff7_externals.field_curr_delta_world_pos_x = field_get_interpolated_value(
 811:                         *ff7_externals.scripted_world_initial_pos_x,
 812:                         *ff7_externals.scripted_world_final_pos_x,
 813:                         *ff7_externals.scripted_world_move_n_steps,
 814:                         *ff7_externals.scripted_world_move_step_index
 815:                     );
 816:                     *ff7_externals.field_curr_delta_world_pos_y = field_get_interpolated_value(
 817:                         *ff7_externals.scripted_world_initial_pos_y,
 818:                         *ff7_externals.scripted_world_final_pos_y,
 819:                         *ff7_externals.scripted_world_move_n_steps,
 820:                         *ff7_externals.scripted_world_move_step_index
 821:                     );
 822: 
 823:                     // Smooth background movement with floating point
 824:                     if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
 825:                     {
 826:                         std::function<float(float, float, int, int)> field_get_interpolated_value = ff7_externals.modules_global_object->world_move_mode == 5 ?
 827:                             field_get_linear_interpolated_value_float : field_get_smooth_interpolated_value_float;
 828:                         field_curr_delta_world_pos.x = field_get_interpolated_value(
 829:                             *ff7_externals.scripted_world_initial_pos_x,
 830:                             *ff7_externals.scripted_world_final_pos_x,
 831:                             *ff7_externals.scripted_world_move_n_steps,
 832:                             *ff7_externals.scripted_world_move_step_index
 833:                         );
 834:                         field_curr_delta_world_pos.y = field_get_interpolated_value(
 835:                             *ff7_externals.scripted_world_initial_pos_y,
 836:                             *ff7_externals.scripted_world_final_pos_y,
 837:                             *ff7_externals.scripted_world_move_n_steps,
 838:                             *ff7_externals.scripted_world_move_step_index
 839:                         );
 840:                     }
 841: 
 842:                     if(*ff7_externals.scripted_world_move_n_steps == *ff7_externals.scripted_world_move_step_index)
 843:                         ff7_externals.modules_global_object->world_move_status = 2;
 844:                     else
 845:                         (*ff7_externals.scripted_world_move_step_index)++;
 846:                 }
 847:                 else
 848:                 {
 849:                     ff7_externals.modules_global_object->world_move_status = 2;
 850:                 }
 851:                 break;
 852:             default:
 853:                 break;
 854:             }
 855: 
 856:             if(is_fieldmap_wide())
 857:             {
 858:                 world_pos = {-(*ff7_externals.field_curr_delta_world_pos_x), -(*ff7_externals.field_curr_delta_world_pos_y)};
 859:                 field_widescreen_width_clip_with_camera_range(&world_pos);
 860:                 *ff7_externals.field_curr_delta_world_pos_x = -world_pos.x;
 861:             }
 862:             if(is_fieldmap_uncropped())
 863:                 field_uncropped_height_clip_with_camera_range(&world_pos);
 864:         }
 865: 
 866:         if(is_position_valid(field_curr_delta_world_pos))
 867:         {
 868:             last_valid_scripted_field_delta_world_pos = field_curr_delta_world_pos;
 869:         }
 870:     }
 871: 
 872:     void set_world_and_background_positions(vector2<float> delta_position, bool use_camdat_pan)
 873:     {
 874:         field_trigger_header* field_triggers_header_ptr = *ff7_externals.field_triggers_header;
 875:         int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
 876: 
 877:         field_3d_world_pos.x = ff7_externals.modules_global_object->shake_bg_x.shake_curr_value + ff7_externals.field_bg_offset->x - delta_position.x - 160;
 878:         field_3d_world_pos.x += (use_camdat_pan) ? -(*ff7_externals.field_camera_data)->pan_x : 0;
 879:         field_3d_world_pos.x *= field_bg_multiplier;
 880:         field_3d_world_pos.y = ff7_externals.modules_global_object->shake_bg_y.shake_curr_value + ff7_externals.field_bg_offset->y - delta_position.y - 120;
 881:         field_3d_world_pos.y += (use_camdat_pan) ? (*ff7_externals.field_camera_data)->pan_y : 0;
 882:         field_3d_world_pos.y *= field_bg_multiplier;
 883:         bg_main_layer_pos.x = delta_position.x + 320 - ff7_externals.field_bg_offset->x - ff7_externals.modules_global_object->shake_bg_x.shake_curr_value;
 884:         bg_main_layer_pos.y = delta_position.y + 232 - ff7_externals.field_bg_offset->y - ff7_externals.modules_global_object->shake_bg_y.shake_curr_value;
 885:         bg_layer3_pos.x = (field_triggers_header_ptr->bg3_pos_x / 16.f) + ((field_triggers_header_ptr->bg3_speed_x * delta_position.x) / 256.f);
 886:         bg_layer3_pos.x = remainder(bg_layer3_pos.x, field_triggers_header_ptr->bg3_width);
 887:         bg_layer3_pos.x = bg_layer3_pos.x + 320 - ff7_externals.field_bg_offset->x - ff7_externals.modules_global_object->shake_bg_x.shake_curr_value;
 888:         bg_layer3_pos.y = (field_triggers_header_ptr->bg3_pos_y / 16.f) + ((field_triggers_header_ptr->bg3_speed_y * delta_position.y) / 256.f);
 889:         bg_layer3_pos.y = remainder(bg_layer3_pos.y, field_triggers_header_ptr->bg3_height);
 890:         bg_layer3_pos.y = bg_layer3_pos.y + 232 - ff7_externals.field_bg_offset->y - ff7_externals.modules_global_object->shake_bg_y.shake_curr_value;
 891:         bg_layer4_pos.x = (field_triggers_header_ptr->bg4_pos_x / 16.f) + ((field_triggers_header_ptr->bg4_speed_x * delta_position.x) / 256.f);
 892:         bg_layer4_pos.x = remainder(bg_layer4_pos.x, field_triggers_header_ptr->bg4_width);
 893:         bg_layer4_pos.x = bg_layer4_pos.x + 320 - ff7_externals.field_bg_offset->x - ff7_externals.modules_global_object->shake_bg_x.shake_curr_value;
 894:         bg_layer4_pos.y = (field_triggers_header_ptr->bg4_pos_y / 16.f) + ((field_triggers_header_ptr->bg4_speed_y * delta_position.y) / 256.f);
 895:         bg_layer4_pos.y = remainder(bg_layer4_pos.y, field_triggers_header_ptr->bg4_height);
 896:         bg_layer4_pos.y = bg_layer4_pos.y + 232 - ff7_externals.field_bg_offset->y - ff7_externals.modules_global_object->shake_bg_y.shake_curr_value;
 897: 
 898:         // Round the position to steps of 1/MIN_STEP_INVERSE due to visual glitches between tiles
 899:         field_3d_world_pos.x = round(field_3d_world_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 900:         field_3d_world_pos.y = round(field_3d_world_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 901:         bg_main_layer_pos.x = round(bg_main_layer_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 902:         bg_main_layer_pos.y = round(bg_main_layer_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 903:         bg_layer3_pos.x = round(bg_layer3_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 904:         bg_layer3_pos.y = round(bg_layer3_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 905:         bg_layer4_pos.x = round(bg_layer4_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 906:         bg_layer4_pos.y = round(bg_layer4_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 907:     }
 908: 
 909:     void compute_pointer_hand_position(vector2<float> field_3d_world_coord, int model_id)
 910:     {
 911:         int view_multiplier = *ff7_externals.field_bg_multiplier;
 912:         field_event_data* event_data_ptr = *ff7_externals.field_event_data_ptr;
 913:         vector3<float> position;
 914:         vector2<float> cursor_delta_pos;
 915: 
 916:         position.x = event_data_ptr[model_id].model_pos.x / 4096.f + event_data_ptr[model_id].offset_position_x;
 917:         position.y = event_data_ptr[model_id].model_pos.y / 4096.f + event_data_ptr[model_id].offset_position_y;
 918:         position.z = event_data_ptr[model_id].model_pos.z / 4096.f + event_data_ptr[model_id].offset_position_z + (ff7_externals.modules_global_object->field_10 << 7 >> 9);
 919:         field_apply_2D_translation_float_64314F(&position, &cursor_delta_pos);
 920:         cursor_position.x = field_3d_world_coord.x + view_multiplier * cursor_delta_pos.x + ff7_externals.field_curr_half_viewport_width_height_CFF1FC->x;
 921:         cursor_position.y = field_3d_world_coord.y + view_multiplier * (cursor_delta_pos.y - 8) + ff7_externals.field_curr_half_viewport_width_height_CFF1FC->y;
 922: 
 923: 
 924:         int viewport_x = is_fieldmap_wide() ? wide_viewport_x : ff7_externals.field_viewport_xy_CFF204->x;
 925:         int viewport_width = is_fieldmap_wide() ? wide_viewport_width / 2 : 320;
 926:         if(cursor_position.x > viewport_x + viewport_width * view_multiplier)
 927:             cursor_position.x = viewport_x + viewport_width * view_multiplier;
 928:         if(cursor_position.x < viewport_x)
 929:             cursor_position.x = viewport_x;
 930:         if(cursor_position.y > ff7_externals.field_viewport_xy_CFF204->y + 224 * view_multiplier)
 931:             cursor_position.y = ff7_externals.field_viewport_xy_CFF204->y + 224 * view_multiplier;
 932:         if(cursor_position.y < ff7_externals.field_viewport_xy_CFF204->y - 32)
 933:             cursor_position.y = ff7_externals.field_viewport_xy_CFF204->y - 32;
 934:     }
 935: 
 936:     void ff7_field_update_background()
 937:     {
 938:         ff7_externals.field_update_background_positions();
 939: 
 940:         int player_model_id = *ff7_externals.field_player_model_id;
 941:         field_3d_world_pos = {INVALID_VALUE, INVALID_VALUE};
 942:         bg_main_layer_pos = {INVALID_VALUE, INVALID_VALUE};
 943:         bg_layer3_pos = {INVALID_VALUE, INVALID_VALUE};
 944:         bg_layer4_pos = {INVALID_VALUE, INVALID_VALUE};
 945:         cursor_position = {INVALID_VALUE, INVALID_VALUE};
 946:         if ( *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag)
 947:         {
 948:             if(ff7_externals.modules_global_object->MVCAM_flag == 1 && is_position_valid(field_curr_delta_world_pos))
 949:             {
 950:                 int field_bg_multiplier = *ff7_externals.field_bg_multiplier;
 951:                 field_3d_world_pos.x = (field_curr_delta_world_pos.x + ff7_externals.field_bg_offset->x - 160) * field_bg_multiplier;
 952:                 field_3d_world_pos.y = (field_curr_delta_world_pos.y + ff7_externals.field_bg_offset->y - 120) * field_bg_multiplier;
 953:                 field_3d_world_pos.x = round(field_3d_world_pos.x * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 954:                 field_3d_world_pos.y = round(field_3d_world_pos.y * MIN_STEP_INVERSE) / MIN_STEP_INVERSE;
 955:             }
 956:         }
 957:         else if(*ff7_externals.field_bg_flag_CC15E4)
 958:         {
 959:             if (enable_analogue_controls)
 960:             {
 961:                 vector2<float> bg_delta_position = {0.0f, 0.0f};
 962:                 bool use_camdat_pan = true;
 963:                 if(is_position_valid(field_curr_delta_world_pos))
 964:                 {
 965:                     bg_delta_position.x = -field_curr_delta_world_pos.x;
 966:                     bg_delta_position.y = -field_curr_delta_world_pos.y;
 967:                     use_camdat_pan = true;
 968:                     set_world_and_background_positions(bg_delta_position, true);
 969:                 }
 970:                 else if(is_position_valid(last_valid_scripted_field_delta_world_pos))
 971:                 {
 972:                     bg_delta_position.x = -last_valid_scripted_field_delta_world_pos.x;
 973:                     bg_delta_position.y = -last_valid_scripted_field_delta_world_pos.y;
 974: 
 975:                     field_clip_with_camera_range_float(&bg_delta_position);
 976:                     field_curr_delta_world_pos.x = -bg_delta_position.x;
 977:                     field_curr_delta_world_pos.y = -bg_delta_position.y;
 978: 
 979:                     set_world_and_background_positions(bg_delta_position, true);
 980:                 }
 981:             }
 982:             else
 983:             {
 984:                 if(is_position_valid(field_curr_delta_world_pos))
 985:                     set_world_and_background_positions({-field_curr_delta_world_pos.x, -field_curr_delta_world_pos.y}, true);
 986:             }
 987: 
 988: 
 989:             if((*ff7_externals.field_event_data_ptr)[player_model_id].field_62)
 990:                 compute_pointer_hand_position(field_3d_world_pos, player_model_id);
 991:         }
 992:         else
 993:         {
 994:             vector2<float> bg_delta_position;
 995:             field_apply_player_position_2D_translation_float(&bg_delta_position, player_model_id);
 996:             field_clip_with_camera_range_float(&bg_delta_position);
 997:             float_sub_643628(*ff7_externals.field_triggers_header, &bg_delta_position);
 998:             field_curr_delta_world_pos.x = -bg_delta_position.x;
 999:             field_curr_delta_world_pos.y = -bg_delta_position.y;
1000:             set_world_and_background_positions(bg_delta_position, false);
1001: 
1002:             compute_pointer_hand_position(field_3d_world_pos, player_model_id);
1003:         }
1004:     }
1005: 
1006:     // This function should be called at each frame after drawing backgrounds and 3d models
1007:     void draw_gray_quads_sub_644E90()
1008:     {
1009:         ff7_externals.field_draw_gray_quads_644E90();
1010: 
1011:         if (widescreen_enabled) widescreen.zoomBackground();
1012: 
1013:         newRenderer.setTimeFilterEnabled(false);
1014:     }
1015: }
</file>

<file path="src/ff7/field/background.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include "../../ff7.h"
27: 
28: namespace ff7::field
29: {
30:     constexpr float INVALID_VALUE = -1000000;
31: 
32:     vector2<float>
33:         field_curr_delta_world_pos,
34:         last_valid_scripted_field_delta_world_pos,
35:         field_3d_world_pos,
36:         bg_main_layer_pos,
37:         bg_layer3_pos,
38:         bg_layer4_pos,
39:         cursor_position;
40: 
41:     void ff7_field_update_background();
42:     void ff7_field_set_world_coordinate_640EB7();
43:     void ff7_field_submit_draw_arrow(field_arrow_graphics_data* arrow_data);
44:     void ff7_field_submit_draw_cursor(field_arrow_graphics_data* arrow_data);
45:     void draw_gray_quads_sub_644E90();
46:     inline bool is_position_valid(vector2<float> position) {
47:         return position.x != INVALID_VALUE && position.y != INVALID_VALUE;
48:     }
49: 
50: }
</file>

<file path="src/ff7/field/camera.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2022 Tang-Tang Zhou                                     //
10: //    Copyright (C) 2022 Cosmos                                             //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: #include "camera.h"
24: 
25: namespace ff7::field
26: {
27:     Camera camera;
28: 
29:     void Camera::setScrollingDir(float x, float y)
30:     {
31:         scrollingDir.x = x;
32:         scrollingDir.y = y;
33:     }
34: 
35:     void Camera::setScrollingOffset(float x, float y)
36:     {
37:         scrollingOffset.x = x;
38:         scrollingOffset.y = y;
39:     }
40: }
</file>

<file path="src/ff7/field/camera.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2022 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: #pragma once
17: 
18: #include "matrix.h"
19: 
20: namespace ff7::field
21: {
22:     class Camera
23:     {
24:         public:
25:             Camera() = default;
26:             ~Camera() = default;
27: 
28:             void setScrollingDir(float x, float y);
29:             float getScrollingDirX();
30:             float getScrollingDirY();
31: 
32:             void setScrollingOffset(float x, float y);
33:             float getScrollingOffsetX();
34:             float getScrollingOffsetY();
35: 
36:         private:
37:             vector2<float> scrollingDir = { 0.0, 0.0 };
38:             vector2<float> scrollingOffset = { 0.0, 0.0 };
39:     };
40: 
41:     inline float Camera::getScrollingDirX()
42:     {
43:         return scrollingDir.x;
44:     }
45: 
46:     inline float Camera::getScrollingDirY()
47:     {
48:         return scrollingDir.y;
49:     }
50: 
51:     inline float Camera::getScrollingOffsetX()
52:     {
53:         return scrollingOffset.x;
54:     }
55: 
56:     inline float Camera::getScrollingOffsetY()
57:     {
58:         return scrollingOffset.y;
59:     }
60: 
61:     extern Camera camera;
62: }
</file>

<file path="src/ff7/field/defs.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include "ff7.h"
27: 
28: namespace ff7::field
29: {
30:     void ff7_field_hook_init();
31:     void field_load_textures(struct ff7_game_obj *game_object, struct struc_3 *struc_3);
32:     void field_layer1_pick_tiles(short x_offset, short y_offset);
33:     void field_layer2_pick_tiles(short x_offset, short y_offset);
34:     void field_layer3_pick_tiles(short x_offset, short y_offset);
35:     void field_layer4_pick_tiles(short x_offset, short y_offset);
36:     void ff7_field_clip_with_camera_range(vector2<short>* point);
37:     void ff7_field_layer3_clip_with_camera_range(field_trigger_header* trigger_header, vector2<short>* point);
38:     uint32_t field_open_flevel_siz();
39:     void field_init_scripted_bg_movement();
40:     void field_update_scripted_bg_movement();
41:     bool ff7_field_do_draw_3d_model(short x, short y);
42:     void ff7_field_set_fade_quad_size(int x, int y, int width, int height);
43:     int ff7_field_models_eye_to_model(char* model_name);
44:     int ff7_field_blink_eye_sub_649B50(field_animation_data *field_anim_data, field_model_blink_data *blink_data);
45:     void ff7_field_handle_blink_reset();
46: }
</file>

<file path="src/ff7/field/enter.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include "model.h"
27: #include "background.h"
28: #include "../widescreen.h"
29: 
30: namespace ff7::field
31: {
32:     inline void ff7_field_initialize_variables()
33:     {
34:         ((void(*)())ff7_externals.field_initialize_variables)();
35: 
36:         field_3d_world_pos = {INVALID_VALUE, INVALID_VALUE};
37:         bg_main_layer_pos = {INVALID_VALUE, INVALID_VALUE};
38:         bg_layer3_pos = {INVALID_VALUE, INVALID_VALUE};
39:         bg_layer4_pos = {INVALID_VALUE, INVALID_VALUE};
40:         field_curr_delta_world_pos = {INVALID_VALUE, INVALID_VALUE};
41:         cursor_position = {INVALID_VALUE, INVALID_VALUE};
42: 
43:         // reset movement frame index for all models
44:         for(auto &external_data : external_model_data){
45:             external_data.moveFrameIndex = 0;
46:             external_data.rotationMoveFrameIndex = 0;
47:             external_data.prevCollisionRadius = 0;
48: 
49:             external_data.blinkFrameIndex = BLINKING_FRAMES;
50:         }
51: 
52:         if(widescreen_enabled || enable_uncrop) widescreen.initParamsFromConfig();
53:     }
54: }
</file>

<file path="src/ff7/field/field.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: /*
 23:  * This file contains the changes necessary to support subtractive and 25%
 24:  * blending modes in field backgrounds. Texture pages where these blending
 25:  * modes are used are duplicated and the tile data modified to point to these
 26:  * new pages which have the correct blending mode set.
 27:  */
 28: 
 29: #include "../../log.h"
 30: #include "../../patch.h"
 31: #include "../../common.h"
 32: #include "../widescreen.h"
 33: #include "../defs.h"
 34: 
 35: #include "opcode.h"
 36: #include "background.h"
 37: #include "defs.h"
 38: #include "enter.h"
 39: #include "model.h"
 40: 
 41: namespace ff7::field
 42: {
 43:     // helper function initializes page dst, copies texture from src and applies
 44:     // blend_mode
 45:     void field_load_textures_helper(struct ff7_game_obj *game_object, struct struc_3 *struc_3, uint32_t src, uint32_t dst, uint32_t blend_mode)
 46:     {
 47:         struct ff7_tex_header *tex_header;
 48: 
 49:         ff7_externals.make_struc3(blend_mode, struc_3);
 50: 
 51:         tex_header = (struct ff7_tex_header *)common_externals.create_tex_header();
 52: 
 53:         ff7_externals.field_layers[dst]->tex_header = tex_header;
 54: 
 55:         if(ff7_externals.field_layers[src]->type == 1) ff7_externals.make_field_tex_header_pal(tex_header);
 56:         if(ff7_externals.field_layers[src]->type == 2) {
 57:             ff7_externals.make_field_tex_header(tex_header);
 58:             tex_header->color_key = 3;
 59:         }
 60: 
 61:         struc_3->tex_header = tex_header;
 62: 
 63:         if(src != dst)
 64:         {
 65:             ff7_externals.field_layers[dst]->image_data = external_malloc(256 * 256);
 66:             memcpy(ff7_externals.field_layers[dst]->image_data, ff7_externals.field_layers[src]->image_data, 256 * 256);
 67:         }
 68: 
 69:         tex_header->image_data = (unsigned char*)ff7_externals.field_layers[dst]->image_data;
 70: 
 71:         tex_header->file.pc_name = (char*)external_malloc(1024);
 72:         sprintf(tex_header->file.pc_name, "field/%s/%s_%02i", strchr(ff7_externals.field_file_name, '\\') + 1, strchr(ff7_externals.field_file_name, '\\') + 1, src);
 73: 
 74:         ff7_externals.field_layers[dst]->graphics_object = ff7_externals._load_texture(1, PT_S2D, struc_3, 0, game_object->dx_sfx_something);
 75:         ff7_externals.field_layers[dst]->present = true;
 76:     }
 77: 
 78:     void field_load_textures(struct ff7_game_obj *game_object, struct struc_3 *struc_3)
 79:     {
 80:         uint32_t i;
 81: 
 82:         ff7_externals.field_convert_type2_layers();
 83: 
 84:         for(i = 0; i < 29; i++)
 85:         {
 86:             uint32_t blend_mode = 4;
 87: 
 88:             if(!ff7_externals.field_layers[i]->present) continue;
 89: 
 90:             if(ff7_externals.field_layers[i]->type == 1)
 91:             {
 92:                 if(i >= 24) blend_mode = 0;
 93:                 else if(i >= 15) blend_mode = 1;
 94:             }
 95:             else if(ff7_externals.field_layers[i]->type == 2)
 96:             {
 97:                 if(i >= 40) blend_mode = 0;
 98:                 else if(i >= 33) blend_mode = 1;
 99:             }
100:             else ffnx_glitch("unknown field layer type %i\n", ff7_externals.field_layers[i]->type);
101: 
102:             field_load_textures_helper(game_object, struc_3, i, i, blend_mode);
103: 
104:             // these magic numbers have been gleaned from original source data
105:             // the missing blend modes in question are used in exactly these pages
106:             // and copying them in this manner does not risk overwriting any other
107:             // data
108:             if(i >= 15 && i <= 18 && ff7_externals.field_layers[i]->type == 1) field_load_textures_helper(game_object, struc_3, i, i + 14, 2);
109:             if(i >= 15 && i <= 20 && ff7_externals.field_layers[i]->type == 1) field_load_textures_helper(game_object, struc_3, i, i + 18, 3);
110:         }
111: 
112:         *ff7_externals.layer2_end_page += 18;
113:     }
114: 
115:     uint32_t field_open_flevel_siz()
116:     {
117:         struct lgp_file *f = lgp_open_file("flevel.siz", 1);
118: 
119:         if (0 == f) {
120:             return 0;
121:         }
122: 
123:         uint32_t size = lgp_get_filesize(f, 1);
124:         char* buffer = new char[size];
125: 
126:         lgp_read_file(f, 1, buffer, size);
127: 
128:         // Increase from 787 (field map count) to 1200
129:         const uint32_t max_map_count = 1200;
130:         uint32_t* uncompressed_sizes = reinterpret_cast<uint32_t*>(buffer);
131:         uint32_t count = size / sizeof(uint32_t);
132:         uint32_t* flevel_sizes = reinterpret_cast<uint32_t*>(ff7_externals.field_map_infos + 0xBC);
133: 
134:         if (count > max_map_count) {
135:             count = max_map_count;
136:         }
137: 
138:         for (uint32_t i = 0; i < count; ++i) {
139:             flevel_sizes[i * 0x34] = uncompressed_sizes[i] + 4000000; // +2 MB compared to the original implementation
140:         }
141: 
142:         // Force a value if not specified by the flevel.siz
143:         for (uint32_t i = count; i < max_map_count; ++i) {
144:             flevel_sizes[i * 0x34] = 4000000;
145:         }
146: 
147:         delete[] buffer;
148: 
149:         return 1;
150:     }
151: 
152:     void ff7_field_set_fade_quad_size(int x, int y, int width, int height)
153:     {
154:         if(widescreen_enabled)
155:         {
156:             x -= abs(wide_viewport_x);
157:             width += (wide_viewport_width - game_width);
158:         }
159:         if(enable_uncrop)
160:         {
161:             y -= ff7_field_center ? 16 : 0;
162:             height += 32;
163:         }
164:         ff7_externals.field_sub_63AC3F(x, y, width, height);
165:     }
166: 
167:     void ff7_field_evaluate_encounter_rate()
168:     {
169:         field_event_data* field_event_data_array = (*ff7_externals.field_event_data_ptr);
170:         int original_movement_speed = field_event_data_array[*ff7_externals.field_player_model_id].movement_speed;
171:         field_event_data_array[*ff7_externals.field_player_model_id].movement_speed = original_movement_speed / common_frame_multiplier;
172:         ff7_externals.field_evaluate_encounter_rate_60B2C6();
173:         field_event_data_array[*ff7_externals.field_player_model_id].movement_speed = original_movement_speed;
174:     }
175: 
176:     int ff7_field_load_map_trigger_data()
177:     {
178:         // Do not override current trigger data for woa_* fields
179:         if (
180:             *ff7_externals.field_resuming_from_battle_CFF268 &&
181:             (
182:                 (*common_externals.current_field_id == 709) ||
183:                 (*common_externals.current_field_id == 710) ||
184:                 (*common_externals.current_field_id == 711)
185:             )
186:         )
187:             return 1;
188: 
189:         return ff7_externals.field_load_map_trigger_data_sub_6211C3();
190:     }
191: 
192:     void ff7_field_hook_init()
193:     {
194:         std::copy(common_externals.execute_opcode_table, &common_externals.execute_opcode_table[OPCODE_COUNT - 1], &original_opcode_table[0]);
195:         // Init stuff
196:         replace_call_function(ff7_externals.field_sub_60DCED + 0x178, ff7_field_initialize_variables);
197: 
198:         // Model movement (walk, run) fps fix + allow footstep sfx
199:         replace_call_function(ff7_externals.field_loop_sub_63C17F + 0x5DD, ff7_field_update_models_position);
200:         replace_call_function(ff7_externals.field_update_models_positions + 0x8BC, ff7_field_update_player_model_position);
201:         replace_call_function(ff7_externals.field_update_models_positions + 0x9E8, ff7_field_update_single_model_position);
202:         replace_call_function(ff7_externals.field_update_models_positions + 0x9AA, ff7_field_check_collision_with_target);
203:         replace_call_function(common_externals.execute_opcode_table[OFST] + 0x46, ff7_opcode_multiply_get_bank_value);
204: 
205:         // Model rotation
206:         byte jump_to_OFST_update[] = {0xE9, 0xE6, 0x01, 0x00, 0x00};
207:         replace_call_function(ff7_externals.field_update_models_positions + 0x7C, ff7_field_update_models_rotation_new);
208:         memcpy_code(ff7_externals.field_update_models_positions + 0x81, jump_to_OFST_update, sizeof(jump_to_OFST_update));
209: 
210:         if(ff7_fps_limiter >= FPS_LIMITER_30FPS)
211:         {
212:             if(ff7_fps_limiter == FPS_LIMITER_60FPS)
213:             {
214:                 // Partial animation fps fix
215:                 patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANMX1], (DWORD)&opcode_script_partial_animation_wrapper);
216:                 patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANMX2], (DWORD)&opcode_script_partial_animation_wrapper);
217:                 patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANIM1], (DWORD)&opcode_script_partial_animation_wrapper);
218:                 patch_code_dword((uint32_t)&common_externals.execute_opcode_table[CANIM2], (DWORD)&opcode_script_partial_animation_wrapper);
219: 
220:                 // Model movement fps fix for ladder and jump
221:                 patch_code_byte(ff7_externals.field_update_models_positions + 0x1041, 0x2 - common_frame_multiplier / 2);
222:                 patch_code_byte(ff7_externals.field_update_models_positions + 0x189A, 0x2 - common_frame_multiplier / 2);
223:                 replace_call_function(common_externals.execute_opcode_table[JUMP] + 0x1F1, ff7_opcode_multiply_get_bank_value);
224:                 patch_divide_code<int>(ff7_externals.field_update_models_positions + 0xC89, common_frame_multiplier * 2);
225:                 patch_divide_code<int>(ff7_externals.field_update_models_positions + 0xE48, common_frame_multiplier * 2);
226: 
227:                 // Encounter rate fix
228:                 replace_call_function(ff7_externals.field_update_models_positions + 0x90F, ff7_field_evaluate_encounter_rate);
229: 
230:                 // Text box message fix
231:                 patch_code_byte(ff7_externals.field_text_box_window_paging_631945 + 0xFD, 0x5 + common_frame_multiplier / 2);
232:                 patch_divide_code<byte>(ff7_externals.field_text_box_window_paging_631945 + 0x100, common_frame_multiplier);
233:                 patch_divide_code<WORD>(ff7_externals.field_text_box_window_paging_631945 + 0x111, common_frame_multiplier);
234:                 patch_code_byte(ff7_externals.field_text_box_window_paging_631945 + 0x141, 0x4 + common_frame_multiplier / 2);
235:                 patch_code_byte(ff7_externals.field_text_box_window_opening_6317A9 + 0x3D, 0x2 + common_frame_multiplier / 2);
236:                 patch_code_byte(ff7_externals.field_text_box_window_opening_6317A9 + 0xD2, 0x2 + common_frame_multiplier / 2);
237:                 patch_code_byte(ff7_externals.field_text_box_window_closing_632EB8 + 0x64, 0x2 + common_frame_multiplier / 2);
238:                 patch_code_byte(ff7_externals.field_text_box_window_closing_632EB8 + 0xBF, 0x2 + common_frame_multiplier / 2);
239:                 patch_divide_code<short>(ff7_externals.field_text_box_window_reverse_paging_632CAA + 0x42, common_frame_multiplier);
240:                 patch_divide_code<short>(ff7_externals.field_opcode_message_update_loop_630D50 + 0x1AC, common_frame_multiplier);
241:                 patch_divide_code<short>(ff7_externals.field_opcode_message_update_loop_630D50 + 0x2CF, common_frame_multiplier);
242:                 patch_divide_code<short>((uint32_t)ff7_externals.field_opcode_ask_update_loop_6310A1 + 0x1AC, common_frame_multiplier);
243:                 patch_divide_code<byte>((uint32_t)ff7_externals.field_opcode_ask_update_loop_6310A1 + 0x3CC, common_frame_multiplier);
244: 
245:                 // Fade in and fade out screen transitions
246:                 patch_divide_code<short>(ff7_externals.field_initialize_variables + 0x123, common_frame_multiplier);
247:                 patch_code_byte(ff7_externals.field_handle_screen_fading + 0x210, 25 * common_frame_multiplier);
248:                 patch_code_int(ff7_externals.field_handle_screen_fading + 0x240, 25 * common_frame_multiplier - 1);
249:             }
250: 
251:             // Smooth background movement for both 30 fps mode and 60 fps mode
252:             replace_call_function(ff7_externals.field_draw_everything + 0x34, ff7_field_set_world_coordinate_640EB7);
253:             replace_call_function(ff7_externals.field_loop_sub_63C17F + 0x1A6, ff7_field_update_background);
254:             replace_call_function(ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B + 0x357, ff7_field_submit_draw_arrow);
255:             replace_call_function(ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B + 0x63C, ff7_field_submit_draw_arrow);
256:             replace_call_function(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x284, ff7_field_submit_draw_cursor);
257:         }
258: 
259:         // Movie model animation fps fix
260:         replace_call_function(ff7_externals.field_update_models_positions + 0x68D, ff7_field_update_model_animation_frame);
261:         replace_call_function(ff7_externals.field_update_models_positions + 0x919, ff7_field_update_model_animation_frame);
262:         replace_call_function(ff7_externals.field_update_models_positions + 0xA2B, ff7_field_update_model_animation_frame);
263:         replace_call_function(ff7_externals.field_update_models_positions + 0xE8C, ff7_field_update_model_animation_frame);
264: 
265:         // Background scroll fps fix
266:         replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x34, ff7_opcode_divide_get_bank_value);
267:         replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x4D, ff7_opcode_divide_get_bank_value);
268:         replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x68, ff7_opcode_divide_get_bank_value);
269:         replace_call_function(common_externals.execute_opcode_table[BGSCR] + 0x81, ff7_opcode_divide_get_bank_value);
270:         replace_function(ff7_externals.opcode_shake, opcode_script_SHAKE);
271: 
272:         // Camera fps fix
273:         replace_call_function(common_externals.execute_opcode_table[SCRLC] + 0x3B, ff7_opcode_multiply_get_bank_value);
274:         replace_call_function(common_externals.execute_opcode_table[SCRLA] + 0x72, ff7_opcode_multiply_get_bank_value);
275:         replace_call_function(common_externals.execute_opcode_table[SCR2DC] + 0x3C, ff7_opcode_multiply_get_bank_value);
276:         replace_call_function(common_externals.execute_opcode_table[SCR2DL] + 0x3C, ff7_opcode_multiply_get_bank_value);
277:         replace_call_function(common_externals.execute_opcode_table[SCRLP] + 0xA7, ff7_opcode_multiply_get_bank_value);
278:         replace_call_function(common_externals.execute_opcode_table[NFADE] + 0x89, ff7_opcode_divide_get_bank_value);
279:         replace_call_function(common_externals.execute_opcode_table[VWOFT] + 0xCC, ff7_opcode_multiply_get_bank_value);
280:         patch_code_dword((uint32_t)&common_externals.execute_opcode_table[FADE], (DWORD)&opcode_script_FADE);
281: 
282:         // Movie fps fix
283:         patch_code_dword((uint32_t)&common_externals.execute_opcode_table[MVIEF], (DWORD)&opcode_script_MVIEF);
284:         patch_code_dword((uint32_t)&common_externals.execute_opcode_table[BGMOVIE], (DWORD)&opcode_script_BGMOVIE);
285: 
286:         // Others fps fix
287:         patch_code_dword((uint32_t)&common_externals.execute_opcode_table[WAIT], (DWORD)&opcode_script_WAIT);
288:         replace_function(ff7_externals.sub_611BAE, opcode_IFSW_compare_sub);
289: 
290:         // Fix wind wall animation for woa_* fields
291:         replace_call_function(ff7_externals.sub_62120E + 0x3AA, ff7_field_load_map_trigger_data);
292: 
293:         // Fix run emulation when using the analogue key for NPCs
294:         patch_code_dword((uint32_t)&common_externals.execute_opcode_table[IFKEY], (DWORD)&opcode_script_IFKEY);
295:     }
296: }
</file>

<file path="src/ff7/field/model.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "../../globals.h"
 25: #include "../../sfx.h"
 26: #include "../../movies.h"
 27: #include "../../utils.h"
 28: #include "../../log.h"
 29: #include "../widescreen.h"
 30: 
 31: #include "utils.h"
 32: #include "model.h"
 33: 
 34: namespace ff7::field
 35: {
 36:     bool ff7_field_do_draw_3d_model(short x, short y)
 37:     {
 38:         if(*ff7_externals.field_bg_flag_CC15E4)
 39:             return 1;
 40:         int left_offset_x = 40 + (widescreen_enabled ? abs(wide_viewport_x) - 50 : 0);
 41:         int right_offset_x = 400 + (widescreen_enabled ? abs(wide_viewport_x) - 50 : 0);
 42:         return x > ff7_externals.field_viewport_xy_CFF204->x - left_offset_x && x < ff7_externals.field_viewport_xy_CFF204->x + right_offset_x &&
 43:             y > ff7_externals.field_viewport_xy_CFF204->y - 120 && y < ff7_externals.field_viewport_xy_CFF204->y + 460;
 44:     }
 45: 
 46:     void ff7_field_update_models_position(int key_input_status)
 47:     {
 48:         bool emulate_run = !(ff7_externals.modules_global_object->current_key_input_status & 0x40) && gamepad_analogue_intent == INTENT_RUN;
 49: 
 50:         if (emulate_run)
 51:         {
 52:             key_input_status |= 0x40;
 53:             ff7_externals.modules_global_object->current_key_input_status |= 0x40;
 54:         }
 55: 
 56:         ((void(*)(int))ff7_externals.field_update_models_positions)(key_input_status);
 57: 
 58:         if (emulate_run)
 59:         {
 60:             key_input_status &= ~0x40;
 61:             ff7_externals.modules_global_object->current_key_input_status &= ~0x40;
 62:         }
 63: 
 64:         for(int model_idx = 0; model_idx < (int)(*ff7_externals.field_n_models); model_idx++)
 65:         {
 66:             // Reset movement frame index for all models if they are not walking/running
 67:             if((*ff7_externals.field_event_data_ptr)[model_idx].movement_type != 1)
 68:             {
 69:                 external_model_data[model_idx].moveFrameIndex = 0;
 70:             }
 71: 
 72:             // Reset rotation movement frame index for all models if they are not rotating
 73:             byte rotation_type = (*ff7_externals.field_event_data_ptr)[model_idx].rotation_steps_type;
 74:             if(rotation_type == 0 || rotation_type == 3)
 75:             {
 76:                 external_model_data[model_idx].rotationMoveFrameIndex = 0;
 77:             }
 78:         }
 79:     }
 80: 
 81:     int ff7_field_update_player_model_position(short model_id)
 82:     {
 83:         field_event_data* field_event_data_array = (*ff7_externals.field_event_data_ptr);
 84:         int original_movement_speed = field_event_data_array[model_id].movement_speed;
 85:         int frame_multiplier = get_frame_multiplier();
 86:         if(is_fps_running_more_than_original())
 87:         {
 88:             field_event_data_array[model_id].movement_speed = original_movement_speed / frame_multiplier;
 89:         }
 90: 
 91:         int is_player_moving = ff7_externals.field_update_single_model_position(model_id);
 92:         field_event_data_array[model_id].movement_speed = original_movement_speed;
 93: 
 94:         // Allow footsteps to be detected correctly
 95:         if(ff7_footsteps)
 96:             sfx_process_footstep(is_player_moving);
 97: 
 98:         return is_player_moving;
 99:     }
100: 
101:     int ff7_field_update_single_model_position(short model_id)
102:     {
103:         int ret;
104:         int frame_multiplier = get_frame_multiplier();
105:         field_event_data* field_event_data_array = (*ff7_externals.field_event_data_ptr);
106: 
107:         if(is_fps_running_more_than_original() && *ff7_externals.field_id == 748)
108:         {
109:             // Fix softlock related to this discussion https://github.com/julianxhokaxhiu/FFNx/discussions/569. 
110:             // The issue is due to the fact that when Cloud climb up, there is a mini auto movement which triggers a line making Cloud jump below.
111:             // This script that makes Cloud jump below does not end well, which makes the next script overlapping with this.
112:             // If the next script is to climb back up, there is a sort of race condition where the player movability is activated.
113:             // Then if the player taps the DOWN button, it will go into a softlock.
114:             // 
115:             // This logic is very fragile (might cause other softlock), so, the solution is to write another logic only for this map
116:             int interpolationStep = external_model_data[model_id].moveFrameIndex + 1;
117:             if(external_model_data[model_id].moveFrameIndex == 0)
118:             {
119:                 external_model_data[model_id].initialPosition = field_event_data_array[model_id].model_pos;
120:                 ret = ff7_externals.field_update_single_model_position(model_id);
121:                 external_model_data[model_id].updateMovementReturnValue = ret;
122:                 external_model_data[model_id].finalPosition = field_event_data_array[model_id].model_pos;
123:                 external_model_data[model_id].prevCollisionRadius = field_event_data_array[model_id].collision_radius;
124:                 field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
125:                 field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
126:                 field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
127:                 field_event_data_array[model_id].collision_radius = 0;
128:             }
129:             else
130:             {
131:                 ret = external_model_data[model_id].updateMovementReturnValue;
132:                 field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
133:                 field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
134:                 field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
135:             }
136: 
137:             if((external_model_data[model_id].moveFrameIndex + 1) % frame_multiplier == 0)
138:             {
139:                 field_event_data_array[model_id].collision_radius = external_model_data[model_id].prevCollisionRadius;
140:             }
141: 
142:             external_model_data[model_id].moveFrameIndex = (external_model_data[model_id].moveFrameIndex + 1) % frame_multiplier;
143:         }
144:         else if(is_fps_running_more_than_original())
145:         {
146:             int interpolationStep = external_model_data[model_id].moveFrameIndex + 1;
147:             if(external_model_data[model_id].moveFrameIndex == 0)
148:             {
149:                 external_model_data[model_id].initialPosition = field_event_data_array[model_id].model_pos;
150:                 ret = ff7_externals.field_update_single_model_position(model_id);
151:                 external_model_data[model_id].updateMovementReturnValue = ret;
152:                 external_model_data[model_id].finalPosition = field_event_data_array[model_id].model_pos;
153:                 field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
154:                 field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
155:                 field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
156:             }
157:             else
158:             {
159:                 ret = external_model_data[model_id].updateMovementReturnValue;
160:                 field_event_data_array[model_id].model_pos.x = external_model_data[model_id].initialPosition.x + ((external_model_data[model_id].finalPosition.x - external_model_data[model_id].initialPosition.x) * interpolationStep) / frame_multiplier;
161:                 field_event_data_array[model_id].model_pos.y = external_model_data[model_id].initialPosition.y + ((external_model_data[model_id].finalPosition.y - external_model_data[model_id].initialPosition.y) * interpolationStep) / frame_multiplier;
162:                 field_event_data_array[model_id].model_pos.z = external_model_data[model_id].initialPosition.z + ((external_model_data[model_id].finalPosition.z - external_model_data[model_id].initialPosition.z) * interpolationStep) / frame_multiplier;
163:             }
164:             external_model_data[model_id].moveFrameIndex = (external_model_data[model_id].moveFrameIndex + 1) % frame_multiplier;
165:         }
166:         else
167:         {
168:             ret = ff7_externals.field_update_single_model_position(model_id);
169:         }
170: 
171:         return ret;
172:     }
173: 
174:     int ff7_field_check_collision_with_target(field_event_data* field_event_model, short target_collision_radius)
175:     {
176:         int ret;
177:         int frame_multiplier = get_frame_multiplier();
178:         int model_id = std::distance(*ff7_externals.field_event_data_ptr, field_event_model);
179: 
180:         if(is_fps_running_more_than_original())
181:         {
182:             if(external_model_data[model_id].moveFrameIndex == 0)
183:             {
184:                 ret = ff7_externals.field_check_collision_with_target(field_event_model, target_collision_radius);
185:                 external_model_data[model_id].wasNotCollidingWithTarget = ret;
186:             }
187:             else
188:             {
189:                 ret = external_model_data[model_id].wasNotCollidingWithTarget;
190:             }
191:         }
192:         else
193:         {
194:             ret = ff7_externals.field_check_collision_with_target(field_event_model, target_collision_radius);
195:         }
196: 
197:         return ret;
198:     }
199: 
200:     void ff7_field_update_models_rotation_new()
201:     {
202:         for(int model_idx = 0; model_idx < *ff7_externals.field_n_models; model_idx++)
203:         {
204:             auto &field_event_data = (*ff7_externals.field_event_data_ptr)[model_idx];
205:             byte rotation_type = field_event_data.rotation_steps_type;
206:             if(rotation_type)
207:             {
208:                 // Legacy code still works, but when in 60FPS, the steps index and number of steps are modified
209:                 uint32_t rotation_n_steps = field_event_data.rotation_n_steps;
210:                 uint32_t rotation_steps_idx = field_event_data.rotation_step_idx;
211: 
212:                 if(is_fps_running_more_than_original())
213:                 {
214:                     rotation_n_steps *= get_frame_multiplier();
215:                     rotation_steps_idx = rotation_steps_idx * get_frame_multiplier() + external_model_data[model_idx].rotationMoveFrameIndex;
216:                 }
217: 
218:                 if(rotation_type == 1)
219:                 {
220:                     field_event_data.rotation_curr_value = ff7_externals.field_get_linear_interpolated_value(
221:                         field_event_data.rotation_initial,
222:                         field_event_data.rotation_final,
223:                         rotation_n_steps,
224:                         rotation_steps_idx
225:                     );
226: 
227:                     if(field_event_data.rotation_step_idx == field_event_data.rotation_n_steps)
228:                         field_event_data.rotation_steps_type = 3;
229:                     else
230:                     {
231:                         if(is_fps_running_more_than_original())
232:                         {
233:                             external_model_data[model_idx].rotationMoveFrameIndex = (external_model_data[model_idx].rotationMoveFrameIndex + 1) % get_frame_multiplier();
234:                             if(external_model_data[model_idx].rotationMoveFrameIndex == 0)
235:                                 field_event_data.rotation_step_idx++;
236:                         }
237:                         else
238:                         {
239:                             field_event_data.rotation_step_idx++;
240:                         }
241:                     }
242:                 }
243:                 else if(rotation_type == 2)
244:                 {
245:                     field_event_data.rotation_curr_value = ff7_externals.field_get_smooth_interpolated_value(
246:                         field_event_data.rotation_initial,
247:                         field_event_data.rotation_final,
248:                         rotation_n_steps,
249:                         rotation_steps_idx
250:                     );
251: 
252:                     if(field_event_data.rotation_step_idx == field_event_data.rotation_n_steps)
253:                         field_event_data.rotation_steps_type = 3;
254:                     else
255:                     {
256:                         if(is_fps_running_more_than_original())
257:                         {
258:                             external_model_data[model_idx].rotationMoveFrameIndex = (external_model_data[model_idx].rotationMoveFrameIndex + 1) % get_frame_multiplier();
259:                             if(external_model_data[model_idx].rotationMoveFrameIndex == 0)
260:                                 field_event_data.rotation_step_idx++;
261:                         }
262:                         else
263:                         {
264:                             field_event_data.rotation_step_idx++;
265:                         }
266:                     }
267:                 }
268:             }
269:         }
270:     }
271: 
272:     void ff7_field_handle_blink_reset()
273:     {
274:         static WORD last_field_id = 0;
275: 
276:         if (last_field_id != *common_externals.current_field_id)
277:         {
278:             last_field_id = *common_externals.current_field_id;
279: 
280:             // Reset eyes blinking
281:             ff7_externals.field_model_blink_data_D000C8->blink_left_eye_mode = 0;
282:             ff7_externals.field_model_blink_data_D000C8->blink_right_eye_mode = 0;
283: 
284:             // Reset mouths
285:             for(int i = 0; i < FF7_MAX_NUM_MODEL_ENTITIES; i++)
286:             {
287:                 ff7_model_data[i].current_mouth_idx = 0;
288:                 if (ff7_model_data[i].mouth_tex) ff7_externals.field_unload_model_tex(ff7_model_data[i].mouth_tex);
289:                 ff7_model_data[i].mouth_tex = NULL;
290:             }
291:         }
292:     }
293: 
294:     int ff7_internal_blink_eye(field_animation_data *field_anim_data, field_model_blink_data *blink_data)
295:     {
296:         int i;
297:         ff7_polygon_set *polygon_set = nullptr;
298:         struct hrc_bone *bones;
299:         hrc_data *hrc_data;
300:         int blink_left_eye_mode;
301:         int blink_right_eye_mode;
302: 
303:         if ( field_anim_data->anim_frame_object )
304:         {
305:             hrc_data = field_anim_data->anim_frame_object->hrc_data;
306:             if ( hrc_data )
307:             {
308:                 int bone_idx = 0;
309:                 bones = field_anim_data->anim_frame_object->hrc_data->bones;
310:                 if ( (char)field_anim_data->eye_texture_idx >= 33 )
311:                     return 1;
312:                 while ( bone_idx < (signed int)hrc_data->num_bones && _strcmpi(bones->bone_name, "head") )
313:                 {
314:                     ++bone_idx;
315:                     ++bones;
316:                 }
317:                 if ( bone_idx == hrc_data->num_bones ) return 0;
318:                 polygon_set = bones->rsd_array->rsd_data->polygon_set;
319:                 ff7_externals.field_sub_6A2736(polygon_set);
320:                 // Mouth replacement logic
321:                 if (ff7_advanced_blinking && polygon_set && ff7_model_data[blink_data->model_id].mouth_tex)
322:                 {
323:                     if (polygon_set->hundred_data_group_array[3] != NULL)
324:                     {
325:                         polygon_set->hundred_data_group_array[3] = ff7_model_data[blink_data->model_id].mouth_tex;
326:                         polygon_set->per_group_hundreds = 1;
327:                     }
328:                 }
329:                 blink_left_eye_mode = blink_data->blink_left_eye_mode;
330:                 for ( i = 0; i < (signed int)polygon_set->numgroups && !polygon_set->hundred_data[i].texture_set; ++i );
331:                 if ( i == polygon_set->numgroups )return 0;
332:                 if ( blink_left_eye_mode == 1 )
333:                 {
334:                     if (ff7_advanced_blinking && ff7_model_data[blink_data->model_id].left_eye_tex) polygon_set->hundred_data_group_array[1] = ff7_model_data[blink_data->model_id].left_eye_tex;
335:                     ff7_externals.field_sub_6A2782(i, &polygon_set->hundred_data[i], polygon_set);
336:                 }
337:                 else
338:                 {
339:                     if ( blink_left_eye_mode != 2 )
340:                     {
341:                         if (ff7_advanced_blinking && !ff7_model_data[blink_data->model_id].has_mouth) polygon_set->per_group_hundreds = 0;
342:                         return 0;
343:                     }
344:                     polygon_set->per_group_hundreds = 1;
345:                     if ( !field_anim_data->static_left_eye_tex )
346:                     goto LABEL_22;
347:                     ff7_externals.field_sub_6A2782(i, (p_hundred *)field_anim_data->static_left_eye_tex, polygon_set);
348:                 }
349:                 blink_right_eye_mode = blink_data->blink_right_eye_mode;
350:                 if ( ++i == polygon_set->numgroups ) return 0;
351:                 if ( blink_right_eye_mode == 1 )
352:                 {
353:                     if (ff7_advanced_blinking && ff7_model_data[blink_data->model_id].right_eye_tex) polygon_set->hundred_data_group_array[2] = ff7_model_data[blink_data->model_id].right_eye_tex;
354:                     ff7_externals.field_sub_6A2782(i, &polygon_set->hundred_data[i], polygon_set);
355:                     return 1;
356:                 }
357:                 if ( blink_right_eye_mode != 2 )
358:                 {
359:                     if (ff7_advanced_blinking && !ff7_model_data[blink_data->model_id].has_mouth) polygon_set->per_group_hundreds = 0;
360:                     return 0;
361:                 }
362:                 polygon_set->per_group_hundreds = 1;
363:                 if ( field_anim_data->static_right_eye_tex )
364:                 {
365:                     ff7_externals.field_sub_6A2782(i, (p_hundred *)field_anim_data->static_right_eye_tex, polygon_set);
366:                     return 1;
367:                 }
368:             LABEL_22:
369:                 ff7_externals.field_sub_6A2782(i, &polygon_set->hundred_data[i], polygon_set);
370:                 return 0;
371:             }
372:         }
373: 
374:         return 0;
375:     }
376: 
377:     int ff7_field_blink_eye_sub_649B50(field_animation_data *field_anim_data, field_model_blink_data *blink_data)
378:     {
379:         int ret = 0;
380: 
381:         // Custom eyes + mouth fetching
382:         byte curr_entity_id = *ff7_externals.current_entity_id;
383:         byte curr_model_id = blink_data->model_id;
384:         byte curr_eye_index = MAXBYTE;
385:         static char curr_model_name[10]{0};
386:         bool is_npc = false;
387: 
388:         if (ff7_advanced_blinking && curr_model_id != MAXBYTE)
389:         {
390:             byte left_eye_index = blink_data->blink_left_eye_mode;
391:             byte right_eye_index = blink_data->blink_right_eye_mode;
392:             byte mouth_index = ff7_model_data[curr_model_id].current_mouth_idx;
393:             curr_eye_index = field_anim_data->eye_texture_idx;
394: 
395:             _splitpath((const char*)(*ff7_externals.field_models_data + (10380 * curr_model_id) + 512), NULL, NULL, curr_model_name, NULL);
396: 
397:             if (trace_all || trace_opcodes) ffnx_trace("field_blink_eye_sub: curr_entity_id=%u,curr_model_id=%u,curr_eye_index=%u,curr_mouth_index=%u,curr_model_name=%s\n", curr_entity_id, curr_model_id, curr_eye_index, mouth_index, curr_model_name);
398: 
399:             if (curr_eye_index < 10)
400:             {
401:                 char directpath[MAX_PATH + sizeof(basedir)];
402:                 char filename[10];
403:                 char ext[4];
404:                 bool ext_left_eye_found = false, ext_right_eye_found = false;
405: 
406:                 // NPCs always default on Cloud eyes/mouth
407:                 if (curr_eye_index == 9)
408:                 {
409:                     curr_eye_index = 0;
410:                     is_npc = true;
411:                 }
412: 
413:                 if (ff7_externals.field_models_eye_blink_buffer[curr_eye_index].has_eyes)
414:                 {
415:                     // LEFT EYE
416:                     _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_left_eye_filename, NULL, NULL, filename, ext);
417: 
418:                     _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/eye_%s_%d.TEX", basedir, direct_mode_path.c_str(), curr_model_name, left_eye_index);
419:                     if (ext_left_eye_found = fileExists(directpath))
420:                         _snprintf(ff7_model_data[curr_model_id].left_eye_tex_filename, 1024, "eye_%s_%d%s", curr_model_name, left_eye_index, ext);
421:                     else
422:                     {
423:                         if (left_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom left eye texture not found: %s\n", directpath);
424: 
425:                         // If it is an NPC use the generic NPC name instead of Cloud
426:                         if (is_npc) _snprintf(filename, sizeof(filename), "npc_eye2");
427: 
428:                         _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/%s_%d.TEX", basedir, direct_mode_path.c_str(), filename, left_eye_index);
429:                         if (ext_left_eye_found = fileExists(directpath))
430:                             _snprintf(ff7_model_data[curr_model_id].left_eye_tex_filename, 1024, "%s_%d%s", filename, left_eye_index, ext);
431:                         else
432:                         {
433:                             if (left_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom left eye texture not found: %s\n", directpath);
434: 
435:                             // If it is an NPC, and nothing was found so far, switch back to Cloud eye
436:                             if (is_npc) _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_left_eye_filename, NULL, NULL, filename, ext);
437:                             _snprintf(ff7_model_data[curr_model_id].left_eye_tex_filename, 1024, "%s%s", filename, ext);
438:                         }
439:                     }
440: 
441:                     // RIGHT EYE
442:                     _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_right_eye_filename, NULL, NULL, filename, ext);
443: 
444:                     _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/eye_%sr_%d.TEX", basedir, direct_mode_path.c_str(), curr_model_name, right_eye_index);
445:                     if (ext_right_eye_found = fileExists(directpath))
446:                         _snprintf(ff7_model_data[curr_model_id].right_eye_tex_filename, 1024, "eye_%sr_%d%s", curr_model_name, right_eye_index, ext);
447:                     else
448:                     {
449:                         if (right_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom right eye texture not found: %s\n", directpath);
450: 
451:                         // If it is an NPC use the generic NPC name instead of Cloud
452:                         if (is_npc) _snprintf(filename, sizeof(filename), "npc_eye2r");
453: 
454:                         _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/%s_%d.TEX", basedir, direct_mode_path.c_str(), filename, right_eye_index);
455:                         if (ext_right_eye_found = fileExists(directpath))
456:                             _snprintf(ff7_model_data[curr_model_id].right_eye_tex_filename, 1024, "%s_%d%s", filename, right_eye_index, ext);
457:                         else
458:                         {
459:                             if (right_eye_index > 2 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom right eye texture not found: %s\n", directpath);
460: 
461:                             // If it is an NPC, and nothing was found so far, switch back to Cloud eye
462:                             if (is_npc) _splitpath(ff7_externals.field_models_eye_blink_buffer[curr_eye_index].static_right_eye_filename, NULL, NULL, filename, ext);
463:                             _snprintf(ff7_model_data[curr_model_id].right_eye_tex_filename, 1024, "%s%s", filename, ext);
464:                         }
465:                     }
466: 
467:                     // Reload TEX data in memory
468:                     if(field_anim_data->static_left_eye_tex) ff7_externals.field_unload_model_tex(field_anim_data->static_left_eye_tex);
469:                     if(field_anim_data->static_right_eye_tex) ff7_externals.field_unload_model_tex(field_anim_data->static_right_eye_tex);
470:                     curr_model_data.has_eyes = 1;
471:                     curr_model_data.static_left_eye_filename = ff7_model_data[curr_model_id].left_eye_tex_filename;
472:                     curr_model_data.static_right_eye_filename = ff7_model_data[curr_model_id].right_eye_tex_filename;
473:                     ff7_externals.field_load_model_eye_tex(&curr_model_data, field_anim_data);
474:                     ff7_model_data[curr_model_id].left_eye_tex = field_anim_data->static_left_eye_tex;
475:                     ff7_model_data[curr_model_id].right_eye_tex = field_anim_data->static_right_eye_tex;
476: 
477:                     // Restore original curr_eye_index
478:                     curr_eye_index = field_anim_data->eye_texture_idx;
479:                 }
480: 
481:                 // MOUTH
482:                 char* char_name = strtok(filename, "_");
483: 
484:                 _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/mouth_%s_%d.TEX", basedir, direct_mode_path.c_str(), curr_model_name, mouth_index);
485:                 if (ff7_model_data[curr_model_id].has_mouth = fileExists(directpath))
486:                     _snprintf(ff7_model_data[curr_model_id].mouth_tex_filename, 1024, "mouth_%s_%d%s", curr_model_name, mouth_index, ext);
487:                 else
488:                 {
489:                     if (mouth_index > 0 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom mouth texture not found: %s\n", directpath);
490: 
491:                     // NPC only
492:                     if (is_npc)
493:                     {
494:                         _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/npc_mouth_%d.TEX", basedir, direct_mode_path.c_str(), mouth_index);
495:                         if (ff7_model_data[curr_model_id].has_mouth = fileExists(directpath))
496:                             _snprintf(ff7_model_data[curr_model_id].mouth_tex_filename, 1024, "npc_mouth_%d%s", mouth_index, ext);
497:                         else if (mouth_index > 0 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom mouth texture not found: %s\n", directpath);
498:                     }
499:                     else
500:                     {
501:                         _snprintf(directpath, sizeof(directpath), "%s/%s/flevel/%s_mouth_%d.TEX", basedir, direct_mode_path.c_str(), filename, mouth_index);
502:                         if (ff7_model_data[curr_model_id].has_mouth = fileExists(directpath))
503:                             _snprintf(ff7_model_data[curr_model_id].mouth_tex_filename, 1024, "%s_mouth_%d%s", char_name, mouth_index, ext);
504:                         else if (mouth_index > 0 && (trace_all || trace_direct || trace_opcodes)) ffnx_trace("subcode[EYETX]: Custom mouth texture not found: %s\n", directpath);
505:                     }
506:                 }
507: 
508:                 // Prepare mouth tex object
509:                 if (ff7_model_data[curr_model_id].has_mouth)
510:                 {
511:                     struc_3 tex_mouth_info;
512:                     ff7_externals.create_struc_3_info_sub_67455E(&tex_mouth_info);
513:                     tex_mouth_info.base_directory = (uint32_t)ff7_externals.field_unk_909288;
514:                     tex_mouth_info.file_context.use_lgp = 1;
515:                     tex_mouth_info.file_context.lgp_num = 1;
516:                     tex_mouth_info.file_context.name_mangler = 0;
517:                     ff7_model_data[curr_model_id].mouth_tex = ff7_externals.field_load_model_tex(0, 0, ff7_model_data[curr_model_id].mouth_tex_filename, &tex_mouth_info, common_externals.get_game_object());
518:                 }
519:                 else
520:                 {
521:                     if (ff7_model_data[curr_model_id].mouth_tex) ff7_externals.field_unload_model_tex(ff7_model_data[curr_model_id].mouth_tex);
522:                     ff7_model_data[curr_model_id].mouth_tex = NULL;
523:                 }
524: 
525:                 // Index is also treated as blink mode, if higher than 2 then "fake a closed eyes" in order to reload textures
526:                 if (left_eye_index <= 2 || right_eye_index <= 2)
527:                 {
528:                     blink_data->blink_left_eye_mode = left_eye_index;
529:                     blink_data->blink_right_eye_mode = right_eye_index;
530:                 }
531:                 else if (ext_left_eye_found || ext_right_eye_found)
532:                 {
533:                     blink_data->blink_left_eye_mode = 2;
534:                     blink_data->blink_right_eye_mode = 2;
535:                 }
536:                 blink_data->model_id = curr_model_id;
537:             }
538:         }
539: 
540:         // Original code
541:         ret = ff7_internal_blink_eye(field_anim_data, blink_data);
542: 
543:         // 60FPS patch: wait time and blink time
544:         if(ff7_fps_limiter == FPS_LIMITER_60FPS)
545:         {
546:             if(blink_data->blink_left_eye_mode == 2 && blink_data->blink_right_eye_mode == 2)
547:             {
548:                 auto &field_event_data = (*ff7_externals.field_event_data_ptr)[blink_data->model_id];
549:                 if(external_model_data[blink_data->model_id].blinkFrameIndex > 0)
550:                 {
551:                     field_event_data.blink_wait_frames = 0;
552:                     external_model_data[blink_data->model_id].blinkFrameIndex--;
553:                 }
554:                 else
555:                 {
556:                     field_event_data.blink_wait_frames = 64 * common_frame_multiplier + getRandomInt(0, 32 * common_frame_multiplier);
557:                     external_model_data[blink_data->model_id].blinkFrameIndex = BLINKING_FRAMES;
558:                 }
559:             }
560:         }
561: 
562:         return ret;
563:     }
564: 
565:     void ff7_field_update_model_animation_frame(short model_id)
566:     {
567:         field_event_data &model_event_data = (*ff7_externals.field_event_data_ptr)[model_id];
568:         const int original_animation_speed = model_event_data.animation_speed;
569:         if (is_overlapping_movie_playing())
570:         {
571:             if(movie_fps_ratio == 1 && ff7_fps_limiter == FPS_LIMITER_60FPS)
572:                 model_event_data.animation_speed *= common_frame_multiplier;
573:             else if(movie_fps_ratio > 1 && ff7_fps_limiter < FPS_LIMITER_60FPS)
574:                 model_event_data.animation_speed /= movie_fps_ratio;
575:             else if(movie_fps_ratio > 2 && ff7_fps_limiter == FPS_LIMITER_60FPS)
576:                 model_event_data.animation_speed /= (movie_fps_ratio / 2);
577:         }
578: 
579:         ff7_externals.field_update_model_animation_frame(model_id);
580: 
581:         model_event_data.animation_speed = original_animation_speed;
582:     }
583: 
584:     int ff7_field_models_eye_to_model(char* model_name)
585:     {
586:         // Cloud
587:         if ( !_strcmpi(model_name, "AAAA") )
588:             return 0;
589:         if ( !_strcmpi(model_name, "AFIE") )
590:             return 0;
591:         if ( !_strcmpi(model_name, "BHFF") )
592:             return 0;
593:         if ( !_strcmpi(model_name, "BUGE") )
594:             return 0;
595:         if ( !_strcmpi(model_name, "DLFB") )
596:             return 0;
597:         if ( !_strcmpi(model_name, "EIHD") )
598:             return 0;
599:         if ( !_strcmpi(model_name, "EKBF") )
600:             return 0;
601:         if ( !_strcmpi(model_name, "ENAB") )
602:             return 0;
603:         if ( !_strcmpi(model_name, "HTJE") )
604:             return 0;
605: 
606:         // Tifa
607:         if ( !_strcmpi(model_name, "AAGB") )
608:             return 1;
609:         if ( !_strcmpi(model_name, "AXJA") )
610:             return 1;
611:         if ( !_strcmpi(model_name, "EQIB") )
612:             return 1;
613:         if ( !_strcmpi(model_name, "BIDB") )
614:             return 1;
615:         if ( !_strcmpi(model_name, "AGGB") )
616:             return 1;
617:         if ( !_strcmpi(model_name, "BUAC") )
618:             return 1;
619: 
620:         // Aerith
621:         if ( !_strcmpi(model_name, "AUFF") )
622:             return 2;
623:         if ( !_strcmpi(model_name, "CAHC") )
624:             return 2;
625:         if ( !_strcmpi(model_name, "AZBB") )
626:             return 2;
627:         if ( !_strcmpi(model_name, "CQGA") )
628:             return 2;
629:         if ( !_strcmpi(model_name, "DIFF") )
630:             return 2;
631:         if ( !_strcmpi(model_name, "CPJF") ) // Ifalna - shares the same eyes
632:             return 2;
633: 
634:         // Barret
635:         if ( !_strcmpi(model_name, "ACGD") )
636:             return 3;
637:         if ( !_strcmpi(model_name, "FQCB") )
638:             return 3;
639:         if ( !_strcmpi(model_name, "AYFB") )
640:             return 3;
641:         if ( !_strcmpi(model_name, "AIBA") )
642:             return 3;
643: 
644:         // Red XIII
645:         if ( !_strcmpi(model_name, "ADDA") )
646:             return 4;
647:         if ( !_strcmpi(model_name, "HVJF") )
648:             return 4;
649: 
650:         // Cid
651:         if ( !_strcmpi(model_name, "ABDA") )
652:             return 5;
653:         if ( !_strcmpi(model_name, "AIHB") )
654:             return 5;
655: 
656:         // Vincent
657:         if ( !_strcmpi(model_name, "AEHD") )
658:             return 6;
659:         if ( !_strcmpi(model_name, "BIJD") )
660:             return 6;
661: 
662:         // Yuffie
663:         if ( !_strcmpi(model_name, "ABJB") )
664:             return 7;
665:         if ( !_strcmpi(model_name, "FEEA") )
666:             return 7;
667:         if ( !_strcmpi(model_name, "AHDF") )
668:             return 7;
669: 
670:         // Cait Sith
671:         if ( !_strcmpi(model_name, "AEBC") )
672:             return 8;
673: 
674:         return 9; // Defaults to Cloud eye
675:     }
676: }
</file>

<file path="src/ff7/field/model.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include "ff7.h"
27: 
28: #include <array>
29: 
30: namespace ff7::field
31: {
32:     struct external_field_model_data
33:     {
34:         int moveFrameIndex;
35:         vector3<int> initialPosition;
36:         vector3<int> finalPosition;
37:         int wasNotCollidingWithTarget;
38:         int updateMovementReturnValue;
39:         int prevCollisionRadius;
40: 
41:         int rotationMoveFrameIndex;
42: 
43:         int blinkFrameIndex;
44:     };
45: 
46:     constexpr int MAX_FIELD_MODELS = 32;
47:     constexpr int BLINKING_FRAMES = 4;
48: 
49:     std::array<external_field_model_data, MAX_FIELD_MODELS> external_model_data;
50:     ff7_model_eye_texture_data curr_model_data;
51:     ff7_model_custom_data ff7_model_data[FF7_MAX_NUM_MODEL_ENTITIES];
52: 
53:     bool ff7_field_do_draw_3d_model(short x, short y);
54:     void ff7_field_update_models_position(int key_input_status);
55:     int ff7_field_update_player_model_position(short model_id);
56:     int ff7_field_update_single_model_position(short model_id);
57:     int ff7_field_check_collision_with_target(field_event_data* field_event_model, short target_collision_radius);
58:     void ff7_field_update_models_rotation_new();
59:     int ff7_field_blink_eye_sub_649B50(field_animation_data *field_anim_data, field_model_blink_data *blink_data);
60:     void ff7_field_handle_blink_reset();
61:     void ff7_field_update_model_animation_frame(short model_id);
62:     int ff7_field_models_eye_to_model(char* model_name);
63: }
</file>

<file path="src/ff7/field/opcode.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "../../log.h"
 25: #include "../../globals.h"
 26: #include "../../ff7.h"
 27: #include "../../field.h"
 28: #include "opcode.h"
 29: #include "utils.h"
 30: 
 31: #include <set>
 32: 
 33: namespace ff7::field
 34: {
 35:     std::set<field_bank_address> field_bank_address_to_be_fixed = {{14, 6}};
 36:     field_bank_address mvief_bank_address;
 37: 
 38:     int call_original_opcode_function(byte opcode)
 39:     {
 40:         if(original_opcode_table[opcode])
 41:             return ((int(*)())original_opcode_table[opcode])();
 42:         else
 43:         {
 44:             ffnx_error("Initialization error: original opcode table empty in position %d\n", opcode);
 45:             return 0;
 46:         }
 47:     }
 48: 
 49:     short ff7_opcode_multiply_get_bank_value(short bank, short address)
 50:     {
 51:         int16_t ret = ff7_externals.get_bank_value(bank, address);
 52:         if(is_fps_running_more_than_original())
 53:             ret *= get_frame_multiplier();
 54:         return ret;
 55:     }
 56: 
 57:     short ff7_opcode_divide_get_bank_value(short bank, short address)
 58:     {
 59:         int16_t ret = ff7_externals.get_bank_value(bank, address);
 60:         if(is_fps_running_more_than_original())
 61:         {
 62:             if(abs(ret) >= get_frame_multiplier())
 63:                 ret /= get_frame_multiplier();
 64:         }
 65:         return ret;
 66:     }
 67: 
 68:     int opcode_script_partial_animation_wrapper()
 69:     {
 70:         field_event_data* event_data = *ff7_externals.field_event_data_ptr;
 71:         field_animation_data* animation_data = *ff7_externals.field_animation_data_ptr;
 72:         WORD total_number_of_frames = -1;
 73:         int frame_multiplier = get_frame_multiplier();
 74: 
 75:         byte curr_opcode = get_field_parameter<byte>(-1);
 76:         byte curr_model_id = ff7_externals.field_model_id_array[*ff7_externals.current_entity_id];
 77:         byte previous_animation_id = event_data[curr_model_id].animation_id;
 78:         byte speed = get_field_parameter<byte>(3);
 79:         short previous_current_frame = event_data[curr_model_id].currentFrame;
 80:         short first_frame = 16 * get_field_parameter<byte>(1) * frame_multiplier / ((curr_opcode == CANIM1 || curr_opcode == CANIM2) ? speed : 1);
 81:         short last_frame = (get_field_parameter<byte>(2) * frame_multiplier + 1) / speed;
 82:         char animation_type = ff7_externals.animation_type_array[curr_model_id];
 83: 
 84:         int ret = call_original_opcode_function(curr_opcode);
 85: 
 86:         if(curr_model_id != 255)
 87:         {
 88:             switch(animation_type)
 89:             {
 90:             case 0:
 91:             case 1:
 92:             case 3:
 93:                 if(animation_data)
 94:                     total_number_of_frames = animation_data[curr_model_id].anim_frame_object->number_of_frames - 1;
 95: 
 96:                 if(last_frame > total_number_of_frames)
 97:                     last_frame = total_number_of_frames;
 98: 
 99:                 // Since last frame is increased by 1, there might be cases where first frame is greater than previous current frame
100:                 if(previous_animation_id == event_data[curr_model_id].animation_id && previous_current_frame == first_frame + event_data[curr_model_id].animation_speed)
101:                     first_frame = previous_current_frame;
102: 
103:                 event_data[curr_model_id].currentFrame = first_frame;
104:                 event_data[curr_model_id].lastFrame = last_frame;
105:                 break;
106:             default:
107:                 break;
108:             }
109:         }
110: 
111:         return ret;
112:     }
113: 
114:     int opcode_script_SHAKE()
115:     {
116:         byte type = get_field_parameter<byte>(2);
117:         auto *field_global_data_ptr = *ff7_externals.field_global_object_ptr;
118:         if ( (type & 1) != 0 )
119:         {
120:             field_global_data_ptr->shake_bg_x.do_shake = 1;
121:             field_global_data_ptr->shake_bg_x.shake_amplitude = ff7_externals.get_char_bank_value(1, 4);
122:             field_global_data_ptr->shake_bg_x.shake_n_steps = ff7_externals.get_char_bank_value(2, 5);
123: 
124:             if(is_fps_running_more_than_original())
125:                 field_global_data_ptr->shake_bg_x.shake_n_steps *= get_frame_multiplier();
126:         }
127:         else
128:         {
129:             field_global_data_ptr->shake_bg_x.do_shake = 0;
130:         }
131:         if ( (type & 2) != 0 )
132:         {
133:             field_global_data_ptr->shake_bg_y.do_shake = 1;
134:             field_global_data_ptr->shake_bg_y.shake_amplitude = ff7_externals.get_char_bank_value(3, 6);
135:             field_global_data_ptr->shake_bg_y.shake_n_steps = ff7_externals.get_char_bank_value(4, 7);
136: 
137:             if(is_fps_running_more_than_original())
138:                 field_global_data_ptr->shake_bg_y.shake_n_steps *= get_frame_multiplier();
139:         }
140:         else
141:         {
142:             field_global_data_ptr->shake_bg_y.do_shake = 0;
143:         }
144:         ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] += 8;
145:         return 0;
146:     }
147: 
148:     int opcode_script_WAIT()
149:     {
150:         int result = 0;
151: 
152:         WORD frames_left = ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id];
153:         if (frames_left)
154:         {
155:             if (frames_left == 1)
156:             {
157:                 ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id] = 0;
158:                 ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] += 3;
159:                 result = 0;
160:             }
161:             else
162:             {
163:                 --ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id];
164:                 result = 1;
165:             }
166:         }
167:         else
168:         {
169:             ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id] = get_field_parameter<WORD>(0);
170: 
171:             if(is_fps_running_more_than_original())
172:                 ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id] *= get_frame_multiplier();
173: 
174:             if (!ff7_externals.wait_frames_ptr[*ff7_externals.current_entity_id])
175:                 ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] += 3;
176:             result = 1;
177:         }
178: 
179:         return result;
180:     }
181: 
182:     int opcode_script_MVIEF()
183:     {
184:         mvief_bank_address = {get_field_parameter<byte>(0), get_field_parameter<byte>(1)};
185: 
186:         return call_original_opcode_function(MVIEF);
187:     }
188: 
189:     int opcode_script_BGMOVIE()
190:     {
191:         is_movie_bgfield = get_field_parameter<byte>(0);
192: 
193:         return call_original_opcode_function(BGMOVIE);
194:     }
195: 
196:     uint8_t opcode_IFSW_compare_sub()
197:     {
198:         int16_t left_value = ff7_externals.get_bank_value(1, 2);
199:         int16_t right_value = ff7_externals.get_bank_value(2, 4);
200:         byte compare_type = get_field_parameter<byte>(5);
201: 
202:         field_bank_address current_mvief_bank_address = {get_field_bank_value(0), (byte)get_field_parameter<WORD>(1)};
203: 
204:         // Movie fix
205:         if (is_overlapping_movie_playing() && movie_fps_ratio > 1)
206:         {
207:             if (current_mvief_bank_address == mvief_bank_address)
208:                 right_value *= movie_fps_ratio;
209:         }
210:         else
211:         {
212:             if(ff7_fps_limiter == FPS_LIMITER_60FPS)
213:             {
214:                 if(field_bank_address_to_be_fixed.contains(current_mvief_bank_address))
215:                     right_value *= common_frame_multiplier;
216:             }
217:         }
218: 
219:         switch(compare_type)
220:         {
221:         case 0:
222:             return (left_value == right_value);
223:         case 1:
224:             return (left_value != right_value);
225:         case 2:
226:             return (left_value > right_value);
227:         case 3:
228:             return (left_value < right_value);
229:         case 4:
230:             return (left_value >= right_value);
231:         case 5:
232:             return (left_value <= right_value);
233:         case 6:
234:             return (right_value & left_value);
235:         case 7:
236:             return (right_value ^ left_value);
237:         case 8:
238:             return (right_value | left_value);
239:         case 9:
240:             return ((1 << right_value) & left_value);
241:         case 10:
242:             return ((uint8_t)((1 << right_value) & left_value) == 0);
243:         default:
244:             return 0;
245:         }
246:     }
247: 
248:     int opcode_script_FADE()
249:     {
250:         int ret = ((int(*)())ff7_externals.opcode_fade)();
251: 
252:         if(is_fps_running_more_than_original())
253:         {
254:             if((*ff7_externals.field_global_object_ptr)->fade_speed >= get_frame_multiplier())
255:                 (*ff7_externals.field_global_object_ptr)->fade_speed /= get_frame_multiplier();
256:         }
257: 
258:         return ret;
259:     }
260: 
261:     int opcode_script_IFKEY()
262:     {
263:         uint16_t key = get_field_parameter<uint16_t>(0);
264:         bool emulate_run = (key & 0x40) == 0x40 && gamepad_analogue_intent == INTENT_RUN;
265: 
266:         if (emulate_run)
267:         {
268:             ff7_externals.modules_global_object->current_key_input_status |= 0x40;
269:             ff7_externals.modules_global_object->field_78 |= 0x40;
270:         }
271: 
272:         int ret = call_original_opcode_function(IFKEY);
273: 
274:         if (emulate_run)
275:         {
276:             ff7_externals.modules_global_object->current_key_input_status &= ~0x40;
277:             ff7_externals.modules_global_object->field_78 &= ~0x40;
278:         }
279: 
280:         return ret;
281:     }
282: }
</file>

<file path="src/ff7/field/opcode.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #pragma once
 25: 
 26: #include <array>
 27: #include <windows.h>
 28: 
 29: namespace ff7::field
 30: {
 31:     struct field_bank_address
 32:     {
 33:         byte bank;
 34:         byte address;
 35: 
 36:         uint32_t getID() const
 37:         {
 38:             return bank * 256 + address;
 39:         }
 40: 
 41:         bool operator< (const field_bank_address& f) const
 42:         {
 43:             return this->getID() < f.getID();
 44:         }
 45: 
 46:         bool operator== (const field_bank_address& f) const
 47:         {
 48:             return this->getID() == f.getID();
 49:         }
 50:     };
 51: 
 52:     std::array<uint32_t, 256> original_opcode_table {0};
 53: 
 54:     short ff7_opcode_multiply_get_bank_value(short bank, short address);
 55:     short ff7_opcode_divide_get_bank_value(short bank, short address);
 56:     int opcode_script_partial_animation_wrapper();
 57:     int opcode_script_SHAKE();
 58:     int opcode_script_WAIT();
 59:     int opcode_script_MVIEF();
 60:     int opcode_script_BGMOVIE();
 61:     uint8_t opcode_IFSW_compare_sub();
 62:     int opcode_script_FADE();
 63:     int opcode_script_IFKEY();
 64: 
 65:     // Thanks for myst6re https://github.com/myst6re/makoureactor/blob/5231723307901043941356ad1e42d26725305edf/core/field/Opcode.h#L71
 66:     enum FieldOpcode {
 67:         RET=0, REQ, REQSW, REQEW,
 68:         PREQ, PRQSW, PRQEW, RETTO,
 69:         JOIN, SPLIT, SPTYE, GTPYE,
 70:         Unknown1, Unknown2, DSKCG, SPECIAL,
 71: 
 72:         JMPF, JMPFL, JMPB, JMPBL,
 73:         IFUB, IFUBL, IFSW, IFSWL,
 74:         IFUW, IFUWL, Unknown3, Unknown4,
 75:         Unknown5, Unknown6, Unknown7, Unknown8,
 76: 
 77:         MINIGAME, TUTOR, BTMD2, BTRLD,
 78:         WAIT, NFADE, BLINK, BGMOVIE,
 79:         KAWAI, KAWIW, PMOVA, SLIP,
 80:         BGPDH, BGSCR, WCLS, WSIZW,
 81: 
 82:         IFKEY, IFKEYON, IFKEYOFF, UC,
 83:         PDIRA, PTURA, WSPCL, WNUMB,
 84:         STTIM, GOLDu, GOLDd, CHGLD,
 85:         HMPMAX1, HMPMAX2, MHMMX, HMPMAX3,
 86: 
 87:         MESSAGE, MPARA, MPRA2, MPNAM,
 88:         Unknown9, MPu, Unknown10, MPd,
 89:         ASK, MENU, MENU2, BTLTB,
 90:         Unknown11, HPu, Unknown12, HPd,
 91: 
 92:         WINDOW, WMOVE, WMODE, WREST,
 93:         WCLSE, WROW, GWCOL, SWCOL,
 94:         STITM, DLITM, CKITM, SMTRA,
 95:         DMTRA, CMTRA, SHAKE, NOP,
 96: 
 97:         MAPJUMP, SCRLO, SCRLC, SCRLA,
 98:         SCR2D, SCRCC, SCR2DC, SCRLW,
 99:         SCR2DL, MPDSP, VWOFT, FADE,
100:         FADEW, IDLCK, LSTMP, SCRLP,
101: 
102:         BATTLE, BTLON, BTLMD, PGTDR,
103:         GETPC, PXYZI, PLUSX, PLUS2X,
104:         MINUSX, MINUS2X, INCX, INC2X,
105:         DECX, DEC2X, TLKON, RDMSD,
106: 
107:         SETBYTE, SETWORD, BITON, BITOFF,
108:         BITXOR, PLUS, PLUS2, MINUS,
109:         MINUS2, MUL, MUL2, DIV,
110:         DIV2, MOD, MOD2, AND,
111: 
112:         AND2, OR, OR2, XOR,
113:         XOR2, INC, INC2, DEC,
114:         DEC2, RANDOM, LBYTE, HBYTE,
115:         TOBYTE, SETX, GETX, SEARCHX,
116: 
117:         PC, CHAR, DFANM, ANIME1,
118:         VISI, XYZI, XYI, XYZ,
119:         MOVE, CMOVE, MOVA, TURA,
120:         ANIMW, FMOVE, ANIME2, ANIMX1,
121: 
122:         CANIM1, CANMX1, MSPED, DIR,
123:         TURNGEN, TURN, DIRA, GETDIR,
124:         GETAXY, GETAI, ANIMX2, CANIM2,
125:         CANMX2, ASPED, Unknown13, CC,
126: 
127:         JUMP, AXYZI, LADER, OFST,
128:         OFSTW, TALKR, SLIDR, SOLID,
129:         PRTYP, PRTYM, PRTYE, IFPRTYQ,
130:         IFMEMBQ, MMBud, MMBLK, MMBUK,
131: 
132:         LINE, LINON, MPJPO, SLINE,
133:         SIN, COS, TLKR2, SLDR2,
134:         PMJMP, PMJMP2, AKAO2, FCFIX,
135:         CCANM, ANIMB, TURNW, MPPAL,
136: 
137:         BGON, BGOFF, BGROL, BGROL2,
138:         BGCLR, STPAL, LDPAL, CPPAL,
139:         RTPAL, ADPAL, MPPAL2, STPLS,
140:         LDPLS, CPPAL2, RTPAL2, ADPAL2,
141: 
142:         MUSIC, SOUND, AKAO, MUSVT,
143:         MUSVM, MULCK, BMUSC, CHMPH,
144:         PMVIE, MOVIE, MVIEF, MVCAM,
145:         FMUSC, CMUSC, CHMST, GAMEOVER,
146:         OPCODE_COUNT
147:     };
148: }
</file>

<file path="src/ff7/field/utils.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #pragma once
 25: 
 26: #include "../../movies.h"
 27: #include "../../cfg.h"
 28: #include "../../globals.h"
 29: #include "../widescreen.h"
 30: 
 31: namespace ff7::field
 32: {
 33:     inline bool is_fps_running_more_than_original()
 34:     {
 35:         if(is_overlapping_movie_playing())
 36:             return movie_fps_ratio > 1;
 37:         else
 38:             return ff7_fps_limiter == FPS_LIMITER_60FPS;
 39:     }
 40: 
 41:     inline int get_frame_multiplier()
 42:     {
 43:         if(is_overlapping_movie_playing())
 44:             return movie_fps_ratio;
 45:         else
 46:             return common_frame_multiplier;
 47:     }
 48: 
 49:     inline bool is_fieldmap_wide()
 50:     {
 51:         return widescreen_enabled && widescreen.getMode() != WM_DISABLED;
 52:     }
 53: 
 54:     inline bool is_fieldmap_uncropped()
 55:     {
 56:         return enable_uncrop && widescreen.getMode() != WM_DISABLED;
 57:     }
 58: 
 59:     inline float field_get_linear_interpolated_value_float(float initial_value, float final_value, int n_steps, int step_idx)
 60:     {
 61:         return std::lerp(initial_value, final_value, step_idx / (float)n_steps);
 62:     }
 63: 
 64:     inline float field_get_smooth_interpolated_value_float(float initial_value, float final_value, int n_steps, int step_idx)
 65:     {
 66:         float delta = final_value - initial_value;
 67:         return initial_value + delta * (0.5f + sin(-M_PI/2.f + M_PI * (step_idx / (float)n_steps)) / 2.f);
 68:     }
 69: 
 70:     inline int engine_apply_matrix_product_float_66307D(vector3<float> *input_vector, vector2<float> *output_vector, int *dummy1, int *dummy2)
 71:     {
 72:         int ret;
 73:         float matrix[16];
 74:         vector3<float> output_temp, vector_temp;
 75:         vector3<float> input_vector_copy = *input_vector;
 76:         ff7_game_engine_data* global_game_data = *ff7_externals.global_game_engine_data;
 77: 
 78:         ff7_externals.engine_convert_psx_matrix_to_float_matrix_row_version_661465(&global_game_data->rot_matrix, matrix);
 79:         ff7_externals.engine_apply_matrix_product_to_vector_66CF7E(matrix, &input_vector_copy, &output_temp);
 80:         vector_temp.x = (double)global_game_data->rot_matrix.position[0] + output_temp.x;
 81:         vector_temp.y = (double)global_game_data->rot_matrix.position[1] + output_temp.y;
 82:         vector_temp.z = (double)global_game_data->rot_matrix.position[2] + output_temp.z;
 83:         if (vector_temp.z == 0.f)
 84:         {
 85:             ret = 0;
 86:         }
 87:         else
 88:         {
 89:             output_vector->x = vector_temp.x * global_game_data->scale / vector_temp.z + global_game_data->float_delta_x;
 90:             output_vector->y = vector_temp.y * global_game_data->scale / vector_temp.z + global_game_data->float_delta_y;
 91:             ret = (vector_temp.z * 0.25f);
 92:         }
 93:         *dummy1 = 0;
 94:         *dummy2 = 0;
 95:         return ret;
 96:     }
 97: 
 98:     inline int field_apply_2D_translation_float_64314F(vector3<float> *input_vector, vector2<float> *output_vector)
 99:     {
100:         int dummy_1, dummy_2;
101:         int ret;
102: 
103:         ff7_externals.engine_set_game_engine_rot_matrix_663673(ff7_externals.field_camera_rotation_matrix_CFF3D8);
104:         ff7_externals.engine_set_game_engine_position_663707(ff7_externals.field_camera_rotation_matrix_CFF3D8);
105:         ff7_externals.engine_set_game_engine_delta_values_661976(ff7_externals.field_viewport_xy_CFF204->x, ff7_externals.field_viewport_xy_CFF204->y);
106:         ret = engine_apply_matrix_product_float_66307D(input_vector, output_vector, &dummy_1, &dummy_2);
107:         ff7_externals.engine_set_game_engine_delta_values_661976(ff7_externals.field_max_half_viewport_width_height_CFF1F4->x, ff7_externals.field_max_half_viewport_width_height_CFF1F4->y);
108:         return ret;
109:     }
110: }
</file>

<file path="src/ff7/world/camera.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2022 Cosmos                                             //
 10: //    Copyright (C) 2022 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "../../globals.h"
 25: #include "camera.h"
 26: #include "world.h"
 27: #include "utils.h"
 28: #include "defs.h"
 29: 
 30: namespace ff7::world
 31: {
 32:     WorldCamera camera;
 33: 
 34:     void update_world_camera_front(int current_key_input, int prev_key_input)
 35:     {
 36:         const int player_model_id = ff7_externals.world_get_player_model_id();
 37:         int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
 38:         int world_map_type = *ff7_externals.world_map_type_E045E8;
 39:         int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;
 40: 
 41:         if (world_map_type == SNOWSTORM)
 42:         {
 43:             auto flag = current_key_input & ANY_DIRECTIONAL_KEY;
 44:             int delta_camera_step = ff7_externals.world_snowstorm_get_camera_movement_758B12(flag,
 45:                                     !((current_key_input & CIRCLE) == 0 || (prev_key_input & CIRCLE) != 0));
 46:             *ff7_externals.world_camera_front_DFC484 += delta_camera_step;
 47:         }
 48:         else
 49:         {
 50: 
 51:             auto rotationSpeed = camera.getRotationSpeed();
 52: 
 53:             int current_key_input = ff7_externals.world_get_current_key_input_status();
 54:             float playerDeltaMovement = static_cast<float>(*ff7_externals.world_special_delta_movement_DE6A18);
 55:             int movement_speed = get_player_movement_speed(player_model_id);
 56:             float speedCoeff = std::abs(playerDeltaMovement) / (movement_speed);
 57: 
 58:             if (camera_view_type == HIGHWIND_VIEW || world_map_type == UNDERWATER || player_model_id == TINY_BRONCO || player_model_id == BUGGY || player_model_id == SUBMARINE)
 59:                 rotationSpeed.y = rotationSpeed.y + rotationSpeed.y * speedCoeff;
 60: 
 61:             camera.localTargetRotation.x = std::min(std::max(camera.localTargetRotation.x - rotationSpeed.x, -175.0f), -95.0f);
 62:             camera.localTargetRotation.y = std::remainder(camera.localTargetRotation.y - rotationSpeed.y, 360.0f);
 63: 
 64:             auto last_valid_player_direction = (*ff7_externals.world_event_current_entity_ptr_E39AD8)->direction;
 65:             if(last_valid_player_direction > 2048)
 66:                 last_valid_player_direction -= 4096;
 67:             if(last_valid_player_direction < -2048)
 68:                 last_valid_player_direction += 4096;
 69:             float player_direction = 360.0f * static_cast<float>(4096 - last_valid_player_direction - 2048) / 4096;
 70:             auto joyDir = ff7::world::world.GetJoystickDirection();
 71:             if (camera_view_type == HIGHWIND_VIEW || world_map_type == UNDERWATER || player_model_id == TINY_BRONCO || player_model_id == BUGGY || player_model_id == SUBMARINE)
 72:             {
 73:                 if(camera.isResetCameraRotationRequested())
 74:                 {
 75:                     camera.localTargetRotation.y = player_direction;
 76:                     ff7::world::camera.requestResetCameraRotation(false);
 77:                 }
 78:                 else
 79:                 {
 80:                     float t = 0.02 * movement_multiplier;
 81: 
 82:                     bool isMovementButtonPressed = is_key_pressed(current_key_input, CIRCLE | R1 | SQUARE | L1 );
 83: 
 84:                     if (abs(joyDir.x) == 0.0f && !isMovementButtonPressed) t = 0.0f;
 85: 
 86:                     if (player_model_id == BUGGY) t *= speedCoeff;
 87:                     else t *= isMovementButtonPressed ? std::max(0.1f, speedCoeff) : abs(joyDir.x);
 88: 
 89:                     float diff = player_direction - camera.localTargetRotation.y;
 90:                     if (diff > 180) camera.localTargetRotation.y += 360;
 91:                     else if (diff < - 180)  camera.localTargetRotation.y -= 360;
 92:                     camera.localTargetRotation.y = (1.0f - t) * camera.localTargetRotation.y + t * player_direction;
 93:                 }
 94:                 camera.targetRotation.y = camera.localTargetRotation.y;
 95:                 camera.targetRotation.x = camera.localTargetRotation.x;
 96:             }
 97:             else
 98:             {
 99:                 if (camera.isResetCameraRotationRequested())
100:                 {
101:                     camera.targetRotation.x = camera.localTargetRotation.x;
102:                     camera.localTargetRotation.y = player_direction;
103:                     camera.targetRotation.y = player_direction;
104:                     ff7::world::camera.requestResetCameraRotation(false);
105:                 }
106:                 else
107:                 {
108:                     camera.targetRotation.x = camera.localTargetRotation.x;
109:                     camera.targetRotation.y = camera.localTargetRotation.y;
110:                 }
111:             }
112: 
113:             *ff7_externals.world_camera_front_DFC484 = camera.targetRotation.y * 4096 / 360.0f;
114:         }
115:     }
116: 
117:     void update_world_camera_rotation_y()
118:     {
119:         int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
120:         int world_map_type = *ff7_externals.world_map_type_E045E8;
121:         int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;
122:         if (world_map_type != SNOWSTORM)
123:         {
124:             float targetRotationY = *ff7_externals.world_camera_front_DFC484 * 360.0f / 4096.0f;
125: 
126:             int world_map_type = *ff7_externals.world_map_type_E045E8;
127: 
128:             float diff = targetRotationY - camera.rotationOffset.y;
129:             if (diff > 180)
130:                 camera.rotationOffset.y += 360;
131:             else if (diff < - 180)  camera.rotationOffset.y -= 360;
132: 
133:             const float t = 0.05f * movement_multiplier;
134:             camera.rotationOffset.y = (1.0f - t) * camera.rotationOffset.y + t * targetRotationY;
135: 
136:             *ff7_externals.world_camera_rotation_y_DFC474 = camera.rotationOffset.y * 4096.0f / 360.0f;
137:         }
138:         else
139:         {
140:             int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;
141:             int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
142: 
143:             if (camera_view_type != HIGHWIND_VIEW)
144:                 *ff7_externals.world_camera_var2_DE6B4C = (*ff7_externals.world_camera_var1_DF542C + 3 * (*ff7_externals.world_camera_var2_DE6B4C)) >> 2;
145: 
146:             if (*ff7_externals.world_camera_rotation_y_DFC474 >= *ff7_externals.world_camera_front_DFC484 - 2048)
147:             {
148:                 if (*ff7_externals.world_camera_rotation_y_DFC474 > *ff7_externals.world_camera_front_DFC484 + 2048)
149:                     *ff7_externals.world_camera_rotation_y_DFC474 -= 4096;
150:             }
151:             else
152:                 *ff7_externals.world_camera_rotation_y_DFC474 += 4096;
153: 
154:             if (movement_multiplier == 1)
155:                 *ff7_externals.world_camera_rotation_y_DFC474 = (*ff7_externals.world_camera_front_DFC484 + 31 * (*ff7_externals.world_camera_rotation_y_DFC474)) >> 5;
156:             else
157:                 *ff7_externals.world_camera_rotation_y_DFC474 = (*ff7_externals.world_camera_front_DFC484 + 15 * (*ff7_externals.world_camera_rotation_y_DFC474)) >> 4;
158:         }
159:     }
160: 
161:     void update_world_camera(short world_camera_rotation_y)
162:     {
163:         int world_map_type = *ff7_externals.world_map_type_E045E8;
164:         int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
165:         float targetRotationX = -ff7_externals.world_get_camera_rotation_x_74F916() * 360.0f / 4096.0f;
166:         //ff7_externals.world_get_camera_rotation_x_74F916();
167: 
168:         static float zoomTarget = 10000.0f;
169:         static int cameraStatusCounter = 0;
170:         float maxZoomDist = camera.getMaxZoomDist();
171: 
172:         if(world_map_type != SNOWSTORM && ff7_externals.world_get_unknown_flag_75335C())
173:         {
174:             targetRotationX = camera.targetRotation.x;
175:             zoomTarget = std::min(maxZoomDist, std::max(camera.minZoomDist, zoomTarget - camera.getZoomSpeed()));
176:             cameraStatusCounter = 0;
177:         } else
178:         {
179:             if (cameraStatusCounter > 0) zoomTarget = 10000.0f;
180:             cameraStatusCounter++;
181:         }
182: 
183:         const float t = 0.05f * movement_multiplier;
184:         camera.rotationOffset.x = (1.0f - t) * camera.rotationOffset.x + t * targetRotationX;
185: 
186:         bx::Vec3 up = { 0, 1, 0 };
187:         bx::Vec3 right = { 1, 0, 0 };
188: 
189:         float rotationY = 360.0f * static_cast<float>(*ff7_externals.world_camera_rotation_y_DFC474) / 4096.0f;
190:         auto quaternionH = bx::fromAxisAngle(up, M_PI * rotationY / 180.0f);
191:         auto quaternionV = bx::fromAxisAngle(right, M_PI * camera.rotationOffset.x / 180.0f);
192: 
193:         *ff7_externals.world_current_camera_rotation_x_DE7418 = 4096 + static_cast<short>(4096.0f * camera.rotationOffset.x / 360.0f);
194: 
195:         auto quaternion = bx::mul(quaternionV, quaternionH);
196:         quaternion = bx::normalize(quaternion);
197: 
198:         float rotMat[16];
199:         bx::mtxFromQuaternion(rotMat, quaternion);
200: 
201: 
202:         camera.zoomOffset = (1.0f - t) * camera.zoomOffset + t * zoomTarget;
203: 
204:         camera.zoomOffset = std::min(maxZoomDist, std::max(camera.minZoomDist, camera.zoomOffset));
205: 
206:         if (world_map_type == SNOWSTORM) camera.zoomOffset = 10000.0;
207: 
208:         auto rot_matrix = ff7_externals.world_camera_direction_matrix_DFC448;
209:         rot_matrix->r3_sub_matrix[0][0] = rotMat[0] * 4096;
210:         rot_matrix->r3_sub_matrix[0][1] = rotMat[1] * 4096;
211:         rot_matrix->r3_sub_matrix[0][2] = rotMat[2] * 4096;
212: 
213:         rot_matrix->r3_sub_matrix[1][0] = rotMat[4] * 4096;
214:         rot_matrix->r3_sub_matrix[1][1] = rotMat[5] * 4096;
215:         rot_matrix->r3_sub_matrix[1][2] = rotMat[6] * 4096;
216: 
217:         rot_matrix->r3_sub_matrix[2][0] = rotMat[8] * 4096;
218:         rot_matrix->r3_sub_matrix[2][1] = rotMat[9] * 4096;
219:         rot_matrix->r3_sub_matrix[2][2] = rotMat[10] * 4096;
220: 
221:         auto translation_matrix = ff7_externals.world_camera_position_matrix_DE6A20;
222:         translation_matrix->position[0] = 0;
223:         translation_matrix->position[1] = 0;
224:         translation_matrix->position[2] = camera.zoomOffset;
225: 
226:         *ff7_externals.world_camera_delta_y_DE6A04 = ff7_externals.world_player_pos_E04918->y + 500;
227:     }
228: 
229:     void WorldCamera::setRotationSpeed(float rotX, float rotY, float rotZ)
230:     {
231:         rotationSpeed.x = 0.5f * rotX / common_frame_multiplier;
232:         rotationSpeed.y = 0.5f * rotY / common_frame_multiplier;
233:         rotationSpeed.z = 0.5f * rotZ / common_frame_multiplier;
234:     }
235: 
236:     void WorldCamera::setZoomSpeed(float speed)
237:     {
238:         zoomSpeed = 0.5f * speed / common_frame_multiplier;
239:     }
240: 
241:     void WorldCamera::reset()
242:     {
243:         targetRotation.x = 0.0f;
244:         targetRotation.y = 0.0f;
245:         zoomOffset = 0.0f;
246:     }
247: 
248:     float WorldCamera::getMaxZoomDist()
249:     {
250:         const int player_model_id = ff7_externals.world_get_player_model_id();
251:         switch(player_model_id)
252:         {
253:             case SUBMARINE:
254:                 return 5000;
255:             default:
256:                 return 35000;
257:         }
258:     }
259: }
</file>

<file path="src/ff7/world/camera.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2022 Cosmos                                             //
 10: //    Copyright (C) 2022 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: #pragma once
 24: 
 25: #include "matrix.h"
 26: 
 27: #include <bx/math.h>
 28: #include <bx/bx.h>
 29: 
 30: namespace ff7::world
 31: {
 32:     enum world_camera_viewtype
 33:     {
 34:         TOP_DOWN_VIEW = 0,
 35:         FRONT_VIEW = 2,
 36:         HIGHWIND_VIEW = 3
 37:     };
 38: 
 39:     void update_world_camera_front(int current_key_input, int prev_key_input);
 40:     void update_world_camera_rotation_y();
 41: 
 42:     class WorldCamera
 43:     {
 44:         public:
 45:             WorldCamera() = default;
 46:             ~WorldCamera() = default;
 47: 
 48:             void setRotationSpeed(float rotX, float rotY, float rotZ);
 49:             vector3<float> getRotationSpeed();
 50:             void setZoomSpeed(float speed);
 51:             float getZoomSpeed();
 52:             float getMaxZoomDist();
 53:             void reset();
 54:             float getRotationOffsetX();
 55:             float getRotationOffsetY();
 56:             void requestResetCameraRotation(bool value);
 57:             bool isResetCameraRotationRequested();
 58:         public:
 59:             vector3<float> targetRotation = { -135.0f, 0.0, 0.0 };
 60:             vector3<float> localTargetRotation = { -135.0f, 0.0, 0.0 };
 61:             vector3<float> rotationOffset = { -135.0f, 0.0, 0.0 };
 62:             float zoomOffset = 10000.0f;
 63:             const float minZoomDist = 2000.0f;
 64:         private:
 65:             vector3<float> rotationSpeed = { 0.0, 0.0, 0.0 };
 66:             float zoomSpeed = 0.0f;
 67: 
 68:             const float minVerticalAngle = 5.0f;
 69:             const float maxVerticalAngle = 85.0f;
 70: 
 71:             bool isResetCameraRotation = false;
 72:     };
 73: 
 74:     inline vector3<float> WorldCamera::getRotationSpeed()
 75:     {
 76:         return rotationSpeed;
 77:     }
 78: 
 79:     inline float WorldCamera::getZoomSpeed()
 80:     {
 81:         return zoomSpeed;
 82:     }
 83: 
 84:     inline float  WorldCamera::getRotationOffsetX()
 85:     {
 86:         return rotationOffset.x;
 87:     }
 88: 
 89:     inline float  WorldCamera::getRotationOffsetY()
 90:     {
 91:         return rotationOffset.y;
 92:     }
 93: 
 94:     inline void WorldCamera::requestResetCameraRotation(bool value)
 95:     {
 96:         isResetCameraRotation = value;
 97:     }
 98: 
 99:     inline bool WorldCamera::isResetCameraRotationRequested()
100:     {
101:         return isResetCameraRotation;
102:     }
103: 
104:     extern WorldCamera camera;
105: }
</file>

<file path="src/ff7/world/defs.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: namespace ff7::world
27: {
28:     void world_hook_init();
29:     void world_update_model_movement(int delta_position_x, int delta_position_z);
30: 
31:     void update_world_camera(short world_camera_rotation_y);
32:     void update_player_and_handle_input();
33: }
</file>

<file path="src/ff7/world/player.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2022 Cosmos                                             //
 10: //    Copyright (C) 2022 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "globals.h"
 25: #include "world.h"
 26: #include "camera.h"
 27: #include "cfg.h"
 28: #include "utils.h"
 29: 
 30: #include <math.h>
 31: #include "ff7/world/defs.h"
 32: 
 33: namespace ff7::world {
 34: 
 35:     int get_player_movement_speed(int model_id)
 36:     {
 37:         int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
 38:         switch(model_id)
 39:         {
 40:             case HIGHWIND: // Highwind
 41:                 return 120 * movement_multiplier;
 42:             case SUBMARINE:
 43:                 return 45 * movement_multiplier;
 44:             case WILD_CHOCOBO:
 45:             case TINY_BRONCO:
 46:             case CHOCOBO:
 47:             case 41:
 48:             case 42:
 49:                 // Chocobos and Tiny Bronco
 50:                 return 60 * movement_multiplier;
 51:             case BUGGY: // Buggy
 52:                 return 45 * movement_multiplier;
 53:             default:
 54:                 return 30 * movement_multiplier;
 55:         }
 56:     }
 57: 
 58:     short get_player_direction_on_key_input(int current_key_status)
 59:     {
 60:         short direction = INVALID_DIRECTION;
 61: 
 62:         auto joyDir = ff7::world::world.GetJoystickDirection();
 63:         float inputDirLength = vector_length(&joyDir);
 64: 	    if(inputDirLength > 0.0f)
 65:         {
 66:             float angle = atan2( joyDir.x, - joyDir.y);
 67:             if (angle < 0) { angle += 2 * M_PI; }
 68:             direction = static_cast<short>(std::max(0.0, std::min(4096.0, 4096.0 * angle / (2.0* M_PI))));
 69:         }
 70:         else
 71:         {
 72:             if(is_key_pressed(current_key_status, LEFT))
 73:                 direction = -1024;
 74:             if(is_key_pressed(current_key_status, RIGHT))
 75:                 direction = 1024;
 76:             if(is_key_pressed(current_key_status, UP))
 77:             {
 78:                 if(direction == INVALID_DIRECTION)
 79:                     direction = 2048;
 80:                 else
 81:                     direction += direction / 2;
 82:             }
 83:             if(is_key_pressed(current_key_status, DOWN))
 84:             {
 85:                 if(direction == INVALID_DIRECTION)
 86:                     direction = 0;
 87:                 else
 88:                     direction -= direction / 2;
 89:             }
 90:         }
 91: 
 92:         return direction;
 93:     }
 94: 
 95:     void update_player_and_handle_input()
 96:     {
 97:         static float rotationSpeedInterp = 0.0f;
 98: 
 99:         const int worldmap_type = *ff7_externals.world_map_type_E045E8;
100:         const int movement_multiplier = *ff7_externals.world_movement_multiplier_DFC480;
101: 
102:         vector3<int> delta_movement = {0, 0, 0};
103:         ff7_externals.world_set_current_entity_to_player_entity();
104:         const int player_model_id = ff7_externals.world_get_player_model_id();
105: 
106:         if(*ff7_externals.world_is_control_enabled_DE6B5C && ff7_externals.world_get_unknown_flag_75335C())
107:         {
108:             int current_key_input = ff7_externals.world_get_current_key_input_status();
109:             int prev_key_input = *ff7_externals.world_prev_key_input_status_DFC470;
110: 
111:             // Limit key input
112:             if(player_model_id == TINY_BRONCO && is_key_pressed(current_key_input, CROSS))
113:                 current_key_input &= SELECT | UNK1 | UNK2;
114: 
115:             int movement_speed = get_player_movement_speed(player_model_id);
116:             short player_direction = get_player_direction_on_key_input(current_key_input);
117:             if(player_direction != INVALID_DIRECTION)
118:             {
119:                 delta_movement.x = cos((player_direction / 2048.f) * M_PI - M_PI / 2) * movement_speed;
120:                 delta_movement.z = -sin((player_direction / 2048.f) * M_PI - M_PI / 2) * movement_speed;
121:             }
122: 
123:             int camera_view_type = *ff7_externals.world_camera_viewtype_DFC4B4;
124:             if(enable_analogue_controls || camera_view_type == FRONT_VIEW || camera_view_type == HIGHWIND_VIEW || worldmap_type == SNOWSTORM)
125:             {
126:                 update_world_camera_front(current_key_input, prev_key_input);
127: 
128:                 auto joyDir = ff7::world::world.GetJoystickDirection();
129: 
130:                 static float deltaMovement = 0.0f;
131:                 static int horizontalDeltaInterp = 0;
132: 
133:                 bool highwind_view_and_square_pressed = camera_view_type == HIGHWIND_VIEW && is_key_pressed(current_key_input, SQUARE | L1);
134: 
135:                 int horizontal_delta = 0;
136:                 if(!highwind_view_and_square_pressed)
137:                 {
138:                 if(std::abs(joyDir.x) > 0.0f)
139:                     horizontal_delta = -2048 * joyDir.x;
140:                 else if(is_key_pressed(current_key_input, LEFT))
141:                     horizontal_delta = 2048;
142:                 else if(is_key_pressed(current_key_input, RIGHT))
143:                     horizontal_delta = -2048;
144:                 }
145: 
146:                 horizontalDeltaInterp = (15 * horizontalDeltaInterp + horizontal_delta) / 16;
147:                 if(camera_view_type == HIGHWIND_VIEW || worldmap_type == UNDERWATER || player_model_id == TINY_BRONCO || player_model_id == BUGGY || player_model_id == SUBMARINE)
148:                 {
149:                     bool is_movement_key_pressed = is_key_pressed(current_key_input, highwind_view_and_square_pressed ? ANY_DIRECTIONAL_KEY: CIRCLE | R1);
150:                     bool is_back_movement_key_pressed = is_key_pressed(current_key_input, SQUARE | L1);
151: 
152:                     if(is_back_movement_key_pressed && (player_model_id == BUGGY || player_model_id == SUBMARINE))
153:                     {
154:                         if(!is_movement_key_pressed)
155:                         {
156:                             movement_speed = -movement_speed * 0.75f;
157:                         } else movement_speed = 0;
158: 
159:                         is_movement_key_pressed = true;
160:                     }
161: 
162:                     if (!is_movement_key_pressed || highwind_view_and_square_pressed) movement_speed = 0;
163: 
164:                     deltaMovement = (deltaMovement * 31.0f + movement_speed) / 32.0f;
165: 
166:                     if(!is_movement_key_pressed && std::abs(deltaMovement) < 10.0f) deltaMovement = 0.0f;
167:                     *ff7_externals.world_special_delta_movement_DE6A18 = deltaMovement;
168: 
169:                     short last_valid_player_direction = (*ff7_externals.world_event_current_entity_ptr_E39AD8)->direction;
170:                     if(highwind_view_and_square_pressed && std::abs(deltaMovement) < 10)
171:                     {
172:                         auto hightwindSpeed = get_player_movement_speed(player_model_id);
173:                         if(std::abs(joyDir.x) > 0.0f)
174:                             delta_movement.x = joyDir.x * hightwindSpeed;
175:                         else if(is_key_pressed(current_key_input, LEFT))
176:                             delta_movement.x = -hightwindSpeed;
177:                         else if(is_key_pressed(current_key_input, RIGHT))
178:                             delta_movement.x = hightwindSpeed;
179: 
180:                         if(std::abs(joyDir.y) > 0.0f)
181:                             delta_movement.z = -joyDir.y * hightwindSpeed;
182:                         else if(is_key_pressed(current_key_input, UP))
183:                             delta_movement.z = -hightwindSpeed;
184:                         else if(is_key_pressed(current_key_input, DOWN))
185:                             delta_movement.z = hightwindSpeed;
186: 
187:                         delta_movement.x *= 0.25f;
188:                         delta_movement.z *= 0.25f;
189:                     }
190:                     else
191:                     {
192:                         const float rotSpeedXMax = worldmap_type == UNDERWATER || player_model_id == SUBMARINE ? 24.0f : player_model_id == BUGGY ? 64.0f : 32.0f;
193:                         float rotSpeedX = 0.0f;
194:                         if (std::abs(joyDir.x) > 0.0)
195:                             rotSpeedX = rotSpeedXMax * joyDir.x / common_frame_multiplier;
196:                         else if(is_key_pressed(current_key_input, LEFT))
197:                             rotSpeedX = -rotSpeedXMax / common_frame_multiplier;
198:                         else if(is_key_pressed(current_key_input, RIGHT))
199:                             rotSpeedX = rotSpeedXMax / common_frame_multiplier;
200: 
201:                         if ( player_model_id == BUGGY )
202:                         {
203:                             rotationSpeedInterp = rotSpeedX;
204:                         }
205:                         else
206:                         {
207:                             rotationSpeedInterp = (rotationSpeedInterp * 15 + rotSpeedX) / 16.0f;
208:                         }
209:                         short delta = -static_cast<short>(rotationSpeedInterp);
210: 
211:                         if (player_model_id == BUGGY )
212:                         {
213:                             auto maxSpeed = static_cast<float>(get_player_movement_speed(player_model_id));
214:                             if (is_back_movement_key_pressed) maxSpeed *= 0.5f;
215:                             delta *= std::abs(deltaMovement) / maxSpeed;
216:                         }
217: 
218:                         last_valid_player_direction += delta;
219: 
220: 
221:                         if(last_valid_player_direction > 2048)
222:                             last_valid_player_direction -= 4096;
223:                         if(last_valid_player_direction < -2048)
224:                             last_valid_player_direction += 4096;
225: 
226:                         player_direction = last_valid_player_direction + *ff7_externals.world_camera_front_DFC484 - 4096;
227: 
228:                         delta_movement.x = cos((player_direction / 2048.f) * M_PI - M_PI / 2) * (deltaMovement);
229:                         delta_movement.z = -sin((player_direction / 2048.f) * M_PI - M_PI / 2) * (deltaMovement);
230:                     }
231:                 }
232:                 else if(player_direction != INVALID_DIRECTION)
233:                     ff7_externals.world_set_facing_and_direction_to_current_entity(player_direction - *ff7_externals.world_camera_front_DFC484);
234: 
235:                 // Deflect delta movement with camera front direction
236:                 vector3<short> copy_delta_movement = {(short)delta_movement.x, 0, (short)delta_movement.z};
237:                 vector3<short> rotation = {0, (short)-*ff7_externals.world_camera_front_DFC484, 0};
238:                 vector3<int> output_delta = {0, 0, 0};
239:                 int dummy;
240:                 rotation_matrix matrix;
241:                 ff7_externals.engine_apply_rotation_to_transform_matrix_6628DE(&rotation, &matrix);
242:                 matrix.position[0] = 0;
243:                 matrix.position[1] = 0;
244:                 matrix.position[2] = 0;
245:                 ff7_externals.engine_set_game_engine_rot_matrix_663673(&matrix);
246:                 ff7_externals.engine_set_game_engine_position_663707(&matrix);
247:                 ff7_externals.engine_apply_translation_with_delta_662ECC(&copy_delta_movement, &output_delta, &dummy);
248:                 delta_movement.x = output_delta.x;
249:                 delta_movement.z = output_delta.z;
250: 
251:                 static float verticalDeltaInterp = 0.0;
252:                 int vertical_delta = 0;
253:                 static float verticalSpeedinterp = 0.0;
254:                 float verticalSpeed = 0.0;
255:                 if(camera_view_type == HIGHWIND_VIEW && !highwind_view_and_square_pressed)
256:                 {
257:                     vector4<int> player_highwind_position;
258:                     ff7_externals.world_copy_player_pos_to_param_762798(&player_highwind_position);
259: 
260:                     auto joyDir = ff7::world::world.GetJoystickDirection();
261:                     if((joyDir.y > 0 || is_key_pressed(current_key_input, UP)) && player_highwind_position.y > 500 && *ff7_externals.world_y_player_pos_flag_DE6A14 &&
262:                        ff7_externals.world_get_player_walkmap_type() != 27)
263:                     {
264:                         if(joyDir.y > 0)
265:                         {
266:                             verticalSpeed = -joyDir.y * 50 * movement_multiplier;
267:                             vertical_delta = joyDir.y * 10.0;
268:                         }
269:                         else
270:                         {
271:                             verticalSpeed = -50 * movement_multiplier;
272:                             vertical_delta = 10;
273:                         }
274:                     }
275:                     else if((joyDir.y < 0 || is_key_pressed(current_key_input, DOWN)) && player_highwind_position.y < UINT16_MAX / 2 - 50 * movement_multiplier - 2000)
276:                     {
277:                         if (joyDir.y < 0)
278:                         {
279:                             verticalSpeed =-joyDir.y * 50 * movement_multiplier;
280:                             vertical_delta = joyDir.y * 10.0;
281:                         }
282:                         else
283:                         {
284:                             verticalSpeed = 50 * movement_multiplier;
285:                             vertical_delta = -10;
286:                         }
287:                     }
288:                     verticalSpeedinterp = (verticalSpeedinterp * 7.0f + verticalSpeed) / 8.0f;
289:                     ff7_externals.world_add_y_pos_to_current_entity_761F22(verticalSpeedinterp);
290:                 }
291: 
292:                 if(worldmap_type == UNDERWATER)
293:                 {
294:                     vector4<int> player_submarine_position;
295:                     ff7_externals.world_copy_player_pos_to_param_762798(&player_submarine_position);
296: 
297:                     if((joyDir.y > 0 || is_key_pressed(current_key_input, UP)) && player_submarine_position.y > -5000 && *ff7_externals.world_y_player_pos_flag_DE6A14)
298:                     {
299:                         if (joyDir.y > 0)
300:                         {
301:                             verticalSpeed = -joyDir.y * 15 * movement_multiplier;
302:                             vertical_delta = joyDir.y * 10.0;
303:                         }
304:                         else
305:                         {
306:                             verticalSpeed = -15 * movement_multiplier;
307:                             vertical_delta = 10;
308:                         }
309:                     }
310: 
311:                     if((joyDir.y < 0 || is_key_pressed(current_key_input, DOWN)) && player_submarine_position.y <-1000)
312:                     {
313:                         if (joyDir.y > 0)
314:                         {
315:                             verticalSpeed = -joyDir.y * 15 * movement_multiplier;
316:                             vertical_delta = joyDir.y * 10.0;
317:                         }
318:                         else
319:                         {
320:                             verticalSpeed = 15 * movement_multiplier;
321:                             vertical_delta = -10;
322:                         }
323:                     }
324: 
325:                     verticalSpeedinterp = (verticalSpeedinterp * 7.0f + verticalSpeed) / 8.0f;
326:                     ff7_externals.world_add_y_pos_to_current_entity_761F22(verticalSpeedinterp);
327:                 }
328: 
329:                 verticalDeltaInterp = (verticalDeltaInterp * 15.0f + vertical_delta) / 16.0f;
330: 
331:                 if(camera_view_type == HIGHWIND_VIEW)
332:                 {
333:                     int is_player_moving = ff7_externals.world_is_current_entity_animated_761F44() &&
334:                                            abs(*ff7_externals.world_camera_rotation_z_DE6B70) >= 16 || horizontalDeltaInterp;
335:                     delta_movement.y = ((movement_multiplier == 1) | (2 * is_player_moving)) + 3;
336:                     *ff7_externals.world_camera_rotation_z_DE6B70 = ((1 << (delta_movement.y - 1)) + horizontalDeltaInterp
337:                                                                     + *ff7_externals.world_camera_rotation_z_DE6B70 * (1 << delta_movement.y - 1)) >> delta_movement.y;
338:                     *ff7_externals.world_unk_rotation_value_E045E0 = (verticalDeltaInterp);
339:                     ff7_externals.world_sub_762F75(*ff7_externals.world_unk_rotation_value_E045E0 + 4, *ff7_externals.world_camera_rotation_z_DE6B70 * 4, *ff7_externals.world_camera_rotation_z_DE6B70 * -2);
340:                 }
341: 
342:                 // Reset world camera rotation Z
343:                 if(!horizontalDeltaInterp && abs(*ff7_externals.world_camera_rotation_z_DE6B70) <= 4)
344:                     *ff7_externals.world_camera_rotation_z_DE6B70 = 0;
345: 
346:                 if(worldmap_type != SNOWSTORM)
347:                 {
348:                     if(player_direction == INVALID_DIRECTION)
349:                         player_direction = *ff7_externals.previous_player_direction_DF5434;
350: 
351:                     if(player_direction != INVALID_DIRECTION)
352:                         *ff7_externals.previous_player_direction_DF5434 = player_direction;
353: 
354:                     player_direction += 2048;
355:                     if(player_direction > 2048)
356:                         player_direction -= 4096;
357: 
358:                     if(camera_view_type != HIGHWIND_VIEW && worldmap_type != UNDERWATER && player_model_id != SUBMARINE && player_model_id != TINY_BRONCO)
359:                     {
360:                         if(delta_movement.x != 0 || delta_movement.z != 0.0f)
361:                         {
362:                             int current_direction = player_direction;
363:                             ff7_externals.world_set_facing_and_direction_to_current_entity(current_direction + 2048 - *ff7_externals.world_camera_front_DFC484);
364:                         }
365:                     }
366:                     else
367:                     {
368:                         if(!highwind_view_and_square_pressed)
369:                         {
370:                             int current_direction = player_direction;
371:                             ff7_externals.world_set_facing_and_direction_to_current_entity(current_direction + 2048 - *ff7_externals.world_camera_front_DFC484);
372:                         }
373:                     }
374:                 }
375:             }
376:             else
377:             {
378:                 *ff7_externals.world_camera_rotation_z_DE6B70 /= 2;
379:                 if(player_direction != INVALID_DIRECTION)
380:                     ff7_externals.world_set_facing_and_direction_to_current_entity(player_direction);
381:             }
382: 
383:             if(player_model_id == BUGGY) {
384:                 if(is_key_pressed_first_time(current_key_input, prev_key_input, ANY_DIRECTIONAL_KEY))
385:                     ff7_externals.world_music_set_frequency_all_channels_75E6A8(8u, 32);
386: 
387:                 if(is_key_released(current_key_input, prev_key_input, ANY_DIRECTIONAL_KEY))
388:                     ff7_externals.world_music_set_frequency_all_channels_75E6A8(8u, 0);
389:             }
390: 
391:             if(player_model_id == SUBMARINE && is_key_pressed_first_time(current_key_input, prev_key_input, CROSS))
392:             {
393:                 if(worldmap_type == UNDERWATER && ff7_externals.world_get_player_walkmap_type() == 3)
394:                     ff7_externals.world_sub_74D6BB();
395:                 else if(ff7_externals.world_get_player_walkmap_type() == 3)
396:                     ff7_externals.world_sub_74D6F6();
397:             }
398: 
399:             if(is_key_pressed_first_time(current_key_input, prev_key_input, START) ||
400:                is_key_pressed_first_time(current_key_input, prev_key_input, SELECT))
401:             {
402:                 if(*ff7_externals.world_map_type_E045E8 == OVERWORLD)
403:                     ff7_externals.world_set_minimap_mask((ff7_externals.world_get_minimap_mask() + 1) % 3);
404:                 else
405:                     ff7_externals.world_set_minimap_mask(ff7_externals.world_get_minimap_mask() == 0 ? 2 : 0);
406:             }
407: 
408:             if(is_key_pressed_first_time(current_key_input, prev_key_input, TRIANGLE) && *ff7_externals.world_mode_E045E4 == 1)
409:             {
410:                 if(player_model_id == HIGHWIND)
411:                     ff7_externals.world_run_special_opcode_7640BC(6);
412:                 else if((player_model_id ==  CLOUD || player_model_id ==  TIFA || player_model_id ==  CID || player_model_id == BUGGY) && ff7_externals.world_get_player_walkmap_type() != 14)
413:                 {
414:                     ff7_externals.world_set_camera_fade_speed_755B97(16);
415:                     ff7_externals.world_set_world_control_lock_74D438(0, 1);
416:                     *ff7_externals.world_mode_E045E4 = 2;
417:                     ff7_externals.world_sub_74C980(0);
418:                 }
419:             }
420: 
421:             *ff7_externals.world_prev_key_input_status_DFC470 = current_key_input;
422:             if(ff7_externals.world_get_player_walkmap_type() == 14)
423:                 ff7_externals.world_add_delta_movement_due_to_bridge_7591C2(&delta_movement.x, &delta_movement.z);
424:             if(player_model_id == TINY_BRONCO)
425:                 ff7_externals.world_sfx_play_or_stop_75E6CC((delta_movement.z | delta_movement.x) != 0 ? 493 : -493);
426: 
427:             if(ff7_footsteps)
428:                 world_update_model_movement(delta_movement.x, delta_movement.z);
429:             else
430:                 ff7_externals.world_update_model_movement_762E87(delta_movement.x, delta_movement.z);
431:             ff7_externals.world_current_entity_model_collision_detection_with_other_models_76296E();
432:         }
433: 
434:         if(!ff7_externals.world_is_control_enabled_DE6B5C && ff7_externals.world_get_player_walkmap_type() == 14)
435:         {
436:             ff7_externals.world_add_delta_movement_due_to_bridge_7591C2(&delta_movement.x, &delta_movement.z);
437:             world_update_model_movement(delta_movement.x, delta_movement.z);
438:             ff7_externals.world_current_entity_model_collision_detection_with_other_models_76296E();
439:         }
440: 
441:         update_world_camera_rotation_y();
442:     }
443: 
444: }
</file>

<file path="src/ff7/world/renderer.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "ff7/world/renderer.h"
 25: #include "camera.h"
 26: #include "cfg.h"
 27: #include "gl.h"
 28: #include "globals.h"
 29: 
 30: #include "../defs.h"
 31: #include "../../lighting.h"
 32: 
 33: namespace ff7::world {
 34: 
 35:     void init_load_wm_bot_blocks() {
 36:         ff7_externals.world_init_load_wm_bot_block_7533AF();
 37: 
 38:         worldRenderer.loadWorldMapExternalMesh();
 39:         worldRenderer.loadCloudsExternalMesh();
 40:         worldRenderer.loadMeteorExternalMesh();
 41:     }
 42: 
 43:     void destroy_graphics_objects() {
 44:         ff7_externals.world_exit_destroy_graphics_objects_75A921();
 45:         worldRenderer.unloadExternalMeshes();
 46:     }
 47: 
 48:     void wm0_overworld_draw_all() {
 49:        auto game_object = (struct ff7_game_obj *)common_externals.get_game_object();
 50:         if (game_object) update_view_matrix (game_object);
 51:         worldRenderer.drawWorldMapExternalMesh();
 52:         ff7_externals.world_wm0_overworld_draw_all_74C179();
 53:     }
 54: 
 55:     void wm0_overworld_draw_clouds()
 56:     {
 57:         worldRenderer.drawCloudsAndMeteorExternalMesh(*ff7_externals.is_meteor_flag_on_E2AAE4);
 58:     }
 59: 
 60:     void wm0_overworld_draw_meteor()
 61:     {
 62:     }
 63: 
 64:     void wm2_underwater_draw_all() {
 65:         auto game_object = (struct ff7_game_obj *)common_externals.get_game_object();
 66:         if (game_object) update_view_matrix (game_object);
 67:         		const int worldmap_type = *ff7_externals.world_map_type_E045E8;
 68: 		newRenderer.setFogEnabled(true);
 69:         worldRenderer.drawWorldMapExternalMesh();
 70:         ff7_externals.world_wm2_underwater_draw_all_74C3F0();
 71:         newRenderer.setFogEnabled(false);
 72:     }
 73: 
 74:     void wm3_snowstorm_draw_all() {
 75:         auto game_object = (struct ff7_game_obj *)common_externals.get_game_object();
 76:         if (game_object) update_view_matrix (game_object);
 77:         worldRenderer.drawWorldMapExternalMesh();
 78:         ff7_externals.world_wm3_snowstorm_draw_all_74C589();
 79:     }
 80: 
 81:     // This draw call is the first UI call that marks the start of the first UI draw section
 82:     void wm0_draw_minimap_quad_graphics_object(ff7_graphics_object* quad_graphics_object, ff7_game_obj* game_object) {
 83:         newRenderer.setTimeFilterEnabled(false);
 84:         ff7_externals.engine_draw_graphics_object(quad_graphics_object, game_object);
 85:     }
 86: 
 87:     // This draw call is the first call related to world effects. It marks the end of the first UI draw section
 88:     void wm0_draw_world_effects_1_graphics_object(ff7_graphics_object* world_effects_1_graphics_object, ff7_game_obj* game_object) {
 89:         newRenderer.setTimeFilterEnabled(true);
 90:         ff7_externals.engine_draw_graphics_object(world_effects_1_graphics_object, game_object);
 91:     }
 92: 
 93:     // This draw call is the UI call that marks the second UI draw section
 94:     void wm0_draw_minimap_points_graphics_object(ff7_graphics_object* minimap_points_graphics_object, ff7_game_obj* game_object) {
 95:         newRenderer.setTimeFilterEnabled(false);
 96:         ff7_externals.engine_draw_graphics_object(minimap_points_graphics_object, game_object);
 97:     }
 98: 
 99: 
100:     int get_camera_rotation_z()
101:     {
102:         return 0;
103:     }
104: 
105:     void world_copy_position(vector4<int> *a1)
106:     {
107:         if ( a1 )
108:             *a1 = *ff7_externals.world_player_pos_E04918;
109:     }
110: 
111:     vector3<float> calcSphericalWorldPos(vector3<float> worldPos)
112:     {
113:         struct matrix viewMatrix;
114:         ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
115: 
116:         vector3<float> viewPos = {0.0f, 0.0f, 0.0f};
117:         transform_point(&viewMatrix, &worldPos, &viewPos);
118: 
119:         struct matrix invViewMatrix;
120:         ::memcpy(&invViewMatrix.m[0][0], newRenderer.getInvViewMatrix(), sizeof(invViewMatrix.m));
121: 
122:         float rp = -250000;
123: 
124:         vector2<float> planedir = { viewPos.x, viewPos.z};
125:         float planeDirLength = sqrtf(planedir.x * planedir.x + planedir.y * planedir.y);
126:         planedir.x /= planeDirLength;
127:         planedir.y /= planeDirLength;
128: 
129:         vector2<float> plane = {viewPos.y, sqrtf((viewPos.x) * (viewPos.x) + (viewPos.z) * (viewPos.z))};
130:         vector2<float> planeScaled = {plane.x / rp, plane.y / rp};
131:         vector2<float> planeScaledExp = {exp(planeScaled.x) * cos(planeScaled.y), exp(planeScaled.x) * sin(planeScaled.y)};
132:         vector2<float> circle = { rp * planeScaledExp.x - rp, rp * planeScaledExp.y};
133: 
134:         vector3<float> newViewPos = {circle.y * planedir.x, circle.x, circle.y * planedir.y};
135: 
136:         vector3<float> newWorldPos = {0.0f, 0.0f, 0.0f};
137:         transform_point(&invViewMatrix, &newViewPos, &newWorldPos);
138: 
139:         return newWorldPos;
140:     }
141: 
142:     void world_draw_effects()
143:     {
144:         short v0;
145:         transform_matrix rot_matrix_0;
146:         transform_matrix rot_matrix_1;
147:         int v3;
148:         transform_matrix rot_matrix_2;
149:         int v5;
150:         int v6;
151:         vector3<short> delta_point;
152:         vector4<short> camera_direction;
153:         vector4<int> a1;
154: 
155:         camera_direction.x = 0;
156:         camera_direction.y = -(short)ff7_externals.get_world_camera_front_rot_74D298();
157:         camera_direction.z = 0;
158:         ff7_externals.engine_apply_rotation_to_rot_matrix_662AD8((vector3<short>*)&camera_direction, &rot_matrix_1);
159:         camera_direction.x = -ff7_externals.world_get_world_current_camera_rotation_x_74D3C6();
160:         ff7_externals.engine_apply_rotation_to_rot_matrix_662AD8((vector3<short>*)&camera_direction, &rot_matrix_2);
161:         ff7_externals.world_copy_position_75042B(&a1);
162: 
163:         world_effect_2d_list_node* eff_node = *ff7_externals.dword_E35648;
164:         world_effect_2d_list_node* next_node = nullptr;
165:         while (eff_node)
166:         {
167:             vector3<float> worldPos = {static_cast<float>(eff_node->x), static_cast<float>(eff_node->y), static_cast<float>(eff_node->z)};
168:             vector3<float> newWorldPos = calcSphericalWorldPos(worldPos);
169: 
170:             vector3<float> refPos = {static_cast<float>(a1.x), static_cast<float>(*ff7_externals.world_camera_delta_y_DE6A04), static_cast<float>(a1.z)};
171: 
172:             v6 = newWorldPos.x - refPos.x;
173:             v5 = newWorldPos.y - refPos.y;
174:             v3 = newWorldPos.z - refPos.z;
175: 
176:             // Save the next node first because world_submit_draw_effects_75C283 might modify the eff_node variable since it mutates the ESI register
177:             next_node = eff_node->next;
178:             if ( v6 > -30000 && v6 < 30000 && v3 > -30000 && v3 < 30000 )
179:             {
180:                 delta_point.x = v6;
181:                 v0 = 0;
182:                 delta_point.y = v5 - v0;
183:                 delta_point.z = v3;
184:                 if ( eff_node->apply_rotation_y )
185:                 {
186:                     camera_direction.z = 0;
187:                     camera_direction.x = 0;
188:                     camera_direction.y = eff_node->rotation_y;
189:                     ff7_externals.engine_apply_rotation_to_transform_matrix_6628DE((vector3<short>*)&camera_direction, (rotation_matrix*)&rot_matrix_0);
190:                     ff7_externals.engine_set_game_engine_rot_matrix_663673((rotation_matrix*)&rot_matrix_0);
191:                 }
192:                 else
193:                 {
194:                     ff7_externals.engine_set_game_engine_rot_matrix_663673((rotation_matrix*)&rot_matrix_2);
195:                 }
196: 
197:                 ff7_externals.world_submit_draw_effects_75C283(
198:                     &eff_node->texture_data,
199:                     (int)&ff7_externals.byte_96D6A8[12 * eff_node->unknown_idx],
200:                     &delta_point,
201:                     eff_node->apply_rotation_y);
202:             }
203:             eff_node = next_node;
204:         }
205:     }
206: 
207:     vector4<short>* previous_position_backup = nullptr;
208:     void animate_world_snake()
209:     {
210:         __int16 unknown;
211:         __int16 v1;
212:         __int16 v2;
213:         int delta_x;
214:         int delta_y;
215:         world_snake_graphics_data *snake_data;
216:         vector4<short>* previous_position;
217:         vector4<int> v7;
218: 
219:         ff7_externals.sub_74C9A5();
220:         ff7_externals.world_copy_position_75042B(&v7);
221:         previous_position = *ff7_externals.world_snake_data_position_ptr_E2A18C - 1;
222:         if ( previous_position < ff7_externals.world_snake_data_position_E29F80 )
223:             previous_position = &(ff7_externals.world_snake_data_position_E29F80[47]);
224: 
225: 
226:         for ( snake_data = ff7_externals.world_snake_graphics_data_E2A490;
227:                 snake_data < ff7_externals.world_snake_graphics_data_end_E2A6D0;
228:                 ++snake_data )
229:         {
230:             previous_position += 4;
231:             if ( previous_position >= ff7_externals.snake_position_size_of_array_E2A100 )
232:             previous_position -= 48;
233: 
234:             if ( ff7_externals.sub_753366(((int)previous_position->x >> 13) + 26, ((int)previous_position->y >> 13) + 16) )
235:             {
236:                 vector3<float> prevPos = { static_cast<float>(previous_position->x + 212992),
237:                                            static_cast<float>(0),
238:                                            static_cast<float>(previous_position->y + 0x20000)};
239:                 vector3<float> newPrevWorldPos = calcSphericalWorldPos(prevPos);
240: 
241:                 delta_x = newPrevWorldPos.x - v7.x;
242:                 if ( delta_x >= -30000 && delta_x <= 30000 )
243:                 {
244:                     snake_data->delta_x = delta_x;
245:                     delta_y = newPrevWorldPos.z - v7.z;
246:                     if ( delta_y >= -30000 && delta_y <= 30000 )
247:                     {
248:                         snake_data->delta_y = newPrevWorldPos.z - LOWORD(v7.z);
249:                         v2 = previous_position->z + 2048;
250:                         unknown = previous_position->w;
251:                         v1 = newPrevWorldPos.y;//sub_762F9A(snake_data->delta_x, snake_data->delta_y);
252:                         previous_position_backup = previous_position;
253:                         ff7_externals.world_draw_snake_texture_75D544(300, 300, unknown + v1, v2, snake_data, 0);// first two parameters = width and height of one block of the snake
254:                         previous_position = previous_position_backup;
255:                     }
256:                 }
257:             }
258: 
259: 
260:         }
261:     }
262: 
263:     int world_sub_762F9A(int x, int z)
264:     {
265:         return 0;
266:     }
267: 
268:     void draw_shadow(ff7_graphics_object *, ff7_game_obj *)
269:     {
270:     }
271: 
272:     void engine_apply_4x4_matrix_product_between_matrices(matrix *a1, matrix *a2, matrix *a3)
273:     {
274:         struct game_mode* mode = getmode_cached();
275: 
276:         struct matrix projection_matrix;
277:         ::memcpy(&projection_matrix.m[0][0], &a2->m[0][0], sizeof(projection_matrix.m));
278: 
279:         if (mode->driver_mode == MODE_WORLDMAP)
280:         {
281:             float f_offset = 0.0035f;
282:             float n_offset = 0.0f;
283: 
284:             float a = projection_matrix._33;
285:             float b = projection_matrix._43;
286: 
287: 
288:             float f = b / (a + 1.0f) + f_offset;
289:             float n = b / (a - 1.0f) + n_offset;
290: 
291: 
292:             projection_matrix._33 = -(f + n) / (f -n);
293:             projection_matrix._43 = -(2*f*n) / (f - n);
294:         }
295: 
296:         ff7_externals.engine_apply_4x4_matrix_product_between_matrices_66C6CD(a1, &projection_matrix, a3);
297:     }
298: 
299:     void Renderer::loadWorldMapExternalMesh()
300:     {
301:         externalWorldMapModel.unloadExternalMesh();
302: 
303:         const int worldmap_type = *ff7_externals.world_map_type_E045E8;
304:         const int world_progress = *ff7_externals.world_progress_E28CB4;
305: 
306:         std::string wmStr = "wm" + std::to_string(worldmap_type);
307:         std::vector<std::string> files;
308: 
309:         files.push_back("wm" + std::to_string(worldmap_type));
310:         if(worldmap_type == 0)
311:         {
312:             files.push_back("wm0_0_" + std::to_string(world_progress > 0));
313:             files.push_back("wm0_1_" + std::to_string(world_progress > 1));
314:             files.push_back("wm0_2_" + std::to_string(world_progress > 2));
315:             files.push_back("wm0_3_" + std::to_string(world_progress > 3));
316:         }
317: 
318:         auto numFiles = files.size();
319:         for (int i = 0; i < numFiles; ++i)
320:         {
321:             char file_path_gltf[MAX_PATH];
322:             sprintf(file_path_gltf, "%s/%s/world/%s.gltf", basedir, external_mesh_path.data(), files[i].data());
323: 
324:             char tex_path[MAX_PATH];
325:             sprintf(tex_path, "%s/%s/world/textures/", basedir, external_mesh_path.data());
326: 
327:             externalWorldMapModel.importExternalMeshGltfFile(file_path_gltf, tex_path);
328:         }
329:     }
330: 
331:     void Renderer::loadCloudsExternalMesh()
332:     {
333:         externalCloudsModel.unloadExternalMesh();
334: 
335:         char file_path_gltf[MAX_PATH];
336:         sprintf(file_path_gltf, "%s/%s/world/clouds.gltf", basedir, external_mesh_path.data());
337: 
338:         char tex_path[MAX_PATH];
339:         sprintf(tex_path, "%s/%s/world/textures/", basedir, external_mesh_path.data());
340: 
341:         externalCloudsModel.importExternalMeshGltfFile(file_path_gltf, tex_path);
342:     }
343: 
344:     void Renderer::loadMeteorExternalMesh()
345:     {
346:         externalMeteorModel.unloadExternalMesh();
347: 
348:         char file_path_gltf[MAX_PATH];
349:         sprintf(file_path_gltf, "%s/%s/world/meteo.gltf", basedir, external_mesh_path.data());
350: 
351:         char tex_path[MAX_PATH];
352:         sprintf(tex_path, "%s/%s/world/textures/", basedir, external_mesh_path.data());
353: 
354:         externalMeteorModel.importExternalMeshGltfFile(file_path_gltf, tex_path);
355:     }
356: 
357:     void Renderer::unloadExternalMeshes()
358:     {
359:         externalWorldMapModel.unloadExternalMesh();
360:         externalCloudsModel.unloadExternalMesh();
361:         externalMeteorModel.unloadExternalMesh();
362:     }
363: 
364:     bool Renderer::drawWorldMapExternalMesh()
365:     {
366:         if(gl_defer_world_external_mesh()) return false;
367: 
368:         auto shapeCount = externalWorldMapModel.shapes.size();
369:         int vertexOffset = 0;
370:         int indexOffset = 0;
371: 
372:         int world_pos_x = ff7_externals.world_player_pos_E04918->x;
373:         int world_pos_y = ff7_externals.world_player_pos_E04918->y;
374:         int world_pos_z = ff7_externals.world_player_pos_E04918->z;
375: 
376:         struct matrix viewMatrix;
377:         ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
378: 
379:         // Create a world matrix
380:         struct matrix worldViewMatrix[9];
381:         for (int gridX = -1; gridX <= 1; gridX++)
382:         {
383:             for (int gridZ = -1; gridZ <= 1; gridZ++)
384:             {
385:                 struct matrix worldMatrix;
386:                 identity_matrix(&worldMatrix);
387:                 worldMatrix._41 = gridX * 294912;
388:                 worldMatrix._42 = -500;
389:                 worldMatrix._43 = gridZ * 229376;
390:                 multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix[3 * (gridX + 1) + gridZ + 1]);
391:             }
392:         }
393: 
394:         newRenderer.setInterpolationQualifier(SMOOTH);
395:         newRenderer.setPrimitiveType();
396:         newRenderer.isTLVertex(false);
397:         newRenderer.setBlendMode(RendererBlendMode::BLEND_NONE);
398:         newRenderer.doTextureFiltering(true);
399:         newRenderer.doMirrorTextureWrap(true);
400:         newRenderer.isExternalTexture(true);
401:         newRenderer.isTexture(true);
402:         newRenderer.doDepthTest(true);
403:         newRenderer.doDepthWrite(true);
404:         newRenderer.setSphericalWorldRate(1.0f);
405: 
406:         if(enable_lighting)
407:         {
408:             // Light view frustum pointing to player position
409:             vector3<float> center = {
410:                 static_cast<float>(world_pos_x),
411:                 static_cast<float>(world_pos_y),
412:                 static_cast<float>(world_pos_z)};
413: 
414:             vector3<float> centerViewSpace;
415:                     transform_point(&viewMatrix, &center, &centerViewSpace);
416:             lighting.updateLightMatrices(centerViewSpace);
417:         }
418: 
419:         struct matrix* pProjMatrix = nullptr;
420:         if(!ff8)
421:         {
422:             struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
423:             if (game_object)
424:             {
425:                 auto polygon_set = (ff7_polygon_set*)game_object->polygon_set_2EC;
426:                 if(polygon_set)
427:                 {
428:                     auto matrix_set = polygon_set->matrix_set;
429:                     pProjMatrix = matrix_set->matrix_projection;
430:                 }
431: 
432:             }
433: 
434:             if(pProjMatrix != nullptr)
435:             {
436:                 newRenderer.setD3DProjection(pProjMatrix);
437:                 newRenderer.setD3DViweport(&d3dviewport_matrix);
438:             }
439:         }
440: 
441:         for (auto& iter : externalWorldMapModel.materials)
442:         {
443:             int texCount = iter.second.baseColorTexHandles.size();
444:             int frameInterval = iter.second.frameInterval * common_frame_multiplier;
445:             if(texCount == 1 || frameInterval == 0) continue;
446:             if(frame_counter % frameInterval == 0)
447:             {
448:                 iter.second.texIndex++;
449:                 if(iter.second.texIndex >= texCount) iter.second.texIndex = 0;
450:             }
451:         }
452: 
453:         const float maxDist = 275000.0f * 275000.0f;
454: 
455:         bool isFirstBinding = true;
456:         for (int i = 0; i < shapeCount; ++i)
457:         {
458:             auto& shape = externalWorldMapModel.shapes[i];
459: 
460:             newRenderer.setCullMode(shape.isDoubleSided ? RendererCullMode::DISABLED : RendererCullMode::BACK);
461: 
462:             vector3<float> center;
463:             center.x = 0.5f * (shape.max.x + shape.min.x);
464:             center.y = 0.5f * (shape.max.y + shape.min.y);
465:             center.z = 0.5f * (shape.max.z + shape.min.z);
466: 
467:             float radius = std::max(shape.max.x - shape.min.x, std::max(shape.max.y - shape.min.y, shape.max.z - shape.min.z));
468: 
469:             bool commonBindingSet = false;
470:             for (int gridX = -1; gridX <= 1; ++gridX)
471:             {
472:                 for (int gridZ = -1; gridZ <= 1; ++gridZ)
473:                 {
474:                     vector3<float> centerShifted;
475:                     centerShifted.x = center.x + gridX * 294912;
476:                     centerShifted.y = center.z;
477:                     centerShifted.z = center.y + gridZ * 229376;
478: 
479:                     vector2<float> diff;
480:                     diff.x = world_pos_x - centerShifted.x;
481:                     diff.y = world_pos_z - centerShifted.z;
482: 
483:                     float sqrDist = diff.x * diff.x + diff.y * diff.y;
484:                     if (sqrDist > maxDist)
485:                     {
486:                         continue;
487:                     }
488: 
489:                     vector3<float> centerShiftedViewSpace;
490:                     transform_point(&viewMatrix, &centerShifted, &centerShiftedViewSpace);
491: 
492:                     if (centerShiftedViewSpace.z + radius < 0.0f)
493:                     {
494:                         continue;
495:                     }
496: 
497:                     if (std::abs(centerShiftedViewSpace.x) - radius >  175000.0f)
498:                     {
499:                         continue;
500:                     }
501: 
502:                     if (std::abs(centerShiftedViewSpace.y) - radius >  175000.0f)
503:                     {
504:                         continue;
505:                     }
506: 
507:                     if (isFirstBinding)
508:                     {
509:                         newRenderer.setWorldViewMatrix(&worldViewMatrix[3 * (gridX + 1) + gridZ + 1]);
510:                         newRenderer.setCommonUniforms();
511:                         if (enable_lighting) newRenderer.setLightingUniforms();
512:                         isFirstBinding = false;
513:                     }
514:                     else
515:                     {
516:                         newRenderer.setWorldViewMatrix(&worldViewMatrix[3 * (gridX + 1) + gridZ + 1], false);
517:                         newRenderer.setUniform(RendererUniform::WORLD_VIEW, newRenderer.getWorldViewMatrix());
518:                     }
519: 
520:                     if(!commonBindingSet)
521:                     {
522:                         externalWorldMapModel.bindField3dVertexBuffer(vertexOffset, shape.vertices.size());
523:                         externalWorldMapModel.bindField3dIndexBuffer(indexOffset, shape.indices.size());
524: 
525:                         if(shape.pMaterial != nullptr)
526:                         {
527:                             if(shape.pMaterial->baseColorTexHandles.size() > 0)
528:                             {
529:                                 auto baseColorTexHandle = shape.pMaterial->baseColorTexHandles[shape.pMaterial->texIndex];
530:                                 if(bgfx::isValid(baseColorTexHandle))
531:                                     newRenderer.useTexture(baseColorTexHandle.idx, RendererTextureSlot::TEX_Y);
532:                                 else newRenderer.useTexture(0, RendererTextureSlot::TEX_Y);
533:                             }
534: 
535:                             if(shape.pMaterial->normalTexHandles.size() > 0)
536:                             {
537:                                 auto normalTexHandle = shape.pMaterial->normalTexHandles[0];
538:                                 if(bgfx::isValid(normalTexHandle))
539:                                     newRenderer.useTexture(normalTexHandle.idx, RendererTextureSlot::TEX_NML);
540:                                 else newRenderer.useTexture(0, RendererTextureSlot::TEX_NML);
541:                             }
542: 
543:                             if(shape.pMaterial->pbrTexHandles.size() > 0)
544:                             {
545:                                 auto pbrTexHandle = shape.pMaterial->pbrTexHandles[0];
546:                                 if(bgfx::isValid(pbrTexHandle))
547:                                     newRenderer.useTexture(pbrTexHandle.idx, RendererTextureSlot::TEX_PBR);
548:                                 else newRenderer.useTexture(0, RendererTextureSlot::TEX_PBR);
549:                             }
550: 
551:                             newRenderer.bindTextures();
552: 
553:                             commonBindingSet = true;
554:                         }
555:                     }
556: 
557:                     if (enable_lighting)
558:                     {
559:                         newRenderer.drawToShadowMap(true, true);
560:                         newRenderer.drawWithLighting(true, true, true);
561:                     }
562:                     else newRenderer.draw(true, true, true);
563:                 }
564:             }
565: 
566:             vertexOffset += shape.vertices.size();
567:             indexOffset += shape.indices.size();
568:         }
569: 
570:         newRenderer.discardAllBindings();
571: 
572:         newRenderer.doMirrorTextureWrap(false);
573: 
574:         if(shapeCount > 0) return true;
575:         else return false;
576:     }
577: 
578:     bool Renderer::drawCloudsExternalMesh()
579:     {
580:         int world_pos_x = ff7_externals.world_player_pos_E04918->x;
581:         int world_pos_y = ff7_externals.world_player_pos_E04918->y;
582:         int world_pos_z = ff7_externals.world_player_pos_E04918->z;
583: 
584:         struct matrix viewMatrix;
585:         ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
586: 
587:         struct matrix inverseViewMatrix;
588:         ::memcpy(&inverseViewMatrix.m[0][0], newRenderer.getInvViewMatrix(), sizeof(inverseViewMatrix.m));
589: 
590:         vector3<float> cameraPosViewSpace = {0.0f, 0.0f, 0.0f};
591:         vector3<float> cameraPos = {0.0f, 0.0f, 0.0f};
592:         transform_point(&inverseViewMatrix, &cameraPosViewSpace, &cameraPos);
593: 
594:         vector3<float> forward = {0.0f, 0.0f, 0.0f};
595:         vector3<float> focusPos = {static_cast<float>(world_pos_x), static_cast<float>(world_pos_y), static_cast<float>(world_pos_z)};
596:         subtract_vector(&focusPos, &cameraPos, &forward);
597:         forward.y = 0;
598:         normalize_vector(&forward);
599: 
600:         vector3<float> up = {0.0, 1.0, 0.0 };
601:         vector3<float> right = {0.0, 0.0, 0.0};
602:         cross_product(&forward, &up, &right);
603: 
604:         static const int numQuads = 5;
605: 
606:         static float frameCount = 0;
607:         frameCount++;
608: 
609:         // Create a world matrix
610:         struct matrix worldViewMatrix[numQuads];
611: 
612:         const float scaleX = 150000;
613:         const float scaleY = scaleX / 4;
614:         for(int i = 0; i < numQuads; ++i)
615:         {
616:             identity_matrix(&worldViewMatrix[i]);
617: 
618:             float offset = 2.0f * scaleX * (i- numQuads / 2);
619:             float cameraOffset = -4.0f * scaleX * (std::remainder(ff7::world::camera.getRotationOffsetY(), 360.0f) / 360.0f);
620:             float totalOffset = offset + cameraOffset;
621: 
622:             struct matrix worldMatrix;
623:             identity_matrix(&worldMatrix);
624:             worldMatrix._11 = (i % 2 == 0 ? 1 : -1) *  scaleX * right.x;
625:             worldMatrix._12 = (i % 2 == 0 ? 1 : -1) *  scaleX * right.y;
626:             worldMatrix._13 = (i % 2 == 0 ? 1 : -1) * scaleX * right.z;
627:             worldMatrix._21 = -scaleY * up.x;
628:             worldMatrix._22 = -scaleY * up.y;
629:             worldMatrix._23 = -scaleY * up.z;
630:             worldMatrix._31 = forward.x;
631:             worldMatrix._32 = forward.y;
632:             worldMatrix._33 = forward.z;
633:             worldMatrix._41 = focusPos.x + forward.x * 100000 + totalOffset * right.x;
634:             worldMatrix._42 = 20000;
635:             worldMatrix._43 = focusPos.z + forward.z * 100000 + totalOffset * right.z;
636: 
637:             multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix[i]);
638: 
639:         }
640: 
641:         newRenderer.setInterpolationQualifier(SMOOTH);
642:         newRenderer.setPrimitiveType();
643:         newRenderer.isTLVertex(false);
644:         newRenderer.setBlendMode(RendererBlendMode::BLEND_ADD);
645:         newRenderer.doTextureFiltering(true);
646:         newRenderer.isExternalTexture(true);
647:         newRenderer.isTexture(true);
648:         newRenderer.doDepthTest(true);
649:         newRenderer.doDepthWrite(false);
650:         newRenderer.setSphericalWorldRate(1.5f);
651: 
652:         struct matrix* pProjMatrix = nullptr;
653:         if(!ff8)
654:         {
655:             struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
656:             if (game_object)
657:             {
658:                 auto polygon_set = (ff7_polygon_set*)game_object->polygon_set_2EC;
659:                 if(polygon_set)
660:                 {
661:                     auto matrix_set = polygon_set->matrix_set;
662:                     pProjMatrix = matrix_set->matrix_projection;
663:                 }
664: 
665:             }
666: 
667:             if(pProjMatrix != nullptr)
668:             {
669:                 newRenderer.setD3DProjection(pProjMatrix);
670:                 newRenderer.setD3DViweport(&d3dviewport_matrix);
671:             }
672:         }
673: 
674:         newRenderer.setWorldViewMatrix(&worldViewMatrix[0]);
675:         newRenderer.setCommonUniforms();
676: 
677:         auto shapeCount = externalCloudsModel.shapes.size();
678:         for (int i = 0; i < shapeCount; ++i)
679:         {
680:             auto& shape = externalCloudsModel.shapes[i];
681: 
682:             newRenderer.setCullMode(shape.isDoubleSided ? RendererCullMode::DISABLED : RendererCullMode::BACK);
683: 
684:             externalCloudsModel.bindField3dVertexBuffer(0, shape.vertices.size());
685:             externalCloudsModel.bindField3dIndexBuffer(0, shape.indices.size());
686: 
687:             if(shape.pMaterial != nullptr)
688:             {
689:                 if(shape.pMaterial->baseColorTexHandles.size() > 0)
690:                 {
691:                     auto baseColorTexHandle = shape.pMaterial->baseColorTexHandles[shape.pMaterial->texIndex];
692:                     if(bgfx::isValid(baseColorTexHandle))
693:                         newRenderer.useTexture(baseColorTexHandle.idx, RendererTextureSlot::TEX_Y);
694:                     else newRenderer.useTexture(0, RendererTextureSlot::TEX_Y);
695:                 }
696: 
697:                 if(shape.pMaterial->normalTexHandles.size() > 0)
698:                 {
699:                     auto normalTexHandle = shape.pMaterial->normalTexHandles[0];
700:                     if(bgfx::isValid(normalTexHandle))
701:                         newRenderer.useTexture(normalTexHandle.idx, RendererTextureSlot::TEX_NML);
702:                     else newRenderer.useTexture(0, RendererTextureSlot::TEX_NML);
703:                 }
704: 
705:                 if(shape.pMaterial->pbrTexHandles.size() > 0)
706:                 {
707:                     auto pbrTexHandle = shape.pMaterial->pbrTexHandles[0];
708:                     if(bgfx::isValid(pbrTexHandle))
709:                         newRenderer.useTexture(pbrTexHandle.idx, RendererTextureSlot::TEX_PBR);
710:                     else newRenderer.useTexture(0, RendererTextureSlot::TEX_PBR);
711:                 }
712: 
713:                 newRenderer.bindTextures();
714:             }
715: 
716:             for(int i = 0; i < numQuads; ++i)
717:             {
718:                 if(i != 0)
719:                 {
720:                     newRenderer.setWorldViewMatrix(&worldViewMatrix[i]);
721:                     newRenderer.setUniform(RendererUniform::WORLD_VIEW, newRenderer.getWorldViewMatrix());
722:                 }
723: 
724:                 newRenderer.draw(true, true, true);
725:             }
726:         }
727: 
728:         newRenderer.discardAllBindings();
729: 
730:         newRenderer.setSphericalWorldRate(1.0f);
731: 
732:         return true;
733:     }
734: 
735:     bool Renderer::drawMeteorExternalMesh()
736:     {
737:         int world_pos_x = ff7_externals.world_player_pos_E04918->x;
738:         int world_pos_y = ff7_externals.world_player_pos_E04918->y;
739:         int world_pos_z = ff7_externals.world_player_pos_E04918->z;
740: 
741:         struct matrix viewMatrix;
742:         ::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
743: 
744:         struct matrix inverseViewMatrix;
745:         ::memcpy(&inverseViewMatrix.m[0][0], newRenderer.getInvViewMatrix(), sizeof(inverseViewMatrix.m));
746: 
747:         vector3<float> cameraPosViewSpace = {0.0f, 0.0f, 0.0f};
748:         vector3<float> cameraPos = {0.0f, 0.0f, 0.0f};
749:         transform_point(&inverseViewMatrix, &cameraPosViewSpace, &cameraPos);
750: 
751:         vector3<float> forward = {0.0f, 0.0f, 0.0f};
752:         vector3<float> focusPos = {static_cast<float>(world_pos_x), static_cast<float>(world_pos_y), static_cast<float>(world_pos_z)};
753:         subtract_vector(&focusPos, &cameraPos, &forward);
754:         forward.y = 0;
755:         normalize_vector(&forward);
756: 
757:         vector3<float> up = {0.0, 1.0, 0.0 };
758:         vector3<float> right = {0.0, 0.0, 0.0};
759:         cross_product(&forward, &up, &right);
760: 
761:         // Create a world matrix
762:         struct matrix worldViewMatrix;
763: 
764:         identity_matrix(&worldViewMatrix);
765: 
766:         const float scaleX = 100000;
767:         const float scaleY = scaleX / 2;
768: 
769:         float cameraOffset = -8.0f * scaleX * (std::remainder(ff7::world::camera.getRotationOffsetY(), 360.0f) / 360.0f);
770: 
771:         struct matrix worldMatrix;
772:         identity_matrix(&worldMatrix);
773:         worldMatrix._11 = scaleX * right.x;
774:         worldMatrix._12 = scaleX * right.y;
775:         worldMatrix._13 = scaleX * right.z;
776:         worldMatrix._21 = scaleY * up.x;
777:         worldMatrix._22 = scaleY * up.y;
778:         worldMatrix._23 = scaleY * up.z;
779:         worldMatrix._31 = forward.x;
780:         worldMatrix._32 = forward.y;
781:         worldMatrix._33 = forward.z;
782:         worldMatrix._41 = focusPos.x + forward.x * 150000 + cameraOffset * right.x;
783:         worldMatrix._42 = 40000;
784:         worldMatrix._43 = focusPos.z + forward.z * 150000 + cameraOffset * right.z;
785: 
786:         multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix);
787: 
788:         newRenderer.setInterpolationQualifier(SMOOTH);
789:         newRenderer.setPrimitiveType();
790:         newRenderer.isTLVertex(false);
791:         newRenderer.setBlendMode(RendererBlendMode::BLEND_ADD);
792:         newRenderer.doTextureFiltering(true);
793:         newRenderer.isExternalTexture(true);
794:         newRenderer.isTexture(true);
795:         newRenderer.doDepthTest(true);
796:         newRenderer.doDepthWrite(false);
797:         newRenderer.setSphericalWorldRate(4.0f);
798: 
799:         struct matrix* pProjMatrix = nullptr;
800:         if(!ff8)
801:         {
802:             struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
803:             if (game_object)
804:             {
805:                 auto polygon_set = (ff7_polygon_set*)game_object->polygon_set_2EC;
806:                 if(polygon_set)
807:                 {
808:                     auto matrix_set = polygon_set->matrix_set;
809:                     pProjMatrix = matrix_set->matrix_projection;
810:                 }
811: 
812:             }
813: 
814:             if(pProjMatrix != nullptr)
815:             {
816:                 newRenderer.setD3DProjection(pProjMatrix);
817:                 newRenderer.setD3DViweport(&d3dviewport_matrix);
818:             }
819:         }
820: 
821:         newRenderer.setWorldViewMatrix(&worldViewMatrix);
822:         newRenderer.setCommonUniforms();
823: 
824:         auto shapeCount = externalMeteorModel.shapes.size();
825:         for (int i = 0; i < shapeCount; ++i)
826:         {
827:             auto& shape = externalMeteorModel.shapes[i];
828: 
829:             newRenderer.setCullMode(shape.isDoubleSided ? RendererCullMode::DISABLED : RendererCullMode::BACK);
830: 
831:             externalMeteorModel.bindField3dVertexBuffer(0, shape.vertices.size());
832:             externalMeteorModel.bindField3dIndexBuffer(0, shape.indices.size());
833: 
834:             if(shape.pMaterial != nullptr)
835:             {
836:                 if(shape.pMaterial->baseColorTexHandles.size() > 0)
837:                 {
838:                     auto baseColorTexHandle = shape.pMaterial->baseColorTexHandles[shape.pMaterial->texIndex];
839:                     if(bgfx::isValid(baseColorTexHandle))
840:                         newRenderer.useTexture(baseColorTexHandle.idx, RendererTextureSlot::TEX_Y);
841:                     else newRenderer.useTexture(0, RendererTextureSlot::TEX_Y);
842:                 }
843: 
844:                 if(shape.pMaterial->normalTexHandles.size() > 0)
845:                 {
846:                     auto normalTexHandle = shape.pMaterial->normalTexHandles[0];
847:                     if(bgfx::isValid(normalTexHandle))
848:                         newRenderer.useTexture(normalTexHandle.idx, RendererTextureSlot::TEX_NML);
849:                     else newRenderer.useTexture(0, RendererTextureSlot::TEX_NML);
850:                 }
851: 
852:                 if(shape.pMaterial->pbrTexHandles.size() > 0)
853:                 {
854:                     auto pbrTexHandle = shape.pMaterial->pbrTexHandles[0];
855:                     if(bgfx::isValid(pbrTexHandle))
856:                         newRenderer.useTexture(pbrTexHandle.idx, RendererTextureSlot::TEX_PBR);
857:                     else newRenderer.useTexture(0, RendererTextureSlot::TEX_PBR);
858:                 }
859: 
860:                 newRenderer.bindTextures();
861:             }
862: 
863:             newRenderer.draw(true, true, true);
864:         }
865: 
866:         newRenderer.discardAllBindings();
867: 
868:         newRenderer.setSphericalWorldRate(1.0f);
869: 
870:         return true;
871:     }
872: 
873:     bool Renderer::drawCloudsAndMeteorExternalMesh(bool isDrawMeteor)
874:     {
875:         if(gl_defer_cloud_external_mesh()) return false;
876: 
877:         if (isDrawMeteor) drawMeteorExternalMesh();
878:         drawCloudsExternalMesh();
879: 
880:         return true;
881:     }
882: }
</file>

<file path="src/ff7/world/renderer.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include "external_mesh.h"
27: #include "ff7.h"
28: 
29: namespace ff7::world {
30: 
31:     void init_load_wm_bot_blocks();
32:     void destroy_graphics_objects();
33: 
34:     void wm0_overworld_draw_all();
35:     void wm0_overworld_draw_clouds();
36:     void wm0_overworld_draw_meteor();
37:     void wm2_underwater_draw_all();
38:     void wm3_snowstorm_draw_all();
39: 
40:     void wm0_draw_minimap_quad_graphics_object(ff7_graphics_object* quad_graphics_object, ff7_game_obj* game_object);
41:     void wm0_draw_world_effects_1_graphics_object(ff7_graphics_object* world_effects_1_graphics_object, ff7_game_obj* game_object);
42:     void wm0_draw_minimap_points_graphics_object(ff7_graphics_object* minimap_points_graphics_object, ff7_game_obj* game_object);
43: 
44:     int get_camera_rotation_z();
45: 
46:     void world_copy_position(vector4<int> *a1);
47:     void world_draw_effects();
48:     void animate_world_snake();
49:     int world_sub_762F9A(int a1, int arg4);
50: 
51:     void draw_shadow(ff7_graphics_object *, ff7_game_obj *);
52: 
53:     void engine_apply_4x4_matrix_product_between_matrices(matrix *a1, matrix *a2, matrix *a3);
54: 
55:     class Renderer
56:     {
57:     public:
58:         void loadWorldMapExternalMesh();
59:         bool drawWorldMapExternalMesh();
60:         void loadCloudsExternalMesh();
61:         void loadMeteorExternalMesh();
62:         void unloadExternalMeshes();
63:         bool drawCloudsExternalMesh();
64:         bool drawMeteorExternalMesh();
65:         bool drawCloudsAndMeteorExternalMesh(bool isDrawMeteor);
66: 
67:     private:
68:         ExternalMesh externalWorldMapModel;
69:         ExternalMesh externalSnakeModel;
70:         ExternalMesh externalCloudsModel;
71:         ExternalMesh externalMeteorModel;
72:     };
73: 
74:     Renderer worldRenderer;
75: }
</file>

<file path="src/ff7/world/utils.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2022 Cosmos                                             //
10: //    Copyright (C) 2022 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: namespace ff7::world
27: {
28:     bool is_key_pressed(int current_key_status, int key)
29:     {
30:         return (current_key_status & key) != 0;
31:     }
32: 
33:     bool is_key_pressed_first_time(int current_key_status, int prev_key_status, int key)
34:     {
35:         return (current_key_status & key) != 0 && (prev_key_status & key) == 0;
36:     }
37: 
38:     bool is_key_released(int current_key_status, int prev_key_status, int key)
39:     {
40:         return (current_key_status & key) == 0 && (prev_key_status & key) != 0;
41:     }
42: }
</file>

<file path="src/ff7/world/world.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <math.h>
 24: 
 25: #include "../../globals.h"
 26: #include "../../patch.h"
 27: #include "../../sfx.h"
 28: 
 29: #include "cfg.h"
 30: #include "defs.h"
 31: #include "world.h"
 32: #include "utils.h"
 33: #include "renderer.h"
 34: 
 35: namespace ff7::world
 36: {
 37:     World world;
 38: 
 39:     std::map<uint32_t, bool> do_decrease_wait_frames;
 40: 
 41:     bool world_has_old_highwind()
 42:     {
 43:         return (*ff7_externals.insertedCD) <= 2;
 44:     }
 45: 
 46:     void world_update_model_movement(int delta_position_x, int delta_position_z)
 47:     {
 48:         int player_model_id = ff7_externals.world_get_player_model_id();
 49:         constexpr float distance_threshold = 10.0f;
 50:         float distance = std::sqrt(std::pow(delta_position_x, 2) + std::pow(delta_position_z, 2));
 51: 
 52:         // For Highwind sound
 53:         if(player_model_id == 3)
 54:         {
 55:             int key_input_status = ff7_externals.world_get_current_key_input_status();
 56:             bool is_highwind_moving = is_key_pressed(key_input_status, enable_analogue_controls ? CIRCLE | R1 : CIRCLE);
 57:             sfx_process_wm_highwind(world_has_old_highwind(), is_highwind_moving);
 58:         }
 59:         // For worldmap footsteps
 60:         else if((player_model_id >= 0 && player_model_id <= 2) || player_model_id == 4 || player_model_id == 19) // Cloud, Tifa, Cid, and Chocobo
 61:         {
 62:             // TODO: Fix footsteps when player is not moving at all. Here delta position is not clipped by collision detection (Need to find collision detection)
 63:             if(distance > distance_threshold)
 64:             {
 65:                 sfx_process_wm_footstep(player_model_id, ff7_externals.world_get_player_walkmap_type());
 66:             }
 67:         }
 68: 
 69:         ff7_externals.world_update_model_movement_762E87(delta_position_x, delta_position_z);
 70:     }
 71: 
 72:     void world_init_variables(short param_1)
 73:     {
 74:         do_decrease_wait_frames.clear();
 75: 
 76:         ((void(*)(short))ff7_externals.world_init_variables_74E1E9)(param_1);
 77:     }
 78: 
 79:     void world_snake_compute_delta_position(vector3<short>* delta_position, short z_value)
 80:     {
 81:         ff7_externals.world_sub_753D00(delta_position, z_value);
 82:         if(delta_position)
 83:         {
 84:             delta_position->x /= common_frame_multiplier;
 85:             delta_position->y /= common_frame_multiplier;
 86:             delta_position->z /= common_frame_multiplier;
 87:         }
 88:     }
 89: 
 90:     int run_world_script_system_operations(WORD opcode)
 91:     {
 92:         int ret = 0;
 93:         if (opcode == 0x306)
 94:         {
 95:             vector3<short> delta_position;
 96:             if (*ff7_externals.is_wait_frames_zero_E39BC0)
 97:             {
 98:                 --(*ff7_externals.world_event_current_entity_ptr_E3A7CC)->curr_script_position;
 99:                 return 1;
100:             }
101:             else
102:             {
103:                 if(do_decrease_wait_frames[(uint32_t)*ff7_externals.world_event_current_entity_ptr_E3A7CC])
104:                     (*ff7_externals.world_event_current_entity_ptr_E3A7CC)->wait_frames--;
105:                 do_decrease_wait_frames[(uint32_t)*ff7_externals.world_event_current_entity_ptr_E3A7CC] = !do_decrease_wait_frames[(uint32_t)*ff7_externals.world_event_current_entity_ptr_E3A7CC];
106: 
107:                 if ((*ff7_externals.world_event_current_entity_ptr_E3A7CC)->wait_frames)
108:                     (*ff7_externals.world_event_current_entity_ptr_E3A7CC)->curr_script_position--;
109:                 else
110:                     *ff7_externals.is_wait_frames_zero_E39BC0 = 1;
111:                 delta_position.x = 0;
112:                 delta_position.y = 0;
113:                 delta_position.z = (*ff7_externals.world_event_current_entity_ptr_E39AD8)->movement_speed << (4 * (((*ff7_externals.world_event_current_entity_ptr_E39AD8)->animation_is_loop_mask & 0x40) != 0));
114:                 ff7_externals.world_sub_753D00(&delta_position, (*ff7_externals.world_event_current_entity_ptr_E39AD8)->direction);
115:                 ff7_externals.world_update_model_movement_762E87(delta_position.x, delta_position.z);
116:                 (*ff7_externals.world_event_current_entity_ptr_E39AD8)->offset_y -= (*ff7_externals.world_event_current_entity_ptr_E39AD8)->vertical_speed;
117:                 (*ff7_externals.world_event_current_entity_ptr_E39AD8)->position.y += (*ff7_externals.world_event_current_entity_ptr_E39AD8)->vertical_speed_2;
118:                 return (*ff7_externals.world_event_current_entity_ptr_E3A7CC)->wait_frames != 0;
119:             }
120:         }
121:         else
122:         {
123:             ret = ((int (*)(WORD))ff7_externals.run_world_event_scripts_system_operations)(opcode);
124:         }
125:         return ret;
126:     }
127: 
128:     int pop_world_stack_multiply_wrapper()
129:     {
130:         int ret = ff7_externals.pop_world_script_stack();
131:         return ret * common_frame_multiplier;
132:     }
133: 
134:     int pop_world_stack_divide_wrapper()
135:     {
136:         int ret = ff7_externals.pop_world_script_stack();
137:         return ret / common_frame_multiplier;
138:     }
139: 
140:     int get_world_encounter_rate()
141:     {
142:         int encounter_rate = ff7_externals.get_world_encounter_rate();
143:         return encounter_rate / common_frame_multiplier;
144:     }
145: 
146:     void world_hook_init()
147:     {
148:         if(ff7_fps_limiter == FPS_LIMITER_60FPS)
149:         {
150:             // World init
151:             replace_call_function(ff7_externals.world_mode_loop_sub_74DB8C + 0x108, world_init_variables);
152: 
153:             // Movement related fix
154:             patch_divide_code<DWORD>(ff7_externals.world_init_variables_74E1E9 + 0x15D, common_frame_multiplier);
155:             replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x172, pop_world_stack_divide_wrapper);
156:             replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x14B, pop_world_stack_divide_wrapper);
157:             replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x55D, pop_world_stack_divide_wrapper);
158:             replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x584, pop_world_stack_divide_wrapper);
159: 
160:             // Camera related fix
161:             replace_call_function(ff7_externals.run_world_event_scripts_system_operations + 0x7DC, pop_world_stack_divide_wrapper);
162: 
163:             // Midgar zolom (snake) movement fix
164:             replace_call_function(ff7_externals.update_world_snake_position_7564CD + 0x26, world_snake_compute_delta_position);
165:             replace_call_function(ff7_externals.update_world_snake_position_7564CD + 0x195, world_snake_compute_delta_position);
166:             replace_call_function(ff7_externals.update_world_snake_position_7564CD + 0x2B4, world_snake_compute_delta_position);
167: 
168:             // World Encounter rate fix
169:             replace_call_function(ff7_externals.world_sub_767641 + 0x110, get_world_encounter_rate);
170: 
171:             // Text box message fix
172:             patch_code_byte(ff7_externals.world_text_box_window_paging_769C02 + 0xF6, 0x5 + common_frame_multiplier / 2);
173:             patch_divide_code<byte>(ff7_externals.world_text_box_window_paging_769C02 + 0xF9, common_frame_multiplier);
174:             patch_divide_code<WORD>(ff7_externals.world_text_box_window_paging_769C02 + 0x10A, common_frame_multiplier);
175:             patch_code_byte(ff7_externals.world_text_box_window_paging_769C02 + 0x13A, 0x4 + common_frame_multiplier / 2);
176:             patch_code_byte(ff7_externals.world_text_box_window_opening_769A66 + 0x3D, 0x2 + common_frame_multiplier / 2);
177:             patch_code_byte(ff7_externals.world_text_box_window_opening_769A66 + 0xD2, 0x2 + common_frame_multiplier / 2);
178:             patch_code_byte(ff7_externals.world_text_box_window_closing_76ADF7 + 0x67, 0x2 + common_frame_multiplier / 2);
179:             patch_code_byte(ff7_externals.world_text_box_window_closing_76ADF7 + 0xC2, 0x2 + common_frame_multiplier / 2);
180:             patch_divide_code<short>(ff7_externals.world_text_box_reverse_paging_76ABE9 + 0x42, common_frame_multiplier);
181:             patch_divide_code<short>(ff7_externals.world_opcode_message + 0x1AC, common_frame_multiplier);
182:             patch_divide_code<short>(ff7_externals.world_opcode_message + 0x2CF, common_frame_multiplier);
183:             patch_divide_code<short>(ff7_externals.world_opcode_ask + 0x1AC, common_frame_multiplier);
184:             patch_divide_code<byte>(ff7_externals.world_opcode_ask + 0x3CC, common_frame_multiplier);
185: 
186:             // Wait frames decrease delayed
187:             replace_call_function(ff7_externals.run_world_event_scripts + 0xC7, run_world_script_system_operations);
188:         }
189: 
190:         if (enable_time_cycle)
191:         {
192:             replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x175, ff7::world::wm0_draw_minimap_quad_graphics_object);
193:             replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x1BE, ff7::world::wm0_draw_world_effects_1_graphics_object);
194:             replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x208, ff7::world::wm0_draw_minimap_points_graphics_object);
195:         }
196: 
197:         if (enable_worldmap_external_mesh)
198:         {
199:             // Replace player and camera update functions
200:             if (enable_analogue_controls)
201:             {
202:                 replace_function(ff7_externals.world_update_camera_74E8CE, ff7::world::update_world_camera);
203:                 replace_function(ff7_externals.world_update_player_74EA48, ff7::world::update_player_and_handle_input);
204: 
205:                 // Disable Z-axis camera rotation
206:                 replace_function(ff7_externals.world_sub_74D319, ff7::world::get_camera_rotation_z);
207:             }            
208:            
209:             replace_call_function(ff7_externals.world_mode_loop_sub_74DB8C + 0x296, ff7::world::init_load_wm_bot_blocks);
210:             replace_call_function(ff7_externals.world_exit_74BD77 + 0x11, ff7::world::destroy_graphics_objects);
211: 
212:             // Expand meteor quad size to render the top part
213:             patch_code_char(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x205, 0x7F);
214:             patch_code_char(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x217, 0x0);
215: 
216:             // Replace original world rendering
217:             patch_code_dword(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 + 0xA7, (DWORD)&ff7::world::wm0_overworld_draw_all);
218:             replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0xF8, ff7::world::wm0_overworld_draw_clouds);
219:             replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x10A, ff7::world::wm0_overworld_draw_meteor);
220:             patch_code_dword(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 + 0xDF, (DWORD)&ff7::world::wm2_underwater_draw_all);
221:             patch_code_dword(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 + 0x117, (DWORD)&ff7::world::wm3_snowstorm_draw_all);
222: 
223:             // Disable original world spherical transformation
224:             memset_code(ff7_externals.world_sub_75F0AD + 0xFA, 0x90, 3);
225:             memset_code(ff7_externals.world_sub_75F0AD + 0x187, 0x90, 3);
226:             memset_code(ff7_externals.world_sub_75F0AD + 0x1A5, 0x90, 3);
227: 
228:             // Disable world models vertical movement
229:             replace_function(ff7_externals.world_sub_762F9A, ff7::world::world_sub_762F9A);
230: 
231:             // Draw snake with new spherical world transformation		
232:             replace_function(ff7_externals.animate_world_snake_75692A, ff7::world::animate_world_snake);	
233: 
234:             // Modify projection matrix to increase view frustrum far plane
235:             replace_call_function((uint32_t)ff7_externals.engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF + 0x16, ff7::world::engine_apply_4x4_matrix_product_between_matrices);
236:             
237:             // Add same spherical world transformation as done in the shader to particles too
238:             replace_function(ff7_externals.world_sub_75C0FD, ff7::world::world_draw_effects);		
239: 
240:             // Remove world meshes draw calls by jumping to end of loop
241:             patch_code_byte((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x32, 0x76);
242:             patch_code_byte((uint32_t)ff7_externals.world_wm2_underwater_draw_all_74C3F0 + 0x32, 0x2D);
243:             patch_code_byte((uint32_t)ff7_externals.world_wm3_snowstorm_draw_all_74C589 + 0x32, 0x2D);
244: 
245:             // Disable model culling
246:             // TODO: try to find a way to make to game update models even when player is far away
247:             //memset_code(ff7_externals.world_draw_all_3d_model_74C6B0 + 0x84, 0x90, 6);
248:            
249:             // Disable shadow draw call
250:             // TODO: fix shadow rendering when lighting not enabled
251:             //if (enable_lighting)
252:             {
253:                 replace_call_function((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179 + 0x13B, ff7::world::draw_shadow);
254:                 replace_call_function((uint32_t)ff7_externals.world_wm3_snowstorm_draw_all_74C589 + 0xB8, ff7::world::draw_shadow);
255:             }
256:         }
257:     }    
258: }
</file>

<file path="src/ff7/world/world.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2022 Cosmos                                             //
 10: //    Copyright (C) 2022 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #pragma once
 25: 
 26: #include "matrix.h"
 27: 
 28: namespace ff7::world
 29: {
 30:     enum input_key
 31:     {
 32:         L2 = 1,
 33:         R2 = 2,
 34:         L1 = 4,
 35:         R1 = 8,
 36:         TRIANGLE = 16,
 37:         CIRCLE = 32,
 38:         CROSS = 64,
 39:         SQUARE = 128,
 40:         SELECT = 256,
 41:         UNK1 = 512,
 42:         UNK2 = 1024,
 43:         START = 2048,
 44:         UP = 4096,
 45:         RIGHT = 8192,
 46:         DOWN = 16384,
 47:         LEFT = 32768,
 48:         ANY_DIRECTIONAL_KEY = UP | RIGHT | DOWN | LEFT
 49:     };
 50: 
 51:     enum map_type {
 52:         OVERWORLD = 0,
 53:         UNDERWATER = 2,
 54:         SNOWSTORM = 3
 55:     };
 56: 
 57:     enum model_type {
 58:         CLOUD = 0,
 59:         TIFA,
 60:         CID,
 61:         HIGHWIND,
 62:         WILD_CHOCOBO,
 63:         TINY_BRONCO ,
 64:         BUGGY,
 65:         JUNON_CANNON,
 66:         CARGO_SHIP,
 67:         HIGHWIND_PROPELLERS,
 68:         DIAMOND_WEAPON,
 69:         ULTIMATE_WEAPON,
 70:         FORT_CONDOR,
 71:         SUBMARINE,
 72:         GOLD_SAUCER,
 73:         ROCKET_TOWN_ROCKET,
 74:         ROCKET_TOWN_LAUNCH_PAD,
 75:         SUNKEN_GELNIKA,
 76:         UNDERWATER_REACTOR,
 77:         CHOCOBO,
 78:         MIDGAR_CANNON,
 79:         MODEL_UNK1,
 80:         MODEL_UNK2,
 81:         MODEL_UNK3,
 82:         NORTH_CRATER_BARRIER,
 83:         ANCIENT_FOREST,
 84:         KEY_ANCIENTS,
 85:         MODEL_UNK4,
 86:         RED_SUBMARINE,
 87:         RUBY_WEAPON,
 88:         EMERALD_WEAPON
 89:     };
 90: 
 91:     constexpr int INVALID_DIRECTION = 9999;
 92: 
 93:     class World
 94:     {
 95:     public:
 96:         const vector3<float>& GetJoystickDirection();
 97:         void SetJoystickDirection(const vector3<float>& dir);
 98: 
 99:         float GetRightTrigger();
100:         void SetRightTrigger(float value);
101: 
102:         float GetLeftTrigger();
103:         void SetLeftTrigger(float value);
104: 
105:     private:
106:         vector3<float> joyDir = {0.0f, 0.0f, 0.0f};
107:         float rightTrigger = 0.0f;
108:         float leftTrigger = 0.0f;
109:     };
110: 
111:     inline const vector3<float>& World::GetJoystickDirection()
112:     {
113:         return joyDir;
114:     }
115: 
116:     inline void World::SetJoystickDirection(const vector3<float>& dir)
117:     {
118:         joyDir = dir;
119:     }
120: 
121:     inline float World::GetRightTrigger()
122:     {
123:         return rightTrigger;
124:     }
125: 
126:     inline void World::SetRightTrigger(float value)
127:     {
128:         rightTrigger = value;
129:     }
130: 
131:     inline float World::GetLeftTrigger()
132:     {
133:         return leftTrigger;
134:     }
135: 
136:     inline void World::SetLeftTrigger(float value)
137:     {
138:         leftTrigger = value;
139:     }
140: 
141:     extern World world;
142: 
143:     int get_player_movement_speed(int model_id);
144: }
</file>

<file path="src/ff7/defs.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #pragma once
 23: 
 24: #include "ff7.h"
 25: #include <windows.h>
 26: #include <stdint.h>
 27: 
 28: // kernel
 29: void kernel2_reset_counters();
 30: char *kernel2_add_section(uint32_t size);
 31: char *kernel2_get_text(uint32_t section_base, uint32_t string_id, uint32_t section_offset);
 32: void ff7_load_kernel2_wrapper(char *filename);
 33: 
 34: // menu
 35: void ff7_menu_battle_end_sub_6C9543();
 36: void ff7_menu_sub_71AAA3(int param_1);
 37: int ff7_get_materia_gil(uint32_t materia);
 38: void ff7_opcode_increase_gil_call(int param_1);
 39: byte ff7_menu_sub_6CBCF3(uint32_t materia_id);
 40: void ff7_menu_sub_6CC17F(uint32_t materia);
 41: uint32_t ff7_menu_decrease_item_quantity(uint32_t item_data);
 42: void ff7_menu_sub_6CDC09(DWORD param_1);
 43: void ff7_battle_menu_sub_6DB0EE();
 44: void ff7_set_battle_menu_state_data_at_full_atb(short param_1, short param_2, short menu_state);
 45: 
 46: // misc
 47: void ff7_core_game_loop();
 48: uint32_t get_equipment_stats(uint32_t party_index, uint32_t type);
 49: void ff7_wm_activateapp(bool hasFocus);
 50: int ff7_get_gamepad();
 51: struct ff7_gamepad_status* ff7_update_gamepad_status();
 52: void* ff7_engine_exit_game_mode(ff7_game_obj* game_object);
 53: void ff7_on_gameover_enter();
 54: void ff7_on_gameover_exit();
 55: BYTE ff7_toggle_battle_field();
 56: BYTE ff7_toggle_battle_worldmap();
 57: bool ff7_skip_movies();
 58: void *ff7_menu_sub_6F5C0C(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5);
 59: void *ff7_menu_sub_6FAC38(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5);
 60: void ff7_limit_fps();
 61: void ff7_handle_ambient_playback();
 62: void ff7_handle_voice_playback();
 63: BOOL ff7_write_save_file(char slot);
 64: int ff7_field_load_models_atoi(const char* str);
 65: void ff7_chocobo_field_entity_60FA7D(WORD param1, short param2, short param3);
 66: void ff7_character_regularly_field_entity_60FA7D(WORD param1, short param2, short param3);
 67: int ff7_load_save_file(int param_1);
 68: 
 69: // file
 70: FILE *open_lgp_file(char *filename, uint32_t mode);
 71: void close_lgp_file(FILE *fd);
 72: extern char lgp_names[18][256];
 73: uint32_t lgp_chdir(char *path);
 74: struct lgp_file *lgp_open_file(char *filename, uint32_t lgp_num);
 75: uint32_t lgp_seek_file(uint32_t offset, uint32_t lgp_num);
 76: uint32_t lgp_read(uint32_t lgp_num, char *dest, uint32_t size);
 77: uint32_t lgp_read_file(struct lgp_file *file, uint32_t lgp_num, char *dest, uint32_t size);
 78: uint32_t lgp_get_filesize(struct lgp_file *file, uint32_t lgp_num);
 79: void close_file(struct ff7_file *file);
 80: struct ff7_file *open_file(struct file_context *file_context, char *filename);
 81: uint32_t __read_file(uint32_t count, void *buffer, struct ff7_file *file);
 82: uint32_t read_file(uint32_t count, void *buffer, struct ff7_file *file);
 83: uint32_t __read(FILE *file, char *buffer, uint32_t count);
 84: uint32_t write_file(uint32_t count, void *buffer, struct ff7_file *file);
 85: uint32_t get_filesize(struct ff7_file *file);
 86: uint32_t tell_file(struct ff7_file *file);
 87: void seek_file(struct ff7_file *file, uint32_t offset);
 88: char *make_pc_name(struct file_context *file_context, struct ff7_file *file, char *filename);
 89: int ff7_read_field_file(char* path);
 90: 
 91: // graphics
 92: void destroy_d3d2_indexed_primitive(struct indexed_primitive *ip);
 93: uint32_t ff7gl_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *_hundred_data, struct p_group *_group_data, struct polygon_data *polygon_data, struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object);
 94: struct tex_header *sub_673F5C(struct struc_91 *struc91);
 95: void draw_single_triangle(struct nvertex *vertices);
 96: void sub_6B2720(struct indexed_primitive *ip);
 97: void draw_3d_model(uint32_t current_frame, struct anim_header *anim_header, struct struc_110 *struc_110, struct hrc_data *hrc_data, struct ff7_game_obj *game_object);
 98: void fill_light_data(struct light_data* pOutLightData, struct ff7_polygon_set *polygon_set);
 99: void update_view_matrix(struct ff7_game_obj *game_object);
100: 
101: // loaders
102: struct anim_header *load_animation(struct file_context *file_context, char *filename);
103: struct battle_hrc_header *read_battle_hrc(uint32_t use_file_context, struct file_context *file_context, char *filename);
104: struct polygon_data *load_p_file(struct file_context *file_context, uint32_t create_lists, char *filename);
105: void destroy_tex_header(struct ff7_tex_header *tex_header);
106: struct ff7_tex_header *load_tex_file(struct file_context *file_context, char *filename);
107: 
108: // dsound
109: int ff7_dsound_create(HWND hwnd, LPGUID guid);
110: void ff7_dsound_release();
111: int ff7_dsound_createsoundbuffer(const WAVEFORMATEX *waveFormatEx);
112: 
113: // minigames
114: void ff7_condor_fix_unit_texture_load(uint32_t unk, struc_3 *struc_3);
115: void __fastcall ff7_snowboard_parse_model_vertices(snowboard_this* _this, void* edx, const matrix *matrix, int current_obj, int obj_type, int unk);
</file>

<file path="src/ff7/dsound.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #include <windows.h>
24: 
25: int ff7_dsound_create(HWND hwnd, LPGUID guid)
26: {
27:   return 1; // Allow the engine to think everything went well
28: }
29: 
30: void ff7_dsound_release()
31: {
32:   // Just do nothing
33: }
34: 
35: int ff7_dsound_createsoundbuffer(const WAVEFORMATEX *waveFormatEx)
36: {
37:   return 1; // Allow the engine to think everything went well
38: }
</file>

<file path="src/ff7/file.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <string.h>
 23: #include <sys/stat.h>
 24: #include <io.h>
 25: 
 26: #include "../ff7.h"
 27: #include "../log.h"
 28: #include "../redirect.h"
 29: 
 30: FILE *open_lgp_file(char *filename, uint32_t mode)
 31: {
 32: 	char _filename[260]{ 0 };
 33: 	if(trace_all || trace_files) ffnx_trace("opening lgp file %s\n", filename);
 34: 
 35: 	int redirect_status = attempt_redirection(filename, _filename, sizeof(_filename));
 36: 
 37: 	if (redirect_status == -1)
 38: 	{
 39: 		strcpy(_filename, filename);
 40: 	}
 41: 
 42: 	return fopen(_filename, "rb");
 43: }
 44: 
 45: void close_lgp_file(FILE *fd)
 46: {
 47: 	if(!fd) return;
 48: 
 49: 	if(trace_all || trace_files) ffnx_trace("closing lgp file\n");
 50: 
 51: 	fclose(fd);
 52: }
 53: 
 54: // LGP names used for modpath lookup
 55: char lgp_names[18][256] = {
 56: 	"char",
 57: 	"flevel",
 58: 	"battle",
 59: 	"magic",
 60: 	"menu",
 61: 	"world",
 62: 	"condor",
 63: 	"chocobo",
 64: 	"high",
 65: 	"coaster",
 66: 	"snowboard",
 67: 	"midi",
 68: 	"",
 69: 	"",
 70: 	"moviecam",
 71: 	"cr",
 72: 	"disc",
 73: 	"sub",
 74: };
 75: 
 76: struct lgp_file
 77: {
 78: 	uint32_t is_lgp_offset;
 79: 	union
 80: 	{
 81: 		uint32_t offset;
 82: 		FILE *fd;
 83: 	};
 84: 	uint32_t resolved_conflict;
 85: };
 86: 
 87: #define NUM_LGP_FILES 64
 88: 
 89: struct lgp_file *lgp_files[NUM_LGP_FILES];
 90: uint32_t lgp_files_index = 0;
 91: 
 92: struct lgp_file *last;
 93: 
 94: char lgp_current_dir[256];
 95: 
 96: uint32_t use_files_array = true;
 97: 
 98: int lgp_lookup_value(unsigned char c)
 99: {
100: 	c = tolower(c);
101: 
102: 	if(c == '.') return -1;
103: 
104: 	if(c < 'a' && c >= '0' && c <= '9') c += 'a' - '0';
105: 
106: 	if(c == '_') c = 'k';
107: 	if(c == '-') c = 'l';
108: 
109: 	return c - 'a';
110: }
111: 
112: uint32_t lgp_chdir(char *path)
113: {
114: 	uint32_t len = strlen(path);
115: 
116: 	while(path[0] == '/' || path[0] == '\\') path++;
117: 
118: 	memcpy(lgp_current_dir, path, len + 1);
119: 
120: 	while(lgp_current_dir[len - 1] == '/' || lgp_current_dir[len - 1] == '\\') len--;
121: 	lgp_current_dir[len] = 0;
122: 
123: 	return true;
124: }
125: 
126: // original LGP open file logic, unchanged except for the LGP Tools safety net
127: uint32_t original_lgp_open_file(char *filename, uint32_t lgp_num, struct lgp_file *ret)
128: {
129: 	uint32_t lookup_value1 = lgp_lookup_value(filename[0]);
130: 	uint32_t lookup_value2 = lgp_lookup_value(filename[1]) + 1;
131: 	struct lookup_table_entry *lookup_table = ff7_externals.lgp_lookup_tables[lgp_num];
132: 	uint32_t toc_offset = lookup_table[lookup_value1 * 30 + lookup_value2].toc_offset;
133: 	uint32_t i;
134: 
135: 	// did we find anything in the lookup table?
136: 	if(toc_offset)
137: 	{
138: 		uint32_t num_files = lookup_table[lookup_value1 * 30 + lookup_value2].num_files;
139: 
140: 		// look for our file
141: 		for(i = 0; i < num_files; i++)
142: 		{
143: 			struct lgp_toc_entry *toc_entry = &ff7_externals.lgp_tocs[lgp_num * 2][toc_offset + i - 1];
144: 
145: 			if(!_stricmp(toc_entry->name, filename))
146: 			{
147: 				if(!toc_entry->conflict)
148: 				{
149: 					// this is the only file with this name, we're done here
150: 					ret->is_lgp_offset = true;
151: 					ret->offset = toc_entry->offset;
152: 					return true;
153: 				}
154: 				else
155: 				{
156: 					struct conflict_list *conflict = &ff7_externals.lgp_folders[lgp_num].conflicts[toc_entry->conflict - 1];
157: 					struct conflict_entry *conflict_entries = conflict->conflict_entries;
158: 					uint32_t num_conflicts = conflict->num_conflicts;
159: 
160: 					// there are multiple files with this name, look for our
161: 					// current directory in the conflict table
162: 					for(i = 0; i < num_conflicts; i++)
163: 					{
164: 						if(!_stricmp(conflict_entries[i].name, lgp_current_dir))
165: 						{
166: 							struct lgp_toc_entry *toc_entry = &ff7_externals.lgp_tocs[lgp_num * 2][conflict_entries[i].toc_index];
167: 
168: 							// file name and directory matches, this is our file
169: 							ret->is_lgp_offset = true;
170: 							ret->offset = toc_entry->offset;
171: 							ret->resolved_conflict = true;
172: 							return true;
173: 						}
174: 					}
175: 
176: 					break;
177: 				}
178: 			}
179: 		}
180: 	}
181: 
182: 	// one last chance, the lookup table might have been broken by LGP Tools,
183: 	// search through the entire archive
184: 	for(i = 0; i < ((uint32_t *)ff7_externals.lgp_tocs)[lgp_num * 2 + 1]; i++)
185: 	{
186: 		struct lgp_toc_entry *toc_entry = &ff7_externals.lgp_tocs[lgp_num * 2][i];
187: 
188: 		if(!_stricmp(toc_entry->name, filename))
189: 		{
190: 			ffnx_glitch("broken LGP file (%s), don't use LGP Tools!\n", lgp_names[lgp_num]);
191: 
192: 			if(!toc_entry->conflict)
193: 			{
194: 				ret->is_lgp_offset = true;
195: 				ret->offset = toc_entry->offset;
196: 				return true;
197: 			}
198: 		}
199: 	}
200: 
201: 	return false;
202: }
203: 
204: // new LGP open file logic with modpath and direct mode support
205: struct lgp_file *lgp_open_file(char *filename, uint32_t lgp_num)
206: {
207: 	struct lgp_file *ret = (lgp_file*)external_calloc(sizeof(*ret), 1);
208: 	char tmp[512 + sizeof(basedir)];
209: 	char _fname[_MAX_FNAME];
210: 	char *fname = _fname;
211: 	char ext[_MAX_EXT];
212: 	char name[_MAX_FNAME + _MAX_EXT];
213: 
214: 	_splitpath(filename, 0, 0, fname, ext);
215: 
216: 	if(!direct_mode_path.empty())
217: 	{
218: 		_snprintf(tmp, sizeof(tmp), "%s/%s/%s/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
219: 		ret->fd = fopen(tmp, "rb");
220: 
221: 		if(!ret->fd)
222: 		{
223: 			_snprintf(tmp, sizeof(tmp), "%s/%s/%s.lgp/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
224: 			ret->fd = fopen(tmp, "rb");
225: 		}
226: 
227: 		// Try to load special language named lgp files
228: 		if(!ret->fd)
229: 		{
230: 			switch (lgp_num) {
231: 				case 4: // menu
232: 				case 5: // world
233: 				case 15: // cr
234: 				case 16: // disc
235: 					_snprintf(tmp, sizeof(tmp), "%s/%s/%s_us.lgp/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
236: 					break;
237: 				case 8: // high
238: 				case 10: // snowboard
239: 					_snprintf(tmp, sizeof(tmp), "%s/%s/%s-us.lgp/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], fname, ext);
240: 					break;
241: 			}
242: 			ret->fd = fopen(tmp, "rb");
243: 		}
244: 
245: 		if(!ret->fd)
246: 		{
247: 			_snprintf(tmp, sizeof(tmp), "%s/%s/%s/%s/%s%s", basedir, direct_mode_path.c_str(), lgp_names[lgp_num], lgp_current_dir, fname, ext);
248: 			ret->fd = fopen(tmp, "rb");
249: 			if(ret->fd) ret->resolved_conflict = true;
250: 		}
251: 
252: 		if(ret->fd && (trace_all || trace_direct)) ffnx_trace("lgp_open_file: %i, %s (%s) [%s] = 0x%x\n", lgp_num, filename, lgp_current_dir, tmp, ret);
253: 	}
254: 
255: 	if(!ret->fd)
256: 	{
257: 		sprintf(name, "%s%s", fname, ext);
258: 
259: 		if(!original_lgp_open_file(name, lgp_num, ret))
260: 		{
261: 			if(!direct_mode_path.empty()) ffnx_error("failed to find file %s; tried %s/%s/%s, %s/%s/%s/%s, %s/%s (LGP) (path: %s)\n", filename, direct_mode_path.c_str(), lgp_names[lgp_num], name, direct_mode_path.c_str(), lgp_names[lgp_num], lgp_current_dir, name, lgp_names[lgp_num], name, lgp_current_dir);
262: 			else ffnx_error("failed to find file %s/%s (LGP) (path: %s)\n", lgp_names[lgp_num], name, lgp_current_dir);
263: 			external_free(ret);
264: 			return 0;
265: 		}
266: 
267: 		if(trace_all || trace_direct) ffnx_trace("lgp_open_file: %i, %s (%s) [ORIGINAL] = 0x%x\n", lgp_num, filename, lgp_current_dir, ret);
268: 	}
269: 
270: 	last = ret;
271: 
272: 	if(use_files_array && !ret->is_lgp_offset)
273: 	{
274: 		if(lgp_files[lgp_files_index])
275: 		{
276: 			fclose(lgp_files[lgp_files_index]->fd);
277: 			external_free(lgp_files[lgp_files_index]);
278: 		}
279: 
280: 		lgp_files[lgp_files_index] = ret;
281: 		lgp_files_index = (lgp_files_index + 1) % NUM_LGP_FILES;
282: 	}
283: 
284: 	return ret;
285: }
286: 
287: /*
288:  * Direct LGP file access routines are used all over the place despite the nice
289:  * generic file interface found below in this file. Therefore we must implement
290:  * these in a way that works with the original code.
291:  */
292: 
293: // seek to given offset in LGP file
294: uint32_t lgp_seek_file(uint32_t offset, uint32_t lgp_num)
295: {
296: 	if(!ff7_externals.lgp_fds[lgp_num]) return false;
297: 
298: 	fseek(ff7_externals.lgp_fds[lgp_num], offset, SEEK_SET);
299: 
300: 	return true;
301: }
302: 
303: // read straight from LGP file
304: uint32_t lgp_read(uint32_t lgp_num, char *dest, uint32_t size)
305: {
306: 	if(!ff7_externals.lgp_fds[lgp_num]) return 0;
307: 
308: 	if(last->is_lgp_offset) return fread(dest, 1, size, ff7_externals.lgp_fds[lgp_num]);
309: 
310: 	return fread(dest, 1, size, last->fd);
311: }
312: 
313: // read from LGP file by LGP file descriptor
314: uint32_t lgp_read_file(struct lgp_file *file, uint32_t lgp_num, char *dest, uint32_t size)
315: {
316: 	if(!ff7_externals.lgp_fds[lgp_num]) return 0;
317: 
318: 	if(file->is_lgp_offset)
319: 	{
320: 		lgp_seek_file(file->offset + 24, lgp_num);
321: 		return fread(dest, 1, size, ff7_externals.lgp_fds[lgp_num]);
322: 	}
323: 
324: 	return fread(dest, 1, size, file->fd);
325: }
326: 
327: // retrieve the size of a file within the LGP archive
328: uint32_t lgp_get_filesize(struct lgp_file *file, uint32_t lgp_num)
329: {
330: 	if(file->is_lgp_offset)
331: 	{
332: 		uint32_t size;
333: 
334: 		lgp_seek_file(file->offset + 20, lgp_num);
335: 		fread(&size, 4, 1, ff7_externals.lgp_fds[lgp_num]);
336: 		return size;
337: 	}
338: 	else
339: 	{
340: 		struct stat s;
341: 
342: 		fstat(_fileno(file->fd), &s);
343: 
344: 		return s.st_size;
345: 	}
346: }
347: 
348: // close a file handle
349: void close_file(struct ff7_file *file)
350: {
351: 	if(!file) return;
352: 
353: 	if(file->fd)
354: 	{
355: 		if(!file->fd->is_lgp_offset && file->fd->fd) fclose(file->fd->fd);
356: 		external_free(file->fd);
357: 	}
358: 
359: 	external_free(file->name);
360: 	external_free(file);
361: }
362: 
363: // open file handle, target could be a file within an LGP archive or a regular
364: // file on disk
365: struct ff7_file *open_file(struct file_context *file_context, char *filename)
366: {
367: 	char mangled_name[200];
368: 	struct ff7_file *ret = (ff7_file*)external_calloc(sizeof(*ret), 1);
369: 	char _filename[260]{ 0 };
370: 	int redirect_status = 0;
371: 
372: 	if (!ret) return 0;
373: 
374: 	if(trace_all || trace_files)
375: 	{
376: 		if(file_context->use_lgp) ffnx_trace("open %s (LGP:%s)\n", filename, lgp_names[file_context->lgp_num]);
377: 		else ffnx_trace("open %s (mode %i)\n", filename, file_context->mode);
378: 	}
379: 
380: 	if (!file_context->use_lgp)
381: 	{
382: 		// File was not found, but was required
383: 		if (redirect_path_with_override(filename, _filename, sizeof(_filename)) == 1)
384: 		{
385: 			strcpy(_filename, filename);
386: 
387: 			goto error;
388: 		}
389: 	}
390: 	else
391: 		// LGP files can be loaded safely from data, as Steam/eStore does not override them
392: 		strcpy(_filename, filename);
393: 
394: 	ret->name = (char*)external_malloc(strlen(_filename) + 1);
395: 	strcpy(ret->name, _filename);
396: 	memcpy(&ret->context, file_context, sizeof(*file_context));
397: 
398: 	// file name mangler used mainly by battle module to convert PSX file names
399: 	// to LGP-friendly PC names
400: 	if(file_context->name_mangler)
401: 	{
402: 		file_context->name_mangler(_filename, mangled_name);
403: 		strcpy(_filename, mangled_name);
404: 
405: 		if(trace_all || trace_files) ffnx_trace("mangled name: %s\n", mangled_name);
406: 	}
407: 
408: 	if(file_context->use_lgp)
409: 	{
410: 		use_files_array = false;
411: 		ret->fd = lgp_open_file(_filename, ret->context.lgp_num);
412: 		use_files_array = true;
413: 		if(!ret->fd)
414: 		{
415: 			if(file_context->name_mangler) ffnx_error("offset error: %s %s\n", _filename, mangled_name);
416: 			else ffnx_error("offset error: %s\n", _filename);
417: 			goto error;
418: 		}
419: 
420: 		if(!lgp_seek_file(ret->fd->offset + 24, ret->context.lgp_num))
421: 		{
422: 			ffnx_error("seek error: %s\n", _filename);
423: 			goto error;
424: 		}
425: 	}
426: 	else
427: 	{
428: 		ret->fd = (lgp_file*)external_calloc(sizeof(*ret->fd), 1);
429: 
430: 		if(ret->context.mode == FF7_FMODE_READ) ret->fd->fd = fopen(_filename, "rb");
431: 		else if(ret->context.mode == FF7_FMODE_READ_TEXT) ret->fd->fd = fopen(_filename, "r");
432: 		else if(ret->context.mode == FF7_FMODE_WRITE) ret->fd->fd = fopen(_filename, "wb");
433: 		else if(ret->context.mode == FF7_FMODE_CREATE) ret->fd->fd = fopen(_filename, "w+b");
434: 		else ret->fd->fd = fopen(_filename, "r+b");
435: 
436: 		if(!ret->fd->fd) goto error;
437: 	}
438: 
439: 	return ret;
440: 
441: error:
442: 	// it's normal for save files to be missing, anything else is probably
443: 	// going to cause trouble
444: 	if(file_context->use_lgp || _stricmp(&_filename[strlen(_filename) - 4], ".ff7")) ffnx_error("could not open file %s\n", _filename);
445: 	close_file(ret);
446: 	return 0;
447: }
448: 
449: // read from file handle, returns how many bytes were actually read
450: uint32_t __read_file(uint32_t count, void *buffer, struct ff7_file *file)
451: {
452: 	uint32_t ret = 0;
453: 
454: 	if(!file || !count) return false;
455: 
456: 	if(trace_all || trace_files) ffnx_trace("reading %i bytes from %s (ALT)\n", count, file->name);
457: 
458: 	if(file->context.use_lgp) return lgp_read(file->context.lgp_num, (char*)buffer, count);
459: 
460: 	ret = fread(buffer, 1, count, file->fd->fd);
461: 
462: 	if(ferror(file->fd->fd))
463: 	{
464: 		ffnx_error("could not read from file %s (%i)\n", file->name, ret);
465: 		return -1;
466: 	}
467: 
468: 	return ret;
469: }
470: 
471: // read from file handle, returns true if the read succeeds
472: uint32_t read_file(uint32_t count, void *buffer, struct ff7_file *file)
473: {
474: 	uint32_t ret = 0;
475: 
476: 	if(!file || !count) return false;
477: 
478: 	if(trace_all || trace_files) ffnx_trace("reading %i bytes from %s\n", count, file->name);
479: 
480: 	if(file->context.use_lgp) return lgp_read(file->context.lgp_num, (char*)buffer, count);
481: 
482: 	ret = fread(buffer, 1, count, file->fd->fd);
483: 
484: 	if(ret != count)
485: 	{
486: 		ffnx_error("could not read from file %s (%i)\n", file->name, ret);
487: 		return false;
488: 	}
489: 
490: 	return true;
491: }
492: 
493: // read directly from a file descriptor returned by the open_file function
494: uint32_t __read(FILE *file, char *buffer, uint32_t count)
495: {
496: 	return fread(buffer, 1, count, file);
497: }
498: 
499: // write to file handle, returns true if the write succeeds
500: uint32_t write_file(uint32_t count, void *buffer, struct ff7_file *file)
501: {
502: 	uint32_t ret = 0;
503: 	void *tmp = 0;
504: 
505: 	if(!file || !count) return false;
506: 
507: 	if(file->context.use_lgp) return false;
508: 
509: 	if(trace_all || trace_files) ffnx_trace("writing %i bytes to %s\n", count, file->name);
510: 
511: 	// hack to emulate win95 style writes, a NULL buffer means we should write
512: 	// all zeroes
513: 	if(!buffer)
514: 	{
515: 		tmp = driver_calloc(count, 1);
516: 		buffer = tmp;
517: 	}
518: 
519: 	ret = fwrite(buffer, 1, count, file->fd->fd);
520: 
521: 	if(tmp) driver_free(tmp);
522: 
523: 	if(ret != count)
524: 	{
525: 		ffnx_error("could not write to file %s\n", file->name);
526: 		return false;
527: 	}
528: 
529: 	return true;
530: }
531: 
532: // retrieve the size of a file from file handle
533: uint32_t get_filesize(struct ff7_file *file)
534: {
535: 	if(!file) return 0;
536: 
537: 	if(trace_all || trace_files) ffnx_trace("get_filesize %s\n", file->name);
538: 
539: 	if(file->context.use_lgp) return lgp_get_filesize(file->fd, file->context.lgp_num);
540: 	else
541: 	{
542: 		struct stat s;
543: 		fstat(_fileno(file->fd->fd), &s);
544: 
545: 		return s.st_size;
546: 	}
547: }
548: 
549: // retrieve the current seek position from file handle
550: uint32_t tell_file(struct ff7_file *file)
551: {
552: 	if(!file) return 0;
553: 
554: 	if(trace_all || trace_files) ffnx_trace("tell %s\n", file->name);
555: 
556: 	if(file->context.use_lgp) return 0;
557: 
558: 	return ftell(file->fd->fd);
559: }
560: 
561: // seek to position in file
562: void seek_file(struct ff7_file *file, uint32_t offset)
563: {
564: 	if(!file) return;
565: 
566: 	if(trace_all || trace_files) ffnx_trace("seek %s to %i\n", file->name, offset);
567: 
568: 	// it's not possible to seek within LGP archives
569: 	if(file->context.use_lgp) return;
570: 
571: 	if(fseek(file->fd->fd, offset, SEEK_SET)) ffnx_error("could not seek file %s\n", file->name);
572: }
573: 
574: // construct modpath name from file context, file handle and filename
575: char *make_pc_name(struct file_context *file_context, struct ff7_file *file, char *filename)
576: {
577: 	uint32_t i, len;
578: 	char *backslash;
579: 	char* ret = (char*)external_malloc(1024);
580: 
581: 	if(file_context->use_lgp)
582: 	{
583: 		if(file->fd->resolved_conflict) len = _snprintf(ret, 1024, "%s/%s/%s", lgp_names[file_context->lgp_num], lgp_current_dir, filename);
584: 		else len = _snprintf(ret, 1024, "%s/%s", lgp_names[file_context->lgp_num], filename);
585: 	}
586: 	else len = _snprintf(ret, 1024, "%s", filename);
587: 
588: 	for(i = 0; i < len; i++)
589: 	{
590: 		if(ret[i] == '.')
591: 		{
592: 			if(!_stricmp(&ret[i], ".tex")) ret[i] = 0;
593: 			else if(!_stricmp(&ret[i], ".p")) ret[i] = 0;
594: 			else ret[i] = '_';
595: 		}
596: 	}
597: 
598: 	while(backslash = strchr(ret, '\\')) *backslash = '/';
599: 
600: 	return ret;
601: }
602: 
603: /*###########################################################
604: 	FF7 CHUNKED FIELD FILES
605: ###########################################################*/
606: 
607: #define FF7_FIELD_NUM_SECTIONS 9
608: #define FF7_FIELD_OFFSET 0x2A
609: 
610: struct {
611: 	uint32_t size = 0;
612: 	byte* data;
613: } ff7_field_file_chunked[FF7_FIELD_NUM_SECTIONS];
614: 
615: int ff7_read_field_file(char* path)
616: {
617: 	char filepath[256];
618: 
619: 	if ( *ff7_externals.field_resuming_from_battle_CFF268 ) return 1;
620: 
621:   _splitpath(path, NULL, NULL, filepath, NULL);
622: 
623:   lgp_file* lgp_file = lgp_open_file(filepath, 1);
624:   if ( !lgp_file ) return 0;
625: 
626:   uint32_t size = lgp_get_filesize(lgp_file, 1);
627:   char* dest = (char*)driver_malloc(size);
628:   char* original_field_data = (char*)driver_malloc(*ff7_externals.known_field_buffer_size);
629: 	if ( !ff7_externals.field_file_buffer )
630: 	{
631: 		driver_free(original_field_data);
632: 		return 0;
633: 	}
634: 
635:   lgp_read_file(lgp_file, 1, dest, size);
636:   ff7_externals.lzss_decode(dest, original_field_data);
637: 	if ( dest )
638:   {
639:     driver_free(dest);
640:     dest = 0;
641:   }
642: 
643: 	// Attempt to override part of the current field file with chunk files
644: 	char chunk_file[1024]{0};
645: 	uint32_t data_ptr = 0, data_len = 0, next_data_ptr = 0;
646: 	FILE* fd;
647: 
648: 	for (int n = 0; n < FF7_FIELD_NUM_SECTIONS; n++)
649: 	{
650: 		_snprintf(chunk_file, sizeof(chunk_file), "%s/%s/%s.lgp/%s.chunk.%i", basedir, direct_mode_path.c_str(), lgp_names[1], filepath, n+1);
651: 
652: 		if ((fd = fopen(chunk_file, "rb")) != NULL)
653: 		{
654: 			fseek(fd, 0L, SEEK_END);
655: 			ff7_field_file_chunked[n].size = ftell(fd);
656: 			ff7_field_file_chunked[n].data = new byte[ff7_field_file_chunked[n].size];
657: 
658: 			fseek(fd, 0L, SEEK_SET);
659: 			fread(ff7_field_file_chunked[n].data, sizeof(byte), ff7_field_file_chunked[n].size, fd);
660: 
661: 			fclose(fd);
662: 		}
663: 		else
664: 		{
665: 			data_ptr = *(uint32_t*)(original_field_data + 0x6 + 0x4 * n);
666: 
667: 			// if this isn't the last section
668: 			if (n < (FF7_FIELD_NUM_SECTIONS-1))
669: 			{
670: 				next_data_ptr = *(uint32_t*)(original_field_data + 0x6 + 0x4 * (n + 1));
671: 
672: 				// the lgp might be lying about the length of the section! recalculate it.
673: 				data_len = next_data_ptr - data_ptr - 0x4;
674: 			}
675: 			else
676: 			{
677: 				// there is no section after, so we have to trust it.
678: 				data_len = *(uint32_t*)(original_field_data + data_ptr);
679: 			}
680: 
681: 			ff7_field_file_chunked[n].size = data_len;
682: 			ff7_field_file_chunked[n].data = new byte[ff7_field_file_chunked[n].size];
683: 
684: 			memcpy(ff7_field_file_chunked[n].data, original_field_data + data_ptr + 0x4, ff7_field_file_chunked[n].size);
685: 		}
686: 	}
687: 
688: 	// Allocate the new field file
689: 	driver_free(original_field_data);
690: 	*ff7_externals.field_file_buffer = (char*)external_malloc(*ff7_externals.known_field_buffer_size);
691: 
692: 	// Build the new field file
693: 	*(short*)(*ff7_externals.field_file_buffer) = 0x0; // 0x0
694: 	*(int*)(*ff7_externals.field_file_buffer + 0x2) = FF7_FIELD_NUM_SECTIONS; // 0x2
695: 	uint32_t offset = FF7_FIELD_OFFSET;
696: 	for (int n = 0; n < FF7_FIELD_NUM_SECTIONS; n++)
697: 	{
698: 		// Pointer to data section
699: 		ff7_externals.field_file_section_ptrs[n] = offset;
700: 		*(int*)(*ff7_externals.field_file_buffer + 0x6 + (0x4 * n)) = ff7_externals.field_file_section_ptrs[n];
701: 
702: 		// Length of data section
703: 		*(int*)(*ff7_externals.field_file_buffer + offset) = ff7_field_file_chunked[n].size;
704: 
705: 		// The data
706: 		offset += 0x4;
707: 		memcpy(*ff7_externals.field_file_buffer + offset, ff7_field_file_chunked[n].data, ff7_field_file_chunked[n].size);
708: 		offset += ff7_field_file_chunked[n].size;
709: 
710: 		// Cleanup
711: 		delete ff7_field_file_chunked[n].data;
712: 	}
713: 
714:   return 1;
715: }
</file>

<file path="src/ff7/graphics.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #define _USE_MATH_DEFINES
 24: #include <math.h>
 25: #include "../renderer.h"
 26: 
 27: #include "../ff7.h"
 28: #include "../macro.h"
 29: #include "../log.h"
 30: #include "../gl.h"
 31: #include "defs.h"
 32: 
 33: /*
 34:  * Most of these functions are lifted from the game with only minor changes to
 35:  * replace Direct3D calls. Modifying or even attempting to understand most of
 36:  * this code is not recommended.
 37:  */
 38: 
 39: void destroy_d3d2_indexed_primitive(struct indexed_primitive *ip)
 40: {
 41: 	if(!ip) return;
 42: 
 43: 	if(ip->vertices) external_free(ip->vertices);
 44: 	if(ip->indices) external_free(ip->indices);
 45: 
 46: 	external_free(ip);
 47: }
 48: 
 49: uint32_t ff7gl_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *_hundred_data, struct p_group *_group_data, struct polygon_data *polygon_data, struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object)
 50: {
 51: 	struct indexed_primitive *ip;
 52: 	struct p_hundred *hundred_data;
 53: 	struct p_group *group_data;
 54: 	uint32_t numvert;
 55: 	uint32_t numpoly;
 56: 	uint32_t offvert;
 57: 	uint32_t offpoly;
 58: 	uint32_t offtex;
 59: 	uint32_t i;
 60: 
 61: 	if(!polygon_data) return false;
 62: 	if(!polygon_set->indexed_primitives) return false;
 63: 	if(group_num >= polygon_data->numgroups) return false;
 64: 
 65: 	ip = (indexed_primitive*)external_calloc(sizeof(*ip), 1);
 66: 
 67: 	ip->primitivetype = RendererPrimitiveType::PT_TRIANGLES;
 68: 	ip->vertex_size = sizeof(struct nvertex);
 69: 
 70: 	group_data = &polygon_data->groupdata[group_num];
 71: 	hundred_data = &polygon_data->hundredsdata[group_num];
 72: 	numvert = group_data->numvert;
 73: 	numpoly = group_data->numpoly;
 74: 	offvert = group_data->offvert;
 75: 	offpoly = group_data->offpoly;
 76: 	offtex = group_data->offtex;
 77: 
 78: 	ip->vertexcount = numvert;
 79: 	ip->indexcount = numpoly * 3;
 80: 	ip->vertices = (nvertex*)external_calloc(sizeof(*ip->vertices), ip->vertexcount);
 81: 	ip->indices = (WORD*)external_calloc(sizeof(*ip->indices), ip->indexcount);
 82: 
 83: 	if(polygon_data->vertextype == 0) ip->vertextype = VERTEX;
 84: 	else if(polygon_data->vertextype == 1) ip->vertextype = LVERTEX;
 85: 	else if(polygon_data->vertextype == 2) ip->vertextype = TLVERTEX;
 86: 
 87: 	for(i = 0; i < numvert; i++)
 88: 	{
 89: 		if(polygon_data->vertdata) memcpy(&ip->vertices[i]._, &polygon_data->vertdata[offvert + i], sizeof(ip->vertices[i]._));
 90: 		if(polygon_data->vertexcolordata) memcpy(&ip->vertices[i].color.color, &polygon_data->vertexcolordata[offvert + i], sizeof(ip->vertices[i].color.color));
 91: 		if(group_data->textured && polygon_data->texcoorddata) memcpy(&ip->vertices[i].u, &polygon_data->texcoorddata[offtex + i], sizeof(polygon_data->texcoorddata[i]));
 92: 
 93: 		if(hundred_data && (hundred_data->field_4 & BIT(V_ALPHABLEND))) ip->vertices[i].color.a = hundred_data->vertex_alpha;
 94: 	}
 95: 
 96: 	for(i = 0; i < numpoly; i++)
 97: 	{
 98: 		if(polygon_data->polydata)
 99: 		{
100: 			struct p_polygon *poly_data = &polygon_data->polydata[offpoly + i];
101: 
102: 			ip->indices[i * 3] = poly_data->vertex1;
103: 			ip->indices[i * 3 + 1] = poly_data->vertex2;
104: 			ip->indices[i * 3 + 2] = poly_data->vertex3;
105: 		}
106: 	}
107: 
108: 	polygon_set->indexed_primitives[group_num] = ip;
109: 
110: 	return true;
111: }
112: 
113: void ff7gl_field_78(struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object)
114: {
115: 	struct matrix_set *matrix_set;
116: 	struct struc_49 *struc_49;
117: 	struct p_hundred *hundred_data = NULL;
118: 	struct p_group *group_data = NULL;
119: 	struct matrix *matrix = NULL;
120: 	struct struc_77 *struc_77;
121: 	struct indexed_primitive *ip = NULL;
122: 	struct nvertex *vertices = NULL;
123: 	struct struc_84 *struc_84;
124: 	struct struc_186 *struc_186;
125: 	uint32_t instance_type = -1;
126: 	uint32_t group_counter = 0;
127: 	uint32_t instanced = false;
128: 	uint32_t correct_frame = false;
129: 	uint32_t instance_transform_mode;
130: 	struct matrix tmp_matrix;
131: 	struct matrix *model_matrix = 0;
132: 
133: 	if(trace_all) ffnx_trace("dll_gfx: field_78 0x%x\n", polygon_set);
134: 
135: 	if(!game_object->in_scene) return;
136: 
137: 	if(!polygon_set) return;
138: 
139: 	if(!polygon_set->field_0) return;
140: 
141: 	if(trace_all) ffnx_trace("field_78: %s (%i groups) (0x%x)\n", polygon_set->polygon_data ? polygon_set->polygon_data->pc_name : "unknown", polygon_set->numgroups, polygon_set);
142: 
143: 	matrix_set = polygon_set->matrix_set;
144: 
145: 	if(matrix_set) model_matrix = matrix_set->matrix_view;
146: 
147: 	struc_49 = &polygon_set->field_14;
148: 
149: 	if(struc_49->field_0)
150: 	{
151: 		instanced = true;
152: 
153: 		correct_frame = (struc_49->graphics_instance->frame_counter == struc_49->frame_counter);
154: 
155: 		instance_transform_mode = struc_49->field_8;
156: 		struc_84 = struc_49->struc_84;
157: 
158: 		if(struc_84) instance_type = struc_84->field_4;
159: 
160: 		if(trace_all) ffnx_trace("instanced, %s, type %i, transform %i\n", correct_frame ? "correct frame" : "wrong frame", instance_type, instance_transform_mode);
161: 	}
162: 
163: 	if(polygon_set->field_2C) hundred_data = polygon_set->hundred_data;
164: 	if(polygon_set->polygon_data) group_data = polygon_set->polygon_data->groupdata;
165: 
166: 	while(group_counter < polygon_set->numgroups)
167: 	{
168: 		uint32_t defer = false;
169: 		uint32_t zsort = false;
170: 
171: 		struc_84 = struc_49->struc_84;
172: 
173: 		if(polygon_set->indexed_primitives) ip = polygon_set->indexed_primitives[group_counter];
174: 
175: 		if(ip) vertices = ip->vertices;
176: 
177: 		if(polygon_set->per_group_hundreds) hundred_data = polygon_set->hundred_data_group_array[group_counter];
178: 
179: 		if(hundred_data)
180: 		{
181: 			if(game_object->field_91C && hundred_data->zsort) zsort = true;
182: 			else if(!game_object->field_928) defer = (hundred_data->options & (BIT(V_ALPHABLEND) | BIT(V_TMAPBLEND)));
183: 		}
184: 
185: 		if(trace_all) ffnx_trace("group %i: %s, %s\n", group_counter, zsort ? "zsort" : "no zsort", defer ? "deferred" : "not deferred");
186: 
187: 		if(!defer) common_setrenderstate(hundred_data, (struct game_obj *)game_object);
188: 
189: 		if(matrix_set && matrix_set->matrix_projection) gl_set_d3dprojection_matrix(matrix_set->matrix_projection);
190: 
191: 		if(instanced)
192: 		{
193: 			if(correct_frame)
194: 			{
195: 				while(struc_84)
196: 				{
197: 					if(trace_all) ffnx_trace("drawing instance 0x%x\n", struc_84);
198: 
199: 					if(instance_type == 2)
200: 					{
201: 						if(instance_transform_mode == 1) matrix = &struc_84->matrix;
202: 						else if(instance_transform_mode == 2)
203: 						{
204: 							multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &tmp_matrix);
205: 							matrix = &tmp_matrix;
206: 						}
207: 
208: 						if(matrix && matrix_set && !zsort) gl_set_worldview_matrix(matrix);
209: 
210: 						struc_186 = struc_84->struc_186;
211: 
212: 						if(struc_186->polytype == 0x11) vertices = struc_186->nvertex_pointer;
213: 						else ff7_externals.sub_671742(zsort, hundred_data, struc_186);
214: 
215: 						if(zsort) ff7_externals.sub_665D9A(matrix, vertices, ip, hundred_data, struc_186, game_object);
216: 						else gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, vertices, 0, ip->vertexcount, ip->indices, ip->indexcount, 0, 0, 0, polygon_set->field_4, true);
217: 					}
218: 					else if(defer)
219: 					{
220: 						struc_77 = (struct struc_77*)ff7_externals.sub_6A2865(game_object->_3dobject_pool);
221: 
222: 						if(struc_77)
223: 						{
224: 							struc_77->current_group = group_counter;
225: 							struc_77->polygon_set = (struct polygon_set *)polygon_set;
226: 							struc_77->hundred_data = hundred_data;
227: 
228: 							if(polygon_set->has_struc_173) memcpy(&struc_77->struc_173, polygon_set->struc_173, sizeof(*polygon_set->struc_173));
229: 
230: 							struc_77->use_matrix = 0;
231: 							struc_77->use_matrix_pointer = 0;
232: 
233: 							if(instance_transform_mode == 1)
234: 							{
235: 								struc_77->use_matrix_pointer = 1;
236: 								struc_77->matrix_pointer = &struc_84->matrix;
237: 							}
238: 
239: 							else if(instance_transform_mode == 2)
240: 							{
241: 								struc_77->use_matrix = 1;
242: 								multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &struc_77->matrix);
243: 								ff7_externals.matrix3x4(&struc_77->matrix);
244: 							}
245: 						}
246: 					}
247: 					else if(instance_type == 0)
248: 					{
249: 						if(instance_transform_mode == 1) matrix = &struc_84->matrix;
250: 						else if(instance_transform_mode == 2)
251: 						{
252: 							multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &tmp_matrix);
253: 							matrix = &tmp_matrix;
254: 						}
255: 
256: 						if(ip)
257: 						{
258: 							if(zsort) ff7_externals.sub_665793(matrix, 0, ip, polygon_set, hundred_data, group_data, game_object);
259: 							else
260: 							{
261: 								if(matrix && matrix_set) gl_set_worldview_matrix(matrix);
262: 								gl_draw_without_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);
263: 							}
264: 						}
265: 					}
266: 					else if(instance_type == 1)
267: 					{
268: 						if(instance_transform_mode == 1) matrix = &struc_84->matrix;
269: 						else if(instance_transform_mode == 2)
270: 						{
271: 							multiply_matrix(&struc_84->matrix, game_object->camera_matrix, &tmp_matrix);
272: 							matrix = &tmp_matrix;
273: 						}
274: 
275: 						if(ip)
276: 						{
277: 							if(struc_84->struc_173.add_offsets || struc_84->struc_173.field_7)
278: 							{
279: 								ff7_externals.sub_68D2B8(group_counter, polygon_set, &struc_84->struc_173);
280: 								ff7_externals.sub_6B27A9(matrix, ip, polygon_set, hundred_data, group_data, &struc_84->struc_173, game_object);
281: 							}
282: 							else
283: 							{
284: 								if(zsort) ff7_externals.sub_665793(matrix, 0, ip, polygon_set, hundred_data, group_data, game_object);
285: 								else
286: 								{
287: 									ff7_externals.sub_68D2B8(group_counter, polygon_set, &struc_84->struc_173);
288: 
289: 									if(matrix && matrix_set) gl_set_worldview_matrix(matrix);
290: 									gl_draw_without_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);
291: 								}
292: 							}
293: 						}
294: 					}
295: 
296: 					struc_84 = struc_84->next;
297: 				}
298: 			}
299: 		}
300: 		else
301: 		{
302: 			if(trace_all) ffnx_trace("drawing single\n");
303: 
304: 			if(defer)
305: 			{
306: 				struc_77 = (struct struc_77*)ff7_externals.sub_6A2865(game_object->_3dobject_pool);
307: 
308: 				struc_77->current_group = group_counter;
309: 				struc_77->polygon_set = (struct polygon_set *)polygon_set;
310: 				struc_77->hundred_data = hundred_data;
311: 
312: 				if(polygon_set->has_struc_173) memcpy(&struc_77->struc_173, polygon_set->struc_173, sizeof(*polygon_set->struc_173));
313: 
314: 				struc_77->use_matrix = 0;
315: 				struc_77->use_matrix_pointer = 0;
316: 
317: 				if(matrix_set && matrix_set->matrix_world)
318: 				{
319: 					struc_77->use_matrix = 1;
320: 					memcpy(&struc_77->matrix, matrix_set->matrix_world, sizeof(*matrix_set->matrix_world));
321: 				}
322: 			}
323: 			else
324: 			{
325: 				if(ip)
326: 				{
327: 					if(zsort) ff7_externals.sub_665793(matrix_set->matrix_world, 0, ip, polygon_set, hundred_data, group_data, game_object);
328: 					else
329: 					{
330: 						if (matrix_set)	gl_set_worldview_matrix(matrix_set->matrix_world);
331: 						if (enable_lighting)
332: 						{					
333: 							update_view_matrix(game_object);		
334: 							if(polygon_set->light != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
335: 							{
336: 								struct light_data lightData;
337: 								fill_light_data(&lightData, polygon_set);
338: 								gl_draw_with_lighting(ip, polygon_set->polygon_data, &lightData, polygon_set->field_4);
339: 							} else 	gl_draw_with_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);						
340: 						} else 
341: 						{
342: 							if(polygon_set->light != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
343: 							{
344: 								struct light_data lightData;
345: 								fill_light_data(&lightData, polygon_set);
346: 								update_view_matrix(game_object);
347: 								gl_draw_without_lighting(ip, polygon_set->polygon_data, &lightData, polygon_set->field_4);
348: 							} else gl_draw_without_lighting(ip, polygon_set->polygon_data, nullptr, polygon_set->field_4);
349: 						}
350: 					}
351: 				}
352: 			}
353: 		}
354: 
355: 		if(hundred_data) hundred_data = &hundred_data[1];
356: 		if(group_data) group_data = &group_data[1];
357: 
358: 		group_counter++;
359: 	}
360: }
361: 
362: struct tex_header *sub_673F5C(struct struc_91 *struc91)
363: {
364: 	if(trace_all) ffnx_trace("sub_673F5C: 0x%x\n", struc91);
365: 
366: 	if(struc91->field_0 == 2) ffnx_glitch_once("unsupported framebuffer operation\n");
367: 
368: 	return make_framebuffer_tex(struc91->width, struc91->height, struc91->x_offset, struc91->y_offset, struc91->width * struc91->xscale, struc91->height * struc91->yscale, struc91->color_key);
369: }
370: 
371: void draw_single_triangle(struct nvertex *vertices)
372: {
373: 	WORD indices[] = {0, 1, 2};
374: 
375: 	newRenderer.bindVertexBuffer(vertices, 0, 3);
376: 	newRenderer.bindIndexBuffer(indices, 3);
377: 
378: 	newRenderer.isTLVertex(true);
379: 
380: 	newRenderer.draw();
381: }
382: 
383: void sub_6B2720(struct indexed_primitive *ip)
384: {
385: 	gl_draw_indexed_primitive(ip->primitivetype, TLVERTEX, ip->vertices, 0, ip->vertexcount, ip->indices, ip->indexcount, 0, 0, 0, true, true);
386: }
387: 
388: void draw_3d_model(uint32_t current_frame, struct anim_header *anim_header, struct struc_110 *struc_110, struct hrc_data *hrc_data, struct ff7_game_obj *game_object)
389: {
390: 	struct anim_frame *anim_frame;
391: 	struct stack *matrix_stack;
392: 	struct matrix *root_matrix;
393: 	void (*root_animation_sub)(struct matrix *, struct anim_frame *, struct anim_header *, struct hrc_data *);
394: 	void (*frame_animation_sub)(uint32_t, struct matrix *, vector3<float> *, struct anim_frame *, struct anim_header *, struct hrc_bone *, struct hrc_data *);
395: 
396: 	if(!anim_header) return;
397: 	if(!hrc_data) return;
398: 	if(current_frame >= anim_header->num_frames) return;
399: 
400: 	anim_frame = &anim_header->anim_frames[current_frame];
401: 
402: 	if(anim_header->use_matrix_array)
403: 	{
404: 		anim_header->current_matrix_array = &anim_header->matrix_array[(anim_header->num_bones + 1) * current_frame];
405: 	}
406: 
407: 	matrix_stack = game_object->matrix_stack1;
408: 
409: 	ff7_externals.stack_push(matrix_stack);
410: 
411: 	root_matrix = (matrix*)ff7_externals.stack_top(matrix_stack);
412: 
413: 	if(hrc_data->field_A4 && *hrc_data->field_A4)
414: 	{
415: 		root_animation_sub = ff7_externals._root_animation;
416: 		frame_animation_sub = ff7_externals._frame_animation;
417: 	}
418: 	else
419: 	{
420: 		root_animation_sub = ff7_externals.root_animation;
421: 		frame_animation_sub = ff7_externals.frame_animation;
422: 	}
423: 
424: 	root_animation_sub(root_matrix, anim_frame, anim_header, hrc_data);
425: 
426: 	if(hrc_data->flags & 0x400) memcpy(&hrc_data->field_24, root_matrix, sizeof(*root_matrix));
427: 
428: 	if(struc_110)
429: 	{
430: 		struct matrix scale_matrix;
431: 
432: 		if(struc_110->scale_factor != 1.0f)
433: 		{
434: 			float scale_factor = struc_110->scale_factor;
435: 
436: 			root_matrix->_41 *= scale_factor;
437: 			root_matrix->_42 *= scale_factor;
438: 			root_matrix->_43 *= scale_factor;
439: 
440: 			uniform_scaling_matrix(scale_factor, &scale_matrix);
441: 			multiply_matrix_unary(root_matrix, &scale_matrix);
442: 		}
443: 
444: 		if(struc_110->scale.x != 1.0f || struc_110->scale.y != 1.0f || struc_110->scale.z != 1.0f)
445: 		{
446: 			scaling_matrix(&struc_110->scale, &scale_matrix);
447: 			multiply_matrix_unary(root_matrix, &scale_matrix);
448: 
449: 			root_matrix->_41 *= struc_110->scale.x;
450: 			root_matrix->_42 *= struc_110->scale.y;
451: 			root_matrix->_43 *= struc_110->scale.z;
452: 		}
453: 
454: 		if(*ff7_externals.model_mode & MDL_USE_STRUC110_MATRIX) multiply_matrix_unary(root_matrix, &struc_110->matrix);
455: 
456: 		if(struc_110->rotation.y != 0.0) rotate_matrix_y(DEG2RAD(struc_110->rotation.y), root_matrix);
457: 		if(struc_110->rotation.x != 0.0) rotate_matrix_x(DEG2RAD(struc_110->rotation.x), root_matrix);
458: 		if(struc_110->rotation.z != 0.0) rotate_matrix_z(DEG2RAD(struc_110->rotation.z), root_matrix);
459: 
460: 		root_matrix->_41 += struc_110->position.x;
461: 		root_matrix->_42 += struc_110->position.y;
462: 		root_matrix->_43 += struc_110->position.z;
463: 	}
464: 
465: 	if(hrc_data->flags & 0x800) memcpy(&hrc_data->field_64, root_matrix, sizeof(*root_matrix));
466: 
467: 	if(hrc_data->flags & 0x2000 && struc_110->bone_positions)
468: 	{
469: 		struc_110->bone_positions[0].x = root_matrix->_41;
470: 		struc_110->bone_positions[0].y = root_matrix->_42;
471: 		struc_110->bone_positions[0].z = root_matrix->_43;
472: 	}
473: 
474: 	if(hrc_data->bone_list)
475: 	{
476: 		struct list_node *bone_list_node;
477: 
478: 		LIST_FOR_EACH(bone_list_node, hrc_data->bone_list)
479: 		{
480: 			struct bone_list_member *bone_list_member = (struct bone_list_member *)&bone_list_node->object;
481: 
482: 			if(bone_list_member->bone_type == 1)
483: 			{
484: 				uint32_t bone_index = bone_list_member->bone_index;
485: 				struct hrc_bone *bone = &hrc_data->bones[bone_index];
486: 				struct matrix *parent_matrix;
487: 				struct matrix *bone_matrix;
488: 				vector3<float> *frame_rotation;
489: 				struct matrix local_matrix;
490: 				struct matrix eye_matrix;
491: 				struct matrix *matrix;
492: 				vector3<float> dummy_point = {0.0f, 0.0f, 0.0f};
493: 
494: 				parent_matrix = (struct matrix*)ff7_externals.stack_top(matrix_stack);
495: 				ff7_externals.stack_push(matrix_stack);
496: 				bone_matrix = (struct matrix*)ff7_externals.stack_top(matrix_stack);
497: 
498: 				if(anim_header->num_bones <= bone_index) frame_rotation = &dummy_point;
499: 				else frame_rotation = &anim_frame->data[bone_index];
500: 
501: 				frame_animation_sub(bone_index, &local_matrix, frame_rotation, anim_frame, anim_header, bone, hrc_data);
502: 
503: 				multiply_matrix(&local_matrix, parent_matrix, bone_matrix);
504: 
505: 				if(*ff7_externals.model_mode & MDL_USE_CAMERA_MATRIX)
506: 				{
507: 					if(hrc_data->flags & 0x4000 && struc_110->bone_matrices) matrix = &struc_110->bone_matrices[bone_index + 1];
508: 					else matrix = &eye_matrix;
509: 
510: 					multiply_matrix(bone_matrix, game_object->camera_matrix, matrix);
511: 
512: 					matrix->_14 = 0.0f;
513: 					matrix->_24 = 0.0f;
514: 					matrix->_34 = 0.0f;
515: 					matrix->_44 = 1.0f;
516: 
517: 					if(hrc_data->flags & 0x2000 && struc_110->bone_positions)
518: 					{
519: 						struc_110->bone_positions[bone_index + 1].x = bone_matrix->_41;
520: 						struc_110->bone_positions[bone_index + 1].y = bone_matrix->_42;
521: 						struc_110->bone_positions[bone_index + 1].z = bone_matrix->_43;
522: 					}
523: 				}
524: 				else matrix = bone_matrix;
525: 
526: 				if(bone->rsd_array)
527: 				{
528: 					uint32_t i;
529: 					struct rsd_array_member *rsd_array_member;
530: 
531: 					for(i = 0, rsd_array_member = bone->rsd_array; i < bone->num_rsd; i++, rsd_array_member++)
532: 					{
533: 						struct ff7_polygon_set *polygon_set;
534: 
535: 						if(!rsd_array_member->rsd_data) continue;
536: 
537: 						polygon_set = rsd_array_member->rsd_data->polygon_set;
538: 
539: 						if(!polygon_set) continue;
540: 
541: 						common_setmatrix(0, matrix, polygon_set->matrix_set, (struct game_obj *)game_object);
542: 						if(polygon_set->matrix_set) polygon_set->matrix_set->matrix_view = (struct matrix*)external_calloc(sizeof(struct matrix), 1);
543: 						common_setmatrix(1, bone_matrix, polygon_set->matrix_set, (struct game_obj *)game_object);
544: 
545: 						if(hrc_data->flags & 0x2000000)
546: 						{
547: 							struct ff7_light *light = polygon_set->light;
548: 
549: 							if(light)
550: 							{
551: 								if(polygon_set->matrix_set) light->matrix_pointer = polygon_set->matrix_set->matrix_world;
552: 								else light->matrix_pointer = 0;
553: 
554: 								if(light->field_138)
555: 								{
556: 									struct matrix tmp;
557: 
558: 									multiply_matrix(bone_matrix, &light->normal_matrix, &tmp);
559: 
560: 									ff7_externals.sub_69C69F(&tmp, light);
561: 								}
562: 								else ff7_externals.sub_69C69F(bone_matrix, light);
563: 
564: 								common_externals.generic_light_polygon_set((struct polygon_set *)polygon_set, (struct light *)light);
565: 							}
566: 						}
567: 
568: 						if(hrc_data->field_4 && hrc_data->flags & 0x100000) ff7gl_field_78(polygon_set, game_object);
569: 					}
570: 				}
571: 			}
572: 			if(bone_list_member->bone_type == 2) ff7_externals.stack_pop(matrix_stack);
573: 		}
574: 	}
575: 
576: 	ff7_externals.stack_pop(matrix_stack);
577: }
578: 
579: void fill_light_data(struct light_data* lightData, struct ff7_polygon_set *polygon_set)
580: {
581: 	lightData->global_light_color = polygon_set->light->global_light_color_abgr_norm;
582: 	lightData->light_dir_1 = polygon_set->light->color_1->point;
583: 	lightData->light_color_1 = polygon_set->light->color_1->d3dcol;
584: 	lightData->light_dir_2 = polygon_set->light->color_2->point;
585: 	lightData->light_color_2 = polygon_set->light->color_2->d3dcol;
586: 	lightData->light_dir_3 = polygon_set->light->color_3->point;
587: 	lightData->light_color_3 = polygon_set->light->color_3->d3dcol;
588: 
589: 	lightData->scripted_light_color = {1.0, 1.0, 1.0, 1.0};
590: 
591: 	if ((polygon_set->light->flags & 4) != 0)
592: 	{
593: 		lightData->scripted_light_color.r = polygon_set->light->color.r / 255.0f;
594: 		lightData->scripted_light_color.g = polygon_set->light->color.g / 255.0f;
595: 		lightData->scripted_light_color.b = polygon_set->light->color.b / 255.0f;
596: 	}
597: }
598: 
599: void ff7_get_field_view_matrix(struct matrix *outViewMatrix)
600: {
601: 	struct matrix viewMatrix;
602: 	identity_matrix(&viewMatrix);
603: 
604: 	byte *level_data = *ff7_externals.field_level_data_pointer;
605: 	if (!level_data)
606: 	{
607: 		return;
608: 	}
609: 
610: 	ff7_camdata *field_camera_data = *ff7_externals.field_camera_data;
611: 	if (!field_camera_data)
612: 	{
613: 		return;
614: 	}
615: 
616: 	vector3<float> vx = {(float)(field_camera_data->eye.x), (float)(field_camera_data->eye.y), (float)(field_camera_data->eye.z)};
617: 	vector3<float> vy = {(float)(field_camera_data->target.x), (float)(field_camera_data->target.y), (float)(field_camera_data->target.z)};
618: 	vector3<float> vz = {(float)(field_camera_data->up.x), (float)(field_camera_data->up.y), (float)(field_camera_data->up.z)};
619: 
620: 	divide_vector(&vx, 4096.0f, &vx);
621: 	divide_vector(&vy, 4096.0f, &vy);
622: 	divide_vector(&vz, 4096.0f, &vz);
623: 
624: 	float ox = static_cast<float>(field_camera_data->position.x);
625: 	float oy = static_cast<float>(field_camera_data->position.y);
626: 	float oz = static_cast<float>(field_camera_data->position.z);
627: 
628: 	float tx = ox;
629: 	float ty = oy;
630: 	float tz = oz;
631: 
632: 	viewMatrix._11 = vx.x;
633: 	viewMatrix._21 = vx.y;
634: 	viewMatrix._31 = vx.z;
635: 	viewMatrix._12 = vy.x;
636: 	viewMatrix._22 = vy.y;
637: 	viewMatrix._32 = vy.z;
638: 	viewMatrix._13 = vz.x;
639: 	viewMatrix._23 = vz.y;
640: 	viewMatrix._33 = vz.z;
641: 	viewMatrix._41 = tx;
642: 	viewMatrix._42 = ty;
643: 	viewMatrix._43 = tz;
644: 	viewMatrix._44 = 1.0;
645: 
646: 	memcpy(outViewMatrix, &viewMatrix, sizeof(matrix));
647: }
648: 
649: void update_view_matrix(struct ff7_game_obj *game_object)
650: {
651: 	if (newRenderer.isViewMatrixSet()) return;
652: 
653: 	struct game_mode *mode = getmode_cached();
654: 
655: 	struct matrix viewMatrix;
656: 	struct matrix *pViewMatrix = &viewMatrix;
657: 
658: 	switch(mode->driver_mode)
659: 	{
660: 		case MODE_FIELD:
661: 			// Get Field view matrix
662: 			ff7_get_field_view_matrix(&viewMatrix);
663: 			newRenderer.setViewMatrix(&viewMatrix);
664: 			break;
665: 		case MODE_WORLDMAP:
666: 		{
667: 			if (enable_worldmap_external_mesh)
668: 			{
669: 				int world_pos_x = ff7_externals.world_player_pos_E04918->x;
670: 				int world_pos_y = ff7_externals.world_player_pos_E04918->y;
671: 				int world_pos_z = ff7_externals.world_player_pos_E04918->z;
672: 
673: 				auto rot_matrix = ff7_externals.world_camera_direction_matrix_DFC448;
674: 				auto tr_matrix = ff7_externals.world_camera_position_matrix_DE6A20;
675: 
676: 				float cameraRotationMatrixFloat[16];
677: 
678: 				cameraRotationMatrixFloat[0] = rot_matrix->r3_sub_matrix[0][0] / 4096.0f;
679: 				cameraRotationMatrixFloat[1] = rot_matrix->r3_sub_matrix[0][1] / 4096.0f;
680: 				cameraRotationMatrixFloat[2] = rot_matrix->r3_sub_matrix[0][2] / 4096.0f;
681: 				cameraRotationMatrixFloat[3] = 0.0f;
682: 
683: 				cameraRotationMatrixFloat[4] = rot_matrix->r3_sub_matrix[1][0] / 4096.0f;
684: 				cameraRotationMatrixFloat[5] = rot_matrix->r3_sub_matrix[1][1] / 4096.0f;
685: 				cameraRotationMatrixFloat[6] = rot_matrix->r3_sub_matrix[1][2] / 4096.0f;
686: 				cameraRotationMatrixFloat[7] = 0.0f;
687: 
688: 				cameraRotationMatrixFloat[8] = rot_matrix->r3_sub_matrix[2][0] / 4096.0f;
689: 				cameraRotationMatrixFloat[9] = rot_matrix->r3_sub_matrix[2][1] / 4096.0f;
690: 				cameraRotationMatrixFloat[10] = rot_matrix->r3_sub_matrix[2][2] / 4096.0f;
691: 				cameraRotationMatrixFloat[11] = 0.0f;
692: 
693: 				cameraRotationMatrixFloat[12] = 0.0f;
694: 				cameraRotationMatrixFloat[13] = 0.0f;
695: 				cameraRotationMatrixFloat[14] = 0.0f;
696: 				cameraRotationMatrixFloat[15] = 1.0f;
697: 
698: 				float cameraTranslationMatrixFloat[16];
699: 				bx::mtxTranslate(cameraTranslationMatrixFloat, 0, 0, -tr_matrix->position[2]);
700: 
701: 				float cameraTranslationMatrixFloat2[16];
702: 				bx::mtxTranslate(cameraTranslationMatrixFloat2, world_pos_x, world_pos_y, world_pos_z);
703: 
704: 				float tmp[16];
705: 				bx::mtxMul(tmp, cameraTranslationMatrixFloat, cameraRotationMatrixFloat);
706: 
707: 				float cameraMatrixFloat[16];
708: 				bx::mtxMul(cameraMatrixFloat, tmp, cameraTranslationMatrixFloat2);
709: 
710: 				float viewMatrixFloat[16];
711: 				bx::mtxInverse(viewMatrixFloat, cameraMatrixFloat);
712: 
713: 				struct matrix viewMatrix;
714: 				::memcpy(&viewMatrix.m[0][0], viewMatrixFloat, sizeof(viewMatrix.m));
715: 
716: 				newRenderer.setViewMatrix(&viewMatrix);
717: 			}
718: 			else
719: 			{
720: 				pViewMatrix = game_object->camera_matrix;
721: 				if (pViewMatrix)
722: 				{
723: 					newRenderer.setViewMatrix(pViewMatrix);
724: 				}
725: 			}
726: 		}
727: 			break;
728: 		default:
729: 			pViewMatrix = game_object->camera_matrix;
730: 			if (pViewMatrix)
731: 			{
732: 				newRenderer.setViewMatrix(pViewMatrix);
733: 			}
734: 			break;
735: 	}
736: };
</file>

<file path="src/ff7/kernel.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #include "../ff7.h"
24: #include "../log.h"
25: 
26: #define FF7_KERNEL_NUM_SECTIONS 27
27: 
28: // KERNEL2
29: char *kernel2_sections[20];
30: uint32_t kernel2_section_counter;
31: 
32: void kernel2_reset_counters()
33: {
34: 	uint32_t i;
35: 
36: 	if(trace_all) ffnx_trace("kernel2 reset\n");
37: 
38: 	for(i = 0; i < kernel2_section_counter; i++) external_free(kernel2_sections[i]);
39: 
40: 	kernel2_section_counter = 0;
41: }
42: 
43: char *kernel2_add_section(uint32_t size)
44: {
45: 	char *ret = (char*)external_malloc(size);
46: 
47: 	if(trace_all) ffnx_trace("kernel2 add section %i (%i)\n", kernel2_section_counter, size);
48: 
49: 	kernel2_sections[kernel2_section_counter++] = ret;
50: 
51: 	return ret;
52: }
53: 
54: char *kernel2_get_text(uint32_t section_base, uint32_t string_id, uint32_t section_offset)
55: {
56: 	char *section = kernel2_sections[section_base + section_offset];
57: 
58: 	if(trace_all) ffnx_trace("kernel2 get text (%i+%i:%i)\n", section_base, section_offset, string_id);
59: 
60: 	return &section[((WORD *)section)[string_id]];
61: }
62: 
63: // ENGINE
64: 
65: void ff7_load_kernel2_wrapper(char *filename)
66: {
67:   ff7_externals.kernel_load_kernel2(filename);
68: 
69: 	char chunk_file[1024]{0};
70: 	uint32_t chunk_size = 0;
71: 	FILE* fd;
72: 
73: 	for (int n = 0; n < FF7_KERNEL_NUM_SECTIONS; n++)
74: 	{
75: 		_snprintf(chunk_file, sizeof(chunk_file), "%s/%s/kernel/kernel.bin.chunk.%i", basedir, direct_mode_path.c_str(), n+1);
76: 
77: 		if ((fd = fopen(chunk_file, "rb")) != NULL)
78: 		{
79: 			fseek(fd, 0L, SEEK_END);
80: 			chunk_size = ftell(fd);
81: 			fseek(fd, 0L, SEEK_SET);
82: 
83: 			if (0 <= n && n <= 8)
84: 				fread(ff7_externals.kernel_1to9_sections[n], sizeof(byte), chunk_size, fd);
85: 			else
86: 				fread(kernel2_sections[n-9], sizeof(byte), chunk_size, fd);
87: 
88: 			ffnx_trace("%s: kernel section %i overridden with %s\n", __func__, n+1, chunk_file);
89: 			fclose(fd);
90: 		}
91: 		else if (trace_direct)
92: 			ffnx_trace("%s: could not find %s\n", __func__, chunk_file);
93: 	}
94: }
</file>

<file path="src/ff7/loaders.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "../ff7.h"
 23: #include "../log.h"
 24: 
 25: #include "defs.h"
 26: 
 27: uint32_t get_frame_data_size(struct anim_header *anim_header)
 28: {
 29: 	if(!anim_header) return 0;
 30: 
 31: 	return (anim_header->num_bones * sizeof(vector3<float>) + sizeof(struct anim_frame_header)) * anim_header->num_frames;
 32: }
 33: 
 34: // load .a file, save modpath name somewhere we can retrieve it later
 35: struct anim_header *load_animation(struct file_context *file_context, char *filename)
 36: {
 37: 	struct ff7_file *file = open_file(file_context, filename);
 38: 	struct anim_header *ret = NULL;
 39: 	uint32_t size;
 40: 	uint32_t i;
 41: 	uint32_t data_pointer;
 42: 
 43: 	if(trace_all || trace_loaders)
 44: 	{
 45: 		if(file_context->use_lgp) ffnx_trace("reading animation file: %s/%s\n", lgp_names[file_context->lgp_num], filename);
 46: 		else ffnx_trace("reading animation file: %s\n", filename);
 47: 	}
 48: 
 49: 	if(!file) goto error;
 50: 
 51: 	ret = (anim_header*)common_externals.alloc_read_file(sizeof(*ret), 1, (struct file *)file);
 52: 
 53: 	if(!ret) goto error;
 54: 	if(ret->version.version != 1) goto error;
 55: 
 56: 	ret->use_matrix_array = false;
 57: 	ret->matrix_array = 0;
 58: 	ret->current_matrix_array = 0;
 59: 
 60: 	size = get_frame_data_size(ret);
 61: 	if(!size) goto error;
 62: 
 63: 	ret->frame_data = common_externals.alloc_read_file(size, 1, (struct file *)file);
 64: 	if(!ret->frame_data) goto error;
 65: 
 66: 	ret->anim_frames = (anim_frame*)external_calloc(sizeof(struct anim_frame), ret->num_frames);
 67: 
 68: 	data_pointer = (uint32_t)ret->frame_data;
 69: 
 70: 	for(i = 0; i < ret->num_frames; i++)
 71: 	{
 72: 		ret->anim_frames[i].header = (anim_frame_header *)data_pointer;
 73: 		data_pointer += sizeof(struct anim_frame_header);
 74: 		ret->anim_frames[i].data = (vector3<float> *)data_pointer;
 75: 		data_pointer += sizeof(vector3<float>) * ret->num_bones;
 76: 	}
 77: 
 78: 	ret->file.pc_name = make_pc_name(file_context, file, filename);
 79: 
 80: 	close_file(file);
 81: 	return ret;
 82: 
 83: error:
 84: 	ff7_externals.destroy_animation(ret);
 85: 	close_file(file);
 86: 	return 0;
 87: };
 88: 
 89: // load battle HRC file (does not save modpath name)
 90: struct battle_hrc_header *read_battle_hrc(uint32_t use_file_context, struct file_context *file_context, char *filename)
 91: {
 92: 	struct battle_hrc_header *ret;
 93: 	struct battle_chdir_struc olddir;
 94: 	char hrc_filename[200];
 95: 	uint32_t size;
 96: 
 97: 	if(use_file_context) ff7_externals.battle_context_chdir(file_context, &olddir);
 98: 	else ff7_externals.battle_regular_chdir(&olddir);
 99: 
100: 	ff7_externals.swap_extension("D", filename, hrc_filename);
101: 
102: 	if(trace_all || trace_loaders)
103: 	{
104: 		if(file_context->use_lgp) ffnx_trace("reading battle hrc file: %s/%s\n", lgp_names[file_context->lgp_num], hrc_filename);
105: 		else ffnx_trace("reading battle hrc file: %s\n", hrc_filename);
106: 	}
107: 
108: 	ret = (battle_hrc_header*)common_externals.alloc_get_file(file_context, &size, hrc_filename);
109: 
110: 	if(size < sizeof(*ret))
111: 	{
112: 		ff7_externals.destroy_battle_hrc(false, ret);
113: 		return 0;
114: 	}
115: 
116: 	ret->bone_data = 0;
117: 
118: 	if(ret->bones > 0) ret->bone_data = (struct battle_hrc_bone *)&ret[1];
119: 
120: 	if(use_file_context) ff7_externals.battle_context_olddir(file_context, &olddir);
121: 	else ff7_externals.battle_regular_olddir(&olddir);
122: 
123: 	return ret;
124: }
125: 
126: // load .p file, save modpath name somewhere we can retrieve it later
127: struct polygon_data *load_p_file(struct file_context *file_context, uint32_t create_lists, char *filename)
128: {
129: 	struct polygon_data *ret = ff7_externals.create_polygon_data(false, 0);
130: 	struct ff7_file *file = open_file(file_context, filename);
131: 
132: 	if(trace_all || trace_loaders)
133: 	{
134: 		if(file_context->use_lgp) ffnx_trace("reading p file: %s/%s\n", lgp_names[file_context->lgp_num], filename);
135: 		else ffnx_trace("reading p file: %s\n", filename);
136: 	}
137: 
138: 	if(!file) goto error;
139: 	if(!read_file(sizeof(*ret), ret, file)) goto error;
140: 
141: 	ret->vertdata = 0;
142: 	ret->normaldata = 0;
143: 	ret->field_48 = 0;
144: 	ret->texcoorddata = 0;
145: 	ret->vertexcolordata = 0;
146: 	ret->polycolordata = 0;
147: 	ret->edgedata = 0;
148: 	ret->polydata = 0;
149: 	ret->pc_name = make_pc_name(file_context, file, filename);
150: 	ret->field_64 = 0;
151: 	ret->hundredsdata = 0;
152: 	ret->groupdata = 0;
153: 	ret->lists = 0;
154: 	ret->boundingboxdata = 0;
155: 	ret->normindextabledata = 0;
156: 
157: 	if(ret->version != 1)
158: 	{
159: 		ffnx_error("invalid version in polygon file %s\n", filename);
160: 		goto error;
161: 	}
162: 
163: 	if(ret->field_2C) ffnx_unexpected("oops, missed some .p data\n");
164: 
165: 	ret->vertdata = (vector3<float>*)common_externals.alloc_read_file(sizeof(*ret->vertdata), ret->numverts, (struct file *)file);
166: 	ret->normaldata = (vector3<float>*)common_externals.alloc_read_file(sizeof(*ret->normaldata), ret->numnormals, (struct file *)file);
167: 	ret->field_48 = (vector3<float>*)common_externals.alloc_read_file(sizeof(*ret->field_48), ret->field_14, (struct file *)file);
168: 	ret->texcoorddata = (struct texcoords*)common_externals.alloc_read_file(sizeof(*ret->texcoorddata), ret->numtexcoords, (struct file *)file);
169: 	ret->vertexcolordata = (uint32_t*)common_externals.alloc_read_file(sizeof(*ret->vertexcolordata), ret->numvertcolors, (struct file *)file);
170: 	ret->polycolordata = (uint32_t*)common_externals.alloc_read_file(sizeof(*ret->polycolordata), ret->numpolys, (struct file *)file);
171: 	ret->edgedata = (struct p_edge*)common_externals.alloc_read_file(sizeof(*ret->edgedata), ret->numedges, (struct file *)file);
172: 	ret->polydata = (struct p_polygon*)common_externals.alloc_read_file(sizeof(*ret->polydata), ret->numpolys, (struct file *)file);
173: 	external_free(common_externals.alloc_read_file(sizeof(struct p_polygon), ret->field_28, (struct file *)file));
174: 	ret->field_64 = common_externals.alloc_read_file(3, ret->field_2C, (struct file *)file);
175: 	ret->hundredsdata = (struct p_hundred*)common_externals.alloc_read_file(sizeof(*ret->hundredsdata), ret->numhundreds, (struct file *)file);
176: 	ret->groupdata = (struct p_group*)common_externals.alloc_read_file(sizeof(*ret->groupdata), ret->numgroups, (struct file *)file);
177: 	ret->boundingboxdata = (struct boundingbox*)common_externals.alloc_read_file(sizeof(*ret->boundingboxdata), ret->numboundingboxes, (struct file *)file);
178: 	if(ret->has_normindextable) ret->normindextabledata = (uint32_t*)common_externals.alloc_read_file(sizeof(*ret->normindextabledata), ret->numverts, (struct file *)file);
179: 
180: 	if(create_lists) ff7_externals.create_polygon_lists(ret);
181: 
182: 	close_file(file);
183: 	return ret;
184: 
185: error:
186: 	ff7_externals.free_polygon_data(ret);
187: 	close_file(file);
188: 	return 0;
189: }
190: 
191: void destroy_tex_header(struct ff7_tex_header *tex_header)
192: {
193: 	if(!tex_header) return;
194: 
195: 	if((uint32_t)tex_header->file.pc_name > 32) external_free(tex_header->file.pc_name);
196: 
197: 	external_free(tex_header->old_palette_data);
198: 	external_free(tex_header->palette_colorkey);
199: 	external_free(tex_header->tex_format.palette_data);
200: 	external_free(tex_header->image_data);
201: 
202: 	external_free(tex_header);
203: }
204: 
205: // load .tex file, save modpath name somewhere we can retrieve it later
206: struct ff7_tex_header *load_tex_file(struct file_context *file_context, char *filename)
207: {
208: 	struct ff7_tex_header *ret = (struct ff7_tex_header *)common_externals.create_tex_header();
209: 	struct ff7_file *file = open_file(file_context, filename);
210: 
211: 	if(!file) goto error;
212: 	if(!read_file(sizeof(*ret), ret, file)) goto error;
213: 
214: 	ret->image_data = 0;
215: 	ret->old_palette_data = 0;
216: 	ret->palette_colorkey = 0;
217: 	ret->tex_format.palette_data = 0;
218: 
219: 	if(ret->version != 1) goto error;
220: 	else
221: 	{
222: 		if(ret->tex_format.use_palette)
223: 		{
224: 			ret->tex_format.palette_data = (uint32_t*)common_externals.alloc_read_file(4, ret->tex_format.palette_size, (struct file *)file);
225: 			if(!ret->tex_format.palette_data) goto error;
226: 		}
227: 
228: 		ret->image_data = (unsigned char*)common_externals.alloc_read_file(ret->tex_format.bytesperpixel, ret->tex_format.width * ret->tex_format.height, (struct file *)file);
229: 		if(!ret->image_data) goto error;
230: 
231: 		if(ret->use_palette_colorkey)
232: 		{
233: 			ret->palette_colorkey = (char*)common_externals.alloc_read_file(1, ret->palettes, (struct file *)file);
234: 			if(!ret->palette_colorkey) goto error;
235: 		}
236: 	}
237: 
238: 	ret->file.pc_name = make_pc_name(file_context, file, filename);
239: 
240: 	close_file(file);
241: 	return ret;
242: 
243: error:
244: 	destroy_tex_header(ret);
245: 	close_file(file);
246: 	return 0;
247: }
</file>

<file path="src/ff7/menu.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include "../ff7.h"
 24: #include "../log.h"
 25: #include "../achievement.h"
 26: #include "../gamehacks.h"
 27: 
 28: void ff7_menu_battle_end_sub_6C9543()
 29: {
 30:     ((void (*)())ff7_externals.menu_battle_end_sub_6C9543)();
 31: 
 32:     if(*ff7_externals.menu_battle_end_mode == 0){
 33:         if (trace_all || trace_achievement)
 34:             ffnx_trace("%s - trying to unlock achievement for battle won and weapons\n", __func__);
 35:         g_FF7SteamAchievements->unlockBattleWonAchievement(*ff7_externals.battle_formation_id);
 36:     }
 37: 
 38:     if(*ff7_externals.menu_battle_end_mode == 1){
 39:         if (trace_all || trace_achievement)
 40:             ffnx_trace("%s - trying to unlock achievement for first limit, cait sith, character level, and master materia\n", __func__);
 41: 
 42:         g_FF7SteamAchievements->unlockCaitSithLastLimitBreakAchievement(ff7_externals.savemap->chars);
 43:         g_FF7SteamAchievements->unlockCharacterLevelAchievement(ff7_externals.savemap->chars);
 44:         g_FF7SteamAchievements->unlockMasterMateriaAchievement(ff7_externals.savemap->chars);
 45:     }
 46:     if(*ff7_externals.menu_battle_end_mode == 3){
 47:         if (trace_all || trace_achievement)
 48:             ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);
 49:         g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil);
 50:     }
 51: }
 52: 
 53: int ff7_get_materia_gil(uint32_t materia)
 54: {
 55:     int materiaGil = ((int (*)(uint32_t))ff7_externals.get_materia_gil)(materia);
 56: 
 57:     if (trace_all || trace_achievement)
 58:         ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);
 59: 
 60:     g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil + materiaGil);
 61:     return materiaGil;
 62: }
 63: 
 64: // called when selling an item
 65: void ff7_opcode_increase_gil_call(int gilObtained)
 66: {
 67:     if (ff7_externals.savemap->gil + gilObtained < ff7_externals.savemap->gil)
 68:         ff7_externals.savemap->gil = -1;
 69:     else
 70:         ff7_externals.savemap->gil = ff7_externals.savemap->gil + gilObtained;
 71: 
 72:     if (trace_all || trace_achievement)
 73:         ffnx_trace("%s - trying to unlock achievement for gil\n", __func__);
 74: 
 75:     g_FF7SteamAchievements->unlockGilAchievement(ff7_externals.savemap->gil);
 76: };
 77: 
 78: byte ff7_menu_sub_6CBCF3(uint32_t materia_id)
 79: {
 80:     byte returnValue = ((byte(*)(uint32_t))ff7_externals.menu_sub_6CBCF3)(materia_id);
 81: 
 82:     if (trace_all || trace_achievement)
 83:         ffnx_trace("%s - trying to unlock achievement for getting materia\n", __func__);
 84: 
 85:     g_FF7SteamAchievements->unlockGotMateriaAchievement(materia_id);
 86: 
 87:     return returnValue;
 88: }
 89: 
 90: void ff7_menu_sub_6CC17F(uint32_t materia)
 91: {
 92:     ((void (*)(uint32_t))ff7_externals.menu_sub_6CC17F)(materia);
 93: 
 94:     if (trace_all || trace_achievement)
 95:         ffnx_trace("%s - trying to unlock achievement for getting materia\n", __func__);
 96: 
 97:     g_FF7SteamAchievements->unlockGotMateriaAchievement(materia & 0xFF);
 98: }
 99: 
100: uint32_t ff7_menu_decrease_item_quantity(uint32_t item_used)
101: {
102:     uint32_t item_id;
103:     uint32_t prevIndex;
104:     uint32_t item_quantity;
105:     WORD local_c;
106:     int index=0;
107: 
108:     WORD *party_item_slots = ff7_externals.savemap->items;
109:     item_id = item_used & 0x1FF;
110:     item_quantity = (item_used & 0xFFFF) >> 9;
111:     prevIndex = item_id;
112: 
113:     while (!(((WORD)party_item_slots[index] != -1) &&
114:             (prevIndex = (WORD)party_item_slots[index] & 0x1ff, item_id == prevIndex)))
115:     {
116:         if (index >= 320)
117:             return prevIndex & 0xFFFF0000 | 0xFFFF;
118: 
119:         prevIndex = index;
120:         index = index + 1;
121:     }
122:     if (item_quantity < (party_item_slots[index] >> 9))
123:     {
124:         local_c = (WORD)(item_used | (item_quantity << 9));
125:         item_id = ((party_item_slots[index] >> 9) - item_quantity) * 512 | item_id;
126:         party_item_slots[index] = (WORD)item_id;
127:     }
128:     else
129:     {
130:         local_c = party_item_slots[index];
131:         item_id = 0;
132:         party_item_slots[index] = 0xFFFF;
133:     }
134:     g_FF7SteamAchievements->unlockLastLimitBreakAchievement(item_used & 0x1FF);
135:     return item_id & 0xFFFF0000 | (uint32_t)local_c;
136: }
137: 
138: void dispatchAttackCommand(){
139:     char* character = (char*)ff7_externals.menu_objects + 0x2CBC; //Character attacking
140:     char* attack = (char*)ff7_externals.gamepad_status + 0xCA8 + (*character * 6); //Their equipped attack
141:     *ff7_externals.issued_command_id = *attack;
142:     *ff7_externals.issued_action_target_type = 0;
143:     *ff7_externals.issued_action_target_index = 4;
144:     ((void(*)())ff7_externals.dispatch_chosen_battle_action)();
145: }
146: 
147: void ff7_battle_menu_sub_6DB0EE(){
148:     ((void(*)())ff7_externals.battle_sub_6DB0EE)();
149:     if(gamehacks.isAutoAttack() && (*ff7_externals.battle_menu_state >= 0 && *ff7_externals.battle_menu_state < 19)){
150:         dispatchAttackCommand();
151:     }
152: }
153: 
154: void ff7_set_battle_menu_state_data_at_full_atb(short param_1, short param_2, short menu_state){
155:     if(gamehacks.isAutoAttack())
156:     {
157:         dispatchAttackCommand();
158:     }
159:     else{
160:         ((void(*)(short, short, short))ff7_externals.set_battle_menu_state_data)(param_1, param_2, menu_state);
161:     }
162: }
</file>

<file path="src/ff7/minigames.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 4: //                                                                          //
 5: //    This file is part of FFNx                                             //
 6: //                                                                          //
 7: //    FFNx is free software: you can redistribute it and/or modify          //
 8: //    it under the terms of the GNU General Public License as published by  //
 9: //    the Free Software Foundation, either version 3 of the License         //
10: //                                                                          //
11: //    FFNx is distributed in the hope that it will be useful,               //
12: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
13: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
14: //    GNU General Public License for more details.                          //
15: /****************************************************************************/
16: 
17: #include <stdint.h>
18: 
19: #include "../ff7.h"
20: #include "../globals.h"
21: 
22: void ff7_condor_fix_unit_texture_load(uint32_t unk, struc_3 *struc_3)
23: {
24:   ff7_externals.make_struc3(unk, struc_3);
25: 
26:   // tell the game engine the files live inside the lgp file
27:   if ( *ff7_externals.condor_uses_lgp )
28:   {
29:     struc_3->file_context.use_lgp = 1;
30:     struc_3->file_context.lgp_num = 6;
31:     struc_3->file_context.name_mangler = 0;
32:   }
33: }
34: 
35: void __fastcall ff7_snowboard_parse_model_vertices(snowboard_this* _this, void* edx, const matrix *matrix, int current_obj, int obj_type, int unk)
36: {
37:   vector3<float> vertex;
38:   point4d *point;
39:   tmd_object *tmd_obj;
40: 
41:   if ( current_obj >= 0 && current_obj < _this->num_objects )
42:   {
43:     point = (point4d *)ff7_externals.battle_sub_661000(0);
44:     tmd_obj = (tmd_object *)(&_this->model_data->tmdobjectlist + 7 * current_obj);
45:     ff7_externals.sub_733479((void*)*((DWORD*)*ff7_externals.snowboard_global_object_off_926290 + 0x9D), matrix);
46: 
47:     for (int32_t i = 0; i < tmd_obj->nverts; ++i )
48:     {
49:       if (_this->model_data->tmdheader.version == 0xFF)
50:       {
51:         vertex.x = ((tmd_vertex_float*)tmd_obj->offsetverts)[i].vx;
52:         vertex.y = ((tmd_vertex_float*)tmd_obj->offsetverts)[i].vy;
53:         vertex.z = ((tmd_vertex_float*)tmd_obj->offsetverts)[i].vz;
54:       }
55:       else
56:       {
57:         vertex.x = (float)((tmd_vertex*)tmd_obj->offsetverts)[i].vx;
58:         vertex.y = (float)((tmd_vertex*)tmd_obj->offsetverts)[i].vy;
59:         vertex.z = (float)((tmd_vertex*)tmd_obj->offsetverts)[i].vz;
60:       }
61: 
62:       ff7_externals.sub_733564((void*)*((DWORD*)*ff7_externals.snowboard_global_object_off_926290 + 0x9D), &vertex, &point[i + 1]);
63:     }
64: 
65:     switch ( obj_type )
66:     {
67:       case 0:
68:         ff7_externals.sub_7322D6((tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
69:         break;
70:       case 1:
71:         ff7_externals.sub_732429((tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
72:         break;
73:       case 2:
74:         ff7_externals.sub_732BB9((tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
75:         break;
76:       case 3:
77:         ff7_externals.sub_732546(_this, (tmd_primitive_packet*)tmd_obj->offsetprimitives, tmd_obj->nprimitives, unk);
78:         break;
79:       default:
80:         return;
81:     }
82:   }
83: }
</file>

<file path="src/ff7/misc.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <stdint.h>
 24: 
 25: #include "defs.h"
 26: #include "battle/camera.h"
 27: #include "field/camera.h"
 28: #include "world/camera.h"
 29: #include "world/world.h"
 30: 
 31: #include "../audio.h"
 32: #include "../gamepad.h"
 33: #include "../gamehacks.h"
 34: #include "../joystick.h"
 35: #include "../music.h"
 36: #include "../ff7.h"
 37: #include "../log.h"
 38: #include "../metadata.h"
 39: #include "../achievement.h"
 40: 
 41: #include <bx/math.h>
 42: 
 43: // CORE GAME LOOP
 44: void ff7_core_game_loop()
 45: {
 46: 	struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
 47: 	uint64_t start_t, end_t;
 48: 
 49: 	common_externals.get_time(&start_t);
 50: 
 51: 	*(double *)&game_object->field_28 = *(double *)&game_object->field_28 + 1.0;
 52: 	ff7_engine_exit_game_mode(game_object);
 53: 
 54: 	if ( !game_object->window_minimized && game_object->engine_loop_obj.main_loop )
 55: 	{
 56: 		game_object->engine_loop_obj.main_loop((game_obj*)game_object);
 57: 		*(double *)&game_object->field_44 = *(double *)&game_object->field_44 + 1.0;
 58: 	}
 59: 
 60: 	if ( !game_object->window_minimized )
 61: 		common_flip((game_obj*)game_object);
 62: 
 63: 	if ( game_object->field_950 || game_object->window_minimized )
 64: 		WaitMessage();
 65: 
 66: 	common_externals.get_time(&end_t);
 67: 	if ( game_object->field_794 ) common_externals.diff_time(&end_t, &start_t, (uint64_t*)(game_object->field_794 + 0x98));
 68: }
 69: 
 70: // MDEF fix
 71: uint32_t get_equipment_stats(uint32_t party_index, uint32_t type)
 72: {
 73: 	uint32_t character = ff7_externals.party_member_to_char_map[ff7_externals.savemap->party_members[party_index]];
 74: 
 75: 	switch(type)
 76: 	{
 77: 		case 0:
 78: 			return ff7_externals.weapon_data_array[ff7_externals.savemap->chars[character].equipped_weapon].attack_stat;
 79: 			break;
 80: 		case 1:
 81: 			return ff7_externals.armor_data_array[ff7_externals.savemap->chars[character].equipped_armor].defense_stat;
 82: 			break;
 83: 		case 2:
 84: 			return 0;
 85: 			break;
 86: 		case 3:
 87: 			return mdef_fix ? ff7_externals.armor_data_array[ff7_externals.savemap->chars[character].equipped_armor].mdef_stat : 0;
 88: 			break;
 89: 
 90: 		default: return 0;
 91: 	}
 92: }
 93: 
 94: // WM_ACTIVATEAPP
 95: void ff7_wm_activateapp(bool hasFocus)
 96: {
 97: 
 98: }
 99: 
100: // Analogue controls
101: int ff7_get_control_direction()
102: {
103: 	byte* level_data = *ff7_externals.field_level_data_pointer;
104: 
105: 	if (level_data != nullptr)
106: 	{
107: 		uint32_t triggers_offset = *(uint32_t*)(level_data + 0x22);
108: 		signed short* control_direction_data = (signed short*)(level_data + triggers_offset + 4 + 9);
109: 
110: 		return static_cast<int>(*control_direction_data);
111: 	}
112: 
113: 	return 0;
114: }
115: 
116: void ff7_set_control_direction(int x)
117: {
118: 	byte* level_data = *ff7_externals.field_level_data_pointer;
119: 
120: 	if (level_data != nullptr)
121: 	{
122: 		uint32_t triggers_offset = *(uint32_t*)(level_data + 0x22);
123: 		signed short* control_direction_data = (signed short*)(level_data + triggers_offset + 4 + 9);
124: 
125: 		*control_direction_data = static_cast<signed short>(x);
126: 	}
127: }
128: 
129: void ff7_use_analogue_controls(float analog_threshold)
130: {
131: 	static WORD last_field_id = 0;
132: 	static int base_control_direction = 0;
133: 	static bool isCameraReset = false;
134: 	if (last_field_id != *ff7_externals.field_id)
135: 	{
136: 		last_field_id = *ff7_externals.field_id;
137: 		base_control_direction = ff7_get_control_direction();
138: 	}
139: 
140: 	vector3<float> joyDir = {0.0f, 0.0f, 0.0f};
141: 	vector3<float> inputDir = {0.0f, 0.0f, 0.0f};
142: 	float horizontalScroll = 0.0f;
143: 	float verticalScroll = 0.0f;
144: 	const float rotSpeedMax = 4.0f;
145: 	float verticalRotSpeed = 0.0f;
146: 	float horizontalRotSpeed = 0.0f;
147: 	const float zoomSpeedMax = 1000.0f;
148: 	float zoomSpeed = 0.0f;
149: 
150: 	float invertedVerticalCameraScale = -1.0;
151: 	if(enable_inverted_vertical_camera_controls) invertedVerticalCameraScale = 1.0;
152: 
153: 	float invertedHorizontalCameraScale = -1.0;
154: 	if(enable_inverted_horizontal_camera_controls) invertedHorizontalCameraScale = 1.0;
155: 
156: 	if(xinput_connected)
157: 	{
158: 		if (gamepad.Refresh())
159: 		{
160: 			if(std::abs(gamepad.leftStickX) > left_analog_stick_deadzone ||
161: 			   std::abs(gamepad.leftStickY) > left_analog_stick_deadzone)
162: 				joyDir = {gamepad.leftStickX, gamepad.leftStickY, 0.0f};
163: 			else
164: 				joyDir = {0.0f, 0.0, 0.0};
165: 
166: 
167: 			if(gamepad.leftStickY > analog_threshold && !(gamepad.leftStickX < -analog_threshold || gamepad.leftStickX > analog_threshold))
168: 				inputDir = {0.0f, 1.0f, 0.0f};
169: 			else if(gamepad.leftStickY > analog_threshold && gamepad.leftStickX < -analog_threshold)
170: 				inputDir = {-0.707f, 0.707f, 0.0f};
171: 			else if(gamepad.leftStickY > analog_threshold && gamepad.leftStickX > analog_threshold)
172: 				inputDir = {0.707f, 0.707f, 0.0f};
173: 			else if(gamepad.leftStickX < -analog_threshold &&!(gamepad.leftStickY > analog_threshold || gamepad.leftStickY < -analog_threshold))
174: 				inputDir = {-1.0f, 0.0f, 0.0f};
175: 			else if(gamepad.leftStickX > analog_threshold && !(gamepad.leftStickY > analog_threshold || gamepad.leftStickY < -analog_threshold))
176: 				inputDir = {1.0f, 0.0f, 0.0f};
177: 			else if(gamepad.leftStickY < -analog_threshold && gamepad.leftStickX < -analog_threshold)
178: 				inputDir = {-0.707f, -0.707f, 0.0f};
179: 			else if(gamepad.leftStickY < -analog_threshold && gamepad.leftStickX > analog_threshold)
180: 				inputDir = {0.707f, -0.707f, 0.0f};
181: 			else if(gamepad.leftStickY < -analog_threshold && !(gamepad.leftStickX < -analog_threshold || gamepad.leftStickX > analog_threshold))
182: 				inputDir = {0.0f, -1.0f, 0.0f};
183: 
184: 			if (gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_THUMB)
185: 			    && std::abs(gamepad.rightStickX) < right_analog_stick_deadzone
186: 				&& std::abs(gamepad.rightStickY) < right_analog_stick_deadzone)
187: 			{
188: 				if(!isCameraReset)
189: 				{
190: 					ff7::world::camera.requestResetCameraRotation(true);
191: 					ff7::battle::camera.reset();
192: 					isCameraReset = true;
193: 				}
194: 			} else
195: 			{
196: 				isCameraReset = false;
197: 
198: 				if(gamepad.rightTrigger > right_analog_trigger_deadzone)
199: 					zoomSpeed += zoomSpeedMax * (0.5f * gamepad.rightTrigger);
200: 				if(gamepad.leftTrigger > left_analog_trigger_deadzone)
201: 					zoomSpeed -= zoomSpeedMax * (0.5f * gamepad.leftTrigger);
202: 
203: 				bx::Vec3 rightAnalogDir(gamepad.rightStickX, gamepad.rightStickY, 0.0f);
204: 				float length = std::min(bx::length(rightAnalogDir), 1.0f);
205: 				if(length > right_analog_stick_deadzone)
206: 				{
207: 					rightAnalogDir = bx::normalize(rightAnalogDir);
208: 					float scale = (length - right_analog_stick_deadzone) / (1.0 - right_analog_stick_deadzone);
209: 					rightAnalogDir.x *= scale;
210: 					rightAnalogDir.y *= scale;
211: 					verticalRotSpeed = invertedVerticalCameraScale * -rotSpeedMax * rightAnalogDir.y;
212: 					horizontalRotSpeed = invertedHorizontalCameraScale * rotSpeedMax * rightAnalogDir.x;
213: 					horizontalScroll = rightAnalogDir.x;
214: 					verticalScroll = -rightAnalogDir.y;
215: 				}
216: 			}
217: 		}
218: 	}
219: 	else
220: 	{
221: 		if (joystick.Refresh())
222: 		{
223: 			if(std::abs(joystick.GetState()->lX) > joystick.GetDeadZone(left_analog_trigger_deadzone) ||
224: 			   std::abs(joystick.GetState()->lY) > joystick.GetDeadZone(left_analog_trigger_deadzone))
225: 				joyDir = {static_cast<float>(joystick.GetState()->lX) / static_cast<float>(SHRT_MAX),
226: 				         -static_cast<float>(joystick.GetState()->lY) / static_cast<float>(SHRT_MAX), 0.0f};
227: 			else
228: 				joyDir = {0.0f, 0.0, 0.0};
229: 
230: 			if(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) &&
231: 			!(joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold)))
232: 				inputDir = {0.0f, 1.0f, 0.0f};
233: 			else if(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) && joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold))
234: 				inputDir = {-0.707f, 0.707f, 0.0f};
235: 			else if(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) && joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold))
236: 				inputDir = {0.707f, 0.707f, 0.0f};
237: 			else if(joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold) &&
238: 			!(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold)))
239: 				inputDir = {-1.0f, 0.0f, 0.0f};
240: 			else if(joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold) &&
241: 				!(joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold)))
242: 				inputDir = {1.0f, 0.0f, 0.0f};
243: 			else if(joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold) && joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold))
244: 				inputDir = {-0.707f, -0.707f, 0.0f};
245: 			else if(joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold) && joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold))
246: 				inputDir = {0.707f, -0.707f, 0.0f};
247: 			else if(joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold) &&
248: 				!(joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold) || joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold)))
249: 				inputDir = {0.0f, -1.0f, 0.0f};
250: 
251: 			if ((joystick.GetState()->rgbButtons[11] & 0x80)
252: 			    && std::abs(joystick.GetState()->lRz) < joystick.GetDeadZone(right_analog_stick_deadzone)
253: 				&& std::abs(joystick.GetState()->lZ) < joystick.GetDeadZone(right_analog_stick_deadzone))
254: 			{
255: 				if(!isCameraReset)
256: 				{
257: 					ff7::world::camera.requestResetCameraRotation(true);
258: 					ff7::battle::camera.reset();
259: 					isCameraReset = true;
260: 				}
261: 			} else
262: 			{
263: 				isCameraReset = false;
264: 
265: 				bx::Vec3 rightAnalogDir(
266: 					static_cast<float>(joystick.GetState()->lZ) / static_cast<float>(SHRT_MAX),
267: 					static_cast<float>(joystick.GetState()->lRz) / static_cast<float>(SHRT_MAX), 0.0f);
268: 				float length = std::min(bx::length(rightAnalogDir), 1.0f);
269: 				if(length > right_analog_stick_deadzone)
270: 				{
271: 					rightAnalogDir = bx::normalize(rightAnalogDir);
272: 					float scale = (length - right_analog_stick_deadzone) / (1.0 - right_analog_stick_deadzone);
273: 					rightAnalogDir.x *=  scale;
274: 					rightAnalogDir.y *=  scale;
275: 					verticalRotSpeed = invertedVerticalCameraScale * rotSpeedMax * rightAnalogDir.y;
276: 					horizontalRotSpeed = invertedHorizontalCameraScale * rotSpeedMax * rightAnalogDir.x;
277: 					horizontalScroll = rightAnalogDir.x;
278: 					verticalScroll = rightAnalogDir.y;
279: 				}
280: 
281: 				if(joystick.HasAnalogTriggers())
282: 				{
283: 					if(joystick.GetState()->lRy > -static_cast<float>(SHRT_MAX) + joystick.GetDeadZone(right_analog_trigger_deadzone))
284: 						zoomSpeed += zoomSpeedMax * (0.5f + 0.5f * static_cast<float>(joystick.GetState()->lRy) / static_cast<float>(SHRT_MAX));
285: 					if(joystick.GetState()->lRx > -static_cast<float>(SHRT_MAX) + joystick.GetDeadZone(left_analog_trigger_deadzone))
286: 						zoomSpeed -= zoomSpeedMax * (0.5f + 0.5f * static_cast<float>(joystick.GetState()->lRx) / static_cast<float>(SHRT_MAX));
287: 				}
288: 				else
289: 				{
290: 					if(joystick.GetState()->rgbButtons[7] & 0x80) zoomSpeed += zoomSpeedMax;
291: 					if(joystick.GetState()->rgbButtons[6] & 0x80) zoomSpeed -= zoomSpeedMax;
292: 				}
293: 			}
294: 		}
295: 	}
296: 
297: 	ff7::world::world.SetJoystickDirection(joyDir);
298: 
299: 	float inputDirLength = vector_length(&inputDir);
300: 	if(inputDirLength > 0.0f)
301: 	{
302: 		normalize_vector(&joyDir);
303: 		float angle = atan2( inputDir.x*joyDir.y - inputDir.y*joyDir.x, inputDir.x*joyDir.x + inputDir.y*joyDir.y );
304: 		int offset = std::max(-128, std::min(128, static_cast<int>(128.0f * angle / M_PI)));
305: 		ff7_set_control_direction(base_control_direction + offset);
306: 	}
307: 	else
308: 	{
309: 		ff7_set_control_direction(base_control_direction);
310: 	}
311: 
312: 	ff7::battle::camera.setRotationSpeed(verticalRotSpeed, horizontalRotSpeed, 0.0f);
313: 	ff7::battle::camera.setZoomSpeed(zoomSpeed);
314: 	ff7::field::camera.setScrollingDir(horizontalScroll, verticalScroll);
315: 	ff7::world::camera.setRotationSpeed(verticalRotSpeed, horizontalRotSpeed, 0.0f);
316: 	ff7::world::camera.setZoomSpeed(zoomSpeed);
317: }
318: 
319: int ff7_get_gamepad()
320: {
321: 	if (simulate_OK_button)
322: 	{
323: 		return TRUE;
324: 	}
325: 	else if (xinput_connected)
326: 	{
327: 		if (gamepad.Refresh())
328: 			return TRUE;
329: 	}
330: 	else
331: 	{
332: 		if (joystick.Refresh())
333:     	return TRUE;
334: 	}
335: 
336: 	return FALSE;
337: }
338: 
339: struct ff7_gamepad_status* ff7_update_gamepad_status()
340: {
341: 	float analog_threshold = enable_auto_run ? left_analog_stick_deadzone + 0.25f * (1.0f - left_analog_stick_deadzone) : 0.5f;
342: 	float run_threshold = left_analog_stick_deadzone + 0.75f * (1.0f - left_analog_stick_deadzone);
343: 
344: 	// Reset
345: 	ZeroMemory(ff7_externals.gamepad_status, sizeof(ff7_gamepad_status));
346: 	gamepad_analogue_intent = INTENT_NONE;
347: 
348: 	if (simulate_OK_button)
349: 	{
350: 		// Flag the button OK ( no matter to what is mapped in the controller ) as pressed
351: 		*ff7_externals.input_ok_button_status = 1;
352: 
353: 		// End simulation right here before we press this button by mistake in other windows
354: 		simulate_OK_button = false;
355: 	}
356: 	else if (xinput_connected && gamehacks.canInputBeProcessed())
357: 	{
358: 		if (gamepad.Refresh())
359: 		{
360: 			ff7_externals.gamepad_status->pos_x = gamepad.leftStickX;
361: 			ff7_externals.gamepad_status->pos_y = gamepad.leftStickY;
362: 			ff7_externals.gamepad_status->dpad_up = (gamepad.leftStickY > analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_UP); // UP
363: 			ff7_externals.gamepad_status->dpad_down = (gamepad.leftStickY < -analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_DOWN); // DOWN
364: 			ff7_externals.gamepad_status->dpad_left = (gamepad.leftStickX < -analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_LEFT); // LEFT
365: 			ff7_externals.gamepad_status->dpad_right = (gamepad.leftStickX > analog_threshold) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_RIGHT); // RIGHT
366: 			ff7_externals.gamepad_status->button1 = gamepad.IsPressed(XINPUT_GAMEPAD_X); // Square
367: 			ff7_externals.gamepad_status->button2 = gamepad.IsPressed(XINPUT_GAMEPAD_A); // Cross
368: 			ff7_externals.gamepad_status->button3 = gamepad.IsPressed(XINPUT_GAMEPAD_B); // Circle
369: 			ff7_externals.gamepad_status->button4 = gamepad.IsPressed(XINPUT_GAMEPAD_Y); // Triangle
370: 			ff7_externals.gamepad_status->button5 = gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_SHOULDER); // L1
371: 			ff7_externals.gamepad_status->button6 = gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1
372: 			ff7_externals.gamepad_status->button7 = gamepad.leftTrigger > 0.85f; // L2
373: 			ff7_externals.gamepad_status->button8 = gamepad.rightTrigger > 0.85f; // R2
374: 
375: 			ff7_externals.gamepad_status->button9 = gamepad.IsPressed(XINPUT_GAMEPAD_BACK); // SELECT
376: 			ff7_externals.gamepad_status->button10 = gamepad.IsPressed(XINPUT_GAMEPAD_START); // START
377: 			ff7_externals.gamepad_status->button11 = gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_THUMB); // L3
378: 			ff7_externals.gamepad_status->button12 = gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_THUMB); // R3
379: 			ff7_externals.gamepad_status->button13 = gamepad.IsPressed(0x400); // PS Button
380: 
381: 			// Update the player intent based on the analogue movement
382: 			if (enable_auto_run)
383: 			{
384: 				bx::Vec3 joyDir = {gamepad.leftStickX, gamepad.leftStickY, 0.0f};
385: 				auto joyLength = std::min(bx::length(joyDir), 1.0f);
386: 				if (joyLength > run_threshold) gamepad_analogue_intent = INTENT_RUN;
387: 				else if(joyLength > analog_threshold) gamepad_analogue_intent = INTENT_WALK;
388: 			}
389: 		}
390: 	}
391: 	else if (gamehacks.canInputBeProcessed())
392: 	{
393: 		if (joystick.Refresh())
394: 		{
395: 			ff7_externals.gamepad_status->pos_x = joystick.GetState()->lX;
396: 			ff7_externals.gamepad_status->pos_y = joystick.GetState()->lY;
397: 			ff7_externals.gamepad_status->dpad_up = (joystick.GetState()->lY < joystick.GetDeadZone(-analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 0
398: 			                                         || joystick.GetState()->rgdwPOV[0] == 4500 || joystick.GetState()->rgdwPOV[0] == 31500; // UP
399: 			ff7_externals.gamepad_status->dpad_down = (joystick.GetState()->lY > joystick.GetDeadZone(analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 18000
400: 			                                         || joystick.GetState()->rgdwPOV[0] == 13500 || joystick.GetState()->rgdwPOV[0] == 22500; // DOWN
401: 			ff7_externals.gamepad_status->dpad_left = (joystick.GetState()->lX < joystick.GetDeadZone(-analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 27000
402: 			                                         || joystick.GetState()->rgdwPOV[0] == 22500 || joystick.GetState()->rgdwPOV[0] == 31500; // LEFT
403: 			ff7_externals.gamepad_status->dpad_right = (joystick.GetState()->lX > joystick.GetDeadZone(analog_threshold)) || joystick.GetState()->rgdwPOV[0] == 9000
404: 			                                         || joystick.GetState()->rgdwPOV[0] == 4500 || joystick.GetState()->rgdwPOV[0] == 13500; // RIGHT
405: 			ff7_externals.gamepad_status->button1 = joystick.GetState()->rgbButtons[0] & 0x80; // Square
406: 			ff7_externals.gamepad_status->button2 = joystick.GetState()->rgbButtons[1] & 0x80; // Cross
407: 			ff7_externals.gamepad_status->button3 = joystick.GetState()->rgbButtons[2] & 0x80; // Circle
408: 			ff7_externals.gamepad_status->button4 = joystick.GetState()->rgbButtons[3] & 0x80; // Triangle
409: 			ff7_externals.gamepad_status->button5 = joystick.GetState()->rgbButtons[4] & 0x80; // L1
410: 			ff7_externals.gamepad_status->button6 = joystick.GetState()->rgbButtons[5] & 0x80; // R1
411: 			ff7_externals.gamepad_status->button7 = joystick.GetState()->rgbButtons[6] & 0x80; // L2
412: 			ff7_externals.gamepad_status->button8 = joystick.GetState()->rgbButtons[7] & 0x80; // R2
413: 
414: 			ff7_externals.gamepad_status->button9 = joystick.GetState()->rgbButtons[8] & 0x80; // SELECT
415: 			ff7_externals.gamepad_status->button10 = joystick.GetState()->rgbButtons[9] & 0x80; // START
416: 			ff7_externals.gamepad_status->button11 = joystick.GetState()->rgbButtons[10] & 0x80; // L3
417: 			ff7_externals.gamepad_status->button12 = joystick.GetState()->rgbButtons[11] & 0x80; // R3
418: 			ff7_externals.gamepad_status->button13 = joystick.GetState()->rgbButtons[12] & 0x80; // PS Button
419: 
420: 			// Update the player intent based on the analogue movement
421: 			if (enable_auto_run)
422: 			{
423: 				bx::Vec3 joyDir = {static_cast<float>(joystick.GetState()->lX) / static_cast<float>(joystick.GetDeadZone(1.0f)),
424: 				static_cast<float>(joystick.GetState()->lY) / static_cast<float>(joystick.GetDeadZone(1.0f)), 0.0f};
425: 				auto joyLength = std::min(bx::length(joyDir), 1.0f);
426: 				if (joyLength > run_threshold) gamepad_analogue_intent = INTENT_RUN;
427: 				else if(joyLength > analog_threshold) gamepad_analogue_intent = INTENT_WALK;
428: 			}
429: 		}
430: 	}
431: 
432: 	if(enable_analogue_controls) ff7_use_analogue_controls(analog_threshold);
433: 
434: 	return ff7_externals.gamepad_status;
435: }
436: 
437: void* ff7_engine_exit_game_mode(ff7_game_obj* game_object)
438: {
439: 	void* result;
440: 
441: 	if (game_object)
442: 	{
443: 		result = game_object;
444: 		if (game_object->field_924)
445: 		{
446: 			if (game_object->engine_loop_obj.exit_main)
447: 				game_object->engine_loop_obj.exit_main((struct game_obj*)game_object);
448: 
449: 			ff7_externals.sub_666C13((struct game_obj*)game_object);
450: 			result = ff7_externals.sub_670F9B(game_object->dx_sfx_something);
451: 
452: 			if (ff7_do_reset)
453: 			{
454: 				// Trigger game over and ensure battle mode can be retriggered
455: 				*ff7_externals.word_CC0828 = 0;
456: 				*ff7_externals.byte_CC0D89 = 26;
457: 				*ff7_externals.word_DB958A = 0;
458: 				*ff7_externals.byte_CC164C = 0;
459: 				*ff7_externals.word_CC0DC6 = 0;
460: 
461: 				// Fix possible weird 3D issues that may happens in movies if resetted after some of those
462: 				ff7_externals.modules_global_object->MVCAM_flag = 0;
463: 
464: 				ff7_do_reset = false;
465: 			}
466: 
467: 			if (game_object->engine_loop_obj.enter_main)
468: 				result = game_object->engine_loop_obj.enter_main((struct game_obj*)game_object);
469: 
470: 			game_object->field_924 = 0;
471: 		}
472: 	}
473: 	return result;
474: }
475: 
476: void ff7_on_gameover_enter()
477: {
478: 	// Stop current music
479: 	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF0, 0, 0, 0, 0, 0);
480: 	// Stop current sound
481: 	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF1, 0, 0, 0, 0, 0);
482: 	// Play the gameover music
483: 	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* play_music */ 0x14, /* midi_id */ 0x3A, 0, 0, 0, 0);
484: 
485: 	ff7_externals.start_gameover();
486: }
487: 
488: void ff7_on_gameover_exit()
489: {
490: 	// Stop current music
491: 	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF0, 0, 0, 0, 0, 0);
492: 	// Stop current sound
493: 	((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(/* stop_music */ 0xF1, 0, 0, 0, 0, 0);
494: 
495: 	ff7_externals.gameover_sub_6C12B1();
496: }
497: 
498: BYTE ff7_toggle_battle_field()
499: {
500: 	BYTE ret = ff7_externals.sub_60B260();
501: 
502: 	if (!gamehacks.wantsBattle()) ret = 255;
503: 
504: 	return ret;
505: }
506: 
507: BYTE ff7_toggle_battle_worldmap()
508: {
509: 	BYTE ret = ff7_externals.sub_767C55();
510: 
511: 	if (!gamehacks.wantsBattle()) ret = 0;
512: 
513: 	return ret;
514: }
515: 
516: bool ff7_skip_movies()
517: {
518: 	uint32_t mode = getmode_cached()->driver_mode;
519: 
520: 	// Prevent game acting weird or wrong if movie is skipped
521: 	if (
522: 		*ff7_externals.field_id == 399 ||
523: 		*ff7_externals.field_id == 489 ||
524: 		*ff7_externals.field_id == 490 ||
525: 		*ff7_externals.field_id == 543
526: 	)
527: 	{
528: 		return false;
529: 	}
530: 
531: 	if (ff7_externals.movie_object->is_playing)
532: 	{
533: 		ff7_externals.movie_object->movie_end = 1;
534: 
535: 		if (mode == MODE_ENDINGMOVIE)
536: 		{
537: 			ff7_externals.movie_object->is_playing = 0;
538: 		}
539: 
540: 		if (mode == MODE_FIELD)
541: 		{
542: 			*ff7_externals.word_CC0DD4 = 5;
543: 			*ff7_externals.word_CC1638 = 0;
544: 		}
545: 
546: 		if (*ff7_externals.field_id == 116)
547: 		{
548: 			if (use_external_music)
549: 				ff7_play_midi(2);
550: 			else
551: 				ff7_externals.play_midi(2);
552: 		}
553: 
554: 		return true;
555: 	}
556: 
557: 	return false;
558: }
559: 
560: void* ff7_menu_sub_6FAC38(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5)
561: {
562: 	return ff7_externals.menu_sub_6FAC38(param1, param2, param3, *ff7_externals.millisecond_counter < 0x8000 ? 7 : 0, param5);
563: }
564: 
565: void* ff7_menu_sub_6F5C0C(uint32_t param1, uint32_t param2, uint8_t param3, uint8_t param4, uint32_t param5)
566: {
567: 	return ff7_externals.menu_sub_6F5C0C(param1, param2, param3, *ff7_externals.millisecond_counter < 0x8000 ? 7 : 0, param5);
568: }
569: 
570: void ff7_limit_fps()
571: {
572: 	static time_t last_gametime;
573: 	time_t gametime;
574: 	double framerate = 30.0f;
575: 
576: 	struct ff7_game_obj *game_object = (ff7_game_obj *)common_externals.get_game_object();
577: 	struct game_mode *mode = getmode_cached();
578: 
579: 	switch(mode->driver_mode)
580: 	{
581: 	case MODE_FIELD:
582: 		if (ff7_externals.movie_object->is_playing && !*ff7_externals.field_limit_fps)
583: 		{
584: 			// Some movies do not expect to be frame limited
585: 			qpc_get_time(&last_gametime);
586: 			return;
587: 		}
588: 		break;
589: 	case MODE_GAMEOVER:
590: 		// Gameover screen has nothing to limit
591: 		qpc_get_time(&last_gametime);
592: 		return;
593: 	case MODE_SUBMARINE:
594: 		last_gametime = *ff7_externals.submarine_last_gametime;
595: 		break;
596: 	}
597: 
598: 	if (ff7_fps_limiter < FPS_LIMITER_60FPS)
599: 	{
600: 		switch (mode->driver_mode)
601: 		{
602: 		case MODE_BATTLE:
603: 			if (ff7_fps_limiter < FPS_LIMITER_30FPS) framerate = 15.0f;
604: 			break;
605: 		case MODE_SNOWBOARD:
606: 		case MODE_COASTER:
607: 		case MODE_CONDOR:
608: 		case MODE_MENU:
609: 		case MODE_MAIN_MENU:
610: 			framerate = 60.0f;
611: 			break;
612: 		case MODE_CREDITS:
613: 			framerate = 39.0f;
614: 			break;
615: 		}
616: 	}
617: 	else
618: 	{
619: 		switch (mode->driver_mode)
620: 		{
621: 		case MODE_FIELD:
622: 		case MODE_WORLDMAP:
623: 		case MODE_BATTLE:
624: 		case MODE_SWIRL:
625: 		case MODE_SNOWBOARD:
626: 		case MODE_SUBMARINE:
627: 		case MODE_COASTER:
628: 		case MODE_CONDOR:
629: 		case MODE_MENU:
630: 		case MODE_MAIN_MENU:
631: 			framerate = 60.0f;
632: 			break;
633: 		case MODE_CREDITS:
634: 			framerate = 39.0f;
635: 			break;
636: 		}
637: 	}
638: 
639: 	switch(mode->driver_mode)
640: 	{
641: 	case MODE_SUBMARINE:
642: 		if (*ff7_externals.submarine_minigame_status)
643: 			*ff7_externals.submarine_minigame_status = 0;
644: 		else
645: 			*ff7_externals.submarine_minigame_status = 1;
646: 		break;
647: 	}
648: 
649: 	framerate *= gamehacks.getCurrentSpeedhack();
650: 	double frame_time = game_object->countspersecond / framerate;
651: 
652: 	do qpc_get_time(&gametime);
653: 	while (gametime > last_gametime && qpc_diff_time(&gametime, &last_gametime, nullptr) < frame_time);
654: 
655: 	last_gametime = gametime;
656: }
657: 
658: void ff7_handle_ambient_playback()
659: {
660: 	struct game_mode *mode = getmode_cached();
661: 	static char filename[64]{0};
662: 	static WORD last_field_id = 0, last_triangle_id = 0, last_battle_id = 0;
663: 	bool playing = false;
664: 
665: 	switch (mode->driver_mode)
666: 	{
667: 	case MODE_BATTLE:
668: 		if (last_battle_id != ff7_externals.modules_global_object->battle_id)
669: 		{
670: 			last_battle_id = ff7_externals.modules_global_object->battle_id;
671: 
672: 			sprintf(filename, "bat_%d", last_battle_id);
673: 			nxAudioEngine.playAmbient(filename);
674: 		}
675: 		if (*ff7_externals.is_battle_paused && nxAudioEngine.isAmbientPlaying())
676: 			nxAudioEngine.pauseAmbient();
677: 		else if (!(*ff7_externals.is_battle_paused) && !(nxAudioEngine.isAmbientPlaying()))
678: 			nxAudioEngine.resumeAmbient();
679: 		break;
680: 	case MODE_FIELD:
681: 		if (last_field_id != *common_externals.current_field_id)
682: 		{
683: 			last_field_id = *common_externals.current_field_id;
684: 			last_triangle_id = *common_externals.current_triangle_id;
685: 
686: 			sprintf(filename, "field_%d_%d", last_field_id, *common_externals.current_triangle_id);
687: 			playing = nxAudioEngine.playAmbient(filename);
688: 
689: 			if (!playing)
690: 			{
691: 				sprintf(filename, "field_%d", last_field_id);
692: 				playing = nxAudioEngine.playAmbient(filename);
693: 			}
694: 		}
695: 		else if (common_externals.current_triangle_id != 0 && last_field_id == *common_externals.current_field_id && last_triangle_id != *common_externals.current_triangle_id)
696: 		{
697: 			last_triangle_id = *common_externals.current_triangle_id;
698: 
699: 			sprintf(filename, "field_%d_%d", last_field_id, *common_externals.current_triangle_id);
700: 			playing = nxAudioEngine.playAmbient(filename);
701: 		}
702: 		break;
703: 	default:
704: 		if (last_field_id != 0 || last_battle_id != 0)
705: 		{
706: 			nxAudioEngine.stopAmbient();
707: 			last_field_id = 0;
708: 			last_battle_id = 0;
709: 		}
710: 		break;
711: 	}
712: }
713: 
714: void ff7_handle_voice_playback()
715: {
716: 	switch (getmode_cached()->driver_mode)
717: 	{
718: 	case MODE_BATTLE:
719: 		if (*ff7_externals.g_is_battle_paused && nxAudioEngine.isVoicePlaying())
720: 			nxAudioEngine.pauseVoice();
721: 		else if (!*ff7_externals.g_is_battle_paused && !nxAudioEngine.isVoicePlaying())
722: 			nxAudioEngine.resumeVoice();
723: 		break;
724: 	default:
725: 		break;
726: 	}
727: }
728: 
729: BOOL ff7_write_save_file(char slot)
730: {
731: 	BOOL ret = ff7_externals.write_save_file(slot);
732: 
733: 	uint8_t savefile_num = ((slot & 0xF0) >> 4);
734: 	ffnx_trace("Save: user saved in save%02i\n", savefile_num);
735: 	metadataPatcher.updateFF7(savefile_num);
736: 
737: 	return ret;
738: }
739: 
740: // The function that load the model size sometimes gets a buffer that is non-null terminated, returning weird values.
741: // Replace the native `atoi` call with a custom function that always uses the first 4 bytes to convert the buffer to int
742: int ff7_field_load_models_atoi(const char* str)
743: {
744: 	std::string buf(str, 4);
745: 
746: 	return std::stol(buf);
747: }
748: 
749: //#########################
750: // steam achievement hooks
751: //#########################
752: 
753: int ff7_load_save_file(int param_1){
754: 	int returnValue = ((int(*)(int))ff7_externals.load_save_file)(param_1);
755: 	g_FF7SteamAchievements->initStatsFromSaveFile(*ff7_externals.savemap);
756: 	return returnValue;
757: }
758: 
759: void ff7_chocobo_field_entity_60FA7D(WORD param1, short param2, short param3){
760: 	((void(*)(WORD, short, short)) ff7_externals.sub_60FA7D)(param1, param2, param3);
761: 
762: 	if(param3 == 0x04)
763: 		g_FF7SteamAchievements->unlockGoldChocoboAchievement(ff7_externals.savemap->chocobo_slots_first, ff7_externals.savemap->chocobo_slots_last);
764: }
765: 
766: void ff7_character_regularly_field_entity_60FA7D(WORD param1, short param2, short param3){
767: 	((void(*)(WORD, short, short)) ff7_externals.sub_60FA7D)(param1, param2, param3);
768: 
769: 	if(param3 & (1 << 0) || param3 & (1 << 2))
770: 		g_FF7SteamAchievements->unlockYuffieAndVincentAchievement(ff7_externals.savemap->yuffie_reg_mask, ff7_externals.savemap->vincent_reg_mask);
771: }
</file>

<file path="src/ff7/time.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2023 Cosmos                                             //
  3: //                                                                          //
  4: //    This file is part of FFNx                                             //
  5: //                                                                          //
  6: //    FFNx is free software: you can redistribute it and/or modify          //
  7: //    it under the terms of the GNU General Public License as published by  //
  8: //    the Free Software Foundation, either version 3 of the License         //
  9: //                                                                          //
 10: //    FFNx is distributed in the hope that it will be useful,               //
 11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 13: //    GNU General Public License for more details.                          //
 14: /****************************************************************************/
 15: 
 16: #include "../renderer.h"
 17: #include "../globals.h"
 18: #include "../patch.h"
 19: #include "../cfg.h"
 20: 
 21: #include "time.h"
 22: #include "field/background.h"
 23: 
 24: namespace ff7
 25: {
 26:     Time time;
 27: 
 28:     void Time::init()
 29:     {
 30:         loadConfig();
 31:         initParamsFromConfig();
 32:     }
 33: 
 34:     void Time::loadConfig()
 35:     {
 36:         char _fullpath[MAX_PATH];
 37:         sprintf(_fullpath, "%s/%s/config.toml", basedir, external_time_cycle_path.c_str());
 38: 
 39:         try
 40:         {
 41:             config = toml::parse_file(_fullpath);
 42:         }
 43:         catch (const toml::parse_error &err)
 44:         {
 45:             config = toml::parse("");
 46:         }
 47:     }
 48: 
 49:     void Time::initParamsFromConfig()
 50:     {
 51:         toml::array* morningColorArray = config["morning_color"].as_array();
 52:         if(morningColorArray != nullptr && morningColorArray->size() == 3)
 53:         {
 54:             morningColor.x = morningColorArray->get(0)->value<float>().value_or(1.0);
 55:             morningColor.y = morningColorArray->get(1)->value<float>().value_or(1.0);
 56:             morningColor.z  = morningColorArray->get(2)->value<float>().value_or(1.0);
 57:         }
 58:         toml::array* middayColorArray = config["midday_color"].as_array();
 59:         if(middayColorArray != nullptr && middayColorArray->size() == 3)
 60:         {
 61:             middayColor.x = middayColorArray->get(0)->value<float>().value_or(1.0);
 62:             middayColor.y = middayColorArray->get(1)->value<float>().value_or(1.0);
 63:             middayColor.z  = middayColorArray->get(2)->value<float>().value_or(1.0);
 64:         }
 65:         toml::array* afternoonColorArray = config["afternoon_color"].as_array();
 66:         if(afternoonColorArray != nullptr && afternoonColorArray->size() == 3)
 67:         {
 68:             afternoonColor.x = afternoonColorArray->get(0)->value<float>().value_or(1.0);
 69:             afternoonColor.y = afternoonColorArray->get(1)->value<float>().value_or(1.0);
 70:             afternoonColor.z  = afternoonColorArray->get(2)->value<float>().value_or(1.0);
 71:         }
 72:         toml::array* nightColorArray = config["night_color"].as_array();
 73:         if(nightColorArray != nullptr && nightColorArray->size() == 3)
 74:         {
 75:             nightColor.x = nightColorArray->get(0)->value<float>().value_or(1.0);
 76:             nightColor.y = nightColorArray->get(1)->value<float>().value_or(1.0);
 77:             nightColor.z  = nightColorArray->get(2)->value<float>().value_or(1.0);
 78:         }
 79: 
 80:         sunriseTime = config["sunrise_time"].value_or(6.0) / 24.0;
 81:         morningTime = config["morning_time"].value_or(7.0) / 24.0;
 82:         middayTime = config["midday_time"].value_or(15.0) / 24.0;
 83:         afternoonTime = config["afternoon_time"].value_or(19.0) / 24.0;
 84:         nightTime = config["night_time"].value_or(20.0) / 24.0;
 85: 
 86:         framesPerMinute = config["frames_per_minute"].value_or(15);
 87: 
 88:         auto optionAddressStr = config["options_address"].value<std::string>();
 89:         if(optionAddressStr.has_value())
 90:         {
 91:             auto str = optionAddressStr.value();
 92:             pOptions = (byte*)(std::strtol(str.data(), nullptr, 16));
 93:         }
 94: 
 95:         auto minutesAddressStr = config["minutes_address"].value<std::string>();
 96:         if(minutesAddressStr.has_value())
 97:         {
 98:             auto str = minutesAddressStr.value();
 99:             pMinutes = (byte*)(std::strtol(str.data(), nullptr, 16));
100:         }
101: 
102:         auto hoursAddressStr = config["hours_address"].value<std::string>();
103:         if(hoursAddressStr.has_value())
104:         {
105:             auto str = hoursAddressStr.value();
106:             pHours = (byte*)(std::strtol(str.data(), nullptr, 16));
107:         }
108: 
109:         auto daysAddressStr = config["days_address"].value<std::string>();
110:         if(daysAddressStr.has_value())
111:         {
112:             auto str = daysAddressStr.value();
113:             pDays = (byte*)(std::strtol(str.data(), nullptr, 16));
114:         }
115: 
116:         auto monthsAddressStr = config["months_address"].value<std::string>();
117:         if(monthsAddressStr.has_value())
118:         {
119:             auto str = monthsAddressStr.value();
120:             pMonths = (byte*)(std::strtol(str.data(), nullptr, 16));
121:         }
122: 
123:         auto monthChar0AddressStr = config["month_char_0_address"].value<std::string>();
124:         if(monthChar0AddressStr.has_value())
125:         {
126:             auto str = monthChar0AddressStr.value();
127:             pMonthChar0 = (byte*)(std::strtol(str.data(), nullptr, 16));
128:         }
129: 
130:         auto monthChar1AddressStr = config["month_char_1_address"].value<std::string>();
131:         if(monthChar1AddressStr.has_value())
132:         {
133:             auto str = monthChar1AddressStr.value();
134:             pMonthChar1 = (byte*)(std::strtol(str.data(), nullptr, 16));
135:         }
136: 
137:         auto monthChar2AddressStr = config["month_char_2_address"].value<std::string>();
138:         if(monthChar2AddressStr.has_value())
139:         {
140:             auto str = monthChar2AddressStr.value();
141:             pMonthChar2 = (byte*)(std::strtol(str.data(), nullptr, 16));
142:         }
143: 
144:         for (int i = 0; i < 12; ++i)
145:         {
146:             monthChar0[i] = config["month_" + std::to_string(i) + "_char_0"].value_or(0);
147:             monthChar1[i] = config["month_" + std::to_string(i) + "_char_1"].value_or(0);
148:             monthChar2[i] = config["month_" + std::to_string(i) + "_char_2"].value_or(0);
149:         }
150:     }
151: 
152:     void time_hook_init()
153:     {
154:         replace_call_function(ff7_externals.field_draw_everything + 0x360, ff7::field::draw_gray_quads_sub_644E90);
155:     }
156: 
157:     bx::Vec3 Time::mixColor(float time, float timeMin, float timeMax, bx::Vec3 color0, bx::Vec3 color1)
158:     {
159:         bx::Vec3 color = bx::Vec3(0.0, 0.0, 0.0);
160:         float t = (time - timeMin) / (timeMax - timeMin);
161:         color.x = std::lerp(color0.x, color1.x, t);
162:         color.y = std::lerp(color0.y, color1.y, t);
163:         color.z = std::lerp(color0.z, color1.z, t);
164:         return color;
165:     }
166: 
167:     void Time::update()
168:     {
169:         newRenderer.setTimeEnabled(false);
170:         newRenderer.setTimeFilterEnabled(false);
171: 
172:         if(pOptions == nullptr || pMinutes == nullptr || pHours == nullptr || pDays == nullptr || pMonths == nullptr)
173:         {
174:             return;
175:         }
176: 
177:         // Early return if bit 0 of options variable is not set (global disable)
178:         if((*pOptions & (1 << 0)) == 0) return;
179: 
180:         struct game_mode* mode = getmode_cached();
181:         if(mode->driver_mode != MODE_FIELD &&
182:            mode->driver_mode != MODE_BATTLE &&
183:            mode->driver_mode != MODE_WORLDMAP)
184:         {
185:             return;
186:         }
187: 
188:         // Progress time if bit 1 of options variable is set
189:         if(*pOptions & (1 << 1)) frame_count++;
190: 
191:         int modeFramesPerMinute = framesPerMinute;
192:         if(mode->driver_mode == MODE_BATTLE)
193:             modeFramesPerMinute *= battle_frame_multiplier;
194:         else
195:             modeFramesPerMinute *= 2 * common_frame_multiplier;
196: 
197:         if(frame_count >= modeFramesPerMinute)
198:         {
199:             (*pMinutes) = (*pMinutes) + 1;
200:             frame_count = 0;
201:         }
202:         if(*pMinutes >= 60 )
203:         {
204:             (*pHours) = (*pHours) + 1;
205:             *pMinutes = 0;
206:             frame_count = 0;
207:         }
208:         if(*pHours >= 24)
209:         {
210:             (*pDays) = (*pDays) + 1;
211:             *pHours = 0;
212:         }
213:         if((*pDays) >= 32)
214:         {
215:             (*pMonths) = (*pMonths) + 1;
216:             *pDays = 1;
217:         }
218:         if((*pMonths) >= 12)
219:         {
220:             (*pMonths) = 0;
221:         }
222: 
223:         if(pMonthChar0 != nullptr && pMonthChar1 != nullptr && pMonthChar2 != nullptr)
224:         {
225:             *pMonthChar0 = monthChar0[*pMonths];
226:             *pMonthChar1 = monthChar1[*pMonths];
227:             *pMonthChar2 = monthChar2[*pMonths];
228:         }
229: 
230:         if(mode->driver_mode == MODE_FIELD ||
231:            mode->driver_mode == MODE_BATTLE)
232:         {
233:             // Disable filter if bit 2 of options variable is not set (e.g. when indoor fields)
234:             if((*pOptions & (1 << 2)) == 0)
235:             {
236:                 newRenderer.setTimeEnabled(false);
237:                 newRenderer.setTimeFilterEnabled(false);
238:                 return;
239:             }
240:         }
241: 
242:         float time = (*pHours * 60.0f * modeFramesPerMinute + *pMinutes * modeFramesPerMinute + frame_count);
243:         time /= (1440.0f * modeFramesPerMinute);
244: 
245:         bx::Vec3 color = bx::Vec3(0.0, 0.0, 0.0);
246:         if(time < sunriseTime) color = nightColor;
247:         else if(time < morningTime) color = mixColor(time, sunriseTime, morningTime, nightColor, morningColor);
248:         else if(time < middayTime) color = mixColor(time, morningTime, middayTime, morningColor, middayColor);
249:         else if(time < afternoonTime) color = mixColor(time, middayTime, afternoonTime, middayColor, afternoonColor);
250:         else if(time < nightTime) color = mixColor(time, afternoonTime, nightTime, afternoonColor, nightColor);
251:         else color = nightColor;
252: 
253:         newRenderer.setTimeEnabled(true);
254:         newRenderer.setTimeFilterEnabled(true);
255:         newRenderer.setTimeColor(color);
256:     }
257: }
</file>

<file path="src/ff7/time.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: #pragma once
17: 
18: #include <toml++/toml.h>
19: #include <windows.h>
20: #include "bx/math.h"
21: 
22: namespace ff7
23: {
24:     void time_hook_init();
25: 
26:     class Time
27:     {
28:         public:
29:             void init();
30:             void update();
31: 
32:         private:
33:             void loadConfig();
34:             void initParamsFromConfig();
35:             bx::Vec3 mixColor(float time, float timeMin, float timeMax, bx::Vec3 color0, bx::Vec3 color1);
36: 
37:         private:
38:             // Config
39:             toml::parse_result config;
40: 
41:             bx::Vec3 morningColor  = bx::Vec3(1.0, 1.0, 1.0);
42:             bx::Vec3 middayColor  = bx::Vec3(1.0, 1.0, 1.0);
43:             bx::Vec3 afternoonColor  = bx::Vec3(1.0, 1.0, 1.0);
44:             bx::Vec3 nightColor  = bx::Vec3(1.0, 1.0, 1.0);
45: 
46:             float sunriseTime = 1.0;
47:             float morningTime = 1.0;
48:             float middayTime = 1.0;
49:             float afternoonTime = 1.0;
50:             float nightTime = 1.0;
51: 
52:             int frame_count = 0;
53: 
54:             int framesPerMinute = 0;
55: 
56:             byte* pOptions = nullptr;
57:             byte* pMinutes = nullptr;
58:             byte* pHours = nullptr;
59:             byte* pDays = nullptr;
60:             byte* pMonths = nullptr;
61: 
62:             byte* pMonthChar0 = nullptr;
63:             byte* pMonthChar1 = nullptr;
64:             byte* pMonthChar2 = nullptr;
65: 
66:             byte monthChar0[12];
67:             byte monthChar1[12];
68:             byte monthChar2[12];
69:     };
70: 
71:     extern Time time;
72: }
</file>

<file path="src/ff7/widescreen.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //    Copyright (C) 2023 Cosmos                                             //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "cmath"
 25: 
 26: #include "../ff7.h"
 27: #include "../cfg.h"
 28: #include "../renderer.h"
 29: #include "../video/movies.h"
 30: #include "../movies.h"
 31: #include "../gl.h"
 32: #include "../globals.h"
 33: #include "../patch.h"
 34: 
 35: #include "widescreen.h"
 36: #include "field/defs.h"
 37: #include "field/background.h"
 38: 
 39: int viewport_width_plus_x_widescreen_fix = 750;
 40: int swirl_framebuffer_offset_x_widescreen_fix = 106;
 41: int swirl_framebuffer_offset_y_widescreen_fix = 64;
 42: 
 43: Widescreen widescreen;
 44: 
 45: // This function should be called at each frame after drawing backgrounds and 3d models
 46: void Widescreen::zoomBackground()
 47: {
 48:     if(gl_defer_zoom()) return;
 49: 
 50:     bool is_movie_playing = *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag;
 51:     int width = 0;
 52:     if(is_movie_playing )
 53:     {
 54:         if(widescreen.getMovieMode() == WM_ZOOM) width = 640;
 55:     }
 56:     else if(widescreen.getMode() == WM_ZOOM)
 57:     {
 58:         auto camera_range = widescreen.getCameraRange();
 59:         width = 2 * (camera_range.right - camera_range.left);
 60:     }
 61: 
 62:     if(width == 0) return;
 63: 
 64:     int zoomed_x = (wide_viewport_width - width) / 2;
 65:     float vOffset = (480 - 9 * width / 16) / 2;
 66: 
 67:     uint16_t newX = newRenderer.getInternalCoordX(zoomed_x);
 68:     uint16_t newWidth = newRenderer.getInternalCoordX(width);
 69:     uint16_t newY = newRenderer.getInternalCoordY(vOffset);
 70:     uint16_t newHeight = newRenderer.getInternalCoordY(game_height - 2 * vOffset);
 71: 
 72:     if(is_movie_playing)
 73:     {
 74:         int frame = ffmpeg_get_movie_frame();
 75:         auto keyPair = widescreen.getMovieKeyPair(frame);
 76: 
 77:         uint16_t newY1 = newRenderer.getInternalCoordY(vOffset + keyPair.first.v_offset);
 78:         uint16_t newY2 = newRenderer.getInternalCoordY(vOffset + keyPair.second.v_offset);
 79: 
 80:         float t = 0.0;
 81:         auto seqFrameCount = static_cast<float>(keyPair.second.frame - keyPair.first.frame);
 82:         if(seqFrameCount > 0)
 83:             t =  static_cast<float>(frame - keyPair.first.frame) / static_cast<float>(keyPair.second.frame - keyPair.first.frame);
 84:         t = std::max(std::min(t, 1.0f), 0.0f);
 85:         int newVOffset = std::round(std::lerp(newY1, newY2, t));
 86:         newY = newVOffset;
 87:     }
 88: 
 89:     newRenderer.zoomBackendFrameBuffer(newX, newY, newWidth, newHeight);
 90: }
 91: 
 92: void ifrit_first_wave_effect_widescreen_fix_sub_66A47E(int wave_data_pointer) {
 93: 	int viewport_width_1_fix = ceil(255.f / game_width * wide_viewport_width) - 255;
 94: 	*(short*)(wave_data_pointer + 8) += wide_viewport_x;
 95: 	*(short*)(wave_data_pointer + 16) += wide_viewport_x + viewport_width_1_fix * 2;
 96: 	*(short*)(wave_data_pointer + 24) += wide_viewport_x;
 97: 	*(short*)(wave_data_pointer + 32) += wide_viewport_x + viewport_width_1_fix * 2;
 98: 
 99:     ff7_externals.engine_draw_sub_66A47E(wave_data_pointer);
100: }
101: 
102: void ifrit_second_third_wave_effect_widescreen_fix_sub_66A47E(int wave_data_pointer) {
103: 	int viewport_width_1_fix = ceil(255.f / game_width * wide_viewport_width) - 255;
104: 	int viewport_width_2_fix = ceil(65.f / game_width * wide_viewport_width) - 65;
105: 	*(short*)(wave_data_pointer + 8) += wide_viewport_x + viewport_width_1_fix * 2;
106: 	*(short*)(wave_data_pointer + 16) += wide_viewport_x + (viewport_width_1_fix + viewport_width_2_fix) * 2;
107: 	*(short*)(wave_data_pointer + 24) += wide_viewport_x + viewport_width_1_fix * 2;
108: 	*(short*)(wave_data_pointer + 32) += wide_viewport_x + (viewport_width_1_fix + viewport_width_2_fix) * 2;
109: 
110:     ff7_externals.engine_draw_sub_66A47E(wave_data_pointer);
111: }
112: 
113: void pollensalta_cold_breath_atk_white_dot_effect()
114: {
115:     effect100_data* effect_data = &ff7_externals.effect100_array_data[*ff7_externals.effect100_array_idx];
116:     ff7_externals.pollensalta_cold_breath_atk_draw_white_dots_547E75(*ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar);
117:     if (!*ff7_externals.g_is_battle_paused)
118:     {
119:         for (int i = 0; i < 400; i++)
120:         {
121:             short offset = 2 * (i % 2) + 2;
122:             ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x = (offset + ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x);
123:             if (ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x < wide_viewport_x)
124:                 ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x = ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x + wide_viewport_width;
125:             if (ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x > wide_viewport_width + wide_viewport_x)
126:                 ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x = ff7_externals.pollensalta_cold_breath_white_dots_pos[i].x - wide_viewport_width;
127: 
128:             ff7_externals.pollensalta_cold_breath_white_dots_pos[i].y = (offset + ff7_externals.pollensalta_cold_breath_white_dots_pos[i].y) % wide_viewport_height;
129:         }
130: 
131:         if (effect_data->field_2 < 8)
132:             *ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar += 1;
133:         if (effect_data->field_2 > 42)
134:             *ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar -= 1;
135:         if (++effect_data->field_2 == 50)
136:             effect_data->field_0 = 0xFFFF;
137: 
138:     }
139: }
140: 
141: void ff7_widescreen_fix_chocobo_submit_quad_graphics_object(int x, int y, int width, int height, int color, int unknown, float z_value, DWORD* pointer)
142: {
143: 	if(width == 640) // Replace only quad related to water effect
144: 	{
145: 		x = wide_viewport_x;
146: 		width = wide_viewport_width;
147: 		height = wide_viewport_height;
148: 	}
149: 	ff7_externals.generic_submit_quad_graphics_object_671D2A(x, y, width, height, color, unknown, z_value, pointer);
150: }
151: 
152: void ff7_widescreen_hook_init() {
153:     // Field fix
154:     replace_function((uint32_t)ff7_externals.field_clip_with_camera_range_6438F6, ff7::field::ff7_field_clip_with_camera_range);
155:     replace_function(ff7_externals.field_layer3_clip_with_camera_range_643628, ff7::field::ff7_field_layer3_clip_with_camera_range);
156:     replace_function(ff7_externals.field_culling_model_639252, ff7::field::ff7_field_do_draw_3d_model);
157:     replace_call_function(ff7_externals.field_sub_63AC66 + 0xD5, ff7::field::ff7_field_set_fade_quad_size);
158:     patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x6A, (uint32_t)&wide_viewport_x);
159:     patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x80, (uint32_t)&wide_viewport_x);
160:     patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x94, (uint32_t)&wide_viewport_x);
161:     patch_code_dword(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x9C, (uint32_t)&wide_viewport_x);
162:     patch_code_int(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x64, wide_viewport_width / 2);
163:     patch_code_int(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x7A, wide_viewport_width / 2);
164:     memset_code(ff7_externals.field_submit_draw_pointer_hand_60D572 + 0x39, 0x90, 12); // Remove useless culling cursor
165:     patch_code_int(ff7_externals.field_init_viewport_values + 0xBE, wide_viewport_width + wide_viewport_x - 60);
166:     patch_code_int(ff7_externals.field_init_viewport_values + 0xC8, 18);
167:     // For zoom field maps
168:     replace_call_function(ff7_externals.field_draw_everything + 0x360, ff7::field::draw_gray_quads_sub_644E90);
169: 
170:     // Swirl fix
171:     patch_code_dword(ff7_externals.swirl_loop_sub_4026D4 + 0x335, (uint32_t)&wide_viewport_x);
172:     patch_code_dword(ff7_externals.swirl_enter_sub_401810 + 0x21, (uint32_t)&wide_viewport_width);
173:     patch_code_dword(ff7_externals.swirl_enter_40164E + 0xEE, (uint32_t)&swirl_framebuffer_offset_x_widescreen_fix);
174:     patch_code_dword(ff7_externals.swirl_enter_40164E + 0x112, (uint32_t)&swirl_framebuffer_offset_x_widescreen_fix);
175:     patch_code_dword(ff7_externals.swirl_enter_40164E + 0xFB, (uint32_t)&swirl_framebuffer_offset_y_widescreen_fix);
176:     patch_code_dword(ff7_externals.swirl_enter_40164E + 0x11F, (uint32_t)&swirl_framebuffer_offset_y_widescreen_fix);
177:     patch_code_int(ff7_externals.swirl_enter_40164E + 0xE8, 85);
178: 
179:     // Battle fix
180:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x4B, (uint32_t)&wide_viewport_width);
181:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x68, (uint32_t)&wide_viewport_x);
182:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x8B, (uint32_t)&wide_viewport_width);
183:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0xB4, (uint32_t)&wide_viewport_x);
184:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x105, (uint32_t)&wide_viewport_width);
185:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x122, (uint32_t)&wide_viewport_x);
186:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x141, (uint32_t)&wide_viewport_width);
187:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x16A, (uint32_t)&wide_viewport_x);
188:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x19F, (uint32_t)&wide_viewport_width);
189:     patch_code_dword(ff7_externals.battle_sub_5BD050 + 0x1BB, (uint32_t)&wide_viewport_x);
190:     patch_code_int(ff7_externals.battle_enter + 0x1E8, wide_viewport_y);
191:     patch_code_int(ff7_externals.battle_enter + 0x21A, wide_viewport_height);
192:     patch_code_dword(ff7_externals.battle_enter + 0x229, (uint32_t)&wide_viewport_width);
193:     patch_code_dword(ff7_externals.battle_enter + 0x22F, (uint32_t)&wide_viewport_x);
194:     patch_code_dword(ff7_externals.battle_draw_quad_5BD473 + 0xDA, (uint32_t)&wide_viewport_x);
195:     patch_code_dword(ff7_externals.battle_draw_quad_5BD473 + 0x112, (uint32_t)&wide_viewport_x);
196:     patch_code_dword(ff7_externals.battle_sub_58ACB9 + 0x55, (uint32_t)&wide_viewport_x);
197:     patch_code_dword(ff7_externals.battle_sub_58ACB9 + 0x65, (uint32_t)&wide_viewport_x);
198:     patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x23F, (uint32_t)&wide_viewport_x);
199:     patch_code_dword(ff7_externals.display_battle_damage_5BB410 + 0x24C, (uint32_t)&wide_viewport_x);
200:     patch_code_int(ff7_externals.shadow_flare_draw_white_bg_57747E + 0x18, wide_viewport_x);
201:     patch_code_int(ff7_externals.shadow_flare_draw_white_bg_57747E + 0x1F, wide_viewport_width / 2);
202:     patch_code_int(ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0 + 0x83, wide_viewport_width);
203:     patch_code_int(ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0 + 0x8D, wide_viewport_height);
204:     patch_code_short(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0 + 0x191, wide_viewport_x - 200);
205:     patch_code_dword(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0 + 0x39, (uint32_t)&pollensalta_cold_breath_atk_white_dot_effect);
206:     patch_code_int(ff7_externals.pandora_box_skill_draw_bg_flash_effect_568371 + 0x3D, wide_viewport_x - 170);
207: 
208:     // Battle summon fix
209:     replace_call_function(ff7_externals.ifrit_sub_595A05 + 0x930, ifrit_first_wave_effect_widescreen_fix_sub_66A47E);
210:     replace_call_function(ff7_externals.ifrit_sub_595A05 + 0xAEC, ifrit_second_third_wave_effect_widescreen_fix_sub_66A47E);
211:     replace_call_function(ff7_externals.ifrit_sub_595A05 + 0xCC0, ifrit_second_third_wave_effect_widescreen_fix_sub_66A47E);
212:     patch_code_int(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x58, wide_viewport_width / 4);
213:     patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x5D, (uint32_t)&wide_viewport_width);
214:     patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x6A, (uint32_t)&wide_viewport_x);
215:     patch_code_int(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x88, wide_viewport_width / 4);
216:     patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x1A2, (uint32_t)&wide_viewport_x);
217:     patch_code_dword(ff7_externals.neo_bahamut_effect_sub_490F2A + 0x1AF, (uint32_t)&wide_viewport_width);
218:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x140, (uint32_t)&wide_viewport_x);
219:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x15B, (uint32_t)&wide_viewport_width);
220:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x19B, (uint32_t)&wide_viewport_x);
221:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x1D1, (uint32_t)&wide_viewport_width);
222:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x20E, (uint32_t)&wide_viewport_x);
223:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x243, (uint32_t)&wide_viewport_width);
224:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x28A, (uint32_t)&wide_viewport_x);
225:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x2C0, (uint32_t)&wide_viewport_width);
226:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x2FC, (uint32_t)&wide_viewport_x);
227:     patch_code_dword(ff7_externals.run_bahamut_neo_main_48C2A1 + 0x332, (uint32_t)&wide_viewport_width);
228:     patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A3A2E + 0x38, (uint32_t)&wide_viewport_x);
229:     patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A3A2E + 0x53, (uint32_t)&wide_viewport_width);
230:     patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A4BE6 + 0x36, (uint32_t)&wide_viewport_x);
231:     patch_code_dword(ff7_externals.odin_gunge_effect_sub_4A4BE6 + 0x51, (uint32_t)&wide_viewport_width);
232:     patch_code_dword(ff7_externals.typhoon_effect_sub_4D7044 + 0x1B, (uint32_t)&wide_viewport_x);
233:     patch_code_dword(ff7_externals.typhoon_effect_sub_4D7044 + 0x36, (uint32_t)&wide_viewport_width);
234:     patch_code_dword(ff7_externals.typhoon_effect_sub_4DB15F + 0x22, (uint32_t)&wide_viewport_x);
235:     patch_code_dword(ff7_externals.typhoon_effect_sub_4DB15F + 0x3D, (uint32_t)&wide_viewport_width);
236:     patch_code_dword(ff7_externals.barret_limit_3_1_sub_4700F7 + 0x1B, (uint32_t)&wide_viewport_x);
237:     patch_code_dword(ff7_externals.barret_limit_3_1_sub_4700F7 + 0x36, (uint32_t)&wide_viewport_width);
238:     patch_code_dword(ff7_externals.fat_chocobo_sub_5096F3 + 0x4A, (uint32_t)&wide_viewport_x);
239:     patch_code_dword(ff7_externals.fat_chocobo_sub_5096F3 + 0x5F, (uint32_t)&wide_viewport_width);
240:     // Makes bahamut small stars background to 512x512 quad size and a different positioning of the 6 image patches
241:     patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x20F, -512);
242:     patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x23F, 1024);
243:     patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x26F, 512);
244:     patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x29E, 512);
245:     patch_code_short(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA + 0x2CE, 512);
246:     patch_code_short(ff7_externals.bahamut_zero_bg_star_graphics_data_7F6748 + 0x8, 512);
247:     patch_code_short(ff7_externals.bahamut_zero_bg_star_graphics_data_7F6748 + 0xA, 512);
248: 
249:     // Battle fading animation fix
250:     patch_code_short(ff7_externals.battle_sub_5BCF9D + 0x3A, 30);
251:     patch_code_byte(ff7_externals.battle_sub_5BCF9D + 0x69, 120);
252:     patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x46, 72);
253:     patch_code_byte(ff7_externals.battle_sub_5BD050 + 0xA5, 72);
254:     patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x87, 48);
255:     patch_code_byte(ff7_externals.battle_sub_5BD050 + 0xDC, 48);
256:     patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x100, 48);
257:     patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x15C, 48);
258:     patch_code_byte(ff7_externals.battle_sub_5BD050 + 0x186, 48);
259: 
260:     // Worldmap fix
261:     patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x12, (uint32_t)&wide_viewport_x);
262:     patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x1A3, (uint32_t)&wide_viewport_width);
263:     patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x2BE, (uint32_t)&wide_viewport_width);
264:     patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x331, (uint32_t)&wide_viewport_width);
265:     patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x4E8, (uint32_t)&wide_viewport_width);
266:     patch_code_dword(ff7_externals.world_draw_fade_quad_75551A + 0x54A, (uint32_t)&wide_viewport_width);
267:     patch_code_dword(ff7_externals.world_culling_bg_meshes_75F263 + 0xE, (uint32_t)&wide_viewport_x);
268:     patch_code_dword(ff7_externals.world_culling_bg_meshes_75F263 + 0x20, (uint32_t)&wide_viewport_width);
269:     patch_code_dword(ff7_externals.world_culling_bg_meshes_75F263 + 0x26, (uint32_t)&wide_viewport_x);
270:     patch_code_dword(ff7_externals.world_submit_draw_bg_meshes_75F68C + 0xAE, (uint32_t)&wide_viewport_width);
271:     patch_code_dword(ff7_externals.world_submit_draw_bg_meshes_75F68C + 0xB6, (uint32_t)&wide_viewport_x);
272:     memset_code(ff7_externals.world_sub_751EFC + 0xC89, 0x90, 6);
273: 
274:     patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x174, -wide_viewport_width / 4 - 20);
275:     patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x1D1, wide_viewport_width / 4 + 20);
276:     patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x22E, -wide_viewport_width / 4 - 20);
277:     patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x282, wide_viewport_width / 4 + 20);
278:     patch_code_byte(ff7_externals.world_compute_skybox_data_754100 + 0x180, 44);
279:     patch_code_byte(ff7_externals.world_compute_skybox_data_754100 + 0x1DD, 44);
280:     patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x237, 20);
281:     patch_code_short(ff7_externals.world_compute_skybox_data_754100 + 0x28B, 20);
282:     patch_code_short(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x132, -256);
283:     patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x144, 256);
284:     patch_code_byte(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x15C, 0);
285:     patch_code_short(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x16D, 256);
286:     patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x2DC, 0);
287:     patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x40F, 0);
288:     patch_code_dword(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x5A5, (uint32_t)&wide_viewport_x); // Meteor avoid culling
289:     patch_code_int(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 + 0x5B5, wide_viewport_width / 2); // Meteor avoid culling
290: 
291:     // Gameover fix
292:     patch_code_int(ff7_externals.enter_gameover + 0xA4, wide_viewport_x);
293:     patch_code_int(ff7_externals.enter_gameover + 0xB8, wide_viewport_width);
294: 
295:     // CDCheck fix
296:     patch_code_int(ff7_externals.cdcheck_enter_sub + 0xB9, wide_viewport_x);
297:     patch_code_int(ff7_externals.cdcheck_enter_sub + 0xCD, wide_viewport_width);
298: 
299:     // Credits fix
300:     patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0x99, (uint32_t)&wide_viewport_x);
301:     patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0xE6, (uint32_t)&wide_viewport_x);
302:     patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0x133, (uint32_t)&viewport_width_plus_x_widescreen_fix);
303:     patch_code_dword(ff7_externals.credits_submit_draw_fade_quad_7AA89B + 0x180, (uint32_t)&viewport_width_plus_x_widescreen_fix);
304: 
305:     // Highway fix
306:     patch_code_int(ff7_externals.highway_submit_fade_quad_659532 + 0x5F, wide_viewport_width);
307:     patch_code_char(ff7_externals.highway_submit_fade_quad_659532 + 0x66, wide_viewport_x);
308: 
309:     // Chocobo fix
310:     patch_code_int(ff7_externals.chocobo_init_viewport_values_76D320 + 0x1F, wide_viewport_height);
311:     patch_code_char(ff7_externals.chocobo_init_viewport_values_76D320 + 0x29, wide_viewport_y);
312:     patch_code_int(ff7_externals.chocobo_init_viewport_values_76D320 + 0x62, wide_viewport_y);
313:     patch_code_dword((uint32_t)ff7_externals.chocobo_submit_draw_fade_quad_77B1CE + 0x99, (uint32_t)&wide_viewport_x);
314:     patch_code_int((uint32_t)ff7_externals.chocobo_fade_quad_data_97A498 + 0x28, wide_viewport_width / 2);
315:     replace_call_function(ff7_externals.chocobo_submit_draw_water_quad_77A7D0 + 0x9F, ff7_widescreen_fix_chocobo_submit_quad_graphics_object);
316: 
317:     // Snowboard fix
318:     patch_code_int(ff7_externals.snowboard_draw_sky_and_mountains_72DAF0 + 0xCC, ceil(wide_viewport_width / 4));
319:     patch_code_int(ff7_externals.snowboard_draw_sky_and_mountains_72DAF0 + 0x140, ceil(wide_viewport_width / 4));
320:     patch_code_float((uint32_t)ff7_externals.snowboard_sky_quad_pos_x_7B7DB8, wide_viewport_x);
321:     patch_code_int(ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F + 0x173, wide_viewport_width + wide_viewport_x);
322:     patch_code_int(ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F + 0x225, wide_viewport_width + wide_viewport_x);
323:     patch_code_int(ff7_externals.snowboard_submit_draw_black_quad_graphics_object_72DD94 + 0x27, wide_viewport_width);
324:     patch_code_char(ff7_externals.snowboard_submit_draw_black_quad_graphics_object_72DD94 + 0x2E, wide_viewport_x);
325:     patch_code_int(ff7_externals.snowboard_submit_draw_white_fade_quad_graphics_object_72DD53 + 0x27, wide_viewport_width);
326:     patch_code_char(ff7_externals.snowboard_submit_draw_white_fade_quad_graphics_object_72DD53 + 0x2E, wide_viewport_x);
327:     patch_code_int(ff7_externals.snowboard_submit_draw_opaque_quad_graphics_object_72DDD5 + 0x1F, wide_viewport_width);
328:     patch_code_char(ff7_externals.snowboard_submit_draw_opaque_quad_graphics_object_72DDD5 + 0x26, wide_viewport_x);
329: 
330:     // Menu, endbattle menu, ... fixes
331:     patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x50, (uint32_t)&wide_viewport_x);
332:     patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0xA8, (uint32_t)&wide_viewport_x);
333:     patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x105, (uint32_t)&wide_viewport_x);
334:     patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x163, (uint32_t)&wide_viewport_x);
335:     patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x111, (uint32_t)&wide_viewport_width);
336:     patch_code_dword(ff7_externals.menu_submit_draw_fade_quad_6CD64E + 0x16F, (uint32_t)&wide_viewport_width);
337: }
338: 
339: void Widescreen::loadConfig()
340: {
341:     char _fullpath[MAX_PATH];
342:     sprintf(_fullpath, "%s/%s/config.toml", basedir, external_widescreen_path.c_str());
343: 
344:     try
345:     {
346:         config = toml::parse_file(_fullpath);
347:     }
348:     catch (const toml::parse_error &err)
349:     {
350:         config = toml::parse("");
351:     }
352: }
353: 
354: void Widescreen::loadMovieConfig()
355: {
356:     char _fullpath[MAX_PATH];
357:     sprintf(_fullpath, "%s/%s/movie_config.toml", basedir, external_widescreen_path.c_str());
358: 
359:     try
360:     {
361:         movie_config = toml::parse_file(_fullpath);
362:     }
363:     catch (const toml::parse_error &err)
364:     {
365:         movie_config = toml::parse("");
366:     }
367: }
368: 
369: void Widescreen::init()
370: {
371:     loadConfig();
372:     loadMovieConfig();
373:     if (aspect_ratio == AR_WIDESCREEN_16X10)
374:     {
375:         wide_viewport_x = -64;
376:         wide_viewport_width = 768;
377:         wide_game_width = 768;
378:         viewport_width_plus_x_widescreen_fix = 704;
379:         swirl_framebuffer_offset_x_widescreen_fix = 64;
380:     }
381: }
382: 
383: void Widescreen::initParamsFromConfig()
384: {
385:     field_trigger_header* field_triggers_header_ptr = *ff7_externals.field_triggers_header;
386:     camera_range.left = field_triggers_header_ptr->camera_range.left;
387:     camera_range.right = field_triggers_header_ptr->camera_range.right;
388:     camera_range.bottom = field_triggers_header_ptr->camera_range.bottom;
389:     camera_range.top = field_triggers_header_ptr->camera_range.top;
390:     if(camera_range.right - camera_range.left >= game_width / 2 + abs(wide_viewport_x))
391:         widescreen_mode = WM_EXTEND_WIDE;
392:     else
393:         widescreen_mode = WM_DISABLED;
394:     h_offset = 0;
395:     v_offset = 0;
396:     is_reset_vertical_pos = false;
397:     is_scripted_clip_enabled = true;
398:     is_scripted_vertical_clip_enabled = false;
399:     movie_v_offset.clear();
400: 
401:     auto pName = get_current_field_name();
402:     if(pName == 0) return;
403: 
404:     std::string _name(pName);
405:     auto node = config[_name];
406:     if(node)
407:     {
408:         if(auto leftNode = node["left"]) camera_range.left = leftNode.value_or(0);
409:         if(auto rightNode = node["right"]) camera_range.right = rightNode.value_or(0);
410:         if(auto bottomNode = node["bottom"])camera_range.bottom = bottomNode.value_or(0);
411:         if(auto topNode = node["top"]) camera_range.top = topNode.value_or(0);
412:         if(auto hOffsetNode = node["h_offset"]) h_offset = hOffsetNode.value_or(0);
413:         if(auto vOffsetNode = node["v_offset"]) v_offset = vOffsetNode.value_or(0);
414:         if(auto vResetVerticalPosNode = node["reset_vertical_pos"]) is_reset_vertical_pos = vResetVerticalPosNode.value_or(false);
415:         if(auto vScriptedClipNode = node["scripted_clip"]) is_scripted_clip_enabled = vScriptedClipNode.value_or(true);
416:         if(auto vScriptedVerticalClipNode = node["scripted_vertical_clip"]) is_scripted_vertical_clip_enabled = vScriptedVerticalClipNode.value_or(false);
417: 
418:         if(auto modeNode = node["mode"]) widescreen_mode = static_cast<WIDESCREEN_MODE>(modeNode.value_or(0));
419: 
420:         if(widescreen_mode == WM_ZOOM)
421:         {
422:             int verticalRangeOffset = 9 * (camera_range.right - camera_range.left) / 16 - 240;
423:             camera_range.bottom -= verticalRangeOffset / 2;
424:             camera_range.top += verticalRangeOffset / 2;
425:         }
426:     }
427: }
428: 
429: void Widescreen::initMovieParamsFromConfig(char *name)
430: {
431:     widescreen_movie_mode = WM_DISABLED;
432:     movie_v_offset.clear();
433: 
434:     if(name == 0) return;
435: 
436:     std::string _name(name);
437:     auto node = movie_config[_name];
438:     if(node)
439:     {
440:         if(auto modeNode = node["mode"]) widescreen_movie_mode = static_cast<WIDESCREEN_MODE>(modeNode.value_or(0));
441: 
442:         if(auto movie_v_offset_node = node["movie_v_offset"])
443:         {
444:             auto array = movie_v_offset_node.as_array();
445:             auto size = array->size();
446:             movie_v_offset.resize(size);
447:             for (int i = 0; i < size; ++i)
448:             {
449:                 auto keyframeArray = array->get(i)->as_array();
450:                 movie_v_offset[i].frame = keyframeArray->get(0)->value<int>().value_or(0);
451:                 movie_v_offset[i].v_offset = keyframeArray->get(1)->value<int>().value_or(0);
452:             }
453:         }
454:     }
455: }
456: 
457: KeyPair Widescreen::getMovieKeyPair(int frame)
458: {
459:     KeyPair ret;
460: 
461:     int keyCount = movie_v_offset.size();
462:     for(int keyIndex = 0; keyIndex < keyCount; ++keyIndex)
463:     {
464:         auto key = movie_v_offset[keyIndex];
465:         if(keyIndex == keyCount-1)
466:         {
467:             ret.first.frame = key.frame * movie_fps_ratio;
468:             ret.first.v_offset = key.v_offset;
469:             ret.second.frame = key.frame * movie_fps_ratio;
470:             ret.second.v_offset = key.v_offset;
471:             break;
472:         }
473: 
474:         auto nextKey = movie_v_offset[keyIndex + 1];
475:         auto keyFrame = key.frame * movie_fps_ratio;
476:         auto nextkeyFrame = nextKey.frame * movie_fps_ratio;
477:         if(frame >= keyFrame && frame < nextkeyFrame)
478:         {
479:             auto nextKey = movie_v_offset[keyIndex + 1];
480:             ret.first.frame = keyFrame;
481:             ret.first.v_offset = key.v_offset;
482:             ret.second.frame = nextkeyFrame;
483:             ret.second.v_offset = nextKey.v_offset;
484:             break;
485:         }
486:     }
487: 
488:     return ret;
489: }
</file>

<file path="src/ff7/widescreen.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //    Copyright (C) 2023 Cosmos                                             //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #pragma once
 25: 
 26: #include <vector>
 27: #include <toml++/toml.h>
 28: 
 29: #include "common.h"
 30: #include "ff7.h"
 31: #include "../widescreen.h"
 32: 
 33: void ff7_widescreen_hook_init();
 34: 
 35: enum WIDESCREEN_MODE
 36: {
 37:     WM_DISABLED,
 38:     WM_EXTEND_ONLY,
 39:     WM_ZOOM,
 40:     WM_EXTEND_WIDE,
 41:     WM_FILL
 42: };
 43: 
 44: struct Keyframe
 45: {
 46:     int frame = 0;
 47:     int v_offset = 0;
 48: };
 49: 
 50: struct KeyPair
 51: {
 52:     Keyframe first;
 53:     Keyframe second;
 54: };
 55: 
 56: class Widescreen
 57: {
 58: public:
 59:     void init();
 60:     void initParamsFromConfig();
 61:     void initMovieParamsFromConfig(char *name);
 62: 
 63:     const field_camera_range& getCameraRange();
 64:     int getHorizontalOffset();
 65:     int getVerticalOffset();
 66:     bool isResetVerticalPos();
 67:     bool isScriptedClipEnabled();
 68:     bool isScriptedVerticalClipEnabled();
 69:     WIDESCREEN_MODE getMode();
 70: 
 71:     KeyPair getMovieKeyPair(int frame);
 72:     WIDESCREEN_MODE getMovieMode();
 73: 
 74:     void zoomBackground();
 75: 
 76: private:
 77:     void loadConfig();
 78:     void loadMovieConfig();
 79: 
 80: private:
 81:     // Config
 82:     toml::parse_result config;
 83:     toml::parse_result movie_config;
 84: 
 85:     field_camera_range camera_range;
 86:     int h_offset = 0;
 87:     int v_offset = 0;
 88:     bool is_reset_vertical_pos = false;
 89:     bool is_scripted_clip_enabled = true;
 90:     bool is_scripted_vertical_clip_enabled = false;
 91:     WIDESCREEN_MODE widescreen_mode = WM_DISABLED;
 92: 
 93:     std::vector<Keyframe> movie_v_offset;
 94:     WIDESCREEN_MODE widescreen_movie_mode = WM_DISABLED;
 95: };
 96: 
 97: inline const field_camera_range& Widescreen::getCameraRange()
 98: {
 99:     return camera_range;
100: }
101: 
102: inline int Widescreen::getHorizontalOffset()
103: {
104:     return h_offset;
105: }
106: 
107: inline int Widescreen::getVerticalOffset()
108: {
109:     return v_offset;
110: }
111: 
112: inline bool Widescreen::isResetVerticalPos()
113: {
114:     return is_reset_vertical_pos;
115: }
116: 
117: inline bool Widescreen::isScriptedClipEnabled()
118: {
119:     return is_scripted_clip_enabled;
120: }
121: 
122: inline bool Widescreen::isScriptedVerticalClipEnabled()
123: {
124:     return is_scripted_vertical_clip_enabled;
125: }
126: 
127: inline WIDESCREEN_MODE Widescreen::getMode()
128: {
129:     struct game_mode* mode = getmode_cached();
130:     if (mode->driver_mode != MODE_FIELD) return WM_DISABLED;
131: 
132:     return widescreen_mode;
133: }
134: 
135: inline WIDESCREEN_MODE Widescreen::getMovieMode()
136: {
137:     return widescreen_movie_mode;
138: }
139: 
140: extern Widescreen widescreen;
</file>

<file path="src/ff8/battle/effects.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2024 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: namespace FF8BattleEffect {
27:     // See https://github.com/DarkShinryu/doomtrain/blob/master/Doomtrain/Resources/Magic_ID_List.txt
28:     enum Effect {
29:         Cure = 0,
30:         Leviathan = 5,
31:         Scan = 39,
32:         Tonberry = 89,
33:         Siren = 94,
34:         Minimog = 95,
35:         BokoChocofire = 96,
36:         BokoChocoflare = 97,
37:         BokoChocometeor = 98,
38:         BokoChocobocle = 99,
39:         Quezacotl = 115,
40:         Phoenix = 139,
41:         Ultima = 148,
42:         Shiva = 184,
43:         Odin = 186,
44:         Doomtrain = 190,
45:         Cactuar = 198,
46:         Ifrit = 200,
47:         Bahamut = 201,
48:         Cerberus = 202,
49:         Alexander = 203,
50:         Brothers = 204,
51:         Eden = 205,
52:         Apocalypse = 220,
53:         Meteor = 222,
54:         Carbuncle = 277,
55:         Pandemona = 290,
56:         Diablos = 324,
57:         GilgameshZantetsukenReverse = 325,
58:         GilgameshZantetsuken = 326,
59:         GilgameshMasamune = 327,
60:         GilgameshExcaliber = 328,
61:         GilgameshExcalipoor = 329,
62:         Moomba = 337,
63:     };
64: }
65: 
66: namespace FF8BattleEffectOpcode {
67:     enum Opcode {
68:         UploadTexture39 = 39,
69:         UploadPalette75 = 75
70:     };
71: }
</file>

<file path="src/ff8/battle/stage.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "stage.h"
 25: #include "../../image/tim.h"
 26: #include "../../log.h"
 27: 
 28: #include <set>
 29: #include <unordered_map>
 30: 
 31: const uint8_t *ff8_battle_stage_search_model(const uint8_t *stage_data, size_t stage_data_size, std::list<uint32_t> &model_offsets)
 32: {
 33:     const uint32_t *stage_data_32 = reinterpret_cast<const uint32_t *>(stage_data);
 34:     const uint32_t *stage_data_end = reinterpret_cast<const uint32_t *>(stage_data + stage_data_size);
 35:     bool ok = false;
 36: 
 37:     // Looking for 00010001
 38:     while (stage_data_32 < stage_data_end) {
 39:         if (*stage_data_32 == 0x00010001) {
 40:             const uint32_t *stage_data_32_2 = stage_data_32 - 1;
 41: 
 42:             // Parse model offsets list
 43:             do {
 44:                 model_offsets.push_front(*stage_data_32_2);
 45: 
 46:                 if (*stage_data_32_2 == (model_offsets.size() + 1) * 4 && *(stage_data_32_2 - 1) == model_offsets.size()) {
 47:                     ok = true;
 48:                     break;
 49:                 }
 50: 
 51:                 --stage_data_32_2;
 52:             } while (*stage_data_32_2 != 0 && *stage_data_32_2 >= *(stage_data_32_2 - 1) &&  *stage_data_32_2 < stage_data_size);
 53: 
 54:             if (ok) {
 55:                 break;
 56:             }
 57:         }
 58: 
 59:         ++stage_data_32;
 60:     }
 61: 
 62:     if (!ok) {
 63:         ffnx_warning("%s: models not found\n", __func__);
 64: 
 65:         return nullptr;
 66:     }
 67: 
 68:     return reinterpret_cast<const uint8_t *>(stage_data_32 - model_offsets.size() - 1);
 69: }
 70: 
 71: bool ff8_battle_stage_parse_geometry(const uint8_t *stage_data, size_t stage_data_size, Stage &stage)
 72: {
 73:     std::list<uint32_t> model_offsets;
 74: 
 75:     const uint8_t *models_section_start = ff8_battle_stage_search_model(stage_data + 0x500, stage_data_size - 0x500, model_offsets);
 76: 
 77:     if (models_section_start == nullptr) {
 78:         return false;
 79:     }
 80: 
 81:     do {
 82:         const uint8_t *after_vertices = nullptr;
 83: 
 84:         for (uint32_t offset: model_offsets) {
 85:             const uint8_t *model_section_start = models_section_start + offset;
 86:             uint16_t vertice_count = *(uint16_t *)(model_section_start + 4);
 87:             after_vertices = model_section_start + 6 + vertice_count * 6 + 4;
 88:             uint32_t unknown1 = *(uint32_t *)(after_vertices - 4);
 89: 
 90:             // Padding
 91:             after_vertices += (after_vertices - stage_data) % 4;
 92:             uint16_t triangles_count = *(uint16_t *)after_vertices, quads_count = *(((uint16_t *)after_vertices) + 1);
 93:             uint32_t unknown2 = *(uint32_t *)(after_vertices + 4);
 94: 
 95:             after_vertices += 8;
 96: 
 97:             for (int triangle_id = 0; triangle_id < triangles_count; ++triangle_id) {
 98:                 FF8StageTriangle triangle = FF8StageTriangle();
 99: 
100:                 memcpy(&triangle, after_vertices, sizeof(FF8StageTriangle));
101: 
102:                 stage.triangles.push_back(triangle);
103: 
104:                 after_vertices += sizeof(FF8StageTriangle);
105:             }
106: 
107:             for (int quad_id = 0; quad_id < quads_count; ++quad_id) {
108:                 FF8StageQuad quad = FF8StageQuad();
109: 
110:                 memcpy(&quad, after_vertices, sizeof(FF8StageQuad));
111: 
112:                 stage.quads.push_back(quad);
113: 
114:                 after_vertices += sizeof(FF8StageQuad);
115:             }
116:         }
117: 
118:         if (after_vertices == nullptr) {
119:             break;
120:         }
121: 
122:         models_section_start = nullptr;
123: 
124:         uint32_t next_models_count = *(uint32_t *)(after_vertices + 0x98);
125: 
126:         if (next_models_count < 65535) {
127:             const uint8_t *pos_next_model = after_vertices + 0x9C + next_models_count * sizeof(uint32_t);
128: 
129:             if (uint32_t(pos_next_model) > uint32_t(after_vertices) && pos_next_model - stage_data < stage_data_size && *(uint32_t *)pos_next_model == 0x00010001)
130:             {
131:                 model_offsets.clear();
132:                 models_section_start = ff8_battle_stage_search_model(pos_next_model, stage_data_size - (pos_next_model - stage_data), model_offsets);
133:             }
134:         }
135:     } while (models_section_start != nullptr);
136: 
137:     return true;
138: }
139: 
140: bool ff8_battle_state_save_texture(const Stage &stage, const Tim &tim, const char *filename)
141: {
142:     std::unordered_map<uint8_t, std::set<uint8_t> > palsPerTexture;
143: 
144:     // Group palettes by texture ids
145:     for (const FF8StageTriangle &triangle: stage.triangles) {
146:         palsPerTexture[triangle.tex_id & 0xF].insert((triangle.pal_id >> 6) & 0xF);
147:     }
148: 
149:     for (const FF8StageQuad &quad: stage.quads) {
150:         palsPerTexture[quad.tex_id & 0xF].insert((quad.pal_id >> 6) & 0xF);
151:     }
152: 
153:     std::vector<TimRect> rectangles;
154: 
155:     for (const std::pair<uint8_t, std::set<uint8_t> > &pair: palsPerTexture) {
156:         uint8_t texId = pair.first;
157: 
158:         if (pair.second.size() > 1) {
159:             // List areas with palette ids
160:             std::set<TimRect> rects;
161: 
162:             for (const FF8StageTriangle &triangle: stage.triangles) {
163:                 if (texId != (triangle.tex_id & 0xF)) {
164:                     continue;
165:                 }
166: 
167:                 uint32_t x1, y1, x2, y2;
168: 
169:                 x1 = std::min(std::min(triangle.u1, triangle.u2), triangle.u3);
170:                 y1 = std::min(std::min(triangle.v1, triangle.v2), triangle.v3);
171:                 x2 = std::max(std::max(triangle.u1, triangle.u2), triangle.u3);
172:                 y2 = std::max(std::max(triangle.v1, triangle.v2), triangle.v3);
173: 
174:                 uint8_t palId = (triangle.pal_id >> 6) & 0xF;
175:                 TimRect rect(palId, x1, y1, x2, y2);
176:                 if (rect.isValid()) {
177:                     rects.insert(rect);
178:                 }
179:             }
180: 
181:             for (const FF8StageQuad &quad: stage.quads) {
182:                 if (texId != (quad.tex_id & 0xF)) {
183:                     continue;
184:                 }
185: 
186:                 uint32_t x1, y1, x2, y2;
187: 
188:                 x1 = std::min(std::min(std::min(quad.u1, quad.u2), quad.u3), quad.u4);
189:                 y1 = std::min(std::min(std::min(quad.v1, quad.v2), quad.v3), quad.v4);
190:                 x2 = std::max(std::max(std::max(quad.u1, quad.u2), quad.u3), quad.u4);
191:                 y2 = std::max(std::max(std::max(quad.v1, quad.v2), quad.v3), quad.v4);
192: 
193:                 uint8_t palId = (quad.pal_id >> 6) & 0xF;
194:                 TimRect rect(palId, x1, y1, x2, y2);
195:                 if (rect.isValid()) {
196:                     rects.insert(rect);
197:                 }
198:             }
199: 
200:             // Merge areas together
201:             std::set<TimRect> rectsMerged;
202:             TimRect previousRect;
203: 
204:             while (true) {
205:                 for (const TimRect &rect: rects) {
206:                     if (! previousRect.isValid()) {
207:                         previousRect = rect;
208: 
209:                         continue;
210:                     }
211: 
212:                     if (previousRect.palIndex == rect.palIndex
213:                             && previousRect.x2 == rect.x1
214:                             && previousRect.y1 == rect.y1 && previousRect.y2 == rect.y2) { // Same height, vertically aligned
215:                         previousRect.x2 = rect.x2; // Increase rect horizontally
216:                     } else if (previousRect.palIndex == rect.palIndex
217:                             && previousRect.x1 == rect.x1 && previousRect.x2 == rect.x2
218:                             && previousRect.y2 == rect.y1) { // Same width, horizontally aligned
219:                         previousRect.y2 = rect.y2; // Increase rect vertically
220:                     } else if (previousRect.palIndex == rect.palIndex
221:                             && previousRect.x1 <= rect.x1 && previousRect.x2 >= rect.x2
222:                             && previousRect.y1 <= rect.y1 && previousRect.y2 >= rect.y2) {
223:                         // Rect inside another
224:                     } else if (previousRect.palIndex == rect.palIndex
225:                             && previousRect.x1 >= rect.x1 && previousRect.x2 <= rect.x2
226:                             && previousRect.y1 >= rect.y1 && previousRect.y2 <= rect.y2) { // Rect inside another
227:                         previousRect = rect; // Replace by bigger rect
228:                     } else {
229:                         // Flush
230:                         rectsMerged.insert(previousRect);
231:                         previousRect = rect;
232:                     }
233:                 }
234: 
235:                 if (previousRect.isValid()) {
236:                     rectsMerged.insert(previousRect);
237:                 }
238: 
239:                 if (rects.size() == rectsMerged.size()) {
240:                     break;
241:                 }
242: 
243:                 rects = rectsMerged;
244:                 rectsMerged.clear();
245:             }
246: 
247:             for (const TimRect &rect: rectsMerged) {
248:                 rectangles.push_back(TimRect(rect.palIndex, texId * 128 + rect.x1, rect.y1, texId * 128 + rect.x2, rect.y2));
249:             }
250:         }
251: 
252:         // Use first palette by default
253:         rectangles.push_back(TimRect(*(pair.second.begin()), texId * 128, 0, texId * 128 + 128, 255));
254:     }
255: 
256:     tim.saveMultiPaletteTrianglesAndQuads(filename, rectangles, true);
257: 
258:     return true;
259: }
</file>

<file path="src/ff8/battle/stage.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include "../../image/tim.h"
27: 
28: #include <vector>
29: 
30: struct FF8StageTriangle {
31:     uint16_t faceA, faceB, faceC;
32:     uint8_t u1, v1;
33:     uint8_t u2, v2;
34:     uint16_t pal_id; // 6 bits = Always 15 | 4 bits = PaletteID | 6 bits = Always 0
35:     uint8_t u3, v3;
36:     uint8_t tex_id;
37:     uint8_t hide;
38:     uint8_t red, green, blue;
39:     uint8_t instruction;
40: };
41: 
42: struct FF8StageQuad {
43:     uint16_t faceA, faceB, faceC, faceD;
44:     uint8_t u1, v1;
45:     uint16_t pal_id; // 6 bits = Always 15 | 4 bits = PaletteID | 6 bits = Always 0
46:     uint8_t u2, v2;
47:     uint8_t tex_id;
48:     uint8_t hide;
49:     uint8_t u3, v3;
50:     uint8_t u4, v4;
51:     uint8_t red, green, blue;
52:     uint8_t instruction;
53: };
54: 
55: struct Stage {
56:     std::vector<FF8StageTriangle> triangles;
57:     std::vector<FF8StageQuad> quads;
58: };
59: 
60: bool ff8_battle_stage_parse_geometry(const uint8_t *stage_data, size_t stage_data_size, Stage &stage);
61: bool ff8_battle_state_save_texture(const Stage &stage, const Tim &tim, const char *filename);
</file>

<file path="src/ff8/field/background.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "background.h"
 25: #include "../../image/tim.h"
 26: #include "../../saveload.h"
 27: #include "../../log.h"
 28: 
 29: #include <unordered_map>
 30: 
 31: bool ff8_background_tiles_looks_alike(const Tile &tile, const Tile &other)
 32: {
 33: 	return tile.texID == other.texID
 34: 		&& tile.palID == other.palID
 35: 		&& tile.srcX == other.srcX
 36: 		&& tile.srcY == other.srcY
 37: 		&& tile.blendType == other.blendType;
 38: }
 39: 
 40: std::vector<Tile> ff8_background_parse_tiles(const uint8_t *map_data)
 41: {
 42: 	std::vector<Tile> tiles;
 43: 
 44: 	while (true) {
 45: 		Tile tile;
 46: 
 47: 		memcpy(&tile, map_data, sizeof(Tile));
 48: 
 49: 		if (tile.x == 0x7fff) {
 50: 			break;
 51: 		}
 52: 
 53: 		uint8_t texture_id = tile.texID & 0xF;
 54: 		Tim::Bpp bpp = Tim::Bpp((tile.texID >> 7) & 3);
 55: 		uint8_t pal_id = (tile.palID >> 6) & 0xF;
 56: 
 57: 		if (trace_all || trace_vram) ffnx_info("tile %d dst %d %d %d src %d %d texid %d bpp %d palId %d blendType %d param %d %d\n", tiles.size(), tile.x, tile.y, tile.z, tile.srcX, tile.srcY, texture_id, int(bpp), pal_id, tile.blendType, tile.parameter, tile.state);
 58: 
 59: 		tiles.push_back(tile);
 60: 
 61: 		map_data += sizeof(Tile);
 62: 	}
 63: 
 64: 	return tiles;
 65: }
 66: 
 67: void ff8_background_tiles_to_map(const std::vector<Tile> &tiles, uint8_t *map_data)
 68: {
 69: 	for (const Tile &tile: tiles) {
 70: 		memcpy(map_data, (const void *)&tile, sizeof(Tile));
 71: 
 72: 		map_data += sizeof(Tile);
 73: 	}
 74: 
 75: 	*(uint16_t *)map_data = 0x7fff;
 76: }
 77: 
 78: void ff8_background_draw_tile(const Tile &tile, uint32_t *target, const uint16_t target_width, const uint8_t* const textures_data, const uint16_t* const palettes_data)
 79: {
 80: 	Tim::Bpp bpp = Tim::Bpp((tile.texID >> 7) & 3);
 81: 	uint8_t texture_id = tile.texID & 0xF;
 82: 	uint8_t pal_id = (tile.palID >> 6) & 0xF;
 83: 	const uint8_t *texture_data_start = textures_data + texture_id * TEXTURE_WIDTH_BYTES + tile.srcY * MIM_DATA_WIDTH_BYTES;
 84: 	const uint16_t *palette_data_start = bpp == Tim::Bpp16 ? nullptr : palettes_data + pal_id * PALETTE_SIZE;
 85: 
 86: 	if (bpp == Tim::Bpp16) {
 87: 		const uint16_t *texture_data = reinterpret_cast<const uint16_t *>(texture_data_start) + tile.srcX;
 88: 
 89: 		for (int y = 0; y < TILE_SIZE; ++y) {
 90: 			for (int x = 0; x < TILE_SIZE; ++x) {
 91: 				*(target + x) = fromR5G5B5Color(*(texture_data + x), true);
 92: 			}
 93: 
 94: 			target += target_width;
 95: 			texture_data += MIM_DATA_WIDTH_BYTES / 2;
 96: 		}
 97: 	} else if (bpp == Tim::Bpp8) {
 98: 		const uint8_t *texture_data = texture_data_start + tile.srcX;
 99: 
100: 		for (int y = 0; y < TILE_SIZE; ++y) {
101: 			for (int x = 0; x < TILE_SIZE; ++x) {
102: 				*(target + x) = fromR5G5B5Color(palette_data_start[*(texture_data + x)], true);
103: 			}
104: 
105: 			target += target_width;
106: 			texture_data += MIM_DATA_WIDTH_BYTES;
107: 		}
108: 	} else {
109: 		const uint8_t *texture_data = texture_data_start + tile.srcX / 2;
110: 
111: 		for (int y = 0; y < TILE_SIZE; ++y) {
112: 			for (int x = 0; x < TILE_SIZE / 2; ++x) {
113: 				uint8_t index = *(texture_data + x);
114: 				*(target + x * 2) = fromR5G5B5Color(palette_data_start[index & 0xF], true);
115: 				*(target + x * 2 + 1) = fromR5G5B5Color(palette_data_start[index >> 4], true);
116: 			}
117: 
118: 			target += target_width;
119: 			texture_data += MIM_DATA_WIDTH_BYTES;
120: 		}
121: 	}
122: }
123: 
124: bool ff8_background_save_textures(const std::vector<Tile> &tiles, const uint8_t *mim_data, const char *filename)
125: {
126: 	if (trace_all || trace_vram) ffnx_trace("%s %s\n", __func__, filename);
127: 
128: 	const uint16_t* const palettes_data = reinterpret_cast<const uint16_t *>(mim_data + 0x1000);
129: 	const uint8_t* const textures_data = mim_data + 0x3000;
130: 
131: 	const uint8_t cols_count = tiles.size() / (TEXTURE_HEIGHT / TILE_SIZE) + int(tiles.size() % (TEXTURE_HEIGHT / TILE_SIZE) != 0);
132: 	const uint16_t width = cols_count * TILE_SIZE;
133: 	const uint32_t image_data_size = width * TEXTURE_HEIGHT * sizeof(uint32_t);
134: 
135: 	uint32_t* const image_data_start = new uint32_t[width * TEXTURE_HEIGHT];
136: 
137: 	if (image_data_start == nullptr) {
138: 		return false;
139: 	}
140: 
141: 	// Fill with zeroes (transparent image)
142: 	memset(image_data_start, 0, image_data_size);
143: 
144: 	uint32_t tile_id = 0;
145: 
146: 	for (const Tile &tile: tiles) {
147: 		uint8_t row = tile_id / cols_count, col = tile_id % cols_count;
148: 		uint32_t *target = image_data_start + row * TILE_SIZE * width + col * TILE_SIZE;
149: 
150: 		ff8_background_draw_tile(tile, target, width, textures_data, palettes_data);
151: 
152: 		++tile_id;
153: 	}
154: 
155: 	save_texture(image_data_start, image_data_size, width, TEXTURE_HEIGHT, uint32_t(-1), filename, false);
156: 
157: 	delete[] image_data_start;
158: 
159: 	return true;
160: }
161: 
162: bool ff8_background_save_textures_legacy(const std::vector<Tile> &tiles, const uint8_t *mim_data, const char *filename)
163: {
164: 	if (trace_all || trace_vram) ffnx_trace("%s %s\n", __func__, filename);
165: 
166: 	std::unordered_map<uint16_t, Tile> tiles_per_position_in_texture, pal_conflicts;
167: 	std::unordered_map<uint8_t, std::vector<uint8_t>> texture_ids;
168: 
169: 	const uint16_t *palettes_data = reinterpret_cast<const uint16_t *>(mim_data + 0x1000);
170: 	const uint8_t *textures_data = mim_data + 0x3000;
171: 
172: 	for (const Tile &tile: tiles) {
173: 		uint8_t texture_id = tile.texID & 0xF, pal_id = (tile.texID >> 6) & 0xF;
174: 		Tim::Bpp bpp = Tim::Bpp((tile.texID >> 7) & 3);
175: 
176: 		ffnx_info("dst %d %d %d src %d %d texid %d bpp %d palid %d blendType %d\n", tile.x, tile.y, tile.z, tile.srcX, tile.srcY, texture_id, int(bpp), pal_id, tile.blendType);
177: 		texture_ids.insert(std::pair<uint8_t, std::vector<uint8_t>>(texture_id, std::vector<uint8_t>()));
178: 		texture_ids[texture_id].push_back(0xFF);
179: 
180: 		uint16_t key = texture_id | ((tile.srcX / 16) << 4) | ((tile.srcY / 16) << 8);
181: 		if (tiles_per_position_in_texture.contains(key)) {
182: 			if (tiles_per_position_in_texture[key].palID == pal_id || pal_conflicts.contains(key | (pal_id << 12))) {
183: 				ffnx_warning("Tile conflict\n");
184: 			} else {
185: 				pal_conflicts[key | (pal_id << 12)] = tile;
186: 				texture_ids[texture_id].push_back(pal_id);
187: 			}
188: 		} else {
189: 			tiles_per_position_in_texture[key] = tile;
190: 		}
191: 	}
192: 
193: 	uint32_t* const image_data_start = new uint32_t[TEXTURE_WIDTH_BPP4 * TEXTURE_HEIGHT];
194: 
195: 	if (image_data_start == nullptr) {
196: 		return false;
197: 	}
198: 
199: 	const uint32_t image_data_size = TEXTURE_WIDTH_BPP4 * TEXTURE_HEIGHT * sizeof(uint32_t);
200: 
201: 	// Save textures
202: 	for (const std::pair<uint8_t, std::vector<uint8_t>> pair: texture_ids) {
203: 		const uint8_t texture_id = pair.first;
204: 
205: 		for (const uint8_t pal_id: pair.second) {
206: 			const std::unordered_map<uint16_t, Tile> &tiles = pal_id == 0xFF ? tiles_per_position_in_texture : pal_conflicts;
207: 			const uint16_t key = texture_id | (pal_id == 0xFF ? 0 : (pal_id << 12));
208: 
209: 			// Fill with zeroes (transparent image)
210: 			memset(image_data_start, 0, image_data_size);
211: 
212: 			for (uint8_t row = 0; row < 16; ++row) {
213: 				for (uint8_t col = 0; col < 16; ++col) {
214: 					uint32_t *target = image_data_start + row * TILE_SIZE * TEXTURE_WIDTH_BPP4 + col * TILE_SIZE;
215: 					auto it = tiles.find(key | (col << 4) | (row << 8));
216: 					if (it == tiles.end()) {
217: 						if (pal_id == 0xFF) {
218: 							ffnx_info("texture_id=%d row=%d col=%d pal_id=%d not found\n", texture_id, row, col, pal_id);
219: 							continue;
220: 						}
221: 
222: 						it = tiles_per_position_in_texture.find(texture_id | (col << 4) | (row << 8));
223: 						if (it == tiles_per_position_in_texture.end()) {
224: 							ffnx_info("texture_id=%d row=%d col=%d pal_id=%d not found\n", texture_id, row, col, pal_id);
225: 							continue;
226: 						}
227: 					}
228: 
229: 					ff8_background_draw_tile(it->second, target, TEXTURE_WIDTH_BPP4, textures_data, palettes_data);
230: 
231: 					ffnx_info("texture_id=%d row=%d col=%d pal_id=%d\n", texture_id, row, col, pal_id);
232: 				}
233: 			}
234: 
235: 			char filename_tex[MAX_PATH] = {};
236: 
237: 			if (pal_id == 0xFF) {
238: 				snprintf(filename_tex, sizeof(filename_tex), "%s_%d", filename, texture_id);
239: 			} else {
240: 				snprintf(filename_tex, sizeof(filename_tex), "%s_%d_0_%d", filename, texture_id, pal_id + 240);
241: 			}
242: 			save_texture(image_data_start, image_data_size, TEXTURE_WIDTH_BPP4, TEXTURE_HEIGHT, -1, filename_tex, false);
243: 		}
244: 	}
245: 
246: 	delete[] image_data_start;
247: 
248: 	return true;
249: }
</file>

<file path="src/ff8/field/background.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include <vector>
27: 
28: constexpr int TEXTURE_WIDTH_BYTES = 128; // Real texture width depends on the texture depth (bpp4 => 256, bpp8 => 128, bpp16 => 64)
29: constexpr int TEXTURE_WIDTH_BPP16 = 64;
30: constexpr int TEXTURE_WIDTH_BPP8 = 128;
31: constexpr int TEXTURE_WIDTH_BPP4 = 256;
32: constexpr int TEXTURE_HEIGHT = 256;
33: constexpr int VRAM_PAGE_MIM_MAX_COUNT = 13;
34: constexpr int MIM_DATA_WIDTH_BYTES = TEXTURE_WIDTH_BYTES * VRAM_PAGE_MIM_MAX_COUNT;
35: constexpr int MIM_DATA_HEIGHT = TEXTURE_HEIGHT;
36: constexpr int TILE_SIZE = 16;
37: constexpr int PALETTE_SIZE = 256;
38: 
39: struct Tile {
40: 	int16_t x, y, z;
41: 	uint16_t texID; // 2 bits = depth | 2 bits = blend | 1 bit = draw | 4 bits = textureID
42: 	uint16_t palID; // 6 bits = Always 30 | 4 bits = PaletteID | 6 bits = Always 0
43: 	uint8_t srcX, srcY;
44: 	uint8_t layerID; // 0-7
45: 	uint8_t blendType; // 0-4
46: 	uint8_t parameter, state;
47: };
48: 
49: // A tile looks like another if it uses the same texture with the same palette and uses the same blending
50: bool ff8_background_tiles_looks_alike(const Tile &tile, const Tile &other);
51: 
52: std::vector<Tile> ff8_background_parse_tiles(const uint8_t *map_data);
53: void ff8_background_tiles_to_map(const std::vector<Tile> &tiles, uint8_t *map_data);
54: bool ff8_background_save_textures(const std::vector<Tile> &tiles, const uint8_t *mim_data, const char *filename);
55: bool ff8_background_save_textures_legacy(const std::vector<Tile> &tiles, const uint8_t *mim_data, const char *filename);
</file>

<file path="src/ff8/field/chara_one.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "chara_one.h"
 25: #include "../../image/tim.h"
 26: #include "../../log.h"
 27: 
 28: std::unordered_map<uint32_t, CharaOneModel> ff8_chara_one_parse_models(const uint8_t *chara_one_data, size_t size)
 29: {
 30: 	std::unordered_map<uint32_t, CharaOneModel> models;
 31: 
 32: 	const uint8_t *cur = chara_one_data;
 33: 
 34: 	uint32_t count;
 35: 	memcpy(&count, cur, 4);
 36: 	cur += 4;
 37: 
 38: 	for (uint32_t i = 0; i < count && cur - chara_one_data < size - 16; ++i) {
 39: 		uint32_t offset;
 40: 		memcpy(&offset, cur, 4);
 41: 		cur += 4;
 42: 
 43: 		if (offset == 0) {
 44: 			break;
 45: 		}
 46: 
 47: 		uint32_t section_size;
 48: 		memcpy(&section_size, cur, 4);
 49: 		cur += 4;
 50: 
 51: 		uint32_t flag;
 52: 		memcpy(&flag, cur, 4);
 53: 		cur += 4;
 54: 
 55: 		if (flag == section_size) {
 56: 			memcpy(&flag, cur, 4);
 57: 			cur += 4;
 58: 		}
 59: 
 60: 		CharaOneModel model = CharaOneModel();
 61: 
 62: 		if (flag >> 24 != 0xd0) { // NPCs (not main characters)
 63: 			uint32_t tim_offset;
 64: 
 65: 			if (trace_all) ffnx_info("%s: %d %d %d\n", __func__, i, int(cur - chara_one_data), size);
 66: 
 67: 			if ((flag & 0xFFFFFF) == 0) {
 68: 				model.texturesData.push_back(0);
 69: 			}
 70: 
 71: 			while (cur - chara_one_data < size) {
 72: 				memcpy(&tim_offset, cur, 4);
 73: 				cur += 4;
 74: 
 75: 				if (tim_offset == 0xFFFFFFFF) {
 76: 					break;
 77: 				}
 78: 
 79: 				model.texturesData.push_back(tim_offset & 0xFFFFFF);
 80: 			}
 81: 		} else {
 82: 			model.isMch = true;
 83: 		}
 84: 
 85: 		if (cur - chara_one_data < 16) {
 86: 			break;
 87: 		}
 88: 
 89: 		cur += 4;
 90: 		char name[5] = "";
 91: 		for (uint8_t j = 0; j < 4; ++j) {
 92: 			if (cur[j] > 'z' || cur[j] < '0') {
 93: 				name[j] = '\0';
 94: 				break;
 95: 			}
 96: 
 97: 			name[j] = cur[j];
 98: 		}
 99: 		strncpy(model.name, name, 4);
100: 
101: 		models[offset + 4] = model;
102: 
103: 		cur += 12;
104: 	}
105: 
106: 	return models;
107: }
108: 
109: void ff8_mch_parse_model(CharaOneModel &model, const uint8_t *mch_data, size_t size)
110: {
111: 	if(size < 0x100) {
112: 		ffnx_warning("%s: empty MCH\n", __func__);
113: 		return;
114: 	}
115: 
116: 	const uint8_t *cur = mch_data;
117: 	uint32_t tim_offset = 0;
118: 
119: 	while (cur - mch_data < 0x100 - 4) {
120: 		memcpy(&tim_offset, cur, 4);
121: 		cur += 4;
122: 
123: 		if(tim_offset == 0xFFFFFFFF) {
124: 			break;
125: 		}
126: 
127: 		model.texturesData.push_back(tim_offset & 0xFFFFFF);
128: 	}
129: }
130: 
131: bool ff8_chara_one_model_save_textures(const CharaOneModel &model, const uint8_t *chara_one_model_data, const char *dirname)
132: {
133: 	if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, dirname);
134: 
135: 	int texture_id = 0;
136: 	for (uint32_t texture_pointer: model.texturesData) {
137: 		char name[MAX_PATH] = {};
138: 		snprintf(name, sizeof(name), "%s/%s-%d", dirname, model.name, texture_id);
139: 		Tim tim = Tim::fromTimData(chara_one_model_data + texture_pointer);
140: 
141: 		if (!tim.save(name, 0, 0, true)) {
142: 			return false;
143: 		}
144: 		++texture_id;
145: 	}
146: 
147: 	return true;
148: }
</file>

<file path="src/ff8/field/chara_one.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include <vector>
27: #include <unordered_map>
28: 
29: struct CharaOneModel {
30: 	char name[6];
31: 	bool isMch;
32: 	std::vector<uint32_t> texturesData;
33: };
34: 
35: std::unordered_map<uint32_t, CharaOneModel> ff8_chara_one_parse_models(const uint8_t *chara_one_data, size_t size);
36: void ff8_mch_parse_model(CharaOneModel &model, const uint8_t *mch_data, size_t size);
37: bool ff8_chara_one_model_save_textures(const CharaOneModel &models, const uint8_t *chara_one_model_data, const char *dirname);
</file>

<file path="src/ff8/world/chara_one.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #include "chara_one.h"
25: #include "../../image/tim.h"
26: #include "../../log.h"
27: 
28: std::vector<CharaOneModelTextures> ff8_world_chara_one_parse_models(const uint8_t *chara_one_data, size_t size)
29: {
30: 	std::vector<CharaOneModelTextures> models;
31: 
32: 	const uint8_t *cur = chara_one_data + size, *min_cur = chara_one_data + 4;
33: 
34: 	// The header is at the end of the file
35: 	uint32_t count;
36: 	cur -= 4;
37: 	memcpy(&count, cur, 4);
38: 
39: 	for (uint32_t i = 0; i < count && cur >= min_cur; ++i) {
40: 		CharaOneModelTextures textures;
41: 
42: 		uint32_t tim_offset;
43: 
44: 		while (cur >= min_cur) {
45: 			cur -= 4;
46: 			memcpy(&tim_offset, cur, 4);
47: 
48: 			if (tim_offset == 0xFFFFFFFF) {
49: 				break;
50: 			}
51: 
52: 			textures.push_back(tim_offset & 0xFFFFFFF);
53: 		}
54: 
55: 		models.push_back(textures);
56: 
57: 		cur -= 4; // Skipping offset to the model data
58: 	}
59: 
60: 	return models;
61: }
62: 
63: bool ff8_world_chara_one_model_save_textures(const std::vector<CharaOneModelTextures> &models, const uint8_t *chara_one_model_data, const char *dirname)
64: {
65: 	if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, dirname);
66: 
67: 	int model_id = 0;
68: 	for (const CharaOneModelTextures &textures: models) {
69: 		int texture_id = 0;
70: 		for (uint32_t texture_pointer: textures) {
71: 			char name[MAX_PATH] = {};
72: 			snprintf(name, sizeof(name), "%s/model%d-%d", dirname, model_id, texture_id);
73: 			Tim tim = Tim::fromTimData(chara_one_model_data + texture_pointer);
74: 
75: 			if (!tim.save(name, 0, 0, true)) {
76: 				return false;
77: 			}
78: 			++texture_id;
79: 		}
80: 		++model_id;
81: 	}
82: 
83: 	return true;
84: }
</file>

<file path="src/ff8/world/chara_one.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include <vector>
27: 
28: typedef std::vector<uint32_t> CharaOneModelTextures;
29: 
30: std::vector<CharaOneModelTextures> ff8_world_chara_one_parse_models(const uint8_t *chara_one_data, size_t size);
31: bool ff8_world_chara_one_model_save_textures(const std::vector<CharaOneModelTextures> &models, const uint8_t *chara_one_model_data, const char *dirname);
</file>

<file path="src/ff8/world/wmset.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "wmset.h"
 25: #include "../../image/tim.h"
 26: #include "../../log.h"
 27: 
 28: std::vector<WmsetSection17Texture> ff8_world_wmset_wave_animations_parse(const uint8_t *wmset_section17_data, size_t size)
 29: {
 30: 	std::vector<WmsetSection17Texture> textures;
 31: 
 32: 	const uint32_t *header = (const uint32_t *)wmset_section17_data;
 33: 	size_t max = size / 4, i = 0;
 34: 
 35: 	for (int i = 0; i < max; ++i) {
 36: 		uint32_t pos = header[i];
 37: 
 38: 		if (pos == 0 || pos + 12 >= size) {
 39: 			break;
 40: 		}
 41: 
 42: 		max = std::min(max, pos / 4);
 43: 
 44: 		WmsetSection17Texture texture = WmsetSection17Texture();
 45: 		const uint16_t *vram_positions = (const uint16_t *)(wmset_section17_data + pos + 4);
 46: 
 47: 		texture.x = vram_positions[0];
 48: 		texture.y = vram_positions[1];
 49: 
 50: 		const uint32_t *secondary_header = (const uint32_t *)(wmset_section17_data + pos + 8);
 51: 		size_t max2 = (size - pos - 8) / 4;
 52: 		uint32_t previous_frame_pos = 0;
 53: 
 54: 		for (int j = 0; j < max2; ++j) {
 55: 			uint32_t frame_pos = secondary_header[j];
 56: 
 57: 			if (frame_pos == previous_frame_pos || pos + 8 + frame_pos >= size - 8 || pos + 8 + frame_pos == header[i + 1]) {
 58: 				break;
 59: 			}
 60: 
 61: 			max2 = std::min(max2, frame_pos / 4);
 62: 			previous_frame_pos = frame_pos;
 63: 
 64: 			texture.textureFramePositions.push_back(wmset_section17_data + pos + 8 + frame_pos);
 65: 		}
 66: 
 67: 		textures.push_back(texture);
 68: 	}
 69: 
 70: 	return textures;
 71: }
 72: 
 73: bool ff8_world_wmset_wave_animations_save_texture(const std::vector<WmsetSection17Texture> &textures, int texture_id, const char *dirname, const Tim &baseTexture)
 74: {
 75: 	if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, dirname);
 76: 
 77: 	if (texture_id >= textures.size()) {
 78: 		return false;
 79: 	}
 80: 
 81: 	int frame_id = 0;
 82: 	std::vector<const uint8_t *> positions = textures.at(texture_id).textureFramePositions;
 83: 	for (const uint8_t *texture_pointer: positions) {
 84: 		char name[MAX_PATH] = {};
 85: 		snprintf(name, sizeof(name), "%s/texture%d", dirname, texture_id);
 86: 		Tim tim = Tim::fromTimData(texture_pointer); // Indexed Tim without palette
 87: 
 88: 		ff8_tim mergedTim = ff8_tim();
 89: 		mergedTim.img_x = tim.imageX();
 90: 		mergedTim.img_y = tim.imageY();
 91: 		mergedTim.img_w = tim.imageWidth();
 92: 		mergedTim.img_h = tim.imageHeight();
 93: 		mergedTim.img_data = tim.imageData();
 94: 		// Use palette from baseTexture
 95: 		mergedTim.pal_x = baseTexture.paletteX();
 96: 		mergedTim.pal_y = baseTexture.paletteY();
 97: 		mergedTim.pal_w = baseTexture.paletteWidth();
 98: 		mergedTim.pal_h = baseTexture.paletteHeight();
 99: 		mergedTim.pal_data = baseTexture.paletteData();
100: 
101: 		if (!Tim(tim.bpp(), mergedTim).save(name, frame_id, true)) {
102: 			return false;
103: 		}
104: 		++frame_id;
105: 	}
106: 
107: 	return true;
108: }
109: 
110: std::unordered_map<uint32_t, WmsetSection41Texture> ff8_world_wmset_palette_animations_parse(const uint8_t *wmset_section41_data, size_t size)
111: {
112: 	std::unordered_map<uint32_t, WmsetSection41Texture> textures;
113: 
114: 	const uint32_t *header = (const uint32_t *)wmset_section41_data;
115: 	size_t max = size / 4, i = 0;
116: 
117: 	for (int i = 0; i < max; ++i) {
118: 		uint32_t pos = header[i];
119: 
120: 		if (pos == 0 || pos + 12 >= size) {
121: 			break;
122: 		}
123: 
124: 		max = std::min(max, pos / 4);
125: 
126: 		WmsetSection41Texture texture = WmsetSection41Texture();
127: 		const uint16_t *vram_positions = (const uint16_t *)(wmset_section41_data + pos + 4);
128: 
129: 		texture.height = wmset_section41_data[pos + 2];
130: 		texture.srcX = vram_positions[0];
131: 		texture.srcY = vram_positions[1];
132: 		texture.x = vram_positions[2];
133: 		texture.y = vram_positions[3];
134: 
135: 		const uint32_t *toc = (const uint32_t *)(wmset_section41_data + pos + 12);
136: 
137: 		for (int j = 0; j < texture.height; ++j) {
138: 			texture.palettePositions.push_back((const uint16_t *)(wmset_section41_data + pos + 12 + toc[j] + 20));
139: 		}
140: 
141: 		textures[uint32_t(texture.srcX) | (uint32_t(texture.srcY) << 16)] = texture;
142: 	}
143: 
144: 	return textures;
145: }
146: 
147: bool ff8_world_wmset_palette_animations_save_texture(const WmsetSection41Texture &texture, const char *dirname, const Tim &baseTexture)
148: {
149: 	if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, dirname);
150: 
151: 	std::vector<const uint16_t *> positions = texture.palettePositions;
152: 	int palette_id = 0;
153: 	for (const uint16_t *texture_pointer: positions) {
154: 		ff8_tim mergedTim = ff8_tim();
155: 		mergedTim.img_x = baseTexture.imageX();
156: 		mergedTim.img_y = baseTexture.imageY();
157: 		mergedTim.img_w = baseTexture.imageWidth();
158: 		mergedTim.img_h = baseTexture.imageHeight();
159: 		mergedTim.img_data = baseTexture.imageData();
160: 		// Use palette from baseTexture
161: 		mergedTim.pal_x = texture.x;
162: 		mergedTim.pal_y = texture.y;
163: 		mergedTim.pal_w = 256;
164: 		mergedTim.pal_h = 1;
165: 		mergedTim.pal_data = (uint16_t *)texture_pointer;
166: 
167: 		if (!Tim(baseTexture.bpp(), mergedTim).save(dirname, palette_id, true)) {
168: 			return false;
169: 		}
170: 		++palette_id;
171: 	}
172: 
173: 	return true;
174: }
</file>

<file path="src/ff8/world/wmset.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include "../../image/tim.h"
27: 
28: #include <vector>
29: #include <unordered_map>
30: 
31: struct WmsetSection17Texture {
32:     uint16_t x, y;
33:     std::vector<const uint8_t *> textureFramePositions;
34: };
35: 
36: struct WmsetSection41Texture {
37:     uint16_t srcX, srcY, x, y;
38:     uint8_t height;
39:     std::vector<const uint16_t *> palettePositions;
40: };
41: 
42: std::vector<WmsetSection17Texture> ff8_world_wmset_wave_animations_parse(const uint8_t *wmset_section17_data, size_t size);
43: bool ff8_world_wmset_wave_animations_save_texture(const std::vector<WmsetSection17Texture> &textures, int texture_id, const char *dirname, const Tim &baseTexture);
44: 
45: std::unordered_map<uint32_t, WmsetSection41Texture> ff8_world_wmset_palette_animations_parse(const uint8_t *wmset_section41_data, size_t size);
46: bool ff8_world_wmset_palette_animations_save_texture(const WmsetSection41Texture &texture, const char *dirname, const Tim &baseTexture);
</file>

<file path="src/ff8/ambient.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #include "ambient.h"
23: #include "audio.h"
24: #include "common.h"
25: #include "globals.h"
26: 
27: void ff8_handle_ambient_playback()
28: {
29: 	struct game_mode *mode = getmode_cached();
30: 	static char filename[64]{0};
31: 	static WORD last_field_id = 0, last_triangle_id = 0, last_battle_id = 0;
32: 	bool playing = false;
33: 
34: 	switch (mode->driver_mode)
35: 	{
36: 	case MODE_BATTLE:
37: 		if (last_battle_id != next_battle_scene_id)
38: 		{
39: 			last_battle_id = next_battle_scene_id;
40: 
41: 			sprintf(filename, "bat_%d", last_battle_id);
42: 			nxAudioEngine.playAmbient(filename);
43: 		}
44: 		if ((*ff8_externals.is_game_paused != 0) && nxAudioEngine.isAmbientPlaying())
45: 			nxAudioEngine.pauseAmbient();
46: 		else if (!(*ff8_externals.is_game_paused != 0) && !(nxAudioEngine.isAmbientPlaying()))
47: 			nxAudioEngine.resumeAmbient();
48: 		break;
49: 	case MODE_FIELD:
50: 		if (last_field_id != *common_externals.current_field_id)
51: 		{
52: 			last_field_id = *common_externals.current_field_id;
53: 
54: 			if (common_externals.current_triangle_id != 0)
55: 			{
56: 				last_triangle_id = *common_externals.current_triangle_id;
57: 				sprintf(filename, "field_%d_%d", last_field_id, *common_externals.current_triangle_id);
58: 				playing = nxAudioEngine.playAmbient(filename);
59: 			}
60: 
61: 			if (!playing)
62: 			{
63: 				sprintf(filename, "field_%d", last_field_id);
64: 				playing = nxAudioEngine.playAmbient(filename);
65: 			}
66: 		}
67: 		else if (common_externals.current_triangle_id != 0 && last_field_id == *common_externals.current_field_id && last_triangle_id != *common_externals.current_triangle_id)
68: 		{
69: 			last_triangle_id = *common_externals.current_triangle_id;
70: 
71: 			sprintf(filename, "field_%d_%d", last_field_id, *common_externals.current_triangle_id);
72: 			playing = nxAudioEngine.playAmbient(filename);
73: 		}
74: 		break;
75: 	case MODE_AFTER_BATTLE:
76: 		next_battle_scene_id = 0;
77: 	default:
78: 		if (last_field_id != 0 || last_battle_id != 0)
79: 		{
80: 			nxAudioEngine.stopAmbient();
81: 			last_field_id = 0;
82: 			last_battle_id = 0;
83: 		}
84: 		break;
85: 	}
86: }
</file>

<file path="src/ff8/ambient.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: void ff8_handle_ambient_playback();
</file>

<file path="src/ff8/engine.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <vector>
 24: #include <string>
 25: 
 26: #include "../globals.h"
 27: 
 28: #include "engine.h"
 29: 
 30: static const std::vector<std::string> ff8_table = {
 31:   " ","0","1","2","3","4","5","6","7","8","9","%","/",":","!","?",
 32:   "‚Ä¶","+","-","=","*","&","„Äå","„Äç","(",")","¬∑",".",",","~","‚Äù","‚Äú",
 33:   "‚Äò","#","$","'","_","A","B","C","D","E","F","G","H","I","J","K",
 34:   "L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a",
 35:   "b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q",
 36:   "r","s","t","u","v","w","x","y","z","√Ä","√Å","√Ç","√Ñ","√á","√à","√â",
 37:   "√ä","√ã","√å","√ç","√é","√è","√ë","√í","√ì","√î","√ñ","√ô","√ö","√õ","√ú","≈í",
 38:   "√ü","√†","√°","√¢","√§","√ß","√®","√©","√™","√´","√¨","√≠","√Æ","√Ø","√±","√≤",
 39:   "√≥","√¥","√∂","√π","√∫","√ª","√º","≈ì","","[","]","‚ñ†","‚óã","‚ô¶","„Äê","„Äë",
 40:   "‚ñ°","","„Äé","„Äè","",";","","¬Ø","√ó","","","‚Üì","¬∞","¬°","¬ø","‚îÄ","¬´",
 41:   "¬ª","¬±","‚ô´","","‚Üë","","","","‚Ñ¢","<",">","","","","","","","","",
 42:   "","","","","","","","","","","","","","","¬Æ","","","","","",
 43:   "{in}","{e }","{ne}","{to}","{re}","{HP}","{l }","{ll}","{GF}",
 44:   "{nt}","{il}","{o }","{ef}","{on}","{ w}","{ r}","{wi}","{fi}",
 45:   "{EC}","{s }","{ar}","{FE}","{ S}","{ag}"
 46: };
 47: 
 48: int ff8_manage_time_engine(int enable_rdtsc)
 49: {
 50:   // Force rdtsc
 51:   return ff8_externals.enable_rdtsc_sub_40AA00(1);
 52: }
 53: 
 54: std::string ff8_decode_text(const char* encoded_text)
 55: {
 56:   std::string ret{};
 57:   int index = 0;
 58:   char current_char = NULL, last_char = NULL;
 59: 
 60:   if (encoded_text != NULL)
 61:   {
 62:     while (current_char = encoded_text[index++], current_char != char(NULL))
 63:     {
 64:       // Control char, save it and continue
 65:       if (current_char < 0x20)
 66:       {
 67:         last_char = current_char;
 68:         continue;
 69:       }
 70: 
 71:       // If it was a control char, evaluate
 72:       if (last_char != char(NULL) && last_char < 0x20)
 73:       {
 74:         switch (last_char){
 75:           case 0x2:
 76:             ret.append(" ");
 77:             ret.append(ff8_table[current_char - 0x20]);
 78:             break;
 79:           case 0x3:
 80:             if(current_char>=0x30 && current_char<=0x3a)
 81:               ret.append(ff8_names[current_char-0x30]);
 82:             else if(current_char==0x40)
 83:               ret.append(ff8_names[11]);
 84:             else if(current_char==0x50)
 85:               ret.append(ff8_names[12]);
 86:             else if(current_char==0x60)
 87:               ret.append(ff8_names[13]);
 88:             break;
 89:         }
 90: 
 91:         last_char = NULL;
 92: 
 93:         continue;
 94:       }
 95: 
 96:       // Normal string char, append
 97:       ret.append(ff8_table[current_char - 0x20]);
 98:     }
 99:   }
100: 
101:   return ret;
102: }
</file>

<file path="src/ff8/engine.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include <string>
26: 
27: static const std::vector<std::string> ff8_names = {
28: 	"Squall",
29:   "Zell",
30:   "Irvine",
31:   "Quistis",
32:   "Rinoa",
33:   "Selphie",
34:   "Seifer",
35:   "Edea",
36:   "Laguna",
37:   "Kiros",
38:   "Ward",
39:   "Angelo",
40:   "Griever",
41:   "Boko"
42: };
43: 
44: int ff8_manage_time_engine(int enable_rdtsc);
45: std::string ff8_decode_text(const char* encoded_text);
</file>

<file path="src/ff8/file.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include "file.h"
 24: #include "utils.h"
 25: #include "../ff8.h"
 26: #include "../log.h"
 27: #include "../redirect.h"
 28: 
 29: #include <fcntl.h>
 30: #include <io.h>
 31: #include <lz4.h>
 32: 
 33: char next_direct_file[MAX_PATH] = "";
 34: bool last_fopen_is_redirected = false;
 35: uint32_t last_compression_type = 0;
 36: size_t last_compressed_size = 0;
 37: size_t last_uncompressed_size = 0;
 38: 
 39: size_t get_fl_prefix_size()
 40: {
 41: 	return 2 + strlen(ff8_externals.archive_path_prefix);
 42: }
 43: 
 44: void ff8_fs_lang_string(char *data)
 45: {
 46: 	strncpy(data, ff8_externals.archive_path_prefix + 10, strlen(ff8_externals.archive_path_prefix) - 10 - 1);
 47: }
 48: 
 49: bool set_direct_path(const char *fullpath, char *output, size_t output_size)
 50: {
 51: 	if (strnicmp(fullpath + 2, ff8_externals.archive_path_prefix, strlen(ff8_externals.archive_path_prefix)) != 0)
 52: 	{
 53: 		if (trace_all || trace_direct) ffnx_warning("%s: file ignored for direct path %s (should match %s)\n", __func__, fullpath, ff8_externals.archive_path_prefix);
 54: 
 55: 		return false;
 56: 	}
 57: 
 58: 	_snprintf(output, output_size, "%s/%s/%s", basedir, direct_mode_path.c_str(), fullpath + get_fl_prefix_size());
 59: 
 60: 	return true;
 61: }
 62: 
 63: bool check_direct_sub_archive_exists(const char *ext, const char *path_without_ext)
 64: {
 65: 	char archive_path[MAX_PATH] = {}, direct_path[MAX_PATH] = {};
 66: 
 67: 	sprintf(archive_path, "%s.%s", path_without_ext, ext);
 68: 
 69: 	set_direct_path(archive_path, direct_path, sizeof(direct_path));
 70: 
 71: 	return fileExists(direct_path);
 72: }
 73: 
 74: void ff8_fs_archive_sub_archive_get_filename(const char *filename, char *dirname)
 75: {
 76: 	ff8_externals.sub_archive_get_filename(filename, dirname);
 77: 
 78: 	char cleaned_dirname[MAX_PATH] = "c:";
 79: 	size_t path_strlen = strlen(dirname);
 80: 
 81: 	strncpy(cleaned_dirname + 2, dirname, path_strlen);
 82: 
 83: 	if (cleaned_dirname[2 + path_strlen - 1] == '\n') {
 84: 		cleaned_dirname[2 + path_strlen - 1] = '\0';
 85: 		path_strlen -= 1;
 86: 	}
 87: 
 88: 	if (cleaned_dirname[2 + path_strlen - 1] == '\\' || cleaned_dirname[2 + path_strlen - 1] == '/') {
 89: 		cleaned_dirname[2 + path_strlen - 1] = '\0';
 90: 	}
 91: 
 92: 	if (check_direct_sub_archive_exists("fi", cleaned_dirname) && check_direct_sub_archive_exists("fl", cleaned_dirname) && check_direct_sub_archive_exists("fs", cleaned_dirname)) {
 93: 		set_direct_path(cleaned_dirname, next_direct_file, sizeof(next_direct_file));
 94: 		// Bypass subarchive opening
 95: 		strncpy(ff8_externals.temp_fs_path_cache, cleaned_dirname + 2, path_strlen);
 96: 	} else {
 97: 		if (trace_all || trace_direct) ffnx_warning("Direct files not found %s.fs, .fl and .fi\n", cleaned_dirname);
 98: 
 99: 		next_direct_file[0] = '\0';
100: 	}
101: 
102: 	if (trace_all || trace_files) ffnx_trace("%s: filename=%s cleaned_dirname=%s next_direct_file=%s\n", __func__, filename, cleaned_dirname, next_direct_file);
103: }
104: 
105: ff8_file_container *ff8_fs_archive_open_temp(char *fl_path, char *fs_path, char *fi_path)
106: {
107: 	if (next_direct_file[0] != '\0') {
108: 		if (trace_all || trace_direct) ffnx_info("Direct file using %s.fs, .fl and .fi\n", next_direct_file);
109: 
110: 		sprintf(fl_path, "%s.fl", next_direct_file);
111: 		sprintf(fs_path, "%s.fs", next_direct_file);
112: 		sprintf(fi_path, "%s.fi", next_direct_file);
113: 
114: 		*next_direct_file = '\0';
115: 	}
116: 
117: 	if (trace_all || trace_files) ffnx_trace("%s: fl_path=%s fs_path=%s fi_path=%s\n", __func__, fl_path, fs_path, fi_path);
118: 
119: 	return ff8_externals.archive_open(fl_path, fs_path, fi_path);
120: }
121: 
122: int ff8_fs_archive_search_filename2(const char *fullpath, ff8_file_fi_infos *fi_infos_for_the_path, const ff8_file_container *file_container)
123: {
124: 	if (trace_all || trace_files) ffnx_trace("%s: Looking in archive for %s\n", __func__, fullpath);
125: 
126: 	int ret = ff8_externals.ff8_fs_archive_search_filename2(fullpath, fi_infos_for_the_path, file_container);
127: 
128: 	if (ret != 1 && file_container != nullptr)
129: 	{
130: 		// Lookup without the language in the path
131: 		size_t prefix_size = get_fl_prefix_size();
132: 
133: 		if (trace_all || trace_files) ffnx_warning("%s: file not found, searching again with another language %s...\n", __func__, fullpath + prefix_size);
134: 
135: 		for (int id = 0; id < file_container->fl_infos->file_count; ++id)
136: 		{
137: 			char *path = ff8_externals.fs_archive_get_fl_filepath(id, file_container->fl_infos);
138: 
139: 			if (!_stricmp(fullpath + prefix_size, path + prefix_size))
140: 			{
141: 				*fi_infos_for_the_path = file_container->fi_infos[id];
142: 
143: 				if (trace_all || trace_files) ffnx_trace("%s: found archive file in another language\n", __func__);
144: 
145: 				return 1;
146: 			}
147: 		}
148: 	}
149: 
150: 	return ret;
151: }
152: 
153: int ff8_fs_archive_search_filename_sub_archive(const char *fullpath, ff8_file_fi_infos *fi_infos_for_the_path, const ff8_file_container *file_container)
154: {
155: 	if (trace_all || trace_files) ffnx_trace("%s %s\n", __func__, fullpath);
156: 
157: 	char direct_path[MAX_PATH];
158: 
159: 	set_direct_path(fullpath, direct_path, sizeof(direct_path));
160: 
161: 	if (fileExists(direct_path))
162: 	{
163: 		strncpy(next_direct_file, direct_path, sizeof(next_direct_file));
164: 
165: 		return 0; // Bypass Moriya filesystem
166: 	}
167: 	else
168: 	{
169: 		if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", direct_path);
170: 	}
171: 
172: 	return ff8_fs_archive_search_filename2(fullpath, fi_infos_for_the_path, file_container);
173: }
174: 
175: void ff8_fs_archive_free_file_container_sub_archive(ff8_file_container *file_container)
176: {
177: 	if (trace_all || trace_files) ffnx_trace("%s\n", __func__);
178: 
179: 	*next_direct_file = '\0';
180: 
181: 	return ff8_externals.free_file_container(file_container);
182: }
183: 
184: void ff8_fs_archive_patch_compression(uint32_t compression_type)
185: {
186: 	if (trace_all || trace_files) ffnx_trace("%s compression_type=%d\n", __func__, compression_type);
187: 
188: 	last_compression_type = compression_type;
189: }
190: 
191: uint8_t *ff8_fs_archive_malloc_source_data(size_t size, char *source_code_path, int line)
192: {
193: 	if (trace_all || trace_files) ffnx_trace("%s size=%d\n", __func__, size);
194: 
195: 	last_compressed_size = size - 12;
196: 
197: 	return (uint8_t *)common_externals.assert_malloc(size, source_code_path, line);
198: }
199: 
200: uint8_t *ff8_fs_archive_malloc_target_data(size_t size, char *source_code_path, int line)
201: {
202: 	if (trace_all || trace_files) ffnx_trace("%s size=%d\n", __func__, size);
203: 
204: 	if (last_compression_type == 2) // LZ4 compression
205: 	{
206: 		last_uncompressed_size = size;
207: 
208: 		size += 10;
209: 	}
210: 
211: 	return (uint8_t *)common_externals.assert_malloc(size, source_code_path, line);
212: }
213: 
214: void ff8_fs_archive_uncompress_data(const uint8_t *source_data, uint8_t *target_data)
215: {
216: 	if (trace_all || trace_files) ffnx_trace("%s\n", __func__);
217: 
218: 	if (last_compression_type == 2) // LZ4 compression
219: 	{
220: 		if (trace_all || trace_files) ffnx_trace("%s LZ4 compression detected\n", __func__);
221: 
222: 		int uncompressed_size = LZ4_decompress_safe_partial((const char *)source_data + 12, (char *)target_data, last_compressed_size, last_uncompressed_size, last_uncompressed_size + 10);
223: 
224: 		if (uncompressed_size < 0)
225: 		{
226: 			ffnx_error("%s: cannot uncompress lz4 file data (compressed_size=%d, uncompressed_size=%d, error=%d)\n", __func__, last_compressed_size, last_uncompressed_size, uncompressed_size);
227: 
228: 			return;
229: 		}
230: 
231: 		if (uncompressed_size != last_uncompressed_size)
232: 		{
233: 			ffnx_warning("%s: uncompressed size is different than expected: %d != %d\n", __func__, uncompressed_size, last_uncompressed_size);
234: 
235: 			return;
236: 		}
237: 	}
238: 	else
239: 	{
240: 		((void(*)(const uint8_t*, uint8_t*))ff8_externals.lzs_uncompress)(source_data, target_data);
241: 	}
242: }
243: 
244: bool ff8_attempt_redirection(const char *in, char *out, size_t size)
245: {
246: 	// Remove AppPath from input
247: 	if (strncmp(in, ff8_externals.app_path, strlen(ff8_externals.app_path)) == 0) {
248: 		// +1 because the last '\' is stripped from AppPath by the game
249: 		in += strlen(ff8_externals.app_path) + 1;
250: 
251: 		return attempt_redirection(in, out, size) != -1;
252: 	}
253: 
254: 	return false;
255: }
256: 
257: int ff8_open(const char *fileName, int oflag, ...)
258: {
259: 	va_list va;
260: 
261: 	va_start(va, oflag);
262: 	int pmode = va_arg(va, DWORD);
263: 	const int shflag = _SH_DENYNO;
264: 
265: 	if (trace_all || trace_files) ffnx_trace("%s: %s oflag=%X pmode=%X\n", __func__, fileName, oflag, pmode);
266: 
267: 	if (next_direct_file && *next_direct_file != '\0')
268: 	{
269: 		if (trace_all || trace_direct) ffnx_info("Direct file using %s\n", next_direct_file);
270: 
271: 		int ret = ff8_externals._sopen(next_direct_file, oflag, shflag, pmode);
272: 
273: 		*next_direct_file = '\0';
274: 
275: 		return ret;
276: 	}
277: 
278: 	char _filename[MAX_PATH]{ 0 };
279: 	bool is_redirected = ff8_attempt_redirection(fileName, _filename, sizeof(_filename));
280: 
281: 	last_fopen_is_redirected = is_redirected;
282: 
283: 	int ret = ff8_externals._sopen(is_redirected ? _filename : fileName, oflag, shflag, pmode);
284: 
285: 	last_fopen_is_redirected = false;
286: 
287: 	return ret;
288: }
289: 
290: FILE *ff8_fopen(const char *fileName, const char *mode)
291: {
292: 	if (trace_all || trace_files) ffnx_trace("%s: %s mode=%s\n", __func__, fileName, mode);
293: 
294: 	const int shflag = _SH_DENYNO;
295: 
296: 	if (next_direct_file && *next_direct_file != '\0')
297: 	{
298: 		if (trace_all || trace_direct) ffnx_info("Direct file using %s\n", next_direct_file);
299: 
300: 		FILE *file = ff8_externals._fsopen(next_direct_file, mode, shflag);
301: 
302: 		*next_direct_file = '\0';
303: 
304: 		return file;
305: 	}
306: 
307: 	char _filename[MAX_PATH]{ 0 };
308: 	bool is_redirected = ff8_attempt_redirection(fileName, _filename, sizeof(_filename));
309: 
310: 	last_fopen_is_redirected = is_redirected;
311: 
312: 	FILE *file = ff8_externals._fsopen(is_redirected ? _filename : fileName, mode, shflag);
313: 
314: 	last_fopen_is_redirected = false;
315: 
316: 	return file;
317: }
318: 
319: ff8_file *ff8_open_file(ff8_file_context *infos, const char *fs_path)
320: {
321: 	if (trace_all || trace_files) ffnx_trace("%s: %s mode=%d callback=%p noOpen=%d archive=%p field_4=%d\n", __func__, fs_path, infos->mode, infos->filename_callback, infos->field_4, infos->file_container, infos->field_4);
322: 
323: 	ff8_file *file;
324: 	char fullpath[MAX_PATH];
325: 	const int shflag = _SH_DENYNO;
326: 
327: 	if (infos->filename_callback != nullptr)
328: 	{
329: 		infos->filename_callback(fs_path, fullpath);
330: 	}
331: 
332: 	if (infos->field_4)
333: 	{
334: 		file = (ff8_file *)external_calloc(1u, sizeof(ff8_file));
335: 
336: 		if (file)
337: 		{
338: 			file->filename = fs_path;
339: 			memcpy(&file->file_context, infos, sizeof(ff8_file_context));
340: 
341: 			if (infos->mode > 1 && infos->mode <= 3)
342: 			{
343: 				ffnx_error("%s: CANT CREATE/WRITE TO FILE %s; FILE SYSTEM IS READ ONLY \n", __func__, fs_path);
344: 			}
345: 		}
346: 	}
347: 	else
348: 	{
349: 		int pmode = _S_IREAD, oflag = _O_BINARY;
350: 
351: 		if (infos->mode == 1)
352: 		{
353: 			oflag = _O_TEXT;
354: 		}
355: 		else if (infos->mode > 1)
356: 		{
357: 			oflag |= _O_CREAT | _O_RDWR;
358: 			pmode |= _S_IWRITE;
359: 
360: 			if (infos->mode == 3)
361: 			{
362: 				oflag |= _O_TRUNC;
363: 			}
364: 		}
365: 
366: 		file = (ff8_file *)external_calloc(1u, sizeof(ff8_file));
367: 
368: 		if (file != nullptr)
369: 		{
370: 			// Note: the code in FF8 is strange here, with a condition on infos->filename_callback
371: 			strncpy(fullpath, fs_path, sizeof(fullpath));
372: 
373: 			if (infos->file_container != nullptr)
374: 			{
375: 				char direct_path[MAX_PATH];
376: 
377: 				set_direct_path(fullpath, direct_path, sizeof(direct_path));
378: 
379: 				file->fd = ff8_externals._sopen(direct_path, oflag, shflag, pmode);
380: 
381: 				if (file->fd != -1)
382: 				{
383: 					if (trace_all || trace_direct) ffnx_info("Direct file using %s\n", direct_path);
384: 				}
385: 				else
386: 				{
387: 					if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", direct_path);
388: 
389: 					if (ff8_externals.fs_archive_search_filename(fullpath, &file->fi_infos, infos->file_container))
390: 					{
391: 						file->fd = 0;
392: 						file->file_container = infos->file_container;
393: 					}
394: 				}
395: 			}
396: 			else
397: 			{
398: 				char _filename[256]{ 0 };
399: 				bool is_redirected = ff8_attempt_redirection(fullpath, _filename, sizeof(_filename));
400: 
401: 				last_fopen_is_redirected = is_redirected;
402: 
403: 				// We need to use the external _open, and not the official one
404: 				file->fd = ff8_externals._sopen(is_redirected ? _filename : fullpath, oflag, shflag, pmode);
405: 
406: 				last_fopen_is_redirected = false;
407: 			}
408: 
409: 			file->is_open = 1;
410: 			file->filename = ff8_externals.strcpy_with_malloc(fullpath);
411: 			memcpy(&(file->file_context), infos, sizeof(ff8_file_context));
412: 
413: 			if (file->fd == -1)
414: 			{
415: 				ffnx_error("%s: COULD NOT OPEN FILE %s\n", __func__, fs_path);
416: 				ff8_close_file(file);
417: 				file = nullptr;
418: 			}
419: 		}
420: 	}
421: 
422: 	return file;
423: }
424: 
425: bool ff8_fs_last_fopen_is_redirected()
426: {
427: 	return last_fopen_is_redirected;
428: }
</file>

<file path="src/ff8/file.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include "../ff8.h"
26: 
27: #include <stdio.h>
28: 
29: int ff8_fs_archive_search_filename2(const char *fullpath, ff8_file_fi_infos *fi_infos_for_the_path, const ff8_file_container *file_container);
30: void ff8_fs_archive_sub_archive_get_filename(const char *filename, char *path);
31: ff8_file_container *ff8_fs_archive_open_temp(char *fl_path, char *fs_path, char *fi_path);
32: int ff8_fs_archive_search_filename_sub_archive(const char *fullpath, ff8_file_fi_infos *fi_infos_for_the_path, const ff8_file_container *file_container);
33: void ff8_fs_archive_free_file_container_sub_archive(ff8_file_container *file_container);
34: void ff8_fs_archive_patch_compression(uint32_t compression_type);
35: uint8_t *ff8_fs_archive_malloc_source_data(size_t size, char *source_code_path, int line);
36: uint8_t *ff8_fs_archive_malloc_target_data(size_t size, char *source_code_path, int line);
37: void ff8_fs_archive_uncompress_data(const uint8_t *source_data, uint8_t *target_data);
38: 
39: int ff8_open(const char *fileName, int oflag, ...);
40: FILE *ff8_fopen(const char *fileName, const char *mode);
41: ff8_file *ff8_open_file(ff8_file_context *infos, const char *fs_path);
42: uint32_t(*ff8_read_file)(uint32_t count, void* buffer, struct ff8_file* file);
43: void (*ff8_close_file)(struct ff8_file* file);
44: 
45: void ff8_fs_lang_string(char *data);
46: 
47: bool ff8_fs_last_fopen_is_redirected();
</file>

<file path="src/ff8/mod.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include "../image/image.h"
 24: #include "../log.h"
 25: #include "../renderer.h"
 26: #include "../utils.h"
 27: 
 28: #include "mod.h"
 29: #include "file.h"
 30: 
 31: 
 32: bx::DefaultAllocator TextureImage::defaultAllocator;
 33: 
 34: TextureImage::TextureImage() :
 35: 	_image(nullptr), _scale(1)
 36: {
 37: }
 38: 
 39: bool TextureImage::createImage(const char *filename, int originalTexturePixelWidth, int originalTextureHeight, int internalLodScale)
 40: {
 41: 	if (_image != nullptr)
 42: 	{
 43: 		destroyImage();
 44: 	}
 45: 
 46: 	bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::BGRA8;
 47: 
 48: 	const char *extension = strrchr(filename, '.');
 49: 	if (extension != nullptr && stricmp(extension + 1, "png") == 0) {
 50: 		// Load PNG using libPNG
 51: 		bimg::ImageMip mip;
 52: 		if (loadPng(filename, mip, targetFormat) && Renderer::doesItFitInMemory(mip.m_size + 1))
 53: 		{
 54: 			_image = bimg::imageAlloc(&defaultAllocator, mip.m_format, mip.m_width, mip.m_height, mip.m_depth, 1, false, false, mip.m_data);
 55: 			setLod(0);
 56: 
 57: 			driver_free((void *)mip.m_data);
 58: 		}
 59: 	} else if (extension != nullptr && stricmp(extension + 1, "dds") == 0) {
 60: 		// Load DDS using DirectXTex
 61: 		DirectX::TexMetadata metadata;
 62: 		DirectX::ScratchImage image;
 63: 		if (parseDds(filename, image, metadata)) {
 64: 			int lod = computeLod(originalTexturePixelWidth, metadata.width, metadata.mipLevels, internalLodScale, filename);
 65: 			// Convert only the relevant lod to improve performance
 66: 			_image = convertDds(&defaultAllocator, image, metadata, targetFormat, lod);
 67: 			image.Release();
 68: 			setLod(0);
 69: 		}
 70: 	} else {
 71: 		_image = loadImageContainer(&defaultAllocator, filename, bimg::TextureFormat::BGRA8);
 72: 
 73: 		if (_image != nullptr)
 74: 		{
 75: 			setLod(computeLod(originalTexturePixelWidth, _image->m_width, _image->m_numMips, internalLodScale, filename));
 76: 		}
 77: 	}
 78: 
 79: 	if (_image == nullptr)
 80: 	{
 81: 		return false;
 82: 	}
 83: 
 84: 	uint8_t scale = computeScale(originalTexturePixelWidth, originalTextureHeight, filename);
 85: 
 86: 	if (trace_all || trace_vram)
 87: 	{
 88: 		ffnx_info("TextureImage::%s: size=%dx%d scaled to %dx%d (x%d) format=%d depth=%d numMips=%d hasAlpha=%d\n", __func__,
 89: 			_image->m_width, _image->m_height, _mip.m_width, _mip.m_height, scale, _mip.m_format, _mip.m_depth, _image->m_numMips, _mip.m_hasAlpha);
 90: 	}
 91: 
 92: 	if (scale == 0)
 93: 	{
 94: 		destroyImage();
 95: 
 96: 		return false;
 97: 	}
 98: 
 99: 	_scale = scale;
100: 
101: 	return true;
102: }
103: 
104: void TextureImage::destroyImage()
105: {
106: 	if (_image != nullptr)
107: 	{
108: 		bimg::imageFree(_image);
109: 		_image = nullptr;
110: 	}
111: }
112: 
113: void TextureImage::setLod(uint8_t lod)
114: {
115: 	if (_image != nullptr)
116: 	{
117: 		bimg::imageGetRawData(*_image, 0, lod, _image->m_data, _image->m_size, _mip);
118: 	}
119: }
120: 
121: int TextureImage::computeMaxScale()
122: {
123: 	int resWidth = window_size_x * newRenderer.getScalingFactor(),
124: 		baseResW = FF8_BASE_RESOLUTION_X;
125: 
126: 	return std::max(resWidth, FF8_BASE_RESOLUTION_X) / baseResW;
127: }
128: 
129: uint8_t TextureImage::computeLod(int originalTexturePixelWidth, int imageWidth, int numMips, int internalScale, const char *filename) const
130: {
131: 	if (numMips <= 1)
132: 	{
133: 		return 0;
134: 	}
135: 
136: 	int maxScale = computeMaxScale(),
137: 		maxWidth = originalTexturePixelWidth * maxScale * internalScale;
138: 
139: 	if (trace_all || trace_vram)
140: 	{
141: 		ffnx_info("TextureImage::%s: maxScale=%d maxWidth=%d imageWidth=%d\n", __func__, maxScale, maxWidth, imageWidth);
142: 	}
143: 
144: 	for (uint8_t lod = 0; lod < numMips; ++lod)
145: 	{
146: 		if (imageWidth <= maxWidth)
147: 		{
148: 			return lod;
149: 		}
150: 
151: 		imageWidth /= 2;
152: 	}
153: 
154: 	ffnx_warning("TextureImage::%s: Cannot detect the LOD of the texture %s\n", __func__, filename);
155: 
156: 	return 0;
157: }
158: 
159: uint8_t TextureImage::computeScale(int sourcePixelW, int sourceH, const char *filename) const
160: {
161: 	int targetPixelW = _mip.m_width, targetH = _mip.m_height;
162: 
163: 	if (targetPixelW < sourcePixelW
164: 		|| targetH < sourceH
165: 		|| targetPixelW % sourcePixelW != 0
166: 		|| targetH % sourceH != 0)
167: 	{
168: 		ffnx_warning("External texture size must be scaled to the original texture size with the same ratio (modded texture size: %dx%d, original texture size: %dx%d, filename=%s)\n", targetPixelW, targetH, sourcePixelW, sourceH, filename);
169: 
170: 		return 0;
171: 	}
172: 
173: 	int scaleW = targetPixelW / sourcePixelW, scaleH = targetH / sourceH;
174: 
175: 	if (scaleW != scaleH)
176: 	{
177: 		ffnx_warning("External texture size must have the same ratio as the original texture: (%d / %d) filename=%s\n", sourcePixelW, sourceH, filename);
178: 
179: 		return 0;
180: 	}
181: 
182: 	if (scaleW > MAX_SCALE)
183: 	{
184: 		ffnx_warning("External texture size cannot exceed \"original size * %d\" (scale=%d) filename=%s\n", MAX_SCALE, scaleW, filename);
185: 
186: 		return 0;
187: 	}
188: 
189: 	return scaleW;
190: }
191: 
192: ModdedTexture::ModdedTexture(const TexturePacker::IdentifiedTexture &originalTexture, bool isInternal):
193: 	_originalTexture(originalTexture), _isInternal(isInternal)
194: {
195: }
196: 
197: bool ModdedTexture::findExternalTexture(const char *name, char *filename, uint8_t palette_index, bool hasPal, const char *extension, char *found_extension)
198: {
199: 	char langPath[16] = "/";
200: 
201: 	if(trace_all || trace_loaders) ffnx_trace("Texture file name (VRAM): %s palette_index=%d hasPal=%d\n", name, palette_index, hasPal);
202: 
203: 	if(save_textures) return false;
204: 
205: 	ff8_fs_lang_string(langPath + 1);
206: 
207: 	for (size_t idx = 0; idx < mod_ext.size(); idx++)
208: 	{
209: 		// Force extension
210: 		if (extension && stricmp(extension, mod_ext[idx].c_str()) != 0)
211: 		{
212: 			continue;
213: 		}
214: 
215: 		for (uint8_t lang = 0; lang < 2; lang++)
216: 		{
217: 			if (hasPal)
218: 			{
219: 				_snprintf(filename, MAX_PATH, "%s/%s%s/%s_%02i.%s", basedir, mod_path.c_str(), langPath, name, palette_index, mod_ext[idx].c_str());
220: 			}
221: 			else
222: 			{
223: 				_snprintf(filename, MAX_PATH, "%s/%s%s/%s.%s", basedir, mod_path.c_str(), langPath, name, mod_ext[idx].c_str());
224: 			}
225: 
226: 			if (fileExists(filename))
227: 			{
228: 				if (trace_all || trace_loaders) ffnx_trace("Using texture: %s\n", filename);
229: 
230: 				if (found_extension != nullptr) {
231: 					strncpy(found_extension, mod_ext[idx].c_str(), mod_ext[idx].size());
232: 				}
233: 
234: 				return true;
235: 			}
236: 			else if (trace_all || trace_loaders)
237: 			{
238: 				ffnx_warning("Texture does not exist, skipping: %s\n", filename);
239: 			}
240: 
241: 			*langPath = '\0';
242: 		}
243: 
244: 		*langPath = '/';
245: 	}
246: 
247: 	return false;
248: }
249: 
250: void ModdedTexture::drawImage(
251: 	const uint32_t *sourceRgba, int sourceRgbaW, uint8_t sourceScale,
252: 	uint32_t *targetRgba, int targetRgbaW, uint8_t targetScale,
253: 	int sourceX, int sourceY, int sourceW, int sourceH,
254: 	int targetX, int targetY)
255: {
256: 	if (targetScale < sourceScale)
257: 	{
258: 		return;
259: 	}
260: 
261: 	sourceRgbaW *= sourceScale;
262: 	targetRgbaW *= targetScale;
263: 	const uint8_t scaleRatio = targetScale / sourceScale;
264: 
265: 	for (int y = 0; y < sourceH; ++y)
266: 	{
267: 		for (int x = 0; x < sourceW; ++x)
268: 		{
269: 			const uint32_t *sourceRgbaCur = sourceRgba + (sourceX + x) * sourceScale + (sourceY + y) * sourceScale * sourceRgbaW;
270: 			uint32_t *targetRgbaCur = targetRgba + (targetX + x) * targetScale + (targetY + y) * targetScale * targetRgbaW;
271: 
272: 			for (int yPix = 0; yPix < targetScale; ++yPix)
273: 			{
274: 				for (int xPix = 0; xPix < targetScale; ++xPix)
275: 				{
276: 					uint32_t color = *(sourceRgbaCur + xPix / scaleRatio + yPix / scaleRatio * sourceRgbaW),
277: 						alpha = color & 0xFF000000;
278: 					*(targetRgbaCur + xPix + yPix * targetRgbaW) = (color & 0xFFFFFF) | (alpha >= 0x7F000000 ? 0x7F000000 : 0);
279: 				}
280: 			}
281: 		}
282: 	}
283: }
284: 
285: void ModdedTexture::copyRect(
286: 	const uint32_t *sourceRgba, int sourceRgbaW, uint32_t *targetRgba, int targetRgbaW, uint8_t scale, Tim::Bpp depth,
287: 	int sourceXBpp2, int sourceY, int sourceWBpp2, int sourceH, int targetXBpp2, int targetY)
288: {
289: 	int sourceX = sourceXBpp2 * (4 >> int(depth)),
290: 		sourceW = sourceWBpp2 * (4 >> int(depth)) * scale,
291: 		targetX = targetXBpp2 * (4 >> int(depth));
292: 
293: 	const uint32_t *source = sourceRgba + (sourceX + sourceY * sourceRgbaW) * scale;
294: 	uint32_t *target = targetRgba + (targetX + targetY * targetRgbaW) * scale;
295: 
296: 	sourceH *= scale;
297: 
298: 	for (int y = 0; y < sourceH; ++y)
299: 	{
300: 		memcpy(target, source, sizeof(uint32_t) * sourceW);
301: 
302: 		source += sourceRgbaW;
303: 		target += targetRgbaW;
304: 	}
305: }
306: 
307: TextureModStandard::~TextureModStandard()
308: {
309: 	for (std::pair<uint8_t, TextureImage> image: _textures)
310: 	{
311: 		image.second.destroyImage();
312: 	}
313: }
314: 
315: bool TextureModStandard::createImages(int paletteCount, int internalLodScale)
316: {
317: 	paletteCount = paletteCount >= 0 ? paletteCount : originalTexture().palette().h(); // Works most of the time
318: 
319: 	if (trace_all || trace_vram) ffnx_trace("TextureModStandard::%s: paletteCount=%d internalLodScale=%d\n", __func__, paletteCount, internalLodScale);
320: 
321: 	int modCount = std::max(paletteCount, 1);
322: 	char filename[MAX_PATH] = {}, *extension = nullptr, found_extension[16] = {};
323: 
324: 	for (int paletteId = 0; paletteId < modCount; ++paletteId) {
325: 		if (!findExternalTexture(originalTexture().name().c_str(), filename, paletteId, true, extension, found_extension))
326: 		{
327: 			continue;
328: 		}
329: 
330: 		// Force the same extension for every palettes to reduce file existence checks
331: 		extension = found_extension;
332: 
333: 		TextureImage externalTexture;
334: 		if (!externalTexture.createImage(filename, originalTexture().texture().pixelW(), originalTexture().texture().h(), internalLodScale))
335: 		{
336: 			continue;
337: 		}
338: 
339: 		_textures[paletteId] = externalTexture;
340: 	}
341: 
342: 	return !_textures.empty();
343: }
344: 
345: uint8_t TextureModStandard::computePaletteId(int vramPalXBpp2, int vramPalY) const
346: {
347: 	if (_currentPalette >= 0)
348: 	{
349: 		return uint8_t(_currentPalette);
350: 	}
351: 
352: 	if (vramPalXBpp2 == originalTexture().palette().x()
353: 		&& vramPalY >= originalTexture().palette().y() && vramPalY < originalTexture().palette().y() + originalTexture().palette().h())
354: 	{
355: 		return vramPalY - originalTexture().palette().y();
356: 	}
357: 
358: 	return 0;
359: }
360: 
361: const TextureImage &TextureModStandard::textureImage(uint8_t paletteId) const
362: {
363: 	if (trace_all || trace_vram) ffnx_trace("TextureModStandard::%s paletteId=%d\n", __func__, paletteId);
364: 
365: 	auto it = _textures.find(paletteId);
366: 
367: 	if (it == _textures.end())
368: 	{
369: 		if (trace_all || trace_vram) ffnx_warning("TextureModStandard::%s cannot find image for paletteId=%d, fallback to the first one\n", __func__, paletteId);
370: 
371: 		return _textures.begin()->second; // Use the first image
372: 	}
373: 
374: 	return it->second;
375: }
376: 
377: uint8_t TextureModStandard::scale(int vramPalXBpp2, int vramPalY) const
378: {
379: 	if (trace_all || trace_vram) ffnx_trace("TextureModStandard::%s %s vramPal=(%d, %d) original=(%d, %d)\n", __func__, originalTexture().name().c_str(), vramPalXBpp2, vramPalY, originalTexture().palette().x(), originalTexture().palette().y());
380: 
381: 	return textureImage(computePaletteId(vramPalXBpp2, vramPalY)).scale();
382: }
383: 
384: TexturePacker::TextureTypes TextureModStandard::drawToImage(
385: 	int offsetX, int offsetY,
386: 	uint32_t *targetRgba, int targetW, int targetH, uint8_t targetScale, Tim::Bpp targetBpp,
387: 	int16_t vramPalXBpp2, int16_t vramPalY) const
388: {
389: 	const TexturePacker::TextureInfos &origTexture = originalTexture().texture();
390: 
391: 	if (origTexture.bpp() != targetBpp)
392: 	{
393: 		return TexturePacker::NoTexture;
394: 	}
395: 
396: 	int sourceX = offsetX < 0 ? -offsetX : 0,
397: 		sourceY = offsetY < 0 ? -offsetY : 0,
398: 		targetX = offsetX > 0 ? offsetX : 0,
399: 		targetY = offsetY > 0 ? offsetY : 0,
400: 		width = std::min(origTexture.pixelW() - sourceX, targetW - targetX),
401: 		height = std::min(origTexture.h() - sourceY, targetH - targetY);
402: 
403: 	if (width <= 0 || height <= 0)
404: 	{
405: 		return TexturePacker::NoTexture;
406: 	}
407: 
408: 	uint8_t paletteId = computePaletteId(vramPalXBpp2, vramPalY);
409: 	const TextureImage &image = textureImage(paletteId);
410: 	const bimg::ImageMip &mip = image.mip();
411: 
412: 	drawImage(
413: 		reinterpret_cast<const uint32_t *>(mip.m_data), mip.m_width / image.scale(), image.scale(),
414: 		targetRgba, targetW, targetScale,
415: 		sourceX, sourceY, width, height,
416: 		targetX, targetY
417: 	);
418: 
419: 	return TexturePacker::ExternalTexture;
420: }
421: 
422: void TextureModStandard::copyRect(int sourceXBpp2, int sourceY, int sourceWBpp2, int sourceH, int targetXBpp2, int targetY)
423: {
424: 	const TexturePacker::TextureInfos &texture = originalTexture().texture();
425: 
426: 	for (const std::pair<uint8_t, TextureImage> &image: _textures)
427: 	{
428: 		const bimg::ImageMip &mip = image.second.mip();
429: 		ModdedTexture::copyRect(
430: 			reinterpret_cast<const uint32_t *>(mip.m_data), mip.m_width,
431: 			const_cast<uint32_t *>(reinterpret_cast<const uint32_t *>(mip.m_data)), mip.m_width,
432: 			image.second.scale(), texture.bpp(),
433: 			sourceXBpp2 - texture.x(), sourceY - texture.y(), sourceWBpp2, sourceH,
434: 			targetXBpp2 - texture.x(), targetY - texture.y()
435: 		);
436: 	}
437: }
438: 
439: void TextureModStandard::copyRect(
440: 	int sourceXBpp2, int sourceY, int sourceWBpp2, int sourceH, int targetXBpp2, int targetY,
441: 	const TextureModStandard &targetTexture)
442: {
443: 	const TexturePacker::TextureInfos &tex = originalTexture().texture(),
444: 		&targetTex = targetTexture.originalTexture().texture();
445: 
446: 	if (tex.bpp() != targetTex.bpp()) {
447: 		return;
448: 	}
449: 
450: 	for (const std::pair<uint8_t, TextureImage> &image: _textures)
451: 	{
452: 		for (const std::pair<uint8_t, TextureImage> &targetImage: targetTexture._textures)
453: 		{
454: 			const bimg::ImageMip &mip = image.second.mip();
455: 			const bimg::ImageMip &targetMip = targetImage.second.mip();
456: 
457: 			if (image.second.scale() != targetImage.second.scale()) {
458: 				continue;
459: 			}
460: 
461: 			ModdedTexture::copyRect(
462: 				reinterpret_cast<const uint32_t *>(mip.m_data), mip.m_width,
463: 				const_cast<uint32_t *>(reinterpret_cast<const uint32_t *>(targetMip.m_data)), targetMip.m_width,
464: 				image.second.scale(), tex.bpp(),
465: 				sourceXBpp2 - tex.x(), sourceY - tex.y(), sourceWBpp2, sourceH,
466: 				targetXBpp2 - targetTex.x(), targetY - targetTex.y()
467: 			);
468: 		}
469: 	}
470: }
471: 
472: void TextureModStandard::forceCurrentPalette(int8_t currentPalette)
473: {
474: 	if (_textures.contains(currentPalette)) {
475: 		_currentPalette = currentPalette;
476: 	}
477: }
478: 
479: TextureBackground::TextureBackground(
480: 	const TexturePacker::IdentifiedTexture &originalTexture,
481: 	const std::vector<Tile> &mapTiles
482: ) : ModdedTexture(originalTexture), _mapTiles(mapTiles)
483: {
484: }
485: 
486: TextureBackground::~TextureBackground()
487: {
488: 	_texture.destroyImage();
489: }
490: 
491: bool TextureBackground::createImages(const char *extension, char *foundExtension)
492: {
493: 	size_t size = _mapTiles.size();
494: 
495: 	_colsCount = size / (TEXTURE_HEIGHT / TILE_SIZE) + int(size % (TEXTURE_HEIGHT / TILE_SIZE) != 0);
496: 
497: 	char filename[MAX_PATH] = {};
498: 
499: 	if (!findExternalTexture(originalTexture().name().c_str(), filename, 0, false, extension, foundExtension))
500: 	{
501: 		return false;
502: 	}
503: 
504: 	if (!_texture.createImage(filename, _colsCount * TILE_SIZE, TEXTURE_HEIGHT))
505: 	{
506: 		return false;
507: 	}
508: 
509: 	// Build tileIdsByPosition for fast lookup
510: 	_tileIdsByTextureId.reserve(size);
511: 
512: 	_usedBpps = 0; // 1: 4-bit, 2: 8-bit, 4: 16-bit
513: 	size_t tileId = 0;
514: 	for (const Tile &tile: _mapTiles) {
515: 		const uint8_t texId = tile.texID & 0xF;
516: 		const uint8_t bpp = (tile.texID >> 7) & 3;
517: 		const uint16_t key = uint16_t(texId) | (uint16_t(tile.srcX / TILE_SIZE) << 4) | (uint16_t(tile.srcY / TILE_SIZE) << 8) | (uint16_t(bpp) << 12);
518: 		_usedBpps |= 1 << bpp;
519: 
520: 		auto it = _tileIdsByTextureId.find(key);
521: 		// Remove some duplicates (but keep those which render differently)
522: 		if (it == _tileIdsByTextureId.end() || ! ff8_background_tiles_looks_alike(tile, _mapTiles.at(it->second))) {
523: 			_tileIdsByTextureId.insert(std::pair<uint16_t, size_t>(key, tileId));
524: 		}
525: 		++tileId;
526: 	}
527: 
528: 	return true;
529: }
530: 
531: bool TextureBackground::isBpp(Tim::Bpp bpp) const
532: {
533: 	return true;
534: }
535: 
536: TexturePacker::TextureTypes TextureBackground::drawToImage(
537: 	int offsetX, int offsetY,
538: 	uint32_t *targetRgba, int targetW, int targetH, uint8_t targetScale, Tim::Bpp targetBpp,
539: 	int16_t vramPalXBpp2, int16_t vramPalY) const
540: {
541: 	const bimg::ImageMip &mip = _texture.mip();
542: 	const uint32_t *imgData = reinterpret_cast<const uint32_t *>(mip.m_data);
543: 	const uint8_t imgScale = _texture.scale();
544: 	const uint32_t imgWidth = mip.m_width / imgScale, imgHeight = mip.m_height / imgScale;
545: 
546: 	const uint8_t cols = targetW / TILE_SIZE, rows = targetH / TILE_SIZE;
547: 	const uint8_t colsBpp = TILE_SIZE / (1 << uint16_t(targetBpp));
548: 	const uint8_t paletteId = vramPalY - 232 - 8; // The palette always is at (0, 232) and the first 8 palettes are unused
549: 	const uint8_t initialTextureId = -offsetX / (4 >> uint16_t(targetBpp)) / TEXTURE_WIDTH_BPP16;
550: 
551: 	for (uint8_t y = 0; y < 16; ++y) {
552: 		for (uint8_t x = 0; x < 16; ++x) {
553: 			const uint8_t textureId = initialTextureId + x / colsBpp;
554: 			const uint8_t textureX = x % colsBpp;
555: 			const uint16_t key = uint16_t(textureId) | (uint16_t(textureX) << 4) | (uint16_t(y) << 8) | (uint16_t(targetBpp) << 12);
556: 			auto [begin, end] = _tileIdsByTextureId.equal_range(key);
557: 			if (begin == end) {
558: 				if (trace_all || trace_vram) ffnx_warning("TextureBackground::%s: No tile found for textureId=%d x=%d y=%d targetBpp=%d paletteId=%d\n", __func__, textureId, textureX, y, targetBpp, paletteId);
559: 
560: 				continue;
561: 			}
562: 
563: 			const size_t tileIdDefault = begin->second;
564: 			std::vector<size_t> matched;
565: 
566: 			// When matching multiple tiles for the same texture part, try to choose the good tile
567: 			for (const std::pair<uint16_t, size_t> &pair: std::ranges::subrange{begin, end}) {
568: 				const Tile &tile = _mapTiles.at(pair.second);
569: 				uint8_t palId = (tile.palID >> 6) & 0xF;
570: 
571: 				if (targetBpp != Tim::Bpp16 && paletteId != palId) {
572: 					continue;
573: 				}
574: 
575: 				/* if (tile.parameter != 255) {
576: 					if (tile.parameter < *ff8_externals.field_state_background_count) {
577: 						const ff8_field_state_background *field_state_backgrounds = *ff8_externals.field_state_backgrounds;
578: 
579: 						if (tile.state != field_state_backgrounds[tile.parameter].bgstate >> 6) {
580: 							continue;
581: 						}
582: 					} else {
583: 						if (trace_all || trace_vram) ffnx_warning("TextureBackground::%s: group script not found for background parameter %d\n", __func__, tile.parameter);
584: 
585: 						continue;
586: 					}
587: 				} */
588: 
589: 				matched.push_back(pair.second);
590: 			}
591: 
592: 			size_t matchedCount = matched.size(),
593: 				tileId = matchedCount > 0 ? matched.at(0) : tileIdDefault;
594: 
595: 			if (matchedCount > 1) {
596: 				if (trace_all || trace_vram) ffnx_warning("TextureBackground::%s: tile %d conflict\n", __func__, tileIdDefault);
597: 			}
598: 
599: 			const int col = tileId % _colsCount, row = tileId / _colsCount;
600: 
601: 			drawImage(
602: 				imgData, imgWidth, imgScale,
603: 				targetRgba, targetW, targetScale,
604: 				col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE,
605: 				x * TILE_SIZE, y * TILE_SIZE
606: 			);
607: 		}
608: 	}
609: 
610: 	return TexturePacker::ExternalTexture;
611: }
612: 
613: TextureRawImage::TextureRawImage(
614: 	const TexturePacker::IdentifiedTexture &originalTexture,
615: 	uint32_t *imageData, int imageWidth, int imageHeight
616: ) : ModdedTexture(originalTexture, true), _image(imageData), _width(imageWidth), _height(imageHeight),
617: 	_scale(computeScale())
618: {
619: }
620: 
621: TextureRawImage::~TextureRawImage()
622: {
623: 	if (_image != nullptr) {
624: 		driver_free(_image);
625: 	}
626: }
627: 
628: uint8_t TextureRawImage::computeScale() const
629: {
630: 	return _height / originalTexture().texture().h();
631: }
632: 
633: TexturePacker::TextureTypes TextureRawImage::drawToImage(
634: 	int offsetX, int offsetY,
635: 	uint32_t *targetRgba, int targetW, int targetH, uint8_t targetScale, Tim::Bpp targetBpp,
636: 	int16_t vramPalXBpp2, int16_t vramPalY) const
637: {
638: 	const TexturePacker::TextureInfos &origTexture = originalTexture().texture();
639: 
640: 	if (origTexture.bpp() != targetBpp)
641: 	{
642: 		return TexturePacker::NoTexture;
643: 	}
644: 
645: 	int sourceX = offsetX < 0 ? -offsetX : 0,
646: 		sourceY = offsetY < 0 ? -offsetY : 0,
647: 		targetX = offsetX > 0 ? offsetX : 0,
648: 		targetY = offsetY > 0 ? offsetY : 0,
649: 		width = std::min(origTexture.pixelW() - sourceX, targetW - targetX),
650: 		height = std::min(origTexture.h() - sourceY, targetH - targetY);
651: 
652: 	if (width <= 0 || height <= 0)
653: 	{
654: 		return TexturePacker::NoTexture;
655: 	}
656: 
657: 	drawImage(
658: 		_image, _width / _scale, _scale,
659: 		targetRgba, targetW, targetScale,
660: 		sourceX, sourceY, width, height,
661: 		targetX, targetY
662: 	);
663: 
664: 	return TexturePacker::InternalTexture;
665: }
</file>

<file path="src/ff8/mod.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <map>
 26: #include <vector>
 27: #include <unordered_map>
 28: #include <bimg/bimg.h>
 29: #include <bx/allocator.h>
 30: 
 31: #include "texture_packer.h"
 32: #include "field/background.h"
 33: 
 34: class TextureImage {
 35: public:
 36: 	TextureImage();
 37: 	bool createImage(const char *filename, int originalTexturePixelWidth, int originalTextureHeight, int internalLodScale = 1);
 38: 	void destroyImage();
 39: 	inline uint8_t scale() const {
 40: 		return _scale;
 41: 	}
 42: 	inline void setScale(uint8_t scale) {
 43: 		_scale = scale;
 44: 	}
 45: 	inline bool hasImage() const {
 46: 		return _image != nullptr;
 47: 	}
 48: 	inline const bimg::ImageMip &mip() const {
 49: 		return _mip;
 50: 	}
 51: 	static int computeMaxScale();
 52: private:
 53: 	void setLod(uint8_t lod);
 54: 	uint8_t computeLod(int originalTexturePixelWidth, int imageWidth, int numMips, int internalScale = 1, const char *filename = "") const;
 55: 	uint8_t computeScale(int originalTexturePixelWidth, int originalTextureHeight, const char *filename = "") const;
 56: 	bimg::ImageContainer *_image;
 57: 	bimg::ImageMip _mip;
 58: 	uint8_t _scale;
 59: 
 60: 	static bx::DefaultAllocator defaultAllocator;
 61: };
 62: 
 63: class ModdedTexture {
 64: public:
 65: 	ModdedTexture(const TexturePacker::IdentifiedTexture &originalTexture, bool isInternal = false);
 66: 	ModdedTexture(const ModdedTexture &other) = delete;
 67: 	virtual ~ModdedTexture() {}
 68: 	virtual bool isBpp(Tim::Bpp bpp) const {
 69: 		return bpp == _originalTexture.texture().bpp();
 70: 	}
 71: 	virtual uint8_t scale(int vramPalXBpp2, int vramPalY) const=0;
 72: 	inline virtual bool canCopyRect() const {
 73: 		return false;
 74: 	}
 75: 	inline bool isInternal() const {
 76: 		return _isInternal;
 77: 	}
 78: 	virtual TexturePacker::TextureTypes drawToImage(
 79: 		int offsetX, int offsetY,
 80: 		uint32_t *targetRgba, int targetW, int targetH, uint8_t targetScale, Tim::Bpp targetBpp,
 81: 		int16_t paletteVramX, int16_t paletteVramY
 82: 	) const=0;
 83: 	static bool findExternalTexture(const char *name, char *outFilename, uint8_t palette_index, bool hasPal, const char *extension = nullptr, char *foundExtension = nullptr);
 84: protected:
 85: 	static void drawImage(
 86: 		const uint32_t *sourceRgba, int sourceRgbaW, uint8_t sourceScale,
 87: 		uint32_t *targetRgba, int targetRgbaW, uint8_t targetScale,
 88: 		int sourceX, int sourceY, int sourceW, int sourceH,
 89: 		int targetX, int targetY
 90: 	);
 91: 	static void copyRect(
 92: 		const uint32_t *sourceRgba, int sourceRgbaW, uint32_t *targetRgba, int targetRgbaW, uint8_t scale, Tim::Bpp depth,
 93: 		int sourceXBpp2, int sourceY, int sourceWBpp2, int sourceH,
 94: 		int targetXBpp2, int targetY
 95: 	);
 96: 	inline const TexturePacker::IdentifiedTexture &originalTexture() const {
 97: 		return _originalTexture;
 98: 	}
 99: private:
100: 	TexturePacker::IdentifiedTexture _originalTexture;
101: 	bool _isInternal, _isFlushed;
102: };
103: 
104: class TextureModStandard : public ModdedTexture {
105: public:
106: 	TextureModStandard(const TexturePacker::IdentifiedTexture &originalTexture) : ModdedTexture(originalTexture), _currentPalette(-1) {}
107: 	TextureModStandard(const TextureModStandard &other) = delete;
108: 	~TextureModStandard();
109: 	inline bool canCopyRect() const override {
110: 		return true;
111: 	}
112: 	bool createImages(int paletteCount, int internalLodScale = 1);
113: 	uint8_t scale(int vramPalXBpp2, int vramPalY) const override;
114: 	TexturePacker::TextureTypes drawToImage(
115: 		int offsetX, int offsetY,
116: 		uint32_t *targetRgba, int targetW, int targetH, uint8_t targetScale, Tim::Bpp targetBpp,
117: 		int16_t vramPalXBpp2, int16_t vramPalY
118: 	) const override;
119: 	// Copy rect inside the textures
120: 	void copyRect(int sourceXBpp2, int sourceY, int sourceWBpp2, int sourceH, int targetXBpp2, int targetY);
121: 	// Copy rect to another textures
122: 	void copyRect(int sourceXBpp2, int sourceY, int sourceWBpp2, int sourceH, int targetXBpp2, int targetY, const TextureModStandard &targetTexture);
123: 	// Set to -1 to unforce
124: 	void forceCurrentPalette(int8_t currentPalette);
125: private:
126: 	bool createImage(const char *name, int paletteId = -1, const char *extension = nullptr, char *foundExtension = nullptr);
127: 	uint8_t computePaletteId(int vramPalXBpp2, int vramPalY) const;
128: 	const TextureImage &textureImage(uint8_t paletteId) const;
129: 	std::map<uint8_t, TextureImage> _textures; // Index: paletteId or current texture
130: 	int8_t _currentPalette;
131: };
132: 
133: class TextureBackground : public ModdedTexture {
134: public:
135: 	TextureBackground(
136: 		const TexturePacker::IdentifiedTexture &originalTexture,
137: 		const std::vector<Tile> &mapTiles
138: 	);
139: 	TextureBackground(const TextureBackground &other) = delete;
140: 	~TextureBackground();
141: 	bool isBpp(Tim::Bpp bpp) const override;
142: 	inline uint8_t scale(int vramPalXBpp2, int vramPalY) const override {
143: 		return _texture.scale();
144: 	}
145: 	bool createImages(const char *extension = nullptr, char *foundExtension = nullptr);
146: 	TexturePacker::TextureTypes drawToImage(
147: 		int offsetX, int offsetY,
148: 		uint32_t *targetRgba, int targetW, int targetH, uint8_t targetScale, Tim::Bpp targetBpp,
149: 		int16_t vramPalXBpp2, int16_t vramPalY
150: 	) const override;
151: private:
152: 	std::vector<Tile> _mapTiles;
153: 	std::unordered_multimap<uint16_t, size_t> _tileIdsByTextureId;
154: 	TextureImage _texture;
155: 	uint8_t _colsCount, _usedBpps;
156: };
157: 
158: struct TextureRawImage : public ModdedTexture {
159: 	TextureRawImage(
160: 		const TexturePacker::IdentifiedTexture &originalTexture,
161: 		uint32_t *imageData, int imageWidth, int imageHeight
162: 	);
163: 	TextureRawImage(const TextureRawImage &other) = delete;
164: 	~TextureRawImage();
165: 	inline bool isValid() const {
166: 		return _scale != 0;
167: 	}
168: 	inline uint8_t scale(int vramPalXBpp2, int vramPalY) const override {
169: 		return _scale;
170: 	}
171: 	TexturePacker::TextureTypes drawToImage(
172: 		int offsetX, int offsetY,
173: 		uint32_t *targetRgba, int targetW, int targetH, uint8_t targetScale, Tim::Bpp targetBpp,
174: 		int16_t vramPalXBpp2, int16_t vramPalY
175: 	) const override;
176: private:
177: 	uint8_t computeScale() const;
178: 	uint32_t *_image;
179: 	int _width, _height;
180: 	uint8_t _scale;
181: };
</file>

<file path="src/ff8/save_data.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2025 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #define G_FORCE_NUM 16
 26: #define CHAR_NUM 8
 27: 
 28: #include <cstdint>
 29: 
 30: struct savemap_ff8_item {
 31: 	uint8_t item_id;
 32: 	uint8_t item_quantity;
 33: };
 34: 
 35: struct savemap_ff8_header {
 36: 	uint16_t location_id;
 37: 	uint16_t char1_curr_hp;
 38: 	uint16_t char1_max_hp;
 39: 	uint16_t save_count;
 40: 	uint32_t gil;
 41: 	uint32_t played_time_secs;
 42: 	uint8_t char1_lvl;
 43: 	uint8_t char1_portrait;
 44: 	uint8_t char2_portrait;
 45: 	uint8_t char3_portrait;
 46: 	uint8_t squall_name[12];
 47: 	uint8_t rinoa_name[12];
 48: 	uint8_t angelo_name[12];
 49: 	uint8_t boko_name[12];
 50: 	uint32_t curr_disk;
 51: 	uint32_t curr_save;
 52: };
 53: 
 54: struct savemap_ff8_gf {
 55: 	uint8_t name[12];
 56: 	uint32_t exp;
 57: 	uint8_t unk1;
 58: 	uint8_t exists;
 59: 	uint16_t HPs;
 60: 	uint8_t complete_abilities[16]; // 115+1 valides, 124 existantes
 61: 	uint8_t APs[24];                // 22 + 2 unused
 62: 	uint16_t kills;
 63: 	uint16_t KOs;
 64: 	uint8_t learning;
 65: 	uint8_t forgotten1; // 22 + 2 unused
 66: 	uint8_t forgotten2;
 67: 	uint8_t forgotten3;
 68: };
 69: 
 70: struct savemap_ff8_character {
 71: 	uint16_t current_hp;
 72: 	uint16_t max_hp;
 73: 	uint32_t exp;
 74: 	uint8_t model_id;
 75: 	uint8_t weapon_id;
 76: 	uint8_t str;
 77: 	uint8_t vit;
 78: 	uint8_t mag;
 79: 	uint8_t spr;
 80: 	uint8_t spd;
 81: 	uint8_t lck;
 82: 	uint16_t magics[32];
 83: 	uint8_t commands[3];
 84: 	uint8_t unk1; // unused command (padding)
 85: 	uint8_t abilities[4];
 86: 	uint16_t gfs;
 87: 	uint8_t unk2;              // used unknown value
 88: 	uint8_t alternative_model; // Seed costume/Galbadia costume
 89: 	uint8_t j_hp;
 90: 	uint8_t j_str;
 91: 	uint8_t j_vit;
 92: 	uint8_t j_mag;
 93: 	uint8_t j_spr;
 94: 	uint8_t j_spd;
 95: 	uint8_t j_eva;
 96: 	uint8_t j_hit;
 97: 	uint8_t j_lck;
 98: 	uint8_t j_atk_ele;
 99: 	uint8_t j_atk_mtl;
100: 	uint8_t j_def_elem[4];
101: 	uint8_t j_def_mtl[4];
102: 	uint8_t unk3; // padding ?
103: 	uint16_t gf_compat[G_FORCE_NUM];
104: 	uint16_t kills;
105: 	uint16_t kos;
106: 	uint8_t exists;
107: 	uint8_t unk4;
108: 	uint8_t status;
109: 	uint8_t unk5; // padding ?
110: };
111: 
112: struct savemap_ff8_shop {
113: 	uint8_t items[16];
114: 	uint8_t visited;
115: 	uint8_t unk1[3];
116: };
117: 
118: struct savemap_ff8_limit_break {
119: 	uint16_t quistis_lb;
120: 	uint16_t zell_lb;
121: 	uint8_t irvine_lb;
122: 	uint8_t selphie_lb;
123: 	uint8_t angelo_completed_lb;
124: 	uint8_t angelo_known_lb;
125: 	uint8_t angelo_points_lb[8];
126: };
127: 
128: struct savemap_ff8_items {
129: 	uint8_t battle_order[32];
130: 	savemap_ff8_item items[198];
131: };
132: 
133: #pragma pack(push, 1)
134: struct savemap_ff8_battle {
135: 	uint32_t unk1;
136: 	uint32_t victory_count;
137: 	uint16_t unk2;
138: 	uint16_t battle_escaped;
139: 	uint32_t unk3;
140: 	uint32_t tomberry_vaincus;
141: 	uint32_t tomberry_sr_vaincu;
142: 	uint32_t ufo_battle_encountered;
143: 	uint32_t elmidea_battle_r1;
144: 	uint32_t succube_battle_elemental;
145: 	uint32_t trex_battle_mental;
146: 	uint32_t battle_irvine;
147: 	uint8_t magic_drawn_once[8];
148: 	uint8_t ennemy_scanned_once[20];
149: 	uint8_t renzokuken_auto;
150: 	uint8_t renzokuken_indicator;
151: 	uint8_t special_flags; //dream|Odin|Phoenix|Gilgamesh|Angelo disabled|Angel Wing enabled|???|???
152: };
153: #pragma pack(pop)
154: 
155: struct savemap_ff8_field_h {
156: 	uint32_t unk1;
157: 	uint32_t steps;
158: 	uint32_t payslip;
159: 	uint32_t unk2;
160: 	uint16_t seedExp;
161: 	uint16_t unk3;
162: 	uint32_t victory_count;
163: 	uint16_t unk4;
164: 	uint16_t battle_escaped;
165: 	uint16_t kills[8];
166: 	uint16_t ko[8];
167: 	uint8_t unk5[8];
168: 	uint32_t monster_kills;
169: 	uint32_t gils;
170: 	uint32_t dream_gils;
171: 	uint32_t current_frame;
172: 	uint16_t last_field_id;
173: 	uint8_t current_car_rent;
174: 	uint8_t music_util;
175: 	uint8_t move_find_ondine;
176: 	uint8_t unk6[15];
177: 	uint32_t unk7;
178: 	uint32_t music_related;
179: 	uint32_t unk8;
180: 	uint8_t draw_points[64];
181: 	uint16_t steps2;
182: 	uint16_t battle_mode;
183: 	uint16_t unk9;
184: 	uint8_t unkA[11];
185: 	uint8_t music_volume;
186: 	uint8_t unkB;
187: 	uint8_t music_played;
188: 	uint8_t unkC;
189: 	uint8_t music_is_played;
190: 	uint8_t unkD;
191: 	uint8_t battle_music;
192: 	uint8_t curr_disk;
193: 	uint8_t unkE;
194: 	uint8_t music_is_loaded;
195: 	uint8_t battle_off;
196: 	uint8_t unkF;
197: 	uint8_t save_enabled;
198: 	uint8_t unkG[3];
199: 	uint8_t music_loaded;
200: 	uint8_t unkH[42];
201: };
202: 
203: struct savemap_ff8_field {
204: 	uint16_t game_moment;
205: 	uint8_t ward_unused;
206: 	uint8_t unused1[2];
207: 	uint8_t save_flag;
208: 	uint8_t unused2[2];
209: 	uint8_t wm_related[7];
210: 	uint8_t unused3;
211: 	uint8_t tt_rules[8];
212: 	uint8_t tt_traderules[8];
213: 	uint8_t tt_lastrules[2];
214: 	uint8_t tt_lastregion[2];
215: 	uint8_t tt_new_rules_tmp;// Unused in save
216: 	uint8_t tt_new_trade_rules_tmp;// Unused in save
217: 	uint8_t tt_add_this_rule_queen_tmp;// Unused in save
218: 	uint8_t tt_cardqueen_location;
219: 	uint8_t tt_traderating_region;
220: 	uint8_t tt_traderating;
221: 	uint8_t tt_degeneration;
222: 	uint8_t tt_curtraderulequeen;
223: 	uint8_t tt_cardqueen_quest;
224: 	uint8_t unused4[3];
225: 	uint16_t timber_maniacs; // bitmap for timber maniacs found
226: 	uint8_t unk1[154];
227: 	uint8_t tt_cc_quest_1; // ??? | ??? | Joker | ??? | King unlocked
228: 	uint8_t unk2[13];
229: 	uint8_t tt_players_bgu_dialogs1;
230: 	uint8_t tt_players_bgu_dialogs2; // King win
231: 	uint8_t tt_players_bgu_dialogs3;
232: 	uint8_t tt_cc_quest_2; // Jack | Clover | Spades | Shu | Diamonds
233: 	uint8_t tt_bgu_victory_count;
234: 	uint8_t unk3[137];
235: 	uint8_t chocobo_affinity[7]; // fourth element is for chocobo garden (value 128 means chocobo found)
236: 	uint8_t unk4[657];
237: };
238: 
239: struct savemap_ff8_worldmap {
240: 	uint16_t char_pos[6];
241: 	uint16_t unknown_pos1[6];
242: 	uint16_t ragnarok_pos[6];
243: 	uint16_t balamb_garden_pos[6];
244: 	uint16_t car_pos[6];
245: 	uint16_t unknown_pos2[6];
246: 	uint16_t unknown_pos3[6];
247: 	uint16_t unknown_pos4[6];
248: 	uint16_t steps_related;
249: 	uint8_t car_rent;
250: 	uint8_t unk1[7];
251: 	uint16_t unk2;
252: 	uint16_t unk3;
253: 	uint8_t disp_map_config;// 0:none|1:minisphere|2:minimap
254: 	uint8_t unk4;
255: 	uint16_t car_steps_related;
256: 	uint16_t car_steps_related2;
257: 	uint8_t vehicles_instructions_worldmap;
258: 	uint8_t pupu_quest;
259: 	uint8_t obel_quest[8];
260: 	/* [0] => avoir fredonn√© twice|???|Unused|Unused|n ricochets|infini ricochets|Vu ryo|Vu ryo¬≤ ("100x + de ricochets que toi !")
261: 	 * [1] => Ryo a donn√© tablette|Unused|Indices ombre pour trouver l'idiot|Unused|Unused|Unused|Indice ombre pour Eldbeak|Eldbeak trouv√©
262: 	 * [2] => Tr√©sor √Æle Minde|Tr√©sor Plaine de Mordor|Unused|Unused|Unused|Unused|Unused|Unused
263: 	 * [3] => ???|Pierre Balamb|Pierre Ryo|Pierre Timber|Pierre Galbadia|Toutes les pierres|Indice Ombre pour Balamb|???
264: 	 * [4] => ??? (mordor var?)
265: 	 * [5] => ???|???|???|???|Block access Lunatic Pandora|???|Block access Lunatic Pandora|???
266: 	 * [6] => avoir parl√© √† l'ombre|Accepter de chercher l'idiot|Avoir vu l'idiot|...
267: 	 * [7] => ??? (temp var)
268: 	 */
269: 	uint8_t unk5[2];
270: };
271: 
272: struct savemap_ff8_triple_triad {
273: 	uint8_t cards[77];
274: 	uint8_t card_locations[33];
275: 	uint8_t cards_rare[5];
276: 	uint8_t unk1;
277: 	uint16_t victory_count;
278: 	uint16_t defeat_count;
279: 	uint16_t equality_count;
280: 	uint16_t unk2;
281: 	uint32_t unk3;
282: };
283: 
284: struct savemap_ff8_chocobo {
285: 	uint8_t enabled;
286: 	uint8_t level;
287: 	uint8_t current_hp;
288: 	uint8_t max_hp;
289: 	uint16_t weapon;
290: 	uint8_t rank;
291: 	uint8_t move;
292: 	uint32_t save_count;
293: 	uint16_t id_related;
294: 	uint8_t unk1[6];
295: 	uint8_t item_class_a_count;
296: 	uint8_t item_class_b_count;
297: 	uint8_t item_class_c_count;
298: 	uint8_t item_class_d_count;
299: 	uint8_t unk2[16];
300: 	uint32_t associated_save_id;
301: 	uint8_t unk3;
302: 	uint8_t boko_attack;
303: 	uint8_t unk4;
304: 	uint8_t home_walking;
305: 	uint8_t unk5[16];
306: };
307: 
308: // For more info: https://hobbitdur.github.io/FF8ModdingWiki/technical-reference/miscellaneous/game-save-format
309: struct savemap_ff8 {
310: 	uint16_t checksum;
311: 	uint16_t fixed_value; // always 0x8FF
312: 	savemap_ff8_header header;
313: 	savemap_ff8_gf gfs[G_FORCE_NUM];
314: 	savemap_ff8_character chars[CHAR_NUM];
315: 	savemap_ff8_shop shop[20];
316: 	uint8_t config[20];
317: 	uint8_t party[4]; // 0xFF terminated
318: 	uint32_t unlocked_weapons; // bitmap for weapons unlocked
319: 	uint8_t griever_name[12];
320: 	uint16_t unk1;
321: 	uint16_t unk2;
322: 	uint32_t gil;
323: 	uint32_t gil_laguna;
324: 	savemap_ff8_limit_break lb;
325: 	savemap_ff8_items items;
326: 	uint32_t game_time;
327: 	uint32_t countdown;
328: 	savemap_ff8_battle battle;
329: 	uint8_t tutorial_infos[16];
330: 	uint8_t seed_test_lvl;
331: 	uint32_t unk3;
332: 	uint8_t party_other[4];
333: 	uint32_t unk4;
334: 	uint16_t module; // 1=field, 2=worldmap, 3=battle
335: 	uint16_t curr_loc;
336: 	uint16_t prev_loc;
337: 	uint16_t x[3];  // coord x (party1, party2, party3)
338: 	uint16_t y[3];  // coord y (party1, party2, party3)
339: 	uint16_t id[3]; // triangle (party1, party2, party3)
340: 	uint8_t dir[3]; // direction (party1, party2, party3)
341: 	uint8_t unk7[5];
342: 	savemap_ff8_field_h field_header;
343: 	savemap_ff8_field field;
344: 	savemap_ff8_worldmap worldmap;
345: 	savemap_ff8_triple_triad triple_triad;
346: 	savemap_ff8_chocobo choco_world;
347: };
</file>

<file path="src/ff8/texture_packer.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: #include <set>
 23: 
 24: #include "texture_packer.h"
 25: #include "../saveload.h"
 26: #include "../renderer.h"
 27: #include "cfg.h"
 28: #include "log.h"
 29: #include "mod.h"
 30: #include "gl.h"
 31: 
 32: // Scale 32-bit BGRA image
 33: void scale_up_image_data(const uint32_t *source, uint32_t *target, uint32_t w, uint32_t h, uint8_t scale)
 34: {
 35: 	if (scale <= 1)
 36: 	{
 37: 		memcpy(target, source, w * h * sizeof(uint32_t));
 38: 
 39: 		return;
 40: 	}
 41: 
 42: 	for (int y = 0; y < h; ++y)
 43: 	{
 44: 		for (int i = 0; i < scale; ++i)
 45: 		{
 46: 			for (int x = 0; x < w; ++x)
 47: 			{
 48: 				for (int j = 0; j < scale; ++j)
 49: 				{
 50: 					target[j] = source[x];
 51: 				}
 52: 
 53: 				target += scale;
 54: 			}
 55: 		}
 56: 
 57: 		source += w;
 58: 	}
 59: }
 60: 
 61: TexturePacker::TexturePacker() :
 62: 	_vramTextureIds(VRAM_WIDTH * VRAM_HEIGHT, INVALID_TEXTURE)
 63: {
 64: }
 65: 
 66: void TexturePacker::cleanVramTextureIds(const TextureInfos &texture)
 67: {
 68: 	for (int prevY = 0; prevY < texture.h(); ++prevY)
 69: 	{
 70: 		int clearKey = texture.x() + (texture.y() + prevY) * VRAM_WIDTH;
 71: 		std::fill_n(_vramTextureIds.begin() + clearKey, texture.w(), INVALID_TEXTURE);
 72: 	}
 73: }
 74: 
 75: void TexturePacker::cleanTextures(ModdedTextureId previousTextureId, int xBpp2, int y, int wBpp2, int h)
 76: {
 77: 	auto it = _textures.find(previousTextureId);
 78: 
 79: 	if (it == _textures.end())
 80: 	{
 81: 		return;
 82: 	}
 83: 
 84: 	const IdentifiedTexture &identifiedTexture = it->second;
 85: 
 86: 	// Abort clean if the conflict is negligible (fixes Rinoa's battle model d4c009.dat)
 87: 	if (identifiedTexture.texture().w() >= 10) {
 88: 		if (xBpp2 + 1 == identifiedTexture.texture().x() + identifiedTexture.texture().w()) {
 89: 			if (trace_all || trace_vram) ffnx_warning("TexturePacker::%s: texture not cleared because the conflict is negligible %s textureId=0x%X\n", __func__, identifiedTexture.printableName(), previousTextureId);
 90: 
 91: 			return;
 92: 		}
 93: 	}
 94: 	if (identifiedTexture.texture().h() >= 10) {
 95: 		if (y + 1 == identifiedTexture.texture().y() + identifiedTexture.texture().h()) {
 96: 			if (trace_all || trace_vram) ffnx_warning("TexturePacker::%s: texture not cleared because the conflict is negligible %s textureId=0x%X\n", __func__, identifiedTexture.printableName(), previousTextureId);
 97: 
 98: 			return;
 99: 		}
100: 	}
101: 
102: 	if (trace_all || trace_vram) ffnx_info("TexturePacker::%s: clear texture %s textureId=0x%X\n", __func__, identifiedTexture.printableName(), previousTextureId);
103: 
104: 	cleanVramTextureIds(identifiedTexture.texture());
105: 
106: 	if (identifiedTexture.mod() != nullptr)
107: 	{
108: 		delete identifiedTexture.mod();
109: 	}
110: 
111: 	for (const std::pair<ModdedTextureId, const IdentifiedTexture &> &pair: identifiedTexture.redirections())
112: 	{
113: 		if (pair.second.mod() != nullptr)
114: 		{
115: 			delete pair.second.mod();
116: 		}
117: 	}
118: 
119: 	_textures.erase(it);
120: }
121: 
122: void TexturePacker::setVramTextureId(ModdedTextureId textureId, int xBpp2, int y, int wBpp2, int h, bool clearOldTexture)
123: {
124: 	if (trace_all || trace_vram) ffnx_trace("%s: textureId=0x%X xBpp2=%d y=%d wBpp2=%d h=%d clearOldTexture=%d\n", __func__, textureId, xBpp2, y, wBpp2, h, clearOldTexture);
125: 
126: 	for (int i = 0; i < h; ++i)
127: 	{
128: 		int vramY = y + i;
129: 
130: 		for (int j = 0; j < wBpp2; ++j)
131: 		{
132: 			int vramX = xBpp2 + j;
133: 			int key = vramX + vramY * VRAM_WIDTH;
134: 
135: 			if (clearOldTexture)
136: 			{
137: 				ModdedTextureId previousTextureId = _vramTextureIds.at(key);
138: 
139: 				if (previousTextureId != INVALID_TEXTURE)
140: 				{
141: 					cleanTextures(previousTextureId, xBpp2, y, wBpp2, h);
142: 				}
143: 			}
144: 
145: 			_vramTextureIds[key] = textureId;
146: 		}
147: 	}
148: }
149: 
150: bool TexturePacker::setTexture(const char *name, const TextureInfos &texture, const TextureInfos &palette, int textureCount, bool clearOldTexture)
151: {
152: 	bool hasNamedTexture = name != nullptr && *name != '\0';
153: 
154: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s %s xBpp2=%d y=%d wBpp2=%d h=%d bpp=%d xPal=%d yPal=%d wPal=%d hPal=%d textureCount=%d clearOldTexture=%d\n", __func__,
155: 		hasNamedTexture ? name : "N/A",
156: 		texture.x(), texture.y(), texture.w(), texture.h(), texture.bpp(),
157: 		palette.x(), palette.y(), palette.w(), palette.h(), textureCount, clearOldTexture);
158: 
159: 	ModdedTextureId textureId = makeTextureId(texture.x(), texture.y());
160: 	setVramTextureId(textureId, texture.x(), texture.y(), texture.w(), texture.h(), clearOldTexture);
161: 
162: 	if (palette.isValid())
163: 	{
164: 		setVramTextureId(makeTextureId(texture.x(), texture.y(), true), palette.x(), palette.y(), palette.w(), palette.h(), clearOldTexture);
165: 	}
166: 
167: 	IdentifiedTexture tex(name, texture, palette);
168: 
169: 	if (hasNamedTexture && textureCount != 0)
170: 	{
171: 		TextureModStandard *mod = new TextureModStandard(tex);
172: 
173: 		if (mod->createImages(textureCount))
174: 		{
175: 			tex.setMod(mod);
176: 		}
177: 		else
178: 		{
179: 			delete mod;
180: 		}
181: 	}
182: 
183: 	_textures[textureId] = tex;
184: 
185: 	return tex.mod() != nullptr;
186: }
187: 
188: bool TexturePacker::setTextureBackground(const char *name, int x, int y, int w, int h, const std::vector<Tile> &mapTiles, const char *extension, char *found_extension)
189: {
190: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s %s x=%d y=%d w=%d h=%d tileCount=%d\n", __func__, name, x, y, w, h, mapTiles.size());
191: 
192: 	ModdedTextureId textureId = makeTextureId(x, y);
193: 	setVramTextureId(textureId, x, y, w, h);
194: 
195: 	IdentifiedTexture tex(name, TextureInfos(x, y, w, h, Tim::Bpp16, true));
196: 
197: 	TextureBackground *mod = new TextureBackground(tex, mapTiles);
198: 	if (mod->createImages(extension, found_extension))
199: 	{
200: 		tex.setMod(mod);
201: 		// Force texture_reload_hack
202: 		tex.setCurrentAnimationFrame(-1);
203: 	}
204: 	else
205: 	{
206: 		delete mod;
207: 	}
208: 
209: 	_textures[textureId] = tex;
210: 
211: 	return tex.mod() != nullptr;
212: }
213: 
214: bool TexturePacker::setTextureRedirection(const char *name, const TextureInfos &oldTexture, const TextureInfos &newTexture, const Tim &tim)
215: {
216: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s: %s old=(%d, %d, %d, %d) <= new=(%d, %d, %d, %d)\n", __func__, name,
217: 		oldTexture.x(), oldTexture.y(), oldTexture.w(), oldTexture.h(),
218: 		newTexture.x(), newTexture.y(), newTexture.w(), newTexture.h());
219: 
220: 	ModdedTextureId textureId = _vramTextureIds.at(oldTexture.x() + oldTexture.y() * VRAM_WIDTH);
221: 
222: 	if (textureId == INVALID_TEXTURE)
223: 	{
224: 		ffnx_warning("TexturePacker::%s cannot find original texture of redirection\n", __func__);
225: 
226: 		return false;
227: 	}
228: 
229: 	auto it = _textures.find(textureId);
230: 
231: 	if (it == _textures.end())
232: 	{
233: 		ffnx_warning("TexturePacker::%s cannot find original texture of redirection 2\n", __func__);
234: 
235: 		return false;
236: 	}
237: 
238: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s: found %s\n", __func__, it->second.printableName());
239: 
240: 	ModdedTextureId redirectionTextureId = makeTextureId(newTexture.x(), newTexture.y());
241: 	auto it2 = it->second.redirections().find(redirectionTextureId);
242: 	if (it2 != it->second.redirections().end() && it2->second.mod() != nullptr)
243: 	{
244: 		delete it2->second.mod();
245: 	}
246: 	IdentifiedTexture red(name, oldTexture);
247: 	TextureModStandard *mod = new TextureModStandard(red);
248: 	const int scaleLod = newTexture.h() / oldTexture.h(); // Force original texture size to be the one from new texture
249: 
250: 	if (mod->createImages(1, scaleLod))
251: 	{
252: 		// Use external texture
253: 		red.setMod(mod);
254: 	}
255: 	else
256: 	{
257: 		char filename[MAX_PATH];
258: 		if (it->second.mod() != nullptr
259: 			|| ModdedTexture::findExternalTexture("world/dat/wmset/section38/texture0_texture1_16_0_0", filename, 0, false))
260: 		{
261: 			// Disable internal redirection, for perfomance reasons, because it will be overloaded by a mod
262: 			return false;
263: 		}
264: 
265: 		if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s: use internal texture\n", __func__);
266: 
267: 		delete mod;
268: 
269: 		uint32_t *imageData = (uint32_t*)driver_malloc(newTexture.pixelW() * newTexture.h() * 4);
270: 
271: 		if (!imageData)
272: 		{
273: 			return false;
274: 		}
275: 
276: 		if (!tim.toRGBA32MultiPaletteGrid(imageData, 4, 4, 0, 4, true))
277: 		{
278: 			driver_free(imageData);
279: 
280: 			return false;
281: 		}
282: 
283: 		// Use internal texture
284: 		red.setMod(new TextureRawImage(red, imageData, newTexture.pixelW(), newTexture.h()));
285: 	}
286: 
287: 	_textures[textureId].setRedirection(redirectionTextureId, red);
288: 
289: 	return red.mod() != nullptr;
290: }
291: 
292: void TexturePacker::animateTextureByCopy(int sourceXBpp2, int sourceY, int sourceWBpp2, int sourceH, int targetXBpp2, int targetY)
293: {
294: 	if (_textures.empty())
295: 	{
296: 		return;
297: 	}
298: 
299: 	ModdedTextureId textureId = _vramTextureIds.at(sourceXBpp2 + sourceY * VRAM_WIDTH),
300: 		textureIdTarget = _vramTextureIds.at(targetXBpp2 + targetY * VRAM_WIDTH);
301: 	if (textureId == INVALID_TEXTURE)
302: 	{
303: 		if (trace_all || trace_vram) ffnx_warning("TexturePacker::%s pos=(%d, %d) source not found\n", __func__, sourceXBpp2, sourceY);
304: 
305: 		return;
306: 	}
307: 
308: 	bool inPalette = textureIdIspalette(textureId) && textureIdIspalette(textureIdTarget);
309: 
310: 	if (inPalette)
311: 	{
312: 		textureId = getTextureIdWithoutFlags(textureId);
313: 		textureIdTarget = getTextureIdWithoutFlags(textureIdTarget);
314: 	}
315: 
316: 	auto it = _textures.find(textureId);
317: 
318: 	if (it == _textures.end())
319: 	{
320: 		return;
321: 	}
322: 
323: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s matches %s inPalette=%d\n", __func__, it->second.printableName(), inPalette);
324: 
325: 	it->second.setCurrentAnimationFrame(sourceXBpp2, sourceY, sourceWBpp2, sourceH);
326: 
327: 	if (textureId != textureIdTarget)
328: 	{
329: 		if (textureIdTarget == INVALID_TEXTURE)
330: 		{
331: 			return;
332: 		}
333: 
334: 		auto itTarget = _textures.find(textureIdTarget);
335: 
336: 		if (itTarget == _textures.end())
337: 		{
338: 			return;
339: 		}
340: 
341: 		if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s also matches %s for target\n", __func__, itTarget->second.printableName());
342: 
343: 		itTarget->second.setCurrentAnimationFrame(sourceXBpp2, sourceY, sourceWBpp2, sourceH);
344: 
345: 		if (itTarget->second.mod() != nullptr)
346: 		{
347: 			if (inPalette)
348: 			{
349: 				dynamic_cast<TextureModStandard *>(itTarget->second.mod())->forceCurrentPalette(sourceY - it->second.palette().y());
350: 			}
351: 			else if (it->second.mod() != nullptr && it->second.mod()->canCopyRect())
352: 			{
353: 				dynamic_cast<TextureModStandard *>(it->second.mod())->copyRect(
354: 					sourceXBpp2, sourceY, sourceWBpp2, sourceH, targetXBpp2, targetY,
355: 					*dynamic_cast<TextureModStandard *>(itTarget->second.mod())
356: 				);
357: 			}
358: 		}
359: 	}
360: 	else if (it->second.mod() != nullptr && it->second.mod()->canCopyRect())
361: 	{
362: 		if (inPalette)
363: 		{
364: 			dynamic_cast<TextureModStandard *>(it->second.mod())->forceCurrentPalette(sourceY - it->second.palette().y());
365: 		}
366: 		else
367: 		{
368: 			dynamic_cast<TextureModStandard *>(it->second.mod())->copyRect(
369: 				sourceXBpp2, sourceY, sourceWBpp2, sourceH, targetXBpp2, targetY
370: 			);
371: 		}
372: 	}
373: }
374: 
375: void TexturePacker::setCurrentAnimationFrame(int xBpp2, int y, int8_t frameId)
376: {
377: 	ModdedTextureId textureId = _vramTextureIds.at(xBpp2 + y * VRAM_WIDTH);
378: 	if (textureId == INVALID_TEXTURE)
379: 	{
380: 		return;
381: 	}
382: 
383: 	auto it = _textures.find(textureId);
384: 
385: 	if (it == _textures.end())
386: 	{
387: 		return;
388: 	}
389: 
390: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s matches %s\n", __func__, it->second.printableName());
391: 
392: 	it->second.setCurrentAnimationFrame(frameId);
393: 
394: 	if (it->second.mod() != nullptr && it->second.mod()->canCopyRect())
395: 	{
396: 		dynamic_cast<TextureModStandard *>(it->second.mod())->forceCurrentPalette(frameId);
397: 	}
398: }
399: 
400: void TexturePacker::clearTiledTexs()
401: {
402: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s\n", __func__);
403: 
404: 	_tiledTexs.clear();
405: }
406: 
407: void TexturePacker::clearTextures()
408: {
409: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s\n", __func__);
410: 
411: 	std::fill_n(_vramTextureIds.begin(), _vramTextureIds.size(), INVALID_TEXTURE);
412: 
413: 	for (const std::pair<ModdedTextureId, const IdentifiedTexture &> &texture: _textures) {
414: 		if (texture.second.mod() != nullptr) {
415: 			delete texture.second.mod();
416: 		}
417: 	}
418: 	_textures.clear();
419: }
420: 
421: std::list<TexturePacker::IdentifiedTexture> TexturePacker::matchTextures(const TiledTex &tiledTex, bool withModsOnly, bool withAnimatedOnly) const
422: {
423: 	std::list<IdentifiedTexture> ret;
424: 
425: 	if (_textures.empty())
426: 	{
427: 		return ret;
428: 	}
429: 
430: 	if (!tiledTex.isValid()) {
431: 		if (trace_all || trace_vram) ffnx_warning("TexturePacker::%s Unknown tex data\n", __func__);
432: 
433: 		return ret;
434: 	}
435: 
436: 	std::set<ModdedTextureId> textureIds;
437: 
438: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s looking for %s textures at (%d, %d, %d, %d, bpp=%d) in VRAM\n", __func__, withModsOnly ? "modded" : (withAnimatedOnly ? "animated" : "all"), tiledTex.x(), tiledTex.y(), tiledTex.w(), tiledTex.h(), tiledTex.bpp());
439: 
440: 	for (int y = 0; y < tiledTex.h(); ++y)
441: 	{
442: 		int vramY = tiledTex.y() + y;
443: 
444: 		if (vramY >= VRAM_HEIGHT)
445: 		{
446: 			break;
447: 		}
448: 
449: 		for (int x = 0; x < tiledTex.w(); ++x)
450: 		{
451: 			int vramX = tiledTex.x() + x;
452: 
453: 			if (vramX >= VRAM_WIDTH)
454: 			{
455: 				break;
456: 			}
457: 
458: 			ModdedTextureId textureId = _vramTextureIds.at(vramX + vramY * VRAM_WIDTH);
459: 
460: 			if (textureId != INVALID_TEXTURE && !textureIdIspalette(textureId))
461: 			{
462: 				textureIds.insert(textureId);
463: 			}
464: 		}
465: 	}
466: 
467: 	for (const ModdedTextureId &textureId: textureIds)
468: 	{
469: 		auto it = _textures.find(textureId);
470: 
471: 		if (it == _textures.end())
472: 		{
473: 			if (trace_all || trace_vram) ffnx_warning("TexturePacker::%s texture with textureId=0x%X not found!\n", __func__, textureId);
474: 
475: 			continue;
476: 		}
477: 
478: 		const IdentifiedTexture &texture = it->second;
479: 
480: 		if (withModsOnly)
481: 		{
482: 			const ModdedTexture *mod = texture.mod();
483: 			bool hasModToDraw = mod != nullptr && mod->isBpp(tiledTex.bpp());
484: 
485: 			if (!hasModToDraw)
486: 			{
487: 				for (const std::pair<ModdedTextureId, const IdentifiedTexture &> &pair: texture.redirections())
488: 				{
489: 					const ModdedTexture *redirectionMod = pair.second.mod();
490: 					if (redirectionMod != nullptr && redirectionMod->isBpp(tiledTex.bpp()))
491: 					{
492: 						hasModToDraw = true;
493: 						break;
494: 					}
495: 				}
496: 
497: 				if (!hasModToDraw)
498: 				{
499: 					if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s ignore matches %s because not modded rect=(%d, %d, %d, %d) bpp=%d (tiledTexBpp=%d)\n", __func__, texture.printableName(), texture.texture().x(), texture.texture().y(), texture.texture().w(), texture.texture().h(), texture.texture().bpp(), tiledTex.bpp());
500: 
501: 					continue;
502: 				}
503: 			}
504: 		}
505: 		else if (!texture.texture().hasMultiBpp() && texture.texture().bpp() != tiledTex.bpp())
506: 		{
507: 			if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s ignore matches %s because not right bpp rect=(%d, %d, %d, %d) bpp=%d (tiledTexBpp=%d)\n", __func__, texture.printableName(), texture.texture().x(), texture.texture().y(), texture.texture().w(), texture.texture().h(), texture.texture().bpp(), tiledTex.bpp());
508: 
509: 			continue;
510: 		}
511: 
512: 		if (withAnimatedOnly && !texture.isAnimated())
513: 		{
514: 			if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s ignore matches %s because not animated rect=(%d, %d, %d, %d) bpp=%d (tiledTexBpp=%d)\n", __func__, texture.printableName(), texture.texture().x(), texture.texture().y(), texture.texture().w(), texture.texture().h(), texture.texture().bpp(), tiledTex.bpp());
515: 
516: 			continue;
517: 		}
518: 
519: 		if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s matches %s rect=(%d, %d, %d, %d)\n", __func__, texture.printableName(), texture.texture().x(), texture.texture().y(), texture.texture().w(), texture.texture().h());
520: 
521: 		ret.push_back(texture);
522: 	}
523: 
524: 	return ret;
525: }
526: 
527: uint32_t TexturePacker::composeTextures(
528: 	const uint8_t *texData, uint32_t *rgbaImageData, int originalW, int originalH,
529: 	int palIndex, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set, bool *isExternal) const
530: {
531: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s texData=0x%X originalSize=(%d, %d) palIndex=%d\n", __func__, texData, originalW, originalH, palIndex);
532: 
533: 	*isExternal = true;
534: 
535: 	if (_textures.empty())
536: 	{
537: 		if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s No textures to draw\n", __func__);
538: 
539: 		return 0;
540: 	}
541: 
542: 	auto it = _tiledTexs.find(texData);
543: 
544: 	if (it == _tiledTexs.end())
545: 	{
546: 		if (trace_all || trace_vram) ffnx_error("TexturePacker::%s Unknown tiledTex data\n", __func__);
547: 
548: 		return 0;
549: 	}
550: 
551: 	const TiledTex &tiledTex = it->second;
552: 
553: 	if (!tiledTex.isValid())
554: 	{
555: 		if (trace_all || trace_vram) ffnx_error("TexturePacker::%s Invalid tiledTex data\n", __func__);
556: 
557: 		return 0;
558: 	}
559: 
560: 	if (!tiledTex.isPaletteValid(palIndex))
561: 	{
562: 		if (trace_all || trace_vram) ffnx_warning("TexturePacker::%s Palette is not set yet, we should not consider this texture\n", __func__);
563: 
564: 		return 0;
565: 	}
566: 
567: 	std::list<IdentifiedTexture> textures = matchTextures(tiledTex, true);
568: 
569: 	if (textures.empty())
570: 	{
571: 		if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s No matched textures at (%d, %d)\n", __func__, tiledTex.x(), tiledTex.y());
572: 
573: 		return 0;
574: 	}
575: 
576: 	TextureInfos palette = tiledTex.palette(palIndex);
577: 	uint8_t scale = 0;
578: 
579: 	for (const IdentifiedTexture &tex: textures)
580: 	{
581: 		for (const std::pair<ModdedTextureId, const IdentifiedTexture &> &pair: tex.redirections())
582: 		{
583: 			if (pair.second.mod() != nullptr)
584: 			{
585: 				scale = std::max(scale, pair.second.mod()->scale(palette.x(), palette.y()));
586: 			}
587: 		}
588: 
589: 		if (tex.mod() != nullptr)
590: 		{
591: 			scale = std::max(scale, tex.mod()->scale(palette.x(), palette.y()));
592: 		}
593: 	}
594: 
595: 	if (scale == 0)
596: 	{
597: 		return 0;
598: 	}
599: 
600: 	uint32_t *target = rgbaImageData;
601: 
602: 	if (scale > 1)
603: 	{
604: 		target = (uint32_t *)driver_malloc(originalW * scale * originalH * scale * 4);
605: 
606: 		// Retry with lower resolution
607: 		while (target == nullptr && scale > 1)
608: 		{
609: 			scale -= 1;
610: 			ffnx_warning("%s: Not enough memory, retry with scale=%d\n", __func__, scale);
611: 			target = (uint32_t *)driver_malloc(originalW * scale * originalH * scale * 4);
612: 		}
613: 
614: 		if (target == nullptr)
615: 		{
616: 			return 0;
617: 		}
618: 
619: 		if (scale > 1)
620: 		{
621: 			// convert source data
622: 			scale_up_image_data(rgbaImageData, target, originalW, originalH, scale);
623: 		}
624: 	}
625: 
626: 	TextureTypes textureType = drawTextures(textures, tiledTex, palette, target, originalW, originalH, scale);
627: 
628: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s tex=(%d, %d) bpp=%d paletteVram=(%d, %d) drawnTextureTypes=0x%X scale=%d\n", __func__, tiledTex.x(), tiledTex.y(), tiledTex.bpp(), palette.x(), palette.y(), textureType, scale);
629: 
630: 	if (textureType == TexturePacker::InternalTexture || (!save_textures && textureType == TexturePacker::ExternalTexture))
631: 	{
632: 		*isExternal = textureType == TexturePacker::ExternalTexture;
633: 		*width = originalW * scale;
634: 		*height = originalH * scale;
635: 		// Data is passed to bgfx, not need to free it here
636: 		bool copyData = target == rgbaImageData;
637: 		return newRenderer.createTexture(reinterpret_cast<uint8_t *>(target), *width, *height, 0, RendererTextureType::BGRA, true, copyData);
638: 	}
639: 
640: 	if (target != nullptr && target != rgbaImageData)
641: 	{
642: 		driver_free(target);
643: 	}
644: 
645: 	return 0;
646: }
647: 
648: TexturePacker::TextureTypes TexturePacker::drawTextures(const std::list<IdentifiedTexture> &textures, const TiledTex &tiledTex, const TextureInfos &palette, uint32_t *target, int targetW, int targetH, uint8_t scale) const
649: {
650: 	TextureTypes drawnTextureTypes = NoTexture;
651: 	int x = tiledTex.pixelX(), y = tiledTex.y();
652: 
653: 	for (const IdentifiedTexture &texture: textures)
654: 	{
655: 		for (const std::pair<ModdedTextureId, const IdentifiedTexture &> &pair: texture.redirections())
656: 		{
657: 			if (pair.second.mod() != nullptr && pair.second.mod()->isInternal())
658: 			{
659: 				TextureTypes textureType = pair.second.mod()->drawToImage(
660: 					pair.second.texture().pixelX() - x, pair.second.texture().y() - y,
661: 					target, targetW, targetH, scale, tiledTex.bpp(),
662: 					palette.x(), palette.y()
663: 				);
664: 
665: 				drawnTextureTypes = TextureTypes(int(drawnTextureTypes) | int(textureType));
666: 			}
667: 		}
668: 
669: 		if (texture.mod() != nullptr)
670: 		{
671: 			TextureTypes textureType = texture.mod()->drawToImage(
672: 				texture.texture().pixelX() - x, texture.texture().y() - y,
673: 				target, targetW, targetH, scale, tiledTex.bpp(),
674: 				palette.x(), palette.y()
675: 			);
676: 
677: 			drawnTextureTypes = TextureTypes(int(drawnTextureTypes) | int(textureType));
678: 		}
679: 
680: 		for (const std::pair<ModdedTextureId, const IdentifiedTexture &> &pair: texture.redirections())
681: 		{
682: 			if (pair.second.mod() != nullptr && !pair.second.mod()->isInternal())
683: 			{
684: 				TextureTypes textureType = pair.second.mod()->drawToImage(
685: 					pair.second.texture().pixelX() - x, pair.second.texture().y() - y,
686: 					target, targetW, targetH, scale, tiledTex.bpp(),
687: 					palette.x(), palette.y()
688: 				);
689: 
690: 				drawnTextureTypes = TextureTypes(int(drawnTextureTypes) | int(textureType));
691: 			}
692: 		}
693: 	}
694: 
695: 	return drawnTextureTypes;
696: }
697: 
698: const TexturePacker::TiledTex &TexturePacker::registerTiledTex(const uint8_t *texData, int xBpp2, int y, int pixelW, int h, Tim::Bpp sourceBpp, int palX, int palY)
699: {
700: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s pointer=0x%X xBpp2=%d y=%d pixelW=%d h=%d sourceBpp=%d palX=%d palY=%d\n", __func__, texData, xBpp2, y, pixelW, h, sourceBpp, palX, palY);
701: 
702: 	// If this entry already exist, override
703: 	_tiledTexs[texData] = TiledTex(xBpp2, y, pixelW, h, sourceBpp, palX, palY);
704: 
705: 	return _tiledTexs[texData];
706: }
707: 
708: void TexturePacker::registerPaletteWrite(const uint8_t *texData, int palIndex, int palX, int palY)
709: {
710: 	if (trace_all || trace_vram) ffnx_trace("TexturePacker::%s pointer=0x%X palIndex=%d palX=%d palY=%d\n", __func__, texData, palIndex, palX, palY);
711: 
712: 	if (_tiledTexs.contains(texData))
713: 	{
714: 		TiledTex &tex = _tiledTexs[texData];
715: 		tex.palettes[palIndex] = TextureInfos(palX, palY, 256, 1, Tim::Bpp16);
716: 	}
717: 	else
718: 	{
719: 		if (trace_all || trace_vram) ffnx_warning("TexturePacker::%s pointer=0x%X register palette before image\n", __func__, texData);
720: 
721: 		_tiledTexs[texData] = TiledTex(-1, -1, -1, -1, Tim::Bpp4, palX, palY);
722: 	}
723: }
724: 
725: TexturePacker::TiledTex TexturePacker::getTiledTex(const uint8_t *texData) const
726: {
727: 	auto it = _tiledTexs.find(texData);
728: 
729: 	if (it != _tiledTexs.end())
730: 	{
731: 		return it->second;
732: 	}
733: 
734: 	return TiledTex();
735: }
736: 
737: void TexturePacker::debugSaveTexture(int textureId, const uint32_t *source, int w, int h, bool removeAlpha, bool after, TextureTypes textureType)
738: {
739: 	uint32_t *target = new uint32_t[w * h];
740: 
741: 	for (int i = 0; i < h * w; ++i)
742: 	{
743: 		target[i] = removeAlpha ? source[i] | 0xff000000 : source[i]; // Remove alpha
744: 	}
745: 
746: 	char filename[MAX_PATH];
747: 	snprintf(filename, sizeof(filename), "texture-%d-%s-type-%s", textureId, after ? "z-after" : "a-before", textureType == TextureTypes::ExternalTexture ? "external" : (textureType == TextureTypes::InternalTexture ? "internal" : "nomatch"));
748: 
749: 	if (trace_all || trace_vram) ffnx_trace("%s %s\n", __func__, filename);
750: 
751: 	save_texture(target, w * h * 4, w, h, -1, filename, false);
752: 
753: 	delete[] target;
754: }
755: 
756: TexturePacker::TextureInfos::TextureInfos() :
757: 	_x(-1), _y(0), _w(0), _h(0), _bpp(Tim::Bpp4)
758: {
759: }
760: 
761: TexturePacker::TextureInfos::TextureInfos(
762: 	int xBpp2, int y, int wBpp2, int h,
763: 	Tim::Bpp bpp, bool multiBpp
764: ) : _x(xBpp2), _y(y), _w(wBpp2), _h(h), _bpp(bpp), _multiBpp(multiBpp)
765: {
766: }
767: 
768: int TexturePacker::TextureInfos::vramId() const
769: {
770: 	return x() / TEXTURE_WIDTH_BPP16 + (y() >= TEXTURE_HEIGHT ? 16 : 0);
771: }
772: 
773: TexturePacker::TiledTex::TiledTex()
774:  : TextureInfos()
775: {
776: }
777: 
778: TexturePacker::TiledTex::TiledTex(
779: 	int xBpp2, int y, int pixelW, int h, Tim::Bpp sourceBpp, int palVramX, int palVramY
780: ) : TextureInfos(xBpp2, y, pixelW / (4 >> sourceBpp), h, sourceBpp)
781: {
782: 	if (palVramX >= 0) {
783: 		palettes[0] = TextureInfos(palVramX, palVramY, 256, 1, Tim::Bpp16);
784: 	}
785: }
786: 
787: TexturePacker::IdentifiedTexture::IdentifiedTexture() :
788: 	_texture(TextureInfos()), _palette(TextureInfos()), _name(""), _mod(nullptr),
789: 	_frameId(-1), _isAnimated(false)
790: {
791: }
792: 
793: TexturePacker::IdentifiedTexture::IdentifiedTexture(
794: 	const char *name,
795: 	const TextureInfos &texture,
796: 	const TextureInfos &palette
797: ) : _texture(texture), _palette(palette), _name(name == nullptr ? "" : name), _mod(nullptr),
798:     _frameId(-1), _isAnimated(false)
799: {
800: }
801: 
802: void TexturePacker::IdentifiedTexture::setMod(ModdedTexture *mod)
803: {
804: 	if (_mod != nullptr)
805: 	{
806: 		delete _mod;
807: 	}
808: 
809: 	_mod = mod;
810: }
811: 
812: void TexturePacker::IdentifiedTexture::setRedirection(ModdedTextureId textureId, const IdentifiedTexture &redirection)
813: {
814: 	_redirections[textureId] = redirection;
815: }
816: 
817: void TexturePacker::IdentifiedTexture::setCurrentAnimationFrame(int frameId)
818: {
819: 	_frameId = frameId;
820: 	_isAnimated = true;
821: }
822: 
823: void TexturePacker::IdentifiedTexture::setCurrentAnimationFrame(int xBpp2, int y, int wBpp2, int h)
824: {
825: 	uint64_t key = uint64_t(xBpp2 + y * VRAM_WIDTH) | (uint64_t(wBpp2 + h * VRAM_WIDTH) << 32);
826: 	_isAnimated = true;
827: 	auto it = std::find(_frames.begin(), _frames.end(), key);
828: 	if (it == _frames.end())
829: 	{
830: 		_frameId = _frames.size();
831: 		_frames.push_back(key);
832: 	}
833: 	else
834: 	{
835: 		_frameId = std::distance(_frames.begin(), it);
836: 	}
837: }
</file>

<file path="src/ff8/texture_packer.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <string>
 26: #include <unordered_map>
 27: #include <list>
 28: #include <vector>
 29: #include <map>
 30: 
 31: #include "../ff8.h"
 32: #include "../image/tim.h"
 33: #include "field/background.h"
 34: 
 35: typedef uint32_t ModdedTextureId;
 36: 
 37: constexpr int VRAM_WIDTH = 1024;
 38: constexpr int VRAM_HEIGHT = 512;
 39: constexpr int VRAM_DEPTH = 2;
 40: constexpr ModdedTextureId INVALID_TEXTURE = ModdedTextureId(0xFFFFFFFF);
 41: constexpr int MAX_SCALE = 128;
 42: constexpr int FF8_BASE_RESOLUTION_X = 320;
 43: 
 44: class ModdedTexture;
 45: 
 46: class TexturePacker {
 47: public:
 48: 	class TextureInfos {
 49: 	public:
 50: 		TextureInfos();
 51: 		TextureInfos(
 52: 			int x, int y, int w, int h,
 53: 			Tim::Bpp bpp, bool multiBpp = false
 54: 		);
 55: 		inline bool isValid() const {
 56: 			return _x >= 0;
 57: 		}
 58: 		inline int x() const {
 59: 			return _x;
 60: 		}
 61: 		inline int pixelX() const {
 62: 			return _x * (4 >> int(_bpp));
 63: 		}
 64: 		inline int y() const {
 65: 			return _y;
 66: 		}
 67: 		inline int w() const {
 68: 			return _w;
 69: 		}
 70: 		inline int pixelW() const {
 71: 			return _w * (4 >> int(_bpp));
 72: 		}
 73: 		inline int h() const {
 74: 			return _h;
 75: 		}
 76: 		inline Tim::Bpp bpp() const {
 77: 			return _bpp;
 78: 		}
 79: 		inline bool hasMultiBpp() const {
 80: 			return _multiBpp;
 81: 		}
 82: 		int vramId() const;
 83: 	private:
 84: 		int _x, _y;
 85: 		int _w, _h;
 86: 		Tim::Bpp _bpp;
 87: 		bool _multiBpp;
 88: 	};
 89: 
 90: 	struct TiledTex : public TextureInfos {
 91: 		TiledTex();
 92: 		TiledTex(int x, int y, int w, int h, Tim::Bpp bpp, int palVramX = -1, int palVramY = -1);
 93: 		inline bool isPaletteValid(int palIndex) const {
 94: 			return bpp() == Tim::Bpp16 || (palettes.contains(palIndex) && palettes.at(palIndex).isValid());
 95: 		}
 96: 		inline TextureInfos palette(int palIndex) const {
 97: 			return bpp() == Tim::Bpp16 || !palettes.contains(palIndex) ? TextureInfos() : palettes.at(palIndex);
 98: 		}
 99: 		std::map<uint8_t, TextureInfos> palettes;
100: 	};
101: 
102: 	class IdentifiedTexture {
103: 	public:
104: 		IdentifiedTexture();
105: 		IdentifiedTexture(
106: 			const char *name,
107: 			const TextureInfos &texture,
108: 			const TextureInfos &palette = TextureInfos()
109: 		);
110: 		void setMod(ModdedTexture *mod);
111: 		inline ModdedTexture *mod() const {
112: 			return _mod;
113: 		}
114: 		void setRedirection(ModdedTextureId textureId, const IdentifiedTexture &redirection);
115: 		const std::unordered_map<ModdedTextureId, IdentifiedTexture> &redirections() const {
116: 			return _redirections;
117: 		}
118: 		inline const TextureInfos &texture() const {
119: 			return _texture;
120: 		}
121: 		inline const TextureInfos &palette() const {
122: 			return _palette;
123: 		}
124: 		inline const std::string &name() const {
125: 			return _name;
126: 		}
127: 		inline const char *printableName() const {
128: 			return _name.empty() ? "N/A" : _name.c_str();
129: 		}
130: 		inline bool isValid() const {
131: 			return !_name.empty();
132: 		}
133: 		inline bool isAnimated() const {
134: 			return _isAnimated;
135: 		}
136: 		void setCurrentAnimationFrame(int frameId);
137: 		void setCurrentAnimationFrame(int xBpp2, int y, int wBpp2, int h);
138: 		inline int currentAnimationFrame() const {
139: 			return _frameId;
140: 		}
141: 	private:
142: 		TextureInfos _texture, _palette;
143: 		std::string _name;
144: 		ModdedTexture *_mod;
145: 		std::unordered_map<ModdedTextureId, IdentifiedTexture> _redirections;
146: 		int _frameId;
147: 		std::vector<uint64_t> _frames;
148: 		bool _isAnimated;
149: 	};
150: 
151: 	enum TextureTypes {
152: 		NoTexture = 0,
153: 		ExternalTexture = 1,
154: 		InternalTexture = 2
155: 	};
156: 
157: 	explicit TexturePacker();
158: 	bool setTexture(const char *name, const TextureInfos &texture, const TextureInfos &palette = TextureInfos(), int textureCount = -1, bool clearOldTexture = true);
159: 	bool setTextureBackground(const char *name, int x, int y, int w, int h, const std::vector<Tile> &mapTiles, const char *extension = nullptr, char *found_extension = nullptr);
160: 	// Override a part of the VRAM from another part of the VRAM, typically with biggest textures (Worldmap)
161: 	bool setTextureRedirection(const char *name, const TextureInfos &oldTexture, const TextureInfos &newTexture, const Tim &tim);
162: 	void animateTextureByCopy(int sourceXBpp2, int y, int sourceWBpp2, int sourceH, int targetXBpp2, int targetY);
163: 	void setCurrentAnimationFrame(int xBpp2, int y, int8_t frameId);
164: 	void clearTiledTexs();
165: 	void clearTextures();
166: 	// Returns the textures matching the tiledTex
167: 	std::list<IdentifiedTexture> matchTextures(const TiledTex &tiledTex, bool withModsOnly = false, bool withAnimatedOnly = false) const;
168: 	const TiledTex &registerTiledTex(const uint8_t *texData, int xBpp2, int y, int pixelW, int h, Tim::Bpp sourceBpp, int palX = -1, int palY = -1);
169: 	void registerPaletteWrite(const uint8_t *texData, int palIndex, int palX, int palY);
170: 	TiledTex getTiledTex(const uint8_t *texData) const;
171: 
172: 	uint32_t composeTextures(
173: 		const uint8_t *texData, uint32_t *rgbaImageData, int originalW, int originalH,
174: 		int palIndex, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set, bool *isExternal
175: 	) const;
176: 
177: 	static void debugSaveTexture(int textureId, const uint32_t *source, int w, int h, bool removeAlpha = true, bool after = false, TextureTypes textureType = NoTexture);
178: private:
179: 	inline static ModdedTextureId makeTextureId(int xBpp2, int y, bool isPal = false) {
180: 		return (xBpp2 + y * VRAM_WIDTH) | (isPal << 31);
181: 	}
182: 	inline static bool textureIdIspalette(ModdedTextureId textureId) {
183: 		return (textureId & 0x80000000) != 0;
184: 	}
185: 	inline static ModdedTextureId getTextureIdWithoutFlags(ModdedTextureId textureId) {
186: 		return textureId & 0x7FFFFFFF;
187: 	}
188: 	inline static int getWidthFromTextureId(ModdedTextureId textureId) {
189: 		return getTextureIdWithoutFlags(textureId) % VRAM_WIDTH;
190: 	}
191: 	inline static int getHeightFromTextureId(ModdedTextureId textureId) {
192: 		return getTextureIdWithoutFlags(textureId) / VRAM_WIDTH;
193: 	}
194: 
195: 	void setVramTextureId(ModdedTextureId textureId, int x, int y, int w, int h, bool clearOldTexture = true);
196: 	uint8_t getMaxScale(const TiledTex &tiledTex) const;
197: 	TextureTypes drawTextures(const std::list<IdentifiedTexture> &textures, const TiledTex &tiledTex, const TextureInfos &palette, uint32_t *target, int w, int h, uint8_t scale) const;
198: 	void cleanVramTextureIds(const TextureInfos &texture);
199: 	void cleanTextures(ModdedTextureId textureId, int xBpp2, int y, int wBpp2, int h);
200: 
201: 	// Link between texture data pointer sent to the graphic driver and VRAM coordinates
202: 	std::unordered_map<const uint8_t *, TiledTex> _tiledTexs;
203: 	// Keep track of where textures are uploaded to the VRAM
204: 	std::vector<ModdedTextureId> _vramTextureIds; // ModdedTextureId[VRAM_WIDTH * VRAM_HEIGHT]
205: 	// List of uploaded textures to the VRAM
206: 	std::unordered_map<ModdedTextureId, IdentifiedTexture> _textures;
207: };
</file>

<file path="src/ff8/uv_patch.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <stdint.h>
 24: 
 25: #include "../globals.h"
 26: #include "../patch.h"
 27: #include "../log.h"
 28: 
 29: #include "uv_patch.h"
 30: 
 31: struct TexCoord {
 32: 	uint8_t x, y;
 33: };
 34: 
 35: struct MapBlockPolygon
 36: {
 37: 	uint8_t vi[3];
 38: 	uint8_t ni[3];
 39: 	TexCoord pos[3];
 40: 	uint8_t texi, groundType;
 41: 	uint16_t flags;
 42: };
 43: 
 44: struct SsigpuExecutionInstruction {
 45: 	uint32_t field_0;
 46: 	uint8_t r, g, b, func_id;
 47: 	uint32_t vertex_a;
 48: 	TexCoord tex_coord_a;
 49: 	uint16_t tex_pos_x6_y9;
 50: 	uint32_t field_10;
 51: 	uint32_t vertex_b;
 52: 	TexCoord tex_coord_b;
 53: 	uint16_t tex_header;
 54: 	uint32_t field_1C;
 55: 	uint32_t vertex_c;
 56: 	TexCoord tex_coord_c;
 57: 	uint16_t field_26;
 58: };
 59: 
 60: int current_polygon = -1;
 61: void *current_polygon_condition_old = nullptr;
 62: bool old_dword_2045C90_value = false;
 63: uint8_t *current_block_data_start = nullptr;
 64: float *maybe_hundred_bak = nullptr;
 65: float psx_floats512[512] = {};
 66: 
 67: void worldmap_fog_filter_polygons_in_block_leave()
 68: {
 69: 	*(bool *)ff8_externals.worldmap_has_polygon_condition_2045C90 = old_dword_2045C90_value;
 70: 	*(void **)ff8_externals.worldmap_polygon_condition_2045C8C = current_polygon_condition_old;
 71: }
 72: 
 73: void worldmap_fog_filter_polygons_in_block_1(uint8_t *block, int a2, void *out)
 74: {
 75: 	current_block_data_start = block;
 76: 
 77: 	((void(*)(uint8_t*,int,void*))ff8_externals.worldmap_fog_filter_polygons_in_block_1)(block, a2, out);
 78: 
 79: 	worldmap_fog_filter_polygons_in_block_leave();
 80: }
 81: 
 82: void worldmap_fog_filter_polygons_in_block_2(uint8_t *block, int a2, void *out)
 83: {
 84: 	current_block_data_start = block;
 85: 
 86: 	((void(*)(uint8_t*,int,void*))ff8_externals.worldmap_fog_filter_polygons_in_block_2)(block, a2, out);
 87: 
 88: 	worldmap_fog_filter_polygons_in_block_leave();
 89: }
 90: 
 91: bool current_polygon_condition(int polygon_id)
 92: {
 93: 	current_polygon = polygon_id;
 94: 
 95: 	if (!old_dword_2045C90_value) {
 96: 		return true;
 97: 	}
 98: 
 99: 	return ((bool(*)(int))current_polygon_condition_old)(polygon_id);
100: }
101: 
102: void sub_45DF20(int a1, int a2, int a3)
103: {
104: 	void **current_polygon_condition_dword_2045964 = (void **)ff8_externals.worldmap_polygon_condition_2045C8C;
105: 
106: 	old_dword_2045C90_value = *(bool *)ff8_externals.worldmap_has_polygon_condition_2045C90;
107: 
108: 	if (!old_dword_2045C90_value) {
109: 		*(bool *)ff8_externals.worldmap_has_polygon_condition_2045C90 = true;
110: 		current_polygon_condition_old = *current_polygon_condition_dword_2045964;
111: 		*current_polygon_condition_dword_2045964 = current_polygon_condition;
112: 	}
113: 
114: 	((void(*)(int,int,int))ff8_externals.worldmap_sub_45DF20)(a1, a2, a3);
115: }
116: 
117: void enrich_tex_coords_sub_45E3A0(SsigpuExecutionInstruction *a1)
118: {
119: 	MapBlockPolygon *polygon = (MapBlockPolygon *)(current_block_data_start + 4 + current_polygon * sizeof(MapBlockPolygon));
120: 	// Save the last bit of texture coordinates in field_26
121: 	a1->field_26 = ((polygon->pos[0].x & 1) << 0) | ((polygon->pos[0].y & 1) << 1)
122: 		| ((polygon->pos[1].x & 1) << 2) | ((polygon->pos[1].y & 1) << 3)
123: 		| ((polygon->pos[2].x & 1) << 4) | ((polygon->pos[2].y & 1) << 5);
124: 
125: 	((void(*)(SsigpuExecutionInstruction*))ff8_externals.sub_45E3A0)(a1);
126: }
127: 
128: void ssigpu_callback_sub_461E00(SsigpuExecutionInstruction *a1)
129: {
130: 	uint8_t lost_bits = a1->field_26;
131: 
132: 	((void(*)(SsigpuExecutionInstruction*))ff8_externals.sub_461E00)(a1);
133: 
134: 	if (!(*(int *)ff8_externals.dword_1CA8848) && maybe_hundred_bak != nullptr) {
135: 		maybe_hundred_bak[6] = psx_floats512[uint32_t(a1->tex_coord_a.x) * 2 + ((lost_bits >> 0) & 1)];
136: 		maybe_hundred_bak[7] = psx_floats512[uint32_t(a1->tex_coord_a.y) * 2 + ((lost_bits >> 1) & 1)];
137: 		maybe_hundred_bak[14] = psx_floats512[uint32_t(a1->tex_coord_b.x) * 2 + ((lost_bits >> 2) & 1)];
138: 		maybe_hundred_bak[15] = psx_floats512[uint32_t(a1->tex_coord_b.y) * 2 + ((lost_bits >> 3) & 1)];
139: 		maybe_hundred_bak[22] = psx_floats512[uint32_t(a1->tex_coord_c.x) * 2 + ((lost_bits >> 4) & 1)];
140: 		maybe_hundred_bak[23] = psx_floats512[uint32_t(a1->tex_coord_c.y) * 2 + ((lost_bits >> 5) & 1)];
141: 
142: 		maybe_hundred_bak = nullptr;
143: 	}
144: }
145: 
146: void ssigpu_sub_461220(float *maybe_hundred)
147: {
148: 	maybe_hundred_bak = maybe_hundred;
149: 
150: 	((void(*)(float*))ff8_externals.sub_461220)(maybe_hundred);
151: }
152: 
153: int pubintro_psxvram_buffer_init_sub_45B310()
154: {
155: 	if (trace_all) ffnx_trace("%s\n", __func__);
156: 
157: 	int ret = ((int(*)())ff8_externals.sub_45B310)();
158: 
159: 	// Divide by 255 instead of 256, and don't alter values of psx_floats1[0] and psx_floats1[255]
160: 	for (int i = 0; i < 256; ++i) {
161: 		ff8_externals.psx_floats1[i] = float(double(i) / 255.0);
162: 	}
163: 
164: 	for (int i = 0; i < 512; ++i) {
165: 		psx_floats512[i] = float(double(i) / 511.0);
166: 	}
167: 
168: 	return ret;
169: }
170: 
171: void uv_patch_init()
172: {
173: 	/* We hook a lot of stuff here to bring back full precision in texture UVs
174: 	 * - We need the UVs directly from the game data. To obtain this,
175: 	 *   we get the current block data and the current polygon from the game.
176: 	 * - Then we put this information into the SSIGPU instruction, the game will
177: 	 *   only stores the UVs divided by 2, so we need to remember the forgotten bits at least.
178: 	 * - And when the game uses the UVs from the SSIGPU instruction, we alter
179: 	 *   the computation of U and V using the forgotten bits.
180: 	 */
181: 
182: 	// Worldmap with Fog enabled
183: 	replace_call(ff8_externals.sub_53BB90 + (FF8_US_VERSION ? 0x42D : 0x43B), worldmap_fog_filter_polygons_in_block_1);
184: 	replace_call(ff8_externals.sub_53BB90 + (FF8_US_VERSION ? 0xADD : 0xB11), worldmap_fog_filter_polygons_in_block_1);
185: 	replace_call(ff8_externals.sub_53BB90 + (FF8_US_VERSION ? 0x442 : 0x450), worldmap_fog_filter_polygons_in_block_2);
186: 	replace_call(ff8_externals.sub_53BB90 + (FF8_US_VERSION ? 0xAF2 : 0xB26), worldmap_fog_filter_polygons_in_block_2);
187: 	replace_call(ff8_externals.worldmap_fog_filter_polygons_in_block_1 + (FF8_US_VERSION ? 0x1FC : 0x202), sub_45DF20);
188: 	replace_call(ff8_externals.worldmap_fog_filter_polygons_in_block_1 + (FF8_US_VERSION ? 0x5C8 : 0x5DC), enrich_tex_coords_sub_45E3A0);
189: 	replace_call(ff8_externals.worldmap_fog_filter_polygons_in_block_2 + (FF8_US_VERSION ? 0x242 : 0x241), sub_45DF20);
190: 	replace_call(ff8_externals.worldmap_fog_filter_polygons_in_block_2 + (FF8_US_VERSION ? 0x698 : 0x6CD), enrich_tex_coords_sub_45E3A0);
191: 	replace_call(ff8_externals.sub_461E00 + 0x50, ssigpu_sub_461220);
192: 	ff8_externals.ssigpu_callbacks_1[52] = uint32_t(ssigpu_callback_sub_461E00);
193: 
194: 	replace_call(ff8_externals.pubintro_init + 0x91, pubintro_psxvram_buffer_init_sub_45B310);
195: }
</file>

<file path="src/ff8/uv_patch.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: void uv_patch_init();
</file>

<file path="src/ff8/vibration.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: #include "vibration.h"
 23: #include "../ff8.h"
 24: #include "../log.h"
 25: #include "../patch.h"
 26: #include "../vibration.h"
 27: #include "battle/effects.h"
 28: 
 29: char vibrateName[32] = "";
 30: ff8_menu_config_input_keymap menu_options_keymap_desc[11];
 31: 
 32: int ff8_vibrate_capability(int port)
 33: {
 34: 	if (trace_all) ffnx_trace("%s port=%d\n", __func__, port);
 35: 
 36: 	return nxVibrationEngine.canRumble();
 37: }
 38: 
 39: int ff8_game_is_paused(int callback)
 40: {
 41: 	if (trace_all) ffnx_trace("%s callback=%p\n", __func__, callback);
 42: 
 43: 	if (nxVibrationEngine.canRumble())
 44: 	{
 45: 		// Reroute to the vibrate pause menu
 46: 		int ret = ff8_externals.pause_menu_with_vibration(callback);
 47: 
 48: 		int keyon = ff8_externals.get_keyon(0, 0);
 49: 		// Press pause again
 50: 		if ((keyon & 0x800) != 0) {
 51: 			return 1;
 52: 		}
 53: 
 54: 		return ret;
 55: 	}
 56: 
 57: 	return ff8_externals.pause_menu(callback);
 58: }
 59: 
 60: void vibrate(int left, int right)
 61: {
 62: 	const int port = 0;
 63: 
 64: 	if (trace_all || trace_gamepad) ffnx_trace("%s left=%d right=%d vibrate_option_enabled=%d\n", __func__, left, right, ff8_externals.gamepad_states->state_by_port[port].vibrate_option_enabled);
 65: 
 66: 	if (ff8_externals.gamepad_states->state_by_port[port].vibrate_option_enabled == 255)
 67: 	{
 68: 		nxVibrationEngine.setLeftMotorValue(left);
 69: 		nxVibrationEngine.setRightMotorValue(right);
 70: 		nxVibrationEngine.rumbleUpdate();
 71: 	}
 72: }
 73: 
 74: void apply_vibrate_calc(char port, int left, int right)
 75: {
 76: 	ff8_gamepad_vibration_state *gamepad_state = ff8_externals.gamepad_states->state_by_port;
 77: 	if (left < 0) left = 0;
 78: 	if (right < 0) right = 0;
 79: 
 80: 	// Keep the game implementation
 81: 	gamepad_state[port & 0x1].vibration_active = 1;
 82: 	gamepad_state[port & 0x1].left_motor_speed = left;
 83: 	gamepad_state[port & 0x1].right_motor_speed = right;
 84: 
 85: 	vibrate(left, right);
 86: }
 87: 
 88: const char *set_name(const char *name)
 89: {
 90: 	return strncpy(vibrateName, name, sizeof(vibrateName));
 91: }
 92: 
 93: const char *vibrate_data_name(const uint8_t *data)
 94: {
 95: 	if (trace_all || trace_gamepad) ffnx_trace("%s: data=0x%X\n", __func__, data);
 96: 
 97: 	if (data == *ff8_externals.vibrate_data_battle)
 98: 	{
 99: 		return set_name("battle");
100: 	}
101: 
102: 	if (data == *ff8_externals.vibrate_data_main)
103: 	{
104: 		return set_name("main");
105: 	}
106: 
107: 	if (getmode_cached()->driver_mode == MODE_WORLDMAP)
108: 	{
109: 		return set_name("world");
110: 	}
111: 
112: 	if (data == ff8_externals.vibrate_data_field)
113: 	{
114: 		return set_name("field");
115: 	}
116: 
117: 	if (getmode_cached()->driver_mode != MODE_BATTLE)
118: 	{
119: 		return nullptr;
120: 	}
121: 
122: 	switch (FF8BattleEffect::Effect(*ff8_externals.battle_magic_id))
123: 	{
124: 	case FF8BattleEffect::Quezacotl:
125: 		return set_name("battle_quezacotl");
126: 	case FF8BattleEffect::Shiva:
127: 		return set_name("battle_shiva");
128: 	case FF8BattleEffect::Ifrit:
129: 		return set_name("battle_ifrit");
130: 	case FF8BattleEffect::Siren:
131: 		return set_name("battle_siren");
132: 	case FF8BattleEffect::Brothers:
133: 		return set_name("battle_brothers");
134: 	case FF8BattleEffect::Diablos:
135: 		return set_name("battle_diablos");
136: 	case FF8BattleEffect::Carbuncle:
137: 		return set_name("battle_carbuncle");
138: 	case FF8BattleEffect::Leviathan:
139: 		return set_name("battle_leviathan");
140: 	case FF8BattleEffect::Pandemona:
141: 		return set_name("battle_pandemona");
142: 	case FF8BattleEffect::Cerberus:
143: 		return set_name("battle_cerberus");
144: 	case FF8BattleEffect::Alexander:
145: 		return set_name("battle_alexander");
146: 	case FF8BattleEffect::Doomtrain:
147: 		return set_name("battle_doomtrain");
148: 	case FF8BattleEffect::Bahamut:
149: 		return set_name("battle_bahamut");
150: 	case FF8BattleEffect::Cactuar:
151: 		return set_name("battle_cactuar");
152: 	case FF8BattleEffect::Tonberry:
153: 		return set_name("battle_tonberry");
154: 	case FF8BattleEffect::Eden:
155: 		return set_name("battle_eden");
156: 	case FF8BattleEffect::Odin:
157: 		return set_name("battle_odin");
158: 	case FF8BattleEffect::GilgameshZantetsuken:
159: 		return set_name("battle_gilgamesh_zantetsuken");
160: 	case FF8BattleEffect::GilgameshMasamune:
161: 		return set_name("battle_gilgamesh_masamune");
162: 	case FF8BattleEffect::GilgameshExcaliber:
163: 		return set_name("battle_gilgamesh_excaliber");
164: 	case FF8BattleEffect::GilgameshExcalipoor:
165: 		return set_name("battle_gilgamesh_excalipoor");
166: 	case FF8BattleEffect::Phoenix:
167: 		return set_name("battle_phoenix");
168: 	case FF8BattleEffect::Moomba:
169: 		return set_name("battle_moomba");
170: 	case FF8BattleEffect::Minimog:
171: 		return set_name("battle_minimog");
172: 	case FF8BattleEffect::BokoChocofire:
173: 		return set_name("battle_boko_chocofire");
174: 	case FF8BattleEffect::BokoChocoflare:
175: 		return set_name("battle_boko_chocoflare");
176: 	case FF8BattleEffect::BokoChocometeor:
177: 		return set_name("battle_boko_chocometeor");
178: 	case FF8BattleEffect::BokoChocobocle:
179: 		return set_name("battle_boko_chocobocle");
180: 	case FF8BattleEffect::Meteor:
181: 		return set_name("battle_meteor");
182: 	case FF8BattleEffect::Apocalypse:
183: 		return set_name("battle_apocalypse");
184: 	case FF8BattleEffect::Ultima:
185: 		return set_name("battle_ultima");
186: 	}
187: 
188: 	snprintf(vibrateName, sizeof(vibrateName), "battle_effect_%d", *ff8_externals.battle_magic_id);
189: 
190: 	return vibrateName;
191: }
192: 
193: uint32_t ff8_set_vibration_replace_id = 0;
194: 
195: int ff8_set_vibration(const uint8_t *data, int set, int intensity)
196: {
197: 	if (trace_all || trace_gamepad) ffnx_trace("%s: set=%d intensity=%d\n", __func__, set, intensity);
198: 
199: 	const char *name = vibrate_data_name(data);
200: 
201: 	if (name != nullptr)
202: 	{
203: 		const uint8_t *dataOverride = nxVibrationEngine.vibrateDataOverride(name);
204: 		if (dataOverride != nullptr)
205: 		{
206: 			data = dataOverride;
207: 		}
208: 		else if (data != *ff8_externals.vibrate_data_main && getmode_cached()->driver_mode == MODE_WORLDMAP)
209: 		{
210: 			// Disable vibration
211: 			return 0;
212: 		}
213: 	}
214: 
215: 	unreplace_function(ff8_set_vibration_replace_id);
216: 	int ret = ((int(*)(const uint8_t*,int,int))ff8_externals.set_vibration)(data, set, intensity);
217: 	rereplace_function(ff8_set_vibration_replace_id);
218: 
219: 	return ret;
220: }
221: 
222: ff8_draw_menu_sprite_texture_infos *alternate_pause_battle(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos)
223: {
224: 	if (nxVibrationEngine.canRumble())
225: 	{
226: 		uint16_t keyon = *(uint16_t *)(*(int *)ff8_externals.battle_menu_state + 0x14);
227: 		uint8_t port = 0;
228: 		int vibrate_state = ((int(*)(uint8_t))ff8_externals.vibration_get_is_enabled)(port);
229: 
230: 		if ((keyon & 0xF060) != 0)
231: 		{
232: 			vibrate_state = uint8_t(-(vibrate_state != 255));
233: 			((void(*)(uint8_t,int))ff8_externals.vibration_set_is_enabled)(port, vibrate_state);
234: 		}
235: 
236: 		*ff8_externals.is_alternative_pause_menu = 1;
237: 		int previous_value = *ff8_externals.pause_menu_option_state;
238: 		*ff8_externals.pause_menu_option_state = vibrate_state;
239: 
240: 		ff8_draw_menu_sprite_texture_infos *ret = ((ff8_draw_menu_sprite_texture_infos*(*)(int,ff8_draw_menu_sprite_texture_infos*))ff8_externals.battle_pause_window_sub_4CD350)(a1, draw_infos);
241: 
242: 		// Reset values to prevent any issues outside the pause menu
243: 		*ff8_externals.is_alternative_pause_menu = 0;
244: 		*ff8_externals.pause_menu_option_state = previous_value;
245: 
246: 		return ret;
247: 	}
248: 
249: 	return ((ff8_draw_menu_sprite_texture_infos*(*)(int,ff8_draw_menu_sprite_texture_infos*))ff8_externals.battle_pause_window_sub_4CD350)(a1, draw_infos);
250: }
251: 
252: ff8_draw_menu_sprite_texture_infos *battle_pause_show_quit_game_text(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos, int x, int y, uint8_t *text_data, int a6)
253: {
254: 	// Replace to "Vibration"
255: 	return ((ff8_draw_menu_sprite_texture_infos*(*)(int,ff8_draw_menu_sprite_texture_infos*,int,int))ff8_externals.sub_4A7210)(a1, draw_infos, x, y);
256: }
257: 
258: void vibration_init()
259: {
260: 	replace_function(ff8_externals.get_vibration_capability, ff8_vibrate_capability);
261: 	replace_function(ff8_externals.vibration_apply, apply_vibrate_calc);
262: 	replace_function(ff8_externals.vibration_clear_intensity, noop_a1);
263: 	ff8_set_vibration_replace_id = replace_function(ff8_externals.set_vibration, ff8_set_vibration);
264: 
265: 	// Replace pause menus
266: 	replace_call(uint32_t(ff8_externals.check_game_is_paused) + 0x88, ff8_game_is_paused);
267: 	replace_call(ff8_externals.battle_pause_sub_4CD140 + (JP_VERSION ? 0x1F1 : 0x225), alternate_pause_battle);
268: 	replace_call(ff8_externals.battle_pause_window_sub_4CD350 + 0x8D, battle_pause_show_quit_game_text);
269: 
270: 	// Relocate menu_options_keymap_desc to make room for a new input line in menu_options_desc which is located right before
271: 	memcpy(menu_options_keymap_desc, ff8_externals.menu_config_input_desc_keymap, sizeof(menu_options_keymap_desc));
272: 	patch_code_dword(uint32_t(ff8_externals.menu_callbacks[8].func) + 0x110, DWORD(menu_options_keymap_desc));
273: 	patch_code_dword(uint32_t(ff8_externals.menu_callbacks[8].func) + 0x12E, DWORD(menu_options_keymap_desc));
274: 	patch_code_dword(ff8_externals.menu_config_controller + 0x84, DWORD(menu_options_keymap_desc));
275: 	patch_code_dword(ff8_externals.menu_config_controller + 0x92, DWORD(menu_options_keymap_desc));
276: 	patch_code_dword(ff8_externals.menu_config_controller + 0xD7, DWORD(menu_options_keymap_desc) + 4);
277: 	patch_code_dword(ff8_externals.menu_config_controller + 0x109, DWORD(menu_options_keymap_desc) + 3);
278: 	patch_code_dword(ff8_externals.menu_config_controller + 0x155, DWORD(menu_options_keymap_desc) + 1);
279: 	patch_code_dword(ff8_externals.menu_config_controller + 0x53A, DWORD(menu_options_keymap_desc) + 3);
280: 	patch_code_dword(ff8_externals.menu_config_controller + 0x5B1, DWORD(menu_options_keymap_desc) + 3);
281: 	patch_code_dword(ff8_externals.menu_config_controller + 0x67B, DWORD(menu_options_keymap_desc));
282: 	patch_code_dword(ff8_externals.menu_config_controller + 0x7A0, DWORD(menu_options_keymap_desc) + 3);
283: 	patch_code_dword(ff8_externals.menu_config_render_submenu + 0x13, DWORD(menu_options_keymap_desc));
284: 
285: 	// Add Vibration configuration line in main menu
286: 	ff8_externals.menu_config_input_desc[9].text_id_name = 0x0; // "Vibration"
287: 	ff8_externals.menu_config_input_desc[9].text_id_value1 = 0x2; // "OFF"
288: 	ff8_externals.menu_config_input_desc[9].text_id_value2 = 0x1; // "ON"
289: 	ff8_externals.menu_config_input_desc[9].type = 2; // Toggle switch (Vibration option specific)
290: 	ff8_externals.menu_config_input_desc[9].mask = 0x40; // Bit mask in the savemap entry
291: 	ff8_externals.menu_config_input_desc[9].value = 0; // Always initialized to zero, will change at runtime
292: 	ff8_externals.menu_config_input_desc[9].callback_change_state = (void(*)())ff8_externals.sub_4C2FF0; // Update structures
293: 	// End of configuration lines
294: 	ff8_externals.menu_config_input_desc[10] = ff8_menu_config_input();
295: 	ff8_externals.menu_config_input_desc[10].text_id_name = -1;
296: }
</file>

<file path="src/ff8/vibration.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: void vibration_init();
</file>

<file path="src/ff8/vram.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 Chris Rizzitello                                   //
   6: //    Copyright (C) 2020 John Pritchard                                     //
   7: //    Copyright (C) 2023 myst6re                                            //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
  10: //                                                                          //
  11: //    This file is part of FFNx                                             //
  12: //                                                                          //
  13: //    FFNx is free software: you can redistribute it and/or modify          //
  14: //    it under the terms of the GNU General Public License as published by  //
  15: //    the Free Software Foundation, either version 3 of the License         //
  16: //                                                                          //
  17: //    FFNx is distributed in the hope that it will be useful,               //
  18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  20: //    GNU General Public License for more details.                          //
  21: /****************************************************************************/
  22: #include "vram.h"
  23: 
  24: #include "../ff8.h"
  25: #include "../patch.h"
  26: #include "../macro.h"
  27: #include "../image/tim.h"
  28: #include "../utils.h"
  29: #include "../globals.h"
  30: #include "../cfg.h"
  31: #include "../log.h"
  32: #include "field/background.h"
  33: #include "field/chara_one.h"
  34: #include "world/chara_one.h"
  35: #include "world/wmset.h"
  36: #include "battle/stage.h"
  37: 
  38: #include <shlwapi.h>
  39: #include <unordered_map>
  40: #include <vector>
  41: 
  42: TexturePacker texturePacker;
  43: 
  44: char next_texture_name[MAX_PATH] = "";
  45: TexturePacker::TextureInfos texture_infos = TexturePacker::TextureInfos();
  46: TexturePacker::TextureInfos palette_infos = TexturePacker::TextureInfos();
  47: uint16_t *next_pal_data = nullptr;
  48: int next_psxvram_x = -1;
  49: int next_psxvram_y = -1;
  50: int next_psxvram_pal_x = -1;
  51: int next_psxvram_pal_y = -1;
  52: texture_page *current_tex_page = nullptr;
  53: int next_texl_id = 0;
  54: int next_texture_count = -1;
  55: int next_do_not_clear_old_texture = false;
  56: Tim::Bpp next_bpp = Tim::Bpp16;
  57: int last_CLUT = 0;
  58: 
  59: // Field background
  60: uint8_t *mim_texture_buffer = nullptr;
  61: // Field models
  62: std::unordered_map<uint32_t, CharaOneModel> chara_one_models;
  63: std::vector<uint32_t> chara_one_loaded_models;
  64: int chara_one_current_pos = 0;
  65: uint32_t chara_one_current_model = 0;
  66: uint32_t chara_one_current_mch = 0;
  67: uint32_t chara_one_current_texture = 0;
  68: // World
  69: std::vector<CharaOneModelTextures> chara_one_world_texture_offsets;
  70: uint8_t *chara_one_world_data;
  71: std::vector<WmsetSection17Texture> wm_wmset_wave_animations_textures;
  72: std::unordered_map<uint32_t, WmsetSection41Texture> wm_wmset_palette_animations_textures;
  73: // Battle
  74: char battle_texture_name[MAX_PATH] = "";
  75: int battle_texture_id = 0;
  76: Stage stage;
  77: struct BattleTextureHeader {
  78: 	uint8_t effect_id;
  79: 	uint8_t file_id;
  80: 	uint8_t is_palette;
  81: 	uint8_t file_relative_id;
  82: 	int16_t x, y;
  83: 	int16_t w, h;
  84: 	uint8_t *data;
  85: };
  86: constexpr int battle_texture_data_list_size = 32;
  87: std::vector<BattleTextureHeader> battle_texture_headers = std::vector<BattleTextureHeader>(battle_texture_data_list_size);
  88: int battle_texture_headers_cursor = 0;
  89: struct BattleTextureFileName {
  90: 	char file_name[32];
  91: 	void *data;
  92: };
  93: std::vector<BattleTextureFileName> battle_texture_data_list = std::vector<BattleTextureFileName>(battle_texture_data_list_size);
  94: int battle_texture_data_list_cursor = 0;
  95: 
  96: uint8_t *ff8_vram_seek(int xBpp2, int y)
  97: {
  98: 	return ff8_externals.psxvram_buffer + VRAM_DEPTH * (xBpp2 + y * VRAM_WIDTH);
  99: }
 100: 
 101: bool ff8_vram_save(const char *fileName, Tim::Bpp bpp)
 102: {
 103: 	uint16_t palette[256] = {};
 104: 
 105: 	ff8_tim tim_infos = ff8_tim();
 106: 
 107: 	tim_infos.img_data = ff8_externals.psxvram_buffer;
 108: 	tim_infos.img_w = VRAM_WIDTH;
 109: 	tim_infos.img_h = VRAM_HEIGHT;
 110: 
 111: 	if (bpp < Tim::Bpp16)
 112: 	{
 113: 		tim_infos.pal_data = palette;
 114: 		tim_infos.pal_h = 1;
 115: 		tim_infos.pal_w = bpp == Tim::Bpp4 ? 16 : 256;
 116: 
 117: 		// Greyscale palette
 118: 		for (int i = 0; i < tim_infos.pal_w; ++i)
 119: 		{
 120: 			uint8_t color = bpp == Tim::Bpp4 ? i * 16 : i;
 121: 			palette[i] = color | (color << 5) | (color << 10);
 122: 		}
 123: 	}
 124: 
 125: 	return Tim(bpp, tim_infos).save(fileName, int(bpp), false);
 126: }
 127: 
 128: void ff8_upload_vram(int16_t *pos_and_size, uint8_t *texture_buffer)
 129: {
 130: 	const int16_t x = pos_and_size[0];
 131: 	const int16_t y = pos_and_size[1];
 132: 	const int16_t w = pos_and_size[2];
 133: 	const int16_t h = pos_and_size[3];
 134: 	bool isPal = (next_pal_data != nullptr && (uint8_t *)next_pal_data == texture_buffer)
 135: 		|| (palette_infos.isValid() && palette_infos.x() == x && palette_infos.y() == y && palette_infos.w() == w && palette_infos.h() == h);
 136: 
 137: 	if (trace_all || trace_vram) ffnx_trace("%s x=%d y=%d w=%d h=%d bpp=%d isPal=%d texture_buffer=0x%X\n", __func__, x, y, w, h, next_bpp, isPal, texture_buffer);
 138: 
 139: 	uint8_t *vram = ff8_vram_seek(x, y);
 140: 	const int vramLineWidth = VRAM_DEPTH * VRAM_WIDTH;
 141: 	const int lineWidth = VRAM_DEPTH * w;
 142: 
 143: 	for (int i = 0; i < h; ++i) {
 144: 		memcpy(vram, texture_buffer, lineWidth);
 145: 
 146: 		texture_buffer += lineWidth;
 147: 		vram += vramLineWidth;
 148: 	}
 149: 
 150: 	if (texture_infos.isValid() && palette_infos.isValid()) {
 151: 		texturePacker.setTexture(next_texture_name, texture_infos, palette_infos, next_texture_count, !next_do_not_clear_old_texture);
 152: 
 153: 		texture_infos = TexturePacker::TextureInfos();
 154: 		palette_infos = TexturePacker::TextureInfos();
 155: 	} else if (!texture_infos.isValid() && !palette_infos.isValid() && !isPal) {
 156: 		texturePacker.setTexture(next_texture_name, TexturePacker::TextureInfos(x, y, w, h, next_bpp), TexturePacker::TextureInfos(), next_texture_count, !next_do_not_clear_old_texture);
 157: 	}
 158: 
 159: 	ff8_externals.sub_464850(x, y, x + w - 1, h + y - 1);
 160: 
 161: 	*next_texture_name = '\0';
 162: 	next_do_not_clear_old_texture = false;
 163: 	next_texture_count = -1;
 164: }
 165: 
 166: void ff8_vram_copy_part(int x, int y, int w, int h, int target_x, int target_y)
 167: {
 168: 	if (trace_all || trace_vram) ffnx_trace("%s x=%d y=%d w=%d h=%d target_x=%d target_y=%d\n", __func__, x, y, w, h, target_x, target_y);
 169: 
 170: 	uint8_t *vram = ff8_vram_seek(x, y), *target = ff8_vram_seek(target_x, target_y);
 171: 	const int vramLineWidth = VRAM_DEPTH * VRAM_WIDTH;
 172: 	const int lineWidth = VRAM_DEPTH * w;
 173: 
 174: 	for (int i = 0; i < h; ++i) {
 175: 		memcpy(target, vram, lineWidth);
 176: 
 177: 		vram += vramLineWidth;
 178: 		target += vramLineWidth;
 179: 	}
 180: 
 181: 	texturePacker.animateTextureByCopy(x, y, w, h, target_x, target_y);
 182: 
 183: 	ff8_externals.sub_464850(x, y, x + w - 1, h + y - 1);
 184: }
 185: 
 186: void ff8_copy_vram_part(int16_t *pos_and_size, int target_x, int target_y)
 187: {
 188: 	const int16_t x = pos_and_size[0];
 189: 	const int16_t y = pos_and_size[1];
 190: 	const int16_t w = pos_and_size[2];
 191: 	const int16_t h = pos_and_size[3];
 192: 
 193: 	ff8_vram_copy_part(x, y, w, h, target_x, target_y);
 194: }
 195: 
 196: int read_vram_to_buffer_parent_call1(struc_50 *psxvram, texture_page *tex_page, int x, int y, int w, int h, int bpp, int rel_pos, int a9, uint8_t *target)
 197: {
 198: 	if (trace_all || trace_vram) ffnx_trace("%s: x=%d y=%d w=%d h=%d bpp=%d rel_pos=(%d, %d) a9=%d target=%X\n", __func__, x, y, w, h, bpp, rel_pos & 0xF, rel_pos >> 4, a9, target);
 199: 
 200: 	next_psxvram_x = (x >> (2 - bpp)) + ((rel_pos & 0xF) << 6);
 201: 	next_psxvram_y = y + (((rel_pos >> 4) & 1) << 8);
 202: 	current_tex_page = tex_page;
 203: 
 204: 	int ret = ff8_externals.sub_464F70(psxvram, tex_page, x, y, w, h, bpp, rel_pos, a9, target);
 205: 
 206: 	next_psxvram_x = -1;
 207: 	next_psxvram_y = -1;
 208: 	current_tex_page = nullptr;
 209: 
 210: 	return ret;
 211: }
 212: 
 213: int read_vram_to_buffer_parent_call1_tx_select(struc_50 *psxvram, texture_page *tex_page, int x, int y, int w, int h, int bpp, int rel_pos, int a9, uint8_t *target)
 214: {
 215: 	TexturePacker::TiledTex oldTiledTex = texturePacker.getTiledTex((uint8_t *)ff8_externals.psx_texture_pages[bpp].struc_50_array[rel_pos].texture_page[0].image_data);
 216: 
 217: 	int ret = read_vram_to_buffer_parent_call1(psxvram, tex_page, x, y, w, h, bpp, rel_pos, a9, target);
 218: 
 219: 	if (trace_all || trace_vram) ffnx_trace("%s: copy palette infos from 0x%X\n", __func__, ff8_externals.psx_texture_pages[bpp].struc_50_array[rel_pos].texture_page[0].image_data);
 220: 
 221: 	// Copy known palettes from neighbor tex
 222: 	for (const std::pair<uint8_t, const TexturePacker::TextureInfos &> &pal: oldTiledTex.palettes) {
 223: 		texturePacker.registerPaletteWrite((const uint8_t *)tex_page->image_data, pal.first, pal.second.x(), pal.second.y());
 224: 	}
 225: 
 226: 	return ret;
 227: }
 228: 
 229: int read_vram_to_buffer_parent_call2(texture_page *tex_page, int rel_pos, int a3)
 230: {
 231: 	if (trace_all || trace_vram) ffnx_trace("%s: x=%d y=%d color_key=%d rel_pos=(%d, %d)\n", __func__, tex_page->x, tex_page->y, tex_page->color_key, rel_pos & 0xF, rel_pos >> 4);
 232: 
 233: 	next_psxvram_x = (tex_page->x >> (2 - tex_page->color_key)) + ((rel_pos & 0xF) << 6);
 234: 	next_psxvram_y = tex_page->y + (((rel_pos >> 4) & 1) << 8);
 235: 	current_tex_page = tex_page;
 236: 
 237: 	int ret = ((int(*)(texture_page *, int, int))ff8_externals.sub_4653B0)(tex_page, rel_pos, a3);
 238: 
 239: 	next_psxvram_x = -1;
 240: 	next_psxvram_y = -1;
 241: 	current_tex_page = nullptr;
 242: 
 243: 	return ret;
 244: }
 245: 
 246: int read_vram_to_buffer_with_palette1_parent_call1(texture_page *tex_page, int rel_pos, struc_50 *psxvram_structure)
 247: {
 248: 	if (trace_all || trace_vram) ffnx_trace("%s: x=%d y=%d color_key=%d rel_pos=(%d, %d)\n", __func__, tex_page->x, tex_page->y, tex_page->color_key, rel_pos & 0xF, rel_pos >> 4);
 249: 
 250: 	next_psxvram_x = (tex_page->x >> (2 - tex_page->color_key)) + ((rel_pos & 0xF) << 6);
 251: 	next_psxvram_y = tex_page->y + (((rel_pos >> 4) & 1) << 8);
 252: 	next_psxvram_pal_x = (psxvram_structure->vram_palette_pos & 0x3F) * 16;
 253: 	next_psxvram_pal_y = (psxvram_structure->vram_palette_pos >> 6) & 0x1FF;
 254: 	current_tex_page = tex_page;
 255: 
 256: 	int ret = ((int(*)(texture_page*,int,struc_50*))ff8_externals.sub_464DB0)(tex_page, rel_pos, psxvram_structure);
 257: 
 258: 	next_psxvram_x = -1;
 259: 	next_psxvram_y = -1;
 260: 	next_psxvram_pal_x = -1;
 261: 	next_psxvram_pal_y = -1;
 262: 	current_tex_page = nullptr;
 263: 
 264: 	return ret;
 265: }
 266: 
 267: int read_vram_to_buffer_with_palette1_parent_call2(texture_page *tex_page, int rel_pos, struc_50 *psxvram_structure)
 268: {
 269: 	if (trace_all || trace_vram) ffnx_trace("%s: x=%d y=%d color_key=%d rel_pos=(%d, %d)\n", __func__, tex_page->x, tex_page->y, tex_page->color_key, rel_pos & 0xF, rel_pos >> 4);
 270: 
 271: 	next_psxvram_x = (tex_page->x >> (2 - tex_page->color_key)) + ((rel_pos & 0xF) << 6);
 272: 	next_psxvram_y = tex_page->y + (((rel_pos >> 4) & 1) << 8);
 273: 	next_psxvram_pal_x = (psxvram_structure->vram_palette_pos & 0x3F) * 16;
 274: 	next_psxvram_pal_y = (psxvram_structure->vram_palette_pos >> 6) & 0x1FF;
 275: 	current_tex_page = tex_page;
 276: 
 277: 	int ret = ((int(*)(texture_page*,int,struc_50*))ff8_externals.sub_465720)(tex_page, rel_pos, psxvram_structure);
 278: 
 279: 	next_psxvram_x = -1;
 280: 	next_psxvram_y = -1;
 281: 	next_psxvram_pal_x = -1;
 282: 	next_psxvram_pal_y = -1;
 283: 	current_tex_page = nullptr;
 284: 
 285: 	return ret;
 286: }
 287: 
 288: int read_vram_to_buffer_with_palette2_parent_call(int a1, uint16_t rel_pos, int16_t palette_pos_related, uint8_t x, uint8_t y, int16_t w, int16_t h)
 289: {
 290: 	uint8_t color_key = (rel_pos >> 7) & 3;
 291: 
 292: 	if (trace_all || trace_vram) ffnx_trace("%s: x=%d y=%d w=%d h=%d color_key=%d rel_pos=(%d, %d)\n", __func__, x, y, w, h, color_key, rel_pos & 0xF, (rel_pos >> 4) & 1);
 293: 
 294: 	next_psxvram_x = (x >> (2 - color_key)) + ((rel_pos & 0xF) << 6);
 295: 	next_psxvram_y = y + (((rel_pos >> 4) & 1) << 8);
 296: 
 297: 	int ret = ((int(*)(int, uint16_t, int16_t, uint8_t, uint8_t, int16_t, int16_t))ff8_externals.sub_4649A0)(a1, rel_pos, palette_pos_related, x, y, w, h);
 298: 
 299: 	next_psxvram_x = -1;
 300: 	next_psxvram_y = -1;
 301: 
 302: 	return ret;
 303: }
 304: 
 305: const std::string &tex_name_special_cases(std::string &filename, const std::string &full_filename, int vram_id)
 306: {
 307: 	if (full_filename.starts_with("field/mapdata/")) {
 308: 		int field_vram_id = next_psxvram_x / TEXTURE_WIDTH_BPP16;
 309: 		char fallback_dir[MAX_PATH]{}, fallback[MAX_PATH]{};
 310: 		// Keep compatibility with old Tonberry mods that uses VRAM ID 13 to 26
 311: 		snprintf(fallback, sizeof(fallback), "field/mapdata/%.2s/%s/%s_%d", get_current_field_name(), get_current_field_name(), get_current_field_name(), field_vram_id + VRAM_PAGE_MIM_MAX_COUNT);
 312: 
 313: 		if (trace_vram || trace_all) ffnx_info("%s: %s %s %d\n", __func__, filename.c_str(), full_filename.c_str(), field_vram_id);
 314: 
 315: 		for (const std::string &ext: mod_ext) {
 316: 			snprintf(fallback_dir, sizeof(fallback_dir), "%s/%s/%s.%s", basedir, mod_path.c_str(), fallback, ext.c_str());
 317: 
 318: 			if (fileExists(fallback_dir)) {
 319: 				filename = std::string(fallback);
 320: 				return filename;
 321: 			}
 322: 		}
 323: 		// Force VRAM ID 0 to 12
 324: 		snprintf(fallback, sizeof(fallback), "field/mapdata/%.2s/%s/%s_%d", get_current_field_name(), get_current_field_name(), get_current_field_name(), field_vram_id);
 325: 		filename = std::string(fallback);
 326: 	}
 327: 
 328: 	return filename;
 329: }
 330: 
 331: void set_tex_name(const TexturePacker::TiledTex &tiledTex, ff8_tex_header *tex_header)
 332: {
 333: 	if (tex_header == nullptr)
 334: 	{
 335: 		return;
 336: 	}
 337: 
 338: 	const auto textures = texturePacker.matchTextures(tiledTex);
 339: 
 340: 	if (textures.empty())
 341: 	{
 342: 		return;
 343: 	}
 344: 
 345: 	std::string filename;
 346: 	int file_count = 0;
 347: 	int start_vram_id = 0;
 348: 
 349: 	for (const TexturePacker::IdentifiedTexture &tex: textures)
 350: 	{
 351: 		if (tex.isValid())
 352: 		{
 353: 			if (file_count == 0)
 354: 			{
 355: 				filename.append(tex.name());
 356: 				start_vram_id = tex.texture().vramId();
 357: 			}
 358: 			else
 359: 			{
 360: 				size_t index = tex.name().find_last_of('/');
 361: 				if (index < 0)
 362: 				{
 363: 					filename.append(tex.name());
 364: 				}
 365: 				else
 366: 				{
 367: 					filename.append(tex.name().substr(index + 1));
 368: 				}
 369: 			}
 370: 			filename.append("_");
 371: 			// Add current frame info
 372: 			if (tex.currentAnimationFrame() >= 0)
 373: 			{
 374: 				filename.append("f");
 375: 				filename.append(std::to_string(tex.currentAnimationFrame()));
 376: 				filename.append("_");
 377: 			}
 378: 			file_count += 1;
 379: 
 380: 			// Do not produce huge file names
 381: 			if (file_count > 6)
 382: 			{
 383: 				break;
 384: 			}
 385: 		}
 386: 	}
 387: 
 388: 	if (!filename.empty())
 389: 	{
 390: 		int vramId = next_psxvram_x / TEXTURE_WIDTH_BPP16 + (next_psxvram_y >= TEXTURE_HEIGHT ? 16 : 0);
 391: 
 392: 		if (file_count == 1) {
 393: 			// To be on par with remaster naming, instead for example with use "card_16", "card_17" etc.., we starts with "card_0"
 394: 			vramId -= start_vram_id;
 395: 		}
 396: 
 397: 		std::string full_filename = filename;
 398: 
 399: 		if (filename.size() > 240) {
 400: 			filename = filename.substr(0, 240);
 401: 
 402: 			if (!filename.ends_with('_')) {
 403: 				filename.append("_");
 404: 			}
 405: 		}
 406: 
 407: 		filename.append(std::to_string(vramId));
 408: 
 409: 		filename = tex_name_special_cases(filename, full_filename, vramId);
 410: 
 411: 		if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, filename.c_str());
 412: 
 413: 		tex_header->file.pc_name = (char*)external_malloc(1024);
 414: 
 415: 		if (tex_header->file.pc_name != nullptr)
 416: 		{
 417: 			strncpy(tex_header->file.pc_name, filename.c_str(), 1024);
 418: 		}
 419: 	}
 420: }
 421: 
 422: void free_tex_header(ff8_tex_header *tex_header)
 423: {
 424: 	if (tex_header != nullptr && uint32_t(tex_header->file.pc_name) > 32)
 425: 	{
 426: 		if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, tex_header->file.pc_name);
 427: 
 428: 		external_free(tex_header->file.pc_name);
 429: 	}
 430: 
 431: 	((void(*)(ff8_tex_header*))ff8_externals.psxvram_texture_page_tex_header_free)(tex_header);
 432: }
 433: 
 434: void read_vram_to_buffer(uint8_t *vram, int vram_w_2048, uint8_t *target, int target_w_in_bytes, signed int w, int h, int bpp)
 435: {
 436: 	if (trace_all || trace_vram) ffnx_trace("%s: vram_pos=(%d, %d) target=0x%X target_w_in_bytes=%d w=%d h=%d bpp=%d\n", __func__, next_psxvram_x, next_psxvram_y, int(target), target_w_in_bytes, w, h, bpp);
 437: 
 438: 	if (next_psxvram_x == -1)
 439: 	{
 440: 		ffnx_warning("%s: cannot detect VRAM position\n", __func__);
 441: 	}
 442: 	else
 443: 	{
 444: 		const TexturePacker::TiledTex &tiledTex = texturePacker.registerTiledTex(target, next_psxvram_x, next_psxvram_y, w, h, Tim::Bpp(bpp));
 445: 
 446: 		if (current_tex_page != nullptr)
 447: 		{
 448: 			set_tex_name(tiledTex, current_tex_page->tex_header);
 449: 		}
 450: 	}
 451: 
 452: 	ff8_externals.read_vram_1(vram, vram_w_2048, target, target_w_in_bytes, w, h, bpp);
 453: }
 454: 
 455: void read_vram_to_buffer_with_palette1(uint8_t *vram, int vram_w_2048, uint8_t *target, int target_w_in_bytes, int w, int h, int bpp, uint16_t *vram_palette)
 456: {
 457: 	if (trace_all || trace_vram) ffnx_trace("%s: vram_pos=(%d, %d) target=0x%X target_w_in_bytes=%d w=%d h=%d bpp=%d vram_palette=%X\n", __func__, next_psxvram_x, next_psxvram_y, int(target), target_w_in_bytes, w, h, bpp, int(vram_palette));
 458: 
 459: 	if (next_psxvram_x == -1)
 460: 	{
 461: 		ffnx_warning("%s: cannot detect VRAM position\n", __func__);
 462: 	}
 463: 	else
 464: 	{
 465: 		const TexturePacker::TiledTex &tiledTex = texturePacker.registerTiledTex(target, next_psxvram_x, next_psxvram_y, w, h, Tim::Bpp(bpp), next_psxvram_pal_x, next_psxvram_pal_y);
 466: 
 467: 		if (current_tex_page != nullptr)
 468: 		{
 469: 			set_tex_name(
 470: 				tiledTex,
 471: 				current_tex_page->sub_tri_gfxobj == nullptr ? current_tex_page->sub_tex_header : (ff8_tex_header *)((ff8_texture_set *)current_tex_page->sub_tri_gfxobj->hundred_data->texture_set)->tex_header
 472: 			);
 473: 		}
 474: 	}
 475: 
 476: 	ff8_externals.read_vram_2_paletted(vram, vram_w_2048, target, target_w_in_bytes, w, h, bpp, vram_palette);
 477: }
 478: 
 479: void read_vram_to_buffer_with_palette2(uint8_t *vram, uint8_t *target, int w, int h, int bpp, uint16_t *vram_palette)
 480: {
 481: 	if (trace_all || trace_vram) ffnx_trace("%s: vram_pos=(%d, %d) target=0x%X w=%d h=%d bpp=%d vram_palette=%X\n", __func__, next_psxvram_x, next_psxvram_y, int(target), w, h, bpp, int(vram_palette));
 482: 
 483: 	if (next_psxvram_x == -1)
 484: 	{
 485: 		ffnx_warning("%s: cannot detect VRAM position\n", __func__);
 486: 	}
 487: 	else
 488: 	{
 489: 		texturePacker.registerTiledTex(target, next_psxvram_x, next_psxvram_y, w, h, Tim::Bpp(bpp), next_psxvram_pal_x, next_psxvram_pal_y);
 490: 	}
 491: 
 492: 	ff8_externals.read_vram_3_paletted(vram, target, w, h, bpp, vram_palette);
 493: }
 494: 
 495: void ff8_read_vram_palette(int CLUT, uint8_t *bgra, int size)
 496: {
 497: 	if (trace_all || trace_vram) ffnx_trace("%s: CLUT=(%d, %d) size=%d\n", __func__, (CLUT & 0x3F) * 16, (CLUT >> 6) & 0x1FF, size);
 498: 
 499: 	last_CLUT = CLUT;
 500: 
 501: 	uint16_t *psxvram_buffer_pointer = (uint16_t *)ff8_vram_seek((CLUT & 0x3F) * 16, (CLUT >> 6) & 0x1FF);
 502: 
 503: 	// Rewrite color conversion and alpha part
 504: 	for (int i = 0; i < size; ++i) {
 505: 		uint16_t color = *psxvram_buffer_pointer++;
 506: 
 507: 		uint8_t r = color & 31,
 508: 			g = (color >> 5) & 31,
 509: 			b = (color >> 10) & 31;
 510: 
 511: 		// Fix blue color in battle with fire spells, and fix palettes always semi-transparent
 512: 		bgra[0] = (b << 3) + (b >> 2);
 513: 		bgra[1] = (g << 3) + (g >> 2);
 514: 		bgra[2] = (r << 3) + (r >> 2);
 515: 		bgra[3] = color == 0 ? 0 : ((color & 0x8000) != 0 ? 0x7F : 0xFF);
 516: 
 517: 		bgra += 4;
 518: 	}
 519: }
 520: 
 521: int ff8_write_palette_to_driver(int source_offset, int size, uint32_t *source_rgba, int dest_offset, ff8_texture_set *texture_set)
 522: {
 523: 	VOBJ(texture_set, texture_set, texture_set);
 524: 	VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));
 525: 
 526: 	uint16_t palette_x = (last_CLUT & 0x3F) * 16, palette_y = (last_CLUT >> 6) & 0x1FF;
 527: 	int pal_index = dest_offset / size / 2;
 528: 
 529: 	texturePacker.registerPaletteWrite(VREF(tex_header, image_data), pal_index, palette_x, palette_y);
 530: 
 531: 	return ((int(*)(int,int,uint32_t*,int,struct ff8_texture_set*))ff8_externals.write_palette_to_driver_sub_467310)(source_offset, size, source_rgba, dest_offset, texture_set);
 532: }
 533: 
 534: uint32_t ff8_credits_open_texture(char *fileName, char *buffer)
 535: {
 536: 	if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, fileName);
 537: 
 538: 	// {name}.lzs
 539: 	strncpy(next_texture_name, strrchr(fileName, '\\') + 1, sizeof(next_texture_name));
 540: 	next_bpp = Tim::Bpp16;
 541: 
 542: 	uint32_t ret = ff8_externals.credits_open_file(fileName, buffer);
 543: 
 544: 	if (save_textures) Tim::fromLzsData((uint8_t *)buffer).save(next_texture_name);
 545: 
 546: 	return ret;
 547: }
 548: 
 549: void ff8_cdcheck_error_upload_vram(int16_t *pos_and_size, uint8_t *texture_buffer)
 550: {
 551: 	if (trace_all || trace_vram) ffnx_trace("%s\n", __func__);
 552: 
 553: 	strncpy(next_texture_name, "discerr.lzs", sizeof(next_texture_name));
 554: 	next_bpp = Tim::Bpp16;
 555: 
 556: 	if (save_textures) Tim::fromLzsData(texture_buffer - 8).save(next_texture_name);
 557: 
 558: 	ff8_upload_vram(pos_and_size, texture_buffer);
 559: }
 560: 
 561: void ff8_upload_vram_triple_triad_1(int16_t *pos_and_size, uint8_t *texture_buffer)
 562: {
 563: 	if (trace_all || trace_vram) ffnx_trace("%s %p\n", __func__, texture_buffer);
 564: 
 565: 	if (texture_buffer == ff8_externals.cardgame_tim_texture_intro)
 566: 	{
 567: 		strncpy(next_texture_name, "cardgame/intro", sizeof(next_texture_name));
 568: 		next_bpp = Tim::Bpp16;
 569: 	}
 570: 	else if (texture_buffer == ff8_externals.cardgame_tim_texture_game)
 571: 	{
 572: 		strncpy(next_texture_name, "cardgame/game", sizeof(next_texture_name));
 573: 		next_bpp = Tim::Bpp16;
 574: 	}
 575: 
 576: 	if (save_textures && *next_texture_name != '\0')
 577: 	{
 578: 		ff8_tim tim = ff8_tim();
 579: 		tim.img_w = pos_and_size[2];
 580: 		tim.img_h = pos_and_size[3];
 581: 		tim.img_data = texture_buffer;
 582: 		Tim(Tim::Bpp16, tim).save(next_texture_name);
 583: 	}
 584: 
 585: 	ff8_upload_vram(pos_and_size, texture_buffer);
 586: }
 587: 
 588: void ff8_upload_vram_triple_triad_2_texture_name(uint8_t *texture_buffer)
 589: {
 590: 	if (texture_buffer >= ff8_externals.cardgame_tim_texture_cards && texture_buffer < ff8_externals.cardgame_tim_texture_game)
 591: 	{
 592: 		strncpy(next_texture_name, "cardgame/cards", sizeof(next_texture_name));
 593: 		if (next_pal_data == (uint16_t *)texture_buffer)
 594: 		{
 595: 			if (save_textures) Tim::fromTimData(texture_buffer - 20).saveMultiPaletteGrid(next_texture_name, 28, 4, 128, 2, true);
 596: 		}
 597: 		next_bpp = Tim::Bpp8;
 598: 	}
 599: 	else if (texture_buffer >= ff8_externals.cardgame_tim_texture_icons && texture_buffer < ff8_externals.cardgame_tim_texture_font)
 600: 	{
 601: 		strncpy(next_texture_name, "cardgame/icons", sizeof(next_texture_name));
 602: 		if (next_pal_data == (uint16_t *)texture_buffer)
 603: 		{
 604: 			if (save_textures) Tim::fromTimData(texture_buffer - 20).save(next_texture_name, 0, 0, true);
 605: 		}
 606: 		next_bpp = Tim::Bpp4;
 607: 	}
 608: 	else if (texture_buffer >= ff8_externals.cardgame_tim_texture_font)
 609: 	{
 610: 		strncpy(next_texture_name, "cardgame/font", sizeof(next_texture_name));
 611: 		Tim tim = Tim::fromTimData(texture_buffer - 20);
 612: 
 613: 		palette_infos = TexturePacker::TextureInfos(tim.paletteX(), tim.paletteY(), tim.paletteWidth(), tim.paletteHeight(), Tim::Bpp16);
 614: 		texture_infos = TexturePacker::TextureInfos(tim.imageX(), tim.imageY(), tim.imageWidth(), tim.imageHeight(), tim.bpp());
 615: 
 616: 		if (next_pal_data == (uint16_t *)texture_buffer)
 617: 		{
 618: 			if (save_textures) tim.save(next_texture_name, 0, 0, true);
 619: 		}
 620: 		next_bpp = tim.bpp();
 621: 	}
 622: }
 623: 
 624: void ff8_upload_vram_triple_triad_2_palette(int16_t *pos_and_size, uint8_t *texture_buffer)
 625: {
 626: 	if (trace_all || trace_vram) ffnx_trace("%s %p\n", __func__, texture_buffer);
 627: 
 628: 	next_pal_data = (uint16_t *)texture_buffer;
 629: 	ff8_upload_vram_triple_triad_2_texture_name(texture_buffer);
 630: 	next_bpp = Tim::Bpp16;
 631: 
 632: 	ff8_upload_vram(pos_and_size, texture_buffer);
 633: }
 634: 
 635: void ff8_upload_vram_triple_triad_2_data(int16_t *pos_and_size, uint8_t *texture_buffer)
 636: {
 637: 	if (trace_all || trace_vram) ffnx_trace("%s %p\n", __func__, texture_buffer);
 638: 
 639: 	ff8_upload_vram_triple_triad_2_texture_name(texture_buffer);
 640: 
 641: 	ff8_upload_vram(pos_and_size, texture_buffer);
 642: }
 643: 
 644: int search_pos_in_toc(const uint32_t *toc, uint32_t searching_value)
 645: {
 646: 	// Find tim id relative to the start of section 38
 647: 	for (const uint32_t *cur = toc; *cur != 0; ++cur) {
 648: 		if (*cur == searching_value) {
 649: 			return int(cur - toc);
 650: 		}
 651: 	}
 652: 
 653: 	return -1;
 654: }
 655: 
 656: void ff8_wm_section_17_set_texture(int texture_id)
 657: {
 658: 	if (texture_id >= wm_wmset_wave_animations_textures.size())
 659: 	{
 660: 		return;
 661: 	}
 662: 
 663: 	const WmsetSection17Texture &tex = wm_wmset_wave_animations_textures.at(texture_id);
 664: 	Tim tim = Tim::fromTimData(tex.textureFramePositions.at(0));
 665: 	TexturePacker::TextureInfos palette_infos(tim.paletteX(), tim.paletteY(), tim.paletteWidth(), tim.paletteHeight(), Tim::Bpp16);
 666: 	TexturePacker::TextureInfos texture_infos(tex.x, tex.y, tim.imageWidth(), tim.imageHeight(), tim.bpp());
 667: 
 668: 	char texture_name[MAX_PATH] = {};
 669: 
 670: 	snprintf(texture_name, sizeof(texture_name), "world/dat/wmset/section17/texture%d", texture_id);
 671: 
 672: 	texturePacker.setTexture(texture_name, texture_infos, palette_infos, tex.textureFramePositions.size(), true);
 673: }
 674: 
 675: uint32_t ff8_wm_section_38_prepare_texture_for_upload(uint8_t *tim_file_data, ff8_tim *tim_infos)
 676: {
 677: 	uint8_t bpp = tim_file_data[4] & 0x3;
 678: 	uint32_t *wm_section_38_textures_pos = *ff8_externals.worldmap_section38_position;
 679: 	uint32_t searching_value = uint32_t(tim_file_data - (uint8_t *)wm_section_38_textures_pos);
 680: 	int timId = search_pos_in_toc(wm_section_38_textures_pos, searching_value);
 681: 
 682: 	snprintf(next_texture_name, MAX_PATH, "world/dat/wmset/section38/texture%d", timId);
 683: 
 684: 	next_bpp = Tim::Bpp(bpp);
 685: 
 686: 	uint32_t ret = ff8_externals.worldmap_prepare_tim_for_upload(tim_file_data, tim_infos);
 687: 
 688: 	if (timId >= 8)
 689: 	{
 690: 		texture_infos = TexturePacker::TextureInfos(tim_infos->img_x, tim_infos->img_y, tim_infos->img_w, tim_infos->img_h, next_bpp);
 691: 		palette_infos = TexturePacker::TextureInfos(tim_infos->pal_x, tim_infos->pal_y, tim_infos->pal_w, tim_infos->pal_h, Tim::Bpp16);
 692: 	}
 693: 	else
 694: 	{
 695: 		texture_infos = TexturePacker::TextureInfos();
 696: 		palette_infos = TexturePacker::TextureInfos();
 697: 	}
 698: 
 699: 	next_do_not_clear_old_texture = timId >= 16 && timId <= 18 || timId == 20;
 700: 
 701: 	// Open wave animation textures
 702: 	if (!*(ff8_externals.config_worldmap_textured_anim_disabled))
 703: 	{
 704: 		if (timId == 0)
 705: 		{
 706: 			// Open section 17
 707: 			uint8_t *wm_section_17_dword_2040068 = *(uint8_t **)ff8_externals.worldmap_section17_position,
 708: 				*wm_section_18_dword_2040638 = *(uint8_t **)ff8_externals.worldmap_section18_position;
 709: 
 710: 			wm_wmset_wave_animations_textures = ff8_world_wmset_wave_animations_parse(wm_section_17_dword_2040068, wm_section_18_dword_2040638 - wm_section_17_dword_2040068);
 711: 		}
 712: 		else if (timId == 21)
 713: 		{
 714: 			if (save_textures)
 715: 			{
 716: 				// Save first texture of section 17, using the palette from section38/texture21
 717: 				ff8_world_wmset_wave_animations_save_texture(wm_wmset_wave_animations_textures, 0, "world/dat/wmset/section17", Tim::fromTimData(tim_file_data));
 718: 			}
 719: 		}
 720: 		else if (timId == 22)
 721: 		{
 722: 			if (save_textures)
 723: 			{
 724: 				// Save second and third textures of section 17, using the palette from section38/texture22
 725: 				Tim tim = Tim::fromTimData(tim_file_data);
 726: 				ff8_world_wmset_wave_animations_save_texture(wm_wmset_wave_animations_textures, 1, "world/dat/wmset/section17", tim);
 727: 				ff8_world_wmset_wave_animations_save_texture(wm_wmset_wave_animations_textures, 2, "world/dat/wmset/section17", tim);
 728: 			}
 729: 		}
 730: 		else if (timId == 34) // After uploads of section38/texture21 & 22
 731: 		{
 732: 			for (int i = 0; i < wm_wmset_wave_animations_textures.size(); ++i)
 733: 			{
 734: 				ff8_wm_section_17_set_texture(i);
 735: 			}
 736: 		}
 737: 	}
 738: 
 739: 	if (!*(ff8_externals.config_worldmap_color_anim_disabled))
 740: 	{
 741: 		if (timId == 0)
 742: 		{
 743: 			// Open section 41
 744: 			uint8_t *wm_section_41_animation_palettes_dword_203FAF8 = (uint8_t *)*ff8_externals.worldmap_section41_position,
 745: 				*wm_section_42_dword_2040690 = (uint8_t *)*ff8_externals.worldmap_section42_position;
 746: 
 747: 			wm_wmset_palette_animations_textures = ff8_world_wmset_palette_animations_parse(wm_section_41_animation_palettes_dword_203FAF8, wm_section_42_dword_2040690 - wm_section_41_animation_palettes_dword_203FAF8);
 748: 		}
 749: 
 750: 		if (palette_infos.isValid() && wm_wmset_palette_animations_textures.contains(uint32_t(palette_infos.x()) | (uint32_t(palette_infos.y()) << 16)))
 751: 		{
 752: 			const WmsetSection41Texture &tex = wm_wmset_palette_animations_textures[uint32_t(palette_infos.x()) | (uint32_t(palette_infos.y()) << 16)];
 753: 			if (trace_all || trace_vram) ffnx_trace("%s: set animation palette source=(%d, %d)\n", __func__, tex.srcX, tex.srcY);
 754: 			next_texture_count = tex.height;
 755: 			TexturePacker::TextureInfos palette(tex.x, tex.y, 256, tex.height, Tim::Bpp16);
 756: 			texturePacker.setTexture(nullptr, palette, palette);
 757: 
 758: 			if (save_textures)
 759: 			{
 760: 				ff8_world_wmset_palette_animations_save_texture(tex, next_texture_name, Tim::fromTimData(tim_file_data));
 761: 			}
 762: 		}
 763: 	}
 764: 
 765: 	if (save_textures)
 766: 	{
 767: 		if (timId < 8)
 768: 		{
 769: 			Tim::fromTimData(tim_file_data).saveMultiPaletteGrid(next_texture_name, 8, 4, 0, 4, true);
 770: 		}
 771: 		else if (palette_infos.h() > 1)
 772: 		{
 773: 			for (int pal = 0; pal < palette_infos.h(); ++pal) {
 774: 				Tim::fromTimData(tim_file_data).save(next_texture_name, 0, pal, true);
 775: 			}
 776: 		}
 777: 		else
 778: 		{
 779: 			Tim::fromTimData(tim_file_data).save(next_texture_name, 0, 0, true);
 780: 		}
 781: 	}
 782: 
 783: 	return ret;
 784: }
 785: 
 786: void ff8_upload_vram_wm_section_38_palette(int16_t *pos_and_size, uint8_t *texture_buffer)
 787: {
 788: 	if (trace_all || trace_vram) ffnx_trace("%s %p\n", __func__, texture_buffer);
 789: 
 790: 	next_pal_data = (uint16_t *)texture_buffer;
 791: 
 792: 	ff8_upload_vram(pos_and_size, texture_buffer);
 793: 
 794: 	next_pal_data = nullptr;
 795: }
 796: 
 797: Tim ff8_wm_set_texture_name_from_section_position(uint8_t section_number, uint32_t *section_toc, uint8_t *tim_file_data)
 798: {
 799: 	if (trace_all || trace_vram) ffnx_trace("%s: tim_file_data=%p section%d_pointer=%p\n", __func__, tim_file_data, section_number, section_toc);
 800: 
 801: 	uint32_t searching_value = uint32_t(tim_file_data - (uint8_t *)section_toc);
 802: 	int timId = search_pos_in_toc(section_toc, searching_value);
 803: 
 804: 	next_do_not_clear_old_texture = section_number == 40 && timId == 0;
 805: 
 806: 	snprintf(next_texture_name, MAX_PATH, "world/dat/wmset/section%d/texture%d", section_number, timId);
 807: 
 808: 	Tim tim = Tim::fromTimData(tim_file_data);
 809: 
 810: 	next_bpp = tim.bpp();
 811: 
 812: 	texture_infos = TexturePacker::TextureInfos(tim.imageX(), tim.imageY(), tim.imageWidth(), tim.imageHeight(), tim.bpp());
 813: 	if (tim.bpp() != Tim::Bpp16) {
 814: 		palette_infos = TexturePacker::TextureInfos(tim.paletteX(), tim.paletteY(), tim.paletteWidth(), tim.paletteHeight(), Tim::Bpp16);
 815: 		next_pal_data = tim.paletteData();
 816: 	}
 817: 
 818: 	return tim;
 819: }
 820: 
 821: void ff8_wm_section_17_upload(uint8_t *tim_file_data, int16_t x, int16_t y)
 822: {
 823: 	if (trace_all || trace_vram) ffnx_trace("%s: pos=(%d, %d)\n", __func__, x, y);
 824: 
 825: 	Tim tim = Tim::fromTimData(tim_file_data);
 826: 
 827: 	next_bpp = tim.bpp();
 828: 	palette_infos = TexturePacker::TextureInfos(); // Invalid palette
 829: 	texture_infos = TexturePacker::TextureInfos(x, y, tim.imageWidth(), tim.imageHeight(), tim.bpp());
 830: 
 831: 	int texture_id = 0;
 832: 	for (const WmsetSection17Texture &texture: wm_wmset_wave_animations_textures) {
 833: 		int frame_id = 0;
 834: 		for (const uint8_t *frameTexturePos: texture.textureFramePositions) {
 835: 			if (frameTexturePos == tim_file_data) {
 836: 				texturePacker.setCurrentAnimationFrame(x, y, frame_id);
 837: 
 838: 				((void(*)(uint8_t*,int16_t,int16_t))ff8_externals.sub_541AE0)(tim_file_data, x, y);
 839: 
 840: 				return;
 841: 			}
 842: 			++frame_id;
 843: 		}
 844: 
 845: 		++texture_id;
 846: 	}
 847: 
 848: 	((void(*)(uint8_t*,int16_t,int16_t))ff8_externals.sub_541AE0)(tim_file_data, x, y);
 849: }
 850: 
 851: void ff8_wm_section_39_upload(uint8_t *tim_file_data)
 852: {
 853: 	Tim tim = ff8_wm_set_texture_name_from_section_position(39, *ff8_externals.worldmap_section39_position, tim_file_data);
 854: 
 855: 	if (save_textures) {
 856: 		tim.save(next_texture_name, 0, 0, true);
 857: 	}
 858: 
 859: 	((void(*)(uint8_t*))ff8_externals.worldmap_sub_541970_upload_tim)(tim_file_data);
 860: 
 861: 	next_pal_data = nullptr;
 862: }
 863: 
 864: void ff8_wm_section_40_upload(uint8_t *tim_file_data)
 865: {
 866: 	Tim tim = ff8_wm_set_texture_name_from_section_position(40, *ff8_externals.worldmap_section40_position, tim_file_data);
 867: 
 868: 	if (save_textures) {
 869: 		tim.saveMultiPaletteGrid(next_texture_name, 8, 4, 0, 4, true);
 870: 	}
 871: 
 872: 	((void(*)(uint8_t*))ff8_externals.worldmap_sub_541970_upload_tim)(tim_file_data);
 873: 
 874: 	next_pal_data = nullptr;
 875: }
 876: 
 877: void ff8_wm_section_41_upload_palette(int16_t *pos_and_size, uint8_t *texture_buffer)
 878: {
 879: 	if (trace_all || trace_vram) ffnx_trace("%s", __func__);
 880: 
 881: 	next_pal_data = (uint16_t *)texture_buffer;
 882: 
 883: 	ff8_upload_vram(pos_and_size, texture_buffer);
 884: 
 885: 	next_pal_data = nullptr;
 886: }
 887: 
 888: void ff8_wm_section_42_upload(uint8_t *tim_file_data)
 889: {
 890: 	Tim tim = ff8_wm_set_texture_name_from_section_position(42, *ff8_externals.worldmap_section42_position, tim_file_data);
 891: 
 892: 	if (save_textures) {
 893: 		tim.save(next_texture_name, 0, 0, true);
 894: 	}
 895: 
 896: 	((void(*)(uint8_t*))ff8_externals.worldmap_sub_541970_upload_tim)(tim_file_data);
 897: 
 898: 	next_pal_data = nullptr;
 899: }
 900: 
 901: int ff8_wm_chara_one_read_file(int fd, uint8_t *data, size_t size)
 902: {
 903: 	if (trace_all || trace_vram) ffnx_trace("%s\n", __func__);
 904: 
 905: 	int read = ((int(*)(int, uint8_t *, size_t))ff8_externals.chara_one_read_file)(fd, data, size);
 906: 
 907: 	chara_one_world_texture_offsets = ff8_world_chara_one_parse_models(data, read);
 908: 	chara_one_world_data = data;
 909: 
 910: 	if (save_textures) {
 911: 		char filename[MAX_PATH];
 912: 		snprintf(filename, sizeof(filename), "world/esk/chara_one");
 913: 		ff8_world_chara_one_model_save_textures(chara_one_world_texture_offsets, data, filename);
 914: 	}
 915: 
 916: 	return read;
 917: }
 918: 
 919: int ff8_wm_chara_one_upload_texture_2(char *image_buffer, char bpp, char a3, int x, int16_t y, int w, int16_t h)
 920: {
 921: 	if (trace_all || trace_vram) ffnx_trace("%s\n", __func__);
 922: 
 923: 	int chara_one_offset = int(*(ff8_externals.chara_one_data_start) - chara_one_world_data);
 924: 	int model_id = 0;
 925: 	for (const CharaOneModelTextures &textures: chara_one_world_texture_offsets) {
 926: 		int texture_id = 0;
 927: 		for (const uint32_t texture_offset: textures) {
 928: 			if (texture_offset == chara_one_offset) {
 929: 				next_bpp = Tim::Bpp(bpp);
 930: 				snprintf(next_texture_name, MAX_PATH, "world/esk/chara_one/model%d-%d", model_id, texture_id);
 931: 
 932: 				return ((int(*)(char *, char, char, int, __int16, int, __int16))ff8_externals.chara_one_upload_texture)(image_buffer, bpp, a3, x, y, w, h);
 933: 			}
 934: 			++texture_id;
 935: 		}
 936: 
 937: 		++model_id;
 938: 	}
 939: 
 940: 	return ((int(*)(char *, char, char, int, __int16, int, __int16))ff8_externals.chara_one_upload_texture)(image_buffer, bpp, a3, x, y, w, h);
 941: }
 942: 
 943: void ff8_wm_chara_one_upload_palette_2(int16_t *pos_and_size, uint8_t *texture_buffer)
 944: {
 945: 	next_pal_data = (uint16_t *)texture_buffer;
 946: 
 947: 	ff8_upload_vram(pos_and_size, texture_buffer);
 948: 
 949: 	next_pal_data = nullptr;
 950: }
 951: 
 952: void ff8_wm_update_fence_animation()
 953: {
 954: 	uint8_t current_disk = (*ff8_externals.savemap_field)->curr_disk;
 955: 
 956: 	if (trace_all || trace_vram) ffnx_trace("%s: current_disk=%d\n", __func__, current_disk);
 957: 
 958: 	// Disable the animation if not in disk 4
 959: 	if (current_disk == 4) {
 960: 		((void(*)())ff8_externals.sub_557140)();
 961: 	}
 962: }
 963: 
 964: int ff8_wm_open_data(const char *path, int32_t pos, uint32_t size, void *data)
 965: {
 966: 	if (strstr(path, "texl.obj") != nullptr)
 967: 	{
 968: 		next_texl_id = pos / 0x12800;
 969: 
 970: 		if (trace_all || trace_vram) ffnx_trace("Next texl ID: %d\n", next_texl_id);
 971: 	}
 972: 
 973: 	return ff8_externals.open_file_world(path, pos, size, data);
 974: }
 975: 
 976: void ff8_wm_texl_palette_upload_vram(int16_t *pos_and_size, uint8_t *texture_buffer)
 977: {
 978: 	Tim tim = Tim::fromTimData(texture_buffer - 20);
 979: 
 980: 	if (trace_all || trace_vram) ffnx_trace("%s texl_id=%d pos=(%d, %d) palPos=(%d, %d)\n", __func__, next_texl_id, tim.imageX(), tim.imageY(), tim.paletteX(), tim.paletteY());
 981: 
 982: 	next_bpp = Tim::Bpp8;
 983: 
 984: 	ff8_upload_vram(pos_and_size, texture_buffer);
 985: 
 986: 	// Worldmap texture fix
 987: 
 988: 	uint16_t oldX = 16 * (next_texl_id - 2 * ((next_texl_id / 2) & 1) + (next_texl_id & 1)), oldY = ((next_texl_id / 2) & 1) ? 384 : 256;
 989: 
 990: 	if (next_texl_id == 18 || next_texl_id == 19)
 991: 	{
 992: 		oldX = next_texl_id & 1 ? 96 : 64;
 993: 		oldY = 384;
 994: 	}
 995: 
 996: 	uint16_t newX = 0;
 997: 
 998: 	if (pos_and_size[0] == 320 && pos_and_size[1] == 224)
 999: 	{
1000: 		newX = 256;
1001: 	}
1002: 	else if (pos_and_size[0] == 320 && pos_and_size[1] == 240)
1003: 	{
1004: 		newX = 384;
1005: 	}
1006: 	else if (pos_and_size[0] == 576 && pos_and_size[1] == 224)
1007: 	{
1008: 		newX = 512;
1009: 	}
1010: 	else if (pos_and_size[0] == 576 && pos_and_size[1] == 240)
1011: 	{
1012: 		newX = 640;
1013: 	}
1014: 
1015: 	if (next_texl_id == 16 || next_texl_id == 17 || next_texl_id > 19)
1016: 	{
1017: 		if (trace_all || trace_vram) ffnx_warning("%s: texl id not supported %d\n", __func__, next_texl_id);
1018: 		return; // TODO
1019: 	}
1020: 
1021: 	TexturePacker::TextureInfos oldTexture(oldX, oldY, tim.imageWidth() / 4, tim.imageHeight() / 2, Tim::Bpp4),
1022: 		newTexture(newX, 256, tim.imageWidth(), tim.imageHeight(), Tim::Bpp(tim.bpp()));
1023: 
1024: 	// Allow to mod via texl textures
1025: 	snprintf(next_texture_name, MAX_PATH, "world/dat/texl/texture%d", next_texl_id);
1026: 
1027: 	if (save_textures)
1028: 	{
1029: 		tim.saveMultiPaletteGrid(next_texture_name, 4, 4, 0, 4, true);
1030: 	}
1031: 
1032: 	if (! ff8_worldmap_internal_highres_textures)
1033: 	{
1034: 		return;
1035: 	}
1036: 
1037: 	// Redirect internal texl textures
1038: 	if (!texturePacker.setTextureRedirection(next_texture_name, oldTexture, newTexture, tim))
1039: 	{
1040: 		return;
1041: 	}
1042: 
1043: 	*next_texture_name = '\0';
1044: 
1045: 	int section = 16 + oldX / 64;
1046: 	// Reload texture
1047: 	struc_50 *stru50 = ff8_externals.psx_texture_pages[0].struc_50_array + section;
1048: 
1049: 	for (int page = 0; page < 8; ++page) {
1050: 		if ((stru50->initialized >> page) & 1) {
1051: 			ff8_texture_set *texture_set = (struct ff8_texture_set *)stru50->texture_page[page].tri_gfxobj->hundred_data->texture_set;
1052: 
1053: 			common_unload_texture((struct texture_set *)texture_set);
1054: 			common_load_texture((struct texture_set *)texture_set, texture_set->tex_header, texture_set->texture_format);
1055: 		}
1056: 	}
1057: }
1058: 
1059: void ff8_field_mim_palette_upload_vram(int16_t *pos_and_size, uint8_t *texture_buffer)
1060: {
1061: 	if (trace_all || trace_vram) ffnx_trace("%s\n", __func__);
1062: 
1063: 	if (save_textures_legacy || save_textures) {
1064: 		if (mim_texture_buffer == nullptr) {
1065: 			mim_texture_buffer = new uint8_t[438272];
1066: 		}
1067: 		memcpy(mim_texture_buffer, texture_buffer, 438272);
1068: 	}
1069: 
1070: 	ff8_upload_vram(pos_and_size, texture_buffer);
1071: }
1072: 
1073: uint32_t ff8_field_read_map_data(char *filename, uint8_t *map_data)
1074: {
1075: 	if (trace_all || trace_vram) ffnx_trace("%s %s\n", __func__, filename);
1076: 
1077: 	uint32_t ret = ff8_externals.sm_pc_read(filename, map_data);
1078: 
1079: 	char tex_directory[MAX_PATH] = {}, tex_filename[MAX_PATH] = {};
1080: 
1081: 	snprintf(tex_directory, sizeof(tex_directory), "field/mapdata/%s", get_current_field_name());
1082: 	snprintf(tex_filename, sizeof(tex_filename), "%s/%s", tex_directory, get_current_field_name());
1083: 
1084: 	if (save_textures_legacy) {
1085: 		snprintf(tex_directory, sizeof(tex_directory), "field/mapdata/%.2s/%s/%s", get_current_field_name(), get_current_field_name(), get_current_field_name());
1086: 		ff8_background_save_textures_legacy(ff8_background_parse_tiles(map_data), mim_texture_buffer, tex_directory);
1087: 
1088: 		return ret;
1089: 	} else if (save_textures) {
1090: 		ff8_background_save_textures(ff8_background_parse_tiles(map_data), mim_texture_buffer, tex_filename);
1091: 
1092: 		return ret;
1093: 	}
1094: 
1095: 	char tex_abs_directory[MAX_PATH] = {};
1096: 	snprintf(tex_abs_directory, sizeof(tex_abs_directory), "%s/%s/%s", basedir, mod_path.c_str(), tex_directory);
1097: 	bool has_dir = dirExists(tex_abs_directory);
1098: 
1099: 	if (!has_dir && (trace_all || trace_loaders || trace_vram)) {
1100: 		ffnx_warning("Directory does not exist, fallback to Tonberry compatibility layer: %s\n", tex_abs_directory);
1101: 	}
1102: 
1103: 	std::vector<Tile> tiles;
1104: 
1105: 	if (has_dir) {
1106: 		tiles = ff8_background_parse_tiles(map_data);
1107: 	}
1108: 
1109: 	if (!has_dir || !texturePacker.setTextureBackground(tex_filename, 0, 256, VRAM_PAGE_MIM_MAX_COUNT * TEXTURE_WIDTH_BPP16, TEXTURE_HEIGHT, tiles)) {
1110: 		snprintf(tex_directory, sizeof(tex_directory), "field/mapdata/%.2s/%s/%s", get_current_field_name(), get_current_field_name(), get_current_field_name());
1111: 
1112: 		for (int i = 0; i < VRAM_PAGE_MIM_MAX_COUNT; ++i) {
1113: 			snprintf(tex_filename, sizeof(tex_filename), "%s_%d", tex_directory, i);
1114: 			const int x = i * TEXTURE_WIDTH_BPP16, y = 256;
1115: 			texturePacker.setTexture(tex_filename, TexturePacker::TextureInfos(x, y, TEXTURE_WIDTH_BPP16, TEXTURE_HEIGHT, Tim::Bpp16, true), TexturePacker::TextureInfos(), 0);
1116: 			// Force texture_reload_hack
1117: 			texturePacker.setCurrentAnimationFrame(x, y, -1);
1118: 		}
1119: 	}
1120: 
1121: 	return ret;
1122: }
1123: 
1124: int ff8_field_chara_one_read_file_header(int fd, uint8_t *const data, size_t size)
1125: {
1126: 	int read = ((int(*)(int,uint8_t*const,size_t))ff8_externals.chara_one_read_file)(fd, data, size);
1127: 
1128: 	if (trace_all || trace_vram) ffnx_trace("%s: size=%d\n", __func__, size);
1129: 
1130: 	chara_one_models = ff8_chara_one_parse_models(data, size);
1131: 	chara_one_loaded_models.clear();
1132: 	chara_one_current_model = 0;
1133: 	chara_one_current_mch = 0;
1134: 	chara_one_current_texture = 0;
1135: 
1136: 	return read;
1137: }
1138: 
1139: int ff8_field_chara_one_seek_to_model(int fd, int pos, int whence)
1140: {
1141: 	if (trace_all || trace_vram) ffnx_trace("%s: pos=0x%X whence=%d\n", __func__, pos, whence);
1142: 
1143: 	chara_one_current_pos = pos;
1144: 
1145: 	return ((int(*)(int,int,int))ff8_externals.chara_one_seek_file)(fd, pos, whence);
1146: }
1147: 
1148: int ff8_field_chara_one_read_model(int fd, uint8_t *const data, size_t size)
1149: {
1150: 	int read = ((int(*)(int,uint8_t*const,size_t))ff8_externals.chara_one_read_file)(fd, data, size);
1151: 
1152: 	if (trace_all || trace_vram) ffnx_trace("%s: size=%d\n", __func__, size);
1153: 
1154: 	if (chara_one_models.contains(chara_one_current_pos)) {
1155: 		if (save_textures) {
1156: 			char filename[MAX_PATH];
1157: 			snprintf(filename, sizeof(filename), "field/model/second_chr");
1158: 			ff8_chara_one_model_save_textures(chara_one_models[chara_one_current_pos], data, filename);
1159: 		}
1160: 
1161: 		chara_one_loaded_models.push_back(chara_one_current_pos);
1162: 	}
1163: 
1164: 	return read;
1165: }
1166: 
1167: int ff8_field_chara_one_read_mch(int fd, uint8_t *const data, size_t size)
1168: {
1169: 	int read = ((int(*)(int,uint8_t*const,size_t))ff8_externals.chara_one_read_file)(fd, data, size);
1170: 
1171: 	if (trace_all || trace_vram) ffnx_trace("%s: size=%d\n", __func__, size);
1172: 
1173: 	int id = 0;
1174: 	for (uint32_t addr: chara_one_loaded_models) {
1175: 		if (chara_one_models[addr].isMch) {
1176: 			if (id == chara_one_current_mch) {
1177: 				ff8_mch_parse_model(chara_one_models[addr], data, size);
1178: 				if (save_textures) {
1179: 					char filename[MAX_PATH];
1180: 					snprintf(filename, sizeof(filename), "field/model/main_chr");
1181: 					ff8_chara_one_model_save_textures(chara_one_models[addr], data, filename);
1182: 				}
1183: 
1184: 				break;
1185: 			}
1186: 			++id;
1187: 		}
1188: 	}
1189: 
1190: 	++chara_one_current_mch;
1191: 
1192: 	return read;
1193: }
1194: 
1195: int ff8_field_texture_upload_one(char *image_buffer, char bpp, char a3, int x, int16_t y, int w, int16_t h)
1196: {
1197: 	if (trace_all || trace_vram) ffnx_trace("%s bpp=%d a3=%d image_buffer=0x%X\n", __func__, bpp, a3, image_buffer);
1198: 
1199: 	while (chara_one_current_model < chara_one_loaded_models.size()) {
1200: 		CharaOneModel model = chara_one_models[chara_one_loaded_models.at(chara_one_current_model)];
1201: 
1202: 		if (chara_one_current_texture < model.texturesData.size()) {
1203: 			next_bpp = Tim::Bpp(bpp);
1204: 			snprintf(next_texture_name, MAX_PATH, "field/model/%s_chr/%s-%d", model.isMch ? "main" : "second", model.name, chara_one_current_texture);
1205: 
1206: 			++chara_one_current_texture;
1207: 			break;
1208: 		}
1209: 
1210: 		++chara_one_current_model;
1211: 		chara_one_current_texture = 0;
1212: 	}
1213: 
1214: 	return ((int(*)(char*,char,char,int,int16_t,int,int16_t))ff8_externals.chara_one_upload_texture)(image_buffer, bpp, a3, x, y, w, h);
1215: }
1216: 
1217: void ff8_field_effects_upload_vram1(int16_t *pos_and_size, uint8_t *texture_buffer)
1218: {
1219: 	Tim::Bpp bpp = Tim::Bpp4;
1220: 	char texture_name[MAX_PATH];
1221: 
1222: 	snprintf(texture_name, sizeof(texture_name), "field/mapdata/%s/%s_pmp", get_current_field_name(), get_current_field_name());
1223: 
1224: 	if (save_textures) {
1225: 		ff8_tim t = ff8_tim();
1226: 		t.pal_data = (uint16_t*)(texture_buffer - 512);
1227: 		t.pal_w = 256;
1228: 		t.pal_h = 1;
1229: 		t.img_data = texture_buffer;
1230: 		t.img_w = pos_and_size[2];
1231: 		t.img_h = pos_and_size[3] * 2; // This upload and the next one together
1232: 		Tim(bpp, t).save(texture_name);
1233: 	}
1234: 
1235: 	ff8_upload_vram(pos_and_size, texture_buffer);
1236: 
1237: 	// This upload and the next one together
1238: 	texturePacker.setTexture(texture_name, TexturePacker::TextureInfos(pos_and_size[0], pos_and_size[1], pos_and_size[2], pos_and_size[3] * 2, bpp));
1239: }
1240: 
1241: int battle_get_texture_file_name_index(void *texture_buffer)
1242: {
1243: 	for (int i = 0; i < battle_texture_data_list_size; ++i) {
1244: 		if (battle_texture_data_list.at(i).data == texture_buffer) {
1245: 			return i;
1246: 		}
1247: 	}
1248: 
1249: 	return -1;
1250: }
1251: 
1252: int16_t ff8_battle_open_and_read_file(int fileId, void *data, int a3, int callback)
1253: {
1254: 	if (trace_all || trace_vram) ffnx_trace("%s: %d => %s\n", __func__, fileId, ff8_externals.battle_filenames[fileId]);
1255: 
1256: 	battle_texture_id = 0;
1257: 	if (stricmp(ff8_externals.battle_filenames[fileId], "B0WAVE.DAT") == 0) {
1258: 		// Fix redundant texture
1259: 		strncpy(battle_texture_name, "battle/A8DEF.TIM", sizeof(battle_texture_name));
1260: 
1261: 		if (trace_all || trace_vram) ffnx_trace("%s: rename texture to %s\n", __func__, battle_texture_name);
1262: 	} else {
1263: 		snprintf(battle_texture_name, sizeof(battle_texture_name), "battle/%s", ff8_externals.battle_filenames[fileId]);
1264: 	}
1265: 
1266: 	// Remember texture name for later
1267: 	BattleTextureFileName tex = BattleTextureFileName();
1268: 	strncpy(tex.file_name, battle_texture_name, sizeof(tex.file_name));
1269: 	tex.data = data;
1270: 
1271: 	int index = battle_get_texture_file_name_index(data);
1272: 	if (index < 0) {
1273: 		battle_texture_data_list[battle_texture_data_list_cursor] = tex;
1274: 
1275: 		battle_texture_data_list_cursor = (battle_texture_data_list_cursor + 1) % battle_texture_data_list_size;
1276: 	} else {
1277: 		if (trace_all || trace_vram) ffnx_trace("%s: texture found in the list at index %d\n", __func__, index);
1278: 
1279: 		battle_texture_data_list[index] = tex;
1280: 	}
1281: 
1282: 	return ((int16_t(*)(int,void*,int,int))ff8_externals.battle_open_file)(fileId, data, a3, callback);
1283: }
1284: 
1285: void *ff8_battle_open_effect(const char *fileName, void *data, int dataSize, DWORD *outSize)
1286: {
1287: 	if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, fileName);
1288: 
1289: 	battle_texture_id = 0;
1290: 	snprintf(battle_texture_name, sizeof(battle_texture_name), "magic/%s", fileName);
1291: 
1292: 	return ((void *(*)(const char*,void*,int,DWORD*))ff8_externals.load_magic_data_sub_571900)(fileName, data, dataSize, outSize);
1293: }
1294: 
1295: size_t ff8_battle_read_file(char *fileName, void *data)
1296: {
1297: 	if (trace_all || trace_vram) ffnx_trace("%s: %s\n", __func__, fileName);
1298: 
1299: 	size_t file_size = ff8_externals.sm_pc_read(fileName, data);
1300: 
1301: 	if (save_textures && StrStrIA(fileName, ".X") != nullptr) {
1302: 		ff8_battle_stage_parse_geometry((uint8_t *)data, file_size, stage);
1303: 	}
1304: 
1305: 	return file_size;
1306: }
1307: 
1308: int battle_get_texture_header_index(uint8_t *texture_buffer)
1309: {
1310: 	for (int i = 0; i < battle_texture_data_list_size; ++i) {
1311: 		if (battle_texture_headers.at(i).data == texture_buffer) {
1312: 			return i;
1313: 		}
1314: 	}
1315: 
1316: 	return -1;
1317: }
1318: 
1319: void battle_read_effect_alloc()
1320: {
1321: 	if (trace_all || trace_vram) ffnx_trace("%s: magic_id=%d\n", __func__, *ff8_externals.battle_magic_id);
1322: 
1323: 	// Reset list
1324: 	for (int i = 0; i < battle_texture_headers.size(); ++i) {
1325: 		battle_texture_headers[i] = BattleTextureHeader();
1326: 	}
1327: 	battle_texture_headers_cursor = 0;
1328: 	// Guess the filename until a file is actually opened
1329: 	battle_texture_id = 0;
1330: 	snprintf(battle_texture_name, sizeof(battle_texture_name), "magic/mag%03d.tim", *ff8_externals.battle_magic_id);
1331: 
1332: 	((void(*)())ff8_externals.sub_571870)();
1333: }
1334: 
1335: void battle_set_texture_header(uint8_t file_id, bool is_palette, uint8_t file_relative_id, int16_t *pos_and_size, uint8_t *texture_buffer)
1336: {
1337: 	if (trace_all || trace_vram) ffnx_trace("%s: effect_id=%d file_id=%d is_palette=%d file_relative_id=%d pos_and_size=(%d, %d, %d, %d) texture_buffer=0x%X battle_texture_headers_cursor=%d\n", __func__,
1338: 		*ff8_externals.battle_magic_id, file_id, is_palette, file_relative_id,
1339: 		pos_and_size[0], pos_and_size[1], pos_and_size[2], pos_and_size[3], texture_buffer, battle_texture_headers_cursor);
1340: 
1341: 	BattleTextureHeader header = BattleTextureHeader();
1342: 	header.effect_id = *ff8_externals.battle_magic_id;
1343: 	header.file_id = file_id;
1344: 	header.is_palette = is_palette;
1345: 	header.file_relative_id = file_relative_id;
1346: 	header.x = pos_and_size[0];
1347: 	header.y = pos_and_size[1];
1348: 	header.w = pos_and_size[2];
1349: 	header.h = pos_and_size[3];
1350: 	header.data = texture_buffer;
1351: 
1352: 	int index = battle_get_texture_header_index(texture_buffer);
1353: 
1354: 	if (index < 0) {
1355: 		battle_texture_headers[battle_texture_headers_cursor] = header;
1356: 
1357: 		battle_texture_headers_cursor = (battle_texture_headers_cursor + 1) % battle_texture_data_list_size;
1358: 	} else {
1359: 		battle_texture_headers[index] = header;
1360: 	}
1361: }
1362: 
1363: void ff8_battle_set_palette_data_from_mag(int file_relative_id)
1364: {
1365: 	if (trace_all || trace_vram) ffnx_trace("%s: file_relative_id=%d\n", __func__, file_relative_id);
1366: 
1367: 	int file_ext_number = *(uint8_t *)(*(*ff8_externals.effect_struct_27973EC + 42) + file_relative_id);
1368: 
1369: 	uint8_t *data = ff8_externals.mag_data_dword_2798A68[file_ext_number];
1370: 	uint8_t *texture_data = data + *(DWORD *)(data + 8) + *(DWORD *)(data + *(DWORD *)(data + 8) + 4 * file_relative_id);
1371: 	*(*ff8_externals.effect_struct_2797624 + 63) = DWORD(texture_data);
1372: 	*(*ff8_externals.effect_struct_2797624 + 60) = *(*ff8_externals.effect_struct_27973EC + 39) + 8 * file_relative_id;
1373: 
1374: 	battle_set_texture_header(file_ext_number, true, file_relative_id, *(int16_t **)(*ff8_externals.effect_struct_2797624 + 60), texture_data);
1375: }
1376: 
1377: void ff8_battle_set_texture_data_from_mag(int file_relative_id)
1378: {
1379: 	if (trace_all || trace_vram) ffnx_trace("%s: file_relative_id=%d\n", __func__, file_relative_id);
1380: 
1381: 	BYTE file_ext_infos = *(BYTE *)(*(*ff8_externals.effect_struct_27973EC + 41) + file_relative_id);
1382: 	int file_ext_number = file_ext_infos & 0x7F;
1383: 
1384: 	*(*ff8_externals.effect_struct_2797624 + 62) = file_ext_infos & 0x80;
1385: 	uint8_t *texture_data1 = ff8_externals.mag_data_dword_2798A68[file_ext_number] + *(DWORD *)(ff8_externals.mag_data_dword_2798A68[file_ext_number] + 20);
1386: 	uint8_t *texture_data = texture_data1 + ((unsigned int)0xFFFFFF & *(DWORD *)(texture_data1 + 4 * file_relative_id));
1387: 	*(*ff8_externals.effect_struct_2797624 + 63) = DWORD(texture_data);
1388: 	int pos_and_size = *(*ff8_externals.effect_struct_27973EC + 38) + 8 * file_relative_id;
1389: 	*(*ff8_externals.effect_struct_2797624 + 60) = pos_and_size;
1390: 	WORD *v4 = *(WORD **)(*ff8_externals.effect_struct_2797624 + 60);
1391: 	*(WORD *)&pos_and_size = *v4;
1392: 	*(*ff8_externals.effect_struct_2797624 + 61) = *(*ff8_externals.effect_struct_2797624 + 62) | *(*ff8_externals.dword_27973E8 + 146) & 0x60 | ((v4[1] & 0x100 | (pos_and_size >> 2) & 0x3F0) >> 4);
1393: 
1394: 	battle_set_texture_header(file_ext_number, false, file_relative_id, *(int16_t **)(*ff8_externals.effect_struct_2797624 + 60), texture_data);
1395: }
1396: 
1397: void *battle_set_texture_action_upload_raw_pal_call(int16_t *pos_and_size, char *texture_data)
1398: {
1399: 	if (trace_all || trace_vram) ffnx_trace("%s: pos=(%d, %d) size=(%d, %d) texture_data=0x%X\n", __func__, pos_and_size[0], pos_and_size[1], pos_and_size[2], pos_and_size[3], texture_data);
1400: 
1401: 	battle_set_texture_header(0, true, 0, pos_and_size, (uint8_t *)texture_data);
1402: 
1403: 	return ((void*(*)(int16_t*,char*))ff8_externals.sub_505DF0)(pos_and_size, texture_data);
1404: }
1405: 
1406: void ff8_battle_upload_texture_raw(int16_t *pos_and_size, uint8_t *texture_buffer)
1407: {
1408: 	int index = battle_get_texture_header_index(texture_buffer);
1409: 
1410: 	if (index >= 0) {
1411: 		const BattleTextureHeader &header = battle_texture_headers.at(index);
1412: 
1413: 		if (trace_all || trace_vram) ffnx_trace("%s: texture identified is_pal=%d rect=(%d, %d, %d, %d) effect_id=%d file_id=%d file_relative_id=%d\n", __func__,
1414: 			header.is_palette, header.x, header.y, header.w, header.h, header.effect_id, header.file_id, header.file_relative_id);
1415: 
1416: 		if (header.is_palette) {
1417: 			next_pal_data = (uint16_t *)texture_buffer;
1418: 		} else {
1419: 			uint16_t minX = 0xFFFF, maxX = 0, minY = 0xFFFF, maxY = 0;
1420: 			int index2 = index;
1421: 
1422: 			for (int i = 1; i < battle_texture_data_list_size; ++i) {
1423: 				const BattleTextureHeader &header2 = battle_texture_headers.at((index + i) % battle_texture_data_list_size);
1424: 				if (!header2.is_palette) {
1425: 					break;
1426: 				}
1427: 
1428: 				if (minX > header2.x) {
1429: 					minX = header2.x;
1430: 				}
1431: 				if (minY > header2.y) {
1432: 					minY = header2.y;
1433: 				}
1434: 				if (maxX < header2.x + header2.w) {
1435: 					maxX = header2.x + header2.w;
1436: 				}
1437: 				if (maxY < header2.y + header2.h) {
1438: 					maxY = header2.y + header2.h;
1439: 				}
1440: 			}
1441: 
1442: 			snprintf(next_texture_name, sizeof(next_texture_name), "magic/MAG%03d_B.%02d-%d", header.effect_id, header.file_id, header.file_relative_id);
1443: 				bool texture_saved = false;
1444: 
1445: 			if (minY != 0xFFFF) {
1446: 				next_bpp = maxX - minX == 16 ? Tim::Bpp4 : Tim::Bpp8;
1447: 				texture_infos = TexturePacker::TextureInfos(pos_and_size[0], pos_and_size[1], pos_and_size[2], pos_and_size[3], next_bpp);
1448: 				palette_infos = TexturePacker::TextureInfos(minX, minY, maxX - minX, maxY - minY, next_bpp);
1449: 
1450: 				if (save_textures) {
1451: 					int last_pal_x = -1, last_pal_y = -1;
1452: 
1453: 					for (int i = 1; i < battle_texture_data_list_size; ++i) {
1454: 						const BattleTextureHeader &header2 = battle_texture_headers.at((index + i) % battle_texture_data_list_size);
1455: 						if (!header2.is_palette || (last_pal_y >= 0 && std::abs(header2.y - last_pal_y) > 10) || (last_pal_x >= 0 && last_pal_x != header.x)) {
1456: 							break;
1457: 						}
1458: 
1459: 						ff8_tim tim_infos = ff8_tim();
1460: 						tim_infos.pal_data = (uint16_t *)header2.data;
1461: 						tim_infos.pal_w = header2.w;
1462: 						tim_infos.pal_h = header2.h;
1463: 						tim_infos.img_data = texture_buffer;
1464: 						tim_infos.img_w = pos_and_size[2];
1465: 						tim_infos.img_h = pos_and_size[3];
1466: 						Tim(next_bpp, tim_infos).save(next_texture_name, header2.y - minY, true);
1467: 						texture_saved = true;
1468: 
1469: 						last_pal_x = header2.x;
1470: 						last_pal_y = header2.y;
1471: 
1472: 						// We assume that the first palette is correct, so we remove it from the array. The others maybe not, so keep them
1473: 						if (i == 1) {
1474: 							battle_texture_headers[(index + i) % battle_texture_data_list_size] = BattleTextureHeader();
1475: 						}
1476: 					}
1477: 				}
1478: 			} else {
1479: 				next_bpp = Tim::Bpp8;
1480: 			}
1481: 
1482: 			// We don't know the palette
1483: 			if (save_textures && !texture_saved) {
1484: 				ff8_tim tim_infos = ff8_tim();
1485: 				tim_infos.img_data = texture_buffer;
1486: 				tim_infos.img_w = pos_and_size[2];
1487: 				tim_infos.img_h = pos_and_size[3];
1488: 				Tim(next_bpp, tim_infos).save(next_texture_name, uint8_t(0), true);
1489: 			}
1490: 
1491: 			battle_texture_headers[index] = BattleTextureHeader();
1492: 		}
1493: 	} else {
1494: 		int index = battle_get_texture_file_name_index(texture_buffer);
1495: 
1496: 		if (index >= 0) {
1497: 			if (trace_all || trace_vram) ffnx_trace("%s: texture data identified 0x%X\n", __func__, texture_buffer);
1498: 
1499: 			strncpy(next_texture_name, battle_texture_data_list[index].file_name, sizeof(battle_texture_data_list[index].file_name));
1500: 
1501: 			battle_texture_data_list[index] = BattleTextureFileName();
1502: 
1503: 			next_bpp = Tim::Bpp8;
1504: 			bool skip_save_textures = false;
1505: 
1506: 			// Splitted version of A8DEF.TIM
1507: 			if (stricmp(next_texture_name, "battle/MA8DEF_P.0") == 0) {
1508: 				next_bpp = Tim::Bpp4;
1509: 				skip_save_textures = true;
1510: 				strncpy(next_texture_name, "battle/A8DEF0.TIM", sizeof(next_texture_name));
1511: 			} else if (stricmp(next_texture_name, "battle/MA8DEF_P.1") == 0) {
1512: 				next_bpp = Tim::Bpp4;
1513: 				skip_save_textures = true;
1514: 				strncpy(next_texture_name, "battle/A8DEF1.TIM", sizeof(next_texture_name));
1515: 			} else if (stricmp(next_texture_name, "battle/MA8DEF_P.2") == 0) {
1516: 				next_bpp = Tim::Bpp4;
1517: 				skip_save_textures = true;
1518: 				strncpy(next_texture_name, "battle/A8DEF2.TIM", sizeof(next_texture_name));
1519: 			}
1520: 
1521: 			if (save_textures && !skip_save_textures) {
1522: 				ff8_tim tim_infos = ff8_tim();
1523: 				tim_infos.img_data = texture_buffer;
1524: 				tim_infos.img_x = pos_and_size[0];
1525: 				tim_infos.img_y = pos_and_size[1];
1526: 				tim_infos.img_w = pos_and_size[2];
1527: 				tim_infos.img_h = pos_and_size[3];
1528: 				// Save without palette
1529: 				Tim(next_bpp, tim_infos).save(next_texture_name);
1530: 
1531: 				// Save with every palettes we know
1532: 				for (int i = 1; i < battle_texture_data_list_size; ++i) {
1533: 					const BattleTextureHeader &header = battle_texture_headers.at(i % battle_texture_data_list_size);
1534: 					if (!header.is_palette) {
1535: 						continue;
1536: 					}
1537: 
1538: 					char fileName[MAX_PATH] = {};
1539: 
1540: 					snprintf(fileName, sizeof(fileName), "%s-pal-guess-%dx%d", next_texture_name, header.x, header.y);
1541: 
1542: 					tim_infos.pal_data = (uint16_t *)header.data;
1543: 					tim_infos.pal_w = header.w;
1544: 					tim_infos.pal_h = header.h;
1545: 					Tim(next_bpp, tim_infos).save(fileName, true);
1546: 				}
1547: 			}
1548: 		} else {
1549: 			if (trace_all || trace_vram) ffnx_warning("%s: unknown texture uploaded\n", __func__);
1550: 
1551: 			if (pos_and_size[2] > 32 && pos_and_size[3] > 32) {
1552: 				snprintf(next_texture_name, sizeof(next_texture_name), "magic/mag%03d.tim-%d", *ff8_externals.battle_magic_id, battle_texture_id);
1553: 				++battle_texture_id;
1554: 				next_bpp = Tim::Bpp8;
1555: 
1556: 				if (save_textures) {
1557: 					ff8_tim tim_infos = ff8_tim();
1558: 					tim_infos.img_data = texture_buffer;
1559: 					tim_infos.img_x = pos_and_size[0];
1560: 					tim_infos.img_y = pos_and_size[1];
1561: 					tim_infos.img_w = pos_and_size[2];
1562: 					tim_infos.img_h = pos_and_size[3];
1563: 					// Save without palette
1564: 					Tim(next_bpp, tim_infos).save(next_texture_name);
1565: 				}
1566: 			}
1567: 		}
1568: 	}
1569: 
1570: 	ff8_upload_vram(pos_and_size, texture_buffer);
1571: }
1572: 
1573: void ff8_battle_upload_texture_palette(int16_t *pos_and_size, uint8_t *texture_buffer)
1574: {
1575: 	if (trace_all || trace_vram) ffnx_trace("%s: %s battle_texture_id=%d\n", __func__, battle_texture_name, battle_texture_id);
1576: 
1577: 	Tim tim = Tim::fromTimData(texture_buffer - 20);
1578: 	next_pal_data = (uint16_t *)texture_buffer;
1579: 
1580: 	ff8_upload_vram(pos_and_size, texture_buffer);
1581: 
1582: 	texture_infos = TexturePacker::TextureInfos(tim.imageX(), tim.imageY(), tim.imageWidth(), tim.imageHeight(), tim.bpp());
1583: 	palette_infos = TexturePacker::TextureInfos(tim.paletteX(), tim.paletteY(), tim.paletteWidth(), tim.paletteHeight(), Tim::Bpp16);
1584: 
1585: 	next_bpp = tim.bpp();
1586: 	if (stricmp(battle_texture_name, "battle/A8DEF.TIM") == 0) {
1587: 		// Exceptionally split the texture into 3 pages, because the game will reupload page by page later (via MA8DEF textures)
1588: 		texture_infos = TexturePacker::TextureInfos(tim.imageX(), tim.imageY(), 64, tim.imageHeight(), tim.bpp());
1589: 		strncpy(next_texture_name, "battle/A8DEF0.TIM", sizeof(next_texture_name));
1590: 		texturePacker.setTexture(next_texture_name, texture_infos, palette_infos);
1591: 		texture_infos = TexturePacker::TextureInfos(tim.imageX() + 64, tim.imageY(), 64, tim.imageHeight(), tim.bpp());
1592: 		strncpy(next_texture_name, "battle/A8DEF1.TIM", sizeof(next_texture_name));
1593: 		texturePacker.setTexture(next_texture_name, texture_infos, palette_infos);
1594: 		texture_infos = TexturePacker::TextureInfos(tim.imageX() + 128, tim.imageY(), 64, tim.imageHeight(), tim.bpp());
1595: 		strncpy(next_texture_name, "battle/A8DEF2.TIM", sizeof(next_texture_name));
1596: 		texturePacker.setTexture(next_texture_name, texture_infos, palette_infos);
1597: 		texture_infos = TexturePacker::TextureInfos(); // Bypass next upload vram
1598: 	} else if (battle_texture_id < 0) {
1599: 		strncpy(next_texture_name, battle_texture_name, sizeof(next_texture_name));
1600: 	} else {
1601: 		snprintf(next_texture_name, sizeof(next_texture_name), "%s-%d", battle_texture_name, battle_texture_id);
1602: 		++battle_texture_id;
1603: 	}
1604: 
1605: 	if (save_textures) {
1606: 		if (stricmp(battle_texture_name, "battle/A8DEF.TIM") == 0) {
1607: 			Tim chunk1 = tim.chunk(0, 0, 64, 256),
1608: 				chunk2 = tim.chunk(64, 0, 64, 256),
1609: 				chunk3 = tim.chunk(128, 0, 64, 256);
1610: 			for (int pal = 0; pal < palette_infos.h(); ++pal) {
1611: 				chunk1.save("battle/A8DEF0.TIM", 0, pal, true);
1612: 				chunk2.save("battle/A8DEF1.TIM", 0, pal, true);
1613: 				chunk3.save("battle/A8DEF2.TIM", 0, pal, true);
1614: 			}
1615: 		} else if (StrStrIA(battle_texture_name, ".X") != nullptr) {
1616: 			ff8_battle_state_save_texture(stage, tim, next_texture_name);
1617: 		} else if (palette_infos.h() > 1) {
1618: 			for (int pal = 0; pal < palette_infos.h(); ++pal) {
1619: 				tim.save(next_texture_name, 0, pal, true);
1620: 			}
1621: 		} else {
1622: 			tim.save(next_texture_name, 0, 0, true);
1623: 		}
1624: 	}
1625: }
1626: 
1627: void engine_set_init_time(double fps_adjust)
1628: {
1629: 	texturePacker.clearTextures();
1630: 
1631: 	palette_infos = TexturePacker::TextureInfos();
1632: 	texture_infos = TexturePacker::TextureInfos();
1633: 
1634: 	((void(*)(double))ff8_externals.engine_set_init_time)(fps_adjust);
1635: }
1636: 
1637: void clean_psxvram_pages()
1638: {
1639: 	texturePacker.clearTiledTexs();
1640: 
1641: 	palette_infos = TexturePacker::TextureInfos();
1642: 	texture_infos = TexturePacker::TextureInfos();
1643: 
1644: 	((void(*)())ff8_externals.sub_4672C0)();
1645: }
1646: 
1647: void vram_init()
1648: {
1649: 	replace_function(ff8_externals.upload_psx_vram, ff8_upload_vram);
1650: 	replace_function(ff8_externals.copy_psx_vram_part, ff8_copy_vram_part);
1651: 
1652: 	// pubintro
1653: 	replace_call(ff8_externals.open_lzs_image + 0x72, ff8_credits_open_texture);
1654: 	// cdcheck
1655: 	replace_call(ff8_externals.cdcheck_sub_52F9E0 + 0x1DC, ff8_cdcheck_error_upload_vram);
1656: 	// Triple Triad
1657: 	replace_call(ff8_externals.sub_5391B0 + 0x49, ff8_upload_vram_triple_triad_1);
1658: 	replace_call(ff8_externals.sub_5391B0 + 0x1CC, ff8_upload_vram_triple_triad_2_palette);
1659: 	replace_call(ff8_externals.sub_5391B0 + 0x1E1, ff8_upload_vram_triple_triad_2_data);
1660: 	// worldmap
1661: 	replace_call(ff8_externals.sub_554940_call_130, ff8_wm_section_17_upload); // Waves
1662: 	replace_call(ff8_externals.worldmap_sub_53F310_call_2A9, ff8_wm_section_38_prepare_texture_for_upload);
1663: 	replace_call(ff8_externals.worldmap_sub_53F310_call_30D, ff8_upload_vram_wm_section_38_palette);
1664: 	replace_call(ff8_externals.worldmap_sub_53F310_call_330, ff8_wm_section_39_upload); // Rails/Roads
1665: 	replace_call(ff8_externals.worldmap_sub_53F310_call_366, ff8_wm_section_40_upload);
1666: 	replace_call(ff8_externals.worldmap_sub_554AA0_call_C2, ff8_wm_section_41_upload_palette); // Animated palettes
1667: 	replace_call(ff8_externals.worldmap_sub_548020 + 0x47, ff8_wm_section_42_upload); // Train/vehicles
1668: 	replace_call(ff8_externals.worldmap_chara_one + 0xCC, ff8_wm_chara_one_read_file);
1669: 	replace_call(ff8_externals.worldmap_chara_one + 0x4D1, ff8_wm_chara_one_upload_texture_2); // Characters/Chocobos/Ragnarok
1670: 	replace_call(ff8_externals.worldmap_chara_one + 0x566, ff8_wm_chara_one_upload_palette_2);
1671: 	replace_call(ff8_externals.worldmap_input_update_sub_559240 + (FF8_US_VERSION ? 0x263 : 0x260), ff8_wm_update_fence_animation);
1672: 	// wm texl project
1673: 	replace_call(ff8_externals.upload_psxvram_texl_pal_call1, ff8_wm_texl_palette_upload_vram);
1674: 	replace_call(ff8_externals.upload_psxvram_texl_pal_call2, ff8_wm_texl_palette_upload_vram);
1675: 	replace_call(ff8_externals.open_file_world_sub_52D670_texl_call1, ff8_wm_open_data);
1676: 	replace_call(ff8_externals.open_file_world_sub_52D670_texl_call2, ff8_wm_open_data);
1677: 	// field: background
1678: 	replace_call(ff8_externals.upload_mim_file + 0x2E, ff8_field_mim_palette_upload_vram);
1679: 	replace_call(ff8_externals.read_field_data + (JP_VERSION ? 0x990 : 0x915), ff8_field_read_map_data);
1680: 	// field: characters
1681: 	replace_call(ff8_externals.load_field_models + 0x15F, ff8_field_chara_one_read_file_header);
1682: 	replace_call(ff8_externals.load_field_models + 0x582, ff8_field_chara_one_seek_to_model);
1683: 	replace_call(ff8_externals.load_field_models + 0x594, ff8_field_chara_one_read_model);
1684: 	replace_call(ff8_externals.load_field_models + 0x879, ff8_field_chara_one_read_mch);
1685: 	replace_call(ff8_externals.load_field_models + 0xB72, ff8_field_texture_upload_one);
1686: 	// field: effects
1687: 	replace_call(ff8_externals.upload_pmp_file + 0x7F, ff8_field_effects_upload_vram1);
1688: 	// battle
1689: 	// battle: File System
1690: 	replace_call(ff8_externals.battle_open_file_wrapper + 0x14, ff8_battle_open_and_read_file);
1691: 	replace_call(ff8_externals.load_magic_data_sub_5718E0 + 0xB, ff8_battle_open_effect);
1692: 	replace_call(ff8_externals.load_magic_data_sub_571B80 + 0x1E, ff8_battle_open_effect);
1693: 	replace_call(ff8_externals.battle_open_file + 0x8E, ff8_battle_read_file);
1694: 	replace_call(ff8_externals.battle_open_file + 0x1A2, ff8_battle_read_file);
1695: 	// battle: Effects
1696: 	replace_call(ff8_externals.battle_read_effect_sub_50AF20 + 0x63, battle_read_effect_alloc);
1697: 	replace_function(ff8_externals.mag_data_palette_sub_B66560, ff8_battle_set_palette_data_from_mag);
1698: 	replace_function(ff8_externals.mag_data_texture_sub_B66560, ff8_battle_set_texture_data_from_mag);
1699: 	// battle: Upload texture
1700: 	replace_call(ff8_externals.battle_set_action_upload_raw_palette_sub_B66400 + 0x68, battle_set_texture_action_upload_raw_pal_call);
1701: 	replace_call(ff8_externals.battle_upload_texture_to_vram + 0x2E, ff8_battle_upload_texture_raw);
1702: 	replace_call(ff8_externals.battle_upload_texture_to_vram + 0x45, ff8_battle_upload_texture_palette);
1703: 
1704: 	//---- VRAM reads
1705: 
1706: 	// read_vram_to_buffer_parent_calls
1707: 	replace_call(ff8_externals.sub_464BD0 + 0x53, read_vram_to_buffer_parent_call1);
1708: 	replace_call(ff8_externals.sub_464BD0 + 0xED, read_vram_to_buffer_parent_call1);
1709: 	replace_call(ff8_externals.sub_464BD0 + 0x1A1, read_vram_to_buffer_parent_call1);
1710: 	replace_call(ff8_externals.ssigpu_tx_select_2_sub_465CE0 + 0x281, read_vram_to_buffer_parent_call1_tx_select);
1711: 
1712: 	replace_call(ff8_externals.sub_464BD0 + 0x79, read_vram_to_buffer_parent_call2);
1713: 	replace_call(ff8_externals.sub_464BD0 + 0x1B5, read_vram_to_buffer_parent_call2);
1714: 
1715: 	// read_vram_to_buffer_with_palette1_parent_calls
1716: 	replace_call(ff8_externals.sub_464BD0 + 0xFC, read_vram_to_buffer_with_palette1_parent_call1);
1717: 	replace_call(ff8_externals.ssigpu_tx_select_2_sub_465CE0 + 0x2CF, read_vram_to_buffer_with_palette1_parent_call1);
1718: 
1719: 	replace_call(ff8_externals.sub_464BD0 + 0xAF, read_vram_to_buffer_with_palette1_parent_call2);
1720: 
1721: 	// read_vram_to_buffer_with_palette2_parent_calls
1722: 	replace_call(ff8_externals.ssigpu_callbacks_2[100] + 0x33, read_vram_to_buffer_with_palette2_parent_call);
1723: 	replace_call(ff8_externals.ssigpu_callbacks_2[116] + 0x2E, read_vram_to_buffer_with_palette2_parent_call);
1724: 	replace_call(ff8_externals.ssigpu_callbacks_2[124] + 0x2E, read_vram_to_buffer_with_palette2_parent_call);
1725: 
1726: 	replace_call(uint32_t(ff8_externals.sub_464F70) + 0x2C5, read_vram_to_buffer);
1727: 	replace_call(ff8_externals.sub_4653B0 + 0x9D, read_vram_to_buffer);
1728: 
1729: 	replace_call(ff8_externals.sub_464DB0 + 0xEC, read_vram_to_buffer_with_palette1);
1730: 	replace_call(ff8_externals.sub_465720 + 0xA5, read_vram_to_buffer_with_palette1);
1731: 
1732: 	// Not used?
1733: 	replace_call(ff8_externals.sub_4649A0 + 0x13F, read_vram_to_buffer_with_palette2);
1734: 
1735: 	// Read palette from VRAM to Graphic driver
1736: 	replace_call(ff8_externals.write_palette_texture_set_sub_466190 + 0x2C, ff8_read_vram_palette);
1737: 	replace_call(ff8_externals.write_palette_texture_set_sub_466190 + 0x7E, ff8_write_palette_to_driver);
1738: 
1739: 	//---- Misc
1740: 
1741: 	// Fix missing textures in battle module by clearing custom textures
1742: 	replace_call(ff8_externals.battle_enter + 0x35, engine_set_init_time);
1743: 	// Clear texture_packer on every module exits
1744: 	replace_call(ff8_externals.psxvram_texture_pages_free + 0x5A, clean_psxvram_pages);
1745: 	// Free pc_name in tex_header
1746: 	replace_call(ff8_externals.psxvram_texture_page_free + 0x98, free_tex_header);
1747: 	replace_call(ff8_externals.psxvram_texture_page_free + 0xAF, free_tex_header);
1748: }
</file>

<file path="src/ff8/vram.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include "texture_packer.h"
26: 
27: extern TexturePacker texturePacker;
28: 
29: void vram_init();
30: bool ff8_vram_save(const char *fileName, Tim::Bpp bpp);
</file>

<file path="src/gl/deferred.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include "../renderer.h"
 24: 
 25: #include "../gl.h"
 26: #include "../macro.h"
 27: #include "../log.h"
 28: #include "../common.h"
 29: #include "../video/movies.h"
 30: #include "../ff7/battle/menu.h"
 31: #include "../ff7/widescreen.h"
 32: 
 33: #include "ff7/world/renderer.h"
 34: 
 35: uint32_t nodefer = false;
 36: 
 37: #define DEFERRED_MAX 1024
 38: 
 39: struct deferred_draw *deferred_draws;
 40: uint32_t num_deferred;
 41: 
 42: struct deferred_sorted_draw *deferred_sorted_draws;
 43: uint32_t num_sorted_deferred;
 44: 
 45: int lastBlitDrawCallIndex = -1;
 46: 
 47: // save a draw call for later processing
 48: uint32_t gl_defer_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex* vertices, struct vector3<float>* normals, uint32_t vertexcount, WORD* indices, uint32_t count, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap)
 49: {
 50: 	if (ff8 || !enable_lighting)
 51: 	{
 52: 		return false;
 53: 	}
 54: 
 55: 	if (trace_all) ffnx_trace("gl_defer_draw: call with primitivetype: %u - vertextype: %u - vertexcount: %u - count: %u - clip: %d - mipmap: %d\n", primitivetype, vertextype, vertexcount, count, clip, mipmap);
 56: 
 57: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
 58: 
 59: 	// global disable
 60: 	if (nodefer) {
 61: 		if (trace_all) ffnx_trace("gl_defer_draw: nodefer true\n");
 62: 		return false;
 63: 	}
 64: 
 65: 	if (num_deferred + 1 > DEFERRED_MAX)
 66: 	{
 67: 		if (trace_all) ffnx_trace("gl_defer_draw: deferred draw queue overflow - num_deferred: %u - count: %u - DEFERRED_MAX: %u\n", num_deferred, count, DEFERRED_MAX);
 68: 		return false;
 69: 	}
 70: 
 71: 	uint32_t defer = num_deferred;
 72: 
 73: 	deferred_draws[defer].count = count;
 74: 	deferred_draws[defer].clip = clip;
 75: 	deferred_draws[defer].mipmap = mipmap;
 76: 	deferred_draws[defer].primitivetype = primitivetype;
 77: 	deferred_draws[defer].vertextype = vertextype;
 78: 	deferred_draws[defer].vertexcount = vertexcount;
 79: 	deferred_draws[defer].indices = (WORD*)driver_malloc(sizeof(*indices) * count);
 80: 	deferred_draws[defer].vertices = (nvertex*)driver_malloc(sizeof(*vertices) * vertexcount);
 81: 	deferred_draws[defer].draw_call_type = DCT_DRAW;
 82: 	if(enable_time_cycle)
 83: 		deferred_draws[defer].is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
 84: 	if(enable_worldmap_external_mesh)
 85: 		deferred_draws[defer].is_fog_enabled = newRenderer.isFogEnabled();
 86: 	gl_save_state(&deferred_draws[defer].state);
 87: 
 88: 	memcpy(deferred_draws[defer].indices, indices, sizeof(*indices) * count);
 89: 	memcpy(deferred_draws[defer].vertices, vertices, sizeof(*vertices) * vertexcount);
 90: 
 91: 	if (boundingbox)
 92: 	{
 93: 		deferred_draws[defer].boundingbox = (struct boundingbox*)driver_malloc(sizeof(struct boundingbox));
 94: 
 95: 		deferred_draws[defer].boundingbox->min_x = boundingbox->min_x;
 96: 		deferred_draws[defer].boundingbox->min_y = boundingbox->min_y;
 97: 		deferred_draws[defer].boundingbox->min_z = boundingbox->min_z;
 98: 
 99: 		deferred_draws[defer].boundingbox->max_x = boundingbox->max_x;
100: 		deferred_draws[defer].boundingbox->max_y = boundingbox->max_y;
101: 		deferred_draws[defer].boundingbox->max_z = boundingbox->max_z;
102: 	}
103: 	else // calculate AABB if no bounding box found
104: 	{
105: 		deferred_draws[defer].boundingbox = (struct boundingbox*)driver_malloc(sizeof(struct boundingbox));
106: 
107: 		deferred_draws[defer].boundingbox->min_x = FLT_MAX;
108: 		deferred_draws[defer].boundingbox->min_y = FLT_MAX;
109: 		deferred_draws[defer].boundingbox->min_z = FLT_MAX;
110: 
111: 		deferred_draws[defer].boundingbox->max_x = FLT_MIN;
112: 		deferred_draws[defer].boundingbox->max_y = FLT_MIN;
113: 		deferred_draws[defer].boundingbox->max_z = FLT_MIN;
114: 
115: 		for (int i = 0; i < vertexcount; ++i)
116: 		{
117: 			float vx = vertices[i]._.x;
118: 			float vy = vertices[i]._.y;
119: 			float vz = vertices[i]._.z;
120: 
121: 			deferred_draws[defer].boundingbox->min_x = std::min(deferred_draws[defer].boundingbox->min_x, vx);
122: 			deferred_draws[defer].boundingbox->min_y = std::min(deferred_draws[defer].boundingbox->min_y, vy);
123: 			deferred_draws[defer].boundingbox->min_z = std::min(deferred_draws[defer].boundingbox->min_z, vz);
124: 
125: 			deferred_draws[defer].boundingbox->max_x = std::max(deferred_draws[defer].boundingbox->max_x, vx);
126: 			deferred_draws[defer].boundingbox->max_y = std::max(deferred_draws[defer].boundingbox->max_y, vy);
127: 			deferred_draws[defer].boundingbox->max_z = std::max(deferred_draws[defer].boundingbox->max_z, vz);
128: 		}
129: 	}
130: 
131: 	if (normals)
132: 	{
133: 		deferred_draws[defer].normals = (vector3<float>*)driver_malloc(sizeof(*normals) * vertexcount);
134: 		memcpy(deferred_draws[defer].normals, normals, sizeof(*normals) * vertexcount);
135: 	}
136: 
137: 	if(lightdata)
138: 	{
139: 		deferred_draws[defer].lightdata = (struct light_data*)driver_malloc(sizeof(struct light_data));
140: 		memcpy(deferred_draws[defer].lightdata, lightdata, sizeof(struct light_data));
141: 	}
142: 
143: 	num_deferred++;
144: 
145: 	if (trace_all) ffnx_trace("gl_defer_draw: return true\n");
146: 
147: 	return true;
148: }
149: 
150: uint32_t gl_defer_blit_framebuffer(struct texture_set *texture_set, struct tex_header *tex_header)
151: {
152: 	if (ff8 || !enable_lighting)
153: 	{
154: 		return false;
155: 	}
156: 
157: 	if (trace_all) ffnx_trace("gl_defer_blit_framebuffer_buffer");
158: 
159: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
160: 
161: 	// global disable
162: 	if (nodefer) {
163: 		if (trace_all) ffnx_trace("gl_defer_draw: nodefer true\n");
164: 		return false;
165: 	}
166: 
167: 	if (num_deferred + 1 > DEFERRED_MAX)
168: 	{
169: 		if (trace_all) ffnx_trace("gl_defer_blit_framebuffer_buffer: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
170: 		return false;
171: 	}
172: 
173: 	uint32_t defer = num_deferred;
174: 
175: 	deferred_draws[defer].fb_texture_set = texture_set;
176: 	deferred_draws[defer].fb_tex_header = tex_header;
177: 	deferred_draws[defer].draw_call_type = DCT_BLIT;
178: 	lastBlitDrawCallIndex = defer;
179: 
180: 	num_deferred++;
181: 
182: 	if (trace_all) ffnx_trace("gl_defer_blit_framebuffer_buffer: return true\n");
183: 
184: 	return true;
185: }
186: 
187: uint32_t gl_defer_clear_buffer(uint32_t clear_color, uint32_t clear_depth, struct game_obj *game_object)
188: {
189: 	if (ff8 || !enable_lighting)
190: 	{
191: 		return false;
192: 	}
193: 
194: 	if (trace_all) ffnx_trace("gl_defer_clear_buffer");
195: 
196: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
197: 
198: 	// global disable
199: 	if (nodefer) {
200: 		if (trace_all) ffnx_trace("gl_defer_clear_buffer: nodefer true\n");
201: 		return false;
202: 	}
203: 
204: 	if (num_deferred + 1 > DEFERRED_MAX)
205: 	{
206: 		if (trace_all) ffnx_trace("gl_defer_clear_buffer: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
207: 		return false;
208: 	}
209: 
210: 	uint32_t defer = num_deferred;
211: 
212: 	deferred_draws[defer].clear_color = clear_color;
213: 	deferred_draws[defer].clear_depth = clear_depth;
214: 	deferred_draws[defer].game_object = game_object;
215: 	deferred_draws[defer].draw_call_type = DCT_CLEAR;
216: 
217: 	num_deferred++;
218: 
219: 	if (trace_all) ffnx_trace("gl_defer_clear_buffer: return true\n");
220: 
221: 	return true;
222: }
223: 
224: uint32_t gl_defer_yuv_frame(uint32_t buffer_index)
225: {
226: 	if (ff8 || !enable_lighting)
227: 	{
228: 		return false;
229: 	}
230: 
231: 	if (trace_all) ffnx_trace("gl_defer_yuv_frame");
232: 
233: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
234: 
235: 	// global disable
236: 	if (nodefer) {
237: 		if (trace_all) ffnx_trace("gl_defer_yuv_frame: nodefer true\n");
238: 		return false;
239: 	}
240: 
241: 	if (num_deferred + 1 > DEFERRED_MAX)
242: 	{
243: 		if (trace_all) ffnx_trace("gl_defer_yuv_frame: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
244: 		return false;
245: 	}
246: 
247: 	uint32_t defer = num_deferred;
248: 
249: 	deferred_draws[defer].movie_buffer_index = buffer_index;
250: 	deferred_draws[defer].draw_call_type = DCT_DRAW_MOVIE;
251: 
252: 	num_deferred++;
253: 
254: 	if (trace_all) ffnx_trace("gl_defer_yuv_frame: return true\n");
255: 
256: 	return true;
257: }
258: 
259: uint32_t gl_defer_zoom()
260: {
261: 	if (ff8 || !enable_lighting)
262: 	{
263: 		return false;
264: 	}
265: 
266: 	if (trace_all) ffnx_trace("gl_defer_zoom");
267: 
268: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
269: 
270: 	// global disable
271: 	if (nodefer) {
272: 		if (trace_all) ffnx_trace("gl_defer_zoom: nodefer true\n");
273: 		return false;
274: 	}
275: 
276: 	if (num_deferred + 1 > DEFERRED_MAX)
277: 	{
278: 		if (trace_all) ffnx_trace("gl_defer_zoom: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
279: 		return false;
280: 	}
281: 
282: 	uint32_t defer = num_deferred;
283: 
284: 	deferred_draws[defer].draw_call_type = DCT_ZOOM;
285: 
286: 	num_deferred++;
287: 
288: 	if (trace_all) ffnx_trace("gl_defer_zoom: return true\n");
289: 
290: 	return true;
291: }
292: 
293: uint32_t gl_defer_world_external_mesh()
294: {
295: 	if (ff8 || !enable_lighting)
296: 	{
297: 		return false;
298: 	}
299: 
300: 	if (trace_all) ffnx_trace("gl_defer_world_external_mesh");
301: 
302: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
303: 
304: 	// global disable
305: 	if (nodefer) {
306: 		if (trace_all) ffnx_trace("gl_defer_world_external_mesh: nodefer true\n");
307: 		return false;
308: 	}
309: 
310: 	if (num_deferred + 1 > DEFERRED_MAX)
311: 	{
312: 		if (trace_all) ffnx_trace("gl_defer_world_external_mesh: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
313: 		return false;
314: 	}
315: 
316: 	uint32_t defer = num_deferred;
317: 
318: 	deferred_draws[defer].draw_call_type = DCT_WORLD_EXTERNAL_MESH;
319: 	deferred_draws[defer].is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
320: 	deferred_draws[defer].is_fog_enabled = newRenderer.isFogEnabled();
321: 
322: 	num_deferred++;
323: 
324: 	if (trace_all) ffnx_trace("gl_defer_world_external_mesh: return true\n");
325: 
326: 	return true;
327: }
328: 
329: uint32_t gl_defer_cloud_external_mesh()
330: {
331: 	if (ff8 || !enable_lighting)
332: 	{
333: 		return false;
334: 	}
335: 
336: 	if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh");
337: 
338: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
339: 
340: 	// global disable
341: 	if (nodefer) {
342: 		if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh: nodefer true\n");
343: 		return false;
344: 	}
345: 
346: 	if (num_deferred + 1 > DEFERRED_MAX)
347: 	{
348: 		if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
349: 		return false;
350: 	}
351: 
352: 	uint32_t defer = num_deferred;
353: 
354: 	deferred_draws[defer].draw_call_type = DCT_CLOUD_EXTERNAL_MESH;
355: 	deferred_draws[defer].is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
356: 	deferred_draws[defer].is_fog_enabled = newRenderer.isFogEnabled();
357: 
358: 	num_deferred++;
359: 
360: 	if (trace_all) ffnx_trace("gl_defer_cloud_external_mesh: return true\n");
361: 
362: 	return true;
363: }
364: 
365: uint32_t gl_defer_battle_depth_clear()
366: {
367: 	if (ff8 || !enable_lighting)
368: 	{
369: 		return false;
370: 	}
371: 
372: 	if (trace_all) ffnx_trace("gl_defer_battle_depth_clear");
373: 
374: 	if (!deferred_draws) deferred_draws = (deferred_draw*)driver_calloc(sizeof(*deferred_draws), DEFERRED_MAX);
375: 
376: 	// global disable
377: 	if (nodefer) {
378: 		if (trace_all) ffnx_trace("gl_defer_battle_depth_clear: nodefer true\n");
379: 		return false;
380: 	}
381: 
382: 	if (num_deferred + 1 > DEFERRED_MAX)
383: 	{
384: 		if (trace_all) ffnx_trace("gl_defer_battle_depth_clear: deferred draw queue overflow - num_deferred: %u - count: 1 - DEFERRED_MAX: %u\n", num_deferred, DEFERRED_MAX);
385: 		return false;
386: 	}
387: 
388: 	uint32_t defer = num_deferred;
389: 
390: 	deferred_draws[defer].draw_call_type = DCT_BATTLE_DEPTH_CLEAR;
391: 
392: 	num_deferred++;
393: 
394: 	if (trace_all) ffnx_trace("gl_defer_battle_depth_clear: return true\n");
395: 
396: 	return true;
397: }
398: 
399: // re-order and save a draw call for later processing
400: uint32_t gl_defer_sorted_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, uint32_t clip, uint32_t mipmap, uint32_t force_defer)
401: {
402: 	uint32_t tri;
403: 	uint32_t mode = getmode_cached()->driver_mode;
404: 	uint32_t *tri_deferred;
405: 	float *tri_z;
406: 	uint32_t defer_index = 0;
407: 
408: 	if (trace_all) ffnx_trace("gl_defer_sorted_draw: call with primitivetype: %u - vertextype: %u - vertexcount: %u - count: %u - clip: %d - mipmap: %d\n", primitivetype, vertextype, vertexcount, count, clip, mipmap);
409: 
410: 	if(!deferred_sorted_draws) deferred_sorted_draws = (deferred_sorted_draw*)driver_calloc(sizeof(*deferred_sorted_draws), DEFERRED_MAX);
411: 
412: 	// global disable
413: 	if (nodefer) {
414: 		if (trace_all) ffnx_trace("gl_defer_sorted_draw: nodefer true\n");
415: 		return false;
416: 	}
417: 
418: 	if (!force_defer)
419: 	{
420: 		// output will not be consistent if depth testing is disabled, this call
421: 		// cannot be re-ordered
422: 		if(!current_state.depthtest)
423: 		{
424: 			if (trace_all) ffnx_trace("gl_defer_sorted_draw: depthtest false\n");
425: 			return false;
426: 		}
427: 
428: 		// framebuffer textures should not be re-ordered
429: 		if(current_state.fb_texture)
430: 		{
431: 			if (trace_all) ffnx_trace("gl_defer_sorted_draw: fb_texture true\n");
432: 			return false;
433: 		}
434: 
435: 		if(current_state.blend_mode != BLEND_NONE)
436: 		{
437: 			if (trace_all) ffnx_trace("gl_defer_sorted_draw: blend_mode != BLEND_NONE - blend_mode: %u\n", current_state.blend_mode);
438: 			if(current_state.blend_mode != BLEND_AVG)
439: 			{
440: 				if (trace_all) ffnx_trace("gl_defer_sorted_draw: blend_mode != BLEND_AVG - blend_mode: %u\n", current_state.blend_mode);
441: 				// be conservative with non-standard blending modes
442: 				if (mode != MODE_MENU && mode != MODE_MAIN_MENU && mode != MODE_BATTLE) {
443: 					if (trace_all) ffnx_trace("gl_defer_sorted_draw: mode != MODE_MENU && mode != MODE_BATTLE - mode: %u\n", mode);
444: 					return false;
445: 				}
446: 			}
447: 		}
448: 		else
449: 		{
450: 			if (!current_state.texture_set)
451: 			{
452: 				if (trace_all) ffnx_trace("gl_defer_sorted_draw: texture_set false\n");
453: 				return false;
454: 			}
455: 			else
456: 			{
457: 				VOBJ(texture_set, texture_set, current_state.texture_set);
458: 				VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));
459: 
460: 				if (trace_all) ffnx_trace("gl_defer_sorted_draw: texture_set true for texture %s%d\n", VREF(tex_header, file.pc_name), VREF(tex_header, palette_index));
461: 
462: 				// texture format does not support alpha, re-order is not necessary
463: 				if (!VREF(texture_set, ogl.external) && VREF(tex_header, tex_format.alpha_bits) < 2) {
464: 					if (trace_all) ffnx_trace("gl_defer_sorted_draw: texture format does not support alpha, re-order is not necessary\n");
465: 					return false;
466: 				}
467: 			}
468: 		}
469: 
470: 		// quads are used for some GUI elements, we do not need to re-order these
471: 		if (primitivetype != RendererPrimitiveType::PT_TRIANGLES) {
472: 			if (trace_all) ffnx_trace("gl_defer_sorted_draw: primitivetype != TRIANGLES\n");
473: 			return false;
474: 		}
475: 	}
476: 
477: 	if(num_sorted_deferred + count / 3 > DEFERRED_MAX)
478: 	{
479: 		if (trace_all) ffnx_trace("gl_defer_sorted_draw: deferred draw queue overflow - num_sorted_deferred: %u - count: %u - DEFERRED_MAX: %u\n", num_sorted_deferred, count, DEFERRED_MAX);
480: 		return false;
481: 	}
482: 
483: 	tri_deferred = (uint32_t*)driver_calloc(sizeof(*tri_deferred), count / 3);
484: 	tri_z = (float*)driver_calloc(sizeof(*tri_z), count / 3);
485: 
486: 	// calculate screen space average Z coordinate for each triangle
487: 	for(tri = 0; tri < count / 3; tri++)
488: 	{
489: 		uint32_t i;
490: 
491: 		for(i = 0; i < 3; i++)
492: 		{
493: 			if(vertextype == TLVERTEX) tri_z[tri] += vertices[indices[tri * 3 + i]]._.z;
494: 			else
495: 			{
496: 				struct point4d world;
497: 				struct point4d proj;
498: 				struct point4d view;
499: 				transform_point_w(&current_state.world_view_matrix, &vertices[indices[tri * 3 + i]]._, &world);
500: 				transform_point4d(&current_state.d3dprojection_matrix, &world, &proj);
501: 				transform_point4d(&d3dviewport_matrix, &proj, &view);
502: 				tri_z[tri] += view.z / view.w;
503: 			}
504: 		}
505: 
506: 		tri_z[tri] /= 3.0f;
507: 	}
508: 
509: 	// arrange triangles into layers based on Z coordinates calculated above
510: 	// each layer will be drawn separately
511: 	while(defer_index < count / 3)
512: 	{
513: 		float z = tri_z[defer_index];
514: 		uint32_t tri_num = 0;
515: 		uint32_t defer = num_sorted_deferred;
516: 		uint32_t vert_index = 0;
517: 
518: 		for(tri = 0; tri < count / 3; tri++) if(tri_z[tri] == z) tri_num++;
519: 
520: 		deferred_sorted_draws[defer].deferred_draw.count = tri_num * 3;
521: 		deferred_sorted_draws[defer].deferred_draw.clip = clip;
522: 		deferred_sorted_draws[defer].deferred_draw.mipmap = mipmap;
523: 		deferred_sorted_draws[defer].deferred_draw.primitivetype = primitivetype;
524: 		deferred_sorted_draws[defer].deferred_draw.vertextype = vertextype;
525: 		deferred_sorted_draws[defer].deferred_draw.vertexcount = tri_num * 3;
526: 		deferred_sorted_draws[defer].deferred_draw.indices = (WORD*)driver_malloc(sizeof(*indices) * tri_num * 3);
527: 		deferred_sorted_draws[defer].deferred_draw.vertices = (nvertex*)driver_malloc(sizeof(*vertices) * tri_num * 3);
528: 		gl_save_state(&deferred_sorted_draws[defer].deferred_draw.state);
529: 		deferred_sorted_draws[defer].drawn = false;
530: 		deferred_sorted_draws[defer].z = z;
531: 		if(enable_time_cycle)
532: 				deferred_sorted_draws[defer].deferred_draw.is_time_filter_enabled = newRenderer.isTimeFilterEnabled();
533: 		deferred_sorted_draws[defer].deferred_draw.is_fog_enabled = false;
534: 
535: 		for(tri = 0; tri < count / 3 && vert_index < tri_num * 3; tri++)
536: 		{
537: 			if(tri_z[tri] == z)
538: 			{
539: 				memcpy(&deferred_sorted_draws[defer].deferred_draw.vertices[vert_index + 0], &vertices[indices[tri * 3 + 0]], sizeof(*vertices));
540: 				memcpy(&deferred_sorted_draws[defer].deferred_draw.vertices[vert_index + 1], &vertices[indices[tri * 3 + 1]], sizeof(*vertices));
541: 				memcpy(&deferred_sorted_draws[defer].deferred_draw.vertices[vert_index + 2], &vertices[indices[tri * 3 + 2]], sizeof(*vertices));
542: 				deferred_sorted_draws[defer].deferred_draw.indices[vert_index + 0] = vert_index + 0;
543: 				deferred_sorted_draws[defer].deferred_draw.indices[vert_index + 1] = vert_index + 1;
544: 				deferred_sorted_draws[defer].deferred_draw.indices[vert_index + 2] = vert_index + 2;
545: 
546: 				vert_index += 3;
547: 
548: 				tri_deferred[tri] = true;
549: 			}
550: 		}
551: 
552: 		if(vert_index < tri_num * 3) ffnx_error("deferred draw z mismatch\n");
553: 
554: 		num_sorted_deferred++;
555: 
556: 		while(defer_index < count / 3 && tri_deferred[defer_index]) defer_index++;
557: 	}
558: 
559: 	driver_free(tri_deferred);
560: 	driver_free(tri_z);
561: 
562: 	if (trace_all) ffnx_trace("gl_defer_sorted_draw: return true\n");
563: 
564: 	return true;
565: }
566: 
567: // draw deferred models
568: void gl_draw_deferred(draw_field_shadow_callback shadow_callback)
569: {
570: 	struct driver_state saved_state;
571: 
572: 	bool isFieldShadowDrawn = false;
573: 
574: 	if (num_deferred == 0) {
575: 		if (trace_all) ffnx_trace("gl_draw_deferred: num_deferred == 0\n");
576: 		return;
577: 	}
578: 
579: 	gl_save_state(&saved_state);
580: 
581: 	nodefer = true;
582: 
583: 	for (int i = 0; i < num_deferred; ++i)
584: 	{
585: 		if(enable_time_cycle)
586: 			newRenderer.setTimeFilterEnabled(deferred_draws[i].is_time_filter_enabled);
587: 
588: 		if(enable_worldmap_external_mesh)
589: 			newRenderer.setFogEnabled(deferred_draws[i].is_fog_enabled);
590: 
591: 		if(deferred_draws[i].draw_call_type == DCT_CLEAR)
592: 		{
593: 			common_clear(deferred_draws[i].clear_color, deferred_draws[i].clear_depth, true, deferred_draws[i].game_object);
594: 			continue;
595: 		} else if(deferred_draws[i].draw_call_type == DCT_BLIT)
596: 		{
597: 			blit_framebuffer_texture(deferred_draws[i].fb_texture_set, deferred_draws[i].fb_tex_header);
598: 			continue;
599: 		}
600: 		else if(deferred_draws[i].draw_call_type == DCT_DRAW_MOVIE)
601: 		{
602: 			draw_yuv_frame(deferred_draws[i].movie_buffer_index);
603: 			continue;
604: 		}
605: 		else if(deferred_draws[i].draw_call_type == DCT_ZOOM)
606: 		{
607: 			widescreen.zoomBackground();
608: 			continue;
609: 		}
610: 		else if(deferred_draws[i].draw_call_type == DCT_BATTLE_DEPTH_CLEAR)
611: 		{
612: 			ff7::battle::battle_depth_clear();
613: 			continue;
614: 		}
615: 		else if(deferred_draws[i].draw_call_type == DCT_WORLD_EXTERNAL_MESH)
616: 		{
617: 			ff7::world::worldRenderer.drawWorldMapExternalMesh();
618: 			continue;
619: 		}
620: 		else if(deferred_draws[i].draw_call_type == DCT_CLOUD_EXTERNAL_MESH)
621: 		{
622: 			ff7::world::worldRenderer.drawCloudsAndMeteorExternalMesh(*ff7_externals.is_meteor_flag_on_E2AAE4);
623: 			continue;
624: 		}
625: 
626: 		if (deferred_draws[i].vertices == nullptr)
627: 		{
628: 			continue;
629: 		}
630: 
631: 		if (shadow_callback != nullptr && !isFieldShadowDrawn && deferred_draws[i].vertextype != TLVERTEX)
632: 		{
633: 			newRenderer.setD3DProjection(&deferred_draws[i].state.d3dprojection_matrix);
634: 			newRenderer.setD3DViweport(&d3dviewport_matrix);
635: 
636: 			(*shadow_callback)();
637: 			isFieldShadowDrawn = true;
638: 		}
639: 
640: 		gl_load_state(&deferred_draws[i].state);
641: 
642: 		gl_draw_indexed_primitive(deferred_draws[i].primitivetype,
643: 			deferred_draws[i].vertextype,
644: 			deferred_draws[i].vertices,
645: 			i > lastBlitDrawCallIndex ? deferred_draws[i].normals : 0,
646: 			deferred_draws[i].vertexcount,
647: 			deferred_draws[i].indices,
648: 			deferred_draws[i].count,
649: 			0,
650: 			deferred_draws[i].boundingbox,
651: 			deferred_draws[i].lightdata,
652: 			deferred_draws[i].clip,
653: 			deferred_draws[i].mipmap
654: 		);
655: 
656: 		++stats.deferred;
657: 
658: 		driver_free(deferred_draws[i].vertices);
659: 		deferred_draws[i].vertices = nullptr;
660: 		driver_free(deferred_draws[i].indices);
661: 		deferred_draws[i].indices = nullptr;
662: 		driver_free(deferred_draws[i].normals);
663: 		deferred_draws[i].normals = nullptr;
664: 		driver_free(deferred_draws[i].boundingbox);
665: 		deferred_draws[i].boundingbox = nullptr;
666: 		driver_free(deferred_draws[i].lightdata);
667: 		deferred_draws[i].lightdata = nullptr;
668: 	}
669: 
670: 	num_deferred = 0;
671: 	lastBlitDrawCallIndex = -1;
672: 
673: 	nodefer = false;
674: 
675: 	gl_load_state(&saved_state);
676: }
677: 
678: struct boundingbox calculateSceneAabb()
679: {
680: 	struct boundingbox sceneAabb;
681: 	sceneAabb.min_x = FLT_MAX;
682: 	sceneAabb.min_y = FLT_MAX;
683: 	sceneAabb.min_z = FLT_MAX;
684: 	sceneAabb.max_x = FLT_MIN;
685: 	sceneAabb.max_y = FLT_MIN;
686: 	sceneAabb.max_z = FLT_MIN;
687: 	for (int i = 0; i < num_deferred; ++i)
688: 	{
689: 		if (deferred_draws[i].vertextype == TLVERTEX)
690: 		{
691: 			continue;
692: 		}
693: 		if (deferred_draws[i].normals == nullptr || deferred_draws[i].count == 3)
694: 		{
695: 			continue;
696: 		}
697: 
698: 		struct boundingbox* bb = deferred_draws[i].boundingbox;
699: 		if (bb)
700: 		{
701: 			vector3<float> corners[8] = { {bb->min_x, bb->min_y, bb->min_z},
702: 									   {bb->min_x, bb->min_y, bb->max_z},
703: 			                           {bb->min_x, bb->max_y, bb->min_z},
704: 			                           {bb->min_x, bb->max_y, bb->max_z},
705: 			                           {bb->max_x, bb->min_y, bb->min_z},
706: 			                           {bb->max_x, bb->min_y, bb->max_z},
707: 			                           {bb->max_x, bb->max_y, bb->min_z},
708: 			                           {bb->max_x, bb->max_y, bb->max_z} };
709: 
710: 			struct matrix worldViewMatrix = deferred_draws[i].state.world_view_matrix;
711: 			for (int j = 0; j < 8; ++j)
712: 			{
713: 				vector3<float> cornerViewSpace;
714: 				transform_point(&worldViewMatrix, &corners[j], &cornerViewSpace);
715: 
716: 				sceneAabb.min_x = std::min(sceneAabb.min_x, cornerViewSpace.x);
717: 				sceneAabb.min_y = std::min(sceneAabb.min_y, cornerViewSpace.y);
718: 				sceneAabb.min_z = std::min(sceneAabb.min_z, cornerViewSpace.z);
719: 
720: 				sceneAabb.max_x = std::max(sceneAabb.max_x, cornerViewSpace.x);
721: 				sceneAabb.max_y = std::max(sceneAabb.max_y, cornerViewSpace.y);
722: 				sceneAabb.max_z = std::max(sceneAabb.max_z, cornerViewSpace.z);
723: 			}
724: 		}
725: 	}
726: 
727: 	return sceneAabb;
728: }
729: 
730: // draw all the layers we've accumulated in the correct order and reset queue
731: void gl_draw_sorted_deferred()
732: {
733: 	struct driver_state saved_state;
734: 
735: 	if (num_sorted_deferred == 0) {
736: 		if (trace_all) ffnx_trace("gl_draw_sorted_deferred: num_sorted_deferred == 0\n");
737: 		return;
738: 	}
739: 
740: 	gl_save_state(&saved_state);
741: 
742: 	nodefer = true;
743: 
744: 	stats.deferred += num_sorted_deferred;
745: 
746: 	while(true)
747: 	{
748: 		uint32_t i;
749: 		double z = -1.0;
750: 		uint32_t next = -1;
751: 
752: 		for(i = 0; i < num_sorted_deferred; i++)
753: 		{
754: 			if(deferred_sorted_draws[i].z > z && !deferred_sorted_draws[i].drawn)
755: 			{
756: 				next = i;
757: 				z = deferred_sorted_draws[i].z;
758: 			}
759: 		}
760: 
761: 		if(next == -1) break;
762: 
763: 		gl_load_state(&deferred_sorted_draws[next].deferred_draw.state);
764: 		internal_set_renderstate(V_DEPTHTEST, 1, 0);
765: 		internal_set_renderstate(V_DEPTHMASK, 1, 0);
766: 
767: 		if(enable_time_cycle)
768: 			newRenderer.setTimeFilterEnabled(deferred_sorted_draws[next].deferred_draw.is_time_filter_enabled);
769: 
770: 		gl_draw_indexed_primitive(deferred_sorted_draws[next].deferred_draw.primitivetype,
771: 								  deferred_sorted_draws[next].deferred_draw.vertextype,
772: 								  deferred_sorted_draws[next].deferred_draw.vertices,
773: 								  0,
774: 								  deferred_sorted_draws[next].deferred_draw.vertexcount,
775: 								  deferred_sorted_draws[next].deferred_draw.indices,
776: 								  deferred_sorted_draws[next].deferred_draw.count,
777: 								  0,
778: 								  0,
779: 								  0,
780: 								  deferred_sorted_draws[next].deferred_draw.clip,
781: 								  deferred_sorted_draws[next].deferred_draw.mipmap
782: 								  );
783: 
784: 		driver_free(deferred_sorted_draws[next].deferred_draw.vertices);
785: 		driver_free(deferred_sorted_draws[next].deferred_draw.indices);
786: 		deferred_sorted_draws[next].drawn = true;
787: 	}
788: 
789: 	num_sorted_deferred = 0;
790: 
791: 	nodefer = false;
792: 
793: 	gl_load_state(&saved_state);
794: }
795: 
796: // a texture is being unloaded, invalidate any pending draw calls associated
797: // with it and perform the necessary cleanup
798: void gl_check_deferred(struct texture_set *texture_set)
799: {
800: 	uint32_t i;
801: 
802: 	for (i = 0; i < num_deferred; i++)
803: 	{
804: 		if (deferred_draws[i].state.texture_set == texture_set)
805: 		{
806: 			driver_free(deferred_draws[i].vertices);
807: 			deferred_draws[i].vertices = nullptr;
808: 			driver_free(deferred_draws[i].indices);
809: 			deferred_draws[i].indices = nullptr;
810: 			driver_free(deferred_draws[i].normals);
811: 			deferred_draws[i].normals = nullptr;
812: 			driver_free(deferred_draws[i].boundingbox);
813: 			deferred_draws[i].boundingbox = nullptr;
814: 			driver_free(deferred_draws[i].lightdata);
815: 			deferred_draws[i].lightdata = nullptr;
816: 		}
817: 	}
818: 
819: 	for(i = 0; i < num_sorted_deferred; i++)
820: 	{
821: 		if(deferred_sorted_draws[i].deferred_draw.state.texture_set == texture_set)
822: 		{
823: 			driver_free(deferred_sorted_draws[i].deferred_draw.vertices);
824: 			driver_free(deferred_sorted_draws[i].deferred_draw.indices);
825: 			deferred_sorted_draws[i].drawn = true;
826: 		}
827: 	}
828: }
829: 
830: void gl_cleanup_deferred()
831: {
832: 	driver_free(deferred_draws);
833: 	deferred_draws = nullptr;
834: 	driver_free(deferred_sorted_draws);
835: 	deferred_sorted_draws = nullptr;
836: }
</file>

<file path="src/gl/gl.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <stdio.h>
 24: #include <math.h>
 25: #include <algorithm>
 26: 
 27: #include "../renderer.h"
 28: #include "../cfg.h"
 29: #include "../gl.h"
 30: #include "../macro.h"
 31: #include "../log.h"
 32: #include "../matrix.h"
 33: 
 34: #include "../ff7/widescreen.h"
 35: 
 36: struct matrix d3dviewport_matrix = {
 37: 	1.0f, 0.0f, 0.0f, 0.0f,
 38: 	0.0f, 1.0f, 0.0f, 0.0f,
 39: 	0.0f, 0.0f, 1.0f, 0.0f,
 40: 	0.0f, 0.0f, 0.0f, 1.0f
 41: };
 42: 
 43: struct driver_state current_state;
 44: 
 45: int max_texture_size;
 46: 
 47: extern uint32_t nodefer;
 48: 
 49: // draw a fullscreen quad, respect aspect ratio of source image
 50: void gl_draw_movie_quad_common(uint32_t width, uint32_t height)
 51: {
 52: 	struct game_obj *game_object = common_externals.get_game_object();
 53: 	uint32_t cur_game_width = game_width;
 54: 	if (!ff8)
 55: 	{
 56: 		if (widescreen.getMovieMode() == WM_EXTEND_ONLY)
 57: 		{
 58: 			cur_game_width = wide_game_width;
 59: 		}
 60: 	}
 61: 
 62: 	float ratio = cur_game_width / (float)width;
 63: 	float movieHeight = ratio * height;
 64: 	float movieWidth = ratio * width;
 65: 	float movieOffsetY = (game_height - movieHeight) / 2.0f;
 66: 
 67: 	if (!ff8 && enable_time_cycle) newRenderer.setTimeFilterEnabled(true);
 68: 
 69: 	if (!ff8 && !ff7_field_center) movieOffsetY = 0.0f;
 70: 
 71: 	float movie_quad_x = 0.0f;
 72: 	float movie_quad_y = movieOffsetY;
 73: 	float movie_quad_height = movieHeight + movieOffsetY;
 74: 	float movie_quad_width = movieWidth;
 75: 	if (!ff8)
 76: 	{
 77: 		if (widescreen.getMovieMode() == WM_FILL)
 78: 		{
 79: 			movie_quad_x = wide_viewport_x;
 80: 			movie_quad_y = 0.0f;
 81: 			movie_quad_height = movieHeight + 2 * movieOffsetY;
 82: 			movie_quad_width = wide_game_width;
 83: 		} else if (widescreen.getMovieMode() == WM_EXTEND_ONLY)
 84: 		{
 85: 			movie_quad_x = (game_width - movieWidth) / 2.0f;
 86: 		}
 87: 	}
 88: 
 89: 	/*  y0    y2
 90: 	 x0 +-----+ x2
 91: 		|    /|
 92: 		|   / |
 93: 		|  /  |
 94: 		| /   |
 95: 		|/    |
 96: 	 x1 +-----+ x3
 97: 		y1    y3
 98: 	*/
 99: 
100: 	// 0
101: 	float x0 = movie_quad_x;
102: 	float y0 = movie_quad_y;
103: 	float u0 = 0.0f;
104: 	float v0 = 0.0f;
105: 	// 1
106: 	float x1 = x0;
107: 	float y1 = movie_quad_height;
108: 	float u1 = u0;
109: 	float v1 = 1.0f;
110: 	// 2
111: 	float x2 = x0 + movie_quad_width;
112: 	float y2 = y0;
113: 	float u2 = 1.0f;
114: 	float v2 = v0;
115: 	// 3
116: 	float x3 = x2;
117: 	float y3 = y1;
118: 	float u3 = u2;
119: 	float v3 = v1;
120: 
121: 	struct nvertex vertices[] = {
122: 		{x0, y0, 1.0f, 1.0f, 0xffffffff, 0, u0, v0},
123: 		{x1, y1, 1.0f, 1.0f, 0xffffffff, 0, u1, v1},
124: 		{x2, y2, 1.0f, 1.0f, 0xffffffff, 0, u2, v2},
125: 		{x3, y3, 1.0f, 1.0f, 0xffffffff, 0, u3, v3},
126: 	};
127: 	WORD indices[] = {
128: 		0, 1, 2,
129: 		1, 3, 2
130: 	};
131: 
132: 	current_state.texture_filter = true;
133: 
134: 	internal_set_renderstate(V_NOCULL, 1, game_object);
135: 	internal_set_renderstate(V_DEPTHTEST, 0, game_object);
136: 	internal_set_renderstate(V_DEPTHMASK, 0, game_object);
137: 
138: 	newRenderer.setInterpolationQualifier(RendererInterpolationQualifier::SMOOTH);
139: 	newRenderer.bindVertexBuffer(vertices, 0, 4);
140: 	newRenderer.bindIndexBuffer(indices, 6);
141: 
142: 	newRenderer.isTLVertex(true);
143: 	newRenderer.doTextureFiltering(current_state.texture_filter);
144: 
145: 	newRenderer.draw();
146: }
147: 
148: // draw movie frame
149: void gl_draw_movie_quad(uint32_t width, uint32_t height)
150: {
151: 	struct driver_state saved_state;
152: 
153: 	gl_save_state(&saved_state);
154: 
155: 	gl_draw_movie_quad_common(width, height);
156: 
157: 	gl_load_state(&saved_state);
158: }
159: 
160: // save complete rendering state to memory
161: void gl_save_state(struct driver_state *dest)
162: {
163: 	memcpy(dest, &current_state, sizeof(current_state));
164: }
165: 
166: // restore complete rendering state from memory
167: void gl_load_state(struct driver_state *src)
168: {
169: 	VOBJ(texture_set, texture_set, src->texture_set);
170: 
171: 	memcpy(&current_state, src, sizeof(current_state));
172: 
173: 	gl_bind_texture_set(src->texture_set);
174: 	gl_set_texture(src->texture_handle, src->texture_set ? VREF(texture_set, ogl.gl_set) : NULL);
175: 	current_state.texture_set = src->texture_set;
176: 	common_setviewport(src->viewport[0], src->viewport[1], src->viewport[2], src->viewport[3], 0);
177: 	gl_set_blend_func(src->blend_mode);
178: 	internal_set_renderstate(V_WIREFRAME, src->wireframe, 0);
179: 	// setting V_LINEARFILTER has no side effects
180: 	internal_set_renderstate(V_CULLFACE, src->cullface, 0);
181: 	internal_set_renderstate(V_NOCULL, src->nocull, 0);
182: 	internal_set_renderstate(V_DEPTHTEST, src->depthtest, 0);
183: 	internal_set_renderstate(V_DEPTHMASK, src->depthmask, 0);
184: 	internal_set_renderstate(V_ALPHATEST, src->alphatest, 0);
185: 	internal_set_renderstate(V_ALPHAFUNC, src->alphafunc, 0);
186: 	internal_set_renderstate(V_ALPHAREF, src->alpharef, 0);
187: 	internal_set_renderstate(V_SHADEMODE, src->shademode, 0);
188: 	gl_set_worldview_matrix(&src->world_view_matrix);
189: 	gl_set_d3dprojection_matrix(&src->d3dprojection_matrix);
190: }
191: 
192: void gl_calculate_normals(std::vector<vector3<float>>* pNormals, struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata)
193: {
194: 	bool has_model_data = false;
195: 	static vector3<float> zero = { 0.0f, 0.0f, 0.0f };
196: 	auto& normals = *pNormals;
197: 
198: 	normals.resize(ip->vertexcount);
199: 	std::fill(normals.begin(), normals.end(), zero);
200: 
201: 	// User wants to attempt to load model data
202: 	if (!prefer_lighting_cpu_calculations)
203: 	{
204: 		// If models do provide normal data, use it
205: 		if (polydata->normaldata != NULL)
206: 		{
207: 			for (uint32_t idx = 0; idx < ip->vertexcount; idx++)
208: 			{
209: 				normals[idx] = polydata->has_normindextable ? polydata->normaldata[polydata->normindextabledata[idx]] : polydata->normaldata[idx];
210: 			}
211: 
212: 			has_model_data = true;
213: 		}
214: 	}
215: 
216: 	// If the previous code was not able to fetch the model normal data, we have to calculate it on the CPU
217: 	if (!has_model_data)
218: 	{
219: 		vector3<float> e12, e13, triNormal;
220: 
221: 		// Calculate vertex normals by averaging adjacent triangle normals
222: 		// Vertex normals are calculated here because battle models dont seem to include normals
223: 		for (uint32_t idx = 0; idx < ip->indexcount; idx+=3)
224: 		{
225: 			e12 = e13 = triNormal = zero;
226: 
227: 			int vId0 = ip->indices[idx];
228: 			int vId1 = ip->indices[idx + 1];
229: 			int vId2 = ip->indices[idx + 2];
230: 
231: 			auto v1 = &ip->vertices[vId0]._;
232: 			auto v2 = &ip->vertices[vId1]._;
233: 			auto v3 = &ip->vertices[vId2]._;
234: 
235: 			subtract_vector(v2, v1, &e12);
236: 			subtract_vector(v3, v1, &e13);
237: 			cross_product(&e13, &e12, &triNormal);
238: 
239: 			add_vector(&normals[vId0], &triNormal, &normals[vId0]);
240: 			add_vector(&normals[vId1], &triNormal, &normals[vId1]);
241: 			add_vector(&normals[vId2], &triNormal, &normals[vId2]);
242: 		}
243: 
244: 		for (uint32_t idx = 0; idx < ip->vertexcount; idx++)
245: 		{
246: 			normalize_vector(&normals[idx]);
247: 		}
248: 	}
249: }
250: 
251: void gl_draw_without_lighting(struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip)
252: {
253: 	static std::vector<vector3<float>> normals;
254: 	if (!ff8 && lightdata != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
255: 	{
256: 		gl_calculate_normals(&normals, ip, polydata, lightdata);
257: 		gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, normals.data(), ip->vertexcount, ip->indices, ip->indexcount, 0, 0, lightdata, clip, true);
258: 	} else gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, nullptr, ip->vertexcount, ip->indices, ip->indexcount, 0, 0, lightdata, clip, true);
259: }
260: 
261: // draw a set of primitives with lighting
262: void gl_draw_with_lighting(struct indexed_primitive *ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip)
263: {
264: 	static std::vector<vector3<float>> normals;
265: 	if (!ff8)
266: 	{
267: 		gl_calculate_normals(&normals, ip, polydata, lightdata);
268: 		gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, normals.data(), ip->vertexcount, ip->indices, ip->indexcount, 0, polydata->boundingboxdata, lightdata, clip, true);
269: 	}
270: 	else gl_draw_indexed_primitive(ip->primitivetype, ip->vertextype, ip->vertices, nullptr, ip->vertexcount, ip->indices, ip->indexcount, 0, polydata->boundingboxdata, lightdata, clip, true);
271: }
272: 
273: // main rendering routine, draws a set of primitives according to the current render state
274: void gl_draw_indexed_primitive(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, struct vector3<float>* normals, uint32_t vertexcount, WORD *indices, uint32_t count, struct graphics_object *graphics_object, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap)
275: {
276: 	FILE *log;
277: 	uint32_t i;
278: 	uint32_t mode = getmode_cached()->driver_mode;
279: 	// filter setting can change inside this function, we don't want that to
280: 	// affect the global rendering state so save & restore it
281: 	uint32_t saved_texture_filter = current_state.texture_filter;
282: 
283: 	// should never happen, broken 3rd-party models cause this
284: 	if(!count) return;
285: 
286: 	// scissor test is used to emulate D3D viewports
287: 	if (clip) newRenderer.doScissorTest(true);
288: 	else newRenderer.doScissorTest(false);
289: 
290: 	if(vertextype > TLVERTEX)
291: 	{
292: 		ffnx_unexpected_once("vertextype > TLVERTEX\n");
293: 		return;
294: 	}
295: 
296: 	newRenderer.setInterpolationQualifier(current_state.shademode ? RendererInterpolationQualifier::SMOOTH : RendererInterpolationQualifier::FLAT);
297: 
298: 	// handle some special cases, see special_case.c
299: 	if(gl_special_case(primitivetype, vertextype, vertices, vertexcount, indices, count, graphics_object, clip, mipmap))
300: 	{
301: 		// special cases can signal back to this function that the draw call has
302: 		// been handled in some other manner
303: 		current_state.texture_filter = saved_texture_filter;
304: 		return;
305: 	}
306: 	else if(gl_defer_draw(primitivetype, vertextype, vertices, normals, vertexcount, indices, count, boundingbox, lightdata, clip, mipmap))
307: 	{
308: 		current_state.texture_filter = saved_texture_filter;
309: 		return;
310: 	}
311: 
312: 	bool isLightingEnabledTexture = true;
313: 
314: 	// If we're attaching a texture, and it is an external one, then use a better blending that considers the alpha channel
315: 	if (current_state.texture_set)
316: 	{
317: 		VOBJ(texture_set, texture_set, current_state.texture_set);
318: 
319: 		if (VREF(texture_set, ogl.external)) newRenderer.isExternalTexture(true);
320: 
321: 		if(enable_lighting && VREF(texture_set, ogl.gl_set->disable_lighting))
322: 		{
323: 			isLightingEnabledTexture = false;
324: 		}
325: 	}
326: 
327: 	// OpenGL treats texture filtering as a per-texture parameter, we need it
328: 	// to be consistent with our global render state
329: 	newRenderer.doTextureFiltering(current_state.texture_filter);
330: 
331: 	if(vertextype != TLVERTEX)
332: 	{
333: 		newRenderer.setD3DProjection(&current_state.d3dprojection_matrix);
334: 		newRenderer.setD3DViweport(&d3dviewport_matrix);
335: 	}
336: 
337: 	newRenderer.isTLVertex(vertextype == TLVERTEX);
338: 	newRenderer.isFBTexture(current_state.fb_texture);
339: 
340: 	newRenderer.doModulateAlpha(true);
341: 
342: 	//// upload vertex data
343: 	newRenderer.bindVertexBuffer(vertices, normals, vertexcount);
344: 	newRenderer.bindIndexBuffer(indices, count);
345: 	newRenderer.setPrimitiveType(RendererPrimitiveType(primitivetype));
346: 
347: 	if(!ff8 && lightdata != nullptr && normals != nullptr && game_lighting != GAME_LIGHTING_ORIGINAL)
348: 	{
349: 		newRenderer.setGameLightData(lightdata);
350: 	} else newRenderer.setGameLightData(nullptr);
351: 
352: 	if (!ff8 && enable_lighting && normals != nullptr && isLightingEnabledTexture)
353: 	{
354: 		newRenderer.drawToShadowMap();
355: 		newRenderer.drawWithLighting(true, true);
356: 	}
357: 	else newRenderer.draw();
358: 
359: 	stats.vertex_count += count;
360: 
361: 	current_state.texture_filter = saved_texture_filter;
362: }
363: 
364: void gl_set_worldview_matrix(struct matrix *matrix)
365: {
366: 	newRenderer.setWorldViewMatrix(matrix);
367: 	memcpy(&current_state.world_view_matrix, matrix, sizeof(struct matrix));
368: }
369: 
370: void gl_set_d3dprojection_matrix(struct matrix *matrix)
371: {
372: 	memcpy(&current_state.d3dprojection_matrix, matrix, sizeof(struct matrix));
373: }
374: 
375: // apply blend mode to OpenGL state
376: void gl_set_blend_func(uint32_t blend_mode)
377: {
378: 	if(trace_all) ffnx_trace("set blend mode %i\n", blend_mode);
379: 
380: 	current_state.blend_mode = blend_mode;
381: 
382: 	newRenderer.setBlendMode(RendererBlendMode(blend_mode));
383: }
384: 
385: // draw text on screen using the game font
386: uint32_t gl_draw_text(uint32_t x, uint32_t y, uint32_t color, uint32_t alpha, char *fmt, ...)
387: {
388: 	char text[4096];
389: 	va_list args;
390: 
391: 	va_start(args, fmt);
392: 	vsnprintf(text, 4096, fmt, args);
393: 	newRenderer.printText(x, y, color, text);
394: 	va_end(args);
395: 
396: 	return true;
397: }
</file>

<file path="src/gl/special_case.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #define _USE_MATH_DEFINES
 24: #include <math.h>
 25: 
 26: #include "../gl.h"
 27: #include "../cfg.h"
 28: #include "../macro.h"
 29: #include "../globals.h"
 30: 
 31: #include "../ff7/widescreen.h"
 32: 
 33: #define SAFE_GFXOBJ_CHECK(X, Y) ((X) && (X) == (struct graphics_object *)(Y))
 34: 
 35: // rendering special cases, returns true if the draw call has been handled in
 36: // some way and should not be rendered normally
 37: // it is generally not safe to modify source data directly, a copy should be
 38: // made and rendered separately
 39: uint32_t gl_special_case(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, struct graphics_object *graphics_object, uint32_t clip, uint32_t mipmap)
 40: {
 41: 	uint32_t mode = getmode_cached()->driver_mode;
 42: 	VOBJ(texture_set, texture_set, current_state.texture_set);
 43: 	uint32_t defer = false, force_defer = false;
 44: 
 45: 	// modpath textures rendered in 3D should always be filtered
 46: 	if(vertextype != TLVERTEX && current_state.texture_set && VREF(texture_set, ogl.external)) current_state.texture_filter = true;
 47: 
 48: 	// modpath textures in menu should always be filtered
 49: 	if((mode == MODE_MENU || mode == MODE_MAIN_MENU) && current_state.texture_set && VREF(texture_set, ogl.external)) current_state.texture_filter = true;
 50: 
 51: 	// some modpath textures have filtering forced on
 52: 	if(current_state.texture_set && VREF(texture_set, ogl.gl_set->force_filter) && VREF(texture_set, ogl.external)) current_state.texture_filter = true;
 53: 
 54: 	// Texture filtering mostly does not work well in FF8
 55: 	if(ff8) current_state.texture_filter = enable_bilinear && vertextype != TLVERTEX && current_state.texture_set;
 56: 	else if (enable_bilinear && (vertextype != TLVERTEX || mode == MODE_MENU || mode == MODE_MAIN_MENU || (current_state.texture_set && VREF(texture_set, ogl.gl_set->force_filter)))) current_state.texture_filter = true;
 57: 
 58: 	// some modpath textures have z-sort forced on
 59: 	if(current_state.texture_set && VREF(texture_set, ogl.gl_set->force_zsort) && VREF(texture_set, ogl.external)) defer = true;
 60: 
 61: 	// z-sort by default in menu, unnecessary sorting will be avoided by defer logic
 62: 	if(mode == MODE_MENU || mode == MODE_MAIN_MENU) defer = true;
 63: 
 64: 	if(!ff8)
 65: 	{
 66: 		if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->buster_tex))
 67: 		{
 68: 			// stretch main menu to fullscreen if it is a modpath texture
 69: 			if(VREF(texture_set, ogl.external) && vertexcount == 4)
 70: 			{
 71: 				float texture_ratio = VREF(texture_set, ogl.width) / (float)VREF(texture_set, ogl.height);
 72: 				bool use_wide_vertices = abs(texture_ratio - 16 / (aspect_ratio == AR_WIDESCREEN_16X10 ? 10.f : 9.f)) <= 0.01 && widescreen_enabled;
 73: 				float x = use_wide_vertices ? wide_viewport_x : 0.0f;
 74: 				float y = 0.0f;
 75: 				float width = use_wide_vertices ? wide_viewport_width : game_width;
 76: 				float height = game_height;
 77: 				vertices[0]._.x = x;
 78: 				vertices[0]._.y = y;
 79: 				vertices[0]._.z = 1.0f;
 80: 				vertices[1]._.x = x;
 81: 				vertices[1]._.y = y + height;
 82: 				vertices[1]._.z = 1.0f;
 83: 				vertices[2]._.x = x + width;
 84: 				vertices[2]._.y = y;
 85: 				vertices[2]._.z = 1.0f;
 86: 				vertices[3]._.x = x + width;
 87: 				vertices[3]._.y = y + height;
 88: 				vertices[3]._.z = 1.0f;
 89: 				vertices[0].u = 0.0f;
 90: 				vertices[0].v = 0.0f;
 91: 				vertices[1].u = 0.0f;
 92: 				vertices[1].v = 1.0f;
 93: 				vertices[2].u = 1.0f;
 94: 				vertices[2].v = 0.0f;
 95: 				vertices[3].u = 1.0f;
 96: 				vertices[3].v = 1.0f;
 97: 			}
 98: 		}
 99: 
100: 		if(current_state.texture_set && VREF(texture_set, tex_header))
101: 		{
102: 			VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));
103: 
104: 			if((uint32_t)VREF(tex_header, file.pc_name) > 32)
105: 			{
106: 				// avoid filtering window borders
107: 				if(!_strnicmp(VREF(tex_header, file.pc_name), "menu/btl_win_c_", strlen("menu/btl_win_c_") - 1) && VREF(texture_set, palette_index) == 0) current_state.texture_filter = false;
108: 			}
109: 		}
110: 
111: 		// z-sort select menu elements everywhere
112: 		if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->menu_fade)) defer = true;
113: 		if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->blend_window_bg)) defer = true;
114: 
115: 		if(mode == MODE_FIELD)
116: 		{
117: 			// always z-sort vanilla messages
118: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->window_bg)) force_defer = true;
119: 
120: 			// fix timer messages when window is normal
121: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->_btl_win)) force_defer = true;
122: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_a)) force_defer = true;
123: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_b)) force_defer = true;
124: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_c)) force_defer = true;
125: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->btl_win_d)) force_defer = true;
126: 		}
127: 
128: 		if(mode == MODE_BATTLE)
129: 		{
130: 			// z-sort some GUI elements in battle
131: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->unknown2)) defer = true; // Limit and barrier bar (necessary for ESUI)
132: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->unknown3)) defer = true; // Limit and barrier bar (necessary for ESUI)
133: 			if(SAFE_GFXOBJ_CHECK(graphics_object, ff7_externals.menu_objects->unknown5)) defer = true; // Limit box (necessary for ESUI)
134: 		}
135: 	}
136: 
137: 	if((defer || force_defer) && !ff8) return gl_defer_sorted_draw(primitivetype, vertextype, vertices, vertexcount, indices, count, clip, mipmap, force_defer);
138: 
139: 	return false;
140: }
</file>

<file path="src/gl/texture.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "../renderer.h"
 23: 
 24: #include "../log.h"
 25: #include "../gl.h"
 26: #include "../macro.h"
 27: 
 28: // check to make sure we can actually load a given texture
 29: bool gl_check_texture_dimensions(uint32_t width, uint32_t height, char *source)
 30: {
 31: 	if (width > max_texture_size || height > max_texture_size) {
 32: 		ffnx_error("Texture dimensions exceed max texture size, will not be able to load %s\n", source);
 33: 		return false;
 34: 	}
 35: 	else
 36: 		return true;
 37: }
 38: 
 39: // apply OpenGL texture for a certain palette in a texture set, possibly
 40: // replacing an existing texture which will then be unloaded
 41: void gl_replace_texture(struct texture_set *texture_set, uint32_t palette_index, uint32_t new_texture)
 42: {
 43: 	VOBJ(texture_set, texture_set, texture_set);
 44: 
 45: 	if(VREF(texture_set, texturehandle[palette_index]))
 46: 	{
 47: 		if (VREF(texture_set, ogl.external) && !VREF(texture_set, ogl.gl_set->is_animated)) ffnx_glitch("oops, may have messed up an external texture\n");
 48: 		if (!VREF(texture_set, ogl.external) || !VREF(texture_set, ogl.gl_set->is_animated)) newRenderer.deleteTexture(VREF(texture_set, texturehandle[palette_index]));
 49: 	}
 50: 
 51: 	VRASS(texture_set, texturehandle[palette_index], new_texture);
 52: }
 53: 
 54: // upload texture for a texture set from raw pixel data
 55: void gl_upload_texture(struct texture_set *texture_set, uint32_t palette_index, void *image_data, uint32_t format)
 56: {
 57: 	uint32_t w, h;
 58: 	VOBJ(texture_set, texture_set, texture_set);
 59: 	VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));
 60: 
 61: 	if(VREF(texture_set, ogl.external))
 62: 	{
 63: 		w = VREF(texture_set, ogl.width);
 64: 		h = VREF(texture_set, ogl.height);
 65: 	}
 66: 	else
 67: 	{
 68: 		w = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.w) : VREF(tex_header, tex_format.width);
 69: 		h = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.h) : VREF(tex_header, tex_format.height);
 70: 	}
 71: 
 72: 	gl_check_texture_dimensions(w, h, "unknown");
 73: 
 74: 	uint32_t newTexture = newRenderer.createTexture(
 75: 		(uint8_t*)image_data,
 76: 		w,
 77: 		h,
 78: 		0,
 79: 		RendererTextureType(format)
 80: 	);
 81: 
 82: 	gl_replace_texture(
 83: 		texture_set,
 84: 		palette_index,
 85: 		newTexture
 86: 	);
 87: 
 88: 	if (trace_all) ffnx_trace("Created internal texture: %u\n", newTexture);
 89: }
 90: 
 91: // prepare texture set for rendering
 92: void gl_bind_texture_set(struct texture_set *_texture_set)
 93: {
 94: 	VOBJ(texture_set, texture_set, _texture_set);
 95: 
 96: 	if(VPTR(texture_set))
 97: 	{
 98: 		VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));
 99: 
100: 		struct gl_texture_set* gl_set = VREF(texture_set, ogl.gl_set);
101: 
102: 		gl_set_texture(VREF(texture_set, texturehandle[VREF(tex_header, palette_index)]), gl_set);
103: 
104: 		if(VREF(tex_header, version) == FB_TEX_VERSION) current_state.fb_texture = true;
105: 		else current_state.fb_texture = false;
106: 	}
107: 	else gl_set_texture(0, NULL);
108: 
109: 	current_state.texture_set = _texture_set;
110: }
111: 
112: // prepare an OpenGL texture for rendering, passing zero to this function will
113: // disable texturing entirely
114: void gl_set_texture(uint32_t texture, struct gl_texture_set* gl_set)
115: {
116: 	if(trace_all) ffnx_trace("gl_set_texture: set texture %i\n", texture);
117: 
118: 	newRenderer.useTexture(texture);
119: 
120: 	// Attach additional textures only for non-paletted static textures
121: 	if (gl_set && !gl_set->is_animated)
122: 	{
123: 		for (short slot = RendererTextureSlot::TEX_NML; slot < RendererTextureSlot::COUNT; slot++)
124: 			newRenderer.useTexture(texture > 0 ? gl_set->additional_textures[slot] : 0, slot);
125: 	}
126: 
127: 	current_state.texture_handle = texture;
128: 	current_state.texture_set = 0;
129: }
</file>

<file path="src/image/image.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <stdio.h>
 24: #include <libpng16/png.h>
 25: 
 26: #include "image.h"
 27: #include "../common.h"
 28: #include "../renderer.h"
 29: #include "log.h"
 30: 
 31: static void LibPngErrorCb(png_structp png_ptr, const char* error)
 32: {
 33:     ffnx_error("libpng error: %s\n", error);
 34: }
 35: 
 36: static void LibPngWarningCb(png_structp png_ptr, const char* warning)
 37: {
 38:     ffnx_info("libpng warning: %s\n", warning);
 39: }
 40: 
 41: bool loadPng(const char *filename, bimg::ImageMip &mip, bimg::TextureFormat::Enum targetFormat)
 42: {
 43:     FILE* file = fopen(filename, "rb");
 44: 
 45:     if (!file)
 46:     {
 47:         return false;
 48:     }
 49: 
 50:     png_infop info_ptr = nullptr;
 51:     png_structp png_ptr = nullptr;
 52: 
 53:     png_uint_32 _width = 0, _height = 0;
 54:     png_byte color_type = 0, bit_depth = 0;
 55: 
 56:     png_bytepp rowptrs = nullptr;
 57:     size_t rowbytes = 0;
 58: 
 59:     uint8_t* data = nullptr;
 60:     size_t datasize = 0;
 61: 
 62:     fseek(file, 0, SEEK_END);
 63:     datasize = ftell(file);
 64:     fseek(file, 0, SEEK_SET);
 65: 
 66:     png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, (png_voidp)0, LibPngErrorCb, LibPngWarningCb);
 67: 
 68:     if (!png_ptr)
 69:     {
 70:         fclose(file);
 71: 
 72:         return false;
 73:     }
 74: 
 75:     info_ptr = png_create_info_struct(png_ptr);
 76: 
 77:     if (!info_ptr)
 78:     {
 79:         png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
 80: 
 81:         fclose(file);
 82: 
 83:         return false;
 84:     }
 85: 
 86:     if (setjmp(png_jmpbuf(png_ptr)))
 87:     {
 88:         png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
 89: 
 90:         fclose(file);
 91: 
 92:         return false;
 93:     }
 94: 
 95:     png_init_io(png_ptr, file);
 96: 
 97:     png_set_filter(png_ptr, 0, PNG_FILTER_NONE);
 98: 
 99:     if (!Renderer::doesItFitInMemory(datasize))
100:     {
101:         png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
102: 
103:         fclose(file);
104: 
105:         return false;
106:     }
107: 
108:     int transforms = PNG_TRANSFORM_EXPAND;
109: 
110:     if (targetFormat == bimg::TextureFormat::BGRA8) {
111:         transforms |= PNG_TRANSFORM_STRIP_16 | PNG_TRANSFORM_GRAY_TO_RGB | PNG_TRANSFORM_BGR;
112:     } else if (targetFormat == bimg::TextureFormat::RGBA8) {
113:         transforms |= PNG_TRANSFORM_STRIP_16 | PNG_TRANSFORM_GRAY_TO_RGB;
114:     }
115: 
116:     png_read_png(png_ptr, info_ptr, transforms, NULL);
117: 
118:     color_type = png_get_color_type(png_ptr, info_ptr);
119:     bit_depth = png_get_bit_depth(png_ptr, info_ptr);
120:     _width = png_get_image_width(png_ptr, info_ptr);
121:     _height = png_get_image_height(png_ptr, info_ptr);
122: 
123:     if (color_type == PNG_COLOR_TYPE_RGB && (targetFormat == bimg::TextureFormat::BGRA8 || targetFormat == bimg::TextureFormat::RGBA8)) {
124:         ffnx_warning("%s: PNG files without alpha is not supported, please convert it to RGBA for improved performance\n", __func__);
125: 
126:         return false;
127:     }
128: 
129:     rowptrs = png_get_rows(png_ptr, info_ptr);
130:     rowbytes = png_get_rowbytes(png_ptr, info_ptr);
131: 
132:     datasize = rowbytes * _height;
133: 
134:     if (trace_all || trace_loaders) ffnx_trace("%s: data_size=%d width=%d height=%d bit_depth=%d color_type=%X\n", __func__, datasize, _width, _height, bit_depth, color_type);
135: 
136:     if (!Renderer::doesItFitInMemory(datasize))
137:     {
138:         png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
139: 
140:         fclose(file);
141: 
142:         return false;
143:     }
144: 
145:     data = (uint8_t*)driver_calloc(datasize, sizeof(uint8_t));
146: 
147:     for (png_uint_32 y = 0; y < _height; y++) memcpy(data + (rowbytes * y), rowptrs[y], rowbytes);
148: 
149:     png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
150: 
151:     fclose(file);
152: 
153:     // ------------------------------------------------------------
154: 
155:     bimg::TextureFormat::Enum texFmt = bimg::TextureFormat::Unknown;
156: 
157:     switch (bit_depth)
158:     {
159:     case 8:
160:     {
161:         switch (color_type)
162:         {
163:         case PNG_COLOR_TYPE_GRAY:
164:             texFmt = bimg::TextureFormat::R8;
165:             break;
166:         case PNG_COLOR_TYPE_GRAY_ALPHA:
167:             texFmt = bimg::TextureFormat::RG8;
168:             break;
169:         case PNG_COLOR_TYPE_RGB:
170:             texFmt = bimg::TextureFormat::RGB8;
171:             break;
172:         case PNG_COLOR_TYPE_RGBA:
173:         case PNG_COLOR_TYPE_PALETTE:
174:             texFmt = bimg::TextureFormat::RGBA8;
175:             break;
176:         }
177:         break;
178:     }
179:     case 16:
180:     {
181:         switch (color_type)
182:         {
183:         case PNG_COLOR_TYPE_GRAY:
184:             texFmt = bimg::TextureFormat::R16;
185:             break;
186:         case PNG_COLOR_TYPE_GRAY_ALPHA:
187:             texFmt = bimg::TextureFormat::RG16;
188:             break;
189:         case PNG_COLOR_TYPE_RGB:
190:         case PNG_COLOR_TYPE_RGBA:
191:             texFmt = bimg::TextureFormat::RGBA16;
192:             break;
193:         case PNG_COLOR_TYPE_PALETTE:
194:             break;
195:         }
196:         break;
197:     }
198:     default:
199:         break;
200:     }
201: 
202:     if (texFmt != bimg::TextureFormat::Unknown)
203:     {
204:         mip.m_blockSize = 0;
205:         mip.m_bpp = 0;
206:         mip.m_data = data;
207:         mip.m_depth = 0;
208:         mip.m_format = texFmt;
209:         mip.m_hasAlpha = true;
210:         mip.m_size = datasize;
211:         mip.m_width = _width;
212:         mip.m_height = _height;
213: 
214:         return true;
215:     }
216:     else
217:     {
218:         driver_free(data);
219:     }
220: 
221:     return false;
222: }
223: 
224: bool parseDds(const char *filename, DirectX::ScratchImage &image, DirectX::TexMetadata &metadata)
225: {
226:     wchar_t filenameW[MAX_PATH];
227: 
228:     mbstowcs(filenameW, filename, MAX_PATH);
229: 
230:     HRESULT hr = DirectX::LoadFromDDSFile(
231:         filenameW,
232:         DirectX::DDS_FLAGS_NONE, &metadata, image
233:     );
234:     if (FAILED(hr) || image.GetImageCount() == 0)
235:     {
236:         ffnx_error("%s: Load DDS from file error (%d)\n", __func__, HRESULT_CODE(hr));
237: 
238:         return false;
239:     }
240: 
241:     return true;
242: }
243: 
244: bimg::ImageContainer *convertDds(bx::AllocatorI *allocator, DirectX::ScratchImage &image, const DirectX::TexMetadata &metadata, bimg::TextureFormat::Enum targetFormat, int lod)
245: {
246:     if (lod >= image.GetImageCount())
247:     {
248:         lod = image.GetImageCount() - 1;
249:     }
250: 
251:     const DirectX::Image &mainImage = image.GetImages()[lod];
252:     DXGI_FORMAT format = DXGI_FORMAT_R8G8B8A8_UNORM;
253: 
254:     if (targetFormat == bimg::TextureFormat::BGRA8) {
255:         format = DXGI_FORMAT_B8G8R8A8_UNORM;
256:     } else {
257:         targetFormat = bimg::TextureFormat::RGBA8;
258:     }
259: 
260:     DirectX::ScratchImage out;
261:     HRESULT hr;
262:     if (DirectX::IsCompressed(image.GetMetadata().format))
263:     {
264:         hr = DirectX::Decompress(mainImage, format, out);
265:         image.Release();
266:     }
267:     else if (image.GetMetadata().format != format)
268:     {
269:         hr = DirectX::Convert(mainImage, format, DirectX::TEX_FILTER_DEFAULT, DirectX::TEX_THRESHOLD_DEFAULT, out);
270:         image.Release();
271:     }
272:     else
273:     {
274:         if (!Renderer::doesItFitInMemory(mainImage.rowPitch * mainImage.height + 1)) {
275:             return nullptr;
276:         }
277: 
278:         return bimg::imageAlloc(allocator, targetFormat, mainImage.width, mainImage.height, 0, 1, false, false, mainImage.pixels);
279:     }
280: 
281:     if (FAILED(hr) || out.GetImageCount() == 0)
282:     {
283:         ffnx_error("%s: Convert DDS error (%d)\n", __func__, HRESULT_CODE(hr));
284: 
285:         return nullptr;
286:     }
287: 
288:     const DirectX::Image &mainImage2 = out.GetImages()[0];
289: 
290:     if (!Renderer::doesItFitInMemory(mainImage2.rowPitch * mainImage2.height + 1)) {
291:         return nullptr;
292:     }
293: 
294:     return bimg::imageAlloc(allocator, targetFormat, mainImage2.width, mainImage2.height, 0, 1, false, false, mainImage2.pixels);
295: }
296: 
297: bimg::ImageContainer *loadImageContainer(bx::AllocatorI *allocator, const char *filename, bimg::TextureFormat::Enum targetFormat)
298: {
299:     FILE* file = fopen(filename, "rb");
300: 
301:     if (!file)
302:     {
303:         return nullptr;
304:     }
305: 
306:     size_t filesize = 0;
307:     char* buffer = nullptr;
308: 
309:     fseek(file, 0, SEEK_END);
310:     filesize = ftell(file);
311: 
312:     if (Renderer::doesItFitInMemory(filesize + 1))
313:     {
314:         buffer = (char*)driver_malloc(filesize + 1);
315:         fseek(file, 0, SEEK_SET);
316:         fread(buffer, filesize, 1, file);
317:     }
318: 
319:     fclose(file);
320: 
321:     if (buffer == nullptr)
322:     {
323:         return nullptr;
324:     }
325: 
326:     bimg::ImageContainer* img = bimg::imageParse(allocator, buffer, filesize + 1, targetFormat);
327: 
328:     driver_free(buffer);
329: 
330:     return img;
331: }
</file>

<file path="src/image/image.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include <stdint.h>
26: #include <bimg/bimg.h>
27: #include <DirectXTex.h>
28: 
29: bimg::ImageContainer *loadImageContainer(bx::AllocatorI *allocator, const char *filename, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Count);
30: // Fast PNG opening, you need to deallocate mip.m_data yourself
31: bool loadPng(const char *filename, bimg::ImageMip &mip, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Count);
32: // Fast DDS opening
33: bool parseDds(const char *filename, DirectX::ScratchImage &image, DirectX::TexMetadata &metadata);
34: bimg::ImageContainer *convertDds(bx::AllocatorI *allocator, DirectX::ScratchImage &image, const DirectX::TexMetadata &metadata, bimg::TextureFormat::Enum targetFormat, int lod);
</file>

<file path="src/image/tim.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include "tim.h"
 24: 
 25: #include "../common.h"
 26: #include "../log.h"
 27: #include "../saveload.h"
 28: 
 29: TimRect::TimRect() :
 30: 	palIndex(0), x1(0), y1(0), x2(0), y2(0)
 31: {
 32: }
 33: 
 34: TimRect::TimRect(uint32_t palIndex, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2) :
 35: 	palIndex(palIndex), x1(x1), y1(y1), x2(x2), y2(y2)
 36: {
 37: }
 38: 
 39: bool TimRect::match(uint32_t x, uint32_t y) const
 40: {
 41: 	return x >= x1 && x <= x2 && y >= y1 && y <= y2;
 42: }
 43: 
 44: bool TimRect::isValid() const
 45: {
 46: 	return x1 != x2 || y1 != y2;
 47: }
 48: 
 49: int operator==(const TimRect &rect, const TimRect &other)
 50: {
 51: 	return rect.palIndex == other.palIndex
 52: 		&& rect.x1 == other.x1
 53: 		&& rect.y1 == other.y1
 54: 		&& rect.x2 == other.x2
 55: 		&& rect.y2 == other.y2;
 56: }
 57: 
 58: bool operator<(const TimRect &rect, const TimRect &other)
 59: {
 60: 	return ((uint64_t(rect.palIndex) << 56) | (uint64_t(rect.x1) << 28) | uint64_t(rect.y1)) < ((uint64_t(other.palIndex) << 56) | (uint64_t(other.x1) << 28) | uint64_t(other.y1));
 61: }
 62: 
 63: Tim::Tim(Bpp bpp, const ff8_tim &tim, int lineSkip) :
 64: 	_bpp(bpp), _tim(tim), _lineSkip(lineSkip)
 65: {
 66: 	_tim.img_w *= 4 >> int(bpp);
 67: }
 68: 
 69: uint32_t PaletteDetectionStrategyFixed::palOffset(uint16_t, uint16_t) const
 70: {
 71: 	return _palX + _palY * _tim->_tim.pal_w;
 72: }
 73: 
 74: uint32_t PaletteDetectionStrategyFixed::palIndex() const
 75: {
 76: 	if (_tim->bpp() == Tim::Bpp16)
 77: 	{
 78: 		return 0;
 79: 	}
 80: 
 81: 	if (_tim->bpp() == Tim::Bpp8 || _tim->paletteWidth() == 16)
 82: 	{
 83: 		return _palY;
 84: 	}
 85: 
 86: 	int palPerLine = _tim->paletteWidth() / 16;
 87: 
 88: 	return _palY * palPerLine + _palX / 16;
 89: }
 90: 
 91: bool Tim::save(const char *fileName, bool withAlpha) const
 92: {
 93: 	PaletteDetectionStrategyFixed fixed(this, 0, 0);
 94: 	return fixed.isValid() && save(fileName, &fixed, withAlpha);
 95: }
 96: 
 97: bool Tim::save(const char *fileName, uint8_t paletteId, bool withAlpha) const
 98: {
 99: 	PaletteDetectionStrategyFixed fixed(this, 0, 0);
100: 	return fixed.isValid() && save(fileName, &fixed, withAlpha, paletteId);
101: }
102: 
103: bool Tim::save(const char *fileName, uint8_t palX, uint8_t palY, bool withAlpha) const
104: {
105: 	PaletteDetectionStrategyFixed fixed(this, palX, palY);
106: 	return fixed.isValid() && save(fileName, &fixed, withAlpha);
107: }
108: 
109: bool Tim::toRGBA32(uint32_t *target, uint8_t palX, uint8_t palY, bool withAlpha) const
110: {
111: 	PaletteDetectionStrategyFixed fixed(this, palX, palY);
112: 	return fixed.isValid() && toRGBA32(target, &fixed, withAlpha);
113: }
114: 
115: PaletteDetectionStrategyGrid::PaletteDetectionStrategyGrid(const Tim *const tim, uint8_t cellCols, uint8_t cellRows, uint16_t colorsPerPal, uint8_t palColsPerRow) :
116: 	PaletteDetectionStrategy(tim), _cellCols(cellCols), _cellRows(cellRows), _colorsPerPal(colorsPerPal), _palColsPerRow(palColsPerRow)
117: {
118: 	if (_colorsPerPal == 0)
119: 	{
120: 		_colorsPerPal = tim->bpp() == Tim::Bpp4 ? 16 : 256;
121: 	}
122: 	_palCols = tim->_tim.pal_w / _colorsPerPal;
123: 	_cellWidth = tim->_tim.img_w / _cellCols;
124: 	_cellHeight = tim->_tim.img_h / _cellRows;
125: }
126: 
127: bool PaletteDetectionStrategyGrid::isValid() const
128: {
129: 	if (_tim->_bpp == Tim::Bpp16)
130: 	{
131: 		ffnx_error("PaletteDetectionStrategyGrid::%s bpp should not be 2\n", __func__);
132: 		return false;
133: 	}
134: 
135: 	if (_tim->_tim.img_w % _cellCols != 0)
136: 	{
137: 		ffnx_error("PaletteDetectionStrategyGrid::%s img_w=%d mod cellCols=%d != 0\n", __func__, _tim->_tim.img_w, _cellCols);
138: 		return false;
139: 	}
140: 
141: 	if (_tim->_tim.pal_h * _palCols != _cellCols * _cellRows)
142: 	{
143: 		ffnx_error("PaletteDetectionStrategyGrid::%s not enough palette for this image %d (%d * %d)\n", __func__, _palCols, _tim->_tim.pal_w, _tim->_tim.pal_h);
144: 		return false;
145: 	}
146: 
147: 	return true;
148: }
149: 
150: uint32_t PaletteDetectionStrategyGrid::palOffset(uint16_t imgX, uint16_t imgY) const
151: {
152: 	// Direction: top to bottom then left to right
153: 	uint16_t cellX = imgX / _cellWidth, cellY = imgY / _cellHeight;
154: 	int palId = (cellX % _palColsPerRow) + cellY * _palColsPerRow + (cellX / _palColsPerRow) * (_cellRows * _palColsPerRow);
155: 	uint16_t palX = (palId % _palCols) * _colorsPerPal, palY = palId / _palCols;
156: 
157: 	return palX + palY * _tim->_tim.pal_w;
158: }
159: 
160: uint32_t PaletteDetectionStrategyGrid::palIndex() const
161: {
162: 	return 0;
163: }
164: 
165: bool Tim::saveMultiPaletteGrid(const char *fileName, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal, uint8_t palColsPerRow, bool withAlpha) const
166: {
167: 	PaletteDetectionStrategyGrid grid(this, cellCols, cellRows, colorsPerPal, palColsPerRow);
168: 	return grid.isValid() && save(fileName, &grid, withAlpha);
169: }
170: 
171: bool Tim::toRGBA32MultiPaletteGrid(uint32_t *target, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal, uint8_t palColsPerRow, bool withAlpha) const
172: {
173: 	PaletteDetectionStrategyGrid grid(this, cellCols, cellRows, colorsPerPal, palColsPerRow);
174: 	return grid.isValid() && toRGBA32(target, &grid, withAlpha);
175: }
176: 
177: 
178: 
179: PaletteDetectionStrategyTrianglesAndQuads::PaletteDetectionStrategyTrianglesAndQuads(const Tim *const tim, const std::vector<TimRect> &rectangles) :
180: 	PaletteDetectionStrategy(tim), _rectangles(rectangles)
181: {
182: }
183: 
184: uint32_t PaletteDetectionStrategyTrianglesAndQuads::palOffset(uint16_t imgX, uint16_t imgY) const
185: {
186: 	for (const TimRect &rectangle: _rectangles) {
187: 		if (rectangle.match(imgX, imgY)) {
188: 			return rectangle.palIndex * _tim->_tim.pal_w;
189: 		}
190: 	}
191: 
192: 	return 0;
193: }
194: 
195: uint32_t PaletteDetectionStrategyTrianglesAndQuads::palIndex() const
196: {
197: 	return 0;
198: }
199: 
200: bool Tim::saveMultiPaletteTrianglesAndQuads(const char *fileName, const std::vector<TimRect> &rectangles, bool withAlpha) const
201: {
202: 	PaletteDetectionStrategyTrianglesAndQuads strategy(this, rectangles);
203: 	return strategy.isValid() && save(fileName, &strategy, withAlpha);
204: }
205: 
206: bool Tim::toRGBA32MultiPaletteTrianglesAndQuads(uint32_t *target, const std::vector<TimRect> &rectangles, bool withAlpha) const
207: {
208: 	PaletteDetectionStrategyTrianglesAndQuads strategy(this, rectangles);
209: 	return strategy.isValid() && toRGBA32(target, &strategy, withAlpha);
210: }
211: 
212: bool Tim::toRGBA32(uint32_t *target, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha) const
213: {
214: 	if (_tim.img_data == nullptr)
215: 	{
216: 		ffnx_error("%s img_data is null\n", __func__);
217: 
218: 		return false;
219: 	}
220: 
221: 	if (_bpp == Bpp4)
222: 	{
223: 		if (_tim.pal_data == nullptr || paletteDetectionStrategy == nullptr)
224: 		{
225: 			uint8_t *img_data8 = _tim.img_data;
226: 
227: 			for (int y = 0; y < _tim.img_h; ++y)
228: 			{
229: 				for (int x = 0; x < _tim.img_w / 2; ++x)
230: 				{
231: 					// Grey color
232: 					uint8_t color = (*img_data8 & 0xF) * 16;
233: 
234: 					*target = ((color == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
235: 						(color << 16) | (color << 8) | color;
236: 
237: 					++target;
238: 
239: 					color = (*img_data8 >> 4) * 16;
240: 
241: 					*target = ((color == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
242: 						(color << 16) | (color << 8) | color;
243: 
244: 					++target;
245: 					++img_data8;
246: 				}
247: 
248: 				img_data8 += _lineSkip / 2;
249: 			}
250: 		}
251: 		else
252: 		{
253: 			uint8_t *img_data = _tim.img_data;
254: 
255: 			for (int y = 0; y < _tim.img_h; ++y)
256: 			{
257: 				for (int x = 0; x < _tim.img_w / 2; ++x)
258: 				{
259: 					*target = fromR5G5B5Color((_tim.pal_data + paletteDetectionStrategy->palOffset(x * 2, y))[*img_data & 0xF], withAlpha);
260: 
261: 					++target;
262: 
263: 					*target = fromR5G5B5Color((_tim.pal_data + paletteDetectionStrategy->palOffset(x * 2 + 1, y))[*img_data >> 4], withAlpha);
264: 
265: 					++target;
266: 					++img_data;
267: 				}
268: 
269: 				img_data += _lineSkip / 2;
270: 			}
271: 		}
272: 	}
273: 	else if (_bpp == Bpp8)
274: 	{
275: 		if (_tim.pal_data == nullptr || paletteDetectionStrategy == nullptr)
276: 		{
277: 			uint8_t *img_data8 = _tim.img_data;
278: 
279: 			for (int y = 0; y < _tim.img_h; ++y)
280: 			{
281: 				for (int x = 0; x < _tim.img_w; ++x)
282: 				{
283: 					// Grey color
284: 					*target = ((*img_data8 == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
285: 						(*img_data8 << 16) | (*img_data8 << 8) | *img_data8;
286: 
287: 					++target;
288: 					++img_data8;
289: 				}
290: 
291: 				img_data8 += _lineSkip;
292: 			}
293: 		}
294: 		else
295: 		{
296: 			uint8_t *img_data = _tim.img_data;
297: 
298: 			for (int y = 0; y < _tim.img_h; ++y)
299: 			{
300: 				for (int x = 0; x < _tim.img_w; ++x)
301: 				{
302: 					*target = fromR5G5B5Color((_tim.pal_data + paletteDetectionStrategy->palOffset(x, y))[*img_data], withAlpha);
303: 
304: 					++target;
305: 					++img_data;
306: 				}
307: 
308: 				img_data += _lineSkip;
309: 			}
310: 		}
311: 	}
312: 	else if (_bpp == Bpp16)
313: 	{
314: 		uint16_t *img_data16 = (uint16_t *)_tim.img_data;
315: 
316: 		for (int y = 0; y < _tim.img_h; ++y)
317: 		{
318: 			for (int x = 0; x < _tim.img_w; ++x)
319: 			{
320: 				*target = fromR5G5B5Color(*img_data16, withAlpha);
321: 
322: 				++target;
323: 				++img_data16;
324: 			}
325: 
326: 			img_data16 += _lineSkip;
327: 		}
328: 	}
329: 	else
330: 	{
331: 		ffnx_error("%s unknown bpp %d\n", __func__, _bpp);
332: 
333: 		return false;
334: 	}
335: 
336: 	return true;
337: }
338: 
339: Tim Tim::chunk(int x, int y, int w, int h)
340: {
341: 	ff8_tim infos = ff8_tim();
342: 	infos.img_data = _tim.img_data + (x + y * imageWidth()) * 2;
343: 	infos.img_x = _tim.img_x + x;
344: 	infos.img_y = _tim.img_y + y;
345: 	infos.img_w = w;
346: 	infos.img_h = h;
347: 	infos.pal_data = _tim.pal_data;
348: 	infos.pal_x = _tim.pal_x;
349: 	infos.pal_y = _tim.pal_y;
350: 	infos.pal_w = _tim.pal_w;
351: 	infos.pal_h = _tim.pal_h;
352: 
353: 	return Tim(_bpp, infos, _tim.img_w - w * (4 >> int(_bpp)));
354: }
355: 
356: bool Tim::save(const char *fileName, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha, int forcePaletteId) const
357: {
358: 	// allocate PBO
359: 	uint32_t image_data_size = _tim.img_w * _tim.img_h * 4;
360: 	uint32_t *image_data = (uint32_t*)driver_malloc(image_data_size);
361: 
362: 	// convert source data
363: 	if (image_data != nullptr)
364: 	{
365: 		if (toRGBA32(image_data, paletteDetectionStrategy, withAlpha))
366: 		{
367: 			save_texture(image_data, image_data_size, _tim.img_w, _tim.img_h, forcePaletteId >= 0 ? forcePaletteId : (paletteDetectionStrategy != nullptr ? paletteDetectionStrategy->palIndex() : 0), fileName, false);
368: 		}
369: 
370: 		driver_free(image_data);
371: 	}
372: 
373: 	return true;
374: }
375: 
376: Tim Tim::fromLzsData(const uint8_t *uncompressed_data)
377: {
378: 	const uint16_t *header = (const uint16_t *)uncompressed_data;
379: 	ff8_tim tim_infos = ff8_tim();
380: 	tim_infos.img_w = header[2];
381: 	tim_infos.img_h = header[3];
382: 	tim_infos.img_data = (uint8_t *)uncompressed_data + 8;
383: 
384: 	return Tim(Bpp::Bpp16, tim_infos);
385: }
386: 
387: struct TimDataHeader {
388: 	uint32_t size;
389: 	uint16_t x, y;
390: 	uint16_t w, h;
391: };
392: 
393: Tim Tim::fromTimData(const uint8_t *data)
394: {
395: 	Bpp bpp = Bpp(data[4] & 3);
396: 	bool hasPal = (data[4] & 8) != 0;
397: 	TimDataHeader palHeader = TimDataHeader();
398: 	ff8_tim tim_infos = ff8_tim();
399: 
400: 	if (hasPal)
401: 	{
402: 		memcpy(&palHeader, data + 8, sizeof(palHeader));
403: 
404: 		tim_infos.pal_data = (uint16_t *)(data + 8 + sizeof(palHeader));
405: 		tim_infos.pal_x = palHeader.x;
406: 		tim_infos.pal_y = palHeader.y;
407: 		tim_infos.pal_w = palHeader.w;
408: 		tim_infos.pal_h = palHeader.h;
409: 	}
410: 
411: 	TimDataHeader imgHeader = TimDataHeader();
412: 	memcpy(&imgHeader, data + 8 + palHeader.size, sizeof(imgHeader));
413: 
414: 	tim_infos.img_data = (uint8_t *)data + 8 + palHeader.size + sizeof(imgHeader);
415: 	tim_infos.img_x = imgHeader.x;
416: 	tim_infos.img_y = imgHeader.y;
417: 	tim_infos.img_w = imgHeader.w;
418: 	tim_infos.img_h = imgHeader.h;
419: 
420: 	return Tim(bpp, tim_infos);
421: }
422: 
423: uint16_t Tim::colorsPerPal() const
424: {
425: 	if (_bpp == Bpp8)
426: 	{
427: 		return 256;
428: 	}
429: 	else if (_bpp == Bpp4)
430: 	{
431: 		return 16;
432: 	}
433: 
434: 	return 0;
435: }
</file>

<file path="src/image/tim.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <stdint.h>
 26: #include <vector>
 27: #include "../ff8.h"
 28: 
 29: struct TimRect {
 30: 	TimRect();
 31: 	TimRect(uint32_t palIndex, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2);
 32: 	bool match(uint32_t x, uint32_t y) const;
 33: 	bool isValid() const;
 34: 	uint32_t palIndex;
 35: 	uint32_t x1, y1;
 36: 	uint32_t x2, y2;
 37: };
 38: 
 39: int operator==(const TimRect &rectangle, const TimRect &other);
 40: bool operator<(const TimRect &rectangle, const TimRect &other);
 41: 
 42: inline uint32_t fromR5G5B5Color(uint16_t color, bool withAlpha = false)
 43: {
 44: 	uint8_t r = color & 0x1F,
 45: 		g = (color >> 5) & 0x1F,
 46: 		b = (color >> 10) & 0x1F;
 47: 
 48: 	return ((color == 0 && withAlpha ? 0x00 : 0xffu) << 24) |
 49: 		((((r << 3) + (r >> 2)) & 0xffu) << 16) |
 50: 		((((g << 3) + (g >> 2)) & 0xffu) << 8) |
 51: 		(((b << 3) + (b >> 2)) & 0xffu);
 52: }
 53: 
 54: class Tim;
 55: 
 56: class PaletteDetectionStrategy {
 57: public:
 58: 	PaletteDetectionStrategy(const Tim *const tim) : _tim(tim) {};
 59: 	virtual bool isValid() const {
 60: 		return true;
 61: 	}
 62: 	virtual uint32_t palOffset(uint16_t x, uint16_t y) const = 0;
 63: 	virtual uint32_t palIndex() const = 0;
 64: protected:
 65: 	const Tim *const _tim;
 66: };
 67: 
 68: // One palette at (x, y)
 69: class PaletteDetectionStrategyFixed : public PaletteDetectionStrategy {
 70: public:
 71: 	PaletteDetectionStrategyFixed(const Tim *const tim, uint16_t palX, uint16_t palY) :
 72: 		PaletteDetectionStrategy(tim), _palX(palX), _palY(palY) {}
 73: 	virtual uint32_t palOffset(uint16_t imgX, uint16_t imgY) const override;
 74: 	virtual uint32_t palIndex() const override;
 75: private:
 76: 	uint16_t _palX, _palY;
 77: };
 78: 
 79: // A grid of fixed size cells, with one palette per cell
 80: class PaletteDetectionStrategyGrid : public PaletteDetectionStrategy {
 81: public:
 82: 	enum Direction {
 83: 		TopBottomLeftRight,
 84: 		LeftRightTopBottom
 85: 	};
 86: 	PaletteDetectionStrategyGrid(const Tim *const tim, uint8_t cellCols, uint8_t cellRows, uint16_t colorsPerPal, uint8_t palColsPerRow);
 87: 	virtual bool isValid() const override;
 88: 	virtual uint32_t palOffset(uint16_t imgX, uint16_t imgY) const override;
 89: 	virtual uint32_t palIndex() const override;
 90: private:
 91: 	uint8_t _cellCols, _cellRows;
 92: 	uint16_t _cellWidth, _cellHeight;
 93: 	uint16_t _colorsPerPal;
 94: 	uint8_t _palColsPerRow;
 95: 	uint8_t _palCols;
 96: };
 97: 
 98: class PaletteDetectionStrategyTrianglesAndQuads : public PaletteDetectionStrategy {
 99: public:
100: 	PaletteDetectionStrategyTrianglesAndQuads(const Tim *const tim, const std::vector<TimRect> &rectangles);
101: 	virtual uint32_t palOffset(uint16_t imgX, uint16_t imgY) const override;
102: 	virtual uint32_t palIndex() const override;
103: private:
104: 	const std::vector<TimRect> &_rectangles;
105: };
106: 
107: class Tim {
108: 	friend class PaletteDetectionStrategyFixed;
109: 	friend class PaletteDetectionStrategyGrid;
110: 	friend class PaletteDetectionStrategyTrianglesAndQuads;
111: public:
112: 	enum Bpp {
113: 		Bpp4 = 0,
114: 		Bpp8 = 1,
115: 		Bpp16 = 2
116: 	};
117: 
118: 	Tim(Bpp bpp, const ff8_tim &tim, int lineSkip = 0);
119: 	uint16_t colorsPerPal() const;
120: 	inline Bpp bpp() const {
121: 		return _bpp;
122: 	}
123: 	inline uint16_t imageX() const {
124: 		return _tim.img_x;
125: 	}
126: 	inline uint16_t imageY() const {
127: 		return _tim.img_y;
128: 	}
129: 	inline uint16_t imageWidth() const {
130: 		return _tim.img_w / (4 >> int(_bpp));
131: 	}
132: 	inline uint16_t imageHeight() const {
133: 		return _tim.img_h;
134: 	}
135: 	inline uint8_t *imageData() const {
136: 		return _tim.img_data;
137: 	}
138: 	inline uint16_t paletteX() const {
139: 		return _tim.pal_x;
140: 	}
141: 	inline uint16_t paletteY() const {
142: 		return _tim.pal_y;
143: 	}
144: 	inline uint16_t paletteWidth() const {
145: 		return _tim.pal_w;
146: 	}
147: 	inline uint16_t paletteHeight() const {
148: 		return _tim.pal_h;
149: 	}
150: 	inline uint16_t *paletteData() const {
151: 		return _tim.pal_data;
152: 	}
153: 	bool save(const char *fileName, bool withAlpha = false) const;
154: 	bool save(const char *fileName, uint8_t paletteId, bool withAlpha = false) const;
155: 	bool save(const char *fileName, uint8_t palX, uint8_t palY, bool withAlpha = false) const;
156: 	bool saveMultiPaletteGrid(
157: 		const char *fileName, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal = 0, uint8_t palColsPerRow = 1,
158: 		bool withAlpha = false
159: 	) const;
160: 	bool saveMultiPaletteTrianglesAndQuads(
161: 		const char *fileName, const std::vector<TimRect> &rectangles,
162: 		bool withAlpha = false
163: 	) const;
164: 	bool toRGBA32(uint32_t *target, uint8_t palX = 0, uint8_t palY = 0, bool withAlpha = false) const;
165: 	bool toRGBA32MultiPaletteGrid(
166: 		uint32_t *target, uint8_t cellCols, uint8_t cellRows, uint8_t colorsPerPal = 0, uint8_t palColsPerRow = 1,
167: 		bool withAlpha = false
168: 	) const;
169: 	bool toRGBA32MultiPaletteTrianglesAndQuads(
170: 		uint32_t *target, const std::vector<TimRect> &rectangles,
171: 		bool withAlpha = false
172: 	) const;
173: 	Tim chunk(int x, int y, int w, int h);
174: 	static Tim fromLzsData(const uint8_t *uncompressed_data);
175: 	static Tim fromTimData(const uint8_t *data);
176: private:
177: 	bool save(const char *fileName, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha, int forcePaletteId = -1) const;
178: 	bool toRGBA32(uint32_t *target, PaletteDetectionStrategy *paletteDetectionStrategy, bool withAlpha) const;
179: 	ff8_tim _tim;
180: 	Bpp _bpp;
181: 	int _lineSkip;
182: };
</file>

<file path="src/imgui_club/imgui_memory_editor.h">
  1: // Mini memory editor for Dear ImGui (to embed in your game/tools)
  2: // Get latest version at http://www.github.com/ocornut/imgui_club
  3: // Licensed under The MIT License (MIT)
  4: 
  5: // Right-click anywhere to access the Options menu!
  6: // You can adjust the keyboard repeat delay/rate in ImGuiIO.
  7: // The code assume a mono-space font for simplicity!
  8: // If you don't use the default font, use ImGui::PushFont()/PopFont() to switch to a mono-space font before calling this.
  9: //
 10: // Usage:
 11: //   // Create a window and draw memory editor inside it:
 12: //   static MemoryEditor mem_edit_1;
 13: //   static char data[0x10000];
 14: //   size_t data_size = 0x10000;
 15: //   mem_edit_1.DrawWindow("Memory Editor", data, data_size);
 16: //
 17: // Usage:
 18: //   // If you already have a window, use DrawContents() instead:
 19: //   static MemoryEditor mem_edit_2;
 20: //   ImGui::Begin("MyWindow")
 21: //   mem_edit_2.DrawContents(this, sizeof(*this), (size_t)this);
 22: //   ImGui::End();
 23: //
 24: // Changelog:
 25: // - v0.10: initial version
 26: // - v0.23 (2017/08/17): added to github. fixed right-arrow triggering a byte write.
 27: // - v0.24 (2018/06/02): changed DragInt("Rows" to use a %d data format (which is desirable since imgui 1.61).
 28: // - v0.25 (2018/07/11): fixed wording: all occurrences of "Rows" renamed to "Columns".
 29: // - v0.26 (2018/08/02): fixed clicking on hex region
 30: // - v0.30 (2018/08/02): added data preview for common data types
 31: // - v0.31 (2018/10/10): added OptUpperCaseHex option to select lower/upper casing display [@samhocevar]
 32: // - v0.32 (2018/10/10): changed signatures to use void* instead of unsigned char*
 33: // - v0.33 (2018/10/10): added OptShowOptions option to hide all the interactive option setting.
 34: // - v0.34 (2019/05/07): binary preview now applies endianness setting [@nicolasnoble]
 35: // - v0.35 (2020/01/29): using ImGuiDataType available since Dear ImGui 1.69.
 36: // - v0.36 (2020/05/05): minor tweaks, minor refactor.
 37: // - v0.40 (2020/10/04): fix misuse of ImGuiListClipper API, broke with Dear ImGui 1.79. made cursor position appears on left-side of edit box. option popup appears on mouse release. fix MSVC warnings where _CRT_SECURE_NO_WARNINGS wasn't working in recent versions.
 38: // - v0.41 (2020/10/05): fix when using with keyboard/gamepad navigation enabled.
 39: // - v0.42 (2020/10/14): fix for . character in ASCII view always being greyed out.
 40: // - v0.43 (2021/03/12): added OptFooterExtraHeight to allow for custom drawing at the bottom of the editor [@leiradel]
 41: // - v0.44 (2021/03/12): use ImGuiInputTextFlags_AlwaysOverwrite in 1.82 + fix hardcoded width.
 42: // - v0.50 (2021/11/12): various fixes for recent dear imgui versions (fixed misuse of clipper, relying on SetKeyboardFocusHere() handling scrolling from 1.85). added default size.
 43: // - v0.51 (2024/02/22): fix for layout change in 1.89 when using IMGUI_DISABLE_OBSOLETE_FUNCTIONS. (#34)
 44: // - v0.52 (2024/03/08): removed unnecessary GetKeyIndex() calls, they are a no-op since 1.87.
 45: // - v0.53 (2024/05/27): fixed right-click popup from not appearing when using DrawContents(). warning fixes. (#35)
 46: // - v0.54 (2024/07/29): allow ReadOnly mode to still select and preview data. (#46) [@DeltaGW2])
 47: // - v0.55 (2024/08/19): added BgColorFn to allow setting background colors independently from highlighted selection. (#27) [@StrikerX3]
 48: //                       added MouseHoveredAddr public readable field. (#47, #27) [@StrikerX3]
 49: //                       fixed a data preview crash with 1.91.0 WIP. fixed contiguous highlight color when using data preview.
 50: //                       *BREAKING* added UserData field passed to all optional function handlers: ReadFn, WriteFn, HighlightFn, BgColorFn. (#50) [@silverweed]
 51: // - v0.56 (2024/11/04): fixed MouseHovered, MouseHoveredAddr not being set when hovering a byte being edited. (#54)
 52: //
 53: // TODO:
 54: // - This is generally old/crappy code, it should work but isn't very good.. to be rewritten some day.
 55: // - PageUp/PageDown are not supported because we use _NoNav. This is a good test scenario for working out idioms of how to mix natural nav and our own...
 56: // - Arrows are being sent to the InputText() about to disappear which for LeftArrow makes the text cursor appear at position 1 for one frame.
 57: // - Using InputText() is awkward and maybe overkill here, consider implementing something custom.
 58: 
 59: #pragma once
 60: 
 61: #include <stdio.h>      // sprintf, scanf
 62: #include <stdint.h>     // uint8_t, etc.
 63: 
 64: #if defined(_MSC_VER) || defined(_UCRT)
 65: #define _PRISizeT   "I"
 66: #define ImSnprintf  _snprintf
 67: #else
 68: #define _PRISizeT   "z"
 69: #define ImSnprintf  snprintf
 70: #endif
 71: 
 72: #if defined(_MSC_VER) || defined(_UCRT)
 73: #pragma warning (push)
 74: #pragma warning (disable: 4996) // warning C4996: 'sprintf': This function or variable may be unsafe.
 75: #endif
 76: 
 77: struct MemoryEditor
 78: {
 79:     enum DataFormat
 80:     {
 81:         DataFormat_Bin = 0,
 82:         DataFormat_Dec = 1,
 83:         DataFormat_Hex = 2,
 84:         DataFormat_COUNT
 85:     };
 86: 
 87:     // Settings
 88:     bool            Open;                                       // = true   // set to false when DrawWindow() was closed. ignore if not using DrawWindow().
 89:     bool            ReadOnly;                                   // = false  // disable any editing.
 90:     int             Cols;                                       // = 16     // number of columns to display.
 91:     bool            OptShowOptions;                             // = true   // display options button/context menu. when disabled, options will be locked unless you provide your own UI for them.
 92:     bool            OptShowDataPreview;                         // = false  // display a footer previewing the decimal/binary/hex/float representation of the currently selected bytes.
 93:     bool            OptShowHexII;                               // = false  // display values in HexII representation instead of regular hexadecimal: hide null/zero bytes, ascii values as ".X".
 94:     bool            OptShowAscii;                               // = true   // display ASCII representation on the right side.
 95:     bool            OptGreyOutZeroes;                           // = true   // display null/zero bytes using the TextDisabled color.
 96:     bool            OptUpperCaseHex;                            // = true   // display hexadecimal values as "FF" instead of "ff".
 97:     int             OptMidColsCount;                            // = 8      // set to 0 to disable extra spacing between every mid-cols.
 98:     int             OptAddrDigitsCount;                         // = 0      // number of addr digits to display (default calculated based on maximum displayed addr).
 99:     float           OptFooterExtraHeight;                       // = 0      // space to reserve at the bottom of the widget to add custom widgets
100:     ImU32           HighlightColor;                             //          // background color of highlighted bytes.
101: 
102:     // Function handlers
103:     ImU8            (*ReadFn)(const ImU8* mem, size_t off, void* user_data);      // = 0      // optional handler to read bytes.
104:     void            (*WriteFn)(ImU8* mem, size_t off, ImU8 d, void* user_data);   // = 0      // optional handler to write bytes.
105:     bool            (*HighlightFn)(const ImU8* mem, size_t off, void* user_data); // = 0      // optional handler to return Highlight property (to support non-contiguous highlighting).
106:     ImU32           (*BgColorFn)(const ImU8* mem, size_t off, void* user_data);   // = 0      // optional handler to return custom background color of individual bytes.
107:     void*           UserData;                                                     // = NULL   // user data forwarded to the function handlers
108: 
109:     // Public read-only data
110:     bool            MouseHovered;                               // set when mouse is hovering a value.
111:     size_t          MouseHoveredAddr;                           // the address currently being hovered if MouseHovered is set.
112: 
113:     // [Internal State]
114:     bool            ContentsWidthChanged;
115:     size_t          DataPreviewAddr;
116:     size_t          DataEditingAddr;
117:     bool            DataEditingTakeFocus;
118:     char            DataInputBuf[32];
119:     char            AddrInputBuf[32];
120:     size_t          GotoAddr;
121:     size_t          HighlightMin, HighlightMax;
122:     int             PreviewEndianness;
123:     ImGuiDataType   PreviewDataType;
124: 
125:     MemoryEditor()
126:     {
127:         // Settings
128:         Open = true;
129:         ReadOnly = false;
130:         Cols = 16;
131:         OptShowOptions = true;
132:         OptShowDataPreview = false;
133:         OptShowHexII = false;
134:         OptShowAscii = true;
135:         OptGreyOutZeroes = true;
136:         OptUpperCaseHex = true;
137:         OptMidColsCount = 8;
138:         OptAddrDigitsCount = 0;
139:         OptFooterExtraHeight = 0.0f;
140:         HighlightColor = IM_COL32(255, 255, 255, 50);
141:         ReadFn = nullptr;
142:         WriteFn = nullptr;
143:         HighlightFn = nullptr;
144:         BgColorFn = nullptr;
145:         UserData = nullptr;
146: 
147:         // State/Internals
148:         ContentsWidthChanged = false;
149:         DataPreviewAddr = DataEditingAddr = (size_t)-1;
150:         DataEditingTakeFocus = false;
151:         memset(DataInputBuf, 0, sizeof(DataInputBuf));
152:         memset(AddrInputBuf, 0, sizeof(AddrInputBuf));
153:         GotoAddr = (size_t)-1;
154:         MouseHovered = false;
155:         MouseHoveredAddr = 0;
156:         HighlightMin = HighlightMax = (size_t)-1;
157:         PreviewEndianness = 0;
158:         PreviewDataType = ImGuiDataType_S32;
159:     }
160: 
161:     void GotoAddrAndHighlight(size_t addr_min, size_t addr_max)
162:     {
163:         GotoAddr = addr_min;
164:         HighlightMin = addr_min;
165:         HighlightMax = addr_max;
166:     }
167: 
168:     struct Sizes
169:     {
170:         int     AddrDigitsCount;
171:         float   LineHeight;
172:         float   GlyphWidth;
173:         float   HexCellWidth;
174:         float   SpacingBetweenMidCols;
175:         float   PosHexStart;
176:         float   PosHexEnd;
177:         float   PosAsciiStart;
178:         float   PosAsciiEnd;
179:         float   WindowWidth;
180: 
181:         Sizes() { memset(this, 0, sizeof(*this)); }
182:     };
183: 
184:     void CalcSizes(Sizes& s, size_t mem_size, size_t base_display_addr)
185:     {
186:         ImGuiStyle& style = ImGui::GetStyle();
187:         s.AddrDigitsCount = OptAddrDigitsCount;
188:         if (s.AddrDigitsCount == 0)
189:             for (size_t n = base_display_addr + mem_size - 1; n > 0; n >>= 4)
190:                 s.AddrDigitsCount++;
191:         s.LineHeight = ImGui::GetTextLineHeight();
192:         s.GlyphWidth = ImGui::CalcTextSize("F").x + 1;                  // We assume the font is mono-space
193:         s.HexCellWidth = (float)(int)(s.GlyphWidth * 2.5f);             // "FF " we include trailing space in the width to easily catch clicks everywhere
194:         s.SpacingBetweenMidCols = (float)(int)(s.HexCellWidth * 0.25f); // Every OptMidColsCount columns we add a bit of extra spacing
195:         s.PosHexStart = (s.AddrDigitsCount + 2) * s.GlyphWidth;
196:         s.PosHexEnd = s.PosHexStart + (s.HexCellWidth * Cols);
197:         s.PosAsciiStart = s.PosAsciiEnd = s.PosHexEnd;
198:         if (OptShowAscii)
199:         {
200:             s.PosAsciiStart = s.PosHexEnd + s.GlyphWidth * 1;
201:             if (OptMidColsCount > 0)
202:                 s.PosAsciiStart += (float)((Cols + OptMidColsCount - 1) / OptMidColsCount) * s.SpacingBetweenMidCols;
203:             s.PosAsciiEnd = s.PosAsciiStart + Cols * s.GlyphWidth;
204:         }
205:         s.WindowWidth = s.PosAsciiEnd + style.ScrollbarSize + style.WindowPadding.x * 2 + s.GlyphWidth;
206:     }
207: 
208:     // Standalone Memory Editor window
209:     void DrawWindow(const char* title, void* mem_data, size_t mem_size, size_t base_display_addr = 0x0000)
210:     {
211:         Sizes s;
212:         CalcSizes(s, mem_size, base_display_addr);
213:         ImGui::SetNextWindowSize(ImVec2(s.WindowWidth, s.WindowWidth * 0.60f), ImGuiCond_FirstUseEver);
214:         ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, 0.0f), ImVec2(s.WindowWidth, FLT_MAX));
215: 
216:         Open = true;
217:         if (ImGui::Begin(title, &Open, ImGuiWindowFlags_NoScrollbar))
218:         {
219:             DrawContents(mem_data, mem_size, base_display_addr);
220:             if (ContentsWidthChanged)
221:             {
222:                 CalcSizes(s, mem_size, base_display_addr);
223:                 ImGui::SetWindowSize(ImVec2(s.WindowWidth, ImGui::GetWindowSize().y));
224:             }
225:         }
226:         ImGui::End();
227:     }
228: 
229:     // Memory Editor contents only
230:     void DrawContents(void* mem_data_void, size_t mem_size, size_t base_display_addr = 0x0000)
231:     {
232:         if (Cols < 1)
233:             Cols = 1;
234: 
235:         ImU8* mem_data = (ImU8*)mem_data_void;
236:         Sizes s;
237:         CalcSizes(s, mem_size, base_display_addr);
238:         ImGuiStyle& style = ImGui::GetStyle();
239: 
240:         const ImVec2 contents_pos_start = ImGui::GetCursorScreenPos();
241: 
242:         // We begin into our scrolling region with the 'ImGuiWindowFlags_NoMove' in order to prevent click from moving the window.
243:         // This is used as a facility since our main click detection code doesn't assign an ActiveId so the click would normally be caught as a window-move.
244:         const float height_separator = style.ItemSpacing.y;
245:         float footer_height = OptFooterExtraHeight;
246:         if (OptShowOptions)
247:             footer_height += height_separator + ImGui::GetFrameHeightWithSpacing() * 1;
248:         if (OptShowDataPreview)
249:             footer_height += height_separator + ImGui::GetFrameHeightWithSpacing() * 1 + ImGui::GetTextLineHeightWithSpacing() * 3;
250:         ImGui::BeginChild("##scrolling", ImVec2(-FLT_MIN, -footer_height), ImGuiChildFlags_None, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNav);
251:         ImDrawList* draw_list = ImGui::GetWindowDrawList();
252: 
253:         ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
254:         ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
255: 
256:         // We are not really using the clipper API correctly here, because we rely on visible_start_addr/visible_end_addr for our scrolling function.
257:         const int line_total_count = (int)((mem_size + Cols - 1) / Cols);
258:         ImGuiListClipper clipper;
259:         clipper.Begin(line_total_count, s.LineHeight);
260: 
261:         bool data_next = false;
262: 
263:         if (DataEditingAddr >= mem_size)
264:             DataEditingAddr = (size_t)-1;
265:         if (DataPreviewAddr >= mem_size)
266:             DataPreviewAddr = (size_t)-1;
267: 
268:         size_t preview_data_type_size = OptShowDataPreview ? DataTypeGetSize(PreviewDataType) : 0;
269: 
270:         size_t data_editing_addr_next = (size_t)-1;
271:         if (DataEditingAddr != (size_t)-1)
272:         {
273:             // Move cursor but only apply on next frame so scrolling with be synchronized (because currently we can't change the scrolling while the window is being rendered)
274:             if (ImGui::IsKeyPressed(ImGuiKey_UpArrow) && (ptrdiff_t)DataEditingAddr >= (ptrdiff_t)Cols)                 { data_editing_addr_next = DataEditingAddr - Cols; }
275:             else if (ImGui::IsKeyPressed(ImGuiKey_DownArrow) && (ptrdiff_t)DataEditingAddr < (ptrdiff_t)mem_size - Cols){ data_editing_addr_next = DataEditingAddr + Cols; }
276:             else if (ImGui::IsKeyPressed(ImGuiKey_LeftArrow) && (ptrdiff_t)DataEditingAddr > (ptrdiff_t)0)              { data_editing_addr_next = DataEditingAddr - 1; }
277:             else if (ImGui::IsKeyPressed(ImGuiKey_RightArrow) && (ptrdiff_t)DataEditingAddr < (ptrdiff_t)mem_size - 1)  { data_editing_addr_next = DataEditingAddr + 1; }
278:         }
279: 
280:         // Draw vertical separator
281:         ImVec2 window_pos = ImGui::GetWindowPos();
282:         if (OptShowAscii)
283:             draw_list->AddLine(ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y), ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y + 9999), ImGui::GetColorU32(ImGuiCol_Border));
284: 
285:         const ImU32 color_text = ImGui::GetColorU32(ImGuiCol_Text);
286:         const ImU32 color_disabled = OptGreyOutZeroes ? ImGui::GetColorU32(ImGuiCol_TextDisabled) : color_text;
287: 
288:         const char* format_address = OptUpperCaseHex ? "%0*" _PRISizeT "X: " : "%0*" _PRISizeT "x: ";
289:         const char* format_data = OptUpperCaseHex ? "%0*" _PRISizeT "X" : "%0*" _PRISizeT "x";
290:         const char* format_byte = OptUpperCaseHex ? "%02X" : "%02x";
291:         const char* format_byte_space = OptUpperCaseHex ? "%02X " : "%02x ";
292: 
293:         MouseHovered = false;
294:         MouseHoveredAddr = 0;
295: 
296:         while (clipper.Step())
297:             for (int line_i = clipper.DisplayStart; line_i < clipper.DisplayEnd; line_i++) // display only visible lines
298:             {
299:                 size_t addr = (size_t)line_i * Cols;
300:                 ImGui::Text(format_address, s.AddrDigitsCount, base_display_addr + addr);
301: 
302:                 // Draw Hexadecimal
303:                 for (int n = 0; n < Cols && addr < mem_size; n++, addr++)
304:                 {
305:                     float byte_pos_x = s.PosHexStart + s.HexCellWidth * n;
306:                     if (OptMidColsCount > 0)
307:                         byte_pos_x += (float)(n / OptMidColsCount) * s.SpacingBetweenMidCols;
308:                     ImGui::SameLine(byte_pos_x);
309: 
310:                     // Draw highlight or custom background color
311:                     const bool is_highlight_from_user_range = (addr >= HighlightMin && addr < HighlightMax);
312:                     const bool is_highlight_from_user_func = (HighlightFn && HighlightFn(mem_data, addr, UserData));
313:                     const bool is_highlight_from_preview = (addr >= DataPreviewAddr && addr < DataPreviewAddr + preview_data_type_size);
314: 
315:                     ImU32 bg_color = 0;
316:                     bool is_next_byte_highlighted = false;
317:                     if (is_highlight_from_user_range || is_highlight_from_user_func || is_highlight_from_preview)
318:                     {
319:                         is_next_byte_highlighted = (addr + 1 < mem_size) && ((HighlightMax != (size_t)-1 && addr + 1 < HighlightMax) || (HighlightFn && HighlightFn(mem_data, addr + 1, UserData)) || (addr + 1 < DataPreviewAddr + preview_data_type_size));
320:                         bg_color = HighlightColor;
321:                     }
322:                     else if (BgColorFn != nullptr)
323:                     {
324:                         is_next_byte_highlighted = (addr + 1 < mem_size) && ((BgColorFn(mem_data, addr + 1, UserData) & IM_COL32_A_MASK) != 0);
325:                         bg_color = BgColorFn(mem_data, addr, UserData);
326:                     }
327:                     if (bg_color != 0)
328:                     {
329:                         float bg_width = s.GlyphWidth * 2;
330:                         if (is_next_byte_highlighted || (n + 1 == Cols))
331:                         {
332:                             bg_width = s.HexCellWidth;
333:                             if (OptMidColsCount > 0 && n > 0 && (n + 1) < Cols && ((n + 1) % OptMidColsCount) == 0)
334:                                 bg_width += s.SpacingBetweenMidCols;
335:                         }
336:                         ImVec2 pos = ImGui::GetCursorScreenPos();
337:                         draw_list->AddRectFilled(pos, ImVec2(pos.x + bg_width, pos.y + s.LineHeight), bg_color);
338:                     }
339: 
340:                     if (DataEditingAddr == addr)
341:                     {
342:                         // Display text input on current byte
343:                         bool data_write = false;
344:                         ImGui::PushID((void*)addr);
345:                         if (DataEditingTakeFocus)
346:                         {
347:                             ImGui::SetKeyboardFocusHere(0);
348:                             ImSnprintf(AddrInputBuf, 32, format_data, s.AddrDigitsCount, base_display_addr + addr);
349:                             ImSnprintf(DataInputBuf, 32, format_byte, ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr]);
350:                         }
351:                         struct InputTextUserData
352:                         {
353:                             // FIXME: We should have a way to retrieve the text edit cursor position more easily in the API, this is rather tedious. This is such a ugly mess we may be better off not using InputText() at all here.
354:                             static int Callback(ImGuiInputTextCallbackData* data)
355:                             {
356:                                 InputTextUserData* user_data = (InputTextUserData*)data->UserData;
357:                                 if (!data->HasSelection())
358:                                     user_data->CursorPos = data->CursorPos;
359: #if IMGUI_VERSION_NUM < 19102
360:                                 if (data->Flags & ImGuiInputTextFlags_ReadOnly)
361:                                     return 0;
362: #endif
363:                                 if (data->SelectionStart == 0 && data->SelectionEnd == data->BufTextLen)
364:                                 {
365:                                     // When not editing a byte, always refresh its InputText content pulled from underlying memory data
366:                                     // (this is a bit tricky, since InputText technically "owns" the master copy of the buffer we edit it in there)
367:                                     data->DeleteChars(0, data->BufTextLen);
368:                                     data->InsertChars(0, user_data->CurrentBufOverwrite);
369:                                     data->SelectionStart = 0;
370:                                     data->SelectionEnd = 2;
371:                                     data->CursorPos = 0;
372:                                 }
373:                                 return 0;
374:                             }
375:                             char   CurrentBufOverwrite[3];  // Input
376:                             int    CursorPos;               // Output
377:                         };
378:                         InputTextUserData input_text_user_data;
379:                         input_text_user_data.CursorPos = -1;
380:                         ImSnprintf(input_text_user_data.CurrentBufOverwrite, 3, format_byte, ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr]);
381:                         ImGuiInputTextFlags flags = ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoHorizontalScroll | ImGuiInputTextFlags_CallbackAlways;
382:                         if (ReadOnly)
383:                             flags |= ImGuiInputTextFlags_ReadOnly;
384:                         flags |= ImGuiInputTextFlags_AlwaysOverwrite; // was ImGuiInputTextFlags_AlwaysInsertMode
385:                         ImGui::SetNextItemWidth(s.GlyphWidth * 2);
386:                         if (ImGui::InputText("##data", DataInputBuf, IM_ARRAYSIZE(DataInputBuf), flags, InputTextUserData::Callback, &input_text_user_data))
387:                             data_write = data_next = true;
388:                         else if (!DataEditingTakeFocus && !ImGui::IsItemActive())
389:                             DataEditingAddr = data_editing_addr_next = (size_t)-1;
390:                         DataEditingTakeFocus = false;
391:                         if (input_text_user_data.CursorPos >= 2)
392:                             data_write = data_next = true;
393:                         if (data_editing_addr_next != (size_t)-1)
394:                             data_write = data_next = false;
395:                         unsigned int data_input_value = 0;
396:                         if (!ReadOnly && data_write && sscanf(DataInputBuf, "%X", &data_input_value) == 1)
397:                         {
398:                             if (WriteFn)
399:                                 WriteFn(mem_data, addr, (ImU8)data_input_value, UserData);
400:                             else
401:                                 mem_data[addr] = (ImU8)data_input_value;
402:                         }
403:                         if (ImGui::IsItemHovered())
404:                         {
405:                             MouseHovered = true;
406:                             MouseHoveredAddr = addr;
407:                         }
408:                         ImGui::PopID();
409:                     }
410:                     else
411:                     {
412:                         // NB: The trailing space is not visible but ensure there's no gap that the mouse cannot click on.
413:                         ImU8 b = ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr];
414: 
415:                         if (OptShowHexII)
416:                         {
417:                             if ((b >= 32 && b < 128))
418:                                 ImGui::Text(".%c ", b);
419:                             else if (b == 0xFF && OptGreyOutZeroes)
420:                                 ImGui::TextDisabled("## ");
421:                             else if (b == 0x00)
422:                                 ImGui::Text("   ");
423:                             else
424:                                 ImGui::Text(format_byte_space, b);
425:                         }
426:                         else
427:                         {
428:                             if (b == 0 && OptGreyOutZeroes)
429:                                 ImGui::TextDisabled("00 ");
430:                             else
431:                                 ImGui::Text(format_byte_space, b);
432:                         }
433:                         if (ImGui::IsItemHovered())
434:                         {
435:                             MouseHovered = true;
436:                             MouseHoveredAddr = addr;
437:                             if (ImGui::IsMouseClicked(0))
438:                             {
439:                                 DataEditingTakeFocus = true;
440:                                 data_editing_addr_next = addr;
441:                             }
442:                         }
443:                     }
444:                 }
445: 
446:                 if (OptShowAscii)
447:                 {
448:                     // Draw ASCII values
449:                     ImGui::SameLine(s.PosAsciiStart);
450:                     ImVec2 pos = ImGui::GetCursorScreenPos();
451:                     addr = (size_t)line_i * Cols;
452: 
453:                     const float mouse_off_x = ImGui::GetIO().MousePos.x - pos.x;
454:                     const size_t mouse_addr = (mouse_off_x >= 0.0f && mouse_off_x < s.PosAsciiEnd - s.PosAsciiStart) ? addr + (size_t)(mouse_off_x / s.GlyphWidth) : (size_t)-1;
455: 
456:                     ImGui::PushID(line_i);
457:                     if (ImGui::InvisibleButton("ascii", ImVec2(s.PosAsciiEnd - s.PosAsciiStart, s.LineHeight)))
458:                     {
459:                         DataEditingAddr = DataPreviewAddr = mouse_addr;
460:                         DataEditingTakeFocus = true;
461:                     }
462:                     if (ImGui::IsItemHovered())
463:                     {
464:                         MouseHovered = true;
465:                         MouseHoveredAddr = mouse_addr;
466:                     }
467:                     ImGui::PopID();
468:                     for (int n = 0; n < Cols && addr < mem_size; n++, addr++)
469:                     {
470:                         if (addr == DataEditingAddr)
471:                         {
472:                             draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), ImGui::GetColorU32(ImGuiCol_FrameBg));
473:                             draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), ImGui::GetColorU32(ImGuiCol_TextSelectedBg));
474:                         }
475:                         else if (BgColorFn)
476:                         {
477:                             draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), BgColorFn(mem_data, addr, UserData));
478:                         }
479:                         unsigned char c = ReadFn ? ReadFn(mem_data, addr, UserData) : mem_data[addr];
480:                         char display_c = (c < 32 || c >= 128) ? '.' : c;
481:                         draw_list->AddText(pos, (display_c == c) ? color_text : color_disabled, &display_c, &display_c + 1);
482:                         pos.x += s.GlyphWidth;
483:                     }
484:                 }
485:             }
486:         ImGui::PopStyleVar(2);
487:         const float child_width = ImGui::GetWindowSize().x;
488:         ImGui::EndChild();
489: 
490:         // Notify the main window of our ideal child content size (FIXME: we are missing an API to get the contents size from the child)
491:         ImGui::SetCursorPosX(s.WindowWidth);
492:         ImGui::Dummy(ImVec2(0.0f, 0.0f));
493: 
494:         if (data_next && DataEditingAddr + 1 < mem_size)
495:         {
496:             DataEditingAddr = DataPreviewAddr = DataEditingAddr + 1;
497:             DataEditingTakeFocus = true;
498:         }
499:         else if (data_editing_addr_next != (size_t)-1)
500:         {
501:             DataEditingAddr = DataPreviewAddr = data_editing_addr_next;
502:             DataEditingTakeFocus = true;
503:         }
504: 
505:         const bool lock_show_data_preview = OptShowDataPreview;
506:         if (OptShowOptions)
507:         {
508:             ImGui::Separator();
509:             DrawOptionsLine(s, mem_data, mem_size, base_display_addr);
510:         }
511: 
512:         if (lock_show_data_preview)
513:         {
514:             ImGui::Separator();
515:             DrawPreviewLine(s, mem_data, mem_size, base_display_addr);
516:         }
517: 
518:         const ImVec2 contents_pos_end(contents_pos_start.x + child_width, ImGui::GetCursorScreenPos().y);
519:         //ImGui::GetForegroundDrawList()->AddRect(contents_pos_start, contents_pos_end, IM_COL32(255, 0, 0, 255));
520:         if (OptShowOptions)
521:             if (ImGui::IsMouseHoveringRect(contents_pos_start, contents_pos_end))
522:                 if (ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows) && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
523:                     ImGui::OpenPopup("OptionsPopup");
524: 
525:         if (ImGui::BeginPopup("OptionsPopup"))
526:         {
527:             ImGui::SetNextItemWidth(s.GlyphWidth * 7 + style.FramePadding.x * 2.0f);
528:             if (ImGui::DragInt("##cols", &Cols, 0.2f, 4, 32, "%d cols")) { ContentsWidthChanged = true; if (Cols < 1) Cols = 1; }
529:             ImGui::Checkbox("Show Data Preview", &OptShowDataPreview);
530:             ImGui::Checkbox("Show HexII", &OptShowHexII);
531:             if (ImGui::Checkbox("Show Ascii", &OptShowAscii)) { ContentsWidthChanged = true; }
532:             ImGui::Checkbox("Grey out zeroes", &OptGreyOutZeroes);
533:             ImGui::Checkbox("Uppercase Hex", &OptUpperCaseHex);
534: 
535:             ImGui::EndPopup();
536:         }
537:     }
538: 
539:     void DrawOptionsLine(const Sizes& s, void* mem_data, size_t mem_size, size_t base_display_addr)
540:     {
541:         IM_UNUSED(mem_data);
542:         ImGuiStyle& style = ImGui::GetStyle();
543:         const char* format_range = OptUpperCaseHex ? "Range %0*" _PRISizeT "X..%0*" _PRISizeT "X" : "Range %0*" _PRISizeT "x..%0*" _PRISizeT "x";
544: 
545:         // Options menu
546:         if (ImGui::Button("Options"))
547:             ImGui::OpenPopup("OptionsPopup");
548: 
549:         ImGui::SameLine();
550:         ImGui::Text(format_range, s.AddrDigitsCount, base_display_addr, s.AddrDigitsCount, base_display_addr + mem_size - 1);
551:         ImGui::SameLine();
552:         ImGui::SetNextItemWidth((s.AddrDigitsCount + 1) * s.GlyphWidth + style.FramePadding.x * 2.0f);
553:         if (ImGui::InputText("##addr", AddrInputBuf, IM_ARRAYSIZE(AddrInputBuf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue))
554:         {
555:             size_t goto_addr;
556:             if (sscanf(AddrInputBuf, "%" _PRISizeT "X", &goto_addr) == 1)
557:             {
558:                 GotoAddr = goto_addr - base_display_addr;
559:                 HighlightMin = HighlightMax = (size_t)-1;
560:             }
561:         }
562: 
563:         if (GotoAddr != (size_t)-1)
564:         {
565:             if (GotoAddr < mem_size)
566:             {
567:                 ImGui::BeginChild("##scrolling");
568:                 ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + (GotoAddr / Cols) * ImGui::GetTextLineHeight());
569:                 ImGui::EndChild();
570:                 DataEditingAddr = DataPreviewAddr = GotoAddr;
571:                 DataEditingTakeFocus = true;
572:             }
573:             GotoAddr = (size_t)-1;
574:         }
575: 
576:         //if (MouseHovered)
577:         //{
578:         //    ImGui::SameLine();
579:         //    ImGui::Text("Hovered: %p", MouseHoveredAddr);
580:         //}
581:     }
582: 
583:     void DrawPreviewLine(const Sizes& s, void* mem_data_void, size_t mem_size, size_t base_display_addr)
584:     {
585:         IM_UNUSED(base_display_addr);
586:         ImU8* mem_data = (ImU8*)mem_data_void;
587:         ImGuiStyle& style = ImGui::GetStyle();
588:         ImGui::AlignTextToFramePadding();
589:         ImGui::Text("Preview as:");
590:         ImGui::SameLine();
591:         ImGui::SetNextItemWidth((s.GlyphWidth * 10.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);
592: 
593:         static const ImGuiDataType supported_data_types[] = { ImGuiDataType_S8, ImGuiDataType_U8, ImGuiDataType_S16, ImGuiDataType_U16, ImGuiDataType_S32, ImGuiDataType_U32, ImGuiDataType_S64, ImGuiDataType_U64, ImGuiDataType_Float, ImGuiDataType_Double };
594:         if (ImGui::BeginCombo("##combo_type", DataTypeGetDesc(PreviewDataType), ImGuiComboFlags_HeightLargest))
595:         {
596:             for (int n = 0; n < IM_ARRAYSIZE(supported_data_types); n++)
597:             {
598:                 ImGuiDataType data_type = supported_data_types[n];
599:                 if (ImGui::Selectable(DataTypeGetDesc(data_type), PreviewDataType == data_type))
600:                     PreviewDataType = data_type;
601:             }
602:             ImGui::EndCombo();
603:         }
604:         ImGui::SameLine();
605:         ImGui::SetNextItemWidth((s.GlyphWidth * 6.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);
606:         ImGui::Combo("##combo_endianness", &PreviewEndianness, "LE\0BE\0\0");
607: 
608:         char buf[128] = "";
609:         float x = s.GlyphWidth * 6.0f;
610:         bool has_value = DataPreviewAddr != (size_t)-1;
611:         if (has_value)
612:             DrawPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Dec, buf, (size_t)IM_ARRAYSIZE(buf));
613:         ImGui::Text("Dec"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
614:         if (has_value)
615:             DrawPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Hex, buf, (size_t)IM_ARRAYSIZE(buf));
616:         ImGui::Text("Hex"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
617:         if (has_value)
618:             DrawPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Bin, buf, (size_t)IM_ARRAYSIZE(buf));
619:         buf[IM_ARRAYSIZE(buf) - 1] = 0;
620:         ImGui::Text("Bin"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
621:     }
622: 
623:     // Utilities for Data Preview (since we don't access imgui_internal.h)
624:     // FIXME: This technically depends on ImGuiDataType order.
625:     const char* DataTypeGetDesc(ImGuiDataType data_type) const
626:     {
627:         const char* descs[] = { "Int8", "Uint8", "Int16", "Uint16", "Int32", "Uint32", "Int64", "Uint64", "Float", "Double" };
628:         IM_ASSERT(data_type >= 0 && data_type < IM_ARRAYSIZE(descs));
629:         return descs[data_type];
630:     }
631: 
632:     size_t DataTypeGetSize(ImGuiDataType data_type) const
633:     {
634:         const size_t sizes[] = { 1, 1, 2, 2, 4, 4, 8, 8, sizeof(float), sizeof(double) };
635:         IM_ASSERT(data_type >= 0 && data_type < IM_ARRAYSIZE(sizes));
636:         return sizes[data_type];
637:     }
638: 
639:     const char* DataFormatGetDesc(DataFormat data_format) const
640:     {
641:         const char* descs[] = { "Bin", "Dec", "Hex" };
642:         IM_ASSERT(data_format >= 0 && data_format < DataFormat_COUNT);
643:         return descs[data_format];
644:     }
645: 
646:     bool IsBigEndian() const
647:     {
648:         uint16_t x = 1;
649:         char c[2];
650:         memcpy(c, &x, 2);
651:         return c[0] != 0;
652:     }
653: 
654:     static void* EndiannessCopyBigEndian(void* _dst, void* _src, size_t s, int is_little_endian)
655:     {
656:         if (is_little_endian)
657:         {
658:             uint8_t* dst = (uint8_t*)_dst;
659:             uint8_t* src = (uint8_t*)_src + s - 1;
660:             for (int i = 0, n = (int)s; i < n; ++i)
661:                 memcpy(dst++, src--, 1);
662:             return _dst;
663:         }
664:         else
665:         {
666:             return memcpy(_dst, _src, s);
667:         }
668:     }
669: 
670:     static void* EndiannessCopyLittleEndian(void* _dst, void* _src, size_t s, int is_little_endian)
671:     {
672:         if (is_little_endian)
673:         {
674:             return memcpy(_dst, _src, s);
675:         }
676:         else
677:         {
678:             uint8_t* dst = (uint8_t*)_dst;
679:             uint8_t* src = (uint8_t*)_src + s - 1;
680:             for (int i = 0, n = (int)s; i < n; ++i)
681:                 memcpy(dst++, src--, 1);
682:             return _dst;
683:         }
684:     }
685: 
686:     void* EndiannessCopy(void* dst, void* src, size_t size) const
687:     {
688:         static void* (*fp)(void*, void*, size_t, int) = nullptr;
689:         if (fp == nullptr)
690:             fp = IsBigEndian() ? EndiannessCopyBigEndian : EndiannessCopyLittleEndian;
691:         return fp(dst, src, size, PreviewEndianness);
692:     }
693: 
694:     const char* FormatBinary(const uint8_t* buf, int width) const
695:     {
696:         IM_ASSERT(width <= 64);
697:         size_t out_n = 0;
698:         static char out_buf[64 + 8 + 1];
699:         int n = width / 8;
700:         for (int j = n - 1; j >= 0; --j)
701:         {
702:             for (int i = 0; i < 8; ++i)
703:                 out_buf[out_n++] = (buf[j] & (1 << (7 - i))) ? '1' : '0';
704:             out_buf[out_n++] = ' ';
705:         }
706:         IM_ASSERT(out_n < IM_ARRAYSIZE(out_buf));
707:         out_buf[out_n] = 0;
708:         return out_buf;
709:     }
710: 
711:     // [Internal]
712:     void DrawPreviewData(size_t addr, const ImU8* mem_data, size_t mem_size, ImGuiDataType data_type, DataFormat data_format, char* out_buf, size_t out_buf_size) const
713:     {
714:         uint8_t buf[8];
715:         size_t elem_size = DataTypeGetSize(data_type);
716:         size_t size = addr + elem_size > mem_size ? mem_size - addr : elem_size;
717:         if (ReadFn)
718:             for (int i = 0, n = (int)size; i < n; ++i)
719:                 buf[i] = ReadFn(mem_data, addr + i, UserData);
720:         else
721:             memcpy(buf, mem_data + addr, size);
722: 
723:         if (data_format == DataFormat_Bin)
724:         {
725:             uint8_t binbuf[8];
726:             EndiannessCopy(binbuf, buf, size);
727:             ImSnprintf(out_buf, out_buf_size, "%s", FormatBinary(binbuf, (int)size * 8));
728:             return;
729:         }
730: 
731:         out_buf[0] = 0;
732:         switch (data_type)
733:         {
734:         case ImGuiDataType_S8:
735:         {
736:             int8_t data = 0;
737:             EndiannessCopy(&data, buf, size);
738:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hhd", data); return; }
739:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%02x", data & 0xFF); return; }
740:             break;
741:         }
742:         case ImGuiDataType_U8:
743:         {
744:             uint8_t data = 0;
745:             EndiannessCopy(&data, buf, size);
746:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hhu", data); return; }
747:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%02x", data & 0XFF); return; }
748:             break;
749:         }
750:         case ImGuiDataType_S16:
751:         {
752:             int16_t data = 0;
753:             EndiannessCopy(&data, buf, size);
754:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hd", data); return; }
755:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%04x", data & 0xFFFF); return; }
756:             break;
757:         }
758:         case ImGuiDataType_U16:
759:         {
760:             uint16_t data = 0;
761:             EndiannessCopy(&data, buf, size);
762:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hu", data); return; }
763:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%04x", data & 0xFFFF); return; }
764:             break;
765:         }
766:         case ImGuiDataType_S32:
767:         {
768:             int32_t data = 0;
769:             EndiannessCopy(&data, buf, size);
770:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%d", data); return; }
771:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%08x", data); return; }
772:             break;
773:         }
774:         case ImGuiDataType_U32:
775:         {
776:             uint32_t data = 0;
777:             EndiannessCopy(&data, buf, size);
778:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%u", data); return; }
779:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%08x", data); return; }
780:             break;
781:         }
782:         case ImGuiDataType_S64:
783:         {
784:             int64_t data = 0;
785:             EndiannessCopy(&data, buf, size);
786:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%lld", (long long)data); return; }
787:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%016llx", (long long)data); return; }
788:             break;
789:         }
790:         case ImGuiDataType_U64:
791:         {
792:             uint64_t data = 0;
793:             EndiannessCopy(&data, buf, size);
794:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%llu", (long long)data); return; }
795:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "0x%016llx", (long long)data); return; }
796:             break;
797:         }
798:         case ImGuiDataType_Float:
799:         {
800:             float data = 0.0f;
801:             EndiannessCopy(&data, buf, size);
802:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%f", data); return; }
803:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%a", data); return; }
804:             break;
805:         }
806:         case ImGuiDataType_Double:
807:         {
808:             double data = 0.0;
809:             EndiannessCopy(&data, buf, size);
810:             if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%f", data); return; }
811:             if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%a", data); return; }
812:             break;
813:         }
814:         default:
815:         case ImGuiDataType_COUNT:
816:             break;
817:         } // Switch
818:         IM_ASSERT(0); // Shouldn't reach
819:     }
820: };
821: 
822: #undef _PRISizeT
823: #undef ImSnprintf
824: 
825: #ifdef _MSC_VER
826: #pragma warning (pop)
827: #endif
</file>

<file path="src/video/movies.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "../audio.h"
 23: #include "../renderer.h"
 24: #include "../gl.h"
 25: 
 26: #include "movies.h"
 27: 
 28: #include <cctype>
 29: 
 30: // 10 frames
 31: #define VIDEO_BUFFER_SIZE 10
 32: 
 33: #define LAG (((now - start_time) - (timer_freq / movie_fps) * movie_frame_counter) / (timer_freq / 1000))
 34: 
 35: uint32_t audio_must_be_converted = false;
 36: 
 37: AVFormatContext *format_ctx = 0;
 38: AVCodecContext *codec_ctx = 0;
 39: const AVCodec *codec = 0;
 40: AVCodecContext *acodec_ctx = 0;
 41: const AVCodec *acodec = 0;
 42: AVFrame *movie_frame = 0;
 43: struct SwsContext *sws_ctx = 0;
 44: SwrContext* swr_ctx = NULL;
 45: 
 46: int videostream;
 47: int audiostream;
 48: 
 49: struct video_frame
 50: {
 51: 	uint32_t yuv_textures[3] = { 0 };
 52: };
 53: 
 54: struct video_frame video_buffer[VIDEO_BUFFER_SIZE];
 55: uint32_t vbuffer_read = 0;
 56: uint32_t vbuffer_write = 0;
 57: 
 58: uint32_t movie_frame_counter = 0;
 59: uint32_t movie_frames;
 60: uint32_t movie_width, movie_height;
 61: double movie_fps;
 62: double movie_duration;
 63: bool fullrange_input = false;
 64: ColorMatrixType colormatrix = COLORMATRIX_BT601;
 65: ColorGamutType colorgamut = COLORGAMUT_SRGB;
 66: InverseGammaFunctionType gammatype = GAMMAFUNCTION_SRGB;
 67: AVPixelFormat targetpixelformat = AV_PIX_FMT_YUV444P;
 68: 
 69: bool first_audio_packet;
 70: 
 71: time_t timer_freq;
 72: time_t start_time;
 73: 
 74: void ffmpeg_movie_init()
 75: {
 76: 	ffnx_info("FFMpeg movie player plugin loaded\n");
 77: 
 78: 	QueryPerformanceFrequency((LARGE_INTEGER *)&timer_freq);
 79: }
 80: 
 81: // clean up anything we have allocated
 82: void ffmpeg_release_movie_objects()
 83: {
 84: 	uint32_t i;
 85: 
 86: 	if (movie_frame) av_frame_free(&movie_frame);
 87: 	if (codec_ctx) avcodec_free_context(&codec_ctx);
 88: 	if (acodec_ctx) avcodec_free_context(&acodec_ctx);
 89: 	if (format_ctx) avformat_close_input(&format_ctx);
 90: 	if (swr_ctx) {
 91: 		swr_close(swr_ctx);
 92: 		swr_free(&swr_ctx);
 93: 	}
 94: 
 95: 	codec_ctx = 0;
 96: 	acodec_ctx = 0;
 97: 	format_ctx = 0;
 98: 
 99: 	audio_must_be_converted = false;
100: 
101: 	for(i = 0; i < VIDEO_BUFFER_SIZE; i++)
102: 	{
103: 		// Cleanup YUV textures
104: 		for (uint32_t idx = 0; idx < 3; idx++)
105: 		{
106: 			newRenderer.deleteTexture(video_buffer[i].yuv_textures[idx]);
107: 			video_buffer[i].yuv_textures[idx] = 0;
108: 		}
109: 	}
110: 
111: 	// Unset slot U and V as they are used only for YUV textures
112: 	newRenderer.useTexture(0, RendererTextureSlot::TEX_U);
113: 	newRenderer.useTexture(0, RendererTextureSlot::TEX_V);
114: }
115: 
116: // prepare a movie for playback
117: uint32_t ffmpeg_prepare_movie(const char *name, bool with_audio)
118: {
119: 	uint32_t i;
120: 	WAVEFORMATEX sound_format;
121: 	DSBUFFERDESC1 sbdesc;
122: 	bool okpixelformat = false;
123: 	bool okcolorspace = false;
124: 	bool yuvjfixneeded = false;
125: 	bool islogomovie = false;
126: 	bool isff8steammovie = false;
127: 	int lastbackslashindex = -1;
128: 	int bytessincebackslash = 0;
129: 	int scanoffset = 0;
130: 
131: 	movie_frames = 0;
132: 
133: 	if(avformat_open_input(&format_ctx, name, NULL, NULL))
134: 	{
135: 		ffnx_error("prepare_movie: couldn't open movie file: %s\n", name);
136: 		ffmpeg_release_movie_objects();
137: 		goto exit;
138: 	}
139: 
140: 	if(avformat_find_stream_info(format_ctx, NULL) < 0)
141: 	{
142: 		ffnx_error("prepare_movie: couldn't find stream info\n");
143: 		ffmpeg_release_movie_objects();
144: 		goto exit;
145: 	}
146: 
147: 	videostream = av_find_best_stream(format_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, &codec, 0);
148: 	if (videostream < 0) {
149: 		ffnx_error("prepare_movie: no video stream found\n");
150: 		ffmpeg_release_movie_objects();
151: 		goto exit;
152: 	}
153: 
154: 	if (with_audio)
155: 	{
156: 		audiostream = av_find_best_stream(format_ctx, AVMEDIA_TYPE_AUDIO, -1, -1, &acodec, 0);
157: 		if(audiostream < 0 && (trace_movies || trace_all)) ffnx_trace("prepare_movie: no audio stream found\n");
158: 	}
159: 	else
160: 		audiostream = -1;
161: 
162: 	codec_ctx = avcodec_alloc_context3(codec);
163: 	if (!codec_ctx) {
164: 		ffnx_error("prepare_movie: could not allocate video codec context\n");
165: 		codec_ctx = 0;
166: 		ffmpeg_release_movie_objects();
167: 		goto exit;
168: 	}
169: 	avcodec_parameters_to_context(codec_ctx, format_ctx->streams[videostream]->codecpar);
170: 
171: 	if(avcodec_open2(codec_ctx, codec, NULL) < 0)
172: 	{
173: 		ffnx_error("prepare_movie: couldn't open video codec\n");
174: 		ffmpeg_release_movie_objects();
175: 		goto exit;
176: 	}
177: 
178: 	if(audiostream >= 0)
179: 	{
180: 		acodec_ctx = avcodec_alloc_context3(acodec);
181: 		if (!acodec_ctx) {
182: 			ffnx_error("prepare_movie: could not allocate audio codec context\n");
183: 			codec_ctx = 0;
184: 			ffmpeg_release_movie_objects();
185: 			goto exit;
186: 		}
187: 		avcodec_parameters_to_context(acodec_ctx, format_ctx->streams[audiostream]->codecpar);
188: 
189: 		if(avcodec_open2(acodec_ctx, acodec, NULL) < 0)
190: 		{
191: 			ffnx_error("prepare_movie: couldn't open audio codec\n");
192: 			ffmpeg_release_movie_objects();
193: 			goto exit;
194: 		}
195: 	}
196: 
197: 	// figure out if this is the eidos logo or square logo; they need special treatment
198: 	// scan till we hit 0 terminator
199: 	while (true){
200: 		bytessincebackslash++;
201: 		// note the index of the last backslash, and how far the string continues after that
202: 		if (name[scanoffset] == 92){
203: 			lastbackslashindex = scanoffset;
204: 			bytessincebackslash = 0;
205: 		}
206: 		else if (name[scanoffset] == 0){
207: 			break;
208: 		}
209: 		scanoffset++;
210: 	}
211: 	char upperbuffer[128];
212: 	memset(upperbuffer, 0, 128);
213: 	if ((lastbackslashindex > -1) && (bytessincebackslash > 1) && (bytessincebackslash <= 128)){
214: 		memcpy(&upperbuffer, &name[lastbackslashindex+1], bytessincebackslash);
215: 		// convert to uppercase
216: 		for (int i=0; i<bytessincebackslash; i++){
217: 			upperbuffer[i] = toupper(upperbuffer[i]);
218: 		}
219: 		// strip the file extension
220: 		for (int i=bytessincebackslash-1; i>=0; i--){
221: 			char backchar = upperbuffer[i];
222: 			upperbuffer[i] = 0;
223: 			if (backchar == 46){
224: 				break;
225: 			}
226: 		}
227: 		if (	(strcmp(upperbuffer, "EIDOSLOGO") == 0) ||
228: 			(strcmp(upperbuffer, "SQLOGO") == 0)
229: 		){
230: 			islogomovie = true;
231: 			if (trace_movies  || trace_all) ffnx_trace("prepare_movie: %s detected as logo movie; NTSC-J conversion will be supressed.\n", name);
232: 		}
233: 	}
234: 
235: 	// Movie files from the ff8 Steam release appear to be bt709, tv-range, with gamut conversion already done, and no metadata
236: 	// (Not completely sure about bt709; it's hard to tell under the circumstances.)
237: 	if (    ff8 &&
238: 			((codec_ctx->height >= 720) || (codec_ctx->width >= 1280)) && // the samples I examined were 1280 x 896, but I didn't check them all to rule out some of them being cropped
239: 			(codec_ctx->pix_fmt == AV_PIX_FMT_YUV420P) &&
240: 			(codec_ctx->color_range == AVCOL_RANGE_UNSPECIFIED) &&
241: 			(codec_ctx->colorspace == AVCOL_SPC_UNSPECIFIED) &&
242: 			(codec_ctx->color_trc == AVCOL_TRC_UNSPECIFIED) &&
243: 			(codec_ctx->color_primaries == AVCOL_PRI_UNSPECIFIED)
244: 	){
245: 		isff8steammovie = true;
246: 		if (trace_movies  || trace_all) ffnx_trace("prepare_movie: File %s appears to be from the FF8 Steam release. Missing metadata will be guessed accordingly.\n", name);
247: 	}
248: 
249: 	movie_width = codec_ctx->width;
250: 	movie_height = codec_ctx->height;
251: 	movie_fps = av_q2d(av_guess_frame_rate(format_ctx, format_ctx->streams[videostream], NULL));
252: 	movie_duration = (double)format_ctx->duration / (double)AV_TIME_BASE;
253: 	movie_frames = (uint32_t)::round(movie_fps * movie_duration);
254: 	fullrange_input = (codec_ctx->color_range == AVCOL_RANGE_JPEG);
255: 
256: 	// some pixel formats are inherently full-range
257: 	// so we should treat them as such, even if the color range metadata is missing
258: 	// some of these formats also trigger an automatic color range conversion that we must suppress
259: 	switch (codec_ctx->pix_fmt){
260: 		case AV_PIX_FMT_YUVJ420P:
261: 		case AV_PIX_FMT_YUVJ411P:
262: 		case AV_PIX_FMT_YUVJ422P:
263: 		case AV_PIX_FMT_YUVJ444P:
264: 		case AV_PIX_FMT_YUVJ440P:
265: 			fullrange_input = true;
266: 			yuvjfixneeded = true;
267: 			break;
268: 		case AV_PIX_FMT_GRAY8:
269: 		case AV_PIX_FMT_YA8:
270: 		case AV_PIX_FMT_GRAY16LE:
271: 		case AV_PIX_FMT_GRAY16BE:
272: 		case AV_PIX_FMT_YA16BE:
273: 		case AV_PIX_FMT_YA16LE:
274: 		case AV_PIX_FMT_BGR24:
275: 			fullrange_input = true;
276: 			yuvjfixneeded = false;
277: 			break;
278: 		default:
279: 			yuvjfixneeded = false;
280: 	}
281: 
282: 	if (isff8steammovie){
283: 		fullrange_input = false;
284: 		yuvjfixneeded = false;
285: 	}
286: 
287: 	if (trace_movies  || trace_all) ffnx_trace("prepare_movie: color range detected as %i (0=tv, 1=pc).\n", fullrange_input);
288: 
289: 	// will we need to convert the colorspace?
290: 	switch(codec_ctx->colorspace){
291: 		// these are all the same (bt601)
292: 		case AVCOL_SPC_UNSPECIFIED: // ffmpeg guesses and treats this as bt601
293: 		case AVCOL_SPC_RESERVED: // ffmpeg guesses and treats this as bt601
294: 			if (codec_ctx->pix_fmt == AV_PIX_FMT_BGR24){
295: 				if (trace_movies  || trace_all) ffnx_trace("prepare_movie: BGR24 detected.\n");
296: 				colormatrix = COLORMATRIX_BGR24;
297: 				okcolorspace = true;
298: 				break;
299: 			}
300: 			else if (isff8steammovie){
301: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: assuming bt709 color matrix because this is a FF8 Steam release movie.\n");
302: 				colormatrix = COLORMATRIX_BT709;
303: 				okcolorspace = true;
304: 				break;
305: 			}
306: 			// fall through to next case if we didn't already break
307: 		case AVCOL_SPC_BT470BG:
308: 		case AVCOL_SPC_SMPTE170M:
309: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: bt601 color matrix detected or defaulted to.\n");
310: 			colormatrix = COLORMATRIX_BT601;
311: 			okcolorspace = true;
312: 			break;
313: 		case AVCOL_SPC_BT709:
314: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: bt709 color matrix detected.\n");
315: 			colormatrix = COLORMATRIX_BT709;
316: 			okcolorspace = true;
317: 		case AVCOL_SPC_RGB:
318: 			if (codec_ctx->pix_fmt == AV_PIX_FMT_BGR24){
319: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: BGR24 detected.\n");
320: 				colormatrix = COLORMATRIX_BGR24;
321: 				okcolorspace = true;
322: 			}
323: 			else {
324: 				okcolorspace = false;
325: 			}
326: 			break;
327: 		default:
328: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: unhandled color matrix detected; will use swscale to convert. Expect incorrect gamut.\n");
329: 			okcolorspace = false;
330: 	}
331: 
332: 	// what gamma should we use?
333: 	switch(codec_ctx->color_trc){
334: 		case AVCOL_TRC_UNSPECIFIED:
335: 		case AVCOL_TRC_RESERVED:
336: 		case AVCOL_TRC_RESERVED0:
337: 			if (colormatrix == COLORMATRIX_BT709){
338: 				gammatype = GAMMAFUNCTION_SMPTE170M;
339: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing gamma metadata, but bt709 color matrix, so assuming SMPTE170M transfer function.\n");
340: 			}
341: 			else if (codec_ctx->color_primaries == AVCOL_PRI_BT470BG){
342: 				gammatype = GAMMAFUNCTION_TWO_PT_EIGHT;
343: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing gamma metadata, but EBU color gamut (PAL), so assuming 2.8 gamma (PAL).\n");
344: 			}
345: 			else {
346: 				gammatype = GAMMAFUNCTION_TOELESS_SRGB;
347: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing gamma metadata, assuming Playstation-derived video, using \"toeless sRGB\" gamma curve.\n");
348: 			}
349: 			break;
350: 		case AVCOL_TRC_IEC61966_2_1: //srgb
351: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: srgb gamma transfer function detected\n");
352: 			gammatype = GAMMAFUNCTION_SRGB;
353: 			break;
354: 		case AVCOL_TRC_GAMMA22:
355: 			gammatype = GAMMAFUNCTION_TWO_PT_TWO;
356: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: 2.2 gamma transfer function detected\n");
357: 			break;
358: 		case AVCOL_TRC_SMPTE170M:
359: 		case AVCOL_TRC_BT709: // same as SMPTE170M
360: 		case AVCOL_TRC_BT2020_10: // same as SMPTE170M
361: 		case AVCOL_TRC_BT2020_12: // same as SMPTE170M
362: 		case AVCOL_TRC_IEC61966_2_4: // same as SMPTE170M, but is defined for negative numbers too (which we ignore)
363: 		case AVCOL_TRC_BT1361_ECG: // same as SMPTE170M, but is defined for negative numbers too (which we ignore)
364: 			gammatype = GAMMAFUNCTION_SMPTE170M;
365: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: SMPTE170M transfer function detected\n");
366: 			break;
367: 		case AVCOL_TRC_GAMMA28:
368: 			gammatype = GAMMAFUNCTION_TWO_PT_EIGHT;
369: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: 2.8 gamma transfer function detected\n");
370: 			break;
371: 		default:
372: 			ffnx_error("prepare_movie: unsupported transfer (inverse gamma) function\n");
373: 			ffmpeg_release_movie_objects();
374: 			goto exit;
375: 	}
376: 
377: 	if (codec_ctx->pix_fmt == AV_PIX_FMT_BGR24){
378: 		targetpixelformat = AV_PIX_FMT_BGR24;
379: 	}
380: 	else{
381: 		targetpixelformat = AV_PIX_FMT_YUV444P;
382: 	}
383: 
384: 	// will we need to convert the pixel format?
385: 	// we're going to target YUV444 on the assumption that swscale does better subsampling than texture2D() in the shader
386: 	// Also, we generally shouldn't target a YUVJ format because that triggers a bunch of automatic, sometimes wrong, color range conversions
387: 	if (codec_ctx->pix_fmt == targetpixelformat){
388: 		okpixelformat = true;
389: 	}
390: 
391: 	switch(codec_ctx->color_primaries){
392: 		case AVCOL_PRI_BT709:
393: 			colorgamut = COLORGAMUT_SRGB;
394: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: srgb/bt709 color gamut detected.\n");
395: 			break;
396: 		case AVCOL_PRI_BT470M:
397: 			// Since 470m (NTSC1953) was deprecated in 1979, material in this gamut is rare and likely irrelevant to FF7/8.
398: 			// Assume user meant SMPTE-C (which replaced NTSC1953 in 1979).
399: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: NTSC1953 color gamut detected. Assuming user error and using SMPTE-C instead.\n");
400: 			// fall through to next case
401: 		case AVCOL_PRI_SMPTE170M:
402: 		case AVCOL_PRI_SMPTE240M:
403: 
404: 			colorgamut = COLORGAMUT_SMPTEC;
405: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: SMPTE-C color gamut detected.\n");
406: 			break;
407: 		case AVCOL_PRI_UNSPECIFIED:
408: 		case AVCOL_PRI_RESERVED0:
409: 		case AVCOL_PRI_RESERVED:
410: 			if (isff8steammovie){
411: 				colorgamut = COLORGAMUT_SRGB;
412: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming srgb/bt709 because this is a FF8 Steam release video. (Steam already did NTSC-J to SRGB gamut conversion.)\n");
413: 			}
414: 			else if (colormatrix == COLORMATRIX_BT709){
415: 				colorgamut = COLORGAMUT_SRGB;
416: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming srgb/bt709 because bt709 color matrix.\n");
417: 			}
418: 			else if (islogomovie){
419: 				colorgamut = COLORGAMUT_SRGB;
420: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming srgb/bt709 because this is a logo movie.\n");
421: 			}
422: 			else {
423: 				colorgamut = COLORGAMUT_NTSCJ;
424: 				if (trace_movies || trace_all) ffnx_trace("prepare_movie: missing color gamut metadata; assuming NTSC-J.\n");
425: 			}
426: 			break;
427: 		case AVCOL_PRI_BT470BG:
428: 			colorgamut = COLORGAMUT_EBU;
429: 			if (trace_movies || trace_all) ffnx_trace("prepare_movie: EBU(PAL) color gamut detected.\n");
430: 			break;
431: 		default:
432: 			ffnx_error("prepare_movie: unsupported color gamut\n");
433: 			ffmpeg_release_movie_objects();
434: 			goto exit;
435: 	}
436: 
437: 	if (trace_movies || trace_all)
438: 	{
439: 		if (movie_fps < 100.0) ffnx_info("prepare_movie: %s; %s/%s %ix%i, %f FPS, duration: %f, frames: %i, color_range: %d\n", name, codec->name, acodec_ctx ? acodec->name : "null", movie_width, movie_height, movie_fps, movie_duration, movie_frames, codec_ctx->color_range);
440: 		// bogus FPS value, assume the codec provides frame limiting
441: 		else ffnx_info("prepare_movie: %s; %s/%s %ix%i, duration: %f, color_range: %d\n", name, codec->name, acodec_ctx ? acodec->name : "null", movie_width, movie_height, movie_duration, codec_ctx->color_range);
442: 	}
443: 
444: 	if(movie_width > max_texture_size || movie_height > max_texture_size)
445: 	{
446: 		ffnx_error("prepare_movie: movie dimensions exceed max texture size, skipping\n");
447: 		ffmpeg_release_movie_objects();
448: 		goto exit;
449: 	}
450: 
451: 	if(!movie_frame) movie_frame = av_frame_alloc();
452: 
453: 	if(sws_ctx) sws_freeContext(sws_ctx);
454: 
455: 	vbuffer_read = 0;
456: 	vbuffer_write = 0;
457: 
458: 	if(!okpixelformat || !okcolorspace || yuvjfixneeded)
459: 		// Don't check for !fullrange_input here because swscale won't always do color range conversions on request, so we can't rely on it and must instead do it ourselves in the shader
460: 	{
461: 		if (trace_movies || trace_all)
462: 		{
463: 			ffnx_trace("prepare_movie: Video must be converted: IN codec_ctx->colorspace: %s\n", av_color_space_name(codec_ctx->colorspace));
464: 			ffnx_trace("prepare_movie: Video must be converted: IN codec_ctx->pix_fmt: %s\n", av_pix_fmt_desc_get(codec_ctx->pix_fmt)->name);
465: 		}
466: 
467: 		sws_ctx = sws_getContext(
468: 			movie_width,
469: 			movie_height,
470: 			codec_ctx->pix_fmt,
471: 			movie_width,
472: 			movie_height,
473: 			targetpixelformat,
474: 			SWS_LANCZOS | SWS_ACCURATE_RND | SWS_FULL_CHR_H_INT,
475: 			NULL,
476: 			NULL,
477: 			NULL
478: 		);
479: 
480: 		// if we need a colorspace conversion, set it up here
481: 		// this would also be the place to set up color range conversion, if it worked -- which it doens't
482: 		if (!okcolorspace || yuvjfixneeded){
483: 			int *coefs_in;
484: 			int *coefs_out;
485: 			int srcRange, dstRange;
486: 			int brightness, contrast, saturation;
487: 			sws_getColorspaceDetails(sws_ctx, &coefs_in, &srcRange, &coefs_out, &dstRange, &brightness, &contrast, &saturation);
488: 
489: 			coefs_in = const_cast<int*>(sws_getCoefficients(codec_ctx->colorspace)); // const sucks
490: 			// use the same colorspace
491: 			if (okcolorspace){
492: 				coefs_out = coefs_in;
493: 			}
494: 			// convert
495: 			else {
496: 				coefs_out = const_cast<int*>(sws_getCoefficients(SWS_CS_ITU601)); // const sucks
497: 			}
498: 
499: 			// Surprisingly, these parameters don't appear to **do** anything in most cases.
500: 			// It appears that whether swscale does a range conversion is controlled by pixformat and range metadata.
501: 			// And it will do one regardless of whether you want it.
502: 			// Except, when the input format is YUVJ, these parameters can be used to **prevent** an un-asked-for PC->TV conversion
503: 			// (They are totally ignored with 10-bit input formats, however.)
504: 			// Gawd... swscale is a buggy mess...
505: 			if (yuvjfixneeded){
506: 				srcRange = fullrange_input ? 1 : 0; // use the input color range
507: 				dstRange = srcRange; // no conversion!
508: 			}
509: 
510: 			sws_setColorspaceDetails(sws_ctx, coefs_in, srcRange, coefs_out, dstRange, brightness, contrast, saturation);
511: 		}
512: 
513: 	}
514: 	else {
515: 		sws_ctx = nullptr;
516: 	}
517: 
518: 	if(audiostream >= 0)
519: 	{
520: 		if (acodec_ctx->sample_fmt != AV_SAMPLE_FMT_FLT) {
521: 			audio_must_be_converted = true;
522: 			if (trace_movies || trace_all)
523: 			{
524: 				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->sample_fmt: %s\n", av_get_sample_fmt_name(acodec_ctx->sample_fmt));
525: 				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->sample_rate: %d\n", acodec_ctx->sample_rate);
526: 				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->ch_layout.u.mask: %u\n", acodec_ctx->ch_layout.u.mask);
527: 				ffnx_trace("prepare_movie: Audio must be converted: IN acodec_ctx->ch_layout.nb_channels: %u\n", acodec_ctx->ch_layout.nb_channels);
528: 			}
529: 
530: 			// Prepare software conversion context
531: 			swr_alloc_set_opts2(
532: 				// Create a new context
533: 				&swr_ctx,
534: 				// OUT
535: 				&acodec_ctx->ch_layout,
536: 				AV_SAMPLE_FMT_FLT,
537: 				acodec_ctx->sample_rate,
538: 				// IN
539: 				&acodec_ctx->ch_layout,
540: 				acodec_ctx->sample_fmt,
541: 				acodec_ctx->sample_rate,
542: 				// LOG
543: 				0,
544: 				NULL
545: 			);
546: 
547: 			swr_init(swr_ctx);
548: 		}
549: 
550: 		nxAudioEngine.initStream(
551: 			movie_duration,
552: 			acodec_ctx->sample_rate,
553: 			acodec_ctx->ch_layout.nb_channels
554: 		);
555: 
556: 		first_audio_packet = true;
557: 	}
558: 
559: 	exit:
560: 	movie_frame_counter = 0;
561: 
562: 	return movie_frames;
563: }
564: 
565: // stop movie playback, no video updates will be requested after this so all we have to do is stop the audio
566: void ffmpeg_stop_movie()
567: {
568: 	nxAudioEngine.stopStream();
569: }
570: 
571: void upload_yuv_texture(uint8_t **planes, int *strides, uint32_t num, uint32_t buffer_index)
572: {
573: 	uint32_t upload_width = strides[num];
574: 	// Use full dimensions for chroma planes in yuv444. If yuv420, use half width and half height instead.
575: 	uint32_t tex_width = movie_width;
576: 	uint32_t tex_height = movie_height;
577: 
578: 	if (upload_width > tex_width) tex_width = upload_width;
579: 
580: 	if (video_buffer[buffer_index].yuv_textures[num])
581: 		newRenderer.deleteTexture(video_buffer[buffer_index].yuv_textures[num]);
582: 
583: 	video_buffer[buffer_index].yuv_textures[num] = newRenderer.createTexture(
584: 		planes[num],
585: 		tex_width,
586: 		tex_height,
587: 		upload_width,
588: 		RendererTextureType::YUV,
589: 		false
590: 	);
591: }
592: 
593: void buffer_yuv_frame(uint8_t **planes, int *strides)
594: {
595: 	// Special case for BGR24. Make it planar RGB so we can pass it through the YUV plumbing
596: 	// Not very efficient, but it's not worth making everything else more complex for the sake of this one case.
597: 	if (targetpixelformat == AV_PIX_FMT_BGR24){
598: 		if (strides[0] % 3 != 0){
599: 			ffnx_error("buffer_yuv_frame: movie file claims to be bgr24, but stride isn't divisible by 3!\n");
600: 			ffmpeg_release_movie_objects();
601: 			movie_frame_counter = 0;
602: 			return;
603: 		}
604: 		const int planarstride = strides[0]/3;
605: 		int fakestrides[3] = {planarstride, planarstride, planarstride};
606: 		uint8_t* realbuffer = planes[0];
607: 		uint8_t* redbuffer = (uint8_t*)malloc(planarstride * movie_height * sizeof(uint8_t));
608: 		uint8_t* greenbuffer = (uint8_t*)malloc(planarstride * movie_height * sizeof(uint8_t));
609: 		uint8_t* bluebuffer = (uint8_t*)malloc(planarstride * movie_height * sizeof(uint8_t));
610: 		uint8_t* fakeplanes[3] = {redbuffer, greenbuffer, bluebuffer};
611: 		int smallindex = 0;
612: 		int rgbindex = 0;
613: 		int maxindex = strides[0] * movie_height;
614: 		for (int i=0; i<maxindex; i++){
615: 			uint8_t nextbyte = realbuffer[i];
616: 			if (rgbindex == 0){
617: 				bluebuffer[smallindex] = nextbyte;
618: 			}
619: 			else if (rgbindex == 1){
620: 				greenbuffer[smallindex] = nextbyte;
621: 			}
622: 			else {
623: 				redbuffer[smallindex] = nextbyte;
624: 				smallindex++;
625: 			}
626: 			rgbindex++;
627: 			if (rgbindex > 2){
628: 				rgbindex = 0;
629: 			}
630: 		}
631: 		upload_yuv_texture(fakeplanes, fakestrides, 0, vbuffer_write); // R as Y
632: 		upload_yuv_texture(fakeplanes, fakestrides, 1, vbuffer_write); // G as U
633: 		upload_yuv_texture(fakeplanes, fakestrides, 2, vbuffer_write); // B as V
634: 		free(redbuffer);
635: 		redbuffer = nullptr;
636: 		free(greenbuffer);
637: 		greenbuffer = nullptr;
638: 		free(bluebuffer);
639: 		bluebuffer = nullptr;
640: 	}
641: 	// normal case
642: 	else {
643: 		upload_yuv_texture(planes, strides, 0, vbuffer_write); // Y
644: 		upload_yuv_texture(planes, strides, 1, vbuffer_write); // U
645: 		upload_yuv_texture(planes, strides, 2, vbuffer_write); // V
646: 	}
647: 
648: 	vbuffer_write = (vbuffer_write + 1) % VIDEO_BUFFER_SIZE;
649: }
650: 
651: void draw_yuv_frame(uint32_t buffer_index)
652: {
653: 	if(gl_defer_yuv_frame(buffer_index)) return;
654: 
655: 	for (uint32_t idx = 0; idx < 3; idx++)
656: 		newRenderer.useTexture(video_buffer[buffer_index].yuv_textures[idx], idx);
657: 
658: 	newRenderer.isMovie(true);
659: 	newRenderer.isYUV(true);
660: 	newRenderer.isFullRange(fullrange_input);
661: 	newRenderer.setColorMatrix(colormatrix);
662: 	newRenderer.setColorGamut(colorgamut);
663: 	newRenderer.setGammaType(gammatype);
664: 	gl_draw_movie_quad(movie_width, movie_height);
665: 	newRenderer.isFullRange(false);
666: 	newRenderer.isYUV(false);
667: 	newRenderer.isMovie(false);
668: 	newRenderer.setColorMatrix(COLORMATRIX_BT601);
669: 	newRenderer.setColorGamut(COLORGAMUT_SRGB);
670: 	newRenderer.setGammaType(GAMMAFUNCTION_SRGB);
671: }
672: 
673: // display the next frame
674: uint32_t ffmpeg_update_movie_sample(bool use_movie_fps)
675: {
676: 	AVPacket packet;
677: 	int ret;
678: 	time_t now;
679: 	DWORD DSStatus;
680: 
681: 	// no playable movie loaded, skip it
682: 	if(!format_ctx) return false;
683: 
684: 	// keep track of when we started playing this movie
685: 	if(movie_frame_counter == 0) QueryPerformanceCounter((LARGE_INTEGER *)&start_time);
686: 
687: 	while((ret = av_read_frame(format_ctx, &packet)) >= 0)
688: 	{
689: 		if(packet.stream_index == videostream)
690: 		{
691: 			ret = avcodec_send_packet(codec_ctx, &packet);
692: 
693: 			if (ret < 0)
694: 			{
695: 				ffnx_trace("%s: avcodec_send_packet -> %d\n", __func__, ret);
696: 				av_packet_unref(&packet);
697: 				break;
698: 			}
699: 
700: 			ret = avcodec_receive_frame(codec_ctx, movie_frame);
701: 
702: 			if (ret == AVERROR_EOF)
703: 			{
704: 				ffnx_trace("%s: avcodec_receive_frame -> %d\n", __func__, ret);
705: 				av_packet_unref(&packet);
706: 				break;
707: 			}
708: 
709: 			if (ret >= 0)
710: 			{
711: 				QueryPerformanceCounter((LARGE_INTEGER *)&now);
712: 
713: 				if(sws_ctx)
714: 				{
715: 					AVFrame* frame = av_frame_alloc();
716: 					frame->width = movie_width;
717: 					frame->height = movie_height;
718: 					frame->format = targetpixelformat;
719: 
720: 					av_image_alloc(frame->data, frame->linesize, frame->width, frame->height, AVPixelFormat(frame->format), 1);
721: 
722: 					sws_scale(sws_ctx, movie_frame->extended_data, movie_frame->linesize, 0, frame->height, frame->data, frame->linesize);
723: 					buffer_yuv_frame(frame->data, frame->linesize);
724: 
725: 					av_freep(&frame->data[0]);
726: 					av_frame_free(&frame);
727: 				}
728: 				else buffer_yuv_frame(movie_frame->extended_data, movie_frame->linesize);
729: 
730: 				if(vbuffer_write == vbuffer_read)
731: 				{
732: 					draw_yuv_frame(vbuffer_read);
733: 
734: 					vbuffer_read = (vbuffer_read + 1) % VIDEO_BUFFER_SIZE;
735: 
736: 					av_packet_unref(&packet);
737: 
738: 					break;
739: 				}
740: 			}
741: 		}
742: 
743: 		if(packet.stream_index == audiostream)
744: 		{
745: 			QueryPerformanceCounter((LARGE_INTEGER *)&now);
746: 
747: 			ret = avcodec_send_packet(acodec_ctx, &packet);
748: 
749: 			if (ret < 0)
750: 			{
751: 				ffnx_trace("%s: avcodec_send_packet -> %d\n", __func__, ret);
752: 				av_packet_unref(&packet);
753: 				break;
754: 			}
755: 
756: 			ret = avcodec_receive_frame(acodec_ctx, movie_frame);
757: 
758: 			if (ret == AVERROR_EOF)
759: 			{
760: 				ffnx_trace("%s: avcodec_receive_frame -> %d\n", __func__, ret);
761: 				av_packet_unref(&packet);
762: 				break;
763: 			}
764: 
765: 			if (ret >= 0)
766: 			{
767: 				uint32_t bytesperpacket = audio_must_be_converted ? av_get_bytes_per_sample(AV_SAMPLE_FMT_FLT) : av_get_bytes_per_sample(acodec_ctx->sample_fmt);
768: 				uint32_t _size = bytesperpacket * movie_frame->nb_samples * acodec_ctx->ch_layout.nb_channels;
769: 
770: 				// Sometimes the captured frame may have no sound samples. Just skip and move forward
771: 				if (_size)
772: 				{
773: 					uint8_t *buffer;
774: 
775: 					av_samples_alloc(&buffer, movie_frame->linesize, acodec_ctx->ch_layout.nb_channels, movie_frame->nb_samples, (audio_must_be_converted ? AV_SAMPLE_FMT_FLT : acodec_ctx->sample_fmt), 0);
776: 					if (audio_must_be_converted) swr_convert(swr_ctx, &buffer, movie_frame->nb_samples, (const uint8_t**)movie_frame->extended_data, movie_frame->nb_samples);
777: 					else av_samples_copy(&buffer, movie_frame->extended_data, 0, 0, movie_frame->nb_samples, acodec_ctx->ch_layout.nb_channels, acodec_ctx->sample_fmt);
778: 
779: 					nxAudioEngine.pushStreamData(buffer, _size);
780: 
781: 					av_freep(&buffer);
782: 				}
783: 			}
784: 		}
785: 
786: 		av_packet_unref(&packet);
787: 	}
788: 
789: 	if (first_audio_packet)
790: 	{
791: 		first_audio_packet = false;
792: 
793: 		// reset start time so video syncs up properly
794: 		QueryPerformanceCounter((LARGE_INTEGER *)&start_time);
795: 
796: 		nxAudioEngine.playStream();
797: 	}
798: 
799: 	movie_frame_counter++;
800: 
801: 	// could not read any more frames, exhaust video buffer then end movie
802: 	if(ret < 0)
803: 	{
804: 		if(vbuffer_write != vbuffer_read)
805: 		{
806: 			draw_yuv_frame(vbuffer_read);
807: 
808: 			vbuffer_read = (vbuffer_read + 1) % VIDEO_BUFFER_SIZE;
809: 		}
810: 
811: 		if(vbuffer_write == vbuffer_read) return false;
812: 	}
813: 
814: 	// Pure movie playback has no frame limiter, although it is not always required. Use it only when necessary
815: 	if (use_movie_fps)
816: 	{
817: 		// wait for the next frame
818: 		do
819: 		{
820: 			QueryPerformanceCounter((LARGE_INTEGER *)&now);
821: 		} while(LAG < 0.0);
822: 	}
823: 
824: 	// keep going
825: 	return true;
826: }
827: 
828: // draw the current frame, don't update anything
829: void ffmpeg_draw_current_frame()
830: {
831: 	draw_yuv_frame((vbuffer_read - 1) % VIDEO_BUFFER_SIZE);
832: }
833: 
834: // loop back to the beginning of the movie
835: void ffmpeg_loop()
836: {
837: 	if(format_ctx) avformat_seek_file(format_ctx, -1, 0, 0, 0, 0);
838: }
839: 
840: // get the current frame number
841: uint32_t ffmpeg_get_movie_frame()
842: {
843: 	return movie_frame_counter;
844: }
845: 
846: short ffmpeg_get_fps_ratio()
847: {
848: 	return ceil(movie_fps / 15.0f);
849: }
</file>

<file path="src/video/movies.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <windows.h>
25: #include <math.h>
26: #include <sys/timeb.h>
27: #include <dbghelp.h>
28: #include <stdint.h>
29: 
30: void ffmpeg_movie_init();
31: void ffmpeg_release_movie_objects();
32: uint32_t ffmpeg_prepare_movie(const char* name, bool with_audio = true);
33: void ffmpeg_stop_movie();
34: uint32_t ffmpeg_update_movie_sample(bool use_movie_fps = true);
35: void ffmpeg_draw_current_frame();
36: void ffmpeg_loop();
37: uint32_t ffmpeg_get_movie_frame();
38: 
39: short ffmpeg_get_fps_ratio();
40: 
41: void draw_yuv_frame(uint32_t buffer_index);
</file>

<file path="src/achievement.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <steamworkssdk/isteamutils.h>
 24: #include <steamworkssdk/isteamuserstats.h>
 25: #include <steamworkssdk/isteamuser.h>
 26: 
 27: #include <numeric>
 28: #include <algorithm>
 29: #include <unordered_set>
 30: 
 31: #include "achievement.h"
 32: #include "log.h"
 33: #include "cfg.h"
 34: 
 35: #define ach_trace(x, ...) if (trace_all || trace_achievement) ffnx_trace((x), ##__VA_ARGS__)
 36: 
 37: using std::string;
 38: 
 39: std::unique_ptr<SteamAchievementsFF7> g_FF7SteamAchievements = nullptr;
 40: std::unique_ptr<SteamAchievementsFF8> g_FF8SteamAchievements = nullptr;
 41: 
 42: SteamManager::SteamManager(const achievement *achievements, int nAchievements, std::vector<std::string> statsNameVec):
 43:   isInitialized(false),
 44:   callbackUserStatsReceived(this, &SteamManager::OnUserStatsReceived),
 45:   callbackUserStatsStored(this, &SteamManager::OnUserStatsStored),
 46:   callbackAchievementStored(this, &SteamManager::OnAchievementStored)
 47: {
 48:     this->appID = SteamUtils()->GetAppID();
 49:     this->nAchievements = nAchievements;
 50:     for (std::string statName : statsNameVec) {
 51:         this->stats.insert({statName, 0});
 52:     }
 53:     this->achievementList.insert(this->achievementList.end(), &achievements[0], &achievements[nAchievements]);
 54:     this->requestStats();
 55:     if (trace_all || trace_achievement)
 56:         ffnx_trace("%s - Init steam achievements with appID: %d\n", __func__, this->appID);
 57: }
 58: 
 59: bool SteamManager::requestStats()
 60: {
 61:     // Is Steam loaded?
 62:     if (NULL == SteamUserStats() || NULL == SteamUser())
 63:     {
 64:         return false;
 65:     }
 66:     // Is the user logged on?
 67:     if (!SteamUser()->BLoggedOn())
 68:     {
 69:         return false;
 70:     }
 71:     if (trace_all || trace_achievement)
 72:         ffnx_trace("%s - Request user stats sent\n", __func__);
 73: 
 74:     return SteamUserStats()->RequestCurrentStats();
 75: }
 76: 
 77: bool SteamManager::setAchievement(int achID)
 78: {
 79:     if (this->isInitialized)
 80:     {
 81:         if (trace_all || trace_achievement)
 82:             ffnx_trace("%s - Achievement %s set, Store request sent to Steam\n", __func__, this->getStringAchievementID(achID));
 83: 
 84:         this->achievementList[achID].isAchieved = true;
 85:         if (steam_achievements_debug_mode)
 86:         {
 87:             return SteamUserStats()->IndicateAchievementProgress(this->getStringAchievementID(achID), 99, 100);
 88:         }
 89:         else
 90:         {
 91:             SteamUserStats()->SetAchievement(this->getStringAchievementID(achID));
 92:             return SteamUserStats()->StoreStats();
 93:         }
 94:     }
 95: 
 96:     if (trace_all || trace_achievement)
 97:         ffnx_error("%s - Have not received a callback from Steam, thus, cannot send achievement\n", __func__);
 98: 
 99:     return false;
100: }
101: 
102: bool SteamManager::showAchievementProgress(int achID, int progressValue, int maxValue)
103: {
104:     if (this->isInitialized)
105:     {
106:         if (trace_all || trace_achievement)
107:             ffnx_trace("%s - Show achievement progress for achievement %s (%d/%d)\n", __func__, this->getStringAchievementID(achID), progressValue, maxValue);
108: 
109:         return SteamUserStats()->IndicateAchievementProgress(this->getStringAchievementID(achID), progressValue, maxValue);
110:     }
111: 
112:     if (trace_all || trace_achievement)
113:         ffnx_error("%s - Have not received a callback from Steam, thus, cannot show progress achievement\n", __func__);
114: 
115:     return false;
116: }
117: 
118: bool SteamManager::isAchieved(int achID)
119: {
120:     return this->achievementList[achID].isAchieved;
121: }
122: 
123: const char *SteamManager::getStringAchievementID(int achID)
124: {
125:     return this->achievementList[achID].chAchID;
126: }
127: 
128: std::optional<int> SteamManager::getUserStat(const std::string &statName) {
129:     if (!this->stats.contains(statName)) {
130:        return {};
131:     }
132:     return {this->stats.at(statName)};
133: }
134: 
135: bool SteamManager::updateUserStat(const std::string &statName, int value) {
136:     if (!this->stats.contains(statName)) {
137:        return false;
138:     }
139:     ach_trace("%s - Updating steam user stat '%s' to %d\n", __func__, statName.c_str(), value);
140:     this->stats.insert_or_assign(statName, value);
141:     SteamUserStats()->SetStat(statName.c_str(), value);
142:     return SteamUserStats()->StoreStats();
143: }
144: 
145: void SteamManager::OnUserStatsReceived(UserStatsReceived_t *pCallback)
146: {
147:     if (this->appID == pCallback->m_nGameID)
148:     {
149:         if (k_EResultOK == pCallback->m_eResult)
150:         {
151:             if (trace_all || trace_achievement)
152:                 ffnx_trace("%s - received stats and achievements from Steam\n", __func__);
153:             this->isInitialized = true;
154:  
155:             // load stats (assume all stats to be integers)
156:             for (auto statName: this->stats) {
157:                 int statValue;
158:                 if (SteamUserStats()->GetStat(statName.first.c_str(), &statValue)) {
159:                     this->stats.insert_or_assign(statName.first, statValue);
160:                 }
161: 
162:                 ach_trace("%s - user stat(%s, %d)\n", __func__, statName.first.c_str(), statValue);
163:             }
164: 
165:             // load achievements
166:             for (int i = 0; i < this->nAchievements; ++i)
167:             {
168:                 achievement &ach = this->achievementList[i];
169: 
170:                 SteamUserStats()->GetAchievement(ach.chAchID, &ach.isAchieved);
171:                 _snprintf(ach.achName, sizeof(ach.achName), "%s",
172:                           SteamUserStats()->GetAchievementDisplayAttribute(ach.chAchID,
173:                                                                            "name"));
174:                 _snprintf(ach.achDescription, sizeof(ach.achDescription), "%s",
175:                           SteamUserStats()->GetAchievementDisplayAttribute(ach.chAchID,
176:                                                                            "desc"));
177: 
178:                 if (trace_all || trace_achievement)
179:                     ffnx_trace("%s - achievement data(%s, %s, %s)\n", __func__, ach.chAchID, ach.achDescription, ach.isAchieved ? "true" : "false");
180:             }
181:         }
182:         else
183:         {
184:             if (trace_all || trace_achievement)
185:                 ffnx_trace("%s - RequestStats - failed, %d\n", __func__, pCallback->m_eResult);
186:         }
187:     }
188: }
189: 
190: void SteamManager::OnUserStatsStored(UserStatsStored_t *pCallback)
191: {
192:     if (this->appID == pCallback->m_nGameID)
193:     {
194:         if (k_EResultOK == pCallback->m_eResult)
195:         {
196:             if (trace_all || trace_achievement)
197:                 ffnx_info("%s - success\n", __func__);
198:         }
199:         else
200:         {
201:             if (trace_all || trace_achievement)
202:                 ffnx_trace("%s - failed, %d\n", __func__, pCallback->m_eResult);
203:         }
204:     }
205: }
206: 
207: void SteamManager::OnAchievementStored(UserAchievementStored_t *pCallback)
208: {
209:     if (this->appID == pCallback->m_nGameID)
210:     {
211:         if (trace_all || trace_achievement)
212:             ffnx_trace("%s - Stored Achievement %s for Steam\n", __func__, pCallback->m_rgchAchievementName);
213:     }
214: }
215: 
216: // -------------------------- STEAM ACHIEVEMENTS OF FF7 ---------------------------
217: 
218: SteamAchievementsFF7::SteamAchievementsFF7()
219: {
220:     this->steamManager = std::make_unique<SteamManager>(SteamAchievementsFF7::ACHIEVEMENTS, FF7_N_ACHIEVEMENTS);
221:     this->lastSeenMovieName = INVALID_MOVIE_NAME;
222: }
223: 
224: void SteamAchievementsFF7::initStatsFromSaveFile(const savemap &savemap)
225: {
226:     this->yuffieUnlocked = this->isYuffieUnlocked(savemap.yuffie_reg_mask);
227:     this->vincentUnlocked = this->isVincentUnlocked(savemap.vincent_reg_mask);
228:     for (int i = 0; i < N_GOLD_CHOCOBO_FIRST_SLOTS + N_GOLD_CHOCOBO_LAST_SLOTS; i++)
229:     {
230:         const chocobo_slot slot = (i < N_GOLD_CHOCOBO_FIRST_SLOTS) ? savemap.chocobo_slots_first[i] : savemap.chocobo_slots_last[i - N_GOLD_CHOCOBO_FIRST_SLOTS];
231:         this->isGoldChocoboSlot[i] = slot.type == GOLD_CHOCOBO_TYPE;
232:     }
233: 
234:     this->lastSeenMovieName = INVALID_MOVIE_NAME;
235:     this->initMateriaMastered(savemap);
236: 
237:     if (trace_all || trace_achievement)
238:     {
239:         ffnx_trace("%s - init stats from save file\n", __func__);
240:         ffnx_trace("yuffie unlocked: %s\n", this->yuffieUnlocked ? "true" : "false");
241:         ffnx_trace("vincent unlocked: %s\n", this->vincentUnlocked ? "true" : "false");
242:     }
243: }
244: 
245: void SteamAchievementsFF7::initCharStatsBeforeBattle(const savemap_char characters[])
246: {
247:     if (trace_all || trace_achievement)
248:         ffnx_trace("%s - initialization of character stats before battle\n", __func__);
249: 
250:     for (int i = 0; i < N_CHARACTERS; i++)
251:     {
252:         this->previousUsedLimitNumber[i] = characters[i].used_n_limit_1_1;
253:         for (int j = 0; j < N_EQUIP_MATERIA_PER_CHARACTER; j++)
254:         {
255:             uint32_t materia = characters[i].equipped_materia[j];
256:             this->equipMasteredMateriaCharacter[i][j] = isMateriaMastered(materia);
257:         }
258: 
259:         if (i == CAIT_SITH_INDEX)
260:             this->caitsithNumKills = characters[i].num_kills;
261:     }
262: }
263: 
264: void SteamAchievementsFF7::initMovieStats(const string movieName)
265: {
266:     if (trace_all || trace_achievement)
267:         ffnx_trace("%s - the movie name initialized is: %s\n", __func__, movieName.c_str());
268: 
269:     this->lastSeenMovieName = std::move(movieName);
270: }
271: 
272: void SteamAchievementsFF7::initMateriaMastered(const savemap &savemap)
273: {
274:     // Called only when loading a save file
275:     // Assumption: there is no mastered materia obtained through new character joining the team
276: 
277:     if (trace_all || trace_achievement)
278:         ffnx_trace("%s - init materia mastered\n", __func__);
279: 
280:     std::fill_n(this->masteredMateria.data(), N_TYPE_MATERIA, false);
281: 
282:     for (int i = 0; i < N_UNKNOWN_MATERIA; i++)
283:     {
284:         this->masteredMateria[this->unknownMateriaList[i]] = true;
285:     }
286: 
287:     for (int i = 0; i < N_MATERIA_SLOT; i++)
288:     {
289:         uint32_t materia = savemap.materia[i];
290:         if (this->isMateriaMastered(materia))
291:         {
292:             masteredMateria[materia & 0xFF] = true;
293:         }
294:     }
295:     if (this->isYuffieUnlocked(savemap.yuffie_reg_mask))
296:     {
297:         for (int i = 0; i < N_STOLEN_MATERIA_SLOT; i++)
298:         {
299:             uint32_t materia = savemap.stolen_materia[i];
300:             if (this->isMateriaMastered(materia))
301:             {
302:                 masteredMateria[materia & 0xFF] = true;
303:             }
304:         }
305:     }
306: 
307:     for (int i = 0; i < N_CHARACTERS; i++)
308:     {
309:         for (int j = 0; j < N_EQUIP_MATERIA_PER_CHARACTER; j++)
310:         {
311:             uint32_t materia = savemap.chars[i].equipped_materia[j];
312:             if (this->isMateriaMastered(materia))
313:             {
314:                 masteredMateria[materia & 0xFF] = true;
315:             }
316:         }
317:     }
318: }
319: 
320: bool SteamAchievementsFF7::isMateriaMastered(uint32_t materia)
321: {
322:     byte materiaId = materia & 0xFF;
323:     uint32_t materiaAp = materia >> 8;
324:     if (std::find(unmasterableMateriaList.begin(), unmasterableMateriaList.end(), materiaId) != unmasterableMateriaList.end())
325:         return true;
326:     return materiaId != MATERIA_EMPTY_SLOT && materiaAp == MATERIA_AP_MASTERED;
327: }
328: 
329: bool SteamAchievementsFF7::isAllMateriaMastered(const std::array<bool, N_TYPE_MATERIA> masteredMateriaList)
330: {
331:     bool allMastered = true;
332:     for (int i = 0; i < N_TYPE_MATERIA; i++)
333:     {
334:         if (!masteredMateriaList[i])
335:             return false;
336:     }
337:     return allMastered;
338: }
339: 
340: bool SteamAchievementsFF7::isYuffieUnlocked(char yuffieRegular)
341: {
342:     // took from https://github.com/sithlord48/ff7tk/blob/master/src/data/FF7Save.cpp#L4777
343:     return yuffieRegular & (1 << 0);
344: }
345: 
346: bool SteamAchievementsFF7::isVincentUnlocked(char vincentRegular)
347: {
348:     // took from https://github.com/sithlord48/ff7tk/blob/master/src/data/FF7Save.cpp#L4799
349:     return vincentRegular & (1 << 2);
350: }
351: 
352: bool SteamAchievementsFF7::isEndingMovie()
353: {
354:     return this->lastSeenMovieName == END_OF_GAME_MOVIE_NAME;
355: }
356: 
357: void SteamAchievementsFF7::unlockBattleWonAchievement(WORD formationID)
358: {
359:     if (trace_all || trace_achievement)
360:         ffnx_trace("%s - unlock achievement for winning battle (formation ID: %d)\n", __func__, formationID);
361: 
362:     if (!this->steamManager->isAchieved(WON_1ST_BATTLE))
363:         this->steamManager->setAchievement(WON_1ST_BATTLE);
364: 
365:     if (!this->steamManager->isAchieved(BEAT_DIAMOND_WEAPON) && formationID == DIAMOND_WEAPON_FORMATION_ID)
366:     {
367:         this->steamManager->setAchievement(BEAT_DIAMOND_WEAPON);
368:     }
369: 
370:     if (!this->steamManager->isAchieved(BEAT_RUBY_WEAPON)
371:         && find(begin(RUBY_WEAPON_FORMATION_ID), end(RUBY_WEAPON_FORMATION_ID), formationID) != end(RUBY_WEAPON_FORMATION_ID))
372:     {
373:         this->steamManager->setAchievement(BEAT_RUBY_WEAPON);
374:     }
375: 
376:     if (!this->steamManager->isAchieved(BEAT_EMERALD_WEAPON)
377:         && find(begin(EMERALD_WEAPON_FORMATION_ID), end(EMERALD_WEAPON_FORMATION_ID), formationID) != end(EMERALD_WEAPON_FORMATION_ID))
378:     {
379:         this->steamManager->setAchievement(BEAT_EMERALD_WEAPON);
380:     }
381: 
382:     if (!this->steamManager->isAchieved(BEAT_ULTIMATE_WEAPON) && formationID == ULTIMATE_WEAPON_FORMATION_ID)
383:     {
384:         this->steamManager->setAchievement(BEAT_ULTIMATE_WEAPON);
385:     }
386: }
387: 
388: void SteamAchievementsFF7::unlockGilAchievement(uint32_t gilAmount)
389: {
390:     if (trace_all || trace_achievement)
391:         ffnx_trace("%s - trying to unlock achievement for gil (amount: %d)\n", __func__, gilAmount);
392: 
393:     if (!this->steamManager->isAchieved(GET_99999999_GILS) && gilAmount >= GIL_ACHIEVEMENT_VALUE)
394:         this->steamManager->setAchievement(GET_99999999_GILS);
395: }
396: 
397: void SteamAchievementsFF7::unlockCharacterLevelAchievement(const savemap_char characters[])
398: {
399:     if (trace_all || trace_achievement)
400:         ffnx_trace("%s - trying to unlock achievement for character level\n", __func__);
401: 
402:     if (this->steamManager->isAchieved(GET_LEVEL_99_WITH_A_CHAR))
403:         return;
404: 
405:     for (int i = 0; i < N_CHARACTERS; i++)
406:     {
407:         if (characters[i].level == TOP_LEVEL_CHARACTER)
408:         {
409:             this->steamManager->setAchievement(GET_LEVEL_99_WITH_A_CHAR);
410:             return;
411:         }
412:     }
413: }
414: 
415: void SteamAchievementsFF7::unlockBattleSquareAchievement(WORD battleLocationID)
416: {
417:     if (trace_all || trace_achievement)
418:         ffnx_trace("%s - trying to unlock achievement for fighting in battle square (battle location id: 0x%04x)\n", __func__, battleLocationID);
419: 
420:     if (!this->steamManager->isAchieved(FIGHT_IN_BATTLE_SQUARE) && battleLocationID == BATTLE_SQUARE_LOCATION_ID)
421:     {
422:         this->steamManager->setAchievement(FIGHT_IN_BATTLE_SQUARE);
423:     }
424: }
425: 
426: void SteamAchievementsFF7::unlockGotMateriaAchievement(byte materiaID)
427: {
428:     using namespace std;
429:     if (trace_all || trace_achievement)
430:         ffnx_trace("%s - trying to unlock achievement for getting materia (got materia ID: 0x%02x)\n", __func__, materiaID);
431: 
432:     if (find(begin(unmasterableMateriaList), end(unmasterableMateriaList), materiaID) != end(unmasterableMateriaList))
433:     {
434:         int nMateriaMastered = accumulate(begin(masteredMateria), end(masteredMateria), 0);
435:         if (!this->masteredMateria[materiaID])
436:             this->steamManager->showAchievementProgress(MASTER_ALL_MATERIA, nMateriaMastered + 1 - sizeof(unknownMateriaList),
437:                                                         N_TYPE_MATERIA - sizeof(unknownMateriaList));
438:         this->masteredMateria[materiaID] = true;
439: 
440:         if (!this->steamManager->isAchieved(LEVEL_UP_MATERIA_LVL5))
441:             this->steamManager->setAchievement(LEVEL_UP_MATERIA_LVL5);
442: 
443:         if (!this->steamManager->isAchieved(MASTER_ALL_MATERIA) && this->isAllMateriaMastered(masteredMateria))
444:             this->steamManager->setAchievement(MASTER_ALL_MATERIA);
445:     }
446: 
447:     if (materiaID == BAHAMUT_ZERO_MATERIA_ID)
448:     {
449:         this->steamManager->setAchievement(GET_MATERIA_BAHAMUT_ZERO);
450:     }
451:     else if (materiaID == KOTR_MATERIA_ID)
452:     {
453:         this->steamManager->setAchievement(GET_MATERIA_KOTR);
454:     }
455: }
456: 
457: void SteamAchievementsFF7::unlockMasterMateriaAchievement(const savemap_char characters[])
458: {
459:     using namespace std;
460:     if (trace_all || trace_achievement)
461:         ffnx_trace("%s - trying to unlock achievement for mastering materia\n", __func__);
462: 
463:     int nMateriaMastered = accumulate(begin(masteredMateria), end(masteredMateria), 0);
464:     int nNewMateriaMastered = 0;
465:     for (int i = 0; i < N_CHARACTERS; i++)
466:     {
467:         if (characters[i].id == SEPHIROTH_ID || characters[i].id == YOUNG_CLOUD_ID)
468:             continue;
469: 
470:         for (int j = 0; j < N_EQUIP_MATERIA_PER_CHARACTER; j++)
471:         {
472:             uint32_t materia = characters[i].equipped_materia[j];
473:             if (this->isMateriaMastered(materia) && !this->equipMasteredMateriaCharacter[i][j])
474:             {
475:                 if (trace_all || trace_achievement)
476:                     ffnx_trace("%s - trying to unlock achievement for mastering materia (materia id: 0x%02x)\n", __func__, materia & 0xFF);
477: 
478:                 nNewMateriaMastered += (!this->masteredMateria[materia & 0xFF]) ? 1 : 0;
479:                 this->masteredMateria[materia & 0xFF] = true;
480:                 this->equipMasteredMateriaCharacter[i][j] = true;
481:                 if (!this->steamManager->isAchieved(LEVEL_UP_MATERIA_LVL5))
482:                     this->steamManager->setAchievement(LEVEL_UP_MATERIA_LVL5);
483:             }
484:         }
485:     }
486:     if (nNewMateriaMastered > 0)
487:     {
488:         this->steamManager->showAchievementProgress(MASTER_ALL_MATERIA, nMateriaMastered + nNewMateriaMastered - sizeof(unknownMateriaList),
489:                                                     N_TYPE_MATERIA - sizeof(unknownMateriaList));
490:         if (!this->steamManager->isAchieved(MASTER_ALL_MATERIA) && this->isAllMateriaMastered(masteredMateria))
491:             this->steamManager->setAchievement(MASTER_ALL_MATERIA);
492:     }
493: }
494: 
495: void SteamAchievementsFF7::unlockFirstLimitBreakAchievement(short commandID, short actionID)
496: {
497:     if (trace_all || trace_achievement)
498:         ffnx_trace("%s - trying to unlock achievement for first limit break achievement(command_id: 0x%02x, action_id: 0x%02x)\n", __func__, commandID, actionID);
499: 
500:     if (commandID == LIMIT_COMMAND_INDEX)
501:     {
502:         auto item = find(firstLimitBreakActionID.begin(), firstLimitBreakActionID.end(), actionID);
503:         if (item != firstLimitBreakActionID.end())
504:         {
505:             if (!this->steamManager->isAchieved(USE_1ST_LIMIT_CLOUD + distance(firstLimitBreakActionID.cbegin(), item)))
506:             {
507:                 this->steamManager->setAchievement(USE_1ST_LIMIT_CLOUD + distance(firstLimitBreakActionID.cbegin(), item));
508:             }
509:         }
510:     }
511: }
512: 
513: void SteamAchievementsFF7::unlockCaitSithLastLimitBreakAchievement(const savemap_char characters[])
514: {
515:     if (trace_all || trace_achievement)
516:         ffnx_trace("%s - trying to unlock achievement for cait sith last limit break achievement (num_kills: %d)\n", __func__, characters[CAIT_SITH_INDEX].num_kills);
517: 
518:     if (!this->steamManager->isAchieved(GET_FOURTH_CAITSITH_LAST_LIMIT) && this->caitsithNumKills >= 0 && this->caitsithNumKills < 40
519:         && characters[CAIT_SITH_INDEX].num_kills >= 40)
520:     {
521:         this->steamManager->setAchievement(GET_FOURTH_CAITSITH_LAST_LIMIT);
522:     }
523:     this->caitsithNumKills = -1;
524: }
525: 
526: void SteamAchievementsFF7::unlockLastLimitBreakAchievement(WORD usedItemID)
527: {
528:     using namespace std;
529:     if (trace_all || trace_achievement)
530:         ffnx_trace("%s - trying to unlock achievement for last limit break achievement (used item: 0x%07x)\n", __func__, usedItemID);
531: 
532:     auto item = find(limitBreakItemsID.begin(), limitBreakItemsID.end(), usedItemID);
533:     if (item != limitBreakItemsID.end())
534:     {
535:         if (!this->steamManager->isAchieved(GET_FOURTH_CLOUD_LAST_LIMIT + distance(limitBreakItemsID.cbegin(), item)))
536:         {
537:             this->steamManager->setAchievement(GET_FOURTH_CLOUD_LAST_LIMIT + distance(limitBreakItemsID.cbegin(), item));
538:         }
539:     }
540: }
541: 
542: void SteamAchievementsFF7::unlockGoldChocoboAchievement(const chocobo_slot firstFourSlots[], const chocobo_slot lastTwoSlots[])
543: {
544:     if (trace_all || trace_achievement)
545:         ffnx_trace("%s - trying to unlock gold chocobo achievement\n", __func__);
546: 
547:     if (this->steamManager->isAchieved(GET_GOLD_CHOCOBO))
548:         return;
549: 
550:     for (int i = 0; i < N_GOLD_CHOCOBO_FIRST_SLOTS + N_GOLD_CHOCOBO_LAST_SLOTS; i++)
551:     {
552:         const chocobo_slot slot = (i < N_GOLD_CHOCOBO_FIRST_SLOTS) ? firstFourSlots[i] : lastTwoSlots[i - N_GOLD_CHOCOBO_FIRST_SLOTS];
553:         if (!this->isGoldChocoboSlot[i] && slot.type == GOLD_CHOCOBO_TYPE)
554:         {
555:             this->steamManager->setAchievement(GET_GOLD_CHOCOBO);
556:         }
557:     }
558: }
559: 
560: void SteamAchievementsFF7::unlockGameProgressAchievement()
561: {
562:     if (trace_all || trace_achievement)
563:         ffnx_trace("%s - trying to unlock game progress achievement (movieName: %s)\n", __func__, this->lastSeenMovieName.c_str());
564: 
565:     if (!(this->steamManager->isAchieved(DEATH_OF_AERITH)) && this->lastSeenMovieName == DEATH_OF_AERITH_MOVIE_NAME)
566:         this->steamManager->setAchievement(DEATH_OF_AERITH);
567: 
568:     if (!(this->steamManager->isAchieved(SHINRA_ANNIHILATED)) && this->lastSeenMovieName == SHINRA_ANNIHILATED_MOVIE_NAME)
569:         this->steamManager->setAchievement(SHINRA_ANNIHILATED);
570: 
571:     if (!(this->steamManager->isAchieved(END_OF_GAME)) && this->lastSeenMovieName == END_OF_GAME_MOVIE_NAME)
572:         this->steamManager->setAchievement(END_OF_GAME);
573: }
574: 
575: void SteamAchievementsFF7::unlockYuffieAndVincentAchievement(unsigned char yuffieRegMask, unsigned char vincentRegMask)
576: {
577:     if (trace_all || trace_achievement)
578:         ffnx_trace("%s - trying to unlock yuffie and vincent achievement (yuffie_reg: 0x%02x, vincent_reg: 0x%02x)\n",
579:                    __func__, yuffieRegMask, vincentRegMask);
580: 
581:     if (!this->steamManager->isAchieved(GET_YUFFIE_IN_TEAM) && !this->yuffieUnlocked && this->isYuffieUnlocked(yuffieRegMask))
582:     {
583:         this->steamManager->setAchievement(GET_YUFFIE_IN_TEAM);
584:     }
585: 
586:     if (!this->steamManager->isAchieved(GET_VINCENT_IN_TEAM) && !this->vincentUnlocked && this->isVincentUnlocked(vincentRegMask))
587:     {
588:         this->steamManager->setAchievement(GET_VINCENT_IN_TEAM);
589:     }
590: }
591: 
592: // -------------------------- STEAM ACHIEVEMENTS OF FF8 ---------------------------
593: 
594: SteamAchievementsFF8::SteamAchievementsFF8()
595: {
596:     std::vector<std::string> statsNameVec = { ENEMY_KILLED_STAT_NAME, DRAW_MAGIC_STAT_NAME, STOCK_MAGIC_STAT_NAME, WON_CARDGAME_STAT_NAME };
597:     this->steamManager = std::make_unique<SteamManager>(SteamAchievementsFF8::ACHIEVEMENTS, FF8_N_ACHIEVEMENTS, statsNameVec);
598: }
599: 
600: void SteamAchievementsFF8::initOwnedTripleTriadRareCards(const savemap_ff8_triple_triad &tt_data)
601: {
602:     ach_trace("%s - init owned triple triad rare cards\n", __func__);
603: 
604:     for (int i = 0; i < this->prevOwnedRareCards.size(); i++) {
605:         bool owned = tt_data.card_locations[i] == SQUALL_CARD_LOCATION && (tt_data.cards_rare[i / 8] & (1 << i % 8)) > 0;
606:         this->prevOwnedRareCards[i] = owned;
607:     }
608: }
609: 
610: void SteamAchievementsFF8::initPreviousWeaponIdBeforeUpgrade(byte charId, byte weaponId)
611: {
612:     ach_trace("%s - init previous weapon id before upgrade (char id: %d, weapon id: %d)\n", __func__, charId, weaponId);
613:     this->prevWeaponUpgradeData.char_id = charId;
614:     this->prevWeaponUpgradeData.prev_weapon_id = weaponId;
615: }
616: 
617: void SteamAchievementsFF8::initStatCharIdUnderStatCompute(byte statCharId) {
618:     ach_trace("%s - init stat char id before max hp computation (char id: %d)\n", __func__, statCharId);
619:     this->statCharId = statCharId;
620: }
621: 
622: byte SteamAchievementsFF8::getStatCharIdUnderStatCompute() {
623:     return this->statCharId;
624: }
625: 
626: void SteamAchievementsFF8::unlockPlayTripleTriadAchievement()
627: {
628:     ach_trace("%s - trying to unlock play card game first time achievement\n", __func__);
629: 
630:     if (!(this->steamManager->isAchieved(CARDGAME_FIRST_TIME)))
631:         this->steamManager->setAchievement(CARDGAME_FIRST_TIME);
632: }
633: 
634: void SteamAchievementsFF8::unlockLoserTripleTriadAchievement(const savemap_ff8_triple_triad &tt_data)
635: {
636:     ach_trace("%s - trying to unlock loser card game achievement\n", __func__);
637: 
638:     for (int i = 0; i < this->prevOwnedRareCards.size(); i++) {
639:         bool owned = tt_data.card_locations[i] == SQUALL_CARD_LOCATION && (tt_data.cards_rare[i / 8] & (1 << i % 8)) > 0;
640:         if (!owned && this->prevOwnedRareCards[i]) {
641:             ach_trace("%s - LOSER achievement unlocked due to card id '%d' lost\n", __func__, i);
642: 
643:             if (!(this->steamManager->isAchieved(LOSER)))
644:                 this->steamManager->setAchievement(LOSER);
645:         }
646:     }
647: }
648: 
649: void SteamAchievementsFF8::increaseCardWinsAndUnlockProfessionalAchievement()
650: {
651:     this->increaseUserStatAndTryUnlockAchievement(PROFESSIONAL, WON_CARDGAME_STAT_NAME, 100);
652: }
653: 
654: void SteamAchievementsFF8::unlockCollectorTripleTriadAchievement(const savemap_ff8_triple_triad &tt_data)
655: {
656:     ach_trace("%s - trying to unlock collector card game achievement\n", __func__);
657:     if (this->steamManager->isAchieved(COLLECT_ALL_CARDS)) {
658:       return;
659:     }
660: 
661:     int ownedNormalCards = 0;
662:     for (int i = 0; i < N_CARDS; i++) {
663:         bool owned = tt_data.cards[i] > 0x80;
664:         ownedNormalCards += owned;
665:     }
666: 
667:     int ownedRareCards = 0;
668:     for (int i = 0; i < N_RARE_CARDS; i++) {
669:         bool owned = tt_data.card_locations[i] == SQUALL_CARD_LOCATION && (tt_data.cards_rare[i / 8] & (1 << i % 8)) > 0;
670:         ownedRareCards += owned;
671:     }
672: 
673:     ach_trace("%s - collector report: normal cards %d/%d, rare cards %d/%d\n", __func__,
674:               ownedNormalCards, N_CARDS, ownedRareCards, N_RARE_CARDS);
675: 
676:     if (ownedNormalCards + ownedRareCards == N_CARDS + N_RARE_CARDS) {
677:         this->steamManager->setAchievement(COLLECT_ALL_CARDS);
678:     }
679: }
680: 
681: void SteamAchievementsFF8::unlockGuardianForceAchievement(int gf_idx)
682: {
683:     if (gf_idx < 0 || gf_idx > 15) {
684:       ach_trace("%s - invalid guardian force idx (gf id: %d)\n", __func__, gf_idx);
685:       return;
686:     }
687: 
688:     ach_trace("%s - trying to unlock guardian force achievement (gf id: %d)\n", __func__, gf_idx);
689:     if (!(this->steamManager->isAchieved(gfIndexToAchMap[gf_idx])))
690:         this->steamManager->setAchievement(gfIndexToAchMap[gf_idx]);
691: }
692: 
693: void SteamAchievementsFF8::unlockTopSeedRankAchievement(WORD seed_exp)
694: {
695:     ach_trace("%s - trying to unlock seed rank A achivement (seed exp: %d)\n", __func__, seed_exp);
696:     if (seed_exp >= MAX_SEED_EXP) {
697:         if (!(this->steamManager->isAchieved(REACH_SEED_RANK_A)))
698:             this->steamManager->setAchievement(REACH_SEED_RANK_A);
699:     }
700: }
701: 
702: void SteamAchievementsFF8::unlockUpgradeWeaponAchievement(const savemap_ff8 &savemap)
703: {
704:     if (this->prevWeaponUpgradeData.char_id == 0xFF || this->prevWeaponUpgradeData.prev_weapon_id == 0xFF) {
705:         ach_trace("%s - invalid previous weapon id before upgrade (char id: %d, weapon id: %d)\n",
706:                   __func__, this->prevWeaponUpgradeData.char_id, this->prevWeaponUpgradeData.prev_weapon_id);
707:     }
708: 
709:     byte weaponId = savemap.chars[this->prevWeaponUpgradeData.char_id].weapon_id;
710:     ach_trace("%s - trying to unlock handyman achivement (new weapon id: %d, old weapon id: %d)\n",
711:               __func__, weaponId, this->prevWeaponUpgradeData.prev_weapon_id);
712:     if (weaponId > this->prevWeaponUpgradeData.prev_weapon_id) {
713:         if (!(this->steamManager->isAchieved(UPGRADE_WEAPON_FIRST_TIME)))
714:             this->steamManager->setAchievement(UPGRADE_WEAPON_FIRST_TIME);
715:     }
716: 
717:     this->prevWeaponUpgradeData.char_id = 0xFF;
718:     this->prevWeaponUpgradeData.prev_weapon_id = 0xFF;
719: }
720: 
721: void SteamAchievementsFF8::unlockMaxHpAchievement(int max_hp)
722: {
723:     ach_trace("%s - trying to unlock maximum HP achivement (max hp: %d)\n", __func__, max_hp);
724: 
725:     if (max_hp >= MAX_HP)
726:     {
727:         if (!(this->steamManager->isAchieved(REACH_MAX_HP)))
728:             this->steamManager->setAchievement(REACH_MAX_HP);
729:     }
730:     this->statCharId = 0xFF;
731: }
732: 
733: void SteamAchievementsFF8::unlockMaxGilAchievement(uint32_t gil)
734: {
735:     ach_trace("%s - trying to unlock maximum gil achivement (gil: %d)\n", __func__, gil);
736: 
737:     if (gil >= MAX_GIL)
738:     {
739:         if (!(this->steamManager->isAchieved(REACH_MAX_GIL)))
740:             this->steamManager->setAchievement(REACH_MAX_GIL);
741:     }
742: }
743: 
744: void SteamAchievementsFF8::unlockTopLevelAchievement(int level)
745: {
746:     ach_trace("%s - trying to unlock top level achivement (level: %d)\n", __func__, level);
747: 
748:     if (level == MAX_LEVEL)
749:     {
750:         if (!(this->steamManager->isAchieved(REACH_LEVEL_100)))
751:             this->steamManager->setAchievement(REACH_LEVEL_100);
752:     }
753: }
754: 
755: void SteamAchievementsFF8::increaseKillsAndTryUnlockAchievement()
756: {
757:     if (this->steamManager->isAchieved(TOTAL_KILLS_10000))
758:     {
759:         return;
760:     }
761: 
762:     auto opt_kills = this->steamManager->getUserStat(ENEMY_KILLED_STAT_NAME);
763:     if (!opt_kills.has_value()) {
764:         ffnx_error("%s - failed to get %s stat\n", __func__, ENEMY_KILLED_STAT_NAME.c_str());
765:         return;
766:     }
767: 
768:     int new_kills = opt_kills.value() + 1;
769:     ach_trace("%s - trying to unlock kills achivements (kills: %d)\n", __func__, new_kills);
770:     this->steamManager->updateUserStat(ENEMY_KILLED_STAT_NAME, new_kills);
771: 
772:     if (new_kills >= 100)
773:     {
774:         if (!(this->steamManager->isAchieved(TOTAL_KILLS_100)))
775:             this->steamManager->setAchievement(TOTAL_KILLS_100);
776:     }
777:     else if (new_kills % 10 == 0) {
778:         this->steamManager->showAchievementProgress(TOTAL_KILLS_100, new_kills, 100);
779:     }
780: 
781:     if (new_kills >= 1000)
782:     {
783:         if (!(this->steamManager->isAchieved(TOTAL_KILLS_1000)))
784:             this->steamManager->setAchievement(TOTAL_KILLS_1000);
785:     }
786:     else if (new_kills > 100 && new_kills % 100 == 0) {
787:         this->steamManager->showAchievementProgress(TOTAL_KILLS_1000, new_kills, 1000);
788:     }
789: 
790:     if (new_kills >= 10000)
791:     {
792:         this->steamManager->setAchievement(TOTAL_KILLS_10000);
793:     }
794: }
795: 
796: void SteamAchievementsFF8::increaseMagicStockAndTryUnlockAchievement()
797: {
798:     this->increaseUserStatAndTryUnlockAchievement(DRAW_100_MAGIC, STOCK_MAGIC_STAT_NAME, 100, true);
799: }
800: 
801: void SteamAchievementsFF8::increaseMagicDrawsAndTryUnlockAchievement()
802: {
803:     this->increaseUserStatAndTryUnlockAchievement(MAGIC_FINDER, DRAW_MAGIC_STAT_NAME, 100, true);
804: }
805: 
806: void SteamAchievementsFF8::unlockTimberManiacsAchievement(WORD timber_maniacs_bitmap)
807: {
808:     ach_trace("%s - trying to unlock timber maniacs achivement (timber maniacs: 0x%x)\n", __func__, timber_maniacs_bitmap);
809:     if ((timber_maniacs_bitmap & 0x3FFF) == 0x3FFE || (timber_maniacs_bitmap & 0x3FFF) == 0x3FFD) {
810:         if (!(this->steamManager->isAchieved(TIMBER_MANIACS)))
811:             this->steamManager->setAchievement(TIMBER_MANIACS);
812:     }
813: }
814: 
815: void SteamAchievementsFF8::unlockFirstSalaryAchievement()
816: {
817:     ach_trace("%s - trying to unlock first salary achivement\n", __func__);
818: 
819:     if (!(this->steamManager->isAchieved(SEED_FIRST_SALARY)))
820:         this->steamManager->setAchievement(SEED_FIRST_SALARY);
821: }
822: 
823: void SteamAchievementsFF8::unlockQuistisLimitBreaksAchievement(WORD quistis_lb_bitmap)
824: {
825:     ach_trace("%s - trying to unlock quistis limit breaks achivement (quistis lb: 0x%x)\n", __func__, quistis_lb_bitmap);
826: 
827:     if (quistis_lb_bitmap == 0xFFFF)
828:     {
829:         if (!(this->steamManager->isAchieved(BLUE_MAGICS)))
830:             this->steamManager->setAchievement(BLUE_MAGICS);
831:     }
832: }
833: 
834: void SteamAchievementsFF8::unlockRinoaLimitBreaksAchievement(byte rinoa_completed_lb)
835: {
836:     ach_trace("%s - trying to unlock rinoa limit breaks achivement (completed lb: 0x%x)\n", __func__, rinoa_completed_lb);
837: 
838:     if (rinoa_completed_lb == 0xFF)
839:     {
840:         if (!(this->steamManager->isAchieved(DOG_TRICKS)))
841:             this->steamManager->setAchievement(DOG_TRICKS);
842:     }
843: }
844: 
845: void SteamAchievementsFF8::unlockOmegaDestroyedAchievement()
846: {
847:     ach_trace("%s - trying to unlock omega destroyed achivement\n", __func__);
848: 
849:     if (!(this->steamManager->isAchieved(BEAT_OMEGA_WEAPON)))
850:         this->steamManager->setAchievement(BEAT_OMEGA_WEAPON);
851: }
852: 
853: void SteamAchievementsFF8::unlockPupuQuestAchievement(byte pupu_encounter_bitmap)
854: {
855:     ach_trace("%s - trying to unlock UFO achivement (pupu encounter var: 0x%x)\n", __func__, pupu_encounter_bitmap);
856: 
857:     if ((pupu_encounter_bitmap & 0xFC) == 0xFC)
858:     {
859:         if (!(this->steamManager->isAchieved(UFO)))
860:             this->steamManager->setAchievement(UFO);
861:     }
862: }
863: 
864: void SteamAchievementsFF8::unlockChocoLootAchievement()
865: {
866:     ach_trace("%s - trying to unlock choco loot achivement\n", __func__);
867: 
868:     if (!(this->steamManager->isAchieved(CHOCORPG_FIRST_ITEM)))
869:         this->steamManager->setAchievement(CHOCORPG_FIRST_ITEM);
870: }
871: 
872: void SteamAchievementsFF8::unlockTopLevelBokoAchievement(byte boko_lvl)
873: {
874:     ach_trace("%s - trying to unlock top level boko achivement (boko lvl: %d)\n", __func__, boko_lvl);
875: 
876:     if (boko_lvl >= 100) {
877:         if (!(this->steamManager->isAchieved(CHICOBO_TOP_LEVEL)))
878:             this->steamManager->setAchievement(CHICOBO_TOP_LEVEL);
879:     }
880: }
881: 
882: void SteamAchievementsFF8::unlockChocoboAchievement()
883: {
884:     ach_trace("%s - trying to unlock chocobo achivement\n", __func__);
885: 
886:     if (!(this->steamManager->isAchieved(CAPTURE_CHOCOBO_FIRST_TIME)))
887:         this->steamManager->setAchievement(CAPTURE_CHOCOBO_FIRST_TIME);
888: }
889: 
890: void SteamAchievementsFF8::unlockCardClubMasterAchievement(const savemap_ff8_field &savemap_field)
891: {
892:     bool cc_king_unlocked = savemap_field.tt_cc_quest_1 & 0b10000;
893:     ach_trace("%s - trying to unlock card club master achivement (cc king unlocked: %d)\n", __func__, cc_king_unlocked);
894: 
895:     if (cc_king_unlocked) {
896:         if (!(this->steamManager->isAchieved(CARDS_CLUB_MASTER)))
897:             this->steamManager->setAchievement(CARDS_CLUB_MASTER);
898:     }
899: }
900: 
901: void SteamAchievementsFF8::unlockObelLakeQuestAchievement()
902: {
903:     ach_trace("%s - trying to unlock obel lake quest achivement\n", __func__);
904: 
905:     if (!(this->steamManager->isAchieved(OBEL_LAKE_SECRET)))
906:         this->steamManager->setAchievement(OBEL_LAKE_SECRET);
907: }
908: 
909: void SteamAchievementsFF8::unlockRagnarokAchievement()
910: {
911:     ach_trace("%s - trying to unlock ragnarok achivement\n", __func__);
912: 
913:     if (!(this->steamManager->isAchieved(FOUND_RAGNAROK)))
914:         this->steamManager->setAchievement(FOUND_RAGNAROK);
915: }
916: 
917: void SteamAchievementsFF8::unlockEndOfGameAchievement(int squall_lvl)
918: {
919:     ach_trace("%s - trying to unlock end of game achivement (squall_lvl: %d)\n", __func__, squall_lvl);
920: 
921:     if (!(this->steamManager->isAchieved(FINISH_THE_GAME)))
922:         this->steamManager->setAchievement(FINISH_THE_GAME);
923: 
924:     if (squall_lvl == 7) {
925:         if (!(this->steamManager->isAchieved(FINISH_THE_GAME_INITIAL_LEVEL)))
926:             this->steamManager->setAchievement(FINISH_THE_GAME_INITIAL_LEVEL);
927:     }
928: }
929: 
930: void SteamAchievementsFF8::unlockMagazineAddictAchievement(const savemap_ff8_items &items)
931: {
932:     std::unordered_set<uint8_t> magazines_found = {};
933:     for (int i = 0; i < ITEM_SLOTS; i++) {
934:         if (itemIsMagazine(items.items[i].item_id) && items.items[i].item_quantity > 0) {
935:             magazines_found.insert(items.items[i].item_id);
936:         }
937:     }
938:     ach_trace("%s - trying to unlock magazine addict achivement (magazines found: %d)\n", __func__, magazines_found.size());
939:  
940:     if (magazines_found.size() >= MAGAZINES_TO_COLLECT) {
941:         if (!(this->steamManager->isAchieved(MAGAZINES_ADDICT)))
942:             this->steamManager->setAchievement(MAGAZINES_ADDICT);
943:     }
944: }
945: 
946: bool SteamAchievementsFF8::itemIsMagazine(uint8_t item_id) {
947:     return item_id >= 0xB1 && item_id <= 0xC6;
948: }
949: 
950: // Private methods
951: void SteamAchievementsFF8::increaseUserStatAndTryUnlockAchievement(Achievements achId, const std::string &statName, int achValue, bool showAchievementProgress)
952: {
953:     if (this->steamManager->isAchieved(achId))
954:     {
955:         return;
956:     }
957: 
958:     auto opt_stat_value = this->steamManager->getUserStat(statName);
959:     if (!opt_stat_value.has_value()) {
960:         ffnx_error("%s - failed to get %s stat\n", __func__, statName.c_str());
961:         return;
962:     }
963: 
964:     int new_stat_value = opt_stat_value.value() + 1;
965:     ach_trace("%s - trying to unlock %s achivement (stat value: %d)\n", __func__, this->ACHIEVEMENTS[achId].chAchID, new_stat_value);
966:     this->steamManager->updateUserStat(statName, new_stat_value);
967: 
968:     if (new_stat_value >= achValue)
969:     {
970:         this->steamManager->setAchievement(achId);
971:     }
972:     else if (showAchievementProgress && new_stat_value % (achValue / 10) == 0)
973:     {
974:         this->steamManager->showAchievementProgress(achId, new_stat_value, achValue);
975:     }
976: }
</file>

<file path="src/achievement.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <memory>
 26: #include <optional>
 27: #include <steamworkssdk/steam_api.h>
 28: #include <array>
 29: #include <unordered_map>
 30: #include <vector>
 31: #include <string>
 32: #include <windows.h>
 33: 
 34: #include "ff7.h"
 35: #include "ff8/save_data.h"
 36: 
 37: #define _ACH_ID(id)           \
 38:     {                         \
 39:         id, #id, "", "", 0, 0 \
 40:     }
 41: 
 42: struct achievement
 43: {
 44:     int achID;
 45:     const char *chAchID;
 46:     char achName[128];
 47:     char achDescription[256];
 48:     bool isAchieved;
 49:     int iconImage;
 50: };
 51: 
 52: class SteamManager
 53: {
 54: private:
 55:     int appID;                                          // Our current AppID
 56:     std::vector<achievement> achievementList;           // Achievements data
 57:     int nAchievements;                                  // The number of Achievements
 58:     bool isInitialized;                                 // Have we called Request stats and received the callback?
 59:     std::unordered_map<std::string, int> stats;         // Steam stats used by the game
 60: 
 61: public:
 62:     SteamManager(const achievement *achievements, int nAchievements, std::vector<std::string> statsNameVec = {});
 63:     ~SteamManager() = default;
 64: 
 65:     bool requestStats();
 66:     bool showAchievementProgress(int achID, int progressValue, int maxValue);
 67:     bool setAchievement(int achID);
 68:     bool isAchieved(int achID);
 69:     const char *getStringAchievementID(int achID);
 70:     std::optional<int> getUserStat(const std::string &statName);
 71:     bool updateUserStat(const std::string &statName, int value);
 72: 
 73:     STEAM_CALLBACK(SteamManager, OnUserStatsReceived, UserStatsReceived_t, callbackUserStatsReceived);
 74:     STEAM_CALLBACK(SteamManager, OnUserStatsStored, UserStatsStored_t, callbackUserStatsStored);
 75:     STEAM_CALLBACK(SteamManager, OnAchievementStored, UserAchievementStored_t, callbackAchievementStored);
 76: };
 77: 
 78: class SteamAchievementsFF7
 79: {
 80: private:
 81:     enum Achievements
 82:     {
 83:         DEATH_OF_AERITH = 0,
 84:         SHINRA_ANNIHILATED = 1,
 85:         END_OF_GAME = 2,
 86:         GET_99999999_GILS = 3,
 87:         GET_LEVEL_99_WITH_A_CHAR = 4,
 88:         GET_FOURTH_CLOUD_LAST_LIMIT = 5,
 89:         GET_FOURTH_BARRET_LAST_LIMIT = 6,
 90:         GET_FOURTH_TIFA_LAST_LIMIT = 7,
 91:         GET_FOURTH_AERITH_LAST_LIMIT = 8,
 92:         GET_FOURTH_REDXIII_LAST_LIMIT = 9,
 93:         GET_FOURTH_YUFFIE_LAST_LIMIT = 10,
 94:         GET_FOURTH_CAITSITH_LAST_LIMIT = 11,
 95:         GET_FOURTH_VINCENT_LAST_LIMIT = 12,
 96:         GET_FOURTH_CID_LAST_LIMIT = 13,
 97:         GET_MATERIA_KOTR = 14,
 98:         LEVEL_UP_MATERIA_LVL5 = 15,
 99:         GET_MATERIA_BAHAMUT_ZERO = 16,
100:         BEAT_ULTIMATE_WEAPON = 17,
101:         BEAT_DIAMOND_WEAPON = 18,
102:         BEAT_RUBY_WEAPON = 19,
103:         BEAT_EMERALD_WEAPON = 20,
104:         GET_VINCENT_IN_TEAM = 21,
105:         GET_YUFFIE_IN_TEAM = 22,
106:         MASTER_ALL_MATERIA = 23,
107:         GET_GOLD_CHOCOBO = 24,
108:         WON_1ST_BATTLE = 25,
109:         USE_1ST_LIMIT_CLOUD = 26,
110:         USE_1ST_LIMIT_BARRET = 27,
111:         USE_1ST_LIMIT_TIFA = 28,
112:         USE_1ST_LIMIT_AERITH = 29,
113:         USE_1ST_LIMIT_REDXIII = 30,
114:         USE_1ST_LIMIT_YUFFIE = 31,
115:         USE_1ST_LIMIT_CAITSITH = 32,
116:         USE_1ST_LIMIT_VINCENT = 33,
117:         USE_1ST_LIMIT_CID = 34,
118:         FIGHT_IN_BATTLE_SQUARE = 35
119:     };
120: 
121:     static inline const achievement ACHIEVEMENTS[] = {
122:         _ACH_ID(DEATH_OF_AERITH),
123:         _ACH_ID(SHINRA_ANNIHILATED),
124:         _ACH_ID(END_OF_GAME),
125:         _ACH_ID(GET_99999999_GILS),
126:         _ACH_ID(GET_LEVEL_99_WITH_A_CHAR),
127:         _ACH_ID(GET_FOURTH_CLOUD_LAST_LIMIT),
128:         _ACH_ID(GET_FOURTH_BARRET_LAST_LIMIT),
129:         _ACH_ID(GET_FOURTH_TIFA_LAST_LIMIT),
130:         _ACH_ID(GET_FOURTH_AERITH_LAST_LIMIT),
131:         _ACH_ID(GET_FOURTH_REDXIII_LAST_LIMIT),
132:         _ACH_ID(GET_FOURTH_YUFFIE_LAST_LIMIT),
133:         _ACH_ID(GET_FOURTH_CAITSITH_LAST_LIMIT),
134:         _ACH_ID(GET_FOURTH_VINCENT_LAST_LIMIT),
135:         _ACH_ID(GET_FOURTH_CID_LAST_LIMIT),
136:         _ACH_ID(GET_MATERIA_KOTR),
137:         _ACH_ID(LEVEL_UP_MATERIA_LVL5),
138:         _ACH_ID(GET_MATERIA_BAHAMUT_ZERO),
139:         _ACH_ID(BEAT_ULTIMATE_WEAPON),
140:         _ACH_ID(BEAT_DIAMOND_WEAPON),
141:         _ACH_ID(BEAT_RUBY_WEAPON),
142:         _ACH_ID(BEAT_EMERALD_WEAPON),
143:         _ACH_ID(GET_VINCENT_IN_TEAM),
144:         _ACH_ID(GET_YUFFIE_IN_TEAM),
145:         _ACH_ID(MASTER_ALL_MATERIA),
146:         _ACH_ID(GET_GOLD_CHOCOBO),
147:         _ACH_ID(WON_1ST_BATTLE),
148:         _ACH_ID(USE_1ST_LIMIT_CLOUD),
149:         _ACH_ID(USE_1ST_LIMIT_BARRET),
150:         _ACH_ID(USE_1ST_LIMIT_TIFA),
151:         _ACH_ID(USE_1ST_LIMIT_AERITH),
152:         _ACH_ID(USE_1ST_LIMIT_REDXIII),
153:         _ACH_ID(USE_1ST_LIMIT_YUFFIE),
154:         _ACH_ID(USE_1ST_LIMIT_CAITSITH),
155:         _ACH_ID(USE_1ST_LIMIT_VINCENT),
156:         _ACH_ID(USE_1ST_LIMIT_CID),
157:         _ACH_ID(FIGHT_IN_BATTLE_SQUARE),
158:     };
159: 
160:     static inline constexpr int FF7_N_ACHIEVEMENTS = 36;
161: 
162:     static inline constexpr int N_CHARACTERS = 9;
163:     static inline constexpr int N_TYPE_MATERIA = 91;
164:     static inline constexpr int N_UNKNOWN_MATERIA = 8;
165: 
166:     static inline constexpr int N_MATERIA_SLOT = 200;
167:     static inline constexpr int N_STOLEN_MATERIA_SLOT = 48;
168:     static inline constexpr int N_EQUIP_MATERIA_PER_CHARACTER = 16;
169:     static inline constexpr int GIL_ACHIEVEMENT_VALUE = 99999999;
170:     static inline constexpr int TOP_LEVEL_CHARACTER = 99;
171: 
172:     static inline constexpr int YUFFIE_INDEX = 5;
173:     static inline constexpr int CAIT_SITH_INDEX = 6;
174:     static inline constexpr int VINCENT_INDEX = 7;
175:     static inline constexpr byte YOUNG_CLOUD_ID = 0x09;
176:     static inline constexpr byte SEPHIROTH_ID = 0x0A;
177: 
178:     static inline constexpr byte MATERIA_EMPTY_SLOT = 0xFF;
179:     static inline constexpr int MATERIA_AP_MASTERED = 0xFFFFFF;
180:     static inline constexpr byte BAHAMUT_ZERO_MATERIA_ID = 0x58;
181:     static inline constexpr byte KOTR_MATERIA_ID = 0x59;
182: 
183:     // took from here https://finalfantasy.fandom.com/wiki/Diamond_Weapon_(Final_Fantasy_VII_boss)#Formations
184:     static inline constexpr WORD DIAMOND_WEAPON_FORMATION_ID = 980;
185:     static inline constexpr std::array<WORD, 2> RUBY_WEAPON_FORMATION_ID = {982, 983};
186:     static inline constexpr std::array<WORD, 3> EMERALD_WEAPON_FORMATION_ID = {984, 985, 986};
187:     static inline constexpr WORD ULTIMATE_WEAPON_FORMATION_ID = 287;
188:     static inline constexpr WORD BATTLE_SQUARE_LOCATION_ID = 0x0025;
189: 
190:     static inline constexpr byte GOLD_CHOCOBO_TYPE = 0x04;
191:     static inline constexpr int N_GOLD_CHOCOBO_FIRST_SLOTS = 4;
192:     static inline constexpr int N_GOLD_CHOCOBO_LAST_SLOTS = 2;
193: 
194:     static inline const std::string DEATH_OF_AERITH_MOVIE_NAME = "funeral";
195:     static inline const std::string SHINRA_ANNIHILATED_MOVIE_NAME = "hwindjet";
196:     static inline const std::string END_OF_GAME_MOVIE_NAME = "ending2";
197:     static inline const std::string INVALID_MOVIE_NAME = "";
198: 
199:     static inline constexpr std::array<byte, N_UNKNOWN_MATERIA> unknownMateriaList = {0x16, 0x26, 0x2D, 0x2E, 0x2F, 0x3F, 0x42, 0x43};
200:     static inline constexpr std::array<byte, 4> unmasterableMateriaList = {0x11, 0x30, 0x49, 0x5A};
201: 
202:     static inline constexpr byte LIMIT_COMMAND_INDEX = 0x14;
203:     static inline constexpr std::array<byte, N_CHARACTERS> firstLimitBreakActionID = {0x00, 0x07, 0x62, 0x0E, 0x23, 0x31, 0x2A, 0x2D, 0x1C};
204:     static inline constexpr std::array<WORD, N_CHARACTERS> limitBreakItemsID = {0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0xFFFF, 0x5D, 0x5E};
205: 
206:     std::unique_ptr<SteamManager> steamManager;
207: 
208:     std::array<WORD, N_CHARACTERS> previousUsedLimitNumber;
209:     std::array<std::array<bool, N_EQUIP_MATERIA_PER_CHARACTER>, N_CHARACTERS> equipMasteredMateriaCharacter;
210:     std::array<bool, N_TYPE_MATERIA> masteredMateria;
211:     std::array<bool, N_GOLD_CHOCOBO_FIRST_SLOTS + N_GOLD_CHOCOBO_LAST_SLOTS> isGoldChocoboSlot;
212:     bool yuffieUnlocked;
213:     bool vincentUnlocked;
214:     int caitsithNumKills;
215:     std::string lastSeenMovieName;
216: 
217:     bool isYuffieUnlocked(char yuffieRegular);
218:     bool isVincentUnlocked(char vincentRegular);
219:     void initMateriaMastered(const savemap &savemap);
220:     bool isMateriaMastered(uint32_t materia);
221:     bool isAllMateriaMastered(const std::array<bool, N_TYPE_MATERIA> masteredMateriaList);
222: 
223: public:
224:     SteamAchievementsFF7();
225:     ~SteamAchievementsFF7() = default;
226: 
227:     void initStatsFromSaveFile(const savemap &savemap);
228:     void initCharStatsBeforeBattle(const savemap_char characters[]);
229:     void initMovieStats(const std::string movieName);
230: 
231:     bool isEndingMovie();
232: 
233:     void unlockBattleWonAchievement(WORD formationID);
234:     void unlockGilAchievement(uint32_t gilAmount);
235:     void unlockCharacterLevelAchievement(const savemap_char characters[]);
236:     void unlockBattleSquareAchievement(WORD battleLocationID);
237:     void unlockGotMateriaAchievement(byte materiaID);
238:     void unlockMasterMateriaAchievement(const savemap_char characters[]);
239:     void unlockFirstLimitBreakAchievement(short characterIndex, short actionIndex);
240:     void unlockLastLimitBreakAchievement(WORD itemID);
241:     void unlockCaitSithLastLimitBreakAchievement(const savemap_char characters[]);
242:     void unlockGoldChocoboAchievement(const chocobo_slot firstFourSlots[], const chocobo_slot lastTwoSlots[]);
243:     void unlockGameProgressAchievement();
244:     void unlockYuffieAndVincentAchievement(unsigned char yuffieRegMask, unsigned char vincentRegMask);
245: };
246: 
247: class SteamAchievementsFF8
248: {
249: private:
250:     enum Achievements
251:     {
252:         UNLOCK_GF_QUEZACOTL = 0,
253:         UNLOCK_GF_SHIVA = 1,
254:         UNLOCK_GF_IFRIT = 2,
255:         UNLOCK_GF_SIREN = 3,
256:         UNLOCK_GF_BROTHERS = 4,
257:         UNLOCK_GF_DIABLOS = 5,
258:         UNLOCK_GF_CARBUNCLE = 6,
259:         UNLOCK_GF_LEVIATHAN = 7,
260:         UNLOCK_GF_PANDEMONA = 8,
261:         UNLOCK_GF_CERBERUS = 9,
262:         UNLOCK_GF_ALEXANDER = 10,
263:         UNLOCK_GF_DOOMTRAIN = 11,
264:         UNLOCK_GF_BAHAMUT = 12,
265:         UNLOCK_GF_CACTUAR = 13,
266:         UNLOCK_GF_TONBERRY = 14,
267:         UNLOCK_GF_EDEN = 15,
268:         DRAW_100_MAGIC = 16,
269:         REACH_SEED_RANK_A = 17,
270:         CARDGAME_FIRST_TIME = 18,
271:         COLLECT_ALL_CARDS = 19,
272:         UPGRADE_WEAPON_FIRST_TIME = 20,
273:         REACH_MAX_HP = 21,
274:         REACH_MAX_GIL = 22,
275:         REACH_LEVEL_100 = 23,
276:         FINISH_THE_GAME = 24,
277:         FINISH_THE_GAME_INITIAL_LEVEL = 25,
278:         CAPTURE_CHOCOBO_FIRST_TIME = 26,
279:         FOUND_RAGNAROK = 27,
280:         SEED_FIRST_SALARY = 28,
281:         CHOCORPG_FIRST_ITEM = 29,
282:         BEAT_OMEGA_WEAPON = 30,
283:         OBEL_LAKE_SECRET = 31,
284:         UFO = 32,
285:         CARDS_CLUB_MASTER = 33,
286:         LOSER = 34,
287:         PROFESSIONAL = 35,
288:         TIMBER_MANIACS = 36,
289:         MAGAZINES_ADDICT = 37,
290:         MAGIC_FINDER = 38,
291:         CHICOBO_TOP_LEVEL = 39,
292:         BLUE_MAGICS = 40,
293:         DOG_TRICKS = 41,
294:         TOTAL_KILLS_100 = 42,
295:         TOTAL_KILLS_1000 = 43,
296:         TOTAL_KILLS_10000 = 44
297:     };
298: 
299:     static inline const achievement ACHIEVEMENTS[] = {
300:         _ACH_ID(UNLOCK_GF_QUEZACOTL),
301:         _ACH_ID(UNLOCK_GF_SHIVA),
302:         _ACH_ID(UNLOCK_GF_IFRIT),
303:         _ACH_ID(UNLOCK_GF_SIREN),
304:         _ACH_ID(UNLOCK_GF_BROTHERS),
305:         _ACH_ID(UNLOCK_GF_DIABLOS),
306:         _ACH_ID(UNLOCK_GF_CARBUNCLE),
307:         _ACH_ID(UNLOCK_GF_LEVIATHAN),
308:         _ACH_ID(UNLOCK_GF_PANDEMONA),
309:         _ACH_ID(UNLOCK_GF_CERBERUS),
310:         _ACH_ID(UNLOCK_GF_ALEXANDER),
311:         _ACH_ID(UNLOCK_GF_DOOMTRAIN),
312:         _ACH_ID(UNLOCK_GF_BAHAMUT),
313:         _ACH_ID(UNLOCK_GF_CACTUAR),
314:         _ACH_ID(UNLOCK_GF_TONBERRY),
315:         _ACH_ID(UNLOCK_GF_EDEN),
316:         _ACH_ID(DRAW_100_MAGIC),
317:         _ACH_ID(REACH_SEED_RANK_A),
318:         _ACH_ID(CARDGAME_FIRST_TIME),
319:         _ACH_ID(COLLECT_ALL_CARDS),
320:         _ACH_ID(UPGRADE_WEAPON_FIRST_TIME),
321:         _ACH_ID(REACH_MAX_HP),
322:         _ACH_ID(REACH_MAX_GIL),
323:         _ACH_ID(REACH_LEVEL_100),
324:         _ACH_ID(FINISH_THE_GAME),
325:         _ACH_ID(FINISH_THE_GAME_INITIAL_LEVEL),
326:         _ACH_ID(CAPTURE_CHOCOBO_FIRST_TIME),
327:         _ACH_ID(FOUND_RAGNAROK),
328:         _ACH_ID(SEED_FIRST_SALARY),
329:         _ACH_ID(CHOCORPG_FIRST_ITEM),
330:         _ACH_ID(BEAT_OMEGA_WEAPON),
331:         _ACH_ID(OBEL_LAKE_SECRET),
332:         _ACH_ID(UFO),
333:         _ACH_ID(CARDS_CLUB_MASTER),
334:         _ACH_ID(LOSER),
335:         _ACH_ID(PROFESSIONAL),
336:         _ACH_ID(TIMBER_MANIACS),
337:         _ACH_ID(MAGAZINES_ADDICT),
338:         _ACH_ID(MAGIC_FINDER),
339:         _ACH_ID(CHICOBO_TOP_LEVEL),
340:         _ACH_ID(BLUE_MAGICS),
341:         _ACH_ID(DOG_TRICKS),
342:         _ACH_ID(TOTAL_KILLS_100),
343:         _ACH_ID(TOTAL_KILLS_1000),
344:         _ACH_ID(TOTAL_KILLS_10000),
345:     };
346: 
347:     struct upgrade_data {
348:         byte char_id = 0xFF;
349:         byte prev_weapon_id = 0xFF;
350:     };
351: 
352:     static inline const Achievements gfIndexToAchMap[16] = {
353:         UNLOCK_GF_QUEZACOTL,
354:         UNLOCK_GF_SHIVA,
355:         UNLOCK_GF_IFRIT,
356:         UNLOCK_GF_SIREN,
357:         UNLOCK_GF_BROTHERS,
358:         UNLOCK_GF_DIABLOS,
359:         UNLOCK_GF_CARBUNCLE,
360:         UNLOCK_GF_LEVIATHAN,
361:         UNLOCK_GF_PANDEMONA,
362:         UNLOCK_GF_CERBERUS,
363:         UNLOCK_GF_ALEXANDER,
364:         UNLOCK_GF_DOOMTRAIN,
365:         UNLOCK_GF_BAHAMUT,
366:         UNLOCK_GF_CACTUAR,
367:         UNLOCK_GF_TONBERRY,
368:         UNLOCK_GF_EDEN,
369:     };
370: 
371:     static inline constexpr int FF8_N_ACHIEVEMENTS = 45;
372: 
373:     static inline const std::string ENEMY_KILLED_STAT_NAME = "nmy_kill";
374:     static inline const std::string DRAW_MAGIC_STAT_NAME = "mag_draw";
375:     static inline const std::string STOCK_MAGIC_STAT_NAME = "mag_stck";
376:     static inline const std::string WON_CARDGAME_STAT_NAME = "won_card";
377: 
378:     static inline constexpr int N_CARDS = 77;
379:     static inline constexpr int N_RARE_CARDS = 33;
380:     static inline constexpr byte SQUALL_CARD_LOCATION = 0xF0;
381: 
382:     static inline constexpr WORD MAX_SEED_EXP = 3100;
383:     static inline constexpr int MAX_HP = 9999;
384:     static inline constexpr uint32_t MAX_GIL = 99999999;
385:     static inline constexpr int MAX_LEVEL = 100;
386:     static inline constexpr int ITEM_SLOTS = 198;
387:     static inline constexpr int MAGAZINES_TO_COLLECT = 22;
388: 
389:     std::unique_ptr<SteamManager> steamManager;
390:     std::array<bool, N_RARE_CARDS> prevOwnedRareCards;
391:     upgrade_data prevWeaponUpgradeData;
392:     byte statCharId = 0xFF;
393: 
394:     void increaseUserStatAndTryUnlockAchievement(Achievements achId, const std::string &statName, int achValue, bool showAchievementProgress = false);
395: 
396: public:
397:     static inline constexpr byte DIABLOS_GF_IDX = 5;
398:     static inline constexpr WORD DIABLOS_ENCOUNTER_ID = 811;
399: 
400:     SteamAchievementsFF8();
401:     ~SteamAchievementsFF8() = default;
402: 
403:     void initOwnedTripleTriadRareCards(const savemap_ff8_triple_triad &triple_triad);
404:     void initPreviousWeaponIdBeforeUpgrade(byte charId, byte weaponId);
405:     void initStatCharIdUnderStatCompute(byte statCharId);
406: 
407:     byte getStatCharIdUnderStatCompute();
408: 
409:     void unlockPlayTripleTriadAchievement();
410:     void unlockLoserTripleTriadAchievement(const savemap_ff8_triple_triad &triple_triad);
411:     void unlockCollectorTripleTriadAchievement(const savemap_ff8_triple_triad &triple_triad);
412:     void increaseCardWinsAndUnlockProfessionalAchievement();
413:     void unlockGuardianForceAchievement(int gf_idx);
414:     void unlockTopSeedRankAchievement(WORD seed_exp);
415:     void unlockUpgradeWeaponAchievement(const savemap_ff8 &savemap);
416:     void unlockMaxHpAchievement(int max_hp);
417:     void unlockMaxGilAchievement(uint32_t gil);
418:     void unlockTopLevelAchievement(int level);
419:     void increaseKillsAndTryUnlockAchievement();
420:     void increaseMagicStockAndTryUnlockAchievement();
421:     void increaseMagicDrawsAndTryUnlockAchievement();
422:     void unlockTimberManiacsAchievement(WORD timber_maniacs_bitmap);
423:     void unlockFirstSalaryAchievement();
424:     void unlockQuistisLimitBreaksAchievement(WORD quistis_lb_bitmap);
425:     void unlockOmegaDestroyedAchievement();
426:     void unlockPupuQuestAchievement(byte pupu_encounter_bitmap);
427:     void unlockChocoLootAchievement();
428:     void unlockTopLevelBokoAchievement(byte boko_lvl);
429:     void unlockRinoaLimitBreaksAchievement(byte rinoa_completed_lb);
430:     void unlockCardClubMasterAchievement(const savemap_ff8_field &savemap_field);
431:     void unlockChocoboAchievement();
432:     void unlockObelLakeQuestAchievement();
433:     void unlockRagnarokAchievement();
434:     void unlockEndOfGameAchievement(int squall_lvl);
435:     void unlockMagazineAddictAchievement(const savemap_ff8_items &items);
436: 
437:     static bool itemIsMagazine(uint8_t item_id);
438: 
439: };
440: 
441: // Global, access to Achievements object
442: extern std::unique_ptr<SteamAchievementsFF7> g_FF7SteamAchievements;
443: extern std::unique_ptr<SteamAchievementsFF8> g_FF8SteamAchievements;
</file>

<file path="src/api.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #include "api.h"
23: 
24: FFNX_API void __stdcall nxRegisterMouseListener(MouseListener* listener)
25: {
26:     mouseListeners.push_back(listener);
27: }
28: 
29: FFNX_API void __stdcall nxRegisterKeyListener(KeyListener* listener)
30: {
31:     keyListeners.push_back(listener);
32: }
</file>

<file path="src/api.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include "globals.h"
25: #include "input.h"
26: 
27: FFNX_API void __stdcall nxRegisterMouseListener(MouseListener* listener);
28: FFNX_API void __stdcall nxRegisterKeyListener(KeyListener* listener);
</file>

<file path="src/audio.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //                                                                          //
  10: //    This file is part of FFNx                                             //
  11: //                                                                          //
  12: //    FFNx is free software: you can redistribute it and/or modify          //
  13: //    it under the terms of the GNU General Public License as published by  //
  14: //    the Free Software Foundation, either version 3 of the License         //
  15: //                                                                          //
  16: //    FFNx is distributed in the hope that it will be useful,               //
  17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  19: //    GNU General Public License for more details.                          //
  20: /****************************************************************************/
  21: 
  22: #include "audio/openpsf/openpsf.h"
  23: 
  24: #include "audio.h"
  25: 
  26: #include "log.h"
  27: #include "gamehacks.h"
  28: #include "utils.h"
  29: 
  30: #if defined(__cplusplus)
  31: extern "C" {
  32: #endif
  33: 
  34: #include <libvgmstream/util/log.h>
  35: 
  36: #if defined(__cplusplus)
  37: }
  38: #endif
  39: 
  40: NxAudioEngine nxAudioEngine;
  41: 
  42: // PRIVATE
  43: 
  44: void NxAudioEngine::loadConfig()
  45: {
  46: 	char _fullpath[MAX_PATH];
  47: 
  48: 	for (int idx = NxAudioEngineLayer::NXAUDIOENGINE_SFX; idx <= NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT; idx++)
  49: 	{
  50: 		NxAudioEngineLayer type = NxAudioEngineLayer(idx);
  51: 
  52: 		switch (type)
  53: 		{
  54: 		case NxAudioEngineLayer::NXAUDIOENGINE_SFX:
  55: 			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_sfx_path.c_str());
  56: 			if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
  57: 			break;
  58: 		case NxAudioEngineLayer::NXAUDIOENGINE_MUSIC:
  59: 			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_music_path.c_str());
  60: 			if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
  61: 			break;
  62: 		case NxAudioEngineLayer::NXAUDIOENGINE_VOICE:
  63: 			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_voice_path.c_str());
  64: 			if (trace_all || trace_voice) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
  65: 			break;
  66: 		case NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT:
  67: 			sprintf(_fullpath, "%s/%s/config.toml", basedir, external_ambient_path.c_str());
  68: 			if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, _fullpath);
  69: 			break;
  70: 		}
  71: 
  72: 		try
  73: 		{
  74: 			nxAudioEngineConfig[type] = toml::parse_file(_fullpath);
  75: 		}
  76: 		catch (const toml::parse_error &err)
  77: 		{
  78: 			ffnx_warning("Parse error while opening the file %s. Will continue with the default settings.\n", _fullpath);
  79: 			ffnx_warning("%s (Line %u Column %u)\n", err.what(), err.source().begin.line, err.source().begin.column);
  80: 
  81: 			nxAudioEngineConfig[type] = toml::parse("");
  82: 		}
  83: 	}
  84: }
  85: 
  86: bool NxAudioEngine::getFilenameFullPath(char *_out, const char* _key, NxAudioEngineLayer _type)
  87: {
  88: 	std::vector<std::string> extensions;
  89: 
  90: 	switch(_type)
  91: 	{
  92: 		case NxAudioEngineLayer::NXAUDIOENGINE_SFX:
  93: 			extensions = external_sfx_ext;
  94: 			break;
  95: 		case NxAudioEngineLayer::NXAUDIOENGINE_MUSIC:
  96: 			extensions = external_music_ext;
  97: 			break;
  98: 		case NxAudioEngineLayer::NXAUDIOENGINE_VOICE:
  99: 			extensions = external_voice_ext;
 100: 			break;
 101: 		case NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT:
 102: 			extensions = external_ambient_ext;
 103: 			break;
 104: 		case NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO:
 105: 			extensions = external_movie_audio_ext;
 106: 			break;
 107: 	}
 108: 
 109: 	for (const std::string &extension: extensions) {
 110: 		switch (_type)
 111: 		{
 112: 		case NxAudioEngineLayer::NXAUDIOENGINE_SFX:
 113: 			sprintf(_out, "%s/%s/%s.%s", basedir, external_sfx_path.c_str(), _key, extension.c_str());
 114: 			break;
 115: 		case NxAudioEngineLayer::NXAUDIOENGINE_MUSIC:
 116: 			sprintf(_out, "%s/%s/%s.%s", basedir, external_music_path.c_str(), _key, extension.c_str());
 117: 			break;
 118: 		case NxAudioEngineLayer::NXAUDIOENGINE_VOICE:
 119: 			sprintf(_out, "%s/%s/%s.%s", basedir, external_voice_path.c_str(), _key, extension.c_str());
 120: 			break;
 121: 		case NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT:
 122: 			sprintf(_out, "%s/%s/%s.%s", basedir, external_ambient_path.c_str(), _key, extension.c_str());
 123: 			break;
 124: 		case NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO:
 125: 			sprintf(_out, "%s.%s", _key, extension.c_str());
 126: 			break;
 127: 		}
 128: 
 129: 		if (fileExists(_out)) {
 130: 			return true;
 131: 		}
 132: 	}
 133: 
 134: 	return false;
 135: }
 136: 
 137: bool NxAudioEngine::fileExists(const char* filename)
 138: {
 139: 	bool ret = ::fileExists(filename);
 140: 
 141: 	if (!ret && (trace_all || trace_music || trace_sfx || trace_voice || trace_ambient))
 142: 		ffnx_warning("NxAudioEngine::%s: Could not find file %s\n", __func__, filename);
 143: 
 144: 	return ret;
 145: }
 146: 
 147: // PUBLIC
 148: 
 149: bool NxAudioEngine::init()
 150: {
 151: 	if (_engine.init(SoLoud::Soloud::CLIP_ROUNDOFF, SoLoud::Soloud::AUTO, external_audio_sample_rate, SoLoud::Soloud::AUTO, external_audio_number_of_channels) == 0)
 152: 	{
 153: 		_engineInitialized = true;
 154: 
 155: 		ffnx_info("NxAudioEngine initialized: channels=%u,sample_rate=%u\n", _engine.getBackendChannels(), _engine.getBackendSamplerate());
 156: 
 157: 		// 100 -> LOG_LEVEL_ALL: https://github.com/vgmstream/vgmstream/blob/4cda04d02595b381dc8cf98ec39e771c80987d18/src/util/log.c#L20
 158: 		if (trace_all || trace_ambient || trace_sfx || trace_music || trace_voice) vgm_log_set_callback(NULL, 100, 0, NxAudioEngineVgmstreamCallback);
 159: 
 160: 		loadConfig();
 161: 
 162: 		if (!he_bios_path.empty()) {
 163: 			char fullHeBiosPath[MAX_PATH];
 164: 			sprintf(fullHeBiosPath, "%s/%s", basedir, he_bios_path.c_str());
 165: 
 166: 			if (!Psf::initialize_psx_core(fullHeBiosPath)) {
 167: 				ffnx_error("NxAudioEngine::%s couldn't load %s, please verify 'he_bios_path' or comment it\n", __func__, he_bios_path.c_str());
 168: 			}
 169: 			else {
 170: 				_openpsf_loaded = true;
 171: 				ffnx_info("NxAudioEngine::%s OpenPSF music plugin loaded using %s\n", __func__, he_bios_path.c_str());
 172: 			}
 173: 		}
 174: 
 175: 		for (int channel = 0; channel < _sfxTotalChannels; channel++) _sfxChannels[channel] = NxAudioEngineSFX();
 176: 
 177: 		return true;
 178: 	}
 179: 
 180: 	return false;
 181: }
 182: 
 183: void NxAudioEngine::flush()
 184: {
 185: 	_engine.stopAll();
 186: 
 187: 	for (int channel = 0; channel < 2; channel++)
 188: 	{
 189: 		_musics[channel] = NxAudioEngineMusic();
 190: 	}
 191: 	_musicStack = std::stack<NxAudioEngineMusic>();
 192: 
 193: 	for (int channel = 0; channel < _sfxTotalChannels; channel++)
 194: 	{
 195: 		_sfxChannels[channel] = NxAudioEngineSFX();
 196: 	}
 197: 
 198: 	for (int slot = 0; slot < _voiceMaxSlots; slot++)
 199: 	{
 200: 		_currentVoice[slot] = NxAudioEngineVoice();
 201: 	}
 202: 
 203: 	_currentAmbient = NxAudioEngineAmbient();
 204: 
 205: 	for (int slot = 0; slot < _movieAudioMaxSlots; slot++)
 206: 	{
 207: 		_currentMovieAudio[slot] = NxAudioEngineMovieAudio();
 208: 	}
 209: 
 210: 	_currentStream = NxAudioEngineStreamAudio();
 211: }
 212: 
 213: void NxAudioEngine::cleanup()
 214: {
 215: 	_engine.deinit();
 216: }
 217: 
 218: // SFX
 219: SoLoud::VGMStream* NxAudioEngine::loadSFX(std::string id, bool loop)
 220: {
 221: 	if (_engineInitialized)
 222: 	{
 223: 		char filename[MAX_PATH];
 224: 
 225: 		bool exists = getFilenameFullPath(filename, id.c_str(), NxAudioEngineLayer::NXAUDIOENGINE_SFX);
 226: 
 227: 		if (exists)
 228: 		{
 229: 			auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_SFX][id];
 230: 
 231: 			if (node)
 232: 			{
 233: 				int shouldLoop = node["loop"].value_or(-1);
 234: 
 235: 				// Force loop if requested in the config
 236: 				if (shouldLoop != -1) loop = shouldLoop;
 237: 			}
 238: 
 239: 			if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: filename=%s,loop=%d\n", __func__, filename, loop);
 240: 
 241: 			SoLoud::VGMStream* sfx = new SoLoud::VGMStream();
 242: 
 243: 			sfx->setLooping(loop);
 244: 
 245: 			SoLoud::result res = sfx->load(filename);
 246: 			if (res != SoLoud::SO_NO_ERROR) {
 247: 				ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
 248: 				delete sfx;
 249: 				return nullptr;
 250: 			}
 251: 
 252: 			return sfx;
 253: 		}
 254: 	}
 255: 
 256: 	return nullptr;
 257: }
 258: 
 259: int NxAudioEngine::getSFXIdFromChannel(int channel)
 260: {
 261: 	return _sfxChannels[channel].game_id;
 262: }
 263: 
 264: void NxAudioEngine::unloadSFX(int id)
 265: {
 266: 	if (_sfxEffectsHandler.count(id) > 0)
 267: 	{
 268: 		if (_sfxEffectsHandler[id] != nullptr)
 269: 		{
 270: 			delete _sfxEffectsHandler[id];
 271: 
 272: 			_sfxEffectsHandler.erase(id);
 273: 		}
 274: 	}
 275: }
 276: 
 277: void NxAudioEngine::unloadSFXChannel(int channel)
 278: {
 279: 	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: channel=%d\n", __func__, channel);
 280: 
 281: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 282: 
 283: 	if (options->stream != nullptr)
 284: 	{
 285: 		delete options->stream;
 286: 
 287: 		options->stream = nullptr;
 288: 	}
 289: }
 290: 
 291: bool NxAudioEngine::playSFX(const char* name, int id, int channel, float panning, bool loop, float volume)
 292: {
 293: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 294: 	int _curId = id;
 295: 	bool skipPlay = false;
 296: 	std::string _id(name);
 297: 
 298: 	// If channel is known to be reusable
 299: 	if (channel <= _sfxReusableChannels)
 300: 	{
 301: 		// Stop the current channel is already used and the track to be played is different that the one currently playing
 302: 		if (options->stream != nullptr && options->id != id)
 303: 		{
 304: 			stopSFX(channel);
 305: 			unloadSFXChannel(channel);
 306: 		}
 307: 		// If the engine is asking us to play again the same id on the same channel, and is a looping effect...
 308: 		else if (options->stream != nullptr && options->id == id && loop)
 309: 		{
 310: 			// ...simply skip it since it's already playing
 311: 			skipPlay = true;
 312: 		}
 313: 	}
 314: 	// If channel is known to lazy unload what is currently playing, save the handler for later
 315: 	else if (std::find(_sfxLazyUnloadChannels.begin(), _sfxLazyUnloadChannels.end(), channel) != _sfxLazyUnloadChannels.end())
 316: 	{
 317: 		_sfxEffectsHandler[options->game_id] = options->stream;
 318: 
 319: 		// invalidate the old channel stream in order to continue loading this new ID
 320: 		options->stream = nullptr;
 321: 	}
 322: 	// Otherwise just unload the channel and allow to load a new track immediately
 323: 	else if (channel <= _sfxTotalChannels)
 324: 	{
 325: 		unloadSFXChannel(channel);
 326: 	}
 327: 
 328: 	// Reset state
 329: 	options->volume = volume;
 330: 
 331: 	auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_SFX][name];
 332: 	if (node)
 333: 	{
 334: 		// Shuffle SFX playback, if any entry found for the current id
 335: 		toml::array *shuffleIds = node["shuffle"].as_array();
 336: 		if (shuffleIds && !shuffleIds->empty() && shuffleIds->is_homogeneous(toml::node_type::integer))
 337: 		{
 338: 			auto _newId = shuffleIds->get(getRandomInt(0, shuffleIds->size() - 1));
 339: 
 340: 			_curId = _newId->value_or(id);
 341: 			_id = std::to_string(_curId);
 342: 		}
 343: 
 344: 		// Sequentially playback new SFX ids, if any entry found for the current id
 345: 		toml::array *sequentialIds = node["sequential"].as_array();
 346: 		if (sequentialIds && !sequentialIds->empty() && sequentialIds->is_homogeneous(toml::node_type::integer))
 347: 		{
 348: 			if (_sfxSequentialIndexes.find(name) == _sfxSequentialIndexes.end() || _sfxSequentialIndexes[name] >= sequentialIds->size())
 349: 				_sfxSequentialIndexes[name] = 0;
 350: 
 351: 			auto _newId = sequentialIds->get(_sfxSequentialIndexes[name]);
 352: 
 353: 			_sfxSequentialIndexes[name]++;
 354: 
 355: 			_curId = _newId->value_or(id);
 356: 			_id = std::to_string(_curId);
 357: 		}
 358: 
 359: 		// Should we skip playing the track?
 360: 		toml::node *shouldSkip = node["skip"].as_boolean();
 361: 		if (shouldSkip && shouldSkip->is_boolean()) {
 362: 			skipPlay = shouldSkip->value_or(false);
 363: 		}
 364: 	}
 365: 
 366: 	// Try to load the new ID if it's not already cached
 367: 	if (options->stream == nullptr)
 368: 	{
 369: 		options->game_id = id;
 370: 		options->id = _curId;
 371: 		// Avoid loading a stream if it is meant to be skipped
 372: 		options->stream = skipPlay ? nullptr : loadSFX(_id, loop);
 373: 	}
 374: 
 375: 	if (skipPlay)
 376: 	{
 377: 		// Make the game think everything went fine but instead just be silent
 378: 		return true;
 379: 	}
 380: 
 381: 	if (external_sfx_always_centered)
 382: 	{
 383: 		panning = 0.0f;
 384: 
 385: 		if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: panning overridden because of external_sfx_always_centered\n", __func__);
 386: 	}
 387: 
 388: 	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: name=%s,id=%d,channel=%d,panning=%f,volume=%f\n", __func__, name, options->id, channel, panning, options->volume);
 389: 
 390: 	if (options->stream != nullptr)
 391: 	{
 392: 		options->handle = _engine.play(
 393: 			*options->stream,
 394: 			options->volume * getSFXMasterVolume(),
 395: 			panning
 396: 		);
 397: 
 398: 		options->loop = _engine.getLooping(options->handle);
 399: 
 400: 		return true;
 401: 	}
 402: 
 403: 	return false;
 404: }
 405: 
 406: void NxAudioEngine::stopSFX(int channel, double time)
 407: {
 408: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 409: 
 410: 	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s channel=%d\n", __func__, channel);
 411: 
 412: 	if (time > 0.0)
 413: 	{
 414: 		_engine.fadeVolume(options->handle, 0.0f, time);
 415: 		_engine.scheduleStop(options->handle, time);
 416: 	}
 417: 	else
 418: 	{
 419: 		_engine.stop(options->handle);
 420: 	}
 421: 
 422: 	options->id = 0;
 423: 	options->loop = false;
 424: 	options->volume = 1.0f;
 425: }
 426: 
 427: void NxAudioEngine::pauseSFX(int channel)
 428: {
 429: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 430: 
 431: 	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s channel=%d\n", __func__, channel);
 432: 
 433: 	_engine.setPause(options->handle, true);
 434: }
 435: 
 436: void NxAudioEngine::resumeSFX(int channel)
 437: {
 438: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 439: 
 440: 	if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s channel=%d\n", __func__, channel);
 441: 
 442: 	_engine.setPause(options->handle, false);
 443: }
 444: 
 445: bool NxAudioEngine::isSFXPlaying(int channel)
 446: {
 447: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 448: 
 449: 	return _engine.isValidVoiceHandle(options->handle) && !_engine.getPause(options->handle);
 450: }
 451: 
 452: float NxAudioEngine::getSFXMasterVolume()
 453: {
 454: 	return _sfxMasterVolume < 0.0f ? 1.0f : _sfxMasterVolume;
 455: }
 456: 
 457: void NxAudioEngine::setSFXMasterVolume(float volume, double time)
 458: {
 459: 	_sfxMasterVolume = volume;
 460: }
 461: 
 462: void NxAudioEngine::setSFXVolume(int channel, float volume, double time)
 463: {
 464: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 465: 
 466: 	options->volume = volume;
 467: 
 468: 	ffnx_trace("NxAudioEngine::%s: channel=%d,volume=%f\n", __func__, channel, volume);
 469: 
 470: 	if (time > 0.0) {
 471: 		time /= gamehacks.getCurrentSpeedhack();
 472: 		_engine.fadeVolume(options->handle, volume * getSFXMasterVolume(), time);
 473: 	}
 474: 	else {
 475: 		_engine.setVolume(options->handle, volume * getSFXMasterVolume());
 476: 	}
 477: }
 478: 
 479: void NxAudioEngine::setSFXSpeed(int channel, float speed, double time)
 480: {
 481: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 482: 
 483: 	if (time > 0.0) {
 484: 		time /= gamehacks.getCurrentSpeedhack();
 485: 		_engine.fadeRelativePlaySpeed(options->handle, speed, time);
 486: 	}
 487: 	else {
 488: 		_engine.setRelativePlaySpeed(options->handle, speed);
 489: 	}
 490: }
 491: 
 492: void NxAudioEngine::setSFXPanning(int channel, float panning, double time)
 493: {
 494: 	NxAudioEngineSFX *options = &_sfxChannels[channel - 1];
 495: 
 496: 	if (external_sfx_always_centered)
 497: 	{
 498: 		panning = 0.0f;
 499: 
 500: 		if (trace_all || trace_sfx) ffnx_trace("NxAudioEngine::%s: panning overridden because of external_sfx_always_centered\n", __func__);
 501: 	}
 502: 
 503: 	if (time > 0.0) {
 504: 		time /= gamehacks.getCurrentSpeedhack();
 505: 		_engine.fadePan(options->handle, panning, time);
 506: 	}
 507: 	else {
 508: 		_engine.setPan(options->handle, panning);
 509: 	}
 510: }
 511: 
 512: void NxAudioEngine::setSFXReusableChannels(short num)
 513: {
 514: 	_sfxReusableChannels = num;
 515: }
 516: 
 517: void NxAudioEngine::setSFXTotalChannels(short num)
 518: {
 519: 	_sfxTotalChannels = num;
 520: }
 521: 
 522: void NxAudioEngine::addSFXLazyUnloadChannel(int channel)
 523: {
 524: 	_sfxLazyUnloadChannels.push_back(channel);
 525: }
 526: 
 527: // Music
 528: bool NxAudioEngine::canPlayMusic(const char* name)
 529: {
 530: 	char filename[MAX_PATH];
 531: 
 532: 	return getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_MUSIC);
 533: }
 534: 
 535: bool NxAudioEngine::isMusicDisabled(const char* name)
 536: {
 537: 	char lowercaseName[MAX_PATH];
 538: 
 539: 	// Name to lower case
 540: 	for (int i = 0; name[i]; i++) {
 541: 		lowercaseName[i] = tolower(name[i]);
 542: 	}
 543: 
 544: 	toml::table config = nxAudioEngineConfig[NXAUDIOENGINE_MUSIC];
 545: 	std::optional<bool> disabled = config[lowercaseName]["disabled"].value<bool>();
 546: 
 547: 	return disabled.has_value() && disabled;
 548: }
 549: 
 550: void NxAudioEngine::cleanOldAudioSources()
 551: {
 552: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %d elements in the list before cleaning\n", __func__, _audioSourcesToDeleteLater.size());
 553: 
 554: 	std::list<NxAudioEngineMusicAudioSource>::iterator it = _audioSourcesToDeleteLater.begin();
 555: 	while (it != _audioSourcesToDeleteLater.end()) {
 556: 		if (!_engine.isValidVoiceHandle((*it).handle) && !_engine.isVoiceGroup((*it).handle)) {
 557: 			delete (*it).audioSource;
 558: 			it = _audioSourcesToDeleteLater.erase(it);
 559: 		}
 560: 		else {
 561: 			++it;
 562: 		}
 563: 	}
 564: 
 565: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %d elements in the list after cleaning\n", __func__, _audioSourcesToDeleteLater.size());
 566: }
 567: 
 568: SoLoud::AudioSource* NxAudioEngine::loadMusic(const char* name, bool isFullPath, const char* format, bool suppressOpeningSilence)
 569: {
 570: 	SoLoud::AudioSource* music = nullptr;
 571: 	char filename[MAX_PATH];
 572: 	bool exists = false;
 573: 
 574: 	if (isFullPath)
 575: 	{
 576: 		exists = fileExists(name);
 577: 		strcpy(filename, name);
 578: 	}
 579: 
 580: 	if (!exists)
 581: 	{
 582: 		exists = getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_MUSIC);
 583: 	}
 584: 
 585: 	if (exists)
 586: 	{
 587: 		if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s\n", __func__, filename);
 588: 
 589: 		cleanOldAudioSources();
 590: 
 591: 		if (_openpsf_loaded && SoLoud::OpenPsf::is_our_path(filename)) {
 592: 			SoLoud::OpenPsf* openpsf = new SoLoud::OpenPsf();
 593: 			music = openpsf;
 594: 
 595: 			SoLoud::result res = openpsf->load(filename, suppressOpeningSilence);
 596: 			if (res != SoLoud::SO_NO_ERROR) {
 597: 				ffnx_error("NxAudioEngine::%s: Cannot load %s with openpsf ( SoLoud error: %u )\n", __func__, filename, res);
 598: 				delete openpsf;
 599: 				music = nullptr;
 600: 			}
 601: 		}
 602: 
 603: 		if (music == nullptr) {
 604: 			SoLoud::VGMStream* vgmstream = new SoLoud::VGMStream();
 605: 			music = vgmstream;
 606: 
 607: 			SoLoud::result res = vgmstream->load(filename, format);
 608: 			if (res != SoLoud::SO_NO_ERROR) {
 609: 				ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
 610: 				delete vgmstream;
 611: 				music = nullptr;
 612: 			}
 613: 		}
 614: 	}
 615: 
 616: 	return music;
 617: }
 618: 
 619: void NxAudioEngine::overloadPlayArgumentsFromConfig(char* name, uint32_t* id, MusicOptions* musicOptions)
 620: {
 621: 	// Name to lower case
 622: 	for (int i = 0; name[i]; i++) {
 623: 		name[i] = tolower(name[i]);
 624: 	}
 625: 
 626: 	toml::table config = nxAudioEngineConfig[NXAUDIOENGINE_MUSIC];
 627: 	std::optional<SoLoud::time> offset_seconds_opt = config[name]["offset_seconds"].value<SoLoud::time>();
 628: 	std::optional<std::string> no_intro_track_opt = config[name]["no_intro_track"].value<std::string>();
 629: 	std::optional<SoLoud::time> intro_seconds_opt = config[name]["intro_seconds"].value<SoLoud::time>();
 630: 	std::optional<float> relative_speed_opt = config[name]["relative_speed"].value<float>();
 631: 
 632: 	if (offset_seconds_opt.has_value()) {
 633: 		musicOptions->offsetSeconds = *offset_seconds_opt;
 634: 	} else {
 635: 		std::optional<std::string> offset_special_opt = config[name]["offset_seconds"].value<std::string>();
 636: 
 637: 		if (offset_special_opt.has_value() && offset_special_opt->compare("sync") == 0) {
 638: 			musicOptions->sync = true;
 639: 		}
 640: 	}
 641: 
 642: 	if (musicOptions->noIntro) {
 643: 		if (no_intro_track_opt.has_value()) {
 644: 			std::string no_intro_track = *no_intro_track_opt;
 645: 			if (trace_all || trace_music) ffnx_info("%s: replaced by no intro track %s\n", __func__, no_intro_track.c_str());
 646: 
 647: 			if (!no_intro_track.empty()) {
 648: 				memcpy(name, no_intro_track.c_str(), no_intro_track.size());
 649: 				name[no_intro_track.size()] = '\0';
 650: 			}
 651: 		}
 652: 		else if (intro_seconds_opt.has_value()) {
 653: 			musicOptions->offsetSeconds = *intro_seconds_opt;
 654: 		}
 655: 		else {
 656: 			ffnx_info("%s: cannot play no intro track, please configure it in %s/config.toml\n", __func__, external_music_path.c_str());
 657: 		}
 658: 	}
 659: 
 660: 	if (relative_speed_opt.has_value() && *relative_speed_opt > 0.0f) {
 661: 		musicOptions->relativeSpeed = *relative_speed_opt;
 662: 	}
 663: 
 664: 	// Shuffle Music playback, if any entry found for the current music name
 665: 	toml::array* shuffleNames = config[name]["shuffle"].as_array();
 666: 	if (shuffleNames && !shuffleNames->empty() && shuffleNames->is_homogeneous(toml::node_type::string)) {
 667: 		std::optional<std::string> _newName = shuffleNames->get(getRandomInt(0, shuffleNames->size() - 1))->value<std::string>();
 668: 		if (_newName.has_value()) {
 669: 			memcpy(name, (*_newName).c_str(), (*_newName).size());
 670: 			name[(*_newName).size()] = '\0';
 671: 
 672: 			if (trace_all || trace_music) ffnx_info("%s: replaced by shuffle with %s\n", __func__, (*_newName).c_str());
 673: 		}
 674: 	}
 675: }
 676: 
 677: bool NxAudioEngine::playMusic(const char* name, uint32_t id, int channel, MusicOptions options)
 678: {
 679: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s (%d) on channel #%d\n", __func__, name, id, channel);
 680: 
 681: 	char overloadedName[MAX_PATH];
 682: 
 683: 	strncpy(overloadedName, name, MAX_PATH);
 684: 
 685: 	if (!options.useNameAsFullPath) {
 686: 		overloadPlayArgumentsFromConfig(overloadedName, &id, &options);
 687: 	}
 688: 	// Same music is already playing on this channel
 689: 	if (isMusicPlaying(channel) && currentMusicId(channel) == id) {
 690: 		if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: %s is already playing on channel %d\n", __func__, overloadedName, channel);
 691: 
 692: 		return false;
 693: 	}
 694: 	// Same music is paused on this channel or in backup channel
 695: 	bool restore = !_musicStack.empty() && _musicStack.top().id == id;
 696: 	if ((isChannelValid(channel) && currentMusicId(channel) == id) || restore) {
 697: 		resumeMusic(channel, options.fadetime == 0.0 ? 1.0 : options.fadetime, restore); // Slight fade
 698: 
 699: 		return true;
 700: 	}
 701: 
 702: 	SoLoud::AudioSource* audioSource = loadMusic(overloadedName, options.useNameAsFullPath, options.format, options.suppressOpeningSilence);
 703: 
 704: 	if (audioSource != nullptr) {
 705: 		// Different music is playing on this channel
 706: 		if (isChannelValid(channel)) {
 707: 			stopMusic(channel, options.fadetime == 0.0 ? 0.2 : options.fadetime);
 708: 		}
 709: 
 710: 		NxAudioEngineMusic& music = _musics[channel];
 711: 		SoLoud::time offsetSeconds = options.sync ? _musics[!channel].lastMusicOffset : options.offsetSeconds;
 712: 
 713: 		if (options.targetVolume >= 0.0f) {
 714: 			music.wantedMusicVolume = options.targetVolume;
 715: 		}
 716: 		const float initialVolume = options.fadetime > 0.0 || offsetSeconds > 0.0 ? 0.0f : music.wantedMusicVolume * _musicMasterVolume;
 717: 		music.handle = _engine.playBackground(*audioSource, initialVolume, offsetSeconds > 0.0);
 718: 		music.id = id;
 719: 		music.sync = options.sync;
 720: 
 721: 		// Keep audioSource pointer somewhere to delete it after musicHandle is stopped
 722: 		_audioSourcesToDeleteLater.push_back(NxAudioEngineMusicAudioSource(music.handle, audioSource));
 723: 
 724: 		if (offsetSeconds > 0.0) {
 725: 			if (trace_all || trace_music) ffnx_info("NxAudioEngine::%s: seek to time %fs\n", __func__, offsetSeconds);
 726: 			_engine.seek(music.handle, offsetSeconds);
 727: 			resumeMusic(channel, options.fadetime == 0.0 ? 1.0 : options.fadetime); // Slight fade
 728: 		}
 729: 		else if (options.fadetime > 0.0) {
 730: 			setMusicVolume(music.wantedMusicVolume, channel, options.fadetime);
 731: 		}
 732: 
 733: 		if (options.relativeSpeed > 0.0f && options.relativeSpeed != 1.0f) {
 734: 			setMusicSpeed(options.relativeSpeed, channel);
 735: 		}
 736: 
 737: 		return true;
 738: 	}
 739: 
 740: 	return false;
 741: }
 742: 
 743: void NxAudioEngine::playSynchronizedMusics(const std::vector<std::string>& names, uint32_t id, MusicOptions options)
 744: {
 745: 	const int channel = 0;
 746: 
 747: 	if (_musics[channel].id == id) {
 748: 		if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: id %d is already playing\n", __func__, id);
 749: 		return; // Already playing
 750: 	}
 751: 
 752: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: id %d\n", __func__, id);
 753: 
 754: 	stopMusic(options.fadetime);
 755: 
 756: 	SoLoud::handle groupHandle = _engine.createVoiceGroup();
 757: 
 758: 	if (groupHandle == 0) {
 759: 		ffnx_error("NxAudioEngine::%s: cannot allocate voice group\n", __func__);
 760: 		return;
 761: 	}
 762: 
 763: 	for (const std::string &name: names) {
 764: 		SoLoud::AudioSource* audioSource = loadMusic(name.c_str());
 765: 
 766: 		if (audioSource != nullptr) {
 767: 			SoLoud::handle musicHandle = _engine.playBackground(*audioSource, _musicMasterVolume, true);
 768: 			_engine.addVoiceToGroup(groupHandle, musicHandle);
 769: 			// Keep audioSource pointer somewhere to delete it after musicHandle is stopped
 770: 			_audioSourcesToDeleteLater.push_back(NxAudioEngineMusicAudioSource(musicHandle, audioSource));
 771: 		}
 772: 	}
 773: 
 774: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: handle=%X\n", __func__, groupHandle);
 775: 
 776: 	if (!_engine.isVoiceGroupEmpty(groupHandle)) {
 777: 		_musics[channel].handle = groupHandle;
 778: 		_musics[channel].id = id;
 779: 		// Play synchronously
 780: 		_engine.setPause(groupHandle, false);
 781: 	}
 782: 	else {
 783: 		_engine.destroyVoiceGroup(groupHandle);
 784: 	}
 785: }
 786: 
 787: void NxAudioEngine::swapChannels()
 788: {
 789: 	NxAudioEngineMusic music1 = _musics[0];
 790: 	_musics[0] = _musics[1];
 791: 	_musics[1] = music1;
 792: }
 793: 
 794: void NxAudioEngine::stopMusic(double time)
 795: {
 796: 	for (int channel = 0; channel < 2; ++channel) {
 797: 		stopMusic(channel, time);
 798: 	}
 799: }
 800: 
 801: void NxAudioEngine::stopMusic(int channel, double time)
 802: {
 803: 	NxAudioEngineMusic& music = _musics[channel];
 804: 
 805: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: channel %d, midi %d, time %f\n", __func__, channel, music.id, time);
 806: 
 807: 	if (external_music_sync) {
 808: 		music.lastMusicOffset = _engine.getStreamTime(_musics[channel].handle);
 809: 	}
 810: 
 811: 	if (time > 0.0)
 812: 	{
 813: 		time /= gamehacks.getCurrentSpeedhack();
 814: 		_engine.fadeVolume(music.handle, 0.0f, time);
 815: 		_engine.scheduleStop(music.handle, time);
 816: 		_lastVolumeFadeEndTime = _engine.mStreamTime + time;
 817: 	}
 818: 	else
 819: 	{
 820: 		_engine.stop(music.handle);
 821: 	}
 822: 
 823: 	if (_engine.isVoiceGroup(music.handle)) {
 824: 		_engine.destroyVoiceGroup(music.handle);
 825: 	}
 826: 
 827: 	music.invalidate();
 828: }
 829: 
 830: void NxAudioEngine::pauseMusic(double time)
 831: {
 832: 	for (int channel = 0; channel < 2; ++channel) {
 833: 		pauseMusic(channel, time);
 834: 	}
 835: }
 836: 
 837: void NxAudioEngine::pauseMusic(int channel, double time, bool backup)
 838: {
 839: 	NxAudioEngineMusic& music = _musics[channel];
 840: 	bool syncMusic = external_music_sync && backup && music.sync;
 841: 
 842: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: midi %d, time %f, sync %d\n", __func__, music.id, time, syncMusic);
 843: 
 844: 	if (external_music_sync) {
 845: 		music.lastMusicOffset = _engine.getStreamTime(_musics[channel].handle);
 846: 	}
 847: 
 848: 	if (time > 0.0)
 849: 	{
 850: 		time /= gamehacks.getCurrentSpeedhack();
 851: 		_engine.fadeVolume(music.handle, 0.0f, time);
 852: 		if (!syncMusic) {
 853: 			_engine.schedulePause(music.handle, time);
 854: 		}
 855: 		_lastVolumeFadeEndTime = _engine.mStreamTime + time;
 856: 	}
 857: 	else if (syncMusic)
 858: 	{
 859: 		_engine.setVolume(music.handle, 0.0f);
 860: 	}
 861: 	else
 862: 	{
 863: 		_engine.setPause(music.handle, true);
 864: 	}
 865: 
 866: 	if (backup) {
 867: 		backupMusic(channel);
 868: 	}
 869: }
 870: 
 871: void NxAudioEngine::backupMusic(int channelSource)
 872: {
 873: 	if (!isChannelValid(channelSource)) {
 874: 		return;
 875: 	}
 876: 
 877: 	NxAudioEngineMusic& music = _musics[channelSource];
 878: 
 879: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: backup music %d for later usage\n", __func__, music.id);
 880: 
 881: 	NxAudioEngineMusic backup = NxAudioEngineMusic();
 882: 	// Save for later usage
 883: 	backup.id = music.id;
 884: 	backup.handle = music.handle;
 885: 	backup.sync = music.sync;
 886: 
 887: 	_musicStack.push(backup);
 888: 
 889: 	// Invalidate the current handle
 890: 	music.invalidate();
 891: }
 892: 
 893: void NxAudioEngine::restoreMusic(int channelDest, double stopTime)
 894: {
 895: 	NxAudioEngineMusic& music = _musics[channelDest];
 896: 
 897: 	if (_musicStack.empty()) {
 898: 		return;
 899: 	}
 900: 
 901: 	stopMusic(channelDest, stopTime);
 902: 
 903: 	const NxAudioEngineMusic &backup = _musicStack.top();
 904: 
 905: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: restore music %d\n", __func__, backup.id);
 906: 
 907: 	// Restore
 908: 	music.id = backup.id;
 909: 	music.handle = backup.handle;
 910: 	music.sync = backup.sync;
 911: 
 912: 	_musicStack.pop();
 913: }
 914: 
 915: void NxAudioEngine::resumeMusic(double time)
 916: {
 917: 	for (int channel = 0; channel < 2; ++channel) {
 918: 		resumeMusic(channel, time);
 919: 	}
 920: }
 921: 
 922: void NxAudioEngine::resumeMusic(int channel, double time, bool restore)
 923: {
 924: 	if (restore) {
 925: 		restoreMusic(channel, time);
 926: 	}
 927: 
 928: 	NxAudioEngineMusic& music = _musics[channel];
 929: 
 930: 	time /= gamehacks.getCurrentSpeedhack();
 931: 
 932: 	if (trace_all || trace_music) ffnx_trace("NxAudioEngine::%s: midi %d, time %f\n", __func__, music.id, time);
 933: 
 934: 	// Play it again from where it was left off
 935: 	if (time > 0.0) {
 936: 		_engine.setVolume(music.handle, 0.0);
 937: 	}
 938: 	resetMusicVolume(channel, time);
 939: 	_engine.setPause(music.handle, false);
 940: }
 941: 
 942: bool NxAudioEngine::isChannelValid(int channel)
 943: {
 944: 	const NxAudioEngineMusic& music = _musics[channel];
 945: 
 946: 	return (_engine.isValidVoiceHandle(music.handle)
 947: 		|| _engine.isVoiceGroup(music.handle));
 948: }
 949: 
 950: bool NxAudioEngine::isMusicPlaying()
 951: {
 952: 	for (int channel = 0; channel < 2; ++channel) {
 953: 		if (isMusicPlaying(channel)) return true;
 954: 	}
 955: 
 956: 	return false;
 957: }
 958: 
 959: bool NxAudioEngine::isMusicPlaying(int channel)
 960: {
 961: 	const NxAudioEngineMusic& music = _musics[channel];
 962: 
 963: 	return isChannelValid(channel) && !_engine.getPause(music.handle);
 964: }
 965: 
 966: uint32_t NxAudioEngine::currentMusicId(int channel)
 967: {
 968: 	return isMusicPlaying(channel) ? _musics[channel].id : 0;
 969: }
 970: 
 971: void NxAudioEngine::setMusicMasterVolume(float volume, double time)
 972: {
 973: 	_previousMusicMasterVolume = _musicMasterVolume;
 974: 
 975: 	_musicMasterVolume = volume;
 976: 
 977: 	resetMusicVolume(time);
 978: }
 979: 
 980: void NxAudioEngine::restoreMusicMasterVolume(double time)
 981: {
 982: 	if (_previousMusicMasterVolume != _musicMasterVolume && _previousMusicMasterVolume >= 0.0f)
 983: 	{
 984: 		_musicMasterVolume = _previousMusicMasterVolume;
 985: 
 986: 		// Set them equally so if this API is called again, nothing will happen
 987: 		_previousMusicMasterVolume = _musicMasterVolume;
 988: 
 989: 		resetMusicVolume(time);
 990: 	}
 991: }
 992: 
 993: float NxAudioEngine::getMusicVolume(int channel)
 994: {
 995: 	return _musics[channel].wantedMusicVolume;
 996: }
 997: 
 998: bool NxAudioEngine::isMusicVolumeFadeFinished()
 999: {
1000: 	return _engine.mStreamTime >= _lastVolumeFadeEndTime;
1001: }
1002: 
1003: float NxAudioEngine::getMusicMasterVolume()
1004: {
1005: 	return _musicMasterVolume < 0.0f ? 1.0f : _musicMasterVolume;
1006: }
1007: 
1008: void NxAudioEngine::setMusicVolume(float volume, int channel, double time)
1009: {
1010: 	_musics[channel].wantedMusicVolume = volume;
1011: 
1012: 	resetMusicVolume(channel, time);
1013: }
1014: 
1015: void NxAudioEngine::resetMusicVolume(double time)
1016: {
1017: 	for (int channel = 0; channel < 2; ++channel) {
1018: 		resetMusicVolume(channel, time);
1019: 	}
1020: }
1021: 
1022: void NxAudioEngine::resetMusicVolume(int channel, double time)
1023: {
1024: 	const NxAudioEngineMusic& music = _musics[channel];
1025: 	const float volume = music.wantedMusicVolume * getMusicMasterVolume();
1026: 
1027: 	if (time > 0.0) {
1028: 		time /= gamehacks.getCurrentSpeedhack();
1029: 		_engine.fadeVolume(music.handle, volume, time);
1030: 		_lastVolumeFadeEndTime = _engine.mStreamTime + time;
1031: 	}
1032: 	else {
1033: 		_engine.setVolume(music.handle, volume);
1034: 	}
1035: }
1036: 
1037: void NxAudioEngine::setMusicSpeed(float speed, int channel)
1038: {
1039: 	_engine.setRelativePlaySpeed(_musics[channel].handle, speed);
1040: }
1041: 
1042: void NxAudioEngine::setMusicLooping(bool looping, int channel)
1043: {
1044: 	_engine.setLooping(_musics[channel].handle, looping);
1045: }
1046: 
1047: // Voice
1048: bool NxAudioEngine::canPlayVoice(const char* name)
1049: {
1050: 	char filename[MAX_PATH];
1051: 
1052: 	return getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
1053: }
1054: 
1055: bool NxAudioEngine::playVoice(const char* name, int slot, float volume, int game_moment)
1056: {
1057: 	char filename[MAX_PATH];
1058: 
1059: 	bool exists = false;
1060: 
1061: 	_currentVoice[slot].volume = volume * getVoiceMasterVolume();
1062: 
1063: 	std::string _name(name);
1064: 
1065: 	// TOML doesn't like the / char as key, replace it with - ( one of the valid accepted chars )
1066: 	replaceAll(_name, '/', '-');
1067: 
1068: 	auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_VOICE][_name];
1069: 
1070:   // Attempt to load a subnode based on the current game moment
1071:   if (game_moment > -1)
1072:   {
1073:     std::string _gamemoment("gm-" + std::to_string(game_moment));
1074:     auto subnode = node[_gamemoment];
1075:     if (subnode) node = subnode;
1076:   }
1077: 
1078: 	if (node)
1079: 	{
1080: 		// Set volume for the current track
1081: 		toml::node *trackVolume = node["volume"].as_integer();
1082: 		if (trackVolume)
1083: 		{
1084: 			_currentVoice[slot].volume = (trackVolume->value_or(100) / 100.0f) * getVoiceMasterVolume();
1085: 		}
1086: 
1087: 		// Shuffle Voice playback, if any entry found for the current id
1088: 		toml::array *shuffleNames = node["shuffle"].as_array();
1089: 		if (shuffleNames && !shuffleNames->empty() && shuffleNames->is_homogeneous(toml::node_type::string))
1090: 		{
1091: 			auto _newName = shuffleNames->get(getRandomInt(0, shuffleNames->size() - 1));
1092: 
1093: 			exists = getFilenameFullPath(filename, _newName->value_or(name), NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
1094: 		}
1095: 
1096: 		// Sequentially playback new voice items, if any entry found for the current id
1097: 		toml::array *sequentialNames = node["sequential"].as_array();
1098: 		if (sequentialNames && !sequentialNames->empty() && sequentialNames->is_homogeneous(toml::node_type::string))
1099: 		{
1100: 			if (_voiceSequentialIndexes.find(name) == _voiceSequentialIndexes.end() || _voiceSequentialIndexes[name] >= sequentialNames->size())
1101: 				_voiceSequentialIndexes[name] = 0;
1102: 
1103: 			auto _newName = sequentialNames->get(_voiceSequentialIndexes[name]);
1104: 
1105: 			_voiceSequentialIndexes[name]++;
1106: 
1107: 			exists = getFilenameFullPath(filename, _newName->value_or(name), NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
1108: 		}
1109: 	}
1110: 
1111: 	// If none of the previous configurations worked, load the default one as last tentative
1112: 	if (!exists) {
1113: 		exists = getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_VOICE);
1114: 	}
1115: 
1116: 	if (trace_all || trace_voice) ffnx_trace("NxAudioEngine::%s: slot[%d] %s exists=%d\n", __func__, slot, filename, exists);
1117: 
1118: 	if (exists)
1119: 	{
1120: 		// Stop any previously playing voice
1121: 		if (_engine.isValidVoiceHandle(_currentVoice[slot].handle))
1122: 		{
1123: 			_engine.stop(_currentVoice[slot].handle);
1124: 
1125: 			delete _currentVoice[slot].stream;
1126: 
1127: 			_currentVoice[slot].handle = NXAUDIOENGINE_INVALID_HANDLE;
1128: 		}
1129: 
1130: 		_currentVoice[slot].stream = new SoLoud::VGMStream();
1131: 
1132: 		SoLoud::result res = _currentVoice[slot].stream->load(filename);
1133: 		if (res != SoLoud::SO_NO_ERROR) {
1134: 			ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
1135: 			delete _currentVoice[slot].stream;
1136: 			return false;
1137: 		}
1138: 
1139: 		_currentVoice[slot].handle = _engine.play(*_currentVoice[slot].stream, _currentVoice[slot].volume);
1140: 
1141: 		return _engine.isValidVoiceHandle(_currentVoice[slot].handle);
1142: 	}
1143: 	else
1144: 		return false;
1145: }
1146: 
1147: void NxAudioEngine::stopVoice(int slot, double time)
1148: {
1149: 	SoLoud::handle handle = _currentVoice[slot].handle;
1150: 
1151: 	if (trace_all || trace_voice) ffnx_trace("NxAudioEngine::%s: slot=%d time=%lf handle=%X\n", __func__, slot, time, handle);
1152: 
1153: 	if (!_engine.isValidVoiceHandle(handle))
1154: 	{
1155: 		return;
1156: 	}
1157: 
1158: 	if (time > 0.0)
1159: 	{
1160: 		_engine.fadeVolume(handle, 0, time);
1161: 		_engine.scheduleStop(handle, time);
1162: 	}
1163: 	else
1164: 	{
1165: 		_engine.stop(handle);
1166: 	}
1167: }
1168: 
1169: void NxAudioEngine::pauseVoice(int slot, double time)
1170: {
1171: 	if (time > 0.0)
1172: 	{
1173: 		_engine.fadeVolume(_currentVoice[slot].handle, 0, time);
1174: 		_engine.schedulePause(_currentVoice[slot].handle, time);
1175: 	}
1176: 	else
1177: 	{
1178: 		_engine.setPause(_currentVoice[slot].handle, true);
1179: 	}
1180: }
1181: 
1182: void NxAudioEngine::resumeVoice(int slot, double time)
1183: {
1184: 	if (time > 0.0)
1185: 	{
1186: 		_engine.setPause(_currentVoice[slot].handle, false);
1187: 		_engine.fadeVolume(_currentVoice[slot].handle, _currentVoice[slot].volume, time);
1188: 	}
1189: 	else
1190: 	{
1191: 		_engine.setVolume(_currentVoice[slot].handle, _currentVoice[slot].volume);
1192: 		_engine.setPause(_currentVoice[slot].handle, false);
1193: 	}
1194: }
1195: 
1196: bool NxAudioEngine::isVoicePlaying(int slot)
1197: {
1198: 	return _engine.isValidVoiceHandle(_currentVoice[slot].handle) && !_engine.getPause(_currentVoice[slot].handle);
1199: }
1200: 
1201: void NxAudioEngine::setVoiceMaxSlots(int slot)
1202: {
1203: 	_voiceMaxSlots = slot;
1204: }
1205: 
1206: float NxAudioEngine::getVoiceMasterVolume()
1207: {
1208: 	return _voiceMasterVolume < 0.0f ? 1.0f : _voiceMasterVolume;
1209: }
1210: 
1211: void NxAudioEngine::setVoiceMasterVolume(float volume, double time)
1212: {
1213: 	_voiceMasterVolume = volume;
1214: }
1215: 
1216: // Ambient
1217: bool NxAudioEngine::canPlayAmbient(const char* name)
1218: {
1219: 	char filename[MAX_PATH];
1220: 
1221: 	return getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
1222: }
1223: 
1224: bool NxAudioEngine::playAmbient(const char* name, float volume, double time)
1225: {
1226: 	char filename[MAX_PATH];
1227: 	bool exists = false;
1228: 
1229: 	// Reset state
1230: 	_currentAmbient.fade_in = 0.0f;
1231: 	_currentAmbient.fade_out = 0.0f;
1232: 	_currentAmbient.volume = volume * getAmbientMasterVolume();
1233: 
1234: 	auto node = nxAudioEngineConfig[NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT][name];
1235: 	if (node)
1236: 	{
1237: 		// Shuffle Ambient playback, if any entry found for the current id
1238: 		toml::array *shuffleIds = node["shuffle"].as_array();
1239: 		if (shuffleIds && !shuffleIds->empty() && shuffleIds->is_homogeneous(toml::node_type::string))
1240: 		{
1241: 			auto _newName = shuffleIds->get(getRandomInt(0, shuffleIds->size() - 1));
1242: 
1243: 			exists = getFilenameFullPath(filename, _newName->value_or(""), NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
1244: 		}
1245: 
1246: 		// Sequentially playback new Ambient ids, if any entry found for the current id
1247: 		toml::array *sequentialIds = node["sequential"].as_array();
1248: 		if (sequentialIds && !sequentialIds->empty() && sequentialIds->is_homogeneous(toml::node_type::string))
1249: 		{
1250: 			// If the key doesn't exist already, add it
1251: 			if (_ambientSequentialIndexes.count(name) == 0) _ambientSequentialIndexes[name] = NULL;
1252: 
1253: 			if (_ambientSequentialIndexes.find(name) == _ambientSequentialIndexes.end() || _ambientSequentialIndexes[name] >= sequentialIds->size())
1254: 				_ambientSequentialIndexes[name] = 0;
1255: 
1256: 			auto _newName = sequentialIds->get(_ambientSequentialIndexes[name]);
1257: 
1258: 			_ambientSequentialIndexes[name]++;
1259: 
1260: 			exists = getFilenameFullPath(filename, _newName->value_or(""), NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
1261: 		}
1262: 
1263: 		// Fade In time for this track, if configured
1264: 		toml::node *fadeInTime = node["fade_in"].as_floating_point();
1265: 		if (fadeInTime)
1266: 		{
1267: 			_currentAmbient.fade_in = fadeInTime->value_or(0.0f);
1268: 
1269: 			time = _currentAmbient.fade_in;
1270: 		}
1271: 
1272: 		// Fade Out time for this track, if configured
1273: 		toml::node *fadeOutTime = node["fade_out"].as_floating_point();
1274: 		if (fadeOutTime)
1275: 		{
1276: 			_currentAmbient.fade_out = fadeOutTime->value_or(0.0f);
1277: 		}
1278: 
1279: 		// Set volume for the current ambient
1280: 		toml::node *ambientVolume = node["volume"].as_integer();
1281: 		if (ambientVolume)
1282: 		{
1283: 			_currentAmbient.volume = (ambientVolume->value_or(100) / 100.0f) * getAmbientMasterVolume();
1284: 		}
1285: 	}
1286: 
1287: 	// If none of the previous configurations worked, load the default one as last tentative
1288: 	if (!exists) {
1289: 		exists = getFilenameFullPath(filename, name, NxAudioEngineLayer::NXAUDIOENGINE_AMBIENT);
1290: 	}
1291: 
1292: 	if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: %s exists=%d handle=%X\n", __func__, filename, exists, _currentAmbient.handle);
1293: 
1294: 	if (exists)
1295: 	{
1296: 		// Stop any previously playing ambient
1297: 		if (_engine.isValidVoiceHandle(_currentAmbient.handle))
1298: 		{
1299: 			_engine.stop(_currentAmbient.handle);
1300: 
1301: 			delete _currentAmbient.stream;
1302: 
1303: 			_currentAmbient.handle = NXAUDIOENGINE_INVALID_HANDLE;
1304: 		}
1305: 
1306: 		_currentAmbient.stream = new SoLoud::VGMStream();
1307: 
1308: 		SoLoud::result res = _currentAmbient.stream->load(filename);
1309: 		if (res != SoLoud::SO_NO_ERROR) {
1310: 			ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
1311: 			delete _currentAmbient.stream;
1312: 			return false;
1313: 		}
1314: 
1315: 		_currentAmbient.handle = _engine.play(*_currentAmbient.stream, time > 0.0f ? 0.0f : _currentAmbient.volume, 0.0f, time > 0.0f);
1316: 
1317: 		if (time > 0.0f) resumeAmbient(time);
1318: 
1319: 		return _engine.isValidVoiceHandle(_currentAmbient.handle);
1320: 	}
1321: 	else
1322: 		return false;
1323: }
1324: 
1325: void NxAudioEngine::stopAmbient(double time)
1326: {
1327: 	if (_currentAmbient.fade_out > 0.0f)
1328: 	{
1329: 		time = _currentAmbient.fade_out;
1330: 
1331: 		if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f ( overridden through config.toml )\n", __func__, time);
1332: 	}
1333: 	else if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f\n", __func__, time);
1334: 
1335: 	if (time > 0.0)
1336: 	{
1337: 		_engine.fadeVolume(_currentAmbient.handle, 0, time);
1338: 		_engine.scheduleStop(_currentAmbient.handle, time);
1339: 	}
1340: 	else
1341: 	{
1342: 		_engine.stop(_currentAmbient.handle);
1343: 	}
1344: }
1345: 
1346: void NxAudioEngine::pauseAmbient(double time)
1347: {
1348: 	if (_currentAmbient.fade_out > 0.0f)
1349: 	{
1350: 		time = _currentAmbient.fade_out;
1351: 
1352: 		if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f ( overridden through config.toml )\n", __func__, time);
1353: 	}
1354: 	else if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f\n", __func__, time);
1355: 
1356: 	if (time > 0.0)
1357: 	{
1358: 		_engine.fadeVolume(_currentAmbient.handle, 0, time);
1359: 		_engine.schedulePause(_currentAmbient.handle, time);
1360: 	}
1361: 	else
1362: 	{
1363: 		_engine.setPause(_currentAmbient.handle, true);
1364: 	}
1365: }
1366: 
1367: void NxAudioEngine::resumeAmbient(double time)
1368: {
1369: 	if (_currentAmbient.fade_in > 0.0f)
1370: 	{
1371: 		time = _currentAmbient.fade_in;
1372: 
1373: 		if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f ( overridden through config.toml )\n", __func__, time);
1374: 	}
1375: 	else if (trace_all || trace_ambient) ffnx_trace("NxAudioEngine::%s: time=%f\n", __func__, time);
1376: 
1377: 	if (time > 0.0)
1378: 	{
1379: 		_engine.setPause(_currentAmbient.handle, false);
1380: 		_engine.fadeVolume(_currentAmbient.handle, _currentAmbient.volume, time);
1381: 	}
1382: 	else
1383: 	{
1384: 		_engine.setVolume(_currentAmbient.handle, _currentAmbient.volume);
1385: 		_engine.setPause(_currentAmbient.handle, false);
1386: 	}
1387: }
1388: 
1389: bool NxAudioEngine::isAmbientPlaying()
1390: {
1391: 	return _engine.isValidVoiceHandle(_currentAmbient.handle) && !_engine.getPause(_currentAmbient.handle);
1392: }
1393: 
1394: float NxAudioEngine::getAmbientMasterVolume()
1395: {
1396: 	return _ambientMasterVolume < 0.0f ? 1.0f : _ambientMasterVolume;
1397: }
1398: 
1399: void NxAudioEngine::setAmbientMasterVolume(float volume, double time)
1400: {
1401: 	_ambientMasterVolume = volume;
1402: }
1403: 
1404: // Movie Audio
1405: bool NxAudioEngine::canPlayMovieAudio(const char* nameWithPath)
1406: {
1407: 	char filename[MAX_PATH];
1408: 
1409: 	return getFilenameFullPath(filename, nameWithPath, NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO);
1410: }
1411: 
1412: bool NxAudioEngine::playMovieAudio(const char* nameWithPath, int slot, float volume)
1413: {
1414: 	char filename[MAX_PATH];
1415: 	bool exists = getFilenameFullPath(filename, nameWithPath, NxAudioEngineLayer::NXAUDIOENGINE_MOVIE_AUDIO);
1416: 
1417: 	if (trace_all || trace_movies) ffnx_trace("NxAudioEngine::%s: %s exists=%d\n", __func__, filename, exists);
1418: 
1419: 	// Stop any previously playing movie audio
1420: 	if (_engine.isValidVoiceHandle(_currentMovieAudio[slot].handle))
1421: 	{
1422: 		_engine.stop(_currentMovieAudio[slot].handle);
1423: 
1424: 		delete _currentMovieAudio[slot].stream;
1425: 
1426: 		_currentMovieAudio[slot].handle = NXAUDIOENGINE_INVALID_HANDLE;
1427: 	}
1428: 
1429: 	if (exists)
1430: 	{
1431: 		_currentMovieAudio[slot].stream = new SoLoud::VGMStream();
1432: 
1433: 		SoLoud::result res = _currentMovieAudio[slot].stream->load(filename);
1434: 		if (res != SoLoud::SO_NO_ERROR) {
1435: 			ffnx_error("NxAudioEngine::%s: Cannot load %s with vgmstream ( SoLoud error: %u )\n", __func__, filename, res);
1436: 			delete _currentMovieAudio[slot].stream;
1437: 			return false;
1438: 		}
1439: 
1440: 		_currentMovieAudio[slot].handle = _engine.play(*_currentMovieAudio[slot].stream, volume * getMovieMasterVolume());
1441: 
1442: 		return _engine.isValidVoiceHandle(_currentMovieAudio[slot].handle);
1443: 	}
1444: 	else
1445: 		return false;
1446: }
1447: 
1448: void NxAudioEngine::stopMovieAudio(int slot)
1449: {
1450: 	_engine.stop(_currentMovieAudio[slot].handle);
1451: }
1452: 
1453: bool NxAudioEngine::isMovieAudioPlaying(int slot)
1454: {
1455: 	return _engine.isValidVoiceHandle(_currentMovieAudio[slot].handle);
1456: }
1457: 
1458: void NxAudioEngine::setMovieAudioMaxSlots(int slot)
1459: {
1460: 	_movieAudioMaxSlots = slot;
1461: }
1462: 
1463: float NxAudioEngine::getMovieMasterVolume()
1464: {
1465: 	return _movieMasterVolume < 0.0f ? 1.0f : _movieMasterVolume;
1466: }
1467: 
1468: void NxAudioEngine::setMovieMasterVolume(float volume, double time)
1469: {
1470: 	_movieMasterVolume = volume;
1471: }
1472: 
1473: // Stream Audio
1474: void NxAudioEngine::initStream(float duration, float sample_rate, uint32_t channels)
1475: {
1476: 	if (_currentStream.stream) delete _currentStream.stream;
1477: 
1478: 	_currentStream.stream = new SoLoud::MemoryStream(sample_rate, ::ceil(duration) * sample_rate * channels, channels);
1479: }
1480: 
1481: void NxAudioEngine::pushStreamData(uint8_t* data, uint32_t size)
1482: {
1483: 	if (_currentStream.stream)
1484: 	{
1485: 		_currentStream.stream->push(data, size);
1486: 	}
1487: }
1488: 
1489: bool NxAudioEngine::playStream(float volume)
1490: {
1491: 	_currentStream.volume = volume * getStreamMasterVolume();
1492: 	_currentStream.handle = _engine.play(*_currentStream.stream, _currentStream.volume);
1493: 
1494: 	return _engine.isValidVoiceHandle(_currentStream.handle);
1495: }
1496: 
1497: void NxAudioEngine::stopStream(double time)
1498: {
1499: 	if (time > 0.0)
1500: 	{
1501: 		_engine.fadeVolume(_currentStream.handle, 0, time);
1502: 		_engine.schedulePause(_currentStream.handle, time);
1503: 	}
1504: 	else
1505: 	{
1506: 		_engine.setPause(_currentStream.handle, true);
1507: 	}
1508: 
1509: 	_currentStream.handle = NXAUDIOENGINE_INVALID_HANDLE;
1510: }
1511: 
1512: bool NxAudioEngine::isStreamPlaying()
1513: {
1514: 	return _engine.isValidVoiceHandle(_currentStream.handle);
1515: }
1516: 
1517: void NxAudioEngine::pauseStream(double time)
1518: {
1519: 	if (time > 0.0)
1520: 	{
1521: 		_engine.fadeVolume(_currentStream.handle, 0, time);
1522: 		_engine.schedulePause(_currentStream.handle, time);
1523: 	}
1524: 	else
1525: 	{
1526: 		_engine.setPause(_currentStream.handle, true);
1527: 	}
1528: }
1529: 
1530: void NxAudioEngine::resumeStream(double time)
1531: {
1532: 	if (time > 0.0)
1533: 	{
1534: 		_engine.setPause(_currentStream.handle, false);
1535: 		_engine.fadeVolume(_currentStream.handle, _currentStream.volume, time);
1536: 	}
1537: 	else
1538: 	{
1539: 		_engine.setVolume(_currentStream.handle, _currentStream.volume);
1540: 		_engine.setPause(_currentStream.handle, false);
1541: 	}
1542: }
1543: 
1544: float NxAudioEngine::getStreamMasterVolume()
1545: {
1546: 	return _streamMasterVolume < 0.0f ? 1.0f : _streamMasterVolume;
1547: }
1548: 
1549: void NxAudioEngine::setStreamMasterVolume(float volume, double time)
1550: {
1551: 	_streamMasterVolume = volume;
1552: }
</file>

<file path="src/audio.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #pragma once
 23: 
 24: #include <stack>
 25: #include <string>
 26: #include <vector>
 27: #include <unordered_map>
 28: #include <soloud.h>
 29: #include "audio/memorystream/memorystream.h"
 30: #include "audio/vgmstream/vgmstream.h"
 31: 
 32: #include "log.h"
 33: 
 34: #define NXAUDIOENGINE_INVALID_HANDLE 0xfffff000
 35: 
 36: static void NxAudioEngineVgmstreamCallback(int level, const char* str)
 37: {
 38:   ffnx_info("VGMStream [L%d]: %s", level, str);
 39: }
 40: 
 41: class NxAudioEngine
 42: {
 43: public:
 44: 	struct MusicOptions
 45: 	{
 46: 		MusicOptions() :
 47: 			offsetSeconds(0.0),
 48: 			fadetime(0.0),
 49: 			targetVolume(-1.0f),
 50: 			relativeSpeed(1.0f),
 51: 			format(""),
 52: 			noIntro(false),
 53: 			sync(false),
 54: 			useNameAsFullPath(false),
 55: 			suppressOpeningSilence(false)
 56: 		{}
 57: 		SoLoud::time offsetSeconds;
 58: 		SoLoud::time fadetime;
 59: 		float targetVolume;
 60: 		float relativeSpeed;
 61: 		char format[12];
 62: 		bool noIntro, sync, useNameAsFullPath, suppressOpeningSilence;
 63: 	};
 64: 
 65: 	struct NxAudioEngineSFX
 66: 	{
 67: 		NxAudioEngineSFX() :
 68: 			game_id(0),
 69: 			id(0),
 70: 			stream(nullptr),
 71: 			handle(NXAUDIOENGINE_INVALID_HANDLE),
 72: 			volume(1.0f),
 73: 			loop(false)
 74: 		{}
 75: 		int game_id;
 76: 		int id;
 77: 		SoLoud::VGMStream *stream;
 78: 		SoLoud::handle handle;
 79: 		float volume;
 80: 		bool loop;
 81: 	};
 82: 
 83: 	struct NxAudioEngineMusic
 84: 	{
 85: 		NxAudioEngineMusic() :
 86: 			handle(NXAUDIOENGINE_INVALID_HANDLE),
 87: 			id(-1),
 88: 			wantedMusicVolume(1.0f),
 89: 			lastMusicOffset(-1.0f),
 90: 			sync(false) {}
 91: 		void invalidate() {
 92: 			handle = NXAUDIOENGINE_INVALID_HANDLE;
 93: 			id = -1;
 94: 		}
 95: 		SoLoud::handle handle;
 96: 		int32_t id;
 97: 		float wantedMusicVolume;
 98: 		SoLoud::time lastMusicOffset;
 99: 		bool sync;
100: 	};
101: 
102: 	struct NxAudioEngineMusicAudioSource
103: 	{
104: 		NxAudioEngineMusicAudioSource(SoLoud::handle handle, SoLoud::AudioSource* audioSource) :
105: 			handle(handle),
106: 			audioSource(audioSource) {}
107: 		SoLoud::handle handle;
108: 		SoLoud::AudioSource* audioSource;
109: 	};
110: 
111: 	struct NxAudioEngineVoice
112: 	{
113: 		NxAudioEngineVoice() :
114: 			handle(NXAUDIOENGINE_INVALID_HANDLE),
115: 			stream(nullptr),
116: 			volume(1.0f) {}
117: 		SoLoud::handle handle;
118: 		SoLoud::VGMStream* stream;
119: 		float volume;
120: 	};
121: 
122: 	struct NxAudioEngineAmbient
123: 	{
124: 		NxAudioEngineAmbient() :
125: 			handle(NXAUDIOENGINE_INVALID_HANDLE),
126: 			stream(nullptr),
127: 			volume(1.0f),
128: 			fade_in(0.0f),
129: 			fade_out(0.0f) {}
130: 		SoLoud::handle handle;
131: 		SoLoud::VGMStream* stream;
132: 		float volume;
133: 		double fade_in;
134: 		double fade_out;
135: 	};
136: 
137: 	struct NxAudioEngineMovieAudio
138: 	{
139: 		NxAudioEngineMovieAudio() :
140: 			handle(NXAUDIOENGINE_INVALID_HANDLE),
141: 			stream(nullptr) {}
142: 		SoLoud::handle handle;
143: 		SoLoud::VGMStream* stream;
144: 	};
145: 
146: 	struct NxAudioEngineStreamAudio
147: 	{
148: 		NxAudioEngineStreamAudio() :
149: 			handle(NXAUDIOENGINE_INVALID_HANDLE),
150: 			stream(nullptr),
151: 			volume(1.0f) {}
152: 		SoLoud::handle handle;
153: 		SoLoud::MemoryStream* stream;
154: 		float volume;
155: 	};
156: 
157: private:
158: 	enum NxAudioEngineLayer
159: 	{
160: 		NXAUDIOENGINE_SFX,
161: 		NXAUDIOENGINE_MUSIC,
162: 		NXAUDIOENGINE_VOICE,
163: 		NXAUDIOENGINE_AMBIENT,
164: 		NXAUDIOENGINE_MOVIE_AUDIO,
165: 	};
166: 
167: 	bool _engineInitialized = false;
168: 	SoLoud::Soloud _engine;
169: 	bool _openpsf_loaded = false;
170: 
171: 	// SFX
172: 	short _sfxReusableChannels = 0;
173: 	short _sfxTotalChannels = 0;
174: 	float _sfxMasterVolume = -1.0f;
175: 	std::map<int, NxAudioEngineSFX> _sfxChannels;
176: 	std::map<std::string, int> _sfxSequentialIndexes;
177: 	std::map<int, SoLoud::VGMStream*> _sfxEffectsHandler;
178: 	std::vector<short> _sfxLazyUnloadChannels;
179: 
180: 	SoLoud::VGMStream* loadSFX(std::string id, bool loop = false);
181: 	void unloadSFXChannel(int channel);
182: 
183: 	// MUSIC
184: 	NxAudioEngineMusic _musics[2];
185: 	std::stack<NxAudioEngineMusic> _musicStack; // For resuming
186: 	std::list<NxAudioEngineMusicAudioSource> _audioSourcesToDeleteLater;
187: 
188: 	float _previousMusicMasterVolume = -1.0f;
189: 	float _musicMasterVolume = -1.0f;
190: 	SoLoud::time _lastVolumeFadeEndTime = 0.0;
191: 
192: 	void cleanOldAudioSources();
193: 	SoLoud::AudioSource* loadMusic(const char* name, bool isFullPath = false, const char* format = nullptr, bool suppressOpeningSilence = false);
194: 	void overloadPlayArgumentsFromConfig(char* name, uint32_t *id, MusicOptions *MusicOptions);
195: 	void backupMusic(int channelSource);
196: 	void restoreMusic(int channelDest, double stopTime = 0);
197: 	void resetMusicVolume(double time = 0);
198: 	void resetMusicVolume(int channel, double time = 0);
199: 
200: 	// VOICE
201: 	short _voiceMaxSlots = 0;
202: 	float _voiceMasterVolume = -1.0f;
203: 	std::map<int, NxAudioEngineVoice> _currentVoice;
204: 	std::map<std::string, int> _voiceSequentialIndexes;
205: 
206: 	// AMBIENT
207: 	float _ambientMasterVolume = -1.0f;
208: 	std::map<std::string, int> _ambientSequentialIndexes;
209: 	NxAudioEngineAmbient _currentAmbient;
210: 
211: 	// MOVIE AUDIO
212: 	float _movieMasterVolume = -1.0f;
213: 	short _movieAudioMaxSlots = 0;
214: 	std::map<int, NxAudioEngineMovieAudio> _currentMovieAudio;
215: 
216: 	// STREAM
217: 	float _streamMasterVolume = -1.0f;
218: 	NxAudioEngineStreamAudio _currentStream;
219: 
220: 	// MISC
221: 	// Returns false if the file does not exist
222: 	bool getFilenameFullPath(char *_out, const char* _key, NxAudioEngineLayer _type);
223: 
224: 	bool fileExists(const char* filename);
225: 
226: 	// CFG
227: 	std::unordered_map<NxAudioEngineLayer,toml::parse_result> nxAudioEngineConfig;
228: 
229: 	void loadConfig();
230: 
231: public:
232: 
233: 	bool init();
234: 	void flush();
235: 	void cleanup();
236: 
237: 	// SFX
238: 	int getSFXIdFromChannel(int channel);
239: 	void unloadSFX(int id);
240: 	bool playSFX(const char* name, int id, int channel, float panning, bool loop = false, float volume = 1.0f);
241: 	void stopSFX(int channel, double time = 0);
242: 	void pauseSFX(int channel);
243: 	void resumeSFX(int channel);
244: 	bool isSFXPlaying(int channel);
245: 	float getSFXMasterVolume();
246: 	void setSFXMasterVolume(float volume, double time = 0);
247: 	void setSFXVolume(int channel, float volume, double time = 0);
248: 	void setSFXSpeed(int channel, float speed, double time = 0);
249: 	void setSFXPanning(int channel, float panning, double time = 0);
250: 	void setSFXReusableChannels(short num);
251: 	void setSFXTotalChannels(short num);
252: 	void addSFXLazyUnloadChannel(int channel);
253: 
254: 	// Music
255: 	bool canPlayMusic(const char* name);
256: 	bool isMusicDisabled(const char* name);
257: 	bool playMusic(const char* name, uint32_t id, int channel, MusicOptions options = MusicOptions());
258: 	void playSynchronizedMusics(const std::vector<std::string>& names, uint32_t id, MusicOptions options = MusicOptions());
259: 	void swapChannels();
260: 	void stopMusic(double time = 0);
261: 	void stopMusic(int channel, double time = 0);
262: 	void pauseMusic(double time = 0);
263: 	void pauseMusic(int channel, double time = 0, bool backup = false);
264: 	void resumeMusic(double time = 0);
265: 	void resumeMusic(int channel, double time = 0, bool restore = false);
266: 	bool isChannelValid(int channel);
267: 	bool isMusicPlaying();
268: 	bool isMusicPlaying(int channel);
269: 	uint32_t currentMusicId(int channel);
270: 	void setMusicMasterVolume(float volume, double time = 0);
271: 	void restoreMusicMasterVolume(double time = 0);
272: 	float getMusicVolume(int channel);
273: 	bool isMusicVolumeFadeFinished();
274: 	float getMusicMasterVolume();
275: 	void setMusicVolume(float volume, int channel, double time = 0);
276: 	void setMusicSpeed(float speed, int channel);
277: 	void setMusicLooping(bool looping, int channel);
278: 
279: 	// Voice
280: 	bool canPlayVoice(const char* name);
281: 	bool playVoice(const char* name, int slot = 0, float volume = 1.0f, int game_moment = -1);
282: 	void stopVoice(int slot = 0, double time = 0);
283: 	void pauseVoice(int slot = 0, double time = 0);
284: 	void resumeVoice(int slot = 0, double time = 0);
285: 	bool isVoicePlaying(int slot = 0);
286: 	void setVoiceMaxSlots(int slot);
287: 	float getVoiceMasterVolume();
288: 	void setVoiceMasterVolume(float volume, double time = 0);
289: 
290: 	// Ambient
291: 	bool canPlayAmbient(const char* name);
292: 	bool playAmbient(const char* name, float volume = 1.0f, double time = 0);
293: 	void stopAmbient(double time = 0);
294: 	void pauseAmbient(double time = 0);
295: 	void resumeAmbient(double time = 0);
296: 	bool isAmbientPlaying();
297: 	float getAmbientMasterVolume();
298: 	void setAmbientMasterVolume(float volume, double time = 0);
299: 
300: 	// Movie Audio
301: 	bool canPlayMovieAudio(const char* filename);
302: 	bool playMovieAudio(const char* filename, int slot = 0, float volume = 1.0f);
303: 	void stopMovieAudio(int slot = 0);
304: 	bool isMovieAudioPlaying(int slot = 0);
305: 	void setMovieAudioMaxSlots(int slot);
306: 	float getMovieMasterVolume();
307: 	void setMovieMasterVolume(float volume, double time = 0);
308: 
309: 	// Stream Audio
310: 	void initStream(float duration, float sample_rate, uint32_t channels);
311: 	void pushStreamData(uint8_t* data, uint32_t size);
312: 	bool playStream(float volume = 1.0f);
313: 	void stopStream(double time = 0.0f);
314: 	void pauseStream(double time = 0.0f);
315: 	void resumeStream(double time = 0.0f);
316: 	bool isStreamPlaying();
317: 	float getStreamMasterVolume();
318: 	void setStreamMasterVolume(float volume, double time = 0);
319: };
320: 
321: extern NxAudioEngine nxAudioEngine;
</file>

<file path="src/cfg.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <toml++/toml.h>
 24: 
 25: #include "cfg.h"
 26: #include "common.h"
 27: #include "globals.h"
 28: #include "log.h"
 29: 
 30: #define FFNX_CFG_FILE "FFNx.toml"
 31: 
 32: // configuration variables with their default values
 33: std::string mod_path;
 34: std::vector<std::string> mod_ext;
 35: long enable_ffmpeg_videos;
 36: std::string ffmpeg_video_ext;
 37: std::vector<std::string> external_movie_audio_ext;
 38: bool use_external_sfx;
 39: std::string external_sfx_path;
 40: std::vector<std::string> external_sfx_ext;
 41: bool external_sfx_always_centered;
 42: bool use_external_music;
 43: bool external_music_resume;
 44: bool external_music_sync;
 45: std::string external_music_path;
 46: std::vector<std::string> external_music_ext;
 47: std::string he_bios_path;
 48: std::string external_voice_path;
 49: std::vector<std::string> external_voice_ext;
 50: std::string external_ambient_path;
 51: std::vector<std::string> external_ambient_ext;
 52: std::string external_lighting_path;
 53: std::string external_widescreen_path;
 54: std::string external_time_cycle_path;
 55: std::string external_mesh_path;
 56: bool enable_voice_music_fade;
 57: long external_voice_music_fade_volume;
 58: bool enable_voice_auto_text;
 59: bool enable_auto_run;
 60: bool save_textures;
 61: bool save_textures_legacy;
 62: bool save_exe_data;
 63: bool trace_all;
 64: bool trace_renderer;
 65: bool trace_movies;
 66: bool trace_music;
 67: bool trace_sfx;
 68: bool trace_fake_dx;
 69: bool trace_direct;
 70: bool trace_files;
 71: bool trace_loaders;
 72: bool trace_vram;
 73: bool trace_lights;
 74: bool trace_opcodes;
 75: bool trace_voice;
 76: bool trace_ambient;
 77: bool trace_gamepad;
 78: bool trace_achievement;
 79: bool trace_battle_animation;
 80: bool trace_battle_text;
 81: bool vertex_log;
 82: bool uniform_log;
 83: bool show_renderer_backend;
 84: bool show_fps;
 85: bool show_stats;
 86: bool show_version;
 87: long window_size_x;
 88: long window_size_y;
 89: long internal_resolution_scale;
 90: long aspect_ratio;
 91: bool enable_uncrop;
 92: bool fullscreen;
 93: bool borderless;
 94: long refresh_rate;
 95: bool enable_vsync;
 96: bool mdef_fix;
 97: long enable_antialiasing;
 98: bool enable_anisotropic;
 99: bool enable_bilinear;
100: bool enable_lighting;
101: bool prefer_lighting_cpu_calculations;
102: long game_lighting;
103: bool enable_time_cycle;
104: bool enable_worldmap_external_mesh;
105: bool ff7_external_opening_music;
106: bool more_debug;
107: bool ff8_ssigpu_debug;
108: bool show_applog;
109: bool show_missing_textures;
110: bool show_error_popup;
111: long renderer_backend;
112: bool renderer_debug;
113: bool create_crash_dump;
114: std::string steam_game_userdata;
115: std::string hext_patching_path;
116: std::string override_path;
117: std::string override_mod_path;
118: std::string direct_mode_path;
119: std::string save_path;
120: bool enable_devtools;
121: long devtools_hotkey;
122: double speedhack_step;
123: double speedhack_max;
124: double speedhack_min;
125: bool enable_animated_textures;
126: std::vector<std::string> disable_animated_textures_on_field;
127: long ff7_fps_limiter;
128: bool ff7_footsteps;
129: bool ff7_field_center;
130: bool enable_analogue_controls;
131: bool enable_inverted_vertical_camera_controls;
132: bool enable_inverted_horizontal_camera_controls;
133: double left_analog_stick_deadzone;
134: double right_analog_stick_deadzone;
135: double left_analog_trigger_deadzone;
136: double right_analog_trigger_deadzone;
137: std::string external_vibrate_path;
138: bool enable_steam_achievements;
139: bool steam_achievements_debug_mode;
140: double hdr_max_nits;
141: long external_audio_number_of_channels;
142: long external_audio_sample_rate;
143: bool ff8_worldmap_internal_highres_textures;
144: bool ff8_fix_uv_coords_precision;
145: bool ff8_external_music_force_original_filenames;
146: bool ff8_use_gamepad_icons;
147: bool ff8_always_capture_input;
148: long ff8_fps_limiter;
149: std::string app_path;
150: std::string data_drive;
151: bool enable_ntscj_gamut_mode;
152: long external_music_volume;
153: long external_sfx_volume;
154: long external_voice_volume;
155: long external_ambient_volume;
156: long ffmpeg_video_volume;
157: bool ff7_advanced_blinking;
158: long display_index;
159: 
160: std::vector<std::string> get_string_or_array_of_strings(const toml::node_view<toml::node> &node)
161: {
162: 	if (node.is_array()) {
163: 		toml::array* a = node.as_array();
164: 		if (a && a->is_homogeneous(toml::node_type::string)) {
165: 			std::vector<std::string> ret;
166: 			ret.reserve(a->size());
167: 			for (toml::node &elem: *a) {
168: 				ret.push_back(elem.value_or(""));
169: 			}
170: 			return ret;
171: 		}
172: 	}
173: 
174: 	return std::vector<std::string>(1, node.value_or(""));
175: }
176: 
177: void read_cfg()
178: {
179: 	toml::parse_result config;
180: 
181: 	try
182: 	{
183: 		config = toml::parse_file(FFNX_CFG_FILE);
184: 	}
185: 	catch (const toml::parse_error &err)
186: 	{
187: 		ffnx_warning("Parse error while opening the file " FFNX_CFG_FILE ". Will continue with the default settings.\n");
188: 		ffnx_warning("%s (Line %u Column %u)\n", err.what(), err.source().begin.line, err.source().begin.column);
189: 
190: 		char tmp[1024]{0};
191: 		sprintf(tmp, "%s (Line %u Column %u)\n\nWill continue with safe default settings.", err.what(), err.source().begin.line, err.source().begin.column);
192: 		MessageBoxA(gameHwnd, tmp, "Configuration issue detected!", MB_ICONWARNING | MB_OK);
193: 
194: 		config = toml::parse("");
195: 	}
196: 
197: 	// Read config values
198: 	mod_path = config["mod_path"].value_or("");
199: 	mod_ext = get_string_or_array_of_strings(config["mod_ext"]);
200: 	enable_ffmpeg_videos = config["enable_ffmpeg_videos"].value_or(-1);
201: 	ffmpeg_video_ext = config["ffmpeg_video_ext"].value_or("");
202: 	external_movie_audio_ext = get_string_or_array_of_strings(config["external_movie_audio_ext"]);
203: 	use_external_sfx = config["use_external_sfx"].value_or(false);
204: 	external_sfx_path = config["external_sfx_path"].value_or("");
205: 	external_sfx_ext = get_string_or_array_of_strings(config["external_sfx_ext"]);
206: 	external_sfx_always_centered = config["external_sfx_always_centered"].value_or(false);
207: 	use_external_music = config["use_external_music"].value_or(false);
208: 	external_music_resume = config["external_music_resume"].value_or(true);
209: 	external_music_sync = config["external_music_sync"].value_or(false);
210: 	external_music_path = config["external_music_path"].value_or("");
211: 	external_music_ext = get_string_or_array_of_strings(config["external_music_ext"]);
212: 	he_bios_path = config["he_bios_path"].value_or("");
213: 	external_voice_path = config["external_voice_path"].value_or("");
214: 	external_voice_ext = get_string_or_array_of_strings(config["external_voice_ext"]);
215: 	enable_voice_music_fade = config["enable_voice_music_fade"].value_or(false);
216: 	external_voice_music_fade_volume = config["external_voice_music_fade_volume"].value_or(25);
217: 	enable_voice_auto_text = config["enable_voice_auto_text"].value_or(true);
218: 	external_ambient_path = config["external_ambient_path"].value_or("");
219: 	external_ambient_ext = get_string_or_array_of_strings(config["external_ambient_ext"]);
220: 	external_lighting_path = config["external_lighting_path"].value_or("");
221: 	external_widescreen_path = config["external_widescreen_path"].value_or("");
222: 	external_time_cycle_path = config["external_time_cycle_path"].value_or("");
223: 	external_mesh_path = config["external_mesh_path"].value_or("");
224: 	save_textures = config["save_textures"].value_or(false);
225: 	save_textures_legacy = config["save_textures_legacy"].value_or(false);
226: 	save_exe_data = config["save_exe_data"].value_or(false);
227: 	trace_all = config["trace_all"].value_or(false);
228: 	trace_renderer = config["trace_renderer"].value_or(false);
229: 	trace_movies = config["trace_movies"].value_or(false);
230: 	trace_music = config["trace_music"].value_or(false);
231: 	trace_sfx = config["trace_sfx"].value_or(false);
232: 	trace_fake_dx = config["trace_fake_dx"].value_or(false);
233: 	trace_direct = config["trace_direct"].value_or(false);
234: 	trace_files = config["trace_files"].value_or(false);
235: 	trace_loaders = config["trace_loaders"].value_or(false);
236: 	trace_vram = config["trace_vram"].value_or(false);
237: 	trace_lights = config["trace_lights"].value_or(false);
238: 	trace_opcodes = config["trace_opcodes"].value_or(false);
239: 	trace_voice = config["trace_voice"].value_or(false);
240: 	trace_ambient = config["trace_ambient"].value_or(false);
241: 	trace_gamepad = config["trace_gamepad"].value_or(false);
242: 	trace_achievement = config["trace_achievement"].value_or(false);
243: 	trace_battle_animation = config["trace_battle_animation"].value_or(false);
244: 	trace_battle_text = config["trace_battle_text"].value_or(false);
245: 	vertex_log = config["vertex_log"].value_or(false);
246: 	uniform_log = config["uniform_log"].value_or(false);
247: 	show_renderer_backend = config["show_renderer_backend"].value_or(true);
248: 	show_fps = config["show_fps"].value_or(false);
249: 	show_stats = config["show_stats"].value_or(false);
250: 	show_version = config["show_version"].value_or(true);
251: 	window_size_x = config["window_size_x"].value_or(0);
252: 	window_size_y = config["window_size_y"].value_or(0);
253: 	internal_resolution_scale = config["internal_resolution_scale"].value_or(0);
254: 	aspect_ratio = config["aspect_ratio"].value_or(0);
255: 	enable_uncrop = config["enable_uncrop"].value_or(false);
256: 	fullscreen = config["fullscreen"].value_or(false);
257: 	borderless = config["borderless"].value_or(false);
258: 	refresh_rate = config["refresh_rate"].value_or(0);
259: 	enable_vsync = config["enable_vsync"].value_or(true);
260: 	mdef_fix = config["mdef_fix"].value_or(true);
261: 	enable_antialiasing = config["enable_antialiasing"].value_or(0);
262: 	enable_anisotropic = config["enable_anisotropic"].value_or(true);
263: 	enable_bilinear = config["enable_bilinear"].value_or(false);
264: 	enable_lighting = config["enable_lighting"].value_or(false);
265: 	prefer_lighting_cpu_calculations = config["prefer_lighting_cpu_calculations"].value_or(true);
266: 	game_lighting = config["game_lighting"].value_or(GAME_LIGHTING_PER_VERTEX);
267: 	enable_time_cycle = config["enable_time_cycle"].value_or(false);
268: 	enable_worldmap_external_mesh = config["enable_worldmap_external_mesh"].value_or(false);
269: 	ff7_external_opening_music = config["ff7_external_opening_music"].value_or(false);
270: 	more_debug = config["more_debug"].value_or(false);
271: 	ff8_ssigpu_debug = config["ff8_ssigpu_debug"].value_or(false);
272: 	show_applog = config["show_applog"].value_or(true);
273: 	show_missing_textures = config["show_missing_textures"].value_or(false);
274: 	show_error_popup = config["show_error_popup"].value_or(false);
275: 	renderer_backend = config["renderer_backend"].value_or(RENDERER_BACKEND_AUTO);
276: 	renderer_debug = config["renderer_debug"].value_or(false);
277: 	create_crash_dump = config["create_crash_dump"].value_or(false);
278: 	steam_game_userdata = config["steam_game_userdata"].value_or("");
279: 	hext_patching_path = config["hext_patching_path"].value_or("");
280: 	override_path = config["override_path"].value_or("");
281: 	override_mod_path = config["override_mod_path"].value_or("");
282: 	direct_mode_path = config["direct_mode_path"].value_or("");
283: 	save_path = config["save_path"].value_or("");
284: 	enable_devtools = config["enable_devtools"].value_or(false);
285: 	devtools_hotkey = config["devtools_hotkey"].value_or(VK_F12);
286: 	speedhack_step = config["speedhack_step"].value_or(0.5);
287: 	speedhack_max = config["speedhack_max"].value_or(8.0);
288: 	speedhack_min = config["speedhack_min"].value_or(1.0);
289: 	enable_animated_textures = config["enable_animated_textures"].value_or(false);
290: 	disable_animated_textures_on_field = get_string_or_array_of_strings(config["disable_animated_textures_on_field"]);
291: 	ff7_fps_limiter = config["ff7_fps_limiter"].value_or(FPS_LIMITER_DEFAULT);
292: 	ff7_footsteps = config["ff7_footsteps"].value_or(false);
293: 	ff7_field_center = config["ff7_field_center"].value_or(true);
294: 	enable_analogue_controls = config["enable_analogue_controls"].value_or(false);
295: 	enable_inverted_vertical_camera_controls = config["enable_inverted_vertical_camera_controls"].value_or(false);
296: 	enable_inverted_horizontal_camera_controls = config["enable_inverted_horizontal_camera_controls"].value_or(false);
297: 	left_analog_stick_deadzone = config["left_analog_stick_deadzone"].value_or(0.1);
298: 	right_analog_stick_deadzone = config["right_analog_stick_deadzone"].value_or(0.1);
299: 	left_analog_trigger_deadzone = config["left_analog_trigger_deadzone"].value_or(0.1);
300: 	right_analog_trigger_deadzone = config["right_analog_trigger_deadzone"].value_or(0.1);
301: 	enable_auto_run = config["enable_auto_run"].value_or(false);
302: 	external_vibrate_path = config["external_vibrate_path"].value_or("");
303: 	enable_steam_achievements = config["enable_steam_achievements"].value_or(false);
304: 	steam_achievements_debug_mode = config["steam_achievements_debug_mode"].value_or(false);
305: 	hdr_max_nits = config["hdr_max_nits"].value_or(0);
306: 	external_audio_number_of_channels = config["external_audio_number_of_channels"].value_or(2);
307: 	external_audio_sample_rate = config["external_audio_sample_rate"].value_or(44100);
308: 	ff8_worldmap_internal_highres_textures = config["ff8_worldmap_internal_highres_textures"].value_or(true);
309: 	ff8_fix_uv_coords_precision = config["ff8_fix_uv_coords_precision"].value_or(true);
310: 	ff8_external_music_force_original_filenames = config["ff8_external_music_force_original_filenames"].value_or(false);
311: 	ff8_use_gamepad_icons = config["ff8_use_gamepad_icons"].value_or(false);
312: 	ff8_always_capture_input = config["ff8_always_capture_input"].value_or(false);
313: 	ff8_fps_limiter = config["ff8_fps_limiter"].value_or(FPS_LIMITER_DEFAULT);
314: 	app_path = config["app_path"].value_or("");
315: 	data_drive = config["data_drive"].value_or("");
316: 	enable_ntscj_gamut_mode = config["enable_ntscj_gamut_mode"].value_or(false);
317: 	external_music_volume = config["external_music_volume"].value_or(-1);
318: 	external_sfx_volume = config["external_sfx_volume"].value_or(-1);
319: 	external_voice_volume = config["external_voice_volume"].value_or(-1);
320: 	external_ambient_volume = config["external_ambient_volume"].value_or(-1);
321: 	ffmpeg_video_volume = config["ffmpeg_video_volume"].value_or(-1);
322: 	ff7_advanced_blinking = config["ff7_advanced_blinking"].value_or(false);
323: 	display_index = config["display_index"].value_or(-1);
324: 
325: 	// Windows x or y size can't be less then 0
326: 	if (window_size_x < 0) window_size_x = 0;
327: 	if (window_size_y < 0) window_size_y = 0;
328: 
329: 	// Normalize voice music fade volume
330: 	if (external_voice_music_fade_volume < 0) external_voice_music_fade_volume = 0;
331: 	if (external_voice_music_fade_volume > 100) external_voice_music_fade_volume = 100;
332: 
333: 
334: 	// #############
335: 	// SAFE DEFAULTS
336: 	// #############
337: 
338: 	if (ff7_fps_limiter < FPS_LIMITER_ORIGINAL) ff7_fps_limiter = FPS_LIMITER_ORIGINAL;
339: 	else if (ff7_fps_limiter > FPS_LIMITER_60FPS) ff7_fps_limiter = FPS_LIMITER_60FPS;
340: 
341: 	if (ff8_fps_limiter < FPS_LIMITER_ORIGINAL) ff8_fps_limiter = FPS_LIMITER_ORIGINAL;
342: 	else if (ff8_fps_limiter > FPS_LIMITER_60FPS) ff8_fps_limiter = FPS_LIMITER_60FPS;
343: 
344: 	if (hext_patching_path.empty())
345: 	{
346: 		hext_patching_path = "hext";
347: 	}
348: 
349: 	if (ff8)
350: 		hext_patching_path += "/ff8";
351: 	else
352: 		hext_patching_path += "/ff7";
353: 
354: 	switch (version)
355: 	{
356: 	case VERSION_FF7_102_US:
357: 		if (ff7_japanese_edition)
358: 		{
359: 			hext_patching_path += "/ja";
360: 		}
361: 		else
362: 		{
363: 			hext_patching_path += "/en";
364: 		}
365: 		break;
366: 	case VERSION_FF7_102_FR:
367: 		hext_patching_path += "/fr";
368: 		break;
369: 	case VERSION_FF7_102_DE:
370: 		hext_patching_path += "/de";
371: 		break;
372: 	case VERSION_FF7_102_SP:
373: 		hext_patching_path += "/es";
374: 		break;
375: 	case VERSION_FF8_12_US:
376: 		hext_patching_path += "/en";
377: 		break;
378: 	case VERSION_FF8_12_US_NV:
379: 		hext_patching_path += "/en_nv";
380: 		break;
381: 	case VERSION_FF8_12_FR:
382: 		hext_patching_path += "/fr";
383: 		break;
384: 	case VERSION_FF8_12_FR_NV:
385: 		hext_patching_path += "/fr_nv";
386: 		break;
387: 	case VERSION_FF8_12_DE:
388: 		hext_patching_path += "/de";
389: 		break;
390: 	case VERSION_FF8_12_DE_NV:
391: 		hext_patching_path += "/de_nv";
392: 		break;
393: 	case VERSION_FF8_12_SP:
394: 		hext_patching_path += "/es";
395: 		break;
396: 	case VERSION_FF8_12_SP_NV:
397: 		hext_patching_path += "/es_nv";
398: 		break;
399: 	case VERSION_FF8_12_IT:
400: 		hext_patching_path += "/it";
401: 		break;
402: 	case VERSION_FF8_12_IT_NV:
403: 		hext_patching_path += "/it_nv";
404: 		break;
405: 	case VERSION_FF8_12_US_EIDOS:
406: 		hext_patching_path += "/en_eidos";
407: 		break;
408: 	case VERSION_FF8_12_US_EIDOS_NV:
409: 		hext_patching_path += "/en_eidos_nv";
410: 		break;
411: 	case VERSION_FF8_12_JP:
412: 		hext_patching_path += "/jp";
413: 		break;
414: 	case VERSION_FF8_12_JP_NV:
415: 		hext_patching_path += "/jp_nv";
416: 		break;
417: 	}
418: 
419: 	//OVERRIDE PATH
420: 	if (override_path.empty())
421: 		override_path = "override";
422: 
423: 	// DIRECT MODE PATH
424: 	if (direct_mode_path.empty())
425: 		direct_mode_path = "direct";
426: 
427: 	// EXTERNAL MOVIE FLAG
428: 	if (enable_ffmpeg_videos < 0)
429: 		enable_ffmpeg_videos = !ff8;
430: 
431: 	// EXTERNAL MOVIE EXTENSION
432: 	if (ffmpeg_video_ext.empty())
433: 		ffmpeg_video_ext = "avi";
434: 
435: 	// EXTERNAL MOVIE AUDIO EXTENSION
436: 	if (external_movie_audio_ext.empty() || external_movie_audio_ext.front().empty())
437: 		external_movie_audio_ext = std::vector<std::string>(1, "ogg");
438: 
439: 	// EXTERNAL SFX PATH
440: 	if (external_sfx_path.empty())
441: 		external_sfx_path = "sfx";
442: 
443: 	// EXTERNAL SFX EXTENSION
444: 	if (external_sfx_ext.empty() || external_sfx_ext.front().empty())
445: 		external_sfx_ext = std::vector<std::string>(1, "ogg");
446: 
447: 	// EXTERNAL MUSIC EXTENSION
448: 	if (external_music_ext.empty() || external_music_ext.front().empty())
449: 		external_music_ext = std::vector<std::string>(1, "ogg");
450: 
451: 	// EXTERNAL VOICE PATH
452: 	if (external_voice_path.empty())
453: 		external_voice_path = "voice";
454: 
455: 	// EXTERNAL VOICE EXTENSION
456: 	if (external_voice_ext.empty() || external_voice_ext.front().empty())
457: 		external_voice_ext = std::vector<std::string>(1, "ogg");
458: 
459: 	// EXTERNAL AMBIENT PATH
460: 	if (external_ambient_path.empty())
461: 		external_ambient_path = "ambient";
462: 
463: 	// EXTERNAL AMBIENT EXTENSION
464: 	if (external_ambient_ext.empty() || external_ambient_ext.front().empty())
465: 		external_ambient_ext = std::vector<std::string>(1, "ogg");
466: 
467: 	// EXTERNAL LIGHTING PATH
468: 	if (external_lighting_path.empty())
469: 		external_lighting_path = "lighting";
470: 
471: 	// EXTERNAL WIDESCREEN PATH
472: 	if (external_widescreen_path.empty())
473: 		external_widescreen_path = "widescreen";
474: 
475: 	// EXTERNAL TIME CYCLE
476: 	if (external_time_cycle_path.empty())
477: 		external_time_cycle_path = "time";
478: 
479: 	// EXTERNAL MESH
480: 	if (external_mesh_path.empty())
481: 		external_mesh_path = "mesh";
482: 
483: 	// MOD PATH
484: 	if (mod_path.empty())
485: 		mod_path = "mods/Textures";
486: 
487: 	// MOD EXTENSION
488: 	if (mod_ext.empty() || mod_ext.front().empty())
489: 		mod_ext = {"dds", "png"};
490: 
491: 	// AUDIO NUMBER OF CHANNELS
492: 	if (external_audio_number_of_channels < 0)
493: 		external_audio_number_of_channels = 0;
494: 	else if (external_audio_number_of_channels % 2 != 0)
495: 		// Round to the previous even number
496: 		external_audio_number_of_channels--;
497: 
498: 	// AUDIO SAMPLE RATE
499: 	if (external_audio_sample_rate < 0)
500: 		external_audio_sample_rate = 0;
501: 
502: 	// EXTERNAL VIBRATE PATH
503: 	if (external_vibrate_path.empty())
504: 		external_vibrate_path = "vibrate";
505: 
506: 	if (ff8)
507: 		external_vibrate_path += "/ff8";
508: 	else
509: 		external_vibrate_path += "/ff7";
510: 
511: 	// VOLUME
512: 	if (external_music_volume > 100) external_music_volume = 100;
513: 	if (external_sfx_volume > 100) external_sfx_volume = 100;
514: 	if (external_voice_volume > 100) external_voice_volume = 100;
515: 	if (external_ambient_volume > 100) external_ambient_volume = 100;
516: 	if (ffmpeg_video_volume > 100) ffmpeg_video_volume = 100;
517: 
518: 	// GAME LIGHTING
519: 	if (ff8) game_lighting = GAME_LIGHTING_ORIGINAL;
520: 	else if (enable_lighting) game_lighting = GAME_LIGHTING_PER_PIXEL;
521: 
522: 	// DISPLAY INDEX
523: 	if (display_index < 1) display_index = -1;
524: }
</file>

<file path="src/cfg.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <string>
 26: #include <vector>
 27: 
 28: #define RENDERER_BACKEND_AUTO 0
 29: #define RENDERER_BACKEND_OPENGL 1
 30: // Slot 2 used to be used for DIRECT3D9 but is not more officially supported by bgfx.
 31: // Preserve the slot numbers as they are to ensure compatibility with existing installations and tooling.
 32: #define RENDERER_BACKEND_DIRECT3D11 3
 33: #define RENDERER_BACKEND_DIRECT3D12 4
 34: #define RENDERER_BACKEND_VULKAN 5
 35: 
 36: #define FPS_LIMITER_ORIGINAL 0
 37: #define FPS_LIMITER_DEFAULT 1
 38: #define FPS_LIMITER_30FPS 2
 39: #define FPS_LIMITER_60FPS 3
 40: 
 41: #define GAME_LIGHTING_ORIGINAL 0
 42: #define GAME_LIGHTING_PER_VERTEX 1
 43: #define GAME_LIGHTING_PER_PIXEL 2
 44: 
 45: extern std::string mod_path;
 46: extern std::vector<std::string> mod_ext;
 47: extern long enable_ffmpeg_videos;
 48: extern std::string ffmpeg_video_ext;
 49: extern std::vector<std::string> external_movie_audio_ext;
 50: extern bool use_external_sfx;
 51: extern std::string external_sfx_path;
 52: extern std::vector<std::string> external_sfx_ext;
 53: extern bool external_sfx_always_centered;
 54: extern bool use_external_music;
 55: extern bool external_music_resume;
 56: extern bool external_music_sync;
 57: extern std::string external_music_path;
 58: extern std::vector<std::string> external_music_ext;
 59: extern std::string he_bios_path;
 60: extern std::string external_voice_path;
 61: extern std::vector<std::string> external_voice_ext;
 62: extern std::string external_ambient_path;
 63: extern std::vector<std::string> external_ambient_ext;
 64: extern std::string external_lighting_path;
 65: extern std::string external_widescreen_path;
 66: extern std::string external_time_cycle_path;
 67: extern std::string external_mesh_path;
 68: extern bool enable_voice_music_fade;
 69: extern long external_voice_music_fade_volume;
 70: extern bool enable_voice_auto_text;
 71: extern bool save_textures;
 72: extern bool save_textures_legacy;
 73: extern bool save_exe_data;
 74: extern bool trace_all;
 75: extern bool trace_renderer;
 76: extern bool trace_movies;
 77: extern bool trace_music;
 78: extern bool trace_sfx;
 79: extern bool trace_fake_dx;
 80: extern bool trace_direct;
 81: extern bool trace_files;
 82: extern bool trace_loaders;
 83: extern bool trace_vram;
 84: extern bool trace_lights;
 85: extern bool trace_opcodes;
 86: extern bool trace_voice;
 87: extern bool trace_ambient;
 88: extern bool trace_gamepad;
 89: extern bool trace_achievement;
 90: extern bool trace_battle_animation;
 91: extern bool trace_battle_text;
 92: extern bool vertex_log;
 93: extern bool uniform_log;
 94: extern bool show_renderer_backend;
 95: extern bool show_fps;
 96: extern bool show_stats;
 97: extern bool show_version;
 98: extern long window_size_x;
 99: extern long window_size_y;
100: extern long internal_resolution_scale;
101: extern long aspect_ratio;
102: extern bool enable_uncrop;
103: extern bool fullscreen;
104: extern bool borderless;
105: extern long refresh_rate;
106: extern bool enable_vsync;
107: extern bool mdef_fix;
108: extern long enable_antialiasing;
109: extern bool enable_anisotropic;
110: extern bool enable_bilinear;
111: extern bool enable_lighting;
112: extern bool prefer_lighting_cpu_calculations;
113: extern long game_lighting;
114: extern bool enable_time_cycle;
115: extern bool enable_worldmap_external_mesh;
116: extern bool ff7_external_opening_music;
117: extern bool more_debug;
118: extern bool ff8_ssigpu_debug;
119: extern bool show_applog;
120: extern bool show_missing_textures;
121: extern bool show_error_popup;
122: extern long renderer_backend;
123: extern bool renderer_debug;
124: extern bool create_crash_dump;
125: extern std::string steam_game_userdata;
126: extern std::string hext_patching_path;
127: extern std::string override_path;
128: extern std::string override_mod_path;
129: extern std::string direct_mode_path;
130: extern std::string save_path;
131: extern bool enable_devtools;
132: extern long devtools_hotkey;
133: extern double speedhack_step;
134: extern double speedhack_max;
135: extern double speedhack_min;
136: extern bool enable_animated_textures;
137: extern std::vector<std::string> disable_animated_textures_on_field;
138: extern long ff7_fps_limiter;
139: extern bool ff7_footsteps;
140: extern bool ff7_field_center;
141: extern bool enable_analogue_controls;
142: extern bool enable_inverted_vertical_camera_controls;
143: extern bool enable_inverted_horizontal_camera_controls;
144: extern double left_analog_stick_deadzone;
145: extern double right_analog_stick_deadzone;
146: extern double left_analog_trigger_deadzone;
147: extern double right_analog_trigger_deadzone;
148: extern bool enable_auto_run;
149: extern std::string external_vibrate_path;
150: extern bool enable_steam_achievements;
151: extern bool steam_achievements_debug_mode;
152: extern double hdr_max_nits;
153: extern long external_audio_number_of_channels;
154: extern long external_audio_sample_rate;
155: extern bool ff8_worldmap_internal_highres_textures;
156: extern bool ff8_fix_uv_coords_precision;
157: extern bool ff8_external_music_force_original_filenames;
158: extern bool ff8_use_gamepad_icons;
159: extern bool ff8_always_capture_input;
160: extern long ff8_fps_limiter;
161: extern std::string app_path;
162: extern std::string data_drive;
163: extern bool enable_ntscj_gamut_mode;
164: extern long external_music_volume;
165: extern long external_sfx_volume;
166: extern long external_voice_volume;
167: extern long external_ambient_volume;
168: extern long ffmpeg_video_volume;
169: extern bool ff7_advanced_blinking;
170: extern long display_index;
171: 
172: void read_cfg();
</file>

<file path="src/common_imports.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #pragma once
 23: 
 24: #include <windows.h>
 25: #include <stdint.h>
 26: 
 27: #include "matrix.h"
 28: 
 29: /*
 30:  * Render states supported by the graphics engine
 31:  *
 32:  * Not all of these were implemented in the original games, even fewer are
 33:  * actually required. Named after corresponding Direct3D states.
 34:  */
 35: enum effects
 36: {
 37: 	V_WIREFRAME,			      // 0x1
 38: 	V_TEXTURE,				      // 0x2
 39: 	V_LINEARFILTER,			    // 0x4
 40: 	V_PERSPECTIVE,			    // 0x8
 41: 	V_TMAPBLEND,			      // 0x10
 42: 	V_WRAP_U,				        // 0x20
 43: 	V_WRAP_V,				        // 0x40
 44: 	V_UNKNOWN80,			      // 0x80
 45: 	V_COLORKEY,				      // 0x100
 46: 	V_DITHER,				        // 0x200
 47: 	V_ALPHABLEND,			      // 0x400
 48: 	V_ALPHATEST,			      // 0x800
 49: 	V_ANTIALIAS,			      // 0x1000
 50: 	V_CULLFACE,				      // 0x2000
 51: 	V_NOCULL,				        // 0x4000
 52: 	V_DEPTHTEST,			      // 0x8000
 53: 	V_DEPTHMASK,			      // 0x10000
 54: 	V_SHADEMODE,			      // 0x20000
 55: 	V_SPECULAR,				      // 0x40000
 56: 	V_LIGHTSTATE,			      // 0x80000
 57: 	V_FOG,					        // 0x100000
 58: 	V_TEXADDR,				      // 0x200000
 59: 	V_UNKNOWN400000,        // 0x400000
 60: 	V_UNKNOWN800000,        // 0x800000
 61: 	V_ALPHAFUNC,            // 0x1000000
 62: 	V_ALPHAREF,             // 0x2000000
 63: 	V_UNKNOWNFFFDFBFD,      // 0xFFFDFBFD
 64: 	V_UNKNOWNFFFDFFFD,      // 0xFFFDFFFD
 65: };
 66: 
 67: // helper definitions for all the different functions which should be provided by the graphics driver
 68: typedef uint32_t (gfx_init)(struct game_obj *);
 69: typedef void (gfx_cleanup)(struct game_obj *);
 70: typedef uint32_t (gfx_lock)(uint32_t);
 71: typedef uint32_t (gfx_unlock)(uint32_t);
 72: typedef void (gfx_flip)(struct game_obj *);
 73: typedef void (gfx_clear)(uint32_t, uint32_t, uint32_t, struct game_obj *);
 74: typedef void (gfx_clear_all)(struct game_obj *);
 75: typedef void (gfx_setviewport)(uint32_t, uint32_t, uint32_t, uint32_t, struct game_obj *);
 76: typedef void (gfx_setbg)(struct bgra_color *, struct game_obj *);
 77: typedef uint32_t (gfx_prepare_polygon_set)(struct polygon_set *);
 78: typedef uint32_t (gfx_load_group)(uint32_t, struct matrix_set *, struct p_hundred *, struct p_group *, struct polygon_data *, struct polygon_set *, struct game_obj *);
 79: typedef void (gfx_setmatrix)(uint32_t, struct matrix *, struct matrix_set *, struct game_obj *);
 80: typedef void (gfx_unload_texture)(struct texture_set *);
 81: typedef struct texture_set *(gfx_load_texture)(struct texture_set *, struct tex_header *, struct texture_format *);
 82: typedef uint32_t (gfx_palette_changed)(uint32_t, uint32_t, uint32_t, struct palette *, struct texture_set *);
 83: typedef uint32_t (gfx_write_palette)(uint32_t, uint32_t, void *, uint32_t, struct palette *, struct texture_set *);
 84: typedef struct blend_mode *(gfx_blendmode)(uint32_t, struct game_obj *);
 85: typedef void (gfx_light_polygon_set)(struct polygon_set *, struct light *);
 86: typedef void (gfx_field_64)(uint32_t, uint32_t, struct game_obj *);
 87: typedef void (gfx_setrenderstate)(struct p_hundred *, struct game_obj *);
 88: typedef void (gfx_field_74)(uint32_t, struct game_obj *);
 89: typedef void (gfx_field_78)(struct polygon_set *, struct game_obj *);
 90: typedef void (gfx_draw_deferred)(struct struc_77 *, struct game_obj *);
 91: typedef void (gfx_field_80)(struct graphics_object *, struct game_obj *);
 92: typedef void (gfx_field_84)(uint32_t, struct game_obj *);
 93: typedef uint32_t (gfx_begin_scene)(uint32_t, struct game_obj *);
 94: typedef void (gfx_end_scene)(struct game_obj *);
 95: typedef void (gfx_field_90)(uint32_t);
 96: typedef void (gfx_polysetrenderstate)(struct polygon_set *, struct indexed_vertices *, struct game_obj *);
 97: typedef void (gfx_draw_vertices)(struct polygon_set *, struct indexed_vertices *, struct game_obj *);
 98: typedef void (gfx_field_EC)(struct game_obj *);
 99: 
100: /*
101:  * This section defines some structures used internally by both game engines.
102:  *
103:  * Documentation for some of them can be found on the Qhimm wiki, a lot of
104:  * information can be gleaned from the source code to this program but in many
105:  * cases nothing is known except the size and general layout of the structure.
106:  *
107:  * Variable and structure names are mostly based on what they contain rather
108:  * than what they are for, a lot of names may be wrong, inappropriate or
109:  * downright misleading. Thread with caution!
110:  */
111: 
112: struct color_ui8
113: {
114:     byte r;
115:     byte g;
116:     byte b;
117:     byte a;
118: };
119: 
120: struct bgra_color_ui8
121: {
122:     byte b;
123:     byte g;
124:     byte r;
125:     byte a;
126: };
127: 
128: struct bgra_color
129: {
130: 	float b;
131: 	float g;
132: 	float r;
133: 	float a;
134: };
135: 
136: struct rgba_color
137: {
138: 	float r;
139: 	float g;
140: 	float b;
141: 	float a;
142: };
143: 
144: typedef struct {
145: 	short x, y, z, res;		// short is a 2 byte signed integer
146: } vertex_3s;
147: 
148: struct struc_81
149: {
150: 	uint32_t field_0;
151: 	uint32_t field_4;
152: 	uint32_t field_8;
153: 	uint32_t field_C;
154: 	uint32_t field_10;
155: 	uint32_t field_14;
156: 	uint32_t field_18;
157: 	uint32_t field_1C;
158: 	uint32_t blend_mode;
159: 	uint32_t vertexcolor;
160: 	struct texture_set *texture_set;
161: };
162: 
163: struct struc_173
164: {
165: 	unsigned char color_op;
166: 	unsigned char field_1;
167: 	unsigned char scroll_uv;
168: 	unsigned char scroll_v;
169: 	unsigned char change_palette;
170: 	unsigned char setrenderstate;
171: 	unsigned char add_offsets;
172: 	unsigned char field_7;
173: 	color_ui8 color;
174: 	uint32_t field_C;
175: 	uint32_t field_10;
176: 	uint32_t x_offset;
177: 	uint32_t y_offset;
178: 	uint32_t z_offset;
179: 	uint32_t z_offset2;
180: 	float u_offset;
181: 	float v_offset;
182: 	uint32_t palette_index;
183: 	struct p_hundred *hundred_data;
184: 	unsigned char field_34[16];
185: };
186: 
187: struct struc_77
188: {
189: 	struct struc_77 *next;
190: 	uint32_t current_group;
191: 	struct polygon_set *polygon_set;
192: 	struct p_hundred *hundred_data;
193: 	uint32_t use_matrix;
194: 	struct matrix matrix;
195: 	uint32_t use_matrix_pointer;
196: 	struct matrix *matrix_pointer;
197: 	struct struc_173 struc_173;
198: };
199: 
200: struct heap
201: {
202: 	struct heap *next;
203: 	uint32_t size;					// ?
204: 	struct heap *last;			// ?
205: 	uint32_t field_C;
206: 	uint32_t field_10;
207: 	uint32_t field_14;
208: 	int (*fn_something)(uint32_t, int);
209: 	uint32_t field_1C;
210: 	uint32_t field_20;
211: 	uint32_t field_24;
212: 	uint32_t field_28;
213: 	uint32_t field_2C;
214: 	uint32_t field_30;
215: 	void *callback_data;
216: 	void *callback;
217: };
218: 
219: struct graphics_instance
220: {
221: 	uint32_t frame_counter;
222: 	struct heap *heap;
223: };
224: 
225: struct p_edge
226: {
227: 	WORD vertex1;
228: 	WORD vertex2;
229: };
230: 
231: struct texcoords
232: {
233: 	float u;
234: 	float v;
235: };
236: 
237: struct p_polygon
238: {
239: 	WORD field_0;
240: 	WORD vertex1;
241: 	WORD vertex2;
242: 	WORD vertex3;
243: 	WORD normals[3];
244: 	WORD edges[3];
245: 	uint32_t field_14;
246: };
247: 
248: struct p_group
249: {
250: 	uint32_t polytype;
251: 	uint32_t offpoly;
252: 	uint32_t numpoly;
253: 	uint32_t offvert;
254: 	uint32_t numvert;
255: 	uint32_t offedge;
256: 	uint32_t numedge;
257: 	uint32_t field_1C;
258: 	uint32_t field_20;
259: 	uint32_t field_24;
260: 	uint32_t field_28;
261: 	uint32_t offtex;
262: 	uint32_t textured;
263: 	uint32_t texid;
264: };
265: 
266: struct boundingbox
267: {
268: 	uint32_t field_0;
269: 	float max_x;
270: 	float max_y;
271: 	float max_z;
272: 	float min_x;
273: 	float min_y;
274: 	float min_z;
275: };
276: 
277: struct nvertex
278: {
279: 	vector3<float> _;
280: 
281: 	union
282: 	{
283: 		struct
284: 		{
285: 			float w;
286: 			union
287: 			{
288: 				uint32_t color;
289: 				struct
290: 				{
291: 					unsigned char b;
292: 					unsigned char g;
293: 					unsigned char r;
294: 					unsigned char a;
295: 				};
296: 			};
297: 			uint32_t specular;
298: 		} color;
299: 
300: 		vector3<float> normal;
301: 	};
302: 
303: 	float u;
304: 	float v;
305: };
306: 
307: struct struc_186
308: {
309: 	struct graphics_object *graphics_object;
310: 	uint32_t polytype;
311: 	uint32_t field_8;
312: 	vector3<float> vertices[4];
313: 	struct texcoords texcoords[4];
314: 	color_ui8 colors[4];
315: 	float w[4];
316: 	struct nvertex *nvertex_pointer;
317: 	uint32_t palette_index;
318: };
319: 
320: struct struc_84
321: {
322: 	struct struc_84 *next;
323: 	uint32_t field_4;
324: 	struct struc_186 *struc_186;
325: 	struct matrix matrix;
326: 	struct struc_173 struc_173;
327: };
328: 
329: struct struc_49
330: {
331: 	uint32_t field_0;
332: 	uint32_t field_4;
333: 	uint32_t field_8;
334: 	uint32_t frame_counter;
335: 	struct struc_84 *struc_84;
336: 	struct graphics_instance *graphics_instance;
337: };
338: 
339: struct indexed_primitive
340: {
341: 	uint32_t field_0;
342: 	uint32_t vertex_size;
343: 	uint32_t primitivetype;
344: 	uint32_t vertextype;
345: 	struct nvertex *vertices;
346: 	uint32_t vertexcount;
347: 	WORD *indices;
348: 	uint32_t indexcount;
349: 	uint32_t flags;
350: 	uint32_t field_24;
351: };
352: 
353: struct matrix_set
354: {
355: 	uint32_t field_0;
356: 	uint32_t size;
357: 	uint32_t field_8;
358: 	uint32_t field_C;
359: 	struct matrix *matrix_array;
360: 	struct matrix *matrix_world;
361: 	struct matrix *matrix_view;
362: 	struct matrix *matrix_projection;
363: 	void *d3dmatrix_world;
364: 	void *d3dmatrix_view;
365: 	void *d3dmatrix_projection;
366: };
367: 
368: struct polygon_data
369: {
370: 	uint32_t version;
371: 	uint32_t field_4;
372: 	uint32_t vertextype;
373: 	uint32_t numverts;
374: 	uint32_t numnormals;
375: 	uint32_t field_14;
376: 	uint32_t numtexcoords;
377: 	uint32_t numvertcolors;
378: 	uint32_t numedges;
379: 	uint32_t numpolys;
380: 	uint32_t field_28;
381: 	uint32_t field_2C;
382: 	uint32_t numhundreds;
383: 	uint32_t numgroups;
384: 	uint32_t numboundingboxes;
385: 	uint32_t has_normindextable;
386: 	vector3<float> *vertdata;
387: 	vector3<float> *normaldata;
388: 	vector3<float> *field_48;
389: 	struct texcoords *texcoorddata;
390: 	uint32_t *vertexcolordata;
391: 	uint32_t *polycolordata;
392: 	struct p_edge *edgedata;
393: 	struct p_polygon *polydata;
394: 	char *pc_name;
395: 	void *field_64;
396: 	struct p_hundred *hundredsdata;
397: 	struct p_group *groupdata;
398: 	struct boundingbox *boundingboxdata;
399: 	uint32_t *normindextabledata;
400: 	uint32_t field_78;
401: 	struct polygon_lists *lists;
402: };
403: 
404: struct p_hundred
405: {
406: 	uint32_t field_0;
407: 	uint32_t field_4;
408: 	uint32_t options;
409: 	uint32_t features;
410: 	uint32_t field_10;
411: 	struct texture_set *texture_set;
412: 	uint32_t field_18;
413: 	uint32_t field_1C;
414: 	uint32_t field_20;
415: 	uint32_t shademode;
416: 	uint32_t lightstate_ambient;
417: 	uint32_t field_2C;
418: 	void *lightstate_material_pointer;
419: 	uint32_t srcblend;
420: 	uint32_t destblend;
421: 	uint32_t field_3C;
422: 	uint32_t alpharef;
423: 	uint32_t blend_mode;
424: 	uint32_t zsort;
425: 	uint32_t field_4C;
426: 	uint32_t field_50;
427: 	uint32_t field_54;
428: 	uint32_t field_58;
429: 	uint32_t vertex_alpha;
430: 	uint32_t field_60;
431: };
432: 
433: struct texture_format
434: {
435: 	uint32_t width;
436: 	uint32_t height;
437: 	uint32_t bytesperrow;
438: 	void *field_C;
439: 	uint32_t use_palette;
440: 	uint32_t bitsperindex;
441: 	uint32_t indexed_to_8bit;
442: 	uint32_t palette_size;				// ?
443: 	uint32_t palettes;					// ?
444: 	uint32_t *palette_data;
445: 	uint32_t bitsperpixel;
446: 	uint32_t bytesperpixel;
447: 	uint32_t red_bits;
448: 	uint32_t green_bits;
449: 	uint32_t blue_bits;
450: 	uint32_t alpha_bits;
451: 	uint32_t red_mask;
452: 	uint32_t green_mask;
453: 	uint32_t blue_mask;
454: 	uint32_t alpha_mask;
455: 	uint32_t red_shift;
456: 	uint32_t green_shift;
457: 	uint32_t blue_shift;
458: 	uint32_t alpha_shift;
459: 	uint32_t red_truecolor_bitdiff;		// 8 - red_bits
460: 	uint32_t green_truecolor_bitdiff;	// 8 - green_bits
461: 	uint32_t blue_truecolor_bitdiff;	// etc
462: 	uint32_t alpha_truecolor_bitdiff;
463: 	uint32_t red_max;
464: 	uint32_t green_max;
465: 	uint32_t blue_max;
466: 	uint32_t alpha_max;
467: };
468: 
469: struct struc_91
470: {
471: 	uint32_t field_0;
472: 	uint32_t x_offset;
473: 	uint32_t y_offset;
474: 	uint32_t width;
475: 	uint32_t height;
476: 	uint32_t xscale;
477: 	uint32_t yscale;
478: 	uint32_t color_key;
479: 	uint32_t width2;
480: 	uint32_t height2;
481: 	uint32_t pitch2;
482: 	uint32_t bytesperpixel2;
483: 	void *image_data2;
484: 	struct texture_format tex_format;
485: 	void *image_data;
486: };
487: 
488: struct palette
489: {
490: 	uint32_t field_0;
491: 	uint32_t palette_size;
492: 	uint32_t bitsperpixel;
493: 	uint32_t total_palettes;
494: 	uint32_t palette_entries;
495: 	uint32_t field_14;
496: 	uint32_t field_18;
497: 	uint32_t field_1C;
498: 	uint32_t field_20;
499: 	void *d3dcolorpal;
500: 	void *rgbapal;
501: 	void *palette_entry;
502: 	uint32_t ddpalette;
503: 	tex_header* tex_header;
504: 	texture_set* texture_set;
505: 	uint32_t field_3C;
506: };
507: 
508: struct blend_mode
509: {
510: 	uint32_t field_0;
511: 	uint32_t zsort;
512: 	uint32_t vertex_alpha;
513: 	uint32_t srcblendmode;
514: 	uint32_t srcblendcaps;
515: 	uint32_t destblendmode;
516: 	uint32_t destblendcaps;
517: 	uint32_t field_1C;
518: 	uint32_t field_20;
519: };
520: 
521: typedef struct
522: {
523: 	char dummy[0xCC];
524: } D3DDEVICEDESC;
525: 
526: typedef void* main_obj_fn(struct game_obj*);
527: 
528: struct main_obj
529: {
530: 	main_obj_fn *init;
531: 	main_obj_fn *cleanup;
532: 	main_obj_fn *enter_main;
533: 	main_obj_fn *exit_main;
534: 	main_obj_fn *main_loop;
535: 	main_obj_fn *field_14;
536: 	main_obj_fn *field_18;
537: };
</file>

<file path="src/common.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2020 Marcin Gomulak                                     //
   9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  10: //    Copyright (C) 2023 Cosmos                                             //
  11: //                                                                          //
  12: //    This file is part of FFNx                                             //
  13: //                                                                          //
  14: //    FFNx is free software: you can redistribute it and/or modify          //
  15: //    it under the terms of the GNU General Public License as published by  //
  16: //    the Free Software Foundation, either version 3 of the License         //
  17: //                                                                          //
  18: //    FFNx is distributed in the hope that it will be useful,               //
  19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  21: //    GNU General Public License for more details.                          //
  22: /****************************************************************************/
  23: 
  24: #include <windows.h>
  25: #include <windowsx.h>
  26: #include <dwmapi.h>
  27: #include <stdio.h>
  28: #include <sys/timeb.h>
  29: #include <steamworkssdk/steam_api.h>
  30: #include <hwinfo/hwinfo.h>
  31: #include <regex>
  32: #include <shlwapi.h>
  33: #include <shlobj.h>
  34: #include <psapi.h>
  35: #include <mmsystem.h>
  36: #include <malloc.h>
  37: #include <ddraw.h>
  38: #include <filesystem>
  39: #include <fstream>
  40: 
  41: #include "renderer.h"
  42: #include "hext.h"
  43: #include "ff8_data.h"
  44: 
  45: #include "crashdump.h"
  46: #include "macro.h"
  47: #include "ff7.h"
  48: #include "ff8.h"
  49: #include "patch.h"
  50: #include "gl.h"
  51: #include "movies.h"
  52: #include "music.h"
  53: #include "sfx.h"
  54: #include "saveload.h"
  55: #include "gamepad.h"
  56: #include "joystick.h"
  57: #include "input.h"
  58: #include "field.h"
  59: #include "world.h"
  60: #include "gamehacks.h"
  61: #include "audio.h"
  62: #include "voice.h"
  63: #include "metadata.h"
  64: #include "lighting.h"
  65: #include "achievement.h"
  66: #include "game_cfg.h"
  67: #include "exe_data.h"
  68: #include "utils.h"
  69: 
  70: #include "ff7/defs.h"
  71: #include "ff7/widescreen.h"
  72: #include "ff7/time.h"
  73: #include "ff7/field/defs.h"
  74: 
  75: #include "ff8/vram.h"
  76: #include "ff8/vibration.h"
  77: #include "ff8/engine.h"
  78: #include "ff8/uv_patch.h"
  79: #include "ff8/ambient.h"
  80: #include "ff8/file.h"
  81: 
  82: #include "wine.h"
  83: 
  84: bool proxyWndProc = false;
  85: 
  86: namespace GameWindowState {
  87: 	enum GameWindowState
  88: 	{
  89: 		CURRENT,
  90: 		PRE_FULLSCREEN,
  91: 		COUNT
  92: 	};
  93: };
  94: 
  95: struct {
  96: 	uint32_t x;
  97: 	uint32_t y;
  98: 	uint32_t w;
  99: 	uint32_t h;
 100: } gameWindow[GameWindowState::COUNT];
 101: 
 102: struct MonitorInfo {
 103: 	RECT rcMonitor;
 104: 	std::string deviceName;
 105: };
 106: std::vector<MonitorInfo> monitors;
 107: 
 108: // global game window handler
 109: RECT gameWindowRect;
 110: HINSTANCE gameHinstance;
 111: HWND gameHwnd;
 112: DEVMODE dmCurrentScreenSettings;
 113: DEVMODE dmNewScreenSettings;
 114: bool gameWindowWasMaximized = false;
 115: bool gameWindowMoving = false;
 116: 
 117: // global RAM status
 118: MEMORYSTATUSEX last_ram_state = { sizeof(last_ram_state) };
 119: 
 120: // global FF7/FF8 flag, available after version check
 121: uint32_t ff8 = false;
 122: 
 123: uint32_t ff7_do_reset = false;
 124: 
 125: // global FF7/FF8 flag, check if is steam edition
 126: uint32_t steam_edition = false;
 127: 
 128: // global FF7/FF8 flag, check if using the steam stock launcher
 129: uint32_t steam_stock_launcher = false;
 130: 
 131: // global FF7 flag, check if is eStore edition
 132: uint32_t estore_edition = false;
 133: 
 134: // global FF7 flag, check if is japanese edition ( detected as US )
 135: uint32_t ff7_japanese_edition = false;
 136: 
 137: // window dimensions requested by the game, normally 640x480
 138: uint32_t game_width;
 139: uint32_t game_height;
 140: 
 141: // offset from screen edge to start of content, for aspect correction
 142: uint32_t x_offset = 0;
 143: uint32_t y_offset = 0;
 144: 
 145: // widescreen mode enabled
 146: uint32_t widescreen_enabled = false;
 147: 
 148: // game-specific data, see ff7_data.h/ff8_data.h
 149: uint32_t text_colors[NUM_TEXTCOLORS];
 150: struct game_mode modes[64];
 151: uint32_t num_modes;
 152: 
 153: // memory locations, replaced functions or patching offsets
 154: // some addresses in FF7 are sourced from static tables in the
 155: // externals_102_xx.h files but most of them are computed at runtime,
 156: // see ff7_data.h/ff8_data.h
 157: struct common_externals common_externals;
 158: struct ff7_externals ff7_externals;
 159: struct ff8_externals ff8_externals;
 160: 
 161: // various statistics, collected for display purposes only EXCEPT for the
 162: // external cache size
 163: struct driver_stats stats;
 164: 
 165: // on-screen popup messages
 166: char popup_msg[1024];
 167: uint32_t popup_ttl = 0;
 168: uint32_t popup_color;
 169: 
 170: // scene stack used to save render state when the game calls begin/end scene
 171: struct driver_state scene_stack[8];
 172: uint32_t scene_stack_pointer = 0;
 173: 
 174: // global frame counter
 175: uint32_t frame_counter = 0;
 176: double frame_rate = 0;
 177: int battle_frame_multiplier = 1;
 178: int common_frame_multiplier = 1;
 179: 
 180: // default 32-bit BGRA texture format presented to the game
 181: struct texture_format *texture_format;
 182: 
 183: // install directory for the current game
 184: char basedir[BASEDIR_LENGTH];
 185: 
 186: uint32_t version;
 187: 
 188: bool xinput_connected = false;
 189: 
 190: bool simulate_OK_button = false;
 191: 
 192: GamepadAnalogueIntent gamepad_analogue_intent = INTENT_NONE;
 193: 
 194: uint32_t *image_data_cache = nullptr;
 195: uint32_t image_data_size_cache = 0;
 196: 
 197: uint32_t noop() { return 0; }
 198: uint32_t noop_a1(uint32_t a1) { return 0; }
 199: uint32_t noop_a2(uint32_t a1, uint32_t a2) { return 0; }
 200: uint32_t noop_a3(uint32_t a1, uint32_t a2, uint32_t a3) { return 0; }
 201: 
 202: // global data used for profiling macros
 203: #ifdef PROFILE
 204: time_t profile_start;
 205: time_t profile_end;
 206: time_t profile_total;
 207: #endif PROFILE
 208: 
 209: // support code for the HEAP_DEBUG option
 210: #ifdef HEAP_DEBUG
 211: uint32_t allocs = 0;
 212: 
 213: void *driver_malloc(uint32_t size)
 214: {
 215: 	void *tmp = malloc(size);
 216: 	ffnx_trace("%i: malloc(%i) = 0x%x\n", ++allocs, size, tmp);
 217: 	return tmp;
 218: }
 219: 
 220: void *driver_calloc(uint32_t size, uint32_t num)
 221: {
 222: 	void *tmp = calloc(size, num);
 223: 	ffnx_trace("%i: calloc(%i, %i) = 0x%x\n", ++allocs, size, num, tmp);
 224: 	return tmp;
 225: }
 226: 
 227: void driver_free(void *ptr)
 228: {
 229: 	if(!ptr) return;
 230: 
 231: 	ffnx_trace("%i: free(0x%x)\n", --allocs, ptr);
 232: 	free(ptr);
 233: }
 234: 
 235: void *driver_realloc(void *ptr, uint32_t size)
 236: {
 237: 	void *tmp = realloc(ptr, size);
 238: 	ffnx_trace("%i: realloc(0x%x, %i) = 0x%x\n", allocs, ptr, size, tmp);
 239: 	return tmp;
 240: }
 241: #endif
 242: 
 243: // support code for the NO_EXT_HEAP option
 244: #ifdef NO_EXT_HEAP
 245: 
 246: void ext_free(void *ptr, const char *file, uint32_t line)
 247: {
 248: 	driver_free(ptr);
 249: }
 250: 
 251: void *ext_malloc(uint32_t size, const char *file, uint32_t line)
 252: {
 253: 	return driver_malloc(size);
 254: }
 255: 
 256: void *ext_calloc(uint32_t size, uint32_t num, const char *file, uint32_t line)
 257: {
 258: 	return driver_calloc(size, num);
 259: }
 260: #endif
 261: 
 262: void ffmpeg_log_callback(void* ptr, int level, const char* fmt, va_list vl)
 263: {
 264: 	char msg[4 * 1024]; // 4K
 265: 	static int print_prefix = 1;
 266: 
 267: 	av_log_format_line(ptr, level, fmt, vl, msg, sizeof(msg), &print_prefix);
 268: 
 269: 	switch (level) {
 270: 	case AV_LOG_VERBOSE:
 271: 	case AV_LOG_DEBUG: if (trace_movies) ffnx_trace(msg); break;
 272: 	case AV_LOG_INFO:
 273: 	case AV_LOG_WARNING: if (trace_movies) ffnx_info(msg); break;
 274: 	case AV_LOG_ERROR:
 275: 	case AV_LOG_FATAL:
 276: 	case AV_LOG_PANIC: ffnx_error(msg); break;
 277: 	}
 278: 
 279: 	if (level <= AV_LOG_ERROR) {
 280: 		FFNxStackWalker sw;
 281: 		sw.ShowCallstack();
 282: 	}
 283: }
 284: 
 285: void ffnx_log_current_pc_specs()
 286: {
 287: 	// Start report of PC specs
 288: 	ffnx_info("--- PC SPECS ---\n");
 289: 
 290: 	// CPU
 291: 	auto cpus = hwinfo::getAllCPUs();
 292: 	for (const auto& cpu : cpus) {
 293: 		ffnx_info("   CPU: %s\n", cpu.modelName().c_str());
 294: 	}
 295: 
 296: 	// GPU
 297: 	auto gpus = hwinfo::getAllGPUs();
 298: 	for (auto& gpu : gpus) {
 299: 		uint16_t vendorId = std::stoi(gpu.vendor_id(), 0, 16), deviceId = std::stoi(gpu.device_id(), 0, 16);
 300: 		if (
 301: 			(newRenderer.getCaps()->vendorId == vendorId && newRenderer.getCaps()->deviceId == deviceId) ||
 302: 			(newRenderer.getCaps()->vendorId == vendorId && renderer_backend == RENDERER_BACKEND_OPENGL)
 303: 		)
 304: 			ffnx_info("   GPU: %s (%dMB) - Driver: %s - Backend: %s\n", gpu.name().c_str(), (int)(gpu.memory_Bytes() / 1024.0 / 1024.0), gpu.driverVersion().c_str(), newRenderer.currentRenderer.c_str());
 305: 	}
 306: 
 307: 	// RAM
 308: 	hwinfo::Memory memory;
 309: 	ffnx_info("   RAM: %dMB/%dMB (Free: %dMB)\n", (int)((memory.total_Bytes() - memory.free_Bytes()) / 1024.0 / 1024.0), (int)(memory.total_Bytes() / 1024.0 / 1024.0), (int)(memory.free_Bytes() / 1024.0 / 1024.0));
 310: 
 311: 	// OS
 312: 	hwinfo::OS os;
 313: 	ffnx_info("    OS: %s %s (build %s)\n", os.name().c_str(), (os.is32bit() ? "32 bit" : "64 bit"), os.version().c_str());
 314: 
 315: 	// WINE+PROTON
 316: 	const char* env_wineloader = std::getenv("WINELOADER");
 317: 	if (env_wineloader != NULL) // Are we running under Wine/Proton?
 318: 	{
 319: 		ffnx_info("  WINE: v%s\n", GetWineVersion());
 320: 
 321: 		const std::regex proton_regex("([Pp]roton[\\s\\-\\w.()]+)");
 322: 		std::smatch base_match;
 323: 		std::string s_wineloader = std::string(env_wineloader);
 324: 		if (std::regex_search(s_wineloader, base_match, proton_regex))
 325: 			ffnx_info("PROTON: %s\n", base_match[1].str().c_str());
 326: 	}
 327: 
 328: 	// End report of PC specs
 329: 	ffnx_info("----------------\n");
 330: }
 331: 
 332: // figure out which game module is currently running by looking at the game's
 333: // own mode variable and the address of the current main function
 334: struct game_mode *getmode()
 335: {
 336: 	static uint32_t last_mode = 0;
 337: 	VOBJ(game_obj, game_object, common_externals.get_game_object());
 338: 	uint32_t i;
 339: 
 340: 	// find exact match, mode and main loop both match
 341: 	for(i = 0; i < num_modes; i++)
 342: 	{
 343: 		struct game_mode *m = &modes[i];
 344: 
 345: 		if(m->main_loop == (uint32_t)VREF(game_object, game_loop_obj).main_loop && m->mode == *common_externals._mode)
 346: 		{
 347: 			if(last_mode != m->mode)
 348: 			{
 349: 				if(m->trace) ffnx_trace("%s\n", m->name);
 350: 				last_mode = m->mode;
 351: 			}
 352: 
 353: 			if (trace_all) ffnx_trace("getmode: exact match - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);
 354: 
 355: 			return m;
 356: 		}
 357: 	}
 358: 
 359: 	// FF8 has BATTLE and CARDGAME baked inside the same module
 360: 	// Only for this case use a custom match logic
 361: 	if (ff8)
 362: 	{
 363: 		for(i = 0; i < num_modes; i++)
 364: 		{
 365: 			struct game_mode *m = &modes[i];
 366: 
 367: 			if (*ff8_externals.is_card_game == 1 && *common_externals._mode == m->mode)
 368: 			{
 369: 				if (trace_all) ffnx_trace("getmode: exact match - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);
 370: 
 371: 				return m;
 372: 			}
 373: 		}
 374: 	}
 375: 
 376: 	// if there is no exact match, try to find a match by main loop only
 377: 	for(i = 0; i < num_modes; i++)
 378: 	{
 379: 		struct game_mode *m = &modes[i];
 380: 
 381: 		if(m->main_loop && m->main_loop == (uint32_t)VREF(game_object, game_loop_obj).main_loop)
 382: 		{
 383: 			if(last_mode != m->mode)
 384: 			{
 385: 				if(m->mode != *common_externals._mode && m->trace)
 386: 				{
 387: 					uint32_t j;
 388: 					struct game_mode *_m = NULL;
 389: 
 390: 					for(j = 0; j < num_modes - 1; j++)
 391: 					{
 392: 						_m = &modes[j];
 393: 
 394: 						if(_m->mode == *common_externals._mode) break;
 395: 					}
 396: 
 397: 					if (trace_all) ffnx_trace("getmode: mismatched mode, %s -> %s\n", _m->name, m->name);
 398: 				}
 399: 				if(m->trace) ffnx_trace("%s\n", m->name);
 400: 				last_mode = m->mode;
 401: 			}
 402: 
 403: 			if (trace_all) ffnx_trace("getmode: no exact match, found by main loop - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);
 404: 
 405: 			return m;
 406: 		}
 407: 	}
 408: 
 409: 	// finally, ignore main loop and try to match by mode only
 410: 	for(i = 0; i < num_modes; i++)
 411: 	{
 412: 		struct game_mode *m = &modes[i];
 413: 
 414: 		if(m->mode == *common_externals._mode)
 415: 		{
 416: 			if(last_mode != m->mode)
 417: 			{
 418: 				if(m->trace) ffnx_trace("%s\n", m->name);
 419: 				last_mode = m->mode;
 420: 			}
 421: 
 422: 			if (trace_all) ffnx_trace("getmode: ignore main loop, match by mode only - driver_mode: %u - mode: %u - name: %s\n", m->driver_mode, m->mode, m->name);
 423: 
 424: 			return m;
 425: 		}
 426: 	}
 427: 
 428: 	if(*common_externals._mode != last_mode)
 429: 	{
 430: 		ffnx_unexpected("unknown mode (%i, 0x%x)\n", *common_externals._mode, (uint32_t)VREF(game_object, game_loop_obj).main_loop);
 431: 		last_mode = *common_externals._mode;
 432: 	}
 433: 
 434: 	if(!ff8) return &modes[4];
 435: 	else return &modes[11];
 436: }
 437: 
 438: // game mode usually doesn't change in the middle of a frame and even if it
 439: // does we usually don't care until the next frame so we can safely cache it to
 440: // avoid constant lookups
 441: struct game_mode *getmode_cached()
 442: {
 443: 	static uint32_t last_frame = -1;
 444: 	static struct game_mode *last_mode;
 445: 
 446: 	if(frame_counter != last_frame)
 447: 	{
 448: 		last_mode = getmode();
 449: 		last_frame = frame_counter;
 450: 	}
 451: 
 452: 	return last_mode;
 453: }
 454: 
 455: char* get_current_field_name()
 456: {
 457: 	if (ff8) {
 458: 		return common_externals.current_field_name;
 459: 	}
 460: 
 461: 	char *ret = strrchr(ff7_externals.field_file_name, 92);
 462: 
 463: 	if (ret) ret += 1;
 464: 
 465: 	return ret;
 466: }
 467: 
 468: bool maximized(HWND hwnd) {
 469: 	WINDOWPLACEMENT placement;
 470: 	if (!GetWindowPlacement(hwnd, &placement)) {
 471: 				return false;
 472: 	}
 473: 
 474: 	return placement.showCmd == SW_MAXIMIZE;
 475: }
 476: 
 477: /* Adjust client rect to not spill over monitor edges when maximized.
 478: * rect(in/out): in: proposed window rect, out: calculated client rect
 479: * Does nothing if the window is not maximized.
 480: */
 481: void adjust_maximized_client_rect(HWND window, RECT& rect) {
 482: 	if (!maximized(window)) {
 483: 			return;
 484: 	}
 485: 
 486: 	auto monitor = MonitorFromWindow(window, MONITOR_DEFAULTTONULL);
 487: 	if (!monitor) {
 488: 			return;
 489: 	}
 490: 
 491: 	MONITORINFO monitor_info{};
 492: 	monitor_info.cbSize = sizeof(monitor_info);
 493: 	if (!GetMonitorInfoW(monitor, &monitor_info)) {
 494: 			return;
 495: 	}
 496: 
 497: 	// when maximized, make the client area fill just the monitor (without task bar) rect,
 498: 	// not the whole window rect which extends beyond the monitor.
 499: 	rect = monitor_info.rcWork;
 500: }
 501: 
 502: bool composition_enabled() {
 503: 	BOOL composition_enabled = FALSE;
 504: 	bool success = DwmIsCompositionEnabled(&composition_enabled) == S_OK;
 505: 	return composition_enabled && success;
 506: }
 507: 
 508: LRESULT window_hit_test(HWND hwnd, POINT cursor) {
 509: 	// identify borders and corners to allow resizing the window.
 510: 	// Note: On Windows 10, windows behave differently and
 511: 	// allow resizing outside the visible window frame.
 512: 	// This implementation does not replicate that behavior.
 513: 	const POINT border{
 514: 			::GetSystemMetrics(SM_CXFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER),
 515: 			::GetSystemMetrics(SM_CYFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER)
 516: 	};
 517: 	SetRectEmpty(&gameWindowRect);
 518: 	if (!::GetWindowRect(hwnd, &gameWindowRect)) {
 519: 			return HTNOWHERE;
 520: 	}
 521: 
 522: 	enum region_mask {
 523: 			client = 0b0000,
 524: 			left   = 0b0001,
 525: 			right  = 0b0010,
 526: 			top    = 0b0100,
 527: 			bottom = 0b1000,
 528: 	};
 529: 
 530: 	const auto result =
 531: 			left    * (cursor.x <  (gameWindowRect.left   + border.x)) |
 532: 			right   * (cursor.x >= (gameWindowRect.right  - border.x)) |
 533: 			top     * (cursor.y <  (gameWindowRect.top    + border.y)) |
 534: 			bottom  * (cursor.y >= (gameWindowRect.bottom - border.y));
 535: 
 536: 	switch (result) {
 537: 			case left          : return HTLEFT;
 538: 			case right         : return HTRIGHT;
 539: 			case top           : return HTTOP;
 540: 			case bottom        : return HTBOTTOM;
 541: 			case top | left    : return HTTOPLEFT;
 542: 			case top | right   : return HTTOPRIGHT;
 543: 			case bottom | left : return HTBOTTOMLEFT;
 544: 			case bottom | right: return HTBOTTOMRIGHT;
 545: 			case client        : return HTCAPTION;
 546: 			default            : return HTNOWHERE;
 547: 	}
 548: }
 549: 
 550: void set_window_shadow() {
 551: 	if (composition_enabled()) {
 552: 		static const MARGINS shadow_state{1,1,1,1};
 553: 		::DwmExtendFrameIntoClientArea(gameHwnd, &shadow_state);
 554: 	}
 555: }
 556: 
 557: void toggle_borderless() {
 558: 	DWORD style = borderless ? WS_POPUP | WS_THICKFRAME | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX : WS_OVERLAPPEDWINDOW;
 559: 
 560: 	SetWindowLongPtr(gameHwnd, GWL_STYLE, style | WS_VISIBLE);
 561: 
 562: 	set_window_shadow();
 563: 
 564: 	SetWindowPos(gameHwnd, HWND_TOP, 0, 0, borderless ? window_size_x : gameWindow[GameWindowState::CURRENT].w, borderless ? window_size_y : gameWindow[GameWindowState::CURRENT].h, SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
 565: 	ShowWindow(gameHwnd, SW_SHOW);
 566: }
 567: 
 568: void calc_window_size(uint32_t width, uint32_t height) {
 569: 	SetRectEmpty(&gameWindowRect);
 570: 
 571: 	gameWindowRect.right = width;
 572: 	gameWindowRect.bottom = height;
 573: 
 574: 	AdjustWindowRect(&gameWindowRect, WS_OVERLAPPEDWINDOW, false);
 575: 	gameWindow[GameWindowState::CURRENT].w = gameWindowRect.right - gameWindowRect.left;
 576: 	gameWindow[GameWindowState::CURRENT].h = gameWindowRect.bottom - gameWindowRect.top;
 577: 
 578: 	// Center the window on the screen
 579: 	gameWindow[GameWindowState::CURRENT].x = (dmCurrentScreenSettings.dmPelsWidth / 2) - (gameWindow[GameWindowState::CURRENT].w / 2);
 580: 	gameWindow[GameWindowState::CURRENT].y = (dmCurrentScreenSettings.dmPelsHeight / 2) - (gameWindow[GameWindowState::CURRENT].h / 2);
 581: }
 582: 
 583: LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 584: {
 585: 	if (proxyWndProc)
 586: 	{
 587: 		switch (uMsg)
 588: 		{
 589: 		case WM_NCCALCSIZE:
 590: 			if (wParam == TRUE && borderless) {
 591: 					auto& params = *reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam);
 592: 					adjust_maximized_client_rect(hwnd, params.rgrc[0]);
 593: 					return 0;
 594: 			}
 595: 			break;
 596: 		case WM_NCHITTEST:
 597: 			// When we have no border or title bar, we need to perform our
 598: 			// own hit testing to allow resizing and moving.
 599: 			if (borderless) {
 600: 					return window_hit_test(gameHwnd, POINT{
 601: 							GET_X_LPARAM(lParam),
 602: 							GET_Y_LPARAM(lParam)
 603: 					});
 604: 			}
 605: 			break;
 606: 		case WM_NCACTIVATE:
 607: 			if (!composition_enabled()) {
 608: 					// Prevents window frame reappearing on window activation
 609: 					// in "basic" theme, where no aero shadow is present.
 610: 					return 1;
 611: 			}
 612: 			break;
 613: 		case WM_KEYDOWN:
 614: 			if ((::GetKeyState(VK_CONTROL) & 0x8000) != 0)
 615: 			{
 616: 				switch (LOWORD(wParam))
 617: 				{
 618: 				case VK_F11:
 619: 					newRenderer.toggleCaptureFrame();
 620: 					break;
 621: 				}
 622: 			}
 623: 			else if ((::GetKeyState(VK_SHIFT) & 0x8000) != 0)
 624: 			{
 625: 				switch (LOWORD(wParam))
 626: 				{
 627: 				case VK_LEFT:
 628: 					if (!widescreen_enabled)
 629: 					{
 630: 						aspect_ratio--;
 631: 						if (aspect_ratio < 0) aspect_ratio = AR_STRETCH;
 632: 
 633: 						show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Aspect Ratio Mode: %u", aspect_ratio);
 634: 
 635: 						newRenderer.reset();
 636: 					}
 637: 					break;
 638: 				case VK_RIGHT:
 639: 					if (!widescreen_enabled)
 640: 					{
 641: 						aspect_ratio++;
 642: 						if (aspect_ratio > AR_STRETCH) aspect_ratio = AR_ORIGINAL;
 643: 
 644: 						show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Aspect Ratio Mode: %u", aspect_ratio);
 645: 
 646: 						newRenderer.reset();
 647: 					}
 648: 					break;
 649: 				case VK_RETURN:
 650: 					if (!fullscreen)
 651: 					{
 652: 						borderless = !borderless;
 653: 						toggle_borderless();
 654: 						newRenderer.reset();
 655: 					}
 656: 					break;
 657: 				}
 658: 			}
 659: 			break;
 660: 		case WM_SIZE:
 661: 			window_size_x = (long)LOWORD(lParam);
 662: 			window_size_y = (long)HIWORD(lParam);
 663: 
 664: 			calc_window_size(window_size_x, window_size_y);
 665: 
 666: 			if (wParam != SIZE_MINIMIZED) newRenderer.reset();
 667: 
 668: 			if (wParam == SIZE_MAXIMIZED) gameWindowWasMaximized = true;
 669: 			else if (wParam == SIZE_RESTORED && gameWindowWasMaximized) gameWindowWasMaximized = false;
 670: 			else break;
 671: 		case WM_ENTERSIZEMOVE:
 672: 			gameWindowMoving = true;
 673: 			break;
 674: 		case WM_MOVE:
 675: 			if (gameWindowMoving) {
 676: 				if (!ff8){
 677: 					if (ff7_externals.movie_object->is_playing) ff7_core_game_loop();
 678: 				}
 679: 			}
 680: 			break;
 681: 		case WM_EXITSIZEMOVE:
 682: 			gameWindowMoving = false;
 683: 			newRenderer.reset();
 684: 			break;
 685: 		case WM_MENUCHAR:
 686: 			if (LOWORD(wParam) == VK_RETURN)
 687: 			{
 688: 				const auto& targetMonitor = monitors[display_index-1];
 689: 				if (fullscreen)
 690: 				{
 691: 					// Bring back the original resolution
 692: 					ChangeDisplaySettingsExA(targetMonitor.deviceName.c_str(), &dmCurrentScreenSettings, 0, CDS_FULLSCREEN, 0);
 693: 
 694: 					// Move to window
 695: 					SetWindowLongPtr(gameHwnd, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);
 696: 					MoveWindow(gameHwnd, gameWindow[GameWindowState::PRE_FULLSCREEN].x, gameWindow[GameWindowState::PRE_FULLSCREEN].y, gameWindow[GameWindowState::PRE_FULLSCREEN].w, gameWindow[GameWindowState::PRE_FULLSCREEN].h, true);
 697: 
 698: 					// Show the cursor
 699: 					while (ShowCursor(true) < 0);
 700: 
 701: 					fullscreen = false;
 702: 				}
 703: 				else
 704: 				{
 705: 					// Save current window state
 706: 					gameWindow[GameWindowState::PRE_FULLSCREEN] = gameWindow[GameWindowState::CURRENT];
 707: 
 708: 					// Bring back the user resolution
 709: 					ChangeDisplaySettingsExA(targetMonitor.deviceName.c_str(), &dmNewScreenSettings, 0, CDS_FULLSCREEN, 0);
 710: 
 711: 					// Move to fullscreen
 712: 					SetWindowLongPtr(gameHwnd, GWL_STYLE, WS_SYSMENU | WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE);
 713: 					MoveWindow(gameHwnd, 0, 0, dmNewScreenSettings.dmPelsWidth, dmNewScreenSettings.dmPelsHeight, true);
 714: 
 715: 					// Hide the cursor
 716: 					if (!enable_devtools) while (ShowCursor(false) >= 0);
 717: 
 718: 					fullscreen = true;
 719: 					borderless = false;
 720: 				}
 721: 
 722: 				newRenderer.reset();
 723: 
 724: 				return MAKELRESULT(0, MNC_CLOSE);
 725: 			}
 726: 			break;
 727: 		case WM_CLOSE:
 728: 		case WM_QUIT:
 729: 			if (ff8) ff8_release_movie_objects();
 730: 			else ff7_release_movie_objects();
 731: 
 732: 			gl_cleanup_deferred();
 733: 
 734: 			SetWindowLongA(gameHwnd, GWL_WNDPROC, (LONG)common_externals.engine_wndproc);
 735: 			break;
 736: 		}
 737: 
 738: 		HandleInputEvents(uMsg, wParam, lParam);
 739: 	}
 740: 
 741: 	gamehacks.processKeyboardInput(uMsg, wParam, lParam);
 742: 
 743: 	return common_externals.engine_wndproc(hwnd, uMsg, wParam, lParam);
 744: }
 745: 
 746: BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
 747: 	std::vector<MonitorInfo>* monitors = reinterpret_cast<std::vector<MonitorInfo>*>(dwData);
 748: 
 749: 	MONITORINFOEX monitorInfoEx;
 750: 	monitorInfoEx.cbSize = sizeof(MONITORINFOEX);
 751: 
 752: 	if (GetMonitorInfo(hMonitor, &monitorInfoEx)) {
 753: 		bool isPrimary = (monitorInfoEx.dwFlags & MONITORINFOF_PRIMARY) != 0;
 754: 		monitors->push_back({ monitorInfoEx.rcMonitor, monitorInfoEx.szDevice });
 755: 		if (isPrimary && display_index < 1) display_index = monitors->size();
 756: 	}
 757: 
 758: 	return TRUE;
 759: }
 760: 
 761: int common_create_window(HINSTANCE hInstance, struct game_obj* game_object)
 762: {
 763: 	uint32_t ret = FALSE;
 764: 
 765: 	VOBJ(game_obj, game_object, game_object);
 766: 
 767: 	HWND hWnd;
 768: 	HDC hdc;
 769: 	WNDCLASSA WndClass;
 770: 
 771: 	// Init Steam API
 772: 	if(steam_edition || enable_steam_achievements)
 773: 	{
 774: 		// generate automatically steam_appid.txt
 775: 		if(!steam_edition){
 776: 			std::ofstream steam_appid_file("steam_appid.txt");
 777: 			steam_appid_file << ((ff8) ? FF8_APPID : FF7_APPID);
 778: 			steam_appid_file.close();
 779: 		}
 780: 
 781: 		if (SteamAPI_RestartAppIfNecessary((ff8) ? FF8_APPID : FF7_APPID))
 782: 		{
 783: 			MessageBoxA(gameHwnd, "Steam Error - Could not find steam_appid.txt containing the app ID of the game.\n", "Steam App ID Wrong", 0);
 784: 			ffnx_error( "Steam Error - Could not find steam_appid.txt containing the app ID of the game.\n" );
 785: 			return 1;
 786: 		}
 787: 		if (!SteamAPI_Init())
 788: 		{
 789: 			MessageBoxA(gameHwnd, "Steam Error - Steam must be running to play this game with achievements (SteamAPI_Init() failed).\n", "Steam not running error", 0);
 790: 			ffnx_error( "Steam Error - Steam must be running to play this game with achievements (SteamAPI_Init() failed).\n" );
 791: 			return 1;
 792: 		}
 793: 		if (ff8)
 794: 			g_FF8SteamAchievements = std::make_unique<SteamAchievementsFF8>();
 795: 		else
 796: 			g_FF7SteamAchievements = std::make_unique<SteamAchievementsFF7>();
 797: 	}
 798: 
 799: 	// Enumerate available monitors
 800: 	EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc, reinterpret_cast<LPARAM>(&monitors));
 801: 	if (display_index > monitors.size()) display_index = monitors.size();
 802: 
 803: 	// Get the target monitor
 804: 	auto& targetMonitor = monitors[display_index-1];
 805: 
 806: 	// fetch current screen settings
 807: 	EnumDisplaySettingsA(targetMonitor.deviceName.c_str(), ENUM_CURRENT_SETTINGS, &dmCurrentScreenSettings);
 808: 
 809: 	// store all settings so we can change only few parameters
 810: 	dmNewScreenSettings = dmCurrentScreenSettings;
 811: 
 812: 	// read original resolution
 813: 	game_width = VREF(game_object, window_width);
 814: 	game_height = VREF(game_object, window_height);
 815: 
 816: 	// Assign a legit name to the Window
 817: 	if (ff8)
 818: 	{
 819: 		VRASS(game_object, window_title, "Final Fantasy VIII");
 820: 	}
 821: 	else
 822: 	{
 823: 		VRASS(game_object, window_title, "Final Fantasy VII");
 824: 	}
 825: 
 826: 	if (window_size_x == 0 || window_size_y == 0)
 827: 	{
 828: 		if (fullscreen)
 829: 		{
 830: 			window_size_x = dmCurrentScreenSettings.dmPelsWidth;
 831: 			window_size_y = dmCurrentScreenSettings.dmPelsHeight;
 832: 		}
 833: 		else
 834: 		{
 835: 			window_size_x = game_width;
 836: 			window_size_y = game_height;
 837: 		}
 838: 	}
 839: 	else
 840: 	{
 841: 		// custom resolution
 842: 		dmNewScreenSettings.dmSize = sizeof(dmNewScreenSettings);
 843: 		dmNewScreenSettings.dmPelsWidth = window_size_x;
 844: 		dmNewScreenSettings.dmPelsHeight = window_size_y;
 845: 		dmNewScreenSettings.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
 846: 
 847: 		if (refresh_rate)
 848: 		{
 849: 			dmNewScreenSettings.dmDisplayFrequency = refresh_rate;
 850: 			dmNewScreenSettings.dmFields |= DM_DISPLAYFREQUENCY;
 851: 		}
 852: 
 853: 		if (fullscreen)
 854: 		{
 855: 			if (ChangeDisplaySettingsExA(targetMonitor.deviceName.c_str(), &dmNewScreenSettings, 0, CDS_FULLSCREEN, 0) != DISP_CHANGE_SUCCESSFUL)
 856: 			{
 857: 				MessageBoxA(gameHwnd, "Failed to set the requested fullscreen mode, reverting to the original resolution.\n", "Error", 0);
 858: 				ffnx_error("failed to set fullscreen mode\n");
 859: 				window_size_x = dmCurrentScreenSettings.dmPelsWidth;
 860: 				window_size_y = dmCurrentScreenSettings.dmPelsHeight;
 861: 			}
 862: 			else
 863: 			{
 864: 				// re-fetch current monitors
 865: 				monitors.clear();
 866: 				EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc, reinterpret_cast<LPARAM>(&monitors));
 867: 				// Get the target monitor
 868: 				targetMonitor = monitors[display_index-1];
 869: 				// update current screen settings
 870: 				dmCurrentScreenSettings = dmNewScreenSettings;
 871: 			}
 872: 		}
 873: 	}
 874: 
 875: 	WndClass.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
 876: 	WndClass.lpfnWndProc = WindowProc;
 877: 	WndClass.cbClsExtra = 0;
 878: 	WndClass.cbWndExtra = 0;
 879: 	WndClass.hInstance = hInstance;
 880: 	WndClass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(101));
 881: 	WndClass.hCursor = LoadCursorA(0, (LPCSTR)IDC_ARROW);
 882: 	WndClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
 883: 	WndClass.lpszMenuName = 0;
 884: 	WndClass.lpszClassName = VREF(game_object, window_class);
 885: 
 886: 	if (RegisterClassA(&WndClass))
 887: 	{
 888: 		// If fullscreen is the starting mode, use the native game resolution as a window size starting point
 889: 		if (fullscreen)
 890: 		{
 891: 			calc_window_size(game_width, game_height);
 892: 
 893: 			// Save current window state
 894: 			gameWindow[GameWindowState::PRE_FULLSCREEN] = gameWindow[GameWindowState::CURRENT];
 895: 		}
 896: 		// Otherwise if windowed mode is requested on start, use the given resolution as a starting point
 897: 		else
 898: 			calc_window_size(window_size_x, window_size_y);
 899: 
 900: 		const RECT& monitorRect = targetMonitor.rcMonitor;
 901: 		hWnd = CreateWindowExA(
 902: 			WS_EX_APPWINDOW,
 903: 			VREF(game_object, window_class),
 904: 			VREF(game_object, window_title),
 905: 			fullscreen ? WS_SYSMENU | WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS : WS_OVERLAPPEDWINDOW,
 906: 			monitorRect.left + (fullscreen ? 0 : gameWindow[GameWindowState::CURRENT].x),
 907: 			monitorRect.top + (fullscreen ? 0 : gameWindow[GameWindowState::CURRENT].y),
 908: 			fullscreen ? window_size_x : gameWindow[GameWindowState::CURRENT].w,
 909: 			fullscreen ? window_size_y : gameWindow[GameWindowState::CURRENT].h,
 910: 			0,
 911: 			0,
 912: 			hInstance,
 913: 			0
 914: 		);
 915: 
 916: 		VRASS(game_object, hwnd, hWnd);
 917: 
 918: 		gameHinstance = hInstance;
 919: 		gameHwnd = hWnd;
 920: 
 921: 		if (hWnd)
 922: 		{
 923: 			ret = TRUE;
 924: 
 925: 			ShowWindow(hWnd, SW_SHOWNORMAL);
 926: 			UpdateWindow(hWnd);
 927: 			hdc = GetDC(hWnd);
 928: 			if (hdc)
 929: 			{
 930: 				VRASS(game_object, dc_horzres, GetDeviceCaps(hdc, HORZRES));
 931: 				VRASS(game_object, dc_vertres, GetDeviceCaps(hdc, VERTRES));
 932: 				VRASS(game_object, dc_bitspixel, GetDeviceCaps(hdc, BITSPIXEL));
 933: 				if (!VREF(game_object, colordepth))
 934: 					VRASS(game_object, colordepth, VREF(game_object, dc_bitspixel));
 935: 				ReleaseDC(hWnd, hdc);
 936: 			}
 937: 
 938: 			if (ret && VREF(game_object, engine_loop_obj.init))
 939: 			{
 940: 				if (ff8) ff8_init_hooks(game_object);
 941: 				else ff7_init_hooks(game_object);
 942: 
 943: 				replace_function(common_externals.get_keyboard_state, &GetGameKeyState);
 944: 				// catch all applog messages
 945: 				replace_function(common_externals.debug_print, external_debug_print);
 946: 				if (more_debug)
 947: 				{
 948: 					replace_function(common_externals.debug_print2, external_debug_print2);
 949: 				}
 950: 
 951: #ifdef NO_EXT_HEAP
 952: 				replace_function((uint32_t)common_externals.assert_free, ext_free);
 953: 				replace_function((uint32_t)common_externals.assert_malloc, ext_malloc);
 954: 				replace_function((uint32_t)common_externals.assert_calloc, ext_calloc);
 955: #endif
 956: 
 957: 				if (widescreen_enabled || enable_uncrop) widescreen.init();
 958: 
 959: 				// Init renderer
 960: 				newRenderer.init();
 961: 
 962: 				// Init GameHacks
 963: 				gamehacks.init();
 964: 
 965: 				max_texture_size = newRenderer.getCaps()->limits.maxTextureSize;
 966: 				ffnx_info("Max texture size: %ix%i\n", max_texture_size, max_texture_size);
 967: 
 968: 				newRenderer.prepareFFNxLogo();
 969: 
 970: 				newRenderer.prepareEnvBrdf();
 971: 
 972: 				newRenderer.prepareGamutLUTs();
 973: 
 974: 				// perform any additional initialization that requires the rendering environment to be set up
 975: 				field_init();
 976: 				world_init();
 977: 				music_init();
 978: 				sfx_init();
 979: 				voice_init();
 980: 
 981: 				if (enable_ffmpeg_videos)
 982: 				{
 983: 					movie_init();
 984: 				}
 985: 				if (ff8)
 986: 				{
 987: 					vram_init();
 988: 					if (ff8_fix_uv_coords_precision) uv_patch_init();
 989: 					vibration_init();
 990: 					if (widescreen_enabled)
 991: 					{
 992: 						*ff8_externals.current_viewport_x_dword_1A7764C = wide_viewport_x;
 993: 						*ff8_externals.current_viewport_y_dword_1A77648 = wide_viewport_y;
 994: 						*ff8_externals.current_viewport_width_dword_1A77654 = wide_viewport_width;
 995: 						*ff8_externals.current_viewport_height_dword_1A77650 = wide_viewport_height;
 996: 					}
 997: 				}
 998: 
 999: 				exe_data_init();
1000: 
1001: 				// Init Day Night Cycle
1002: 				if (!ff8 && enable_time_cycle) ff7::time.init();
1003: 
1004: 				// Init Lighting
1005: 				if (!ff8 && enable_lighting) lighting.init();
1006: 
1007: 				ffnx_log_current_pc_specs();
1008: 
1009: 				// enable verbose logging for FFMpeg
1010: 				av_log_set_level(AV_LOG_VERBOSE);
1011: 				av_log_set_callback(ffmpeg_log_callback);
1012: 
1013: 				ffnx_inject_driver(game_object);
1014: 
1015: 				if (VREF(game_object, engine_loop_obj.init)(game_object))
1016: 				{
1017: 					if (!fullscreen || enable_devtools)
1018: 					{
1019: 						// Show the cursor
1020: 						while (ShowCursor(true) < 0);
1021: 					}
1022: 					else if (fullscreen)
1023: 					{
1024: 						// Hide the cursor
1025: 						while (ShowCursor(false) >= 0);
1026: 					}
1027: 
1028: 					nxAudioEngine.init();
1029: 
1030: 					if (borderless) toggle_borderless();
1031: 
1032: 					if (VREF(game_object, engine_loop_obj.enter_main))
1033: 						VREF(game_object, engine_loop_obj.enter_main)(game_object);
1034: 				}
1035: 				else
1036: 				{
1037: 					ret = FALSE;
1038: 				}
1039: 			}
1040: 		}
1041: 	}
1042: 
1043: 	return ret;
1044: }
1045: 
1046: // called by the game before rendering starts, after the driver object has been
1047: // created, we use this opportunity to initialize our default OpenGL render
1048: // state
1049: uint32_t common_init(struct game_obj *game_object)
1050: {
1051: 	if(trace_all) ffnx_trace("dll_gfx: init\n");
1052: 
1053: 	newRenderer.setBlendMode(RendererBlendMode::BLEND_NONE);
1054: 
1055: 	texture_format = common_externals.create_texture_format();
1056: 	common_externals.make_pixelformat(32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000, texture_format);
1057: 	common_externals.add_texture_format(texture_format, game_object);
1058: 
1059: 	nxAudioEngine.setMusicMasterVolume(external_music_volume / 100.0f);
1060: 	nxAudioEngine.setSFXMasterVolume(external_sfx_volume / 100.0f);
1061: 	nxAudioEngine.setAmbientMasterVolume(external_ambient_volume / 100.0f);
1062: 	nxAudioEngine.setVoiceMasterVolume(external_voice_volume / 100.0f);
1063: 
1064: 	proxyWndProc = true;
1065: 
1066: 	return true;
1067: }
1068: 
1069: // called by the game just before it exits, we need to make sure the game
1070: // doesn't crash after we're gone
1071: void common_cleanup(struct game_obj *game_object)
1072: {
1073: 	if(trace_all) ffnx_trace("dll_gfx: cleanup\n");
1074: 
1075: 	if (steam_edition)
1076: 	{
1077: 		if (!ff8)
1078: 		{
1079: 			// Write ff7sound.cfg
1080: 			char ff7soundPath[260]{0};
1081: 			get_userdata_path(ff7soundPath, sizeof(ff7soundPath), false);
1082: 			PathAppendA(ff7soundPath, "ff7sound.cfg");
1083: 			FILE *ff7sound = fopen(ff7soundPath, "wb");
1084: 
1085: 			if (ff7sound)
1086: 			{
1087: 				fwrite(&external_sfx_volume, sizeof(DWORD), 1, ff7sound);
1088: 				fwrite(&external_music_volume, sizeof(DWORD), 1, ff7sound);
1089: 				fclose(ff7sound);
1090: 			}
1091: 		}
1092: 	}
1093: 
1094: 	// Shutdown Steam API
1095: 	if(steam_edition || enable_steam_achievements)
1096: 		SteamAPI_Shutdown();
1097: 
1098: 	nxAudioEngine.cleanup();
1099: 	newRenderer.shutdown();
1100: }
1101: 
1102: // unused and unnecessary
1103: uint32_t common_lock(uint32_t surface)
1104: {
1105: 	if(trace_all) ffnx_trace("dll_gfx: lock %i\n", surface);
1106: 
1107: 	return true;
1108: }
1109: 
1110: // unused and unnecessary
1111: uint32_t common_unlock(uint32_t surface)
1112: {
1113: 	if(trace_all) ffnx_trace("dll_gfx: unlock %i\n", surface);
1114: 
1115: 	return true;
1116: }
1117: 
1118: // called by the game at the end of each frame to swap the front and back
1119: // buffers
1120: void common_flip(struct game_obj *game_object)
1121: {
1122: 	if (trace_all) ffnx_trace("dll_gfx: flip (%i)\n", frame_counter);
1123: 
1124: 	VOBJ(game_obj, game_object, game_object);
1125: 	static struct timeb last_frame;
1126: 	static uint32_t fps_counters[3] = {0, 0, 0};
1127: 	time_t last_seconds = last_frame.time;
1128: 	struct game_mode *mode = getmode_cached();
1129: 
1130: 	// Update RAM usage info
1131: 	GlobalMemoryStatusEx(&last_ram_state);
1132: 
1133: 	// Draw with lighting
1134: 	if (!ff8 && enable_lighting) lighting.draw(game_object);
1135: 
1136: 	// draw any z-sorted content now that we're done drawing everything else
1137: 	gl_draw_sorted_deferred();
1138: 
1139: 	newRenderer.drawOverlay();
1140: 
1141: 	if (fullscreen || borderless)
1142: 	{
1143: 		static uint32_t col = 4;
1144: 		uint32_t row = 1;
1145: 
1146: 		if (show_version)
1147: 		{
1148: 			gl_draw_text(col, row++, text_colors[TEXTCOLOR_GRAY], 255, "Version: " VERSION);
1149: 		}
1150: 
1151: 		if (show_renderer_backend)
1152: 		{
1153: 			gl_draw_text(col, row++, text_colors[TEXTCOLOR_GREEN], 255, "Renderer: %s", newRenderer.currentRenderer.c_str());
1154: 		}
1155: 
1156: 		if (show_fps)
1157: 		{
1158: 			// average last two seconds and round up for our FPS counter
1159: 			gl_draw_text(col, row++, text_colors[TEXTCOLOR_YELLOW], 255, "FPS: %2.1lf", frame_rate);
1160: 		}
1161: 
1162: 		if (show_stats)
1163: 		{
1164: 			static uint32_t color = text_colors[TEXTCOLOR_PINK];
1165: 
1166: #ifdef HEAP_DEBUG
1167: 			gl_draw_text(col, row++, color, 255, "Allocations: %u", allocs);
1168: #endif
1169: #ifdef PROFILE
1170: 			gl_draw_text(col, row++, color, 255, "Profiling: %I64u us", (time_t)((profile_total * 1000000.0) / VREF(game_object, countspersecond)));
1171: #endif
1172: 			gl_draw_text(col, row++, color, 255, "RAM usage: %llu MB / %llu MB", (last_ram_state.ullTotalVirtual - last_ram_state.ullAvailVirtual) / (1024 * 1024), last_ram_state.ullTotalVirtual / ( 1024 * 1024 ));
1173: 			gl_draw_text(col, row++, color, 255, "Textures: %u", stats.texture_count);
1174: 			gl_draw_text(col, row++, color, 255, "External textures: %u", stats.external_textures);
1175: 			gl_draw_text(col, row++, color, 255, "Texture reloads: %u", stats.texture_reloads);
1176: 			gl_draw_text(col, row++, color, 255, "Palette writes: %u", stats.palette_writes);
1177: 			gl_draw_text(col, row++, color, 255, "Palette changes: %u", stats.palette_changes);
1178: 			gl_draw_text(col, row++, color, 255, "Zsort layers: %u", stats.deferred);
1179: 			gl_draw_text(col, row++, color, 255, "Vertices: %u", stats.vertex_count);
1180: 			gl_draw_text(col, row++, color, 255, "Timer: %I64u", stats.timer);
1181: 		}
1182: 	}
1183: 	else
1184: 	{
1185: 		char newWindowTitle[1024];
1186: 
1187: 		strcpy_s(newWindowTitle, 1024, VREF(game_object, window_title));
1188: 
1189: 		// Append chosen rendering engine
1190: 		if (show_renderer_backend)
1191: 		{
1192: 			char tmp[64];
1193: 			sprintf_s(tmp, 64, " (%s)", newRenderer.currentRenderer.c_str());
1194: 			strcat_s(newWindowTitle, 1024, tmp);
1195: 		}
1196: 
1197: 		if (show_version)
1198: 		{
1199: 			char tmp[16];
1200: 			sprintf_s(tmp, 16, " " VERSION);
1201: 			strcat_s(newWindowTitle, 1024, tmp);
1202: 		}
1203: 
1204: 		if (show_stats)
1205: 		{
1206: 			char tmp[768];
1207: 			sprintf_s(tmp, 768, " | RAM: %llu MB / %llu MB | nTex: %u | nExt.Tex: %u", (last_ram_state.ullTotalVirtual - last_ram_state.ullAvailVirtual) / (1024 * 1024), last_ram_state.ullTotalVirtual / (1024 * 1024), stats.texture_count, stats.external_textures);
1208: 			strcat_s(newWindowTitle, 1024, tmp);
1209: 		}
1210: 
1211: 		if (show_fps)
1212: 		{
1213: 			char tmp[64];
1214: 			sprintf_s(tmp, 64, " | FPS: %2.1lf", frame_rate);
1215: 			strcat_s(newWindowTitle, 1024, tmp);
1216: 		}
1217: 
1218: 		SetWindowTextA(gameHwnd, newWindowTitle);
1219: 	}
1220: 
1221: 	fps_counters[0]++;
1222: 	ftime(&last_frame);
1223: 
1224: 	if (last_seconds != last_frame.time)
1225: 	{
1226: 		fps_counters[2] = fps_counters[1];
1227: 		fps_counters[1] = fps_counters[0];
1228: 		fps_counters[0] = 0;
1229: 	}
1230: 
1231: 	frame_rate = (fps_counters[1] + fps_counters[2] + 1) / 2;
1232: 
1233: 	VRASS(game_object, fps, frame_rate);
1234: 
1235: 	// if there is an active popup message, display it
1236: 	if(popup_ttl > 0)
1237: 	{
1238: 		if(gl_draw_text(4, newRenderer.getStats()->textHeight - 2, popup_color, (popup_ttl * 255) / POPUP_TTL_MAX, popup_msg))
1239: 		{
1240: 			uint32_t diff = (POPUP_TTL_MAX - popup_ttl) / 10;
1241: 
1242: 			if(diff == 0) popup_ttl--;
1243: 			else if(diff > popup_ttl) popup_ttl = 0;
1244: 			else popup_ttl -= diff;
1245: 		}
1246: 	}
1247: 
1248: 	// reset per-frame stats
1249: 	stats.texture_reloads = 0;
1250: 	stats.palette_writes = 0;
1251: 	stats.palette_changes = 0;
1252: 	stats.vertex_count = 0;
1253: 	stats.deferred = 0;
1254: 
1255: 	newRenderer.show();
1256: 
1257: 	current_state.texture_filter = true;
1258: 	current_state.fb_texture = false;
1259: 
1260: 	// fix unresponsive quit menu
1261: 	if(!ff8 && VREF(game_object, gfx_reset))
1262: 	{
1263: 		MSG msg;
1264: 
1265: 		if(PeekMessageA(&msg, 0, 0, 0, 1))
1266: 		{
1267: 			TranslateMessage(&msg);
1268: 			DispatchMessage(&msg);
1269: 		}
1270: 	}
1271: 
1272: 	// Enable XInput if a compatible gamepad is detected while playing the game, otherwise continue with native DInput
1273: 	if (!xinput_connected && gamepad.CheckConnection())
1274: 	{
1275: 		if (trace_all || trace_gamepad) ffnx_trace("XInput controller: connected.\n");
1276: 
1277: 		xinput_connected = true;
1278: 
1279: 		// Release any previous DirectInput attached controller, if any
1280: 		joystick.Clean();
1281: 	}
1282: 	else if (xinput_connected && !gamepad.CheckConnection())
1283: 	{
1284: 		if (trace_all || trace_gamepad) ffnx_trace("XInput controller: disconnected.\n");
1285: 
1286: 		xinput_connected = false;
1287: 	}
1288: 
1289: 	frame_counter++;
1290: 
1291: 	// We need to process Gamepad input on each frame
1292: 	gamehacks.processGamepadInput();
1293: 
1294: 	// Update day night time cycle
1295: 	if (!ff8 && enable_time_cycle) ff7::time.update();
1296: 
1297: 	// Handle main menu background music
1298: 	handle_mainmenu_playback();
1299: 
1300: 	// FF8 does not clear the screen properly in the card game module
1301: 	if (ff8)
1302: 	{
1303: 		if (mode->driver_mode == MODE_CARDGAME) common_clear_all(0);
1304: 
1305: 		if (ff8_ssigpu_debug) ff8_externals.refresh_vram_window();
1306: 
1307: 		ff8_handle_ambient_playback();
1308: 	}
1309: 	else
1310: 	{
1311: 		if (ff7_do_reset)
1312: 		{
1313: 			if (ff7_externals.movie_object->is_playing)
1314: 			{
1315: 				ff7_do_reset = false;
1316: 			}
1317: 			else
1318: 			{
1319: 				switch(mode->driver_mode)
1320: 				{
1321: 					// Skip reset on these mode(s)
1322: 					case MODE_MENU:
1323: 					case MODE_MAIN_MENU:
1324: 					case MODE_GAMEOVER:
1325: 					case MODE_CREDITS:
1326: 						ff7_do_reset = false;
1327: 						break;
1328: 					case MODE_BATTLE:
1329: 						if (*ff7_externals.battle_mode < 6) break;
1330: 					default:
1331: 						ff7_externals.reset_game_obj_sub_5F4971(game_object);
1332: 						break;
1333: 				}
1334: 			}
1335: 		}
1336: 
1337: 		*ff7_externals.swirl_limit_fps = 1;
1338: 
1339: 		ff7_handle_ambient_playback();
1340: 		ff7_handle_voice_playback();
1341: 		ff7_handle_wmode_reset();
1342: 		ff7::field::ff7_field_handle_blink_reset();
1343: 	}
1344: 
1345: 	// Steamworks SDK API run callbacks
1346: 	if(steam_edition || enable_steam_achievements)
1347: 		SteamAPI_RunCallbacks();
1348: 
1349: }
1350: 
1351: // called by the game to clear an aspect of the back buffer, mostly called from
1352: // clear_all below
1353: void common_clear(uint32_t clear_color, uint32_t clear_depth, uint32_t unknown, struct game_obj *game_object)
1354: {
1355: 	if(gl_defer_clear_buffer(clear_color, clear_depth, game_object)) return;
1356: 
1357: 	uint32_t mode = getmode_cached()->driver_mode;
1358: 
1359: 	if(trace_all) ffnx_trace("dll_gfx: clear %i %i %i\n", clear_color, clear_depth, unknown);
1360: 
1361: 	if (!ff8 && enable_lighting) newRenderer.clearShadowMap();
1362: 
1363: 	newRenderer.setClearFlags(
1364: 		clear_color || mode == MODE_MENU || mode == MODE_MAIN_MENU || mode == MODE_CONDOR,
1365: 		clear_depth
1366: 	);
1367: }
1368: 
1369: // called by the game to clear the entire back buffer
1370: void common_clear_all(struct game_obj *game_object)
1371: {
1372: 	if(trace_all) ffnx_trace("dll_gfx: clear_all\n");
1373: 
1374: 	common_clear(true, true, true, game_object);
1375: }
1376: 
1377: // called by the game to setup a viewport inside the game window, allowing it
1378: // to clip drawing to the requested area
1379: void common_setviewport(uint32_t _x, uint32_t _y, uint32_t _w, uint32_t _h, struct game_obj *game_object)
1380: {
1381: 	uint32_t mode = getmode_cached()->driver_mode;
1382: 
1383: 	if(trace_all) ffnx_trace("dll_gfx: setviewport %i %i %i %i\n", _x, _y, _w, _h);
1384: 
1385: 	current_state.viewport[0] = _x;
1386: 	current_state.viewport[1] = _y;
1387: 	current_state.viewport[2] = _w;
1388: 	current_state.viewport[3] = _h;
1389: 
1390: 	newRenderer.setScissor(
1391: 		_x,
1392: 		_y,
1393: 		_w,
1394: 		_h
1395: 	);
1396: 
1397: 	// emulate the transformation applied by an equivalent Direct3D viewport
1398: 	d3dviewport_matrix._11 = (float)_w / (float)game_width;
1399: 	// no idea why this is necessary
1400: 	if(!ff8 && mode == MODE_BATTLE) d3dviewport_matrix._22 = 1.0f;
1401: 	else d3dviewport_matrix._22 = (float)_h / (float)game_height;
1402: 	d3dviewport_matrix._41 = (((float)_x + (float)_w / 2.0f) - (float)game_width / 2.0f) / ((float)game_width / 2.0f);
1403: 	d3dviewport_matrix._42 = -(((float)_y + (float)_h / 2.0f) - (float)game_height / 2.0f) / ((float)game_height / 2.0f);
1404: }
1405: 
1406: // called by the game to set the background color which the back buffer will be
1407: // cleared to
1408: void common_setbg(struct bgra_color *color, struct game_obj *game_object)
1409: {
1410: 	if(trace_all) ffnx_trace("dll_gfx: setbg\n");
1411: 
1412: 	newRenderer.setBackgroundColor(
1413: 		color->r,
1414: 		color->g,
1415: 		color->b,
1416: 		ff8 ? color->a : 0.0f
1417: 	);
1418: }
1419: 
1420: // called by the game to initialize a polygon_set structure
1421: // we don't really need to do anything special here
1422: uint32_t common_prepare_polygon_set(struct polygon_set *polygon_set)
1423: {
1424: 	VOBJ(polygon_set, polygon_set, polygon_set);
1425: 
1426: 	if(VPTR(polygon_set)) VRASS(polygon_set, indexed_primitives, (indexed_primitive**)external_calloc(VREF(polygon_set, numgroups), 4));
1427: 
1428: 	return true;
1429: }
1430: 
1431: // called by the game to load a group from a .p file into a renderable format
1432: uint32_t common_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *hundred_data, struct p_group *group_data, struct polygon_data *polygon_data, struct polygon_set *polygon_set, struct game_obj *game_object)
1433: {
1434: 	if(!ff8) return ff7gl_load_group(group_num, matrix_set, hundred_data, group_data, polygon_data, (struct ff7_polygon_set *)polygon_set, (struct ff7_game_obj *)game_object);
1435: 	else return common_externals.generic_load_group(group_num, matrix_set, hundred_data, group_data, polygon_data, polygon_set, game_object);
1436: }
1437: 
1438: // called by the game to update one of the matrices in a matrix_set structure
1439: void common_setmatrix(uint32_t unknown, struct matrix *matrix, struct matrix_set *matrix_set, struct game_obj *game_object)
1440: {
1441: 	if(trace_all) ffnx_trace("dll_gfx: setmatrix\n");
1442: 
1443: 	switch(unknown)
1444: 	{
1445: 		case 0:
1446: 			if(!matrix_set->matrix_world) matrix_set->matrix_world = matrix;
1447: 			else memcpy(matrix_set->matrix_world, matrix, sizeof(*matrix));
1448: 			break;
1449: 
1450: 		case 1:
1451: 			if(!matrix_set->matrix_view) matrix_set->matrix_view = matrix;
1452: 			else memcpy(matrix_set->matrix_view, matrix, sizeof(*matrix));
1453: 			break;
1454: 
1455: 		case 2:
1456: 			if(!matrix_set->matrix_projection) matrix_set->matrix_projection = matrix;
1457: 			else memcpy(matrix_set->matrix_projection, matrix, sizeof(*matrix));
1458: 			break;
1459: 	}
1460: }
1461: 
1462: // called by the game to apply light information to the current polygon set
1463: void common_light_polygon_set(struct polygon_set *polygon_set, struct light *light)
1464: {
1465: 	if(ff8 || game_lighting == GAME_LIGHTING_ORIGINAL) common_externals.generic_light_polygon_set(polygon_set, light);
1466: }
1467: 
1468: // called by the game to unload a texture
1469: void common_unload_texture(struct texture_set *texture_set)
1470: {
1471: 	uint32_t i;
1472: 	VOBJ(texture_set, texture_set, texture_set);
1473: 
1474: 	if(trace_all) ffnx_trace("dll_gfx: unload_texture 0x%x\n", VPTR(texture_set));
1475: 
1476: 	if(!VPTR(texture_set)) return;
1477: 	if(!VREF(texture_set, texturehandle)) return;
1478: 	if(!VREF(texture_set, ogl.gl_set)) return;
1479: 
1480: 	struct gl_texture_set *gl_set = VREF(texture_set, ogl.gl_set);
1481: 
1482: 	// Destroy original static textures
1483: 	for (uint32_t idx = 0; idx < VREF(texture_set, ogl.gl_set->textures); idx++)
1484: 	{
1485: 		newRenderer.deleteTexture(VREF(texture_set, texturehandle[idx]));
1486: 	}
1487: 
1488: 	// Destroy animated textures
1489: 	if (gl_set->is_animated)
1490: 	{
1491: 		for(std::map<std::string,uint32_t>::iterator it = gl_set->animated_textures.begin(); it != gl_set->animated_textures.end(); ++it) {
1492: 			newRenderer.deleteTexture(it->second);
1493: 		}
1494: 		gl_set->animated_textures.clear();
1495: 	}
1496: 
1497: 	// Destroy additional textures
1498: 	for (short slot = RendererTextureSlot::TEX_NML; slot < RendererTextureSlot::COUNT; slot++)
1499: 		newRenderer.deleteTexture(gl_set->additional_textures[slot]);
1500: 
1501: 	external_free(VREF(texture_set, texturehandle));
1502: 	delete VREF(texture_set, ogl.gl_set);
1503: 
1504: 	VRASS(texture_set, texturehandle, 0);
1505: 	VRASS(texture_set, ogl.gl_set, 0);
1506: 
1507: 	stats.texture_count--;
1508: 
1509: 	if(VREF(texture_set, ogl.external)) stats.external_textures--;
1510: 	VRASS(texture_set, ogl.external, false); // texture_set can be reused (FF8)
1511: 
1512: 	// remove any other references to this texture
1513: 	gl_check_deferred(texture_set);
1514: 
1515: 	for(i = 0; i < scene_stack_pointer; i++)
1516: 	{
1517: 		if(scene_stack[i].texture_set == VPTR(texture_set)) scene_stack[i].texture_set = NULL;
1518: 	}
1519: 
1520: 	if(current_state.texture_set == VPTR(texture_set)) current_state.texture_set = NULL;
1521: 
1522: 	if(ff8) ff8_unload_texture(VPTRCAST(ff8_texture_set, texture_set));
1523: }
1524: 
1525: // create a texture from an area of the framebuffer, source rectangle is encoded into tex header
1526: // with our fictional version FB_TEXT_VERSION
1527: // return true to short-circuit texture loader
1528: uint32_t create_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header)
1529: {
1530: 	VOBJ(texture_set, texture_set, texture_set);
1531: 	VOBJ(tex_header, tex_header, tex_header);
1532: 	uint32_t texture;
1533: 
1534: 	if(VREF(tex_header, version) != FB_TEX_VERSION) return false;
1535: 
1536: 	if(trace_all) ffnx_trace("create_framebuffer_texture: XY(%u,%u) %ux%u\n", VREF(tex_header, fb_tex.x), VREF(tex_header, fb_tex.y), VREF(tex_header, fb_tex.w), VREF(tex_header, fb_tex.h));
1537: 
1538: 	texture = newRenderer.createBlitTexture(
1539: 		VREF(tex_header, fb_tex.x),
1540: 		VREF(tex_header, fb_tex.y),
1541: 		VREF(tex_header, fb_tex.w),
1542: 		VREF(tex_header, fb_tex.h)
1543: 	);
1544: 
1545: 	VRASS(texture_set, texturehandle[0], texture);
1546: 
1547: 	return true;
1548: }
1549: 
1550: void blit_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header)
1551: {
1552: 	VOBJ(texture_set, texture_set, texture_set);
1553: 	VOBJ(tex_header, tex_header, tex_header);
1554: 
1555: 	if(VREF(tex_header, version) != FB_TEX_VERSION) return;
1556: 
1557: 	if(gl_defer_blit_framebuffer(texture_set, tex_header)) return;
1558: 
1559: 	if(trace_all) ffnx_trace("load_framebuffer_texture: XY(%u,%u) %ux%u\n", VREF(tex_header, fb_tex.x), VREF(tex_header, fb_tex.y), VREF(tex_header, fb_tex.w), VREF(tex_header, fb_tex.h));
1560: 
1561: 	newRenderer.blitTexture(
1562: 		VREF(texture_set, texturehandle[0]),
1563: 		VREF(tex_header, fb_tex.x),
1564: 		VREF(tex_header, fb_tex.y),
1565: 		VREF(tex_header, fb_tex.w),
1566: 		VREF(tex_header, fb_tex.h)
1567: 	);
1568: }
1569: 
1570: // load modpath texture for tex file, returns true if successful
1571: uint32_t load_external_texture(void* image_data, uint32_t dataSize, struct texture_set *texture_set, struct tex_header *tex_header, uint32_t originalWidth, uint32_t originalHeight, uint32_t saveload_palette_index)
1572: {
1573: 	VOBJ(texture_set, texture_set, texture_set);
1574: 	VOBJ(tex_header, tex_header, tex_header);
1575: 	uint32_t texture = 0;
1576: 	struct gl_texture_set *gl_set = VREF(texture_set, ogl.gl_set);
1577: 	struct texture_format* tex_format = VREFP(tex_header, tex_format);
1578: 
1579: 	if((uint32_t)VREF(tex_header, file.pc_name) > 32 && !save_textures)
1580: 	{
1581: 		if(trace_all || trace_loaders) ffnx_trace("texture file name: %s\n", VREF(tex_header, file.pc_name));
1582: 
1583: 		// Don't use palette index on fallback (for keeping compatibility with Tonberry mods)
1584: 		if(ff8 && _strnicmp(VREF(tex_header, file.pc_name), "field/mapdata/", strlen("field/mapdata/") - 1) == 0) saveload_palette_index |= 0x80000000;
1585: 
1586: 		texture = load_texture(image_data, dataSize, VREF(tex_header, file.pc_name), saveload_palette_index, VREFP(texture_set, ogl.width), VREFP(texture_set, ogl.height), gl_set);
1587: 
1588: 		if (!ff8)
1589: 		{
1590: 			if (enable_lighting)
1591: 			{
1592: 				std::string path = VREF(tex_header, file.pc_name);
1593: 				std::string filename = path.substr(path.find_last_of("/") + 1);
1594: 
1595: 				if(lighting.isDisabledLightingTexture(filename))
1596: 				{
1597: 					gl_set->disable_lighting = true;
1598: 				}
1599: 			}
1600: 
1601: 			if(!_strnicmp(VREF(tex_header, file.pc_name), "world", strlen("world") - 1)) gl_set->force_filter = true;
1602: 
1603: 			if(!_strnicmp(VREF(tex_header, file.pc_name), "menu/usfont", strlen("menu/usfont") - 1))
1604: 			{
1605: 				gl_set->force_filter = true;
1606: 				gl_set->force_zsort = true;
1607: 			}
1608: 
1609: 			if(!_strnicmp(VREF(tex_header, file.pc_name), "menu/btl_win", strlen("menu/btl_win") - 1)) gl_set->force_zsort = true;
1610: 
1611: 			if(!_strnicmp(VREF(tex_header, file.pc_name), "flevel/hand_1", strlen("flevel/hand_1") - 1)) gl_set->force_filter = true;
1612: 		}
1613: 	}
1614: 
1615: 	if(ff8 && texture == 0)
1616: 	{
1617: 		bool external = true;
1618: 		texture = texturePacker.composeTextures(
1619: 			VREF(tex_header, image_data), reinterpret_cast<uint32_t *>(image_data), originalWidth, originalHeight,
1620: 			VREF(tex_header, palette_index) / 2,
1621: 			VREFP(texture_set, ogl.width), VREFP(texture_set, ogl.height), gl_set, &external
1622: 		);
1623: 
1624: 		if (texture == uint32_t(-1))
1625: 		{
1626: 			return true; // Remove texture
1627: 		}
1628: 
1629: 		if (texture == 0)
1630: 		{
1631: 			if(VREF(texture_set, ogl.external)) stats.external_textures--;
1632: 			VRASS(texture_set, ogl.external, false);
1633: 		}
1634: 		else if (external == false)
1635: 		{
1636: 			gl_replace_texture(texture_set, VREF(tex_header, palette_index), texture);
1637: 
1638: 			return true;
1639: 		}
1640: 	}
1641: 
1642: 	if(texture)
1643: 	{
1644: 		gl_replace_texture(texture_set, VREF(tex_header, palette_index), texture);
1645: 
1646: 		if(!VREF(texture_set, ogl.external)) stats.external_textures++;
1647: 		VRASS(texture_set, ogl.external, true);
1648: 
1649: 		return true;
1650: 	}
1651: 
1652: 	return false;
1653: }
1654: 
1655: // convert a single 8-bit paletted pixel to 32-bit BGRA format
1656: _inline uint32_t pal2bgra(uint32_t pixel, uint32_t *palette, uint32_t palette_offset, uint32_t color_key, uint32_t reference_alpha)
1657: {
1658: 	if(color_key && pixel == 0) return 0;
1659: 
1660: 	else
1661: 	{
1662: 		uint32_t color = palette[palette_offset + pixel];
1663: 		// FF7 uses a form of alpha keying to emulate PSX blending
1664: 		if(BGRA_A(color) == 0xFE) color = (color & 0xFFFFFF) | reference_alpha;
1665: 		return color;
1666: 	}
1667: }
1668: 
1669: // convert an entire image from its native format to 32-bit BGRA
1670: void convert_image_data(const unsigned char *image_data, uint32_t *converted_image_data, uint32_t w, uint32_t h, struct texture_format *tex_format, uint32_t invert_alpha, uint32_t color_key, uint32_t palette_offset, uint32_t reference_alpha)
1671: {
1672: 	uint32_t i, j, o = 0, c = 0;
1673: 
1674: 	// invalid texture in FF8, do not attempt to convert
1675: 	if(ff8 && tex_format->bytesperpixel == 0) return;
1676: 
1677: 	// paletted source data (4-bit palettes are expanded to 8-bit by the game)
1678: 	if(tex_format->bytesperpixel == 1)
1679: 	{
1680: 		if(!tex_format->use_palette)
1681: 		{
1682: 			ffnx_glitch("unsupported texture format\n");
1683: 			return;
1684: 		}
1685: 
1686: 		for(i = 0; i < w; i++)
1687: 		{
1688: 			for(j = 0; j < h; j++)
1689: 			{
1690: 				if(image_data[o] > tex_format->palette_size)
1691: 				{
1692: 					ffnx_glitch("texture conversion error\n");
1693: 					return;
1694: 				}
1695: 
1696: 				converted_image_data[c++] = pal2bgra(image_data[o++], tex_format->palette_data, palette_offset, color_key, reference_alpha);
1697: 			}
1698: 		}
1699: 	}
1700: 	// RGB(A) source data
1701: 	else
1702: 	{
1703: 		if(tex_format->use_palette)
1704: 		{
1705: 			ffnx_glitch("unsupported texture format\n");
1706: 			return;
1707: 		}
1708: 
1709: 		for(i = 0; i < w; i++)
1710: 		{
1711: 			for(j = 0; j < h; j++)
1712: 			{
1713: 				uint32_t pixel = 0;
1714: 				uint32_t color = 0;
1715: 
1716: 				switch(tex_format->bytesperpixel)
1717: 				{
1718: 					// 16-bit RGB(A)
1719: 					case 2:
1720: 						pixel = *((WORD *)(&image_data[o]));
1721: 						break;
1722: 					// 24-bit RGB
1723: 					case 3:
1724: 						pixel = image_data[o] | image_data[o + 1] << 8 | image_data[o + 2] << 16;
1725: 						break;
1726: 					// 32-bit RGBA or RGBX
1727: 					case 4:
1728: 						pixel = *((uint32_t *)(&image_data[o]));
1729: 						break;
1730: 
1731: 					default:
1732: 						ffnx_glitch("unsupported texture format\n");
1733: 						return;
1734: 				}
1735: 
1736: 				o += tex_format->bytesperpixel;
1737: 
1738: 				// PSX style mask bit
1739: 				if((color_key == 1 && (pixel & ~tex_format->alpha_mask) == 0) || (color_key == 3 && pixel == 0))
1740: 				{
1741: 					converted_image_data[c++] = 0;
1742: 					continue;
1743: 				}
1744: 
1745: 				// convert source data to 8 bits per channel
1746: 				color = tex_format->blue_max > 0 ? ((((pixel & tex_format->blue_mask) >> tex_format->blue_shift) * 255) / tex_format->blue_max) : 0;
1747: 				color |= (tex_format->green_max > 0 ? ((((pixel & tex_format->green_mask) >> tex_format->green_shift) * 255) / tex_format->green_max) : 0) << 8;
1748: 				color |= (tex_format->red_max > 0 ? ((((pixel & tex_format->red_mask) >> tex_format->red_shift) * 255) / tex_format->red_max) : 0) << 16;
1749: 
1750: 				// special case to deal with poorly converted PSX images in FF7
1751: 				if(invert_alpha && pixel != 0x8000) color |= (tex_format->alpha_max > 0 ? (255 - ((((pixel & tex_format->alpha_mask) >> tex_format->alpha_shift) * 255) / tex_format->alpha_max)) : 255) << 24;
1752: 				else color |= (tex_format->alpha_max > 0 ? ((((pixel & tex_format->alpha_mask) >> tex_format->alpha_shift) * 255) / tex_format->alpha_max) : 255) << 24;
1753: 
1754: 				converted_image_data[c++] = color;
1755: 			}
1756: 		}
1757: 	}
1758: }
1759: 
1760: // called by the game to load a texture
1761: // can be called under a wide variety of circumstances, we must figure out what the game wants
1762: struct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)
1763: {
1764: 	VOBJ(game_obj, game_object, common_externals.get_game_object());
1765: 	VOBJ(texture_set, texture_set, _texture_set);
1766: 	VOBJ(tex_header, tex_header, _tex_header);
1767: 	struct palette *palette = 0;
1768: 	uint32_t color_key = false;
1769: 	struct texture_format *tex_format = VREFP(tex_header, tex_format);
1770: 
1771: 	if(trace_all && _texture_set != NULL) ffnx_trace("dll_gfx: load_texture 0x%x\n", _texture_set);
1772: 
1773: 	// no existing texture set, create one
1774: 	if (!VPTR(texture_set))
1775: 	{
1776: 		_texture_set = common_externals.create_texture_set();
1777: 		VASS(texture_set, texture_set, _texture_set);
1778: 	}
1779: 
1780: 	// allocate space for our private data
1781: 	if(!VREF(texture_set, ogl.gl_set))
1782: 	{
1783: 		VRASS(texture_set, ogl.gl_set, new gl_texture_set());
1784: 		for (short slot = RendererTextureSlot::TEX_NML; slot < RendererTextureSlot::COUNT; slot++)
1785: 			VRASS(texture_set, ogl.gl_set->additional_textures[slot], 0);
1786: 	}
1787: 
1788: 	// texture handle array may not have been initialized
1789: 	if(!VREF(texture_set, texturehandle))
1790: 	{
1791: 		// allocate some more textures just in case, there could be more palettes we don't know about yet
1792: 		// FF8 likes to change its mind about just how many palettes a texture has
1793: 		VRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);
1794: 		VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(VREF(texture_set, ogl.gl_set->textures), sizeof(uint32_t)));
1795: 
1796: 		if(ff8 && VREF(tex_header, version) != FB_TEX_VERSION)
1797: 		{
1798: 			external_free(VREF(tex_header, old_palette_data));
1799: 			VRASS(tex_header, old_palette_data, 0);
1800: 		}
1801: 
1802: 		stats.texture_count++;
1803: 	}
1804: 
1805: 	// number of palettes has changed, reload the texture completely
1806: 	if(VREF(texture_set, ogl.gl_set->textures) != VREF(tex_header, palettes) * 2 && !(VREF(tex_header, palettes) == 0 && VREF(texture_set, ogl.gl_set->textures) == 1))
1807: 	{
1808: 		common_unload_texture(_texture_set);
1809: 
1810: 		return common_load_texture(_texture_set, _tex_header, texture_format);
1811: 	}
1812: 
1813: 	// make sure the information in the texture set is consistent
1814: 	VRASS(texture_set, tex_header, _tex_header);
1815: 	VRASS(texture_set, texture_format, texture_format);
1816: 
1817: 	// check if this is suppposed to be a framebuffer texture, we may not have to do anything
1818: 	if(create_framebuffer_texture(_texture_set, _tex_header))
1819: 	{
1820: 		blit_framebuffer_texture(_texture_set, _tex_header);
1821: 		return _texture_set;
1822: 	}
1823: 
1824: 	// initialize palette index to a sane value if it hasn't been set
1825: 	if(VREF(tex_header, palettes) > 0)
1826: 	{
1827: 		if(VREF(texture_set, palette_index) == -1)
1828: 		{
1829: 			VRASS(tex_header, palette_index, 0);
1830: 		}
1831: 		else
1832: 		{
1833: 			VRASS(tex_header, palette_index, ff8 ? VREF(texture_set, palette_index) & 0x1FFF : VREF(texture_set, palette_index));
1834: 		}
1835: 	}
1836: 	else VRASS(tex_header, palette_index, 0);
1837: 
1838: 	if(VREF(tex_header, palette_index) >= VREF(texture_set, ogl.gl_set->textures))
1839: 	{
1840: 		ffnx_unexpected("tried to use non-existent palette (%i, %i)\n", VREF(tex_header, palette_index), VREF(texture_set, ogl.gl_set->textures));
1841: 		VRASS(tex_header, palette_index, 0);
1842: 		return _texture_set;
1843: 	}
1844: 
1845: 	// create palette structure if it doesn't exist already
1846: 	if(VREF(tex_header, palettes) > 1 && VREF(texture_set, palette) == 0) palette = common_externals.create_palette_for_tex(texture_format->bitsperpixel, _tex_header, _texture_set);
1847: 
1848: 	if(tex_format->palettes == 0) tex_format->palettes = VREF(tex_header, palette_entries);
1849: 
1850: 	// convert texture data from source format and load it
1851: 	if(texture_format != 0 && VREF(tex_header, image_data) != 0)
1852: 	{
1853: 		uint32_t saveload_palette_index = VREF(tex_header, palette_index);
1854: 
1855: 		if (ff8)
1856: 		{
1857: 			// optimization to not upload textures with undefined VRAM palette
1858: 			TexturePacker::TiledTex tiledTex = texturePacker.getTiledTex(VREF(tex_header, image_data));
1859: 
1860: 			if (tiledTex.isValid())
1861: 			{
1862: 				TexturePacker::TextureInfos pal = tiledTex.palette(VREF(tex_header, palette_index) / 2);
1863: 
1864: 				if (tiledTex.bpp() != Tim::Bpp16 && !pal.isValid())
1865: 				{
1866: 					if(trace_all || trace_vram) ffnx_trace("dll_gfx: load_texture ignored texture_set=0x%X pointer=0x%X pos=(%d, %d) bpp=%d index=%d\n", _texture_set, VREF(tex_header, image_data), tiledTex.x(), tiledTex.y(), tiledTex.bpp(), VREF(tex_header, palette_index) / 2);
1867: 
1868: 					return _texture_set;
1869: 				}
1870: 
1871: 				if (pal.isValid()) {
1872: 					saveload_palette_index = uint32_t(0x40000000) | ((uint32_t(pal.y()) & 0x7FFF) << 15) | (uint32_t(pal.x()) & 0x7FFF);
1873: 				} else {
1874: 					saveload_palette_index = uint32_t(-1);
1875: 				}
1876: 			}
1877: 		}
1878: 
1879: 		// detect changes in palette data for FF8, we can't trust it to notify us
1880: 		if(ff8 && VREF(tex_header, palettes) > 0 && VREF(tex_header, version) != FB_TEX_VERSION && tex_format->bytesperpixel == 1)
1881: 		{
1882: 			if(!VREF(tex_header, old_palette_data))
1883: 			{
1884: 				VRASS(tex_header, old_palette_data, (unsigned char*)external_malloc(4 * tex_format->palette_size));
1885: 				memcpy(VREF(tex_header, old_palette_data), tex_format->palette_data, 4 * tex_format->palette_size);
1886: 			}
1887: 			else if(memcmp(VREF(tex_header, old_palette_data), tex_format->palette_data, 4 * tex_format->palette_size) != 0)
1888: 			{
1889: 				for (uint32_t idx = 0; idx < VREF(texture_set, ogl.gl_set->textures); idx++)
1890: 					newRenderer.deleteTexture(VREF(texture_set, texturehandle[idx]));
1891: 
1892: 				memset(VREF(texture_set, texturehandle), 0, VREF(texture_set, ogl.gl_set->textures) * sizeof(uint32_t));
1893: 				VREF(texture_set, ogl.gl_set->default_texture_id) = 0;
1894: 
1895: 				memcpy(VREF(tex_header, old_palette_data), tex_format->palette_data, 4 * tex_format->palette_size);
1896: 			}
1897: 		}
1898: 
1899: 		// the texture handle for the current palette is missing, convert & load it
1900: 		// if we are dealing with an animated palette, load it anyway even if already loaded
1901: 		if(!VREF(texture_set, texturehandle[VREF(tex_header, palette_index)]) || VREF(texture_set, ogl.gl_set->is_animated))
1902: 		{
1903: 			uint32_t c = 0;
1904: 			uint32_t w = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.w) : tex_format->width;
1905: 			uint32_t h = VREF(tex_header, version) == FB_TEX_VERSION ? VREF(tex_header, fb_tex.h) : tex_format->height;
1906: 			uint32_t invert_alpha = false;
1907: 			uint32_t *image_data;
1908: 			// pre-calculate some useful data for palette conversion
1909: 			uint32_t palette_offset = VREF(tex_header, palette_index) * VREF(tex_header, palette_entries);
1910: 			uint32_t reference_alpha = (VREF(tex_header, reference_alpha) & 0xFF) << 24;
1911: 
1912: 			// detect 16-bit PSX 5551 format with mask bit
1913: 			if(tex_format->bitsperpixel == 16 && tex_format->alpha_mask == 0x8000)
1914: 			{
1915: 				// correct incomplete texture format in FF7
1916: 				if(!ff8)
1917: 				{
1918: 					tex_format->blue_mask =  0x001F;
1919: 					tex_format->green_mask = 0x03E0;
1920: 					tex_format->red_mask =   0x7C00;
1921: 					tex_format->blue_shift =  0;
1922: 					tex_format->green_shift = 5;
1923: 					tex_format->red_shift =  10;
1924: 					tex_format->blue_max =  31;
1925: 					tex_format->green_max = 31;
1926: 					tex_format->red_max =   31;
1927: 				}
1928: 
1929: 				invert_alpha = true;
1930: 			}
1931: 
1932: 			if(!ff8)
1933: 			{
1934: 				// find out if color keying is enabled for this texture
1935: 				color_key = VREF(tex_header, color_key);
1936: 
1937: 				// find out if color keying is enabled for this particular palette
1938: 				if(VREF(tex_header, use_palette_colorkey)) color_key = VREF(tex_header, palette_colorkey[VREF(tex_header, palette_index)]);
1939: 			}
1940: 
1941: 			// allocate PBO
1942: 			uint32_t image_data_size = w * h * 4;
1943: 
1944: 			// Allocate with cache
1945: 			if (image_data_size_cache == 0 || image_data_size > image_data_size_cache) {
1946: 				if (image_data_cache != nullptr) {
1947: 					driver_free(image_data_cache);
1948: 				}
1949: 				image_data_cache = (uint32_t*)driver_malloc(image_data_size);
1950: 				image_data_size_cache = image_data_size;
1951: 			}
1952: 
1953: 			image_data = image_data_cache;
1954: 
1955: 			// convert source data
1956: 			if (image_data != NULL) convert_image_data(VREF(tex_header, image_data), image_data, w, h, tex_format, invert_alpha, color_key, palette_offset, reference_alpha);
1957: 
1958: 			// save texture to modpath if save_textures is enabled
1959: 			if(save_textures && (uint32_t)VREF(tex_header, file.pc_name) > 32)
1960: 			{
1961: 				save_texture(image_data, image_data_size, w, h, saveload_palette_index, VREF(tex_header, file.pc_name), VREF(texture_set, ogl.gl_set->is_animated));
1962: 			}
1963: 
1964: 			// check if this texture can be loaded from the modpath, we may not have to do any conversion
1965: 			if (!load_external_texture(image_data, image_data_size, _texture_set, _tex_header, w, h, saveload_palette_index))
1966: 			{
1967: 				// commit PBO and populate texture set
1968: 				gl_upload_texture(_texture_set, VREF(tex_header, palette_index), image_data, RendererTextureType::BGRA);
1969: 			}
1970: 		}
1971: 	}
1972: 	else ffnx_unexpected("no texture format specified or no source data\n");
1973: 
1974: 	return _texture_set;
1975: }
1976: 
1977: // called by the game to indicate when a texture has switched to using another palette
1978: // Either palette_entry_mul_index1 or palette_entry_mul_index2 can be filled. Not both! If palette_entry_mul_index1 has a value, then palette_entry_mul_index2 is 0, for eg.
1979: // If it is one or the other filled, means coming from two different points in the engine ( for FF8 at least )
1980: uint32_t common_palette_changed(uint32_t palette_entry_mul_index1, uint32_t palette_entries, uint32_t palette_entry_mul_index2, struct palette *palette, struct texture_set *texture_set)
1981: {
1982: 	VOBJ(texture_set, texture_set, texture_set);
1983: 
1984: 	if(trace_all) ffnx_trace("dll_gfx: palette_changed 0x%x %i\n", texture_set, VREF(texture_set, palette_index));
1985: 
1986: 	if(palette == 0 || texture_set == 0) return false;
1987: 
1988: 	// unset current texture
1989: 	newRenderer.useTexture(0);
1990: 
1991: 	// texture loader logic handles missing palettes, just make sure the new palette has been loaded
1992: 	texture_set = common_load_texture(texture_set, VREF(texture_set, tex_header), VREF(texture_set, texture_format));
1993: 
1994: 	// re-bind texture set to make sure the new palette is active
1995: 	gl_bind_texture_set(texture_set);
1996: 
1997: 	stats.palette_changes++;
1998: 
1999: 	return true;
2000: }
2001: 
2002: // called by the game to write new color data to a palette
2003: // sometimes called just to indicate that the palette has already been changed
2004: // return value?
2005: uint32_t common_write_palette(uint32_t source_offset, uint32_t size, void *source, uint32_t dest_offset, struct palette *palette, struct texture_set *texture_set)
2006: {
2007: 	struct game_mode *mode = getmode_cached();
2008: 
2009: 	uint32_t palette_index;
2010: 	uint32_t palettes;
2011: 	VOBJ(texture_set, texture_set, texture_set);
2012: 	VOBJ(tex_header, tex_header, VREF(texture_set, tex_header));
2013: 
2014: 	if(trace_all) ffnx_trace("dll_gfx: write_palette texture_set=0x%x source_offset=%i dest_offset=%i size=%i source=0x%x palette_entry=0x%x image_data=0x%X\n", texture_set, source_offset, dest_offset, size, source, palette->palette_entry, VREF(tex_header, image_data));
2015: 
2016: 	if(palette == 0) return false;
2017: 
2018: 	// if the tex header and texture set are not consistent we shouldn't be touching
2019: 	// anything before the texture is reloaded
2020: 	if(VREF(texture_set, ogl.gl_set->textures) != VREF(tex_header, palettes) * 2 && !(VREF(tex_header, palettes) == 0 && VREF(texture_set, ogl.gl_set->textures) == 1)) return true;
2021: 
2022: 	palette_index = dest_offset / VREF(tex_header, palette_entries);
2023: 	palettes = size / VREF(tex_header, palette_entries);
2024: 
2025: 	if(!ff8)
2026: 	{
2027: 		// FF7 writes to one palette at a time
2028: 		if(palettes > 1) ffnx_unexpected("multipalette write\n");
2029: 
2030: 		if(palette_index >= VREF(texture_set, ogl.gl_set->textures))
2031: 		{
2032: 			ffnx_unexpected("palette write outside valid palette area (%i, %i)\n", palette_index, VREF(texture_set, ogl.gl_set->textures));
2033: 			return false;
2034: 		}
2035: 
2036: 		// make sure the palette actually changed to avoid redundant texture reloads
2037: 		if(memcmp(((uint32_t *)VREF(tex_header, tex_format.palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4))
2038: 		{
2039: 			memcpy(((uint32_t *)VREF(tex_header, tex_format.palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4);
2040: 
2041: 			if(!VREF(texture_set, ogl.external))
2042: 			{
2043: 				newRenderer.deleteTexture(VREF(texture_set, texturehandle[palette_index]));
2044: 
2045: 				VRASS(texture_set, texturehandle[palette_index], 0);
2046: 			}
2047: 
2048: 			stats.texture_reloads++;
2049: 		}
2050: 
2051: 		// this texture changes in time, flag this as animated
2052: 		VRASS(texture_set, ogl.gl_set->is_animated, enable_animated_textures && mode->driver_mode == MODE_FIELD && (std::find(disable_animated_textures_on_field.begin(), disable_animated_textures_on_field.end(), get_current_field_name()) == disable_animated_textures_on_field.end()));
2053: 	}
2054: 	else
2055: 	{
2056: 		// FF8 writes multiple palettes in one swath but it always writes whole palettes
2057: 		if(palettes > 1 && size % VREF(tex_header, palette_entries)) ffnx_unexpected("unaligned multipalette write\n");
2058: 
2059: 		const TexturePacker::TextureInfos paletteInfos = texturePacker.getTiledTex(VREF(tex_header, image_data)).palette(palette_index / 2);
2060: 
2061: 		if (paletteInfos.isValid())
2062: 		{
2063: 			if(!VREF(tex_header, vram_positions))
2064: 			{
2065: 				VRASS(tex_header, vram_positions, (uint32_t*)external_calloc(128, sizeof(uint32_t)));
2066: 			}
2067: 
2068: 			const uint32_t pos = VREF(tex_header, vram_positions)[palette_index];
2069: 			const uint16_t x = uint16_t(pos & 0xFFFF), y = uint16_t(pos >> 16);
2070: 
2071: 			// We have a texture for this index, but the coordinates do not match
2072: 			// In this case, we can search if indexes haven't just swaped
2073: 			if (VREF(tex_header, old_palette_data) && VREF(texture_set, texturehandle[palette_index]) && (x > 0 || y > 0) && (x != paletteInfos.x() || y != paletteInfos.y()))
2074: 			{
2075: 				for (uint32_t idx = 0; idx < VREF(texture_set, ogl.gl_set->textures); idx++)
2076: 				{
2077: 					if (idx == palette_index || VREF(texture_set, texturehandle[idx]) == 0)
2078: 					{
2079: 						continue;
2080: 					}
2081: 
2082: 					const uint32_t pos2 = VREF(tex_header, vram_positions)[idx];
2083: 					const uint16_t x2 = uint16_t(pos2 & 0xFFFF), y2 = uint16_t(pos2 >> 16);
2084: 
2085: 					// Found one texture using the same coordinates
2086: 					if ((x2 > 0 || y2 > 0) && paletteInfos.x() == x2 && paletteInfos.y() == y2)
2087: 					{
2088: 						// Swap handles
2089: 						uint32_t old_handle = VREF(texture_set, texturehandle[palette_index]);
2090: 						VRASS(texture_set, texturehandle[palette_index], VREF(texture_set, texturehandle[idx]));
2091: 						VRASS(texture_set, texturehandle[idx], old_handle);
2092: 						// Swap palette data
2093: 						uint32_t *tmp_palette = (uint32_t *)external_malloc(size * 4);
2094: 						memcpy(tmp_palette, ((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, size * 4);
2095: 						memcpy(((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, ((uint32_t *)VREF(tex_header, old_palette_data)) + idx * size, size * 4);
2096: 						memcpy(((uint32_t *)VREF(tex_header, old_palette_data)) + idx * size, tmp_palette, size * 4);
2097: 						external_free(tmp_palette);
2098: 						// Move vram position
2099: 						VREF(tex_header, vram_positions)[idx] = VREF(tex_header, vram_positions)[palette_index];
2100: 
2101: 						break;
2102: 					}
2103: 				}
2104: 			}
2105: 
2106: 			VREF(tex_header, vram_positions)[palette_index] = uint32_t(paletteInfos.x()) | (uint32_t(paletteInfos.y()) << 16);
2107: 		}
2108: 
2109: 		if(!VREF(tex_header, old_palette_data)) return false;
2110: 
2111: 		// since FF8 may have already modified the palette itself we need to compare the new data to our backup
2112: 		if(memcmp(((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4) != 0)
2113: 		{
2114: 			memcpy(((uint32_t *)VREF(tex_header, old_palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4);
2115: 			memcpy(((uint32_t *)VREF(tex_header, tex_format.palette_data)) + dest_offset, ((uint32_t *)source + source_offset), size * 4);
2116: 
2117: 			// limit write to the palettes that we are aware of
2118: 			if(palette_index >= VREF(texture_set, ogl.gl_set->textures)) palettes = 0;
2119: 			else if(palette_index + palettes > VREF(texture_set, ogl.gl_set->textures)) palettes = VREF(texture_set, ogl.gl_set->textures) - palette_index;
2120: 
2121: 			if(dest_offset + size > VREF(tex_header, tex_format.palette_size))
2122: 			{
2123: 				ffnx_unexpected("palette write outside advertised palette area (0x%x + 0x%x, 0x%x)\n", dest_offset, size, VREF(tex_header, tex_format.palette_size));
2124: 			}
2125: 
2126: 			// if there's anything left at this point, reload the affected textures
2127: 			if(palettes)
2128: 			{
2129: 				for (uint32_t idx = 0; idx < palettes; idx++)
2130: 					newRenderer.deleteTexture(VREF(texture_set, texturehandle[palette_index + idx]));
2131: 
2132: 				memset(VREFP(texture_set, texturehandle[palette_index]), 0, palettes * sizeof(uint32_t));
2133: 				VREF(texture_set, ogl.gl_set->default_texture_id) = 0;
2134: 			}
2135: 
2136: 			stats.texture_reloads++;
2137: 		}
2138: 	}
2139: 
2140: 	stats.palette_writes++;
2141: 
2142: 	return true;
2143: }
2144: 
2145: // blend mode parameters, identical to Direct3D driver
2146: struct blend_mode blend_modes[5] = {      // PSX blend mode:
2147: 	{1, 1, 0x80, 5, 0x10, 6, 0x20, 0, 0}, // average
2148: 	{1, 0, 0xFF, 2, 2,    2, 2,    0, 0}, // additive blending
2149: 	{1, 0, 0xFF, 4, 8,    2, 2,    0, 0}, // subtractive blending
2150: 	{1, 0, 0x40, 5, 0x10, 2, 2,    0, 0}, // 25%? incoming color
2151: 	{1, 0, 0xFF, 2, 2,    1, 1,    0, 0}, //
2152: };
2153: 
2154: // called by the game to retrieve blend mode parameters
2155: // only z-sort and vertex alpha are really relevant to us
2156: struct blend_mode *common_blendmode(uint32_t blend_mode, struct game_obj *game_object)
2157: {
2158: 	if(trace_all) ffnx_trace("dll_gfx: blendmode %i\n", blend_mode);
2159: 
2160: 	switch(blend_mode)
2161: 	{
2162: 		case 0:
2163: 			return &blend_modes[0];
2164: 		case 1:
2165: 			return &blend_modes[1];
2166: 		case 2:
2167: 			return &blend_modes[2];
2168: 		case 3:
2169: 			return &blend_modes[3];
2170: 		case 4:
2171: 			if(!ff8) ffnx_unexpected("blend mode 4 requested\n");
2172: 			return &blend_modes[4];
2173: 	}
2174: 
2175: 	ffnx_unexpected("invalid blendmode: %u\n", blend_mode);
2176: 
2177: 	return 0;
2178: }
2179: 
2180: // helper function to set simple render states (single parameter)
2181: void internal_set_renderstate(uint32_t state, uint32_t option, struct game_obj *game_object)
2182: {
2183: 	VOBJ(game_obj, game_object, game_object);
2184: 
2185: 	switch(state)
2186: 	{
2187: 		// wireframe rendering, not used?
2188: 		case V_WIREFRAME:
2189: 			if (option) newRenderer.setWireframeMode(true);
2190: 			else newRenderer.setWireframeMode(false);
2191: 			current_state.wireframe = option;
2192: 			break;
2193: 
2194: 		// texture filtering, can be disabled globally via config file
2195: 		case V_LINEARFILTER:
2196: 			if((option && !VREF(game_object, field_988))) current_state.texture_filter = true;
2197: 			else current_state.texture_filter = false;
2198: 			break;
2199: 
2200: 		// perspective correction should never be turned off
2201: 		case V_PERSPECTIVE:
2202: 			// noop
2203: 			break;
2204: 
2205: 		// color keying is done when textures are converted, not when rendering
2206: 		case V_COLORKEY:
2207: 			// noop
2208: 			break;
2209: 
2210: 		// no dithering necessary in 32-bit color mode
2211: 		case V_DITHER:
2212: 			// noop
2213: 			break;
2214: 
2215: 		// alpha test is used in many places in FF8 instead of color keying
2216: 		case V_ALPHATEST:
2217: 			if (option) newRenderer.doAlphaTest(true);
2218: 			else newRenderer.doAlphaTest(false);
2219: 			current_state.alphatest = option;
2220: 			break;
2221: 
2222: 		// cull face, does this ever change?
2223: 		case V_CULLFACE:
2224: 			if (!option) newRenderer.setCullMode(RendererCullMode::BACK);
2225: 			else newRenderer.setCullMode(RendererCullMode::FRONT);
2226: 			current_state.cullface = option;
2227: 			break;
2228: 
2229: 		// turn off culling completely, once again unsure if its ever used
2230: 		case V_NOCULL:
2231: 			if (option) newRenderer.setCullMode(RendererCullMode::DISABLED);
2232: 			else newRenderer.setCullMode(RendererCullMode::BACK);
2233: 			current_state.nocull = option;
2234: 			break;
2235: 
2236: 		// turn depth testing on/off
2237: 		case V_DEPTHTEST:
2238: 			if (option) newRenderer.doDepthTest(true);
2239: 			else newRenderer.doDepthTest(false);
2240: 			current_state.depthtest = option;
2241: 			break;
2242: 
2243: 		// depth mask, enable/disable writing to the Z-buffer
2244: 		case V_DEPTHMASK:
2245: 			if (option) newRenderer.doDepthWrite(true);
2246: 			else newRenderer.doDepthWrite(false);
2247: 			current_state.depthmask = option;
2248: 			break;
2249: 
2250: 		// no idea what this is supposed to do
2251: 		case V_TEXADDR:
2252: 			// noop
2253: 			break;
2254: 
2255: 		// function and reference values for alpha test
2256: 		case V_ALPHAFUNC:
2257: 		case V_ALPHAREF:
2258: 			if(state == V_ALPHAFUNC) current_state.alphafunc = option;
2259: 			else current_state.alpharef = option;
2260: 
2261: 			switch(current_state.alphafunc)
2262: 			{
2263: 			case 0: newRenderer.setAlphaRef(RendererAlphaFunc::NEVER, current_state.alpharef / 255.0f); break;
2264: 			case 1: newRenderer.setAlphaRef(RendererAlphaFunc::ALWAYS, current_state.alpharef / 255.0f); break;
2265: 			case 2: newRenderer.setAlphaRef(RendererAlphaFunc::LESS, current_state.alpharef / 255.0f); break;
2266: 			case 3: newRenderer.setAlphaRef(RendererAlphaFunc::LEQUAL, current_state.alpharef / 255.0f); break;
2267: 			case 4: newRenderer.setAlphaRef(RendererAlphaFunc::EQUAL, current_state.alpharef / 255.0f); break;
2268: 			case 5: newRenderer.setAlphaRef(RendererAlphaFunc::GEQUAL, current_state.alpharef / 255.0f); break;
2269: 			case 6: newRenderer.setAlphaRef(RendererAlphaFunc::GREATER, current_state.alpharef / 255.0f); break;
2270: 			case 7: newRenderer.setAlphaRef(RendererAlphaFunc::NOTEQUAL, current_state.alpharef / 255.0f); break;
2271: 			default: newRenderer.setAlphaRef(RendererAlphaFunc::LEQUAL, current_state.alpharef / 255.0f); break;
2272: 			}
2273: 			break;
2274: 
2275: 		case V_SHADEMODE:
2276: 			current_state.shademode = option;
2277: 
2278: 		default:
2279: 			break;
2280: 	}
2281: }
2282: 
2283: // called by the game to set a simple render state
2284: void common_field_64(uint32_t state, uint32_t option, struct game_obj *game_object)
2285: {
2286: 	if(trace_all) ffnx_trace("dll_gfx: field_64 %i %i\n", state, option);
2287: 
2288: 	internal_set_renderstate(state, option, game_object);
2289: }
2290: 
2291: // called by the game to apply a set of render states
2292: void common_setrenderstate(struct p_hundred *hundred_data, struct game_obj *game_object)
2293: {
2294: 	if(hundred_data == 0) return;
2295: 
2296: 	VOBJ(game_obj, game_object, game_object);
2297: 
2298: 	uint32_t features = hundred_data->features;
2299: 	uint32_t options = hundred_data->options;
2300: 	struct struc_81 *struc_81 = VREF(game_object, field_944);
2301: 
2302: 	if(trace_all) ffnx_trace("dll_gfx: setrenderstate 0x%x 0x%x\n", features, options);
2303: 
2304: // helper macro to check if a bit is set
2305: // to be able to tell which bits we haven't handled, this macro will also clear
2306: // a bit after checking it, be extremely careful not to copy/paste any
2307: // invocation of this macro, the second invocation will not work!
2308: #define CHECK_BIT(X, Y) ((X) & BIT((Y))) && (((X &= ~BIT((Y))) || true))
2309: 
2310: 	if(CHECK_BIT(features, V_WIREFRAME)) internal_set_renderstate(V_WIREFRAME, CHECK_BIT(options, V_WIREFRAME), game_object);
2311: 	if(CHECK_BIT(features, V_TEXTURE)) gl_bind_texture_set(hundred_data->texture_set);
2312: 	if(CHECK_BIT(features, V_LINEARFILTER)) internal_set_renderstate(V_LINEARFILTER, CHECK_BIT(options, V_LINEARFILTER), game_object);
2313: 	if(CHECK_BIT(features, V_PERSPECTIVE)) internal_set_renderstate(V_PERSPECTIVE, CHECK_BIT(options, V_PERSPECTIVE), game_object);
2314: 	if(CHECK_BIT(features, V_COLORKEY)) internal_set_renderstate(V_COLORKEY, CHECK_BIT(options, V_COLORKEY), game_object);
2315: 	if(CHECK_BIT(features, V_DITHER)) internal_set_renderstate(V_DITHER, CHECK_BIT(options, V_DITHER), game_object);
2316: 	if(CHECK_BIT(features, V_ALPHABLEND))
2317: 	{
2318: 		// Safe default
2319: 		struc_81->blend_mode = 4;
2320: 
2321: 		if(CHECK_BIT(options, V_ALPHABLEND))
2322: 		{
2323: 			if(VREF(game_object, field_93C))
2324: 			{
2325: 				if(VREF(game_object, current_hundred))
2326: 					struc_81->blend_mode = VREF(game_object, current_hundred->blend_mode);
2327: 			}
2328: 			else
2329: 				struc_81->blend_mode = hundred_data->blend_mode;
2330: 		}
2331: 
2332: 		gl_set_blend_func(struc_81->blend_mode);
2333: 	}
2334: 	if(CHECK_BIT(features, V_ALPHATEST)) internal_set_renderstate(V_ALPHATEST, CHECK_BIT(options, V_ALPHATEST), game_object);
2335: 	if(CHECK_BIT(features, V_CULLFACE)) internal_set_renderstate(V_CULLFACE, CHECK_BIT(options, V_CULLFACE), game_object);
2336: 	if(CHECK_BIT(features, V_NOCULL)) internal_set_renderstate(V_NOCULL, CHECK_BIT(options, V_NOCULL), game_object);
2337: 	if(CHECK_BIT(features, V_DEPTHTEST)) internal_set_renderstate(V_DEPTHTEST, CHECK_BIT(options, V_DEPTHTEST), game_object);
2338: 	if(CHECK_BIT(features, V_DEPTHMASK)) internal_set_renderstate(V_DEPTHMASK, CHECK_BIT(options, V_DEPTHMASK), game_object);
2339: 	if(CHECK_BIT(features, V_SHADEMODE)) internal_set_renderstate(V_SHADEMODE, CHECK_BIT(options, V_SHADEMODE) && !VREF(game_object, field_92C) && hundred_data->shademode > 0, game_object);
2340: 	if(CHECK_BIT(features, V_UNKNOWNFFFDFFFD))
2341: 	{
2342: 		// Safe default
2343: 		struc_81->blend_mode = 4;
2344: 
2345: 		if(CHECK_BIT(options, V_ALPHABLEND))
2346: 		{
2347: 			if(VREF(game_object, field_93C))
2348: 			{
2349: 				if(VREF(game_object, current_hundred))
2350: 					struc_81->blend_mode = VREF(game_object, current_hundred->blend_mode);
2351: 			}
2352: 			else
2353: 				struc_81->blend_mode = hundred_data->blend_mode;
2354: 		}
2355: 
2356: 		gl_set_blend_func(struc_81->blend_mode);
2357: 	}
2358: 
2359: 	// any bits still set in the features and options variables at this point
2360: 	// are features that we do not currently handle
2361: }
2362: 
2363: // called by the game to apply a predetermined set of render states
2364: // one for each blend mode? not sure what this is used for exactly
2365: void common_field_74(uint32_t unknown, struct game_obj *game_object)
2366: {
2367: 	VOBJ(game_obj, game_object, game_object);
2368: 
2369: 	if(trace_all) ffnx_trace("dll_gfx: field_74\n");
2370: 
2371: 	if(unknown > 4) return;
2372: 
2373: 	common_setrenderstate(VREF(game_object, hundred_array[unknown]), game_object);
2374: }
2375: 
2376: // called by the game to render a polygon set
2377: // in FF7 this is where most of the 3D rendering happens
2378: // in FF8 this function doesn't do any rendering at all
2379: void common_field_78(struct polygon_set *polygon_set, struct game_obj *game_object)
2380: {
2381: 	if(!ff8) ff7gl_field_78((struct ff7_polygon_set *)polygon_set, (struct ff7_game_obj *)game_object);
2382: 	else ff8gl_field_78((struct ff8_polygon_set *)polygon_set, (struct ff8_game_obj *)game_object);
2383: }
2384: 
2385: // called by the game to render an instance that has been deferred by the above
2386: // function, this is a feature of the original game, not to be confused with
2387: // our own deferred rendering!
2388: void common_draw_deferred(struct struc_77 *struc_77, struct game_obj *game_object)
2389: {
2390: 	VOBJ(polygon_set, polygon_set, struc_77->polygon_set);
2391: 	struct p_hundred *hundred_data = struc_77->hundred_data;
2392: 	struct indexed_primitive *ip;
2393: 
2394: 	if(trace_all) ffnx_trace("dll_gfx: draw_deferred\n");
2395: 
2396: 	if(!VREF(polygon_set, indexed_primitives)) return;
2397: 
2398: 	ip = VREF(polygon_set, indexed_primitives[struc_77->current_group]);
2399: 
2400: 	if(!ip) return;
2401: 
2402: 	common_setrenderstate(hundred_data, game_object);
2403: 
2404: 	if(struc_77->use_matrix) gl_set_worldview_matrix(&struc_77->matrix);
2405: 	if(struc_77->use_matrix_pointer) gl_set_worldview_matrix(struc_77->matrix_pointer);
2406: 
2407: 	if (!ff8 && enable_lighting) gl_draw_with_lighting(ip, VREF(polygon_set, polygon_data), nullptr, VREF(polygon_set, field_4));
2408: 	else gl_draw_without_lighting(ip, VREF(polygon_set, polygon_data), nullptr, VREF(polygon_set, field_4));
2409: }
2410: 
2411: // called by the game to render a graphics object, basically a wrapper for
2412: // field_78
2413: void common_field_80(struct graphics_object *graphics_object, struct game_obj *game_object)
2414: {
2415: 	VOBJ(graphics_object, graphics_object, graphics_object);
2416: 
2417: 	if(trace_all) ffnx_trace("dll_gfx: field_80\n");
2418: 
2419: 	if(!VPTR(graphics_object)) return;
2420: 
2421: 	common_field_78(VREF(graphics_object, polygon_set), game_object);
2422: }
2423: 
2424: // called by the game to draw some predefined polygon sets, no idea what this
2425: // is really used for
2426: void common_field_84(uint32_t unknown, struct game_obj *game_object)
2427: {
2428: 	VOBJ(game_obj, game_object, game_object);
2429: 	VOBJ(polygon_set, polygon_set_2EC, VREF(game_object, polygon_set_2EC));
2430: 	VOBJ(polygon_set, polygon_set_2F0, VREF(game_object, polygon_set_2F0));
2431: 
2432: 	if(trace_all) ffnx_trace("dll_gfx: field_84\n");
2433: 
2434: 	if(!VREF(game_object, in_scene)) return;
2435: 
2436: 	VRASS(game_object, field_928, unknown);
2437: 
2438: 	if(!unknown)
2439: 	{
2440: 		VRASS(polygon_set_2EC, field_0, true);
2441: 		VRASS(polygon_set_2F0, field_0, false);
2442: 		common_field_78(VREF(game_object, polygon_set_2EC), game_object);
2443: 	}
2444: 
2445: 	else
2446: 	{
2447: 		VRASS(polygon_set_2EC, field_0, false);
2448: 		VRASS(polygon_set_2F0, field_0, true);
2449: 		common_field_78(VREF(game_object, polygon_set_2F0), game_object);
2450: 	}
2451: }
2452: 
2453: // called by the game to setup a new scene for rendering
2454: // scenes are not stacked in FF7
2455: // FF8 relies on the ability to stack scenes, saving and later reverting to a previous render state
2456: uint32_t common_begin_scene(uint32_t unknown, struct game_obj *game_object)
2457: {
2458: 	VOBJ(game_obj, game_object, game_object);
2459: 
2460: 	if(trace_all) ffnx_trace("dll_gfx: begin_scene\n");
2461: 
2462: 	if(scene_stack_pointer == sizeof(scene_stack) / sizeof(scene_stack[0])) ffnx_glitch("scene stack overflow\n");
2463: 	else gl_save_state(&scene_stack[scene_stack_pointer++]);
2464: 
2465: 	VRASS(game_object, in_scene, VREF(game_object, in_scene) + 1);
2466: 
2467: 	common_field_84(unknown, game_object);
2468: 
2469: 	return true;
2470: }
2471: 
2472: // called by the game to end a scene previously setup by the above function
2473: // render state will be restored to what it was before the scene was created
2474: void common_end_scene(struct game_obj *game_object)
2475: {
2476: 	VOBJ(game_obj, game_object, game_object);
2477: 
2478: 	if(trace_all) ffnx_trace("dll_gfx: end_scene\n");
2479: 
2480: 	if(!scene_stack_pointer) ffnx_glitch("scene stack underflow\n");
2481: 	else gl_load_state(&scene_stack[--scene_stack_pointer]);
2482: 
2483: 	if(VREF(game_object, in_scene)) VRASS(game_object, in_scene, VREF(game_object, in_scene) - 1);
2484: }
2485: 
2486: // noop
2487: void common_field_90(uint32_t unknown)
2488: {
2489: 	ffnx_glitch_once("dll_gfx: field_90 (not implemented)\n");
2490: }
2491: 
2492: // helper function used to draw a set of triangles without palette data
2493: void generic_draw(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object, uint32_t vertextype)
2494: {
2495: 	VOBJ(polygon_set, polygon_set, polygon_set);
2496: 	VOBJ(indexed_vertices, iv, iv);
2497: 
2498: 	gl_draw_indexed_primitive(RendererPrimitiveType::PT_TRIANGLES, vertextype, VREF(iv, vertices), 0,  VREF(iv, vertexcount), VREF(iv, indices), VREF(iv, indexcount), UNSAFE_VREF(graphics_object, iv, graphics_object), 0, 0, VREF(polygon_set, field_4), true);
2499: }
2500: 
2501: // helper function used to draw a set of triangles with palette data
2502: void generic_draw_paletted(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object, uint32_t vertextype)
2503: {
2504: 	VOBJ(polygon_set, polygon_set, polygon_set);
2505: 	VOBJ(indexed_vertices, iv, iv);
2506: 	uint32_t count = VREF(iv, count);
2507: 	unsigned char *palettes = VREF(iv, palettes);
2508: 	struct p_hundred *hundred_data = VREF(polygon_set, hundred_data);
2509: 	struct nvertex *vertices;
2510: 	struct nvertex *_vertices = VREF(iv, vertices);
2511: 	WORD *indices = VREF(iv, indices);
2512: 
2513: 	if(!VREF(polygon_set, field_2C)) return;
2514: 
2515: 	while(count > 0)
2516: 	{
2517: 		VOBJ(graphics_object, graphics_object, UNSAFE_VREF(graphics_object, iv, graphics_object));
2518: 		VOBJ(texture_set, texture_set, hundred_data->texture_set);
2519: 		uint32_t palette_index = *palettes++;
2520: 		uint32_t var30 = 1;
2521: 		uint32_t vertexcount = VREF(graphics_object, vertices_per_shape);
2522: 		uint32_t indexcount = VREF(graphics_object, indices_per_shape);
2523: 
2524: 		vertices = _vertices;
2525: 
2526: 		VRASS(texture_set, palette_index, palette_index);
2527: 
2528: 		common_palette_changed(0, 0, 0, VREF(texture_set, palette), hundred_data->texture_set);
2529: 
2530: 		while(var30 < count)
2531: 		{
2532: 			if(*palettes != palette_index) break;
2533: 
2534: 			palettes++;
2535: 
2536: 			vertexcount += VREF(graphics_object, vertices_per_shape);
2537: 			indexcount += VREF(graphics_object, indices_per_shape);
2538: 
2539: 			var30++;
2540: 		}
2541: 
2542: 		_vertices = &_vertices[VREF(graphics_object, vertices_per_shape) * var30];
2543: 
2544: 		count -= var30;
2545: 
2546: 		gl_draw_indexed_primitive(RendererPrimitiveType::PT_TRIANGLES, vertextype, vertices, 0, vertexcount, VREF(iv, indices), indexcount, UNSAFE_VREF(graphics_object, iv, graphics_object), 0, 0, VREF(polygon_set, field_4), true);
2547: 	}
2548: }
2549: 
2550: // called by the game to set the render state for a set of 2D triangles
2551: void common_setrenderstate_2D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
2552: {
2553: 	VOBJ(polygon_set, polygon_set, polygon_set);
2554: 
2555: 	if(trace_all) ffnx_trace("dll_gfx: setrenderstate_2D\n");
2556: 
2557: 	if(!VREF(polygon_set, field_2C)) return;
2558: 
2559: 	common_setrenderstate(VREF(polygon_set, hundred_data), game_object);
2560: }
2561: 
2562: // called by the game to draw a set of 2D triangles without palette data
2563: void common_draw_2D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
2564: {
2565: 	if(trace_all) ffnx_trace("dll_gfx: draw_2D\n");
2566: 
2567: 	generic_draw(polygon_set, iv, game_object, TLVERTEX);
2568: }
2569: 
2570: // called by the game to draw a set of 2D triangles with palette data
2571: void common_draw_paletted2D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
2572: {
2573: 	if(trace_all) ffnx_trace("dll_gfx: draw_paletted2D\n");
2574: 
2575: 	generic_draw_paletted(polygon_set, iv, game_object, TLVERTEX);
2576: }
2577: 
2578: // called by the game to set the render state for a set of 3D triangles
2579: void common_setrenderstate_3D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
2580: {
2581: 	VOBJ(polygon_set, polygon_set, polygon_set);
2582: 	VOBJ(indexed_vertices, iv, iv);
2583: 	VOBJ(graphics_object, graphics_object, UNSAFE_VREF(graphics_object, iv, graphics_object));
2584: 
2585: 	if(trace_all) ffnx_trace("dll_gfx: setrenderstate_3D\n");
2586: 
2587: 	if(!VREF(polygon_set, field_2C)) return;
2588: 
2589: 	common_setrenderstate(VREF(polygon_set, hundred_data), game_object);
2590: 
2591: 	if(VREF(graphics_object, use_matrix_pointer)) gl_set_worldview_matrix(VREF(graphics_object, matrix_pointer));
2592: 	else gl_set_worldview_matrix(VREFP(graphics_object, matrix));
2593: }
2594: 
2595: // called by the game to draw a set of 3D triangles without palette data
2596: void common_draw_3D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
2597: {
2598: 	if(trace_all) ffnx_trace("dll_gfx: draw_3D\n");
2599: 
2600: 	generic_draw(polygon_set, iv, game_object, LVERTEX);
2601: }
2602: 
2603: // called by the game to draw a set of 3D triangles with palette data
2604: void common_draw_paletted3D(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
2605: {
2606: 	if(trace_all) ffnx_trace("dll_gfx: draw_paletted3D\n");
2607: 
2608: 	generic_draw_paletted(polygon_set, iv, game_object, LVERTEX);
2609: }
2610: 
2611: // called by the game to draw a set of lines
2612: void common_draw_lines(struct polygon_set *polygon_set, struct indexed_vertices *iv, struct game_obj *game_object)
2613: {
2614: 	VOBJ(polygon_set, polygon_set, polygon_set);
2615: 	VOBJ(indexed_vertices, iv, iv);
2616: 
2617: 	if(trace_all) ffnx_trace("dll_gfx: draw_lines\n");
2618: 
2619: 	gl_draw_indexed_primitive(RendererPrimitiveType::PT_LINES, TLVERTEX, VREF(iv, vertices), 0, VREF(iv, vertexcount), VREF(iv, indices), VREF(iv, indexcount), UNSAFE_VREF(graphics_object, iv, graphics_object), 0, 0, VREF(polygon_set, field_4), true);
2620: }
2621: 
2622: // noop
2623: void common_field_EC(struct game_obj *game_object)
2624: {
2625: 	ffnx_glitch_once("dll_gfx: field_EC (not implemented)\n");
2626: }
2627: 
2628: // create a suitable tex header to be processed by the framebuffer texture loader
2629: struct tex_header *make_framebuffer_tex(uint32_t tex_w, uint32_t tex_h, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color_key)
2630: {
2631: 	struct tex_header* _header = common_externals.create_tex_header();
2632: 
2633: 	VOBJ(tex_header, tex_header, _header);
2634: 
2635: 	VRASS(tex_header, bpp, 32);
2636: 	VRASS(tex_header, color_key, color_key);
2637: 	memcpy(VREFP(tex_header, tex_format), texture_format, sizeof(struct texture_format));
2638: 
2639: 	VRASS(tex_header, tex_format.alpha_max, 0);
2640: 
2641: 	VRASS(tex_header, tex_format.width, tex_w);
2642: 	VRASS(tex_header, tex_format.height, tex_h);
2643: 
2644: 	VRASS(tex_header, version, FB_TEX_VERSION);
2645: 
2646: 	VRASS(tex_header, fb_tex.x, x);
2647: 	VRASS(tex_header, fb_tex.y, y);
2648: 	VRASS(tex_header, fb_tex.w, w);
2649: 	VRASS(tex_header, fb_tex.h, h);
2650: 
2651: 	return _header;
2652: }
2653: 
2654: time_t qpc_get_time(time_t *dest)
2655: {
2656: 	QueryPerformanceCounter((LARGE_INTEGER *)dest);
2657: 
2658: 	stats.timer = *dest;
2659: 
2660: 	return *dest;
2661: }
2662: 
2663: time_t qpc_diff_time(time_t* t1, time_t* t2, time_t* out)
2664: {
2665: 	time_t ret = *t1 - *t2;
2666: 
2667: 	if (out != nullptr) *out = ret;
2668: 
2669: 	return ret;
2670: }
2671: 
2672: // version check reads from a given offset in memory
2673: uint32_t version_check(uint32_t offset)
2674: {
2675: 	return (*(uint32_t *)(offset));
2676: }
2677: 
2678: // figure out if we are running in FF7 or FF8 and detect which version
2679: uint32_t get_version()
2680: {
2681: 	uint32_t version_check1 = version_check(0x401004);
2682: 	uint32_t version_check2 = version_check(0x401404);
2683: 
2684: 	ffnx_trace("v1: 0x%X, v2: 0x%X\n", version_check1, version_check2);
2685: 
2686: 	if(version_check1 == 0x99CE0805)
2687: 	{
2688: 		ffnx_info("Auto-detected version: FF7 1.02 US English\n");
2689: 		return VERSION_FF7_102_US;
2690: 	}
2691: 	else if(version_check1 == 0x99EBF805)
2692: 	{
2693: 		ffnx_info("Auto-detected version: FF7 1.02 French\n");
2694: 		return VERSION_FF7_102_FR;
2695: 	}
2696: 	else if(version_check1 == 0x99DBC805)
2697: 	{
2698: 		ffnx_info("Auto-detected version: FF7 1.02 German\n");
2699: 		return VERSION_FF7_102_DE;
2700: 	}
2701: 	else if(version_check1 == 0x99F65805)
2702: 	{
2703: 		ffnx_info("Auto-detected version: FF7 1.02 Spanish\n");
2704: 		return VERSION_FF7_102_SP;
2705: 	}
2706: 	else if(version_check1 == 0x3885048D && version_check2 == 0x159618)
2707: 	{
2708: 		ffnx_info("Auto-detected version: FF8 1.2 US English\n");
2709: 		return VERSION_FF8_12_US;
2710: 	}
2711: 	else if(version_check1 == 0x3885048D && version_check2 == 0x1597C8)
2712: 	{
2713: 		ffnx_info("Auto-detected version: FF8 1.2 US English (Nvidia)\n");
2714: 		return VERSION_FF8_12_US_NV;
2715: 	}
2716: 	else if(version_check1 == 0x1085048D && version_check2 == 0x159B48)
2717: 	{
2718: 		ffnx_info("Auto-detected version: FF8 1.2 French\n");
2719: 		return VERSION_FF8_12_FR;
2720: 	}
2721: 	else if(version_check1 == 0x1085048D && version_check2 == 0x159CF8)
2722: 	{
2723: 		ffnx_info("Auto-detected version: FF8 1.2 French (Nvidia)\n");
2724: 		return VERSION_FF8_12_FR_NV;
2725: 	}
2726: 	else if(version_check1 == 0xA885048D && version_check2 == 0x159C48)
2727: 	{
2728: 		ffnx_info("Auto-detected version: FF8 1.2 German\n");
2729: 		return VERSION_FF8_12_DE;
2730: 	}
2731: 	else if(version_check1 == 0xA885048D && version_check2 == 0x159DF8)
2732: 	{
2733: 		ffnx_info("Auto-detected version: FF8 1.2 German (Nvidia)\n");
2734: 		return VERSION_FF8_12_DE_NV;
2735: 	}
2736: 	else if(version_check1 == 0x8085048D && version_check2 == 0x159C38)
2737: 	{
2738: 		ffnx_info("Auto-detected version: FF8 1.2 Spanish\n");
2739: 		return VERSION_FF8_12_SP;
2740: 	}
2741: 	else if(version_check1 == 0x8085048D && version_check2 == 0x159DE8)
2742: 	{
2743: 		ffnx_info("Auto-detected version: FF8 1.2 Spanish (Nvidia)\n");
2744: 		return VERSION_FF8_12_SP_NV;
2745: 	}
2746: 	else if(version_check1 == 0xB885048D && version_check2 == 0x159BC8)
2747: 	{
2748: 		ffnx_info("Auto-detected version: FF8 1.2 Italian\n");
2749: 		return VERSION_FF8_12_IT;
2750: 	}
2751: 	else if(version_check1 == 0xB885048D && version_check2 == 0x159D78)
2752: 	{
2753: 		ffnx_info("Auto-detected version: FF8 1.2 Italian (Nvidia)\n");
2754: 		return VERSION_FF8_12_IT_NV;
2755: 	}
2756: 	else if(version_check1 == 0x2885048D && version_check2 == 0x159598)
2757: 	{
2758: 		ffnx_info("Auto-detected version: FF8 1.2 US English (Eidos Patch)\n");
2759: 		return VERSION_FF8_12_US_EIDOS;
2760: 	}
2761: 	else if(version_check1 == 0x2885048D && version_check2 == 0x159748)
2762: 	{
2763: 		ffnx_info("Auto-detected version: FF8 1.2 US English (Eidos Patch) (Nvidia)\n");
2764: 		return VERSION_FF8_12_US_EIDOS_NV;
2765: 	}
2766: 	else if(version_check1 == 0x1B6E9CC && version_check2 == 0x7C8DFFC9)
2767: 	{
2768: 		uint32_t version_check3 = version_check(0x401010);
2769: 
2770: 		if (version_check3 == 0x24AC)
2771: 		{
2772: 			ffnx_info("Auto-detected version: FF8 1.2 Japanese (Nvidia)\n");
2773: 			return VERSION_FF8_12_JP_NV;
2774: 		}
2775: 
2776: 		ffnx_info("Auto-detected version: FF8 1.2 Japanese\n");
2777: 		return VERSION_FF8_12_JP;
2778: 	}
2779: 
2780: 	return 0;
2781: }
2782: 
2783: void get_data_lang_path(PCHAR buffer)
2784: {
2785: 	strcpy(buffer, ff8 ? ff8_externals.app_path : basedir);
2786: 	PathAppendA(buffer, R"(data\lang-)");
2787: 	switch (version)
2788: 	{
2789: 	case VERSION_FF7_102_US:
2790: 	case VERSION_FF8_12_US_NV:
2791: 	case VERSION_FF8_12_US_EIDOS_NV:
2792: 		if (ff7_japanese_edition)
2793: 			strcat(buffer, "ja");
2794: 		else
2795: 			strcat(buffer, "en");
2796: 		break;
2797: 	case VERSION_FF7_102_FR:
2798: 	case VERSION_FF8_12_FR_NV:
2799: 		strcat(buffer, "fr");
2800: 		break;
2801: 	case VERSION_FF7_102_DE:
2802: 	case VERSION_FF8_12_DE_NV:
2803: 		strcat(buffer, "de");
2804: 		break;
2805: 	case VERSION_FF7_102_SP:
2806: 	case VERSION_FF8_12_SP_NV:
2807: 		strcat(buffer, "es");
2808: 		break;
2809: 	case VERSION_FF8_12_IT_NV:
2810: 		strcat(buffer, "it");
2811: 		break;
2812: 	case VERSION_FF8_12_JP:
2813: 		strcat(buffer, "jp");
2814: 		break;
2815: 	}
2816: }
2817: 
2818: void get_userdata_path(PCHAR buffer, size_t bufSize, bool isSavegameFile)
2819: {
2820: 	PWSTR outPath = NULL;
2821: 
2822: 	HRESULT hr = SHGetKnownFolderPath(FOLDERID_Documents, KF_FLAG_DEFAULT, NULL, &outPath);
2823: 
2824: 	if (SUCCEEDED(hr))
2825: 	{
2826: 		wcstombs(buffer, outPath, bufSize);
2827: 
2828: 		CoTaskMemFree(outPath);
2829: 
2830: 		if (ff8)
2831: 			PathAppendA(buffer, R"(Square Enix\FINAL FANTASY VIII Steam)");
2832: 		else
2833: 			PathAppendA(buffer, R"(Square Enix\FINAL FANTASY VII Steam)");
2834: 
2835: 		if (isSavegameFile)
2836: 		{
2837: 			if (!steam_game_userdata.empty())
2838: 			{
2839: 				// Directly use the given userdata
2840: 				PathAppendA(buffer, steam_game_userdata.c_str());
2841: 			}
2842: 			else
2843: 			{
2844: 				// Search for the first "user_" match in the game path
2845: 				CHAR searchPath[MAX_PATH];
2846: 				WIN32_FIND_DATA pathFound;
2847: 				HANDLE hFind;
2848: 
2849: 				strcpy(searchPath, buffer);
2850: 				strcat(searchPath, R"(\user_*)");
2851: 				if (hFind = FindFirstFileA(searchPath, &pathFound))
2852: 				{
2853: 					PathAppendA(buffer, pathFound.cFileName);
2854: 					FindClose(hFind);
2855: 				}
2856: 			}
2857: 		}
2858: 	}
2859: }
2860: 
2861: // cd check
2862: uint32_t ff7_get_inserted_cd(void) {
2863: 	int ret = 1;
2864: 
2865: 	if(steam_edition || enable_steam_achievements){
2866: 		if (trace_all || trace_achievement)
2867: 			ffnx_trace("inserted CD: %d, requiredCD: %d\n", *ff7_externals.insertedCD, *ff7_externals.requiredCD);
2868: 
2869: 		if(*ff7_externals.requiredCD == *ff7_externals.insertedCD + 1)
2870: 			g_FF7SteamAchievements->unlockGameProgressAchievement();
2871: 	}
2872: 
2873: 	if (*ff7_externals.requiredCD > 0 && *ff7_externals.requiredCD <= 3) ret = *ff7_externals.requiredCD;
2874: 
2875: 	*ff7_externals.insertedCD = ret;
2876: 
2877: 	return ret;
2878: }
2879: 
2880: MCIERROR __stdcall dotemuMciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
2881: {
2882: 	DWORD mciStatusRet;
2883: 
2884: 	switch (uMsg)
2885: 	{
2886: 	case MCI_OPEN:
2887: 		((LPDWORD)dwParam2)[2] = (DWORD)"waveaudio";
2888: 		dwParam1 = 8704;
2889: 		((LPDWORD)dwParam2)[3] = (DWORD)R"(Data\Music\eyes_on_me.wav)";
2890: 		return mciSendCommandA(mciId, uMsg, dwParam1, dwParam2);
2891: 	case MCI_SET:
2892: 		((LPDWORD)dwParam2)[1] = 0;
2893: 		break;
2894: 	case MCI_STATUS:
2895: 		mciStatusRet = 0;
2896: 		((LPDWORD)dwParam2)[1] = (DWORD)&mciStatusRet;
2897: 		return 0;
2898: 	case MCI_PLAY:
2899: 		((LPDWORD)dwParam2)[2] = 339000;
2900: 		break;
2901: 	}
2902: 
2903: 	return mciSendCommandA(mciId, uMsg, dwParam1, dwParam2);
2904: }
2905: 
2906: #if defined(__cplusplus)
2907: extern "C" {
2908: #endif
2909: 
2910: // main entry point, called by the game to create a graphics driver object
2911: __declspec(dllexport) void *new_dll_graphics_driver(void *game_object)
2912: {
2913: 	void *ret;
2914: 
2915: 	// game-specific initialization
2916: 	if(!ff8)
2917: 		ret = ff7_load_driver(game_object);
2918: 	else
2919: 		ret = ff8_load_driver(game_object);
2920: 
2921: 	return ret;
2922: }
2923: 
2924: BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
2925: {
2926: 	if (fdwReason == DLL_PROCESS_ATTACH)
2927: 	{
2928: 		// Enable the following block if you wish to use VS2019 ReAttach extension
2929: 		/*
2930: 		while (!IsDebuggerPresent())
2931: 		{
2932: 			Sleep(100);
2933: 		}
2934: 		__debugbreak();
2935: 		*/
2936: 
2937: 		// Push the limit of how many files we can open at the same time to the maximum available on Windows
2938: 		// See https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setmaxstdio?view=msvc-160#remarks
2939: 		_setmaxstdio(8192);
2940: 
2941: 		SetProcessDPIAware();
2942: 
2943: 		GetCurrentDirectoryA(BASEDIR_LENGTH, basedir);
2944: 
2945: 		// install crash handler
2946: 		open_applog("FFNx.log");
2947: 		SetUnhandledExceptionFilter(ExceptionHandler);
2948: 
2949: 		// prevent screensavers
2950: 		SetThreadExecutionState(ES_CONTINUOUS | ES_DISPLAY_REQUIRED | ES_SYSTEM_REQUIRED);
2951: 
2952: 		ffnx_info("FFNx driver version " VERSION "\n");
2953: 		version = get_version();
2954: 		if (version >= VERSION_FF8_12_US)
2955: 		{
2956: 			ff8 = true;
2957: 		}
2958: 		else if (version == VERSION_FF7_102_US)
2959: 		{
2960: #include "externals_102_us.h"
2961: 		}
2962: 		else if (version == VERSION_FF7_102_FR)
2963: 		{
2964: #include "externals_102_fr.h"
2965: 		}
2966: 		else if (version == VERSION_FF7_102_DE)
2967: 		{
2968: #include "externals_102_de.h"
2969: 		}
2970: 		else if (version == VERSION_FF7_102_SP)
2971: 		{
2972: #include "externals_102_sp.h"
2973: 		}
2974: 
2975: 		if (!version)
2976: 		{
2977: 			ffnx_unexpected("no compatible version found\n");
2978: 			MessageBoxA(NULL, "Your ff7.exe or ff8.exe is incompatible with this driver and will exit after this message.\n"
2979: 				"Possible reasons for this error:\n"
2980: 				" - You have the faulty \"1.4 XP Patch\" for FF7.\n"
2981: 				" - You have FF7 retail 1.00 version (you need the 1.02 patch).\n"
2982: 				" - You have an unsupported translation of FF7. (US English, French, German and Spanish versions are currently supported)\n"
2983: 				" - You have FF8 retail 1.0 version (you need the 1.2 patch).\n"
2984: 				" - You have an unsupported translation of FF8. (US English, French, German, Spanish, Italian and Japanese versions are currently supported)\n"
2985: 				" - You have a conflicting patch applied.\n\n"
2986: 				, "Error", MB_ICONERROR | MB_OK);
2987: 			return FALSE;
2988: 		}
2989: 
2990: 		bool is_genuine_steam_api = isFileSigned(L"steam_api.dll");
2991: 		if (!is_genuine_steam_api) is_genuine_steam_api = sha1_file("steam_api.dll") == "03bd9f3e352553a0af41f5fe006f6249a168c243";
2992: 		if (!is_genuine_steam_api)
2993: 		{
2994: 			ffnx_unexpected("Invalid steam_api.dll detected. Please ensure your FFNx installation is not corrupted or tampered by unauthorized software.\n");
2995: 			MessageBoxA(NULL, "Invalid steam_api.dll detected. Please ensure your FFNx installation is not corrupted or tampered by unauthorized software.", "Error", MB_ICONERROR | MB_OK);
2996: 			return FALSE;
2997: 		}
2998: 
2999: 		read_cfg();
3000: 
3001: 		// Did user choose to enable Widescreen?
3002: 		widescreen_enabled = (aspect_ratio == AR_WIDESCREEN_16X9 || aspect_ratio == AR_WIDESCREEN_16X10);
3003: 
3004: 		// Get current process name
3005: 		CHAR parentName[1024];
3006: 		GetModuleFileNameA(NULL, parentName, sizeof(parentName));
3007: 		_strlwr(parentName);
3008: 
3009: 		// Get our filesystem name
3010: 		CHAR dllName[1024];
3011: 		GetModuleFileNameA((HMODULE)hinstDLL, dllName, sizeof(dllName));
3012: 		_strlwr(dllName);
3013: 
3014: 		if (!ff8)
3015: 		{
3016: 			common_externals.winmain = get_relative_call(common_externals.start, 0x14D);
3017: 			replace_function(ff7_externals.get_inserted_cd_sub, ff7_get_inserted_cd);
3018: 			replace_function(common_externals.create_window, common_create_window);
3019: 
3020: 			if (strstr(dllName, "af3dn.p") != NULL)
3021: 			{
3022: 				ff7_japanese_edition = strstr(parentName, "ff7_ja.exe") != NULL;
3023: 
3024: 				// Steam edition is usually installed in this path
3025: 				if (strstr(basedir, "steamapps") != NULL) {
3026: 					ffnx_trace("Detected Steam edition.\n");
3027: 					steam_edition = true;
3028: 
3029: 					// Read ff7sound.cfg
3030: 					char ff7soundPath[260]{ 0 };
3031: 					get_userdata_path(ff7soundPath, sizeof(ff7soundPath), false);
3032: 					PathAppendA(ff7soundPath, "ff7sound.cfg");
3033: 					FILE* ff7sound = fopen(ff7soundPath, "rb");
3034: 
3035: 					if (ff7sound)
3036: 					{
3037: 						if (external_sfx_volume < 0) fread(&external_sfx_volume, sizeof(DWORD), 1, ff7sound);
3038: 						if (external_music_volume < 0) fread(&external_music_volume, sizeof(DWORD), 1, ff7sound);
3039: 						fclose(ff7sound);
3040: 					}
3041: 				}
3042: 				// otherwise it's the eStore edition which has same exe names but installed somewhere else
3043: 				else
3044: 				{
3045: 					ffnx_trace("Detected eStore edition.\n");
3046: 					estore_edition = true;
3047: 				}
3048: 
3049: 				if (external_voice_volume < 0) external_voice_volume = 100;
3050: 				if (external_ambient_volume < 0) external_ambient_volume = 100;
3051: 				if (ffmpeg_video_volume < 0) ffmpeg_video_volume = 100;
3052: 
3053: 				use_external_music = true;
3054: 				if (external_music_path.empty()) external_music_path = "data/music_ogg";
3055: 
3056: 			}
3057: 			else
3058: 			{
3059: 				HKEY ff7_regkey;
3060: 				DWORD regsize = sizeof(DWORD);
3061: 
3062: 				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, R"(Software\Square Soft, Inc.\Final Fantasy VII\1.00\MIDI)", 0, KEY_QUERY_VALUE | KEY_WOW64_32KEY, &ff7_regkey) == ERROR_SUCCESS)
3063: 					if (external_music_volume < 0) RegQueryValueEx(ff7_regkey, "MusicVolume", NULL, NULL, (LPBYTE)&external_music_volume, &regsize);
3064: 
3065: 				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, R"(Software\Square Soft, Inc.\Final Fantasy VII\1.00\Sound)", 0, KEY_QUERY_VALUE | KEY_WOW64_32KEY, &ff7_regkey) == ERROR_SUCCESS)
3066: 					if (external_sfx_volume < 0) RegQueryValueEx(ff7_regkey, "SFXVolume", NULL, NULL, (LPBYTE)&external_sfx_volume, &regsize);
3067: 
3068: 				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, R"(Software\Square Soft, Inc.\Final Fantasy VII\1.00\FFNx)", 0, KEY_QUERY_VALUE | KEY_WOW64_32KEY, &ff7_regkey) == ERROR_SUCCESS)
3069: 				{
3070: 					if (external_ambient_volume < 0) RegQueryValueEx(ff7_regkey, "AmbientVolume", NULL, NULL, (LPBYTE)&external_ambient_volume, &regsize);
3071: 					if (ffmpeg_video_volume < 0) RegQueryValueEx(ff7_regkey, "MovieVolume", NULL, NULL, (LPBYTE)&ffmpeg_video_volume, &regsize);
3072: 					if (external_voice_volume < 0) RegQueryValueEx(ff7_regkey, "VoiceVolume", NULL, NULL, (LPBYTE)&external_voice_volume, &regsize);
3073: 				}
3074: 
3075: 				if (external_music_path.empty()) external_music_path = "music/vgmstream";
3076: 			}
3077: 		}
3078: 		else if (ff8)
3079: 		{
3080: 			// Save start address for later
3081: 			switch (version)
3082: 			{
3083: 			case VERSION_FF8_12_US:
3084: 				ff8_externals.start = 0x55AC07;
3085: 				break;
3086: 			case VERSION_FF8_12_US_NV:
3087: 				ff8_externals.start = 0x55ADB7;
3088: 				break;
3089: 			case VERSION_FF8_12_FR:
3090: 				ff8_externals.start = 0x55B137;
3091: 				break;
3092: 			case VERSION_FF8_12_FR_NV:
3093: 				ff8_externals.start = 0x55B2E7;
3094: 				break;
3095: 			case VERSION_FF8_12_DE:
3096: 				ff8_externals.start = 0x55B237;
3097: 				break;
3098: 			case VERSION_FF8_12_DE_NV:
3099: 				ff8_externals.start = 0x55B3E7;
3100: 				break;
3101: 			case VERSION_FF8_12_SP:
3102: 				ff8_externals.start = 0x55B227;
3103: 				break;
3104: 			case VERSION_FF8_12_SP_NV:
3105: 				ff8_externals.start = 0x55B3D7;
3106: 				break;
3107: 			case VERSION_FF8_12_IT:
3108: 				ff8_externals.start = 0x55B1B7;
3109: 				break;
3110: 			case VERSION_FF8_12_IT_NV:
3111: 				ff8_externals.start = 0x55B367;
3112: 				break;
3113: 			case VERSION_FF8_12_US_EIDOS:
3114: 				ff8_externals.start = 0x55AB87;
3115: 				break;
3116: 			case VERSION_FF8_12_US_EIDOS_NV:
3117: 				ff8_externals.start = 0x55AD37;
3118: 				break;
3119: 			case VERSION_FF8_12_JP:
3120: 				ff8_externals.start = 0x55F487;
3121: 				break;
3122: 			case VERSION_FF8_12_JP_NV:
3123: 				ff8_externals.start = 0x55F6E7;
3124: 				break;
3125: 			}
3126: 
3127: 			if (version == VERSION_FF8_12_US_EIDOS || version == VERSION_FF8_12_US_EIDOS_NV)
3128: 			{
3129: 				MessageBoxA(NULL, "Old Eidos patch detected, please update to the newer 1.2 patch from Square.\n"
3130: 					"The old patch may or may not work properly, it is not supported and has not been tested.",
3131: 					"Warning", 0);
3132: 			}
3133: 
3134: 			ff8_data();
3135: 
3136: 			replace_function(common_externals.create_window, common_create_window);
3137: 			replace_function(ff8_externals.manage_time_engine_sub_569971, ff8_manage_time_engine);
3138: 
3139: 			game_cfg_init();
3140: 
3141: 			if (strstr(dllName, "af3dn.p") != NULL)
3142: 			{
3143: 				ffnx_trace("Detected Steam edition.\n");
3144: 
3145: 				steam_edition = true;
3146: 
3147: 				// Detect if FF8 Stock Launcher
3148: 				if (contains(getCopyrightInfoFromExe("FF8_Launcher.exe"), "SQUARE ENIX CO., LTD"))
3149: 				{
3150: 					steam_stock_launcher = true;
3151: 					ffnx_trace("Detected Steam stock launcher.\n");
3152: 				}
3153: 
3154: 				// Steam edition contains movies unpacked
3155: 				enable_ffmpeg_videos = true;
3156: 
3157: 				// Eyes on me patch
3158: 
3159: 				DWORD mciSendCommandA;
3160: 
3161: 				switch (version)
3162: 				{
3163: 				case VERSION_FF8_12_US_NV:
3164: 				case VERSION_FF8_12_FR_NV:
3165: 				case VERSION_FF8_12_DE_NV:
3166: 				case VERSION_FF8_12_SP_NV:
3167: 				case VERSION_FF8_12_IT_NV:
3168: 					mciSendCommandA = 0xB69388;
3169: 					break;
3170: 				case VERSION_FF8_12_JP:
3171: 					mciSendCommandA = 0x2CA3DC8;
3172: 					break;
3173: 				}
3174: 
3175: 				patch_code_dword(mciSendCommandA, (DWORD)dotemuMciSendCommandA);
3176: 			}
3177: 
3178: 			if (external_music_path.empty()) external_music_path = "data/music/dmusic/ogg";
3179: 			if (external_music_volume < 0) external_music_volume = 100;
3180: 			if (external_sfx_volume < 0) external_sfx_volume = 100;
3181: 			if (external_voice_volume < 0) external_voice_volume = 100;
3182: 			if (external_ambient_volume < 0) external_ambient_volume = 100;
3183: 			if (ffmpeg_video_volume < 0) ffmpeg_video_volume = 100;
3184: 		}
3185: 
3186: 		// Init metadata patcher
3187: 		if (steam_edition) metadataPatcher.init();
3188: 
3189: 		// Apply hext patching
3190: 		hextPatcher.applyAll();
3191: 	}
3192: 	else if (fdwReason == DLL_PROCESS_DETACH)
3193: 	{
3194: 		unreplace_functions();
3195: 	}
3196: 
3197: 	return TRUE;
3198: }
3199: 
3200: // Steam compatibility
3201: __declspec(dllexport) LSTATUS __stdcall dotemuRegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
3202: {
3203: 	return ERROR_SUCCESS;
3204: }
3205: 
3206: __declspec(dllexport) LSTATUS __stdcall dotemuRegCloseKey(HKEY hKey)
3207: {
3208: 	return ERROR_SUCCESS;
3209: }
3210: 
3211: __declspec(dllexport) LSTATUS __stdcall dotemuRegFlushKey(HKEY hKey)
3212: {
3213: 	return ERROR_SUCCESS;
3214: }
3215: 
3216: __declspec(dllexport) LSTATUS __stdcall dotemuRegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
3217: {
3218: 	return ERROR_SUCCESS;
3219: }
3220: 
3221: __declspec(dllexport) LSTATUS __stdcall dotemuRegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, LPBYTE lpData, DWORD cbData)
3222: {
3223: 	if (ff8)
3224: 	{
3225: 		if (strcmp(lpValueName, "SFXVolume") == 0 || strcmp(lpValueName, "MusicVolume") == 0)
3226: 		{
3227: 			if (lpData[0] > 0x64)
3228: 				lpData[0] = 0x64;
3229: 		}
3230: 	}
3231: 	else
3232: 	{
3233: 		if (strcmp(lpValueName, "SFXVolume") == 0)
3234: 		{
3235: 			if (lpData[0] > 0x64)
3236: 				lpData[0] = 0x64;
3237: 
3238: 			external_sfx_volume = lpData[0];
3239: 		}
3240: 		else if (strcmp(lpValueName, "MusicVolume") == 0)
3241: 		{
3242: 			if (lpData[0] > 0x64)
3243: 				lpData[0] = 0x64;
3244: 
3245: 			external_music_volume = lpData[0];
3246: 		}
3247: 	}
3248: 
3249: 	return ERROR_SUCCESS;
3250: }
3251: 
3252: __declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
3253: {
3254: 	LSTATUS ret = ERROR_SUCCESS;
3255: 
3256: 	LPSTR buf = new CHAR[*lpcbData]{ 0 };
3257: 
3258: 	/* FF7 */
3259: 	// General
3260: 	if (strcmp(lpValueName, "AppPath") == 0)
3261: 	{
3262: 		GetCurrentDirectory(*lpcbData, buf);
3263: 		strcat(buf, R"(\)");
3264: 
3265: 		strcpy((CHAR*)lpData, buf);
3266: 	}
3267: 	else if (strcmp(lpValueName, "DataPath") == 0)
3268: 	{
3269: 		GetCurrentDirectory(*lpcbData, buf);
3270: 		strcat(buf, R"(\data\)");
3271: 
3272: 		strcpy((CHAR*)lpData, buf);
3273: 	}
3274: 	else if (strcmp(lpValueName, "DataDrive") == 0)
3275: 	{
3276: 		strcpy((CHAR*)lpData, "CD:");
3277: 	}
3278: 	else if (strcmp(lpValueName, "MoviePath") == 0)
3279: 	{
3280: 		GetCurrentDirectory(*lpcbData, buf);
3281: 		strcat(buf, R"(\data\movies\)");
3282: 
3283: 		strcpy((CHAR*)lpData, buf);
3284: 	}
3285: 	else if (strcmp(lpValueName, "FullInstall") == 0)
3286: 	{
3287: 		lpData[0] = 0x1;
3288: 	}
3289: 	// Audio
3290: 	else if (strcmp(lpValueName, "DD_GUID") == 0 || strcmp(lpValueName, "Sound_GUID") == 0)
3291: 	{
3292: 		memcpy(lpData, buf, *lpcbData);
3293: 	}
3294: 	else if (strcmp(lpValueName, "MIDI_DeviceID") == 0)
3295: 	{
3296: 		lpData[0] = 0x0;
3297: 	}
3298: 	else if (strcmp(lpValueName, "Sound") == 0 || strcmp(lpValueName, "Midi") == 0 || strcmp(lpValueName, "wave_music") == 0)
3299: 	{
3300: 		ret = 2;
3301: 	}
3302: 	else if (strcmp(lpValueName, "SFXVolume") == 0)
3303: 	{
3304: 		lpData[0] = external_sfx_volume;
3305: 	}
3306: 	else if (strcmp(lpValueName, "MusicVolume") == 0)
3307: 	{
3308: 		lpData[0] = external_music_volume;
3309: 	}
3310: 	// Graphics
3311: 	else if (strcmp(lpValueName, "Driver") == 0)
3312: 	{
3313: 		lpData[0] = 0x3;
3314: 	}
3315: 	else if (strcmp(lpValueName, "DriverPath") == 0)
3316: 	{
3317: 		strcpy((CHAR*)lpData, R"(AF3DN.P)");
3318: 	}
3319: 	else if (strcmp(lpValueName, "Mode") == 0)
3320: 	{
3321: 		lpData[0] = 0x2;
3322: 
3323: 		// Steam release is somehow requesting this key multiple times.
3324: 		// Returning 1 will set 2 internally in the engine
3325: 		if (*lpcbData == 256) ret = 1;
3326: 	}
3327: 	else if (strcmp(lpValueName, "Options") == 0)
3328: 	{
3329: 		lpData[0] = 0x0;
3330: 	}
3331: 	/* FF8 */
3332: 	else if (strcmp(lpValueName, "GraphicsGUID") == 0 || strcmp(lpValueName, "SoundGUID") == 0 || strcmp(lpValueName, "MIDIGUID") == 0)
3333: 	{
3334: 		memcpy(lpData, buf, 16);
3335: 	}
3336: 	else if (strcmp(lpValueName, "SoundOptions") == 0)
3337: 	{
3338: 		lpData[0] = 0x00000000;
3339: 	}
3340: 	else if (strcmp(lpValueName, "InstallOptions") == 0)
3341: 	{
3342: 		lpData[0] = 0x000000ff;
3343: 	}
3344: 	else if (strcmp(lpValueName, "MidiOptions") == 0)
3345: 	{
3346: 		lpData[0] = 0x00000001;
3347: 	}
3348: 	else if (strcmp(lpValueName, "Graphics") == 0)
3349: 	{
3350: 		lpData[0] = 0x00100021;
3351: 	}
3352: 
3353: 	delete[] buf;
3354: 
3355: 	return ret;
3356: }
3357: 
3358: __declspec(dllexport) HANDLE __stdcall dotemuCreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
3359: {
3360: 	if (ff8_fs_last_fopen_is_redirected())
3361: 	{
3362: 		return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
3363: 	}
3364: 
3365: 	HANDLE ret = INVALID_HANDLE_VALUE;
3366: 
3367: 	if (strstr(lpFileName, "CD:") != NULL)
3368: 	{
3369: 		CHAR newPath[MAX_PATH]{ 0 };
3370: 		uint8_t requiredDisk = (*ff8_externals.savemap_field)->curr_disk;
3371: 		CHAR diskAsChar[2];
3372: 
3373: 		itoa(requiredDisk, diskAsChar, 10);
3374: 
3375: 		// Search for the last '\' character and get a pointer to the next char
3376: 		const char* pos = strrchr(lpFileName, 92) + 1;
3377: 
3378: 		if (strstr(lpFileName, "DISK1") != NULL || strstr(lpFileName, "DISK2") != NULL || strstr(lpFileName, "DISK3") != NULL || strstr(lpFileName, "DISK4") != NULL)
3379: 		{
3380: 			PathAppendA(newPath, ff8_externals.app_path);
3381: 			PathAppendA(newPath, R"(data\disk)");
3382: 			PathAppendA(newPath, pos);
3383: 
3384: 			if (strstr(lpFileName, diskAsChar) != NULL)
3385: 			{
3386: 				ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
3387: 			}
3388: 		}
3389: 	}
3390: 	else if (strstr(lpFileName, "app.log") || strstr(lpFileName, "ff8input.cfg"))
3391: 	{
3392: 		CHAR newPath[MAX_PATH]{ 0 };
3393: 
3394: 		// Search for the last '\' character and get a pointer to the next char
3395: 		const char* pos = strrchr(lpFileName, 92) + 1;
3396: 
3397: 		get_userdata_path(newPath, sizeof(newPath), false);
3398: 		PathAppendA(newPath, JP_VERSION ? "ff8input_jp.cfg" : pos);
3399: 
3400: 		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
3401: 	}
3402: 	else if (strstr(lpFileName, "temp.fi") || strstr(lpFileName, "temp.fl") || strstr(lpFileName, "temp.fs") || strstr(lpFileName, "temp_evn.") || strstr(lpFileName, "temp_odd."))
3403: 	{
3404: 		CHAR newPath[MAX_PATH]{ 0 };
3405: 
3406: 		// Search for the last '\' character and get a pointer to the next char
3407: 		const char* pos = strrchr(lpFileName, 92) + 1;
3408: 
3409: 		get_userdata_path(newPath, sizeof(newPath), false);
3410: 		PathAppendA(newPath, pos);
3411: 
3412: 		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
3413: 	}
3414: 	else if (strstr(lpFileName, ".fi") != NULL || strstr(lpFileName, ".fl") != NULL || strstr(lpFileName, ".fs") != NULL)
3415: 	{
3416: 		CHAR newPath[MAX_PATH]{ 0 };
3417: 
3418: 		// Search for the last '\' character and get a pointer to the next char
3419: 		const char* pos = strrchr(lpFileName, 92) + 1;
3420: 
3421: 		get_data_lang_path(newPath);
3422: 		PathAppendA(newPath, pos);
3423: 
3424: 		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
3425: 	}
3426: 	else if (StrStrIA(lpFileName, R"(SAVE\)") != NULL) // SAVE\SLOTX\saveN or save\chocorpg
3427: 	{
3428: 		CHAR newPath[MAX_PATH]{ 0 };
3429: 		CHAR saveFileName[50]{ 0 };
3430: 
3431: 		// Search for the next character pointer after "SAVE\"
3432: 		const char* pos = StrStrIA(lpFileName, R"(SAVE\)") + 5;
3433: 		strcpy(saveFileName, pos);
3434: 		_strlwr(saveFileName);
3435: 		char* posSeparator = strstr(saveFileName, R"(\)");
3436: 		if (posSeparator != NULL)
3437: 		{
3438: 			*posSeparator = '_';
3439: 		}
3440: 		strcat(saveFileName, R"(.ff8)");
3441: 
3442: 		get_userdata_path(newPath, sizeof(newPath), true);
3443: 		PathAppendA(newPath, saveFileName);
3444: 
3445: 		ret = CreateFileA(newPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
3446: 	}
3447: 	else
3448: 		ret = CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
3449: 
3450: 	return ret;
3451: }
3452: 
3453: __declspec(dllexport) UINT __stdcall dotemuGetDriveTypeA(LPCSTR lpRootPathName)
3454: {
3455: 	UINT ret;
3456: 
3457: 	if (strcmp(lpRootPathName, "CD:") == 0)
3458: 	{
3459: 		ret = DRIVE_CDROM;
3460: 	}
3461: 	else
3462: 	{
3463: 		ret = GetDriveTypeA(lpRootPathName);
3464: 	}
3465: 
3466: 	return ret;
3467: }
3468: 
3469: __declspec(dllexport) BOOL __stdcall dotemuDeleteFileA(LPCSTR lpFileName)
3470: {
3471: 	BOOL ret = false;
3472: 
3473: 	if (strstr(lpFileName, "app.log"))
3474: 	{
3475: 		CHAR newPath[260]{ 0 };
3476: 
3477: 		// Search for the last '\' character and get a pointer to the next char
3478: 		const char* pos = strrchr(lpFileName, 92) + 1;
3479: 
3480: 		get_userdata_path(newPath, 260, false);
3481: 		PathAppendA(newPath, pos);
3482: 
3483: 		ret = DeleteFileA(newPath);
3484: 	}
3485: 	else if (strstr(lpFileName, "temp.fi") || strstr(lpFileName, "temp.fl") || strstr(lpFileName, "temp.fs") || strstr(lpFileName, "temp_evn.") || strstr(lpFileName, "temp_odd."))
3486: 	{
3487: 		CHAR newPath[260]{ 0 };
3488: 
3489: 		// Search for the last '\' character and get a pointer to the next char
3490: 		const char* pos = strrchr(lpFileName, 92) + 1;
3491: 
3492: 		get_userdata_path(newPath, 260, false);
3493: 		PathAppendA(newPath, pos);
3494: 
3495: 		ret = DeleteFileA(newPath);
3496: 	}
3497: 	else
3498: 		ret = DeleteFileA(lpFileName);
3499: 
3500: 	return ret;
3501: }
3502: 
3503: // FF8 2000 Compatibility
3504: __declspec(dllexport) HRESULT __stdcall EAXDirectSoundCreate(LPGUID guid, LPLPDIRECTSOUND directsound, IUnknown FAR* unk)
3505: {
3506: 	typedef HRESULT(FAR PASCAL* LPEAXDIRECTSOUNDCREATE)(LPGUID, LPLPDIRECTSOUND, IUnknown FAR*);
3507: 	char eax_dll[MAX_PATH] = {};
3508: 
3509: 	if (fileExists("creative_eax.dll")) {
3510: 		// For portable installation, this name can be used to load the official Creative EAX 2.0+ DLL along with FFNx
3511: 		snprintf(eax_dll, sizeof(eax_dll), R"(%s\creative_eax.dll)", basedir);
3512: 	} else {
3513: 		GetSystemDirectoryA(eax_dll, sizeof(eax_dll));
3514: 		strcat(eax_dll, R"(\eax.dll)");
3515: 	}
3516: 
3517: 	FARPROC procDSoundCreate = NULL;
3518: 	HMODULE hDll = LoadLibraryA(eax_dll);
3519: 	if (hDll != NULL) {
3520: 		procDSoundCreate = GetProcAddress(hDll, "EAXDirectSoundCreate");
3521: 	}
3522: 
3523: 	if (procDSoundCreate == NULL) {
3524: 		ffnx_warning("%s: Cannot load EAX Library, please install Creative EAX Unified redistribuable version 2.0+\n", __func__);
3525: 
3526: 		hDll = LoadLibraryA("dsound.dll");
3527: 		if (hDll != NULL) {
3528: 			// EAXDirectSoundCreate is basically DirectSoundCreate with more features
3529: 			procDSoundCreate = GetProcAddress(hDll, "DirectSoundCreate");
3530: 		}
3531: 	}
3532: 
3533: 	return LPEAXDIRECTSOUNDCREATE(procDSoundCreate)(guid, directsound, unk);
3534: }
3535: 
3536: void ffnx_inject_driver(struct game_obj* game_object)
3537: {
3538: 	VOBJ(game_obj, game_object, game_object);
3539: 
3540: 	VRASS(game_object, current_gfx_driver, 2);
3541: 	VRASS(game_object, create_gfx_driver, new_dll_graphics_driver);
3542: }
3543: 
3544: #if defined(__cplusplus)
3545: }
3546: #endif
3547: 
3548: constexpr int FFNX_LOGO_FRAME_COUNT = 180;
3549: int ffnx_logo_current_frame = 0;
3550: 
3551: bool drawFFNxLogoFrame(struct game_obj* game_object)
3552: {
3553: 	static int was_lighting_enabled = -1;
3554: 
3555: 	if (was_lighting_enabled == -1) was_lighting_enabled = enable_lighting;
3556: 
3557: 	if (ffnx_logo_current_frame >= FFNX_LOGO_FRAME_COUNT) {
3558: 		newRenderer.setOverallColorGamut(enable_ntscj_gamut_mode ? COLORGAMUT_NTSCJ : COLORGAMUT_SRGB); // set the gamut back to what it was before newRenderer.drawFFNxLogo() changed it
3559: 		enable_lighting = was_lighting_enabled;
3560: 		return false;
3561: 	}
3562: 
3563: 	VOBJ(game_obj, game_object, game_object);
3564: 
3565: 	int fade_frame_count = FFNX_LOGO_FRAME_COUNT / 3;
3566: 	float fade = 0.0;
3567: 
3568: 	if(ffnx_logo_current_frame < fade_frame_count)
3569: 		fade = ffnx_logo_current_frame / static_cast<float>(fade_frame_count);
3570: 	else if(ffnx_logo_current_frame < 2 * fade_frame_count)
3571: 		fade = 1.0f;
3572: 	else
3573: 		fade = 1.0f - (ffnx_logo_current_frame - 2 * fade_frame_count) / static_cast<float>(fade_frame_count);
3574: 
3575: 	enable_lighting = false;
3576: 
3577: 	newRenderer.drawFFNxLogo(fade);
3578: 
3579: 	common_flip(game_object);
3580: 
3581: 	ffnx_logo_current_frame++;
3582: 
3583: 	return true;
3584: }
3585: 
3586: void stopDrawFFNxLogo()
3587: {
3588: 	ffnx_logo_current_frame = FFNX_LOGO_FRAME_COUNT;
3589: }
</file>

<file path="src/common.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <windows.h>
 26: #include <mmsystem.h>
 27: #include <dinput.h>
 28: #include <dsound.h>
 29: 
 30: #include "common_imports.h"
 31: 
 32: // all known OFFICIAL versions of FF7 & FF8 released for the PC
 33: #define VERSION_FF7_102_US          1
 34: #define VERSION_FF7_102_FR          2
 35: #define VERSION_FF7_102_DE          3
 36: #define VERSION_FF7_102_SP          4
 37: #define VERSION_FF8_12_US           5
 38: #define VERSION_FF8_12_US_NV        6
 39: #define VERSION_FF8_12_FR           7
 40: #define VERSION_FF8_12_FR_NV        8
 41: #define VERSION_FF8_12_DE           9
 42: #define VERSION_FF8_12_DE_NV       10
 43: #define VERSION_FF8_12_SP          11
 44: #define VERSION_FF8_12_SP_NV       12
 45: #define VERSION_FF8_12_IT          13
 46: #define VERSION_FF8_12_IT_NV       14
 47: #define VERSION_FF8_12_US_EIDOS    15
 48: #define VERSION_FF8_12_US_EIDOS_NV 16
 49: #define VERSION_FF8_12_JP          17
 50: #define VERSION_FF8_12_JP_NV       18
 51: 
 52: // Steam app id of FF7 & FF8
 53: #define FF7_APPID 39140
 54: #define FF8_APPID 39150
 55: 
 56: #define NV_VERSION (!(version & 1))
 57: #define JP_VERSION (version == VERSION_FF8_12_JP || version == VERSION_FF8_12_JP_NV)
 58: #define FF8_US_VERSION (version == VERSION_FF8_12_US || version == VERSION_FF8_12_US_NV || version == VERSION_FF8_12_US_EIDOS || version == VERSION_FF8_12_US_EIDOS_NV)
 59: #define FF8_SP_VERSION (version == VERSION_FF8_12_SP || version == VERSION_FF8_12_SP_NV)
 60: #define FF8_IT_VERSION (version == VERSION_FF8_12_IT || version == VERSION_FF8_12_IT_NV)
 61: 
 62: // FF8 does not support BLUE text!
 63: enum
 64: {
 65: 	TEXTCOLOR_GRAY,
 66: 	TEXTCOLOR_BLUE,
 67: 	TEXTCOLOR_RED,
 68: 	TEXTCOLOR_PINK,
 69: 	TEXTCOLOR_GREEN,
 70: 	TEXTCOLOR_LIGHT_BLUE,
 71: 	TEXTCOLOR_YELLOW,
 72: 	TEXTCOLOR_WHITE,
 73: 	NUM_TEXTCOLORS
 74: };
 75: 
 76: enum game_modes
 77: {
 78: 	MODE_FIELD = 0,
 79: 	MODE_BATTLE,
 80: 	MODE_WORLDMAP,
 81: 	MODE_MENU,
 82: 	MODE_HIGHWAY,
 83: 	MODE_CHOCOBO,
 84: 	MODE_SNOWBOARD,
 85: 	MODE_CONDOR,
 86: 	MODE_SUBMARINE,
 87: 	MODE_COASTER,
 88: 	MODE_CDCHECK,
 89: 	MODE_EXIT,
 90: 	MODE_SWIRL,
 91: 	MODE_GAMEOVER,
 92: 	MODE_ENDINGMOVIE,
 93: 	MODE_CREDITS,
 94: 	MODE_INTRO,
 95: 	MODE_CARDGAME,
 96: 	MODE_UNKNOWN,
 97: 	MODE_AFTER_BATTLE,
 98: 	MODE_MAIN_MENU,
 99: };
100: 
101: enum AspectRatioMode
102: {
103: 	AR_ORIGINAL = 0,
104: 	AR_STRETCH,
105: 	AR_WIDESCREEN_16X9,
106: 	AR_WIDESCREEN_16X10,
107: 	AR_COUNT
108: };
109: 
110: enum GamepadAnalogueIntent
111: {
112: 	INTENT_NONE,
113: 	INTENT_WALK,
114: 	INTENT_RUN
115: };
116: 
117: // popup lifetime in frames
118: #define POPUP_TTL_MAX 10000
119: 
120: // dummy TEX version for framebuffer textures
121: #define FB_TEX_VERSION 100
122: 
123: struct game_mode
124: {
125: 	uint32_t mode;
126: 	char *name;
127: 	uint32_t driver_mode;
128: 	uint32_t trace;
129: 	uint32_t main_loop;
130: };
131: 
132: struct light_data
133: {
134: 	bgra_color global_light_color;
135: 	vector3<float> light_dir_1;
136: 	bgra_color light_color_1;
137: 	vector3<float> light_dir_2;
138: 	bgra_color light_color_2;
139: 	vector3<float> light_dir_3;
140: 	bgra_color light_color_3;
141: 	bgra_color scripted_light_color;
142: };
143: 
144: gfx_init common_init;
145: gfx_cleanup common_cleanup;
146: gfx_lock common_lock;
147: gfx_unlock common_unlock;
148: gfx_flip common_flip;
149: gfx_clear common_clear;
150: gfx_clear_all common_clear_all;
151: gfx_setviewport common_setviewport;
152: gfx_setbg common_setbg;
153: gfx_prepare_polygon_set common_prepare_polygon_set;
154: gfx_load_group common_load_group;
155: gfx_setmatrix common_setmatrix;
156: gfx_light_polygon_set common_light_polygon_set;
157: gfx_unload_texture common_unload_texture;
158: gfx_load_texture common_load_texture;
159: gfx_palette_changed common_palette_changed;
160: gfx_write_palette common_write_palette;
161: gfx_blendmode common_blendmode;
162: gfx_light_polygon_set ff7gl_light_polygon_set;
163: gfx_field_64 common_field_64;
164: gfx_setrenderstate common_setrenderstate;
165: gfx_field_74 common_field_74;
166: gfx_field_78 common_field_78;
167: gfx_draw_deferred common_draw_deferred;
168: gfx_field_80 common_field_80;
169: gfx_field_84 common_field_84;
170: gfx_begin_scene common_begin_scene;
171: gfx_end_scene common_end_scene;
172: gfx_field_90 common_field_90;
173: gfx_polysetrenderstate common_setrenderstate_2D;
174: gfx_draw_vertices common_draw_2D;
175: gfx_draw_vertices common_draw_paletted2D;
176: gfx_polysetrenderstate common_setrenderstate_3D;
177: gfx_draw_vertices common_draw_3D;
178: gfx_draw_vertices common_draw_paletted3D;
179: gfx_draw_vertices common_draw_lines;
180: gfx_field_EC common_field_EC;
181: 
182: /*
183:  * This structure holds memory addresses and function pointers of the original
184:  * engine used within this program. Not all of them are currently used for both
185:  * games, MIDI functions for example are only used for FF7 but they could
186:  * concievably be used for FF8 aswell.
187:  */
188: 
189: struct common_externals
190: {
191: 	WORD *_mode;
192: 	WORD *_previous_mode;
193: 	uint32_t dinput_hack1;
194: 	gfx_load_group *generic_load_group;
195: 	gfx_light_polygon_set *generic_light_polygon_set;
196: 	void *(*assert_free)(void *, const char *, uint32_t);
197: 	void *(*assert_malloc)(uint32_t, const char *, uint32_t);
198: 	void *(*assert_calloc)(uint32_t, uint32_t, const char *, uint32_t);
199: 	IDirectSound **directsound;
200: 	uint32_t directsound_create;
201: 	uint32_t directsound_createsoundbuffer;
202: 	uint32_t directsound_release;
203: 	struct palette *(*create_palette_for_tex)(uint32_t, struct tex_header *, struct texture_set *);
204: 	struct game_obj *(*get_game_object)();
205: 	struct texture_format *(*create_texture_format)();
206: 	void (*add_texture_format)(struct texture_format *, struct game_obj *);
207: 	void (*make_pixelformat)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, struct texture_format *);
208: 	struct texture_set *(*create_texture_set)();
209: 	uint32_t debug_print;
210: 	uint32_t debug_print2;
211: 	uint32_t prepare_movie;
212: 	uint32_t release_movie_objects;
213: 	uint32_t start_movie;
214: 	uint32_t update_movie_sample;
215: 	uint32_t stop_movie;
216: 	uint32_t get_movie_frame;
217: 	struct tex_header *(*create_tex_header)();
218: 	uint64_t (*get_time)(uint64_t*);
219: 	uint64_t (*diff_time)(uint64_t*,uint64_t*,uint64_t*);
220: 	uint32_t midi_init;
221: 	uint32_t midi_cleanup;
222: 	uint32_t wav_cleanup;
223: 	char *(*get_midi_name)(uint32_t);
224: 	uint32_t use_midi;
225: 	uint32_t play_midi;
226: 	uint32_t play_wav;
227: 	uint32_t stop_midi;
228: 	uint32_t stop_wav;
229: 	uint32_t cross_fade_midi;
230: 	uint32_t pause_midi;
231: 	uint32_t pause_wav;
232: 	uint32_t restart_midi;
233: 	uint32_t restart_wav;
234: 	uint32_t midi_status;
235: 	DWORD* master_midi_volume;
236: 	uint32_t set_master_midi_volume;
237: 	uint32_t set_midi_volume;
238: 	uint32_t set_midi_volume_trans;
239: 	uint32_t set_midi_volume_fade;
240: 	uint32_t set_midi_tempo;
241: 	uint32_t remember_midi_playing_time;
242: 	uint32_t draw_graphics_object;
243: 	char *font_info;
244: 	uint32_t build_dialog_window;
245: 	uint32_t write_file;
246: 	uint32_t close_file;
247: 	uint32_t open_file;
248: 	uint32_t read_file;
249: 	uint32_t __read_file;
250: 	uint32_t get_filesize;
251: 	uint32_t tell_file;
252: 	uint32_t seek_file;
253: 	void *(*alloc_read_file)(uint32_t, uint32_t, struct file *);
254: 	void *(*alloc_get_file)(struct file_context *, uint32_t *, char *);
255: 	void (*destroy_tex)(struct tex_header *);
256: 	uint32_t destroy_tex_header;
257: 	uint32_t start;
258: 	uint32_t winmain;
259: 	uint32_t load_tex_file;
260: 	uint32_t directsound_buffer_flags_1;
261: 	uint32_t sfx_init;
262: 	uint32_t sfx_cleanup;
263: 	uint32_t sfx_load;
264: 	uint32_t sfx_unload;
265: 	uint32_t sfx_pause;
266: 	uint32_t sfx_resume;
267: 	uint32_t sfx_stop;
268: 	uint32_t sfx_release;
269: 	uint32_t (*play_sfx)(uint32_t);
270: 	uint32_t (*play_sfx_effects)(byte, uint32_t, uint32_t, uint32_t, uint32_t);
271: 	uint32_t play_sfx_on_channel;
272: 	uint32_t (*set_sfx_volume_on_channel)(uint32_t, uint32_t);
273: 	uint32_t (*set_sfx_volume_trans_on_channel)(uint32_t, uint32_t, uint32_t);
274: 	uint32_t (*set_sfx_panning_on_channel)(uint32_t, uint32_t);
275: 	uint32_t (*set_sfx_panning_trans_on_channel)(uint32_t, uint32_t, uint32_t);
276: 	uint32_t (*set_sfx_frequency_on_channel)(uint32_t, uint32_t);
277: 	uint32_t (*set_sfx_frequency_trans_on_channel)(uint32_t, uint32_t, uint32_t);
278: 	uint32_t *master_sfx_volume;
279: 	uint32_t* dsound_volume_table;
280: 	IDirectInputDeviceA **keyboard_device;
281: 	uint32_t get_keyboard_state;
282: 	uint32_t *keyboard_connected;
283: 	int (*dinput_acquire_keyboard)();
284: 	uint32_t create_window;
285: 	WNDPROC engine_wndproc;
286: 	uint32_t* execute_opcode_table;
287: 	uint32_t update_field_entities;
288: 	WORD* current_field_id;
289: 	char* current_field_name;
290: 	WORD* previous_field_id;
291: 	uint32_t update_entities_call;
292: 	int16_t* current_triangle_id;
293: 	WORD* field_game_moment;
294: };
295: 
296: // heap allocation wrappers
297: // driver_* functions are to be used for data internal to the driver, memory which is never allocated or free'd by the game
298: // external_* functions must be used for memory which could be allocated or free'd by the game
299: #ifndef NO_EXT_HEAP
300: #define external_free(x) common_externals.assert_free(x, "", 0)
301: #define external_malloc(x) common_externals.assert_malloc(x, "", 0)
302: #define external_calloc(x, y) common_externals.assert_calloc(x, y, "", 0)
303: #else
304: void ext_free(void *ptr, const char *file, uint32_t line);
305: void *ext_malloc(uint32_t size, const char *file, uint32_t line);
306: void *ext_calloc(uint32_t size, uint32_t num, const char *file, uint32_t line);
307: 
308: #define external_free(x) ext_free(x, "", 0)
309: #define external_malloc(x) ext_malloc(x, "", 0)
310: #define external_calloc(x, y) ext_calloc(x, y, "", 0)
311: #endif
312: 
313: #ifndef HEAP_DEBUG
314: #define driver_malloc(x) malloc(x)
315: #define driver_calloc(x, y) calloc(x, y)
316: #define driver_free(x) free(x)
317: #define driver_realloc(x, y) realloc(x, y)
318: #else
319: void *driver_malloc(uint32_t size);
320: void *driver_calloc(uint32_t size, uint32_t num);
321: void driver_free(void *ptr);
322: void *driver_realloc(void *ptr, uint32_t size);
323: #endif
324: 
325: // profiling routines
326: #ifdef PROFILE
327: #define PROFILE_START() qpc_get_time(&profile_start)
328: #define PROFILE_END() { qpc_get_time(&profile_end); profile_total += profile_end - profile_start; }
329: 
330: extern time_t profile_start;
331: extern time_t profile_end;
332: extern time_t profile_total;
333: #endif PROFILE
334: 
335: struct driver_stats
336: {
337: 	uint32_t texture_count;
338: 	uint32_t external_textures;
339: 	uint32_t ext_cache_size;
340: 	uint32_t texture_reloads;
341: 	uint32_t palette_writes;
342: 	uint32_t palette_changes;
343: 	uint32_t vertex_count;
344: 	uint32_t deferred;
345: 	time_t timer;
346: };
347: 
348: time_t qpc_get_time(time_t *dest);
349: time_t qpc_diff_time(time_t* t1, time_t* t2, time_t* out);
350: uint32_t get_version();
351: struct game_mode *getmode();
352: struct game_mode *getmode_cached();
353: struct tex_header *make_framebuffer_tex(uint32_t tex_w, uint32_t tex_h, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color_key);
354: void internal_set_renderstate(uint32_t state, uint32_t option, struct game_obj *game_object);
355: uint32_t create_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header);
356: void blit_framebuffer_texture(struct texture_set *texture_set, struct tex_header *tex_header);
357: 
358: void get_data_lang_path(PCHAR buffer);
359: void get_userdata_path(PCHAR buffer, size_t bufSize, bool isSavegameFile);
360: 
361: #if defined(__cplusplus)
362: extern "C" {
363: #endif
364: 
365: void ffnx_inject_driver(struct game_obj* game_object);
366: 
367: #if defined(__cplusplus)
368: }
369: #endif
370: 
371: bool drawFFNxLogoFrame(struct game_obj* game_object);
372: void stopDrawFFNxLogo();
</file>

<file path="src/crashdump.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <shlwapi.h>
 23: #include <commctrl.h>
 24: 
 25: #include "audio.h"
 26: 
 27: #include "crashdump.h"
 28: #include "utils.h"
 29: 
 30: // FF7 save file checksum, original by dziugo
 31: int ff7_checksum(void* qw)
 32: {
 33: 	int i = 0, t, d;
 34: 	long r = 0xFFFF, len = 4336;
 35: 	long pbit = 0x8000;
 36: 	char* b = (char*)qw;
 37: 
 38: 	while(len--)
 39: 	{
 40: 		t = b[i++];
 41: 		r ^= t << 8;
 42: 
 43: 		for(d = 0; d < 8; d++)
 44: 		{
 45: 			if(r & pbit) r = (r << 1) ^ 0x1021;
 46: 			else r <<= 1;
 47: 		}
 48: 
 49: 		r &= (1 << 16) - 1;
 50: 	}
 51: 
 52: 	return (r ^ 0xFFFF) & 0xFFFF;
 53: }
 54: 
 55: static const char save_name[] = "\x25" "MERGENCY" "\x00\x33" "AVE" "\xFF";
 56: 
 57: HRESULT CALLBACK TaskDialogCallbackProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData) {
 58: 	if (msg == TDN_HYPERLINK_CLICKED) {
 59: 		LPCWSTR url = (LPCWSTR)lParam;
 60: 		ShellExecuteW(NULL, L"open", url, NULL, NULL, SW_SHOWNORMAL);
 61: 	}
 62: 	return S_OK;
 63: }
 64: 
 65: LONG WINAPI ExceptionHandler(EXCEPTION_POINTERS *ep)
 66: {
 67: 	static uint32_t had_exception = false;
 68: 	char filePath[260]{ 0 };
 69: 
 70: 	// give up if we crash again inside the exception handler (this function)
 71: 	if(had_exception)
 72: 	{
 73: 		ffnx_unexpected("ExceptionHandler: crash while running another ExceptionHandler. Exiting.");
 74: 		SetUnhandledExceptionFilter(0);
 75: 		return EXCEPTION_CONTINUE_EXECUTION;
 76: 	}
 77: 
 78: 	ffnx_trace("*** Exception 0x%x, address 0x%x ***\n", ep->ExceptionRecord->ExceptionCode, ep->ExceptionRecord->ExceptionAddress);
 79: 	FFNxStackWalker sw;
 80: 	sw.ShowCallstack(
 81: 		GetCurrentThread(),
 82: 		ep->ContextRecord
 83: 	);
 84: 
 85: 	had_exception = true;
 86: 
 87: 	// show cursor in case it was hidden
 88: 	while (ShowCursor(true) < 0);
 89: 
 90: 	if (create_crash_dump)
 91: 	{
 92: 		if (steam_edition) get_userdata_path(filePath, sizeof(filePath), false);
 93: 		PathAppendA(filePath, "crash.dmp");
 94: 
 95: 		HANDLE file = CreateFile(filePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
 96: 		HANDLE proc = GetCurrentProcess();
 97: 		DWORD procid = GetCurrentProcessId();
 98: 		MINIDUMP_EXCEPTION_INFORMATION mdei;
 99: 
100: 		CONTEXT c;
101: 		HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());;
102: 		memset(&c, 0, sizeof(c));
103: 		c.ContextFlags = CONTEXT_FULL;
104: 		GetThreadContext(hThread, &c);
105: 
106: 		mdei.ThreadId = GetCurrentThreadId();
107: 		mdei.ExceptionPointers = ep;
108: 		mdei.ExceptionPointers->ContextRecord = &c;
109: 		mdei.ClientPointers = true;
110: 
111: 		if (!MiniDumpWriteDump(
112: 			proc,
113: 			procid,
114: 			file,
115: 			(MINIDUMP_TYPE)(MiniDumpWithFullMemory |
116: 				MiniDumpWithFullMemoryInfo |
117: 				MiniDumpWithHandleData |
118: 				MiniDumpWithUnloadedModules |
119: 				MiniDumpWithThreadInfo),
120: 			&mdei, NULL, NULL)) {
121: 			ffnx_trace("MiniDumpWriteDump failed with error: %ls\n", GetErrorMessage(GetLastError()));
122: 		}
123: 	}
124: 
125: 
126: 	if(!ff8)
127: 	{
128: 		memset(filePath, 0, sizeof(filePath));
129: 
130: 		if (steam_edition)
131: 		{
132: 			get_userdata_path(filePath, sizeof(filePath), false);
133: 			PathAppendA(filePath, "crash.ff7");
134: 		}
135: 		else
136: 		{
137: 			PathAppendA(filePath, "save/crash.ff7");
138: 		}
139: 
140: 		// try to dump the current savemap from memory
141: 		// the savemap could be old, inconsistent or corrupted at this point
142: 		// avoid playing from an emergency save if at all possible!
143: 		FILE *f = fopen(filePath, "wb");
144: 		uint32_t magic = 0x6277371;
145: 		uint32_t bitmask = 1;
146: 		struct savemap dummy[14];
147: 
148: 		memset(dummy, 0, sizeof(dummy));
149: 
150: 		memcpy(ff7_externals.savemap->preview_location, save_name, sizeof(save_name));
151: 
152: 		ff7_externals.savemap->checksum = ff7_checksum(&(ff7_externals.savemap->preview_level));
153: 
154: 		fwrite(&magic, 4, 1, f);
155: 		fwrite("", 1, 1, f);
156: 		fwrite(&bitmask, 4, 1, f);
157: 		fwrite(ff7_externals.savemap, sizeof(*ff7_externals.savemap), 1, f);
158: 		fwrite(dummy, sizeof(dummy), 1, f);
159: 		fclose(f);
160: 	}
161: 
162: 	ffnx_error("Unhandled Exception. See dumped information above.\n");
163: 
164: 	TASKDIALOGCONFIG config = { sizeof(config) };
165: 	config.hwndParent = gameHwnd;
166: 	config.dwFlags = TDF_ENABLE_HYPERLINKS;
167: 	config.pszWindowTitle = L"Something went wrong";
168: 	config.pszMainInstruction = L"Game crashed :(";
169: 	config.pszContent = L"Something unexpected happened and unfortunately the game crashed.\n\nFeel free to visit <a href=\"https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/faq.md\">this link</a> to know about further next steps you can take.";
170: 	config.pszMainIcon = TD_ERROR_ICON;
171: 	config.pfCallback = TaskDialogCallbackProc;
172: 
173: 	TaskDialogIndirect(&config, NULL, NULL, NULL);
174: 
175: 	// Cleanup the audio device
176: 	nxAudioEngine.cleanup();
177: 
178: 	// let OS handle the crash
179: 	SetUnhandledExceptionFilter(0);
180: 	return EXCEPTION_CONTINUE_EXECUTION;
181: }
</file>

<file path="src/crashdump.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <StackWalker.h>
25: #include <dbghelp.h>
26: 
27: #include "log.h"
28: 
29: #define STACK_MAX_NAME_LENGTH 256
30: 
31: class FFNxStackWalker : public StackWalker
32: {
33: public:
34:     FFNxStackWalker(bool muted = false) : StackWalker(), _baseAddress(0), _size(0), _muted(muted) {}
35:     DWORD64 getBaseAddress() const {
36:         return _baseAddress;
37:     }
38:     DWORD getSize() const {
39:         return _size;
40:     }
41: protected:
42:     virtual void OnLoadModule(LPCSTR img, LPCSTR mod, DWORD64 baseAddr,
43:         DWORD size, DWORD result, LPCSTR symType, LPCSTR pdbName,
44:         ULONGLONG fileVersion
45:     )
46:     {
47:         if (_baseAddress == 0 && _size == 0)
48:         {
49:             _baseAddress = baseAddr;
50:             _size = size;
51:         }
52:         StackWalker::OnLoadModule(
53:             img, mod, baseAddr, size, result, symType, pdbName, fileVersion
54:         );
55:     }
56: 
57:     virtual void OnDbgHelpErr(LPCSTR szFuncName, DWORD gle, DWORD64 addr)
58:     {
59:         // Silence is golden.
60:     }
61: 
62:     virtual void OnOutput(LPCSTR szText)
63:     {
64:         if (! _muted)
65:         {
66:             ffnx_trace(szText);
67:         }
68:     }
69: private:
70:     DWORD64 _baseAddress;
71:     DWORD _size;
72:     bool _muted;
73: };
74: 
75: LONG WINAPI ExceptionHandler(EXCEPTION_POINTERS *ep);
</file>

<file path="src/exe_data.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2024 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "common.h"
 23: #include "log.h"
 24: #include "utils.h"
 25: #include "patch.h"
 26: #include "saveload.h"
 27: 
 28: uint8_t *ff8_exe_scan_texts = nullptr;
 29: uint8_t *ff8_exe_card_names = nullptr;
 30: uint8_t *ff8_exe_draw_point = nullptr;
 31: uint8_t *ff8_exe_card_texts = nullptr;
 32: 
 33: bool ff8_get_exe_path(const char *name, char *target_filename)
 34: {
 35:     snprintf(target_filename, MAX_PATH, "%s/%s/exe/%s.msd", basedir, direct_mode_path.c_str(), name);
 36:     normalize_path(target_filename);
 37: 
 38:     return fileExists(target_filename);
 39: }
 40: 
 41: bool ff8_get_battle_scan_texts_filename(char *filename)
 42: {
 43:     return ff8_get_exe_path("battle_scans", filename);
 44: }
 45: 
 46: bool ff8_get_card_names_filename(char *filename)
 47: {
 48:     return ff8_get_exe_path("card_names", filename);
 49: }
 50: 
 51: bool ff8_get_draw_point_filename(char *filename)
 52: {
 53:     return ff8_get_exe_path("draw_point", filename);
 54: }
 55: 
 56: bool ff8_get_card_texts_filename(char *filename)
 57: {
 58:     return ff8_get_exe_path("card_texts", filename);
 59: }
 60: 
 61: void ff8_dump_msd(const char *filename, uint8_t *data)
 62: {
 63:     uint32_t *offsets = (uint32_t *)data;
 64:     uint32_t first_offset = *offsets;
 65:     int text_count = first_offset / 4;
 66:     int higher_offset = 0;
 67: 
 68:     for (int i = 0; i < text_count; ++i) {
 69:         if (offsets[i] > higher_offset) {
 70:             higher_offset = offsets[i];
 71:         }
 72:     }
 73: 
 74:     for (int i = higher_offset; i < higher_offset + 1024; ++i) {
 75:         if (data[i] == '\0') {
 76:             higher_offset = i + 1;
 77:             break;
 78:         }
 79:     }
 80: 
 81:     FILE *f = fopen(filename, "wb");
 82: 
 83:     if (f == nullptr) {
 84:         return;
 85:     }
 86: 
 87:     fwrite(data, first_offset + higher_offset, 1, f);
 88:     fclose(f);
 89: }
 90: 
 91: void ff8_dump_battle_scan_texts()
 92: {
 93:     uint8_t *data = (uint8_t *)ff8_externals.scan_text_data;
 94:     uint16_t *offsets_rel_to_data = (uint16_t *)ff8_externals.scan_text_positions;
 95:     int text_count = int((uint16_t *)data - offsets_rel_to_data);
 96:     uint16_t data_offset = text_count * sizeof(uint32_t);
 97:     uint32_t offsets_rel_to_start[0x200] = {};
 98:     int higher_offset = 0;
 99: 
100:     for (int i = 0; i < text_count; ++i) {
101:         offsets_rel_to_start[i] = offsets_rel_to_data[i] + data_offset;
102:         if (offsets_rel_to_data[i] > higher_offset) {
103:             higher_offset = offsets_rel_to_data[i];
104:         }
105:     }
106: 
107:     for (int i = higher_offset; i < higher_offset + 1024; ++i) {
108:         if (data[i] == '\0') {
109:             higher_offset = i + 1;
110:             break;
111:         }
112:     }
113: 
114:     char filename[MAX_PATH] = {};
115:     if (ff8_get_battle_scan_texts_filename(filename)) {
116:         ffnx_warning("Save exe file skipped because the file [ %s ] already exists.\n", filename);
117: 
118:         return;
119:     }
120: 
121:     FILE *f = fopen(filename, "wb");
122: 
123:     if (f == nullptr) {
124:         return;
125:     }
126: 
127:     fwrite(offsets_rel_to_start, data_offset, 1, f);
128:     fwrite(data, higher_offset, 1, f);
129:     fclose(f);
130: }
131: 
132: void ff8_dump_card_names()
133: {
134:     uint8_t *data = *(uint8_t **)ff8_externals.card_name_positions;
135:     uint16_t *positions = *(uint16_t **)ff8_externals.card_name_positions;
136:     constexpr int text_count = 110;
137:     uint16_t old_data_offset = (1 + text_count) * sizeof(uint16_t), new_data_offset = text_count * sizeof(uint32_t);
138:     uint32_t offsets_rel_to_start[text_count] = {};
139:     int higher_offset = 0;
140: 
141:     for (int i = 0; i < text_count; ++i) {
142:         offsets_rel_to_start[i] = positions[i + 1] - old_data_offset + new_data_offset;
143:         if (positions[i + 1] > higher_offset) {
144:             higher_offset = positions[i + 1];
145:         }
146:     }
147: 
148:     for (int i = higher_offset; i < higher_offset + 1024; ++i) {
149:         if (data[i] == '\0') {
150:             higher_offset = i + 1;
151:             break;
152:         }
153:     }
154: 
155:     char filename[MAX_PATH] = {};
156:     if (ff8_get_card_names_filename(filename)) {
157:         ffnx_warning("Save exe file skipped because the file [ %s ] already exists.\n", filename);
158: 
159:         return;
160:     }
161: 
162:     FILE *f = fopen(filename, "wb");
163: 
164:     if (f == nullptr) {
165:         return;
166:     }
167: 
168:     fwrite(offsets_rel_to_start, new_data_offset, 1, f);
169:     fwrite(data + old_data_offset, higher_offset - old_data_offset, 1, f);
170:     fclose(f);
171: }
172: 
173: void ff8_dump_card_texts()
174: {
175:     uint8_t *data = *ff8_externals.card_texts_off_B96968;
176:     uint16_t *offsets = (uint16_t *)(data + 2);
177:     uint32_t first_offset = *offsets;
178:     int text_count = first_offset / 4;
179:     int higher_offset = 0;
180:     uint32_t offsets_rel_to_start[0x200] = {};
181: 
182:     for (int i = 0; i < text_count; ++i) {
183:         offsets_rel_to_start[i] = offsets[i * 2];
184:         if (offsets[i * 2] > higher_offset) {
185:             higher_offset = offsets[i * 2];
186:         }
187:     }
188: 
189:     for (int i = higher_offset; i < higher_offset + 1024; ++i) {
190:         if (data[i] == '\0') {
191:             higher_offset = i + 1;
192:             break;
193:         }
194:     }
195: 
196:     char filename[MAX_PATH] = {};
197:     if (ff8_get_card_texts_filename(filename)) {
198:         ffnx_warning("Save exe file skipped because the file [ %s ] already exists.\n", filename);
199: 
200:         return;
201:     }
202: 
203:     FILE *f = fopen(filename, "wb");
204: 
205:     if (f == nullptr) {
206:         return;
207:     }
208: 
209:     fwrite(offsets_rel_to_start, text_count * 4, 1, f);
210:     fwrite(data + first_offset, higher_offset - first_offset, 1, f);
211:     fclose(f);
212: }
213: 
214: uint8_t *ff8_open_msd(char *filename, int *data_size = nullptr)
215: {
216:     if (trace_all || trace_direct) ffnx_info("Direct file using %s\n", filename);
217: 
218:     if (data_size != nullptr) {
219:         *data_size = 0;
220:     }
221: 
222:     FILE *f = fopen(filename, "rb");
223: 
224:     if (f == nullptr) {
225:         return nullptr;
226:     }
227: 
228:     fseek(f, 0, SEEK_END);
229:     long file_size = ftell(f);
230:     fseek(f, 0, SEEK_SET);
231: 
232:     uint8_t *target_data = (uint8_t *)driver_malloc(file_size); // Allocated once, never freed
233: 
234:     if (target_data == nullptr) {
235:         return nullptr;
236:     }
237: 
238:     fread(target_data, file_size, 1, f);
239:     fclose(f);
240: 
241:     if (data_size != nullptr) {
242:         *data_size = file_size;
243:     }
244: 
245:     return target_data;
246: }
247: 
248: uint8_t *ff8_override_battle_scans()
249: {
250:     if (ff8_exe_scan_texts != nullptr) {
251:         return ff8_exe_scan_texts;
252:     }
253: 
254:     char filename[MAX_PATH] = {};
255:     if (! ff8_get_battle_scan_texts_filename(filename)) {
256:         if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);
257: 
258:         return nullptr;
259:     }
260: 
261:     ff8_exe_scan_texts = ff8_open_msd(filename);
262: 
263:     return ff8_exe_scan_texts;
264: }
265: 
266: uint8_t *ff8_override_card_names()
267: {
268:     if (ff8_exe_card_names != nullptr) {
269:         return ff8_exe_card_names;
270:     }
271: 
272:     char filename[MAX_PATH] = {};
273:     if (! ff8_get_card_names_filename(filename)) {
274:         if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);
275: 
276:         return nullptr;
277:     }
278: 
279:     ff8_exe_card_names = ff8_open_msd(filename);
280: 
281:     return ff8_exe_card_names;
282: }
283: 
284: uint8_t *ff8_override_draw_point()
285: {
286:     if (ff8_exe_draw_point != nullptr) {
287:         return ff8_exe_draw_point;
288:     }
289: 
290:     char filename[MAX_PATH] = {};
291:     if (! ff8_get_draw_point_filename(filename)) {
292:         if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);
293: 
294:         return nullptr;
295:     }
296: 
297:     ff8_exe_draw_point = ff8_open_msd(filename);
298: 
299:     return ff8_exe_draw_point;
300: }
301: 
302: uint8_t *ff8_override_card_texts()
303: {
304:     if (ff8_exe_card_texts != nullptr) {
305:         return ff8_exe_card_texts;
306:     }
307: 
308:     char filename[MAX_PATH] = {};
309:     if (! ff8_get_card_texts_filename(filename)) {
310:         if (trace_all || trace_direct) ffnx_warning("Direct file not found %s\n", filename);
311: 
312:         return nullptr;
313:     }
314: 
315:     int data_size = 0;
316:     uint8_t *ff8_exe_card_texts_msd = ff8_open_msd(filename, &data_size);
317: 
318:     if (ff8_exe_card_texts_msd == nullptr) {
319:         return nullptr;
320:     }
321: 
322:     ff8_exe_card_texts = (uint8_t *)driver_malloc(data_size + 16); // Allocated once, never freed
323: 
324:     if (ff8_exe_card_texts == nullptr) {
325:         driver_free(ff8_exe_card_texts_msd);
326: 
327:         return nullptr;
328:     }
329: 
330:     uint32_t *msd_offsets = (uint32_t *)ff8_exe_card_texts_msd;
331:     *(uint16_t *)ff8_exe_card_texts = *(uint16_t *)*ff8_externals.card_texts_off_B96968;
332:     int text_count = 256;
333: 
334:     for (int i = 0; i < text_count; ++i) {
335:         if (msd_offsets[i] / 4 < text_count) {
336:             text_count = msd_offsets[i] / 4;
337:         }
338:     }
339: 
340:     // We shift the positions (+2)
341:     memcpy(ff8_exe_card_texts + 2, ff8_exe_card_texts_msd, text_count * 4);
342:     // But not the texts!
343:     memcpy(ff8_exe_card_texts + text_count * 4, ff8_exe_card_texts_msd + text_count * 4, data_size - text_count * 4);
344: 
345:     driver_free(ff8_exe_card_texts_msd);
346: 
347:     return ff8_exe_card_texts;
348: }
349: 
350: uint8_t *ff8_battle_get_scan_text(uint8_t target_id)
351: {
352:     uint8_t *direct_data_msd = ff8_override_battle_scans();
353: 
354:     if (direct_data_msd != nullptr) {
355:         uint32_t *positions = (uint32_t *)direct_data_msd;
356:         uint8_t *entities = (uint8_t *)ff8_externals.battle_entities_1D27BCB;
357: 
358:         if (trace_all) ffnx_trace("%s: get scan text target_id=%d entity_id=%d\n", __func__, target_id, entities[208 * target_id]);
359: 
360:         return direct_data_msd + positions[entities[208 * target_id]];
361:     }
362: 
363:     return ((uint8_t*(*)(uint8_t))ff8_externals.scan_get_text_sub_B687C0)(target_id);
364: }
365: 
366: char *ff8_get_card_name(int32_t card_id)
367: {
368:     if (card_id >= 110) {
369:         return nullptr;
370:     }
371: 
372:     uint8_t *direct_data_msd = ff8_override_card_names();
373:     if (direct_data_msd != nullptr) {
374:         uint32_t *positions = (uint32_t *)direct_data_msd;
375: 
376:         if (trace_all) ffnx_trace("%s: get card name card_id=%d\n", __func__, card_id);
377: 
378:         return (char *)direct_data_msd + positions[card_id];
379:     }
380: 
381:     uint16_t *positions = *(uint16_t **)ff8_externals.card_name_positions;
382: 
383:     return *(char **)ff8_externals.card_name_positions + positions[card_id + 1];
384: }
385: 
386: void dump_exe_data()
387: {
388:     char dirname[MAX_PATH] = {};
389:     snprintf(dirname, sizeof(dirname), "%s/%s/exe/", basedir, direct_mode_path.c_str());
390: 
391:     normalize_path(dirname);
392:     make_path(dirname);
393: 
394:     if (ff8)
395:     {
396:         ff8_dump_battle_scan_texts();
397:         ff8_dump_card_names();
398: 
399:         if (!ff8_get_draw_point_filename(dirname)) {
400:             ff8_dump_msd(dirname, *(uint8_t **)ff8_externals.drawpoint_messages);
401:         }
402: 
403:         ff8_dump_card_texts();
404:     }
405: }
406: 
407: void exe_data_init()
408: {
409:     if (save_exe_data)
410:     {
411:         dump_exe_data();
412:     }
413: 
414:     if (ff8)
415:     {
416:         replace_call(ff8_externals.sub_84F8D0 + 0x88, ff8_battle_get_scan_text);
417:         replace_function(ff8_externals.get_card_name, ff8_get_card_name);
418:         uint8_t *msd = ff8_override_draw_point();
419:         if (msd != nullptr) {
420:             patch_code_uint(ff8_externals.drawpoint_messages, uint32_t(msd));
421:         }
422:         msd = ff8_override_card_texts();
423:         if (msd != nullptr) {
424:             patch_code_uint(uint32_t(ff8_externals.card_texts_off_B96504), uint32_t(msd));
425:             patch_code_uint(uint32_t(ff8_externals.card_texts_off_B96968), uint32_t(msd));
426:         }
427:     }
428: }
</file>

<file path="src/exe_data.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2024 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: void exe_data_init();
</file>

<file path="src/external_mesh.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "external_mesh.h"
 25: 
 26: #include "cfg.h"
 27: #include "log.h"
 28: #include "utils.h"
 29: 
 30: #define CGLTF_IMPLEMENTATION
 31: #include "cgltf.h"
 32: 
 33: bool ExternalMesh::importExternalMeshGltfFile(char* file_path, char* tex_path)
 34: {
 35: 	cgltf_options options = {0};
 36: 	cgltf_data* data = NULL;
 37: 	cgltf_result result = cgltf_parse_file(&options, file_path, &data);
 38: 	if (result != cgltf_result_success)
 39: 	{
 40: 		return false;
 41: 	}
 42: 
 43: 	result = cgltf_load_buffers(&options, data, file_path);
 44: 	if (result != cgltf_result_success)
 45: 	{
 46: 		return false;
 47: 	}
 48: 
 49:     std::string modelPath = file_path;
 50:     std::string modelFolder = modelPath.substr(0, modelPath.find_last_of("/") + 1);
 51:     std::string modelFilename =  modelPath.substr(modelPath.find_last_of("/") + 1);
 52:     std::string modelFilenameWithoutExt =  modelFilename.substr(0, modelFilename.find_last_of("."));
 53:     std::string configPath = modelFolder + modelFilenameWithoutExt + "_config.toml";
 54:     loadConfig(configPath);
 55: 
 56: 	for (size_t i = 0; i < data->textures_count; i++)
 57: 	{
 58: 		auto texture = data->textures[i];
 59: 		std::string relativePath = texture.image->uri;
 60: 
 61: 		std::string filename = relativePath.substr(relativePath.find_last_of("/") + 1);
 62: 		std::string name = filename.substr(0, filename.find_last_of("."));
 63: 
 64: 		std::string texFullPath = tex_path + name + ".dds";
 65: 
 66:         std::string modPath = !override_mod_path.empty() ? override_mod_path : mod_path;
 67: 
 68:         Material candidateMaterial;
 69: 
 70:         auto pair = materials.emplace(name, candidateMaterial);
 71:         if(pair.second)
 72:         {
 73:             auto& material = (*pair.first).second;
 74:             uint32_t width, height, mipCount = 0;
 75: 
 76:             char full_tex_path[512];
 77: 
 78:             int texCount = getTextureCount(name);
 79:             material.frameInterval = getFrameInterval(name);
 80:             for (int texIndex = 0; texIndex < texCount; ++texIndex)
 81:             {
 82:                 if (texIndex != 0)
 83:                 {
 84:                     auto nameWithoutNumber = name.substr(0, name.length() - 1);
 85:                     _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s%s_00.dds", basedir, modPath.c_str(), nameWithoutNumber.data(), std::to_string(texIndex + 1).data());
 86:                 }
 87:                 else
 88:                     _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s_00.dds", basedir, modPath.c_str(), name.data());
 89: 
 90:                 auto textureHandle = newRenderer.createTextureHandle(full_tex_path, &width, &height, &mipCount);
 91:                 if (!textureHandle.idx)
 92:                 {
 93:                     if (texIndex != 0)
 94:                         _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s%s.dds", basedir, modPath.c_str(), name.data(), std::to_string(texIndex + 1).data());
 95:                     else
 96:                         _snprintf(full_tex_path, sizeof(full_tex_path), "%s/%s/world/%s.dds", basedir, modPath.c_str(), name.data());
 97: 
 98:                     textureHandle = newRenderer.createTextureHandle(texFullPath.data(), &width, &height, &mipCount);
 99:                     if (!textureHandle.idx) textureHandle = BGFX_INVALID_HANDLE;
100:                 }
101: 
102:                 if(bgfx::isValid(textureHandle))
103:                 {
104:                     material.baseColorTexHandles.push_back(textureHandle);
105:                 }
106:             }
107: 
108:             std::string nmlTexFullPath = tex_path + name + "_nml.dds";
109:             auto nmlTextureHandle = newRenderer.createTextureHandle(nmlTexFullPath.data(), &width, &height, &mipCount, false);
110:             if (!nmlTextureHandle.idx) nmlTextureHandle = BGFX_INVALID_HANDLE;
111:             if(bgfx::isValid(nmlTextureHandle))
112:             {
113:                 material.normalTexHandles.push_back(nmlTextureHandle);
114:             }
115: 
116:             std::string pbrTexFullPath = tex_path + name + "_pbr.dds";
117:             auto pbrTextureHandle = newRenderer.createTextureHandle(pbrTexFullPath.data(), &width, &height, &mipCount, false);
118:             if (!pbrTextureHandle.idx) pbrTextureHandle = BGFX_INVALID_HANDLE;
119:             if(bgfx::isValid(pbrTextureHandle))
120:             {
121:                 material.pbrTexHandles.push_back(pbrTextureHandle);
122:             }
123:         }
124: 	}
125: 
126: 	for (size_t i = 0; i < data->meshes_count; i++)
127: 	{
128: 		cgltf_mesh mesh = data->meshes[i];
129: 
130: 		for (size_t j = 0; j < mesh.primitives_count; j++)
131: 		{
132: 			Shape outShape;
133: 
134: 			cgltf_primitive primitive = mesh.primitives[j];
135: 			auto indexCount = primitive.indices->count;
136: 			auto vertexCount = 0;
137: 
138: 			float* posBuffer = nullptr;
139: 			float* normalBuffer = nullptr;
140: 			float* uvBuffer = nullptr;
141: 			float* colorBuffer = nullptr;
142: 			for (size_t k = 0; k < primitive.attributes_count; k++)
143: 			{
144: 				cgltf_attribute attr = primitive.attributes[k];
145: 
146: 				if(strcmp(attr.name, "POSITION") == 0)
147: 				{
148: 					vertexCount = attr.data->count;
149: 					posBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
150: 					outShape.min.x = attr.data->min[0];
151: 					outShape.min.y = attr.data->min[1];
152: 					outShape.min.z = attr.data->min[2];
153: 					outShape.max.x = attr.data->max[0];
154: 					outShape.max.y = attr.data->max[1];
155: 					outShape.max.z = attr.data->max[2];
156: 				}
157: 				else if(strcmp(attr.name, "NORMAL") == 0)
158: 				{
159: 					normalBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
160: 				}
161: 				else if(strcmp(attr.name, "TEXCOORD_0") == 0)
162: 				{
163: 					uvBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
164: 				}
165: 				else if(strcmp(attr.name, "COLOR_0") == 0)
166: 				{
167: 					colorBuffer = (float*)((char*)attr.data->buffer_view->buffer->data + attr.data->buffer_view->offset);
168: 				}
169: 			}
170: 
171:             outShape.isDoubleSided = primitive.material->double_sided;
172: 
173: 			auto texture = primitive.material->pbr_metallic_roughness.base_color_texture.texture;
174: 			if(texture != nullptr)
175: 			{
176: 				std::string texName = texture->image->name;
177: 				if(materials.contains(texName)) outShape.pMaterial = &materials[texName];
178: 			}
179: 			auto baseColorFactor = primitive.material->pbr_metallic_roughness.base_color_factor;
180: 			for (int vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)
181: 			{
182: 				struct nvertex vertex;
183: 				vertex._.x = posBuffer[3 * vertexIndex];
184: 				vertex._.y = posBuffer[3 * vertexIndex + 2];
185: 				vertex._.z = posBuffer[3 * vertexIndex + 1];
186: 
187: 				vertex.color.w = 1.0f;
188: 				vertex.color.r = static_cast<char>(baseColorFactor[0] * 255);
189: 				vertex.color.g = static_cast<char>(baseColorFactor[1] * 255);
190: 				vertex.color.b = static_cast<char>(baseColorFactor[2] * 255);
191: 				vertex.color.a = static_cast<char>(baseColorFactor[3] * 255);
192: 
193:                 if (uvBuffer != nullptr)
194:                 {
195: 				    vertex.u = uvBuffer[2 * vertexIndex];
196: 				    vertex.v = uvBuffer[2 * vertexIndex + 1];
197:                 }
198:                 else
199:                 {
200:                     vertex.u = 0.0f;
201: 				    vertex.v = 0.0f;
202:                 }
203: 
204: 				outShape.vertices.push_back(vertex);
205: 
206: 				struct vector3<float> normal;
207: 
208: 				normal.x = normalBuffer[3 * vertexIndex];
209: 				normal.y = normalBuffer[3 * vertexIndex + 2];
210: 				normal.z = normalBuffer[3 * vertexIndex + 1];
211: 
212: 				outShape.normals.push_back(normal);
213: 			}
214: 
215: 			if(primitive.indices->component_type == cgltf_component_type_r_16u)
216: 			{
217: 				auto indexBuffer = (unsigned short*)((char*)primitive.indices->buffer_view->buffer->data + primitive.indices->buffer_view->offset);
218: 
219: 				for (int id = 0; id < indexCount; ++id)
220: 				{
221: 					outShape.indices.push_back(indexBuffer[id]);
222: 				}
223: 			}else if(primitive.indices->component_type == cgltf_component_type_r_32u)
224: 			{
225: 				auto indexBuffer = (unsigned int*)((char*)primitive.indices->buffer_view->buffer->data + primitive.indices->buffer_view->offset);
226: 				for (int id = 0; id < indexCount; ++id)
227: 				{
228: 					outShape.indices.push_back(indexBuffer[id]);
229: 				}
230: 			}
231: 
232:             fillExternalMeshVertexBuffer(outShape.vertices.data(), outShape.normals.data(), outShape.vertices.size());
233:             fillExternalMeshIndexBuffer(outShape.indices.data(), outShape.indices.size());
234: 
235:             shapes.push_back(outShape);
236: 		}
237: 	}
238: 
239:     updateExternalMeshBuffers();
240: 
241:     cgltf_free(data);
242: 
243: 	return true;
244: }
245: 
246: uint32_t ExternalMesh::fillExternalMeshVertexBuffer(struct nvertex* inVertex, struct vector3<float>* normals, uint32_t inCount)
247: {
248:     if (!bgfx::isValid(vertexBufferHandle)) vertexBufferHandle = bgfx::createDynamicVertexBuffer(inCount, newRenderer.GetVertexLayout(), BGFX_BUFFER_ALLOW_RESIZE);
249: 
250:     uint32_t currentOffset = vertexBufferData.size();
251: 
252:     for (uint32_t idx = 0; idx < inCount; idx++)
253:     {
254:         vertexBufferData.push_back(Vertex());
255: 
256:         vertexBufferData[currentOffset + idx].x = inVertex[idx]._.x;
257:         vertexBufferData[currentOffset + idx].y = inVertex[idx]._.y;
258:         vertexBufferData[currentOffset + idx].z = inVertex[idx]._.z;
259:         vertexBufferData[currentOffset + idx].w = (::isinf(inVertex[idx].color.w) ? 1.0f : inVertex[idx].color.w);
260:         vertexBufferData[currentOffset + idx].bgra = inVertex[idx].color.color;
261:         vertexBufferData[currentOffset + idx].u = inVertex[idx].u;
262:         vertexBufferData[currentOffset + idx].v = inVertex[idx].v;
263: 
264:         if (normals)
265:         {
266:             vertexBufferData[currentOffset + idx].nx = normals[idx].x;
267:             vertexBufferData[currentOffset + idx].ny = normals[idx].y;
268:             vertexBufferData[currentOffset + idx].nz = normals[idx].z;
269:         }
270: 
271:         if (vertex_log && idx == 0) ffnx_trace("%s: %u [XYZW(%f, %f, %f, %f), BGRA(%08x), UV(%f, %f)]\n", __func__, idx, vertexBufferData[currentOffset + idx].x, vertexBufferData[currentOffset + idx].y, vertexBufferData[currentOffset + idx].z, vertexBufferData[currentOffset + idx].w, vertexBufferData[currentOffset + idx].bgra, vertexBufferData[currentOffset + idx].u, vertexBufferData[currentOffset + idx].v);
272:         if (vertex_log && idx == 1) ffnx_trace("%s: See the rest on RenderDoc.\n", __func__);
273:     }
274: 
275:     return currentOffset;
276: };
277: 
278: uint32_t ExternalMesh::fillExternalMeshIndexBuffer(uint32_t* inIndex, uint32_t inCount)
279: {
280:     if (!bgfx::isValid(indexBufferHandle)) indexBufferHandle = bgfx::createDynamicIndexBuffer(inCount, BGFX_BUFFER_ALLOW_RESIZE | BGFX_BUFFER_INDEX32);
281: 
282:     uint32_t currentOffset = indexBufferData.size();
283: 
284:     for (uint32_t idx = 0; idx < inCount; idx++)
285:     {
286:         indexBufferData.push_back(inIndex[idx]);
287:     }
288: 
289:     return currentOffset;
290: };
291: 
292: void ExternalMesh::updateExternalMeshBuffers()
293: {
294:     bgfx::update(
295:         vertexBufferHandle,
296:         0,
297:         bgfx::copy(
298:             vertexBufferData.data(),
299:             vectorSizeOf(vertexBufferData)
300:         )
301:     );
302: 
303:     bgfx::update(
304:         indexBufferHandle,
305:         0,
306:         bgfx::copy(
307:             indexBufferData.data(),
308:             vectorSizeOf(indexBufferData)
309:         )
310:     );
311: }
312: 
313: void ExternalMesh::bindField3dVertexBuffer(uint32_t offset, uint32_t inCount)
314: {
315:     bgfx::setVertexBuffer(0, vertexBufferHandle, offset, inCount);
316: }
317: 
318: void ExternalMesh::bindField3dIndexBuffer(uint32_t offset, uint32_t inCount)
319: {
320:     bgfx::setIndexBuffer(indexBufferHandle, offset, inCount);
321: }
322: 
323: void ExternalMesh::clearExternalMesh3dBuffers()
324: {
325:     vertexBufferData.clear();
326:     vertexBufferData.shrink_to_fit();
327: 
328:     indexBufferData.clear();
329:     indexBufferData.shrink_to_fit();
330: }
331: 
332: void ExternalMesh::unloadExternalMesh()
333: {
334:     for (const auto& mat : materials)
335:     {
336:         for (const auto& tex : mat.second.baseColorTexHandles)
337:         {
338:             if (bgfx::isValid(tex))
339:                 bgfx::destroy(tex);
340:         }
341:         for (const auto& tex : mat.second.normalTexHandles)
342:         {
343:             if (bgfx::isValid(tex))
344:                 bgfx::destroy(tex);
345:         }
346:         for (const auto& tex : mat.second.pbrTexHandles)
347:         {
348:             if (bgfx::isValid(tex))
349:                 bgfx::destroy(tex);
350:         }
351:     }
352:     shapes.clear();
353:     materials.clear();
354:     clearExternalMesh3dBuffers();
355: }
356: 
357: void ExternalMesh::loadConfig(const std::string& path)
358: {
359:     try
360:     {
361:         config = toml::parse_file(path);
362:     }
363:     catch (const toml::parse_error &err)
364:     {
365:         config = toml::parse("");
366:     }
367: }
368: 
369: int ExternalMesh::getTextureCount(std::string tex_name)
370: {
371:     auto node = config[tex_name];
372:     if(node)
373:     {
374:         if (auto sub_node = node["num_textures"]) return sub_node.value_or(0);
375:     }
376: 
377:     return 1;
378: }
379: 
380: int ExternalMesh::getFrameInterval(std::string tex_name)
381: {
382:     auto node = config[tex_name];
383:     if(node)
384:     {
385:         if (auto sub_node = node["frame_interval"]) return sub_node.value_or(0);
386:     }
387: 
388:     return 0;
389: }
</file>

<file path="src/external_mesh.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include <vector>
26: #include <map>
27: #include <string>
28: #include <toml++/toml.h>
29: 
30: #include "renderer.h"
31: 
32: struct Material
33: {
34:     std::vector<bgfx::TextureHandle> baseColorTexHandles;
35:     std::vector<bgfx::TextureHandle> normalTexHandles;
36:     std::vector<bgfx::TextureHandle> pbrTexHandles;
37:     int texIndex = 0;
38:     int frameInterval = 0;
39: };
40: 
41: struct Shape
42: {
43:     std::vector<nvertex> vertices;
44:     std::vector<vector3<float>> normals;
45:     std::vector<uint32_t> indices;
46:     vector3<float> min;
47:     vector3<float> max;
48:     Material* pMaterial = nullptr;
49:     bool isDoubleSided = false;
50: };
51: 
52: class ExternalMesh
53: {
54: public:
55:     bool importExternalMeshGltfFile(char* file_path, char* tex_path);
56:     uint32_t fillExternalMeshVertexBuffer(struct nvertex* inVertex, struct vector3<float>* normals, uint32_t inCount);
57:     uint32_t fillExternalMeshIndexBuffer(uint32_t* inIndex, uint32_t inCount);
58:     void updateExternalMeshBuffers();
59:     void bindField3dVertexBuffer(uint32_t offset, uint32_t inCount);
60:     void bindField3dIndexBuffer(uint32_t offset, uint32_t inCount);
61:     void clearExternalMesh3dBuffers();
62:     void unloadExternalMesh();
63: 
64:     std::vector<Shape> shapes;
65: 	std::map<std::string, Material> materials;
66: private:
67:     void loadConfig(const std::string& path);
68: 
69:     int getTextureCount(std::string tex_name);
70:     int getFrameInterval(std::string tex_name);
71: 
72: private:
73:     // Config
74:     toml::parse_result config;
75: 
76:     std::vector<Vertex> vertexBufferData;
77:     bgfx::DynamicVertexBufferHandle vertexBufferHandle = BGFX_INVALID_HANDLE;
78: 
79:     std::vector<uint32_t> indexBufferData;
80:     bgfx::DynamicIndexBufferHandle indexBufferHandle = BGFX_INVALID_HANDLE;
81: };
</file>

<file path="src/externals_102_de.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: common_externals.start =                      0x40B6E0;
25: common_externals.debug_print =                0x664E00;
26: common_externals.debug_print2 =               0x414EE0;
27: common_externals.create_tex_header = (tex_header * (*)(void))0x688C16;
28: common_externals.midi_init =                  0x6DE060;
29: common_externals.get_midi_name = (char* (*)(uint32_t))0x6E69B0;
30: common_externals.play_midi =                  0x6DE935;
31: common_externals.use_midi =                   0x6DDF83;
32: common_externals.stop_midi =                  0x6DF70B;
33: common_externals.cross_fade_midi =            0x6DF4CE;
34: common_externals.pause_midi =                 0x6DF65B;
35: common_externals.restart_midi =               0x6DF6B3;
36: common_externals.midi_status =                0x6DF793;
37: common_externals.set_master_midi_volume =     0x6DF7BA;
38: common_externals.set_midi_volume =            0x6DF817;
39: common_externals.set_midi_volume_trans =      0x6DF92C;
40: common_externals.set_midi_tempo =             0x6DFA9D;
41: common_externals.draw_graphics_object =       0x66E611;
42: common_externals.font_info =          (char *)0x99EB68;
43: common_externals.build_dialog_window =        0x7743B0;
44: common_externals.load_tex_file =              0x688C66;
45: common_externals.directsound_buffer_flags_1 = 0x6E6E3D;
46: common_externals.create_window =              0x6768FA;
47: common_externals.engine_wndproc =    (WNDPROC)0x6765E9;
48: 
49: ff7_externals.chocobo_fix =                   0x70B512;
50: ff7_externals.midi_fix =                      0x6E0422;
51: ff7_externals.snowboard_fix =         (void *)0x94BA30;
52: ff7_externals.cdcheck =                       0x408FF3;
53: ff7_externals.get_inserted_cd_sub =           0x404A7D;
54: ff7_externals.insertedCD =            (DWORD*)0x9A12F8;
55: ff7_externals.requiredCD =          (uint8_t*)0xF3990C;
56: ff7_externals.sub_665D9A = (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D6A;
57: ff7_externals.sub_671742 = (void (*)(uint32_t, p_hundred*, struc_186*))0x671712;
58: ff7_externals.sub_6B27A9 = (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B2779;
59: ff7_externals.sub_68D2B8 = (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D288;
60: ff7_externals.sub_665793 = (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665763;
61: ff7_externals.matrix3x4 = (void (*)(matrix*))0x67BC2B;
62: ff7_externals.matrix4x3_multiply =            0x66CC0B;
63: ff7_externals.sub_6B26C0 =                    0x6B2690;
64: ff7_externals.sub_6B2720 =                    0x6B26F0;
65: ff7_externals.sub_673F5C =                    0x673F2C;
66: ff7_externals.savemap =               (savemap *)0xF38A68;
67: ff7_externals.menu_objects =          (menu_objects *)0xF39CF0;
68: ff7_externals.magic_thread_start =            0x427928;
69: ff7_externals.destroy_magic_effects = (void (*)(void))0x429322;
70: ff7_externals.init_stuff =                    0x40A091;
71: ff7_externals.wm_activateapp =                0x409CF2;
72: ff7_externals.get_gamepad =                   0x41F99E;
73: ff7_externals.update_gamepad_status =         0x41F7D8;
74: ff7_externals.gamepad_status = (struct ff7_gamepad_status*)0x9AEBE8;
75: ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10AF;
76: ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10F3;
77: ff7_externals.sfx_play_summon =               0x6E586F;
78: ff7_externals.battle_summon_leviathan_loop =  0x5B1775;
79: ff7_externals.battle_limit_omnislash_loop =   0x46BA0B;
80: ff7_externals.sub_60B260 = (BYTE(*)())0x60B1F0;
81: ff7_externals.sub_767C55 = (BYTE(*)())0x7048C5;
82: ff7_externals.field_battle_toggle = 0x60B371;
83: ff7_externals.worldmap_battle_toggle = 0x7042E4;
</file>

<file path="src/externals_102_fr.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: common_externals.start =                      0x40B6F0;
25: common_externals.debug_print =                0x664DD0;
26: common_externals.debug_print2 =               0x414EF0;
27: common_externals.create_tex_header = (tex_header * (*)(void))0x688BE6;
28: common_externals.midi_init =                  0x6DE000;
29: common_externals.get_midi_name = (char* (*)(uint32_t))0x6E6950;
30: common_externals.play_midi =                  0x6DE8D5;
31: common_externals.use_midi =                   0x6DDF23;
32: common_externals.stop_midi =                  0x6DF6AB;
33: common_externals.cross_fade_midi =            0x6DF46E;
34: common_externals.pause_midi =                 0x6DF5FB;
35: common_externals.restart_midi =               0x6DF653;
36: common_externals.midi_status =                0x6DF733;
37: common_externals.set_master_midi_volume =     0x6DF75A;
38: common_externals.set_midi_volume =            0x6DF7B7;
39: common_externals.set_midi_volume_trans =      0x6DF8CC;
40: common_externals.set_midi_tempo =             0x6DFA3D;
41: common_externals.draw_graphics_object =       0x66E5E1;
42: common_externals.font_info =           (char*)0x99FB98;
43: common_externals.build_dialog_window =        0x774690;
44: common_externals.load_tex_file =              0x688C36;
45: common_externals.directsound_buffer_flags_1 = 0x6E6DDD;
46: common_externals.create_window =              0x6768CA;
47: common_externals.engine_wndproc =    (WNDPROC)0x6765B9;
48: 
49: ff7_externals.chocobo_fix =                   0x70B4B2;
50: ff7_externals.midi_fix =                      0x6E03C2;
51: ff7_externals.snowboard_fix =         (void *)0x94BA48;
52: ff7_externals.cdcheck =                       0x409003;
53: ff7_externals.get_inserted_cd_sub =           0x404A8D;
54: ff7_externals.insertedCD =            (DWORD*)0x9A2328;
55: ff7_externals.requiredCD =          (uint8_t*)0xF3A91C;
56: ff7_externals.sub_665D9A = (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D3A;
57: ff7_externals.sub_671742 = (void (*)(uint32_t, p_hundred*, struc_186*))0x6716E2;
58: ff7_externals.sub_6B27A9 = (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B2749;
59: ff7_externals.sub_68D2B8 = (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D258;
60: ff7_externals.sub_665793 = (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665733;
61: ff7_externals.matrix3x4 = (void (*)(matrix*))0x67BBFB;
62: ff7_externals.matrix4x3_multiply =            0x66CBDB;
63: ff7_externals.sub_6B26C0 =                    0x6B2660;
64: ff7_externals.sub_6B2720 =                    0x6B26C0;
65: ff7_externals.sub_673F5C =                    0x673EFC;
66: ff7_externals.savemap =               (savemap*)0xF39A78;
67: ff7_externals.menu_objects =          (menu_objects*)0xF3AD00;
68: ff7_externals.magic_thread_start =            0x427938;
69: ff7_externals.destroy_magic_effects = (void (*)(void))0x429332;
70: ff7_externals.init_stuff =                    0x40A0A1;
71: ff7_externals.wm_activateapp =                0x409D02;
72: ff7_externals.get_gamepad =                   0x41F9AE;
73: ff7_externals.update_gamepad_status =         0x41F7E8;
74: ff7_externals.gamepad_status = (struct ff7_gamepad_status*)0x9AFC18;
75: ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10A5;
76: ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10DA;
77: ff7_externals.sfx_play_summon =               0x6E580F;
78: ff7_externals.battle_summon_leviathan_loop =  0x5B1785;
79: ff7_externals.battle_limit_omnislash_loop =   0x46BA1B;
80: ff7_externals.sub_60B260 = (BYTE(*)())0x60B200;
81: ff7_externals.sub_767C55 = (BYTE(*)())0x704865;
82: ff7_externals.field_battle_toggle = 0x60B381;
83: ff7_externals.worldmap_battle_toggle = 0x704284;
</file>

<file path="src/externals_102_sp.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: common_externals.start =                      0x40B6F0;
25: common_externals.debug_print =                0x664DD0;
26: common_externals.debug_print2 =               0x414EF0;
27: common_externals.create_tex_header = (tex_header * (*)(void))0x688BE6;
28: common_externals.midi_init =                  0x6DE000;
29: common_externals.get_midi_name = (char* (*)(uint32_t))0x6E6950;
30: common_externals.play_midi =                  0x6DE8D5;
31: common_externals.use_midi =                   0x6DDF23;
32: common_externals.stop_midi =                  0x6DF6AB;
33: common_externals.cross_fade_midi =            0x6DF46E;
34: common_externals.pause_midi =                 0x6DF5FB;
35: common_externals.restart_midi =               0x6DF653;
36: common_externals.midi_status =                0x6DF733;
37: common_externals.set_master_midi_volume =     0x6DF75A;
38: common_externals.set_midi_volume =            0x6DF7B7;
39: common_externals.set_midi_volume_trans =      0x6DF8CC;
40: common_externals.set_midi_tempo =             0x6DFA3D;
41: common_externals.draw_graphics_object =       0x66E5E1;
42: common_externals.font_info =          (char *)0x9A05F8;
43: common_externals.build_dialog_window =        0x7747A0;
44: common_externals.load_tex_file =              0x688C36;
45: common_externals.directsound_buffer_flags_1 = 0x6E6DDD;
46: common_externals.create_window =              0x6768CA;
47: common_externals.engine_wndproc =    (WNDPROC)0x6765B9;
48: 
49: ff7_externals.chocobo_fix =                   0x70B4B2;
50: ff7_externals.midi_fix =                      0x6E03C2;
51: ff7_externals.snowboard_fix =         (void *)0x94CA30;
52: ff7_externals.cdcheck =                       0x409003;
53: ff7_externals.get_inserted_cd_sub =           0x404A8D;
54: ff7_externals.insertedCD =            (DWORD*)0x9A2D88;
55: ff7_externals.requiredCD =          (uint8_t*)0xF3B3EC;
56: ff7_externals.sub_665D9A = (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D3A;
57: ff7_externals.sub_671742 = (void (*)(uint32_t, p_hundred*, struc_186*))0x6716E2;
58: ff7_externals.sub_6B27A9 = (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B2749;
59: ff7_externals.sub_68D2B8 = (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D258;
60: ff7_externals.sub_665793 = (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665733;
61: ff7_externals.matrix3x4 = (void (*)(matrix*))0x67BBFB;
62: ff7_externals.matrix4x3_multiply =            0x66CBDB;
63: ff7_externals.sub_6B26C0 =                    0x6B2660;
64: ff7_externals.sub_6B2720 =                    0x6B26C0;
65: ff7_externals.sub_673F5C =                    0x673EFC;
66: ff7_externals.savemap =               (savemap *)0xF3A548;
67: ff7_externals.menu_objects =          (menu_objects *)0xF3B7D0;
68: ff7_externals.magic_thread_start =            0x427938;
69: ff7_externals.destroy_magic_effects = (void (*)(void))0x429332;
70: ff7_externals.init_stuff =                    0x40A0A1;
71: ff7_externals.wm_activateapp =                0x409D02;
72: ff7_externals.get_gamepad =                   0x41F9AE;
73: ff7_externals.update_gamepad_status =         0x41F7E8;
74: ff7_externals.gamepad_status = (struct ff7_gamepad_status*)0x9B0678;
75: ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10AC;
76: ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10E1;
77: ff7_externals.sfx_play_summon =               0x6E580F;
78: ff7_externals.battle_summon_leviathan_loop =  0x5B1785;
79: ff7_externals.battle_limit_omnislash_loop =   0x46BA1B;
80: ff7_externals.sub_60B260 = (BYTE(*)())0x60B200;
81: ff7_externals.sub_767C55 = (BYTE(*)())0x704865;
82: ff7_externals.field_battle_toggle = 0x60B381;
83: ff7_externals.worldmap_battle_toggle = 0x704284;
</file>

<file path="src/externals_102_us.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: common_externals.start =                      0x40B6E0;
25: common_externals.debug_print =                0x664E30;
26: common_externals.debug_print2 =               0x414EE0;
27: common_externals.create_tex_header =  (tex_header* (*)(void))0x688C46;
28: common_externals.midi_init =                  0x741780;
29: common_externals.get_midi_name =      (char* (*)(uint32_t))0x74A0D0;
30: common_externals.play_midi =                  0x742055;
31: common_externals.use_midi =                   0x7416A3;
32: common_externals.stop_midi =                  0x742E2B;
33: common_externals.cross_fade_midi =            0x742BEE;
34: common_externals.pause_midi =                 0x742D7B;
35: common_externals.restart_midi =               0x742DD3;
36: common_externals.midi_status =                0x742EB3;
37: common_externals.set_master_midi_volume =     0x742EDA;
38: common_externals.set_midi_volume =            0x742F37;
39: common_externals.set_midi_volume_trans =      0x74304C;
40: common_externals.set_midi_tempo =             0x7431BD;
41: common_externals.draw_graphics_object =       0x66E272;
42: common_externals.font_info =          (char *)0x99DDA8;
43: common_externals.build_dialog_window =        0x6E97E0;
44: common_externals.load_tex_file =              0x688C96;
45: common_externals.directsound_buffer_flags_1 = 0x74A55D;
46: common_externals.create_window =              0x67692A;
47: common_externals.engine_wndproc =    (WNDPROC)0x676619;
48: 
49: ff7_externals.chocobo_fix =                   0x76EC32;
50: ff7_externals.midi_fix =                      0x743B42;
51: ff7_externals.snowboard_fix =         (void *)0x958328;
52: ff7_externals.cdcheck =                       0x408FF3;
53: ff7_externals.get_inserted_cd_sub =           0x404A7D;
54: ff7_externals.insertedCD =            (DWORD*)0x9A0538;
55: ff7_externals.requiredCD =          (uint8_t*)0xDC0BDC;
56: ff7_externals.sub_665D9A =            (void (*)(matrix*, nvertex*, indexed_primitive*, p_hundred*, struc_186*, ff7_game_obj*))0x665D9A;
57: ff7_externals.sub_671742 =            (void (*)(uint32_t, p_hundred*, struc_186*))0x671742;
58: ff7_externals.sub_6B27A9 =            (void (*)(matrix*, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, void*, ff7_game_obj*))0x6B27A9;
59: ff7_externals.sub_68D2B8 =            (void (*)(uint32_t, ff7_polygon_set*, void*))0x68D2B8;
60: ff7_externals.sub_665793 =            (void (*)(matrix*, uint32_t, indexed_primitive*, ff7_polygon_set*, p_hundred*, p_group*, ff7_game_obj*))0x665793;
61: ff7_externals.matrix3x4 =             (void (*)(matrix*))0x67BC5B;
62: ff7_externals.matrix4x3_multiply =            0x66CC3B;
63: ff7_externals.sub_6B26C0 =                    0x6B26C0;
64: ff7_externals.sub_6B2720 =                    0x6B2720;
65: ff7_externals.sub_673F5C =                    0x673F5C;
66: ff7_externals.savemap =               (savemap *)0xDBFD38;
67: ff7_externals.menu_objects =          (menu_objects *)0xDC0FC0;
68: ff7_externals.magic_thread_start =            0x427928;
69: ff7_externals.destroy_magic_effects = (void (*)(void))0x429322;
70: ff7_externals.init_stuff =                    0x40A091;
71: ff7_externals.wm_activateapp =                0x409CF2;
72: ff7_externals.get_gamepad =                   0x41F99E;
73: ff7_externals.update_gamepad_status =         0x41F7D8;
74: ff7_externals.gamepad_status =        (struct ff7_gamepad_status*)0x9ADE28;
75: ff7_externals.call_menu_sound_slider_loop_sfx_down = 0x10A8;
76: ff7_externals.call_menu_sound_slider_loop_sfx_up = 0x10EC;
77: ff7_externals.sfx_play_summon =               0x748F8F;
78: ff7_externals.battle_summon_leviathan_loop =  0x5B1775;
79: ff7_externals.battle_limit_omnislash_loop =   0x46BA0B;
80: ff7_externals.sub_60B260 =         (BYTE(*)())0x60B260;
81: ff7_externals.sub_767C55 =         (BYTE(*)())0x767C55;
82: ff7_externals.field_battle_toggle =           0x60B3E1;
83: ff7_externals.worldmap_battle_toggle =        0x767674;
</file>

<file path="src/fake_dd.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "renderer.h"
 23: 
 24: #include "fake_dd.h"
 25: #include "gl.h"
 26: #include "log.h"
 27: 
 28: uint32_t __stdcall fake_dd_blit_fast(struct ddsurface **me, uint32_t unknown1, uint32_t unknown2, struct ddsurface **target, LPRECT source, uint32_t unknown3);
 29: uint32_t __stdcall fake_ddsurface_get_pixelformat(struct ddsurface **me, LPDDPIXELFORMAT pf);
 30: uint32_t __stdcall fake_ddsurface_get_surface_desc(struct ddsurface **me, LPDDSURFACEDESC2 sd);
 31: uint32_t __stdcall fake_ddsurface_get_dd_interface(struct ddsurface **me, struct dddevice ***dd);
 32: uint32_t __stdcall fake_ddsurface_get_palette(struct ddsurface **me, void **palette);
 33: uint32_t __stdcall fake_ddsurface_lock(struct ddsurface **me, LPRECT dest, LPDDSURFACEDESC sd, uint32_t flags, uint32_t unused);
 34: uint32_t __stdcall fake_ddsurface_unlock(struct ddsurface **me, LPRECT dest);
 35: uint32_t __stdcall fake_ddsurface_islost(struct ddsurface **me);
 36: uint32_t __stdcall fake_ddsurface_restore(struct ddsurface **me);
 37: uint32_t __stdcall fake_dd_query_interface(struct dddevice **me, uint32_t *iid, void **ppvobj);
 38: uint32_t __stdcall fake_dd_addref(struct dddevice **me);
 39: uint32_t __stdcall fake_dd_release(struct dddevice **me);
 40: uint32_t __stdcall fake_dd_create_clipper(struct dddevice **me, DWORD flags, LPDIRECTDRAWCLIPPER *clipper);
 41: uint32_t __stdcall fake_dd_create_palette(struct dddevice **me, LPPALETTEENTRY palette_entry, LPDIRECTDRAWPALETTE *palette, IUnknown *unused);
 42: uint32_t __stdcall fake_dd_create_surface(struct dddevice **me, LPDDSURFACEDESC sd, LPDIRECTDRAWSURFACE *surface, IUnknown *unused);
 43: uint32_t __stdcall fake_dd_get_caps(struct dddevice **me, LPDDCAPS halcaps, LPDDCAPS helcaps);
 44: uint32_t __stdcall fake_dd_get_display_mode(struct dddevice **me, LPDDSURFACEDESC sd);
 45: uint32_t __stdcall fake_dd_set_coop_level(struct dddevice **me, uint32_t coop_level);
 46: uint32_t __stdcall fake_d3d_get_caps(struct d3d2device **me, void *a, void *b);
 47: 
 48: struct ddsurface fake_dd_surface = {
 49: 	fake_dd_query_interface,
 50: 	fake_dd_addref,
 51: 	fake_dd_release,
 52: 	0,
 53: 	0,
 54: 	0,
 55: 	0,
 56: 	fake_dd_blit_fast,
 57: 	0,
 58: 	0,
 59: 	0,
 60: 	0,
 61: 	0,
 62: 	0,
 63: 	0,
 64: 	0,
 65: 	0,
 66: 	0,
 67: 	0,
 68: 	0,
 69: 	fake_ddsurface_get_palette,
 70: 	fake_ddsurface_get_pixelformat,
 71: 	fake_ddsurface_get_surface_desc,
 72: 	0,
 73: 	fake_ddsurface_islost,
 74: 	fake_ddsurface_lock,
 75: 	0,
 76: 	fake_ddsurface_restore,
 77: 	0,
 78: 	0,
 79: 	0,
 80: 	0,
 81: 	fake_ddsurface_unlock,
 82: 	0,
 83: 	0,
 84: 	0,
 85: 	fake_ddsurface_get_dd_interface,
 86: };
 87: struct ddsurface *_fake_dd_back_surface = &fake_dd_surface;
 88: 
 89: struct ddsurface fake_dd_front_surface = {
 90: 	fake_dd_query_interface,
 91: 	fake_dd_addref,
 92: 	fake_dd_release,
 93: 	0,
 94: 	0,
 95: 	0,
 96: 	0,
 97: 	fake_dd_blit_fast,
 98: 	0,
 99: 	0,
100: 	0,
101: 	0,
102: 	0,
103: 	0,
104: 	0,
105: 	0,
106: 	0,
107: 	0,
108: 	0,
109: 	0,
110: 	fake_ddsurface_get_palette,
111: 	fake_ddsurface_get_pixelformat,
112: 	fake_ddsurface_get_surface_desc,
113: 	0,
114: 	fake_ddsurface_islost,
115: 	fake_ddsurface_lock,
116: 	0,
117: 	fake_ddsurface_restore,
118: 	0,
119: 	0,
120: 	0,
121: 	0,
122: 	fake_ddsurface_unlock,
123: 	0,
124: 	0,
125: 	0,
126: 	fake_ddsurface_get_dd_interface,
127: };
128: struct ddsurface *_fake_dd_front_surface = &fake_dd_front_surface;
129: 
130: struct ddsurface fake_dd_temp_surface = {
131: 	fake_dd_query_interface,
132: 	fake_dd_addref,
133: 	fake_dd_release,
134: 	0,
135: 	0,
136: 	0,
137: 	0,
138: 	fake_dd_blit_fast,
139: 	0,
140: 	0,
141: 	0,
142: 	0,
143: 	0,
144: 	0,
145: 	0,
146: 	0,
147: 	0,
148: 	0,
149: 	0,
150: 	0,
151: 	fake_ddsurface_get_palette,
152: 	fake_ddsurface_get_pixelformat,
153: 	fake_ddsurface_get_surface_desc,
154: 	0,
155: 	fake_ddsurface_islost,
156: 	fake_ddsurface_lock,
157: 	0,
158: 	fake_ddsurface_restore,
159: 	0,
160: 	0,
161: 	0,
162: 	0,
163: 	fake_ddsurface_unlock,
164: 	0,
165: 	0,
166: 	0,
167: 	fake_ddsurface_get_dd_interface,
168: };
169: struct ddsurface *_fake_dd_temp_surface = &fake_dd_temp_surface;
170: 
171: struct dddevice fake_dddevice = {
172: 	fake_dd_query_interface,
173: 	fake_dd_addref,
174: 	fake_dd_release,
175: 	0,
176: 	fake_dd_create_clipper,
177: 	fake_dd_create_palette,
178: 	fake_dd_create_surface,
179: 	0,
180: 	0,
181: 	0,
182: 	0,
183: 	fake_dd_get_caps,
184: 	fake_dd_get_display_mode,
185: 	0,
186: 	0,
187: 	0,
188: 	0,
189: 	0,
190: 	0,
191: 	0,
192: 	fake_dd_set_coop_level,
193: 	0,
194: 	0,
195: 	0,
196: };
197: struct dddevice *_fake_dddevice = &fake_dddevice;
198: 
199: struct d3d2device fake_d3d2device = {
200: 	fake_dd_query_interface,
201: 	fake_dd_addref,
202: 	fake_dd_release,
203: 	fake_d3d_get_caps,
204: 	0,
205: 	0,
206: 	0,
207: 	0,
208: 	0,
209: 	0,
210: 	0,
211: 	0,
212: 	0,
213: 	0,
214: 	0,
215: 	0,
216: 	0,
217: 	0,
218: 	0,
219: 	0,
220: 	0,
221: 	0,
222: 	0,
223: 	0,
224: 	0,
225: 	0,
226: 	0,
227: 	0,
228: 	0,
229: };
230: struct d3d2device *_fake_d3d2device = &fake_d3d2device;
231: 
232: uint8_t* fake_dd_surface_buffer = nullptr;
233: 
234: uint32_t movie_texture = 0;
235: 
236: uint32_t __stdcall fake_dd_blit_fast(struct ddsurface **me, uint32_t unknown1, uint32_t unknown2, struct ddsurface **source, LPRECT src_rect, uint32_t unknown3)
237: {
238: 	if(trace_all || trace_fake_dx) ffnx_trace("blit_fast\n");
239: 
240: 	return DD_OK;
241: }
242: 
243: uint32_t __stdcall fake_ddsurface_get_pixelformat(struct ddsurface **me, LPDDPIXELFORMAT pf)
244: {
245: 	if(trace_all || trace_fake_dx) ffnx_trace("get_pixelformat\n");
246: 
247: 	pf->dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
248: 	pf->dwRGBBitCount = 32;
249: 	pf->dwBBitMask = 0xFF;
250: 	pf->dwGBitMask = 0xFF00;
251: 	pf->dwRBitMask = 0xFF0000;
252: 	pf->dwRGBAlphaBitMask = 0xFF000000;
253: 
254: 	return 0;
255: }
256: 
257: uint32_t __stdcall fake_ddsurface_get_surface_desc(struct ddsurface **me, LPDDSURFACEDESC2 sd)
258: {
259: 	if(trace_all || trace_fake_dx) ffnx_trace("get_surface_desc\n");
260: 
261: 	return 0;
262: }
263: 
264: uint32_t __stdcall fake_ddsurface_get_dd_interface(struct ddsurface **me, struct dddevice ***dd)
265: {
266: 	if(trace_all || trace_fake_dx) ffnx_trace("get_dd_interface\n");
267: 
268: 	*dd = &_fake_dddevice;
269: 	return 0;
270: }
271: 
272: uint32_t __stdcall fake_ddsurface_get_palette(struct ddsurface **me, void **palette)
273: {
274: 	if(trace_all || trace_fake_dx) ffnx_trace("get_palette\n");
275: 
276: 	//*palette = 0;
277: 
278: 	return DDERR_UNSUPPORTED;
279: }
280: 
281: uint32_t __stdcall fake_ddsurface_lock(struct ddsurface **me, LPRECT dest, LPDDSURFACEDESC sd, uint32_t flags, uint32_t unused)
282: {
283: 	if(trace_all || trace_fake_dx) ffnx_trace("lock\n");
284: 
285: 	if (fake_dd_surface_buffer == nullptr) fake_dd_surface_buffer = (uint8_t*)driver_calloc(game_width * game_height, 4);
286: 
287: 	sd->lpSurface = fake_dd_surface_buffer;
288: 	sd->dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT | DDSD_LPSURFACE;
289: 
290: 	sd->dwWidth = game_width;
291: 	sd->dwHeight = game_height;
292: 	sd->lPitch = game_width * 4;
293: 
294: 	sd->ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
295: 	sd->ddpfPixelFormat.dwRGBBitCount = 32;
296: 	sd->ddpfPixelFormat.dwBBitMask = 0xFF;
297: 	sd->ddpfPixelFormat.dwGBitMask = 0xFF00;
298: 	sd->ddpfPixelFormat.dwRBitMask = 0xFF0000;
299: 	sd->ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF000000;
300: 
301: 	return DD_OK;
302: }
303: 
304: uint32_t __stdcall fake_ddsurface_unlock(struct ddsurface **me, LPRECT dest)
305: {
306: 	if(trace_all || trace_fake_dx) ffnx_trace("unlock\n");
307: 
308: 	if (movie_texture) newRenderer.deleteTexture(movie_texture);
309: 
310: 	movie_texture = newRenderer.createTexture(
311: 		fake_dd_surface_buffer,
312: 		game_width,
313: 		game_height,
314: 		game_width * 4
315: 	);
316: 
317: 	newRenderer.useTexture(movie_texture);
318: 
319: 	newRenderer.isMovie(true);
320: 
321: 	gl_draw_movie_quad(game_width, game_height);
322: 
323: 	newRenderer.isMovie(false);
324: 
325: 	return DD_OK;
326: }
327: 
328: uint32_t __stdcall fake_ddsurface_islost(struct ddsurface **me)
329: {
330: 	if(trace_all || trace_fake_dx) ffnx_trace("islost\n");
331: 
332: 	return DD_OK;
333: }
334: 
335: uint32_t __stdcall fake_ddsurface_restore(struct ddsurface **me)
336: {
337: 	if(trace_all || trace_fake_dx) ffnx_trace("restore\n");
338: 
339: 	return DD_OK;
340: }
341: 
342: uint32_t __stdcall fake_dd_query_interface(struct dddevice **me, uint32_t *iid, void **ppvobj)
343: {
344: 	if(trace_all || trace_fake_dx) ffnx_trace("query_interface: 0x%p 0x%p 0x%p 0x%p\n", iid[0], iid[1], iid[2], iid[3]);
345: 
346: 	if(iid[0] == 0x6C14DB80)
347: 	{
348: 		*ppvobj = me;
349: 		return S_OK;
350: 	}
351: 
352: 	if(iid[0] == 0x57805885)
353: 	{
354: 		*ppvobj = &_fake_dd_temp_surface;
355: 		return S_OK;
356: 	}
357: 
358: 	return E_NOINTERFACE;
359: }
360: 
361: uint32_t __stdcall fake_dd_addref(struct dddevice **me)
362: {
363: 	if(trace_all || trace_fake_dx) ffnx_trace("addref\n");
364: 
365: 	return 1;
366: }
367: 
368: uint32_t __stdcall fake_dd_release(struct dddevice **me)
369: {
370: 	if(trace_all || trace_fake_dx) ffnx_trace("release\n");
371: 
372: 	return 0;
373: }
374: 
375: uint32_t __stdcall fake_dd_create_clipper(struct dddevice **me, DWORD flags, LPDIRECTDRAWCLIPPER *clipper)
376: {
377: 	if(trace_all || trace_fake_dx) ffnx_trace("create_clipper\n");
378: 
379: 	if(clipper == 0) return DDERR_INVALIDPARAMS;
380: 
381: 	*clipper = 0;
382: 
383: 	return DD_OK;
384: }
385: 
386: uint32_t __stdcall fake_dd_create_palette(struct dddevice **me, LPPALETTEENTRY palette_entry, LPDIRECTDRAWPALETTE *palette, IUnknown *unused)
387: {
388: 	if(trace_all || trace_fake_dx) ffnx_trace("create_palette\n");
389: 
390: 	if(palette == 0) return DDERR_INVALIDPARAMS;
391: 
392: 	*palette = 0;
393: 
394: 	return DD_OK;
395: }
396: 
397: uint32_t __stdcall fake_dd_create_surface(struct dddevice **me, LPDDSURFACEDESC sd, LPDIRECTDRAWSURFACE *surface, IUnknown *unused)
398: {
399: 	if(trace_all || trace_fake_dx) ffnx_trace("create_surface %ix%i\n", sd->dwWidth, sd->dwHeight);
400: 
401: 	*surface = (LPDIRECTDRAWSURFACE)&_fake_dd_temp_surface;
402: 
403: 	return 0;
404: }
405: 
406: uint32_t __stdcall fake_dd_get_caps(struct dddevice **me, LPDDCAPS halcaps, LPDDCAPS helcaps)
407: {
408: 	if(trace_all || trace_fake_dx) ffnx_trace("get_caps\n");
409: 
410: 	halcaps->dwCaps = DDCAPS_BLTSTRETCH;
411: 	return 0;
412: }
413: 
414: uint32_t __stdcall fake_dd_get_display_mode(struct dddevice **me, LPDDSURFACEDESC sd)
415: {
416: 	if(trace_all || trace_fake_dx) ffnx_trace("get_display_mode\n");
417: 
418: 	sd->dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | DDSD_PIXELFORMAT;
419: 
420: 	sd->dwWidth = game_width;
421: 	sd->dwHeight = game_height;
422: 	sd->lPitch = game_width * 4;
423: 
424: 	sd->ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
425: 	sd->ddpfPixelFormat.dwRGBBitCount = 32;
426: 	sd->ddpfPixelFormat.dwBBitMask = 0xFF;
427: 	sd->ddpfPixelFormat.dwGBitMask = 0xFF00;
428: 	sd->ddpfPixelFormat.dwRBitMask = 0xFF0000;
429: 	sd->ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF000000;
430: 
431: 	return 0;
432: }
433: 
434: uint32_t __stdcall fake_dd_set_coop_level(struct dddevice **me, uint32_t coop_level)
435: {
436: 	if(trace_all || trace_fake_dx) ffnx_trace("set_coop_level\n");
437: 
438: 	return 0;
439: }
440: 
441: uint32_t __stdcall fake_d3d_get_caps(struct d3d2device **me, void *a, void *b)
442: {
443: 	if(trace_all || trace_fake_dx) ffnx_trace("d3d_get_caps\n");
444: 
445: 	memset(a, -1, 0xFC);
446: 	memset(b, -1, 0xFC);
447: 
448: 	return DD_OK;
449: }
</file>

<file path="src/fake_dd.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #pragma once
 23: 
 24: #include <stdint.h>
 25: 
 26: struct ddsurface
 27: {
 28: 	void *query_interface;
 29: 	void *addref;
 30: 	void *release;
 31: 	uint32_t field_C;
 32: 	uint32_t field_10;
 33: 	uint32_t field_14;
 34: 	uint32_t field_18;
 35: 	void *blit_fast;
 36: 	uint32_t field_20;
 37: 	uint32_t field_24;
 38: 	uint32_t field_28;
 39: 	uint32_t field_2C;
 40: 	uint32_t field_30;
 41: 	uint32_t field_34;
 42: 	uint32_t field_38;
 43: 	uint32_t field_3C;
 44: 	uint32_t field_40;
 45: 	uint32_t field_44;
 46: 	uint32_t field_48;
 47: 	uint32_t field_4C;
 48: 	void *get_palette;
 49: 	void *get_pixelformat;
 50: 	void *get_surface_desc;
 51: 	uint32_t field_5C;
 52: 	void *islost;
 53: 	void *lock;
 54: 	uint32_t field_68;
 55: 	void *restore;
 56: 	uint32_t field_70;
 57: 	uint32_t field_74;
 58: 	uint32_t field_78;
 59: 	uint32_t field_7C;
 60: 	void *unlock;
 61: 	uint32_t field_84;
 62: 	uint32_t field_88;
 63: 	uint32_t field_8C;
 64: 	void *get_dd_interface;
 65: };
 66: 
 67: struct dddevice
 68: {
 69: 	void *query_interface;
 70: 	void *addref;
 71: 	void *release;
 72: 	uint32_t field_C;
 73: 	void *create_clipper;
 74: 	void *create_palette;
 75: 	void *create_surface;
 76: 	uint32_t field_1C;
 77: 	uint32_t field_20;
 78: 	uint32_t field_24;
 79: 	uint32_t field_28;
 80: 	void *get_caps;
 81: 	void *get_display_mode;
 82: 	uint32_t field_34;
 83: 	uint32_t field_38;
 84: 	uint32_t field_3C;
 85: 	uint32_t field_40;
 86: 	uint32_t field_44;
 87: 	uint32_t field_48;
 88: 	uint32_t field_4C;
 89: 	void *set_coop_level;
 90: 	uint32_t field_54;
 91: 	uint32_t field_58;
 92: 	uint32_t field_5C;
 93: };
 94: 
 95: struct d3d2device
 96: {
 97: 	void *query_interface;
 98: 	void *addref;
 99: 	void *release;
100: 	void *get_caps;
101: 	uint32_t field_10;
102: 	uint32_t field_14;
103: 	uint32_t field_18;
104: 	uint32_t field_1C;
105: 	uint32_t field_20;
106: 	uint32_t field_24;
107: 	uint32_t field_28;
108: 	uint32_t field_2C;
109: 	uint32_t field_30;
110: 	uint32_t field_34;
111: 	uint32_t field_38;
112: 	uint32_t field_3C;
113: 	uint32_t junk[10];
114: 	void *set_transform;
115: 	uint32_t field_6C;
116: 	uint32_t field_70;
117: 	uint32_t field_74;
118: 	void *draw_indexed_primitive;
119: };
120: 
121: extern struct ddsurface *_fake_dd_back_surface;
122: extern struct ddsurface *_fake_dd_temp_surface;
123: extern struct ddsurface *_fake_dd_front_surface;
124: extern struct dddevice *_fake_dddevice;
125: extern struct d3d2device *_fake_d3d2device;
</file>

<file path="src/ff7_data.h">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //    Copyright (C) 2023 Marcin 'Maki' Gomulak                              //
  10: //                                                                          //
  11: //    This file is part of FFNx                                             //
  12: //                                                                          //
  13: //    FFNx is free software: you can redistribute it and/or modify          //
  14: //    it under the terms of the GNU General Public License as published by  //
  15: //    the Free Software Foundation, either version 3 of the License         //
  16: //                                                                          //
  17: //    FFNx is distributed in the hope that it will be useful,               //
  18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  20: //    GNU General Public License for more details.                          //
  21: /****************************************************************************/
  22: 
  23: #pragma once
  24: 
  25: #include <functional>
  26: 
  27: #include "ff7.h"
  28: #include "globals.h"
  29: #include "log.h"
  30: #include "patch.h"
  31: 
  32: // FF7 game mode definitions
  33: static struct game_mode ff7_modes[] = {
  34: 	{FF7_MODE_FIELD,       "MODE_FIELD",       MODE_FIELD,       true  },
  35: 	{FF7_MODE_BATTLE,      "MODE_BATTLE",      MODE_BATTLE,      true  },
  36: 	{FF7_MODE_WORLDMAP,    "MODE_WORLDMAP",    MODE_WORLDMAP,    true  },
  37: 	{FF7_MODE_UNKNOWN4,    "MODE_UNKNOWN4",    MODE_UNKNOWN,     false },
  38: 	{FF7_MODE_MENU,        "MODE_MENU",        MODE_MENU,        true  },
  39: 	{FF7_MODE_HIGHWAY,     "MODE_HIGHWAY",     MODE_HIGHWAY,     true  },
  40: 	{FF7_MODE_CHOCOBO,     "MODE_CHOCOBO",     MODE_CHOCOBO,     true  },
  41: 	{FF7_MODE_SNOWBOARD,   "MODE_SNOWBOARD",   MODE_SNOWBOARD,   true  },
  42: 	{FF7_MODE_CONDOR,      "MODE_CONDOR",      MODE_CONDOR,      true  },
  43: 	{FF7_MODE_SUBMARINE,   "MODE_SUBMARINE",   MODE_SUBMARINE,   true  },
  44: 	{FF7_MODE_COASTER,     "MODE_COASTER",     MODE_COASTER,     true  },
  45: 	{FF7_MODE_CDCHECK,     "MODE_CDCHECK",     MODE_CDCHECK,     true  },
  46: 	{FF7_MODE_UNKNOWN13,   "MODE_UNKNOWN13",   MODE_UNKNOWN,     false },
  47: 	{FF7_MODE_SNOWBOARD2,  "MODE_SNOWBOARD2",  MODE_SNOWBOARD,   true  },
  48: 	{FF7_MODE_UNKNOWN15,   "MODE_UNKNOWN15",   MODE_UNKNOWN,     false },
  49: 	{FF7_MODE_UNKNOWN16,   "MODE_UNKNOWN16",   MODE_UNKNOWN,     false },
  50: 	{FF7_MODE_BATTLE_MENU, "MODE_BATTLE_MENU", MODE_MENU,        true  },
  51: 	{FF7_MODE_UNKNOWN18,   "MODE_UNKNOWN18",   MODE_UNKNOWN,     false },
  52: 	{FF7_MODE_EXIT,        "MODE_EXIT",        MODE_EXIT,        true  },
  53: 	{FF7_MODE_MAIN_MENU,   "MODE_MAIN_MENU",   MODE_MAIN_MENU,   true  },
  54: 	{FF7_MODE_UNKNOWN21,   "MODE_UNKNOWN21",   MODE_UNKNOWN,     false },
  55: 	{FF7_MODE_INTRO,       "MODE_INTRO",       MODE_INTRO,       true  },
  56: 	{FF7_MODE_SWIRL,       "MODE_SWIRL",       MODE_SWIRL,       true  },
  57: 	{FF7_MODE_UNKNOWN24,   "MODE_UNKNOWN24",   MODE_UNKNOWN,     false },
  58: 	{FF7_MODE_ENDING2,     "MODE_ENDING2",     MODE_ENDINGMOVIE, false },
  59: 	{FF7_MODE_GAMEOVER,    "MODE_GAMEOVER",    MODE_GAMEOVER,    true  },
  60: 	{FF7_MODE_CREDITS,     "MODE_CREDITS",     MODE_CREDITS,     true  },
  61: 	{FF7_MODE_UNKNOWN28,   "MODE_UNKNOWN28",   MODE_UNKNOWN,     false },
  62: };
  63: 
  64: inline void ff7_set_main_loop(uint32_t driver_mode, uint32_t main_loop)
  65: {
  66: 	uint32_t i;
  67: 
  68: 	for(i = 0; i < num_modes; i++) if(ff7_modes[i].driver_mode == driver_mode) ff7_modes[i].main_loop = main_loop;
  69: }
  70: 
  71: inline void ff7_find_externals(struct ff7_game_obj* game_object)
  72: {
  73: 	uint32_t main_init_loop = (uint32_t)game_object->engine_loop_obj.init;
  74: 	uint32_t main_loop = (uint32_t)game_object->engine_loop_obj.main_loop;
  75: 	uint32_t main_cleanup_loop = (uint32_t)game_object->engine_loop_obj.cleanup;
  76: 	uint32_t field_main_loop;
  77: 	uint32_t battle_main_loop;
  78: 	uint32_t menu_main_loop;
  79: 	uint32_t cdcheck_main_loop;
  80: 	uint32_t credits_main_loop;
  81: 	uint32_t coaster_main_loop;
  82: 	uint32_t condor_main_loop;
  83: 	uint32_t chocobo_main_loop;
  84: 	uint32_t highway_main_loop;
  85: 	uint32_t swirl_main_loop;
  86: 	uint32_t snowboard_main_loop;
  87: 	uint32_t submarine_main_loop;
  88: 	uint32_t gameover_main_loop;
  89: 	uint32_t movie_module;
  90: 	uint32_t file_module;
  91: 
  92: 	if(*((uint32_t *)main_loop) != 0x81EC8B55) ffnx_unexpected("odd main loop prologue\n");
  93: 
  94: 	common_externals.get_time = (uint64_t (*)(uint64_t*))get_relative_call(common_externals.winmain, 0x2BE);
  95: 	common_externals.diff_time = (uint64_t (*)(uint64_t*,uint64_t*,uint64_t*))get_relative_call(common_externals.winmain, 0x2F6);
  96: 
  97: 	common_externals.update_movie_sample = get_relative_call(main_loop, 0x67);
  98: 
  99: 	movie_module = common_externals.update_movie_sample - 0x3039;
 100: 
 101: 	ff7_externals.movie_sub_415231 = (void (*)(char*))(movie_module + 0x331);
 102: 	common_externals.prepare_movie = movie_module + 0x1A95;
 103: 	common_externals.release_movie_objects = movie_module + 0x2859;
 104: 	common_externals.start_movie = movie_module + 0x2BB0;
 105: 	common_externals.stop_movie = movie_module + 0x2CB2;
 106: 	common_externals.get_movie_frame = movie_module + 0x3713;
 107: 
 108: 	ff7_externals.movie_object = (struct movie_obj *)(get_absolute_value(common_externals.prepare_movie, 0x42) - 0xC);
 109: 
 110: 	common_externals._mode = (WORD*)get_absolute_value(main_loop, 0x8C);
 111: 	common_externals._previous_mode = (WORD *)get_absolute_value(main_loop, 0x1D8);
 112: 
 113: 	gameover_main_loop = get_absolute_value(main_loop, 0x1FE);
 114: 	ff7_set_main_loop(MODE_GAMEOVER, gameover_main_loop);
 115: 	swirl_main_loop = get_absolute_value(main_loop, 0x25B);
 116: 	ff7_set_main_loop(MODE_SWIRL, swirl_main_loop);
 117: 	cdcheck_main_loop = get_absolute_value(main_loop, 0x397);
 118: 	ff7_set_main_loop(MODE_CDCHECK, cdcheck_main_loop);
 119: 	credits_main_loop = get_absolute_value(main_loop, 0x4CA);
 120: 	ff7_set_main_loop(MODE_CREDITS, credits_main_loop);
 121: 	menu_main_loop = get_absolute_value(main_loop, 0x62E);
 122: 	ff7_set_main_loop(MODE_MENU, menu_main_loop);
 123: 	ff7_set_main_loop(MODE_MAIN_MENU, menu_main_loop);
 124: 	battle_main_loop = get_absolute_value(main_loop, 0x89A);
 125: 	ff7_set_main_loop(MODE_BATTLE, battle_main_loop);
 126: 	field_main_loop = get_absolute_value(main_loop, 0x8F8);
 127: 	ff7_set_main_loop(MODE_FIELD, field_main_loop);
 128: 	ff7_externals.world_loop_74BE49 = get_absolute_value(main_loop, 0x977);
 129: 	ff7_set_main_loop(MODE_WORLDMAP, ff7_externals.world_loop_74BE49);
 130: 	chocobo_main_loop = get_absolute_value(main_loop, 0x9C5);
 131: 	ff7_set_main_loop(MODE_CHOCOBO, chocobo_main_loop);
 132: 	condor_main_loop = get_absolute_value(main_loop, 0xA13);
 133: 	ff7_set_main_loop(MODE_CONDOR, condor_main_loop);
 134: 	highway_main_loop = get_absolute_value(main_loop, 0xA61);
 135: 	ff7_set_main_loop(MODE_HIGHWAY, highway_main_loop);
 136: 	coaster_main_loop = get_absolute_value(main_loop, 0xAAF);
 137: 	ff7_set_main_loop(MODE_COASTER, coaster_main_loop);
 138: 	submarine_main_loop = get_absolute_value(main_loop, 0xAFD);
 139: 	ff7_set_main_loop(MODE_SUBMARINE, submarine_main_loop);
 140: 	snowboard_main_loop = get_absolute_value(main_loop, 0xB3E);
 141: 	ff7_set_main_loop(MODE_SNOWBOARD, snowboard_main_loop);
 142: 
 143: 	ff7_externals.reset_game_obj_sub_5F4971 = (void (*)(struct game_obj*))get_relative_call(condor_main_loop, 0x5B);
 144: 	ff7_externals.engine_exit_game_mode_sub_666C78 = get_relative_call(common_externals.winmain, 0x217);
 145: 	ff7_externals.sub_666C13 = (void* (*)(struct game_obj*))get_relative_call(ff7_externals.engine_exit_game_mode_sub_666C78, 0x35);
 146: 	ff7_externals.sub_670F9B = (void* (*)(void*))get_relative_call(ff7_externals.engine_exit_game_mode_sub_666C78, 0x47);
 147: 	ff7_externals.byte_CC0D89 = (BYTE*)get_absolute_value(main_loop, 0x71E);
 148: 	ff7_externals.word_CC0828 = (WORD*)get_absolute_value(main_init_loop, 0x4A5);
 149: 
 150: 	ff7_externals.destroy_field_bk = get_relative_call(field_main_loop, 0x222);
 151: 	ff7_externals.destroy_field_tiles = get_relative_call(ff7_externals.destroy_field_bk, 0x1E6);
 152: 	ff7_externals.field_layers = (field_layer **)get_absolute_value(ff7_externals.destroy_field_tiles, 0x46);
 153: 
 154: 	ff7_externals.num_field_entities = (WORD *)(((uint32_t)ff7_externals.field_layers) - 0xC);
 155: 	ff7_externals.field_objects = (field_object **)(((uint32_t)ff7_externals.field_layers) - 0x10);
 156: 
 157: 	ff7_externals.field_id = (WORD *)get_absolute_value(field_main_loop, 0x326);
 158: 
 159: 	ff7_externals.open_field_file = get_relative_call(field_main_loop, 0x331);
 160: 	ff7_externals.field_file_name = (char *)get_absolute_value(ff7_externals.open_field_file, 0x77);
 161: 	ff7_externals.read_field_file = get_relative_call(ff7_externals.open_field_file, 0xCF);
 162: 
 163: 	ff7_externals.battle_enter = get_absolute_value(main_loop, 0x8A1);
 164: 	ff7_externals.battle_loop = get_relative_call(battle_main_loop, 0x1C8);
 165: 	ff7_externals.battle_mode = (DWORD*)get_absolute_value(ff7_externals.battle_loop, 0x18);
 166: 	ff7_externals.battle_sub_429AC0 = get_absolute_value(ff7_externals.battle_loop, 0x79);
 167: 	ff7_externals.battle_sub_42D808 = get_relative_call(ff7_externals.battle_sub_429AC0, 0xE7);
 168: 	ff7_externals.battle_sub_42D992 = get_relative_call(ff7_externals.battle_sub_42D808, 0x30);
 169: 	ff7_externals.battle_sub_42DAE5 = get_relative_call(ff7_externals.battle_sub_42D992, 0x7E);
 170: 	ff7_externals.battle_fight_end = get_relative_call(ff7_externals.battle_sub_42D992, 0xB7);
 171: 	ff7_externals.battle_fanfare_music = get_relative_call(ff7_externals.battle_fight_end, 0x25);
 172: 	ff7_externals.battle_sub_427C22 = get_relative_call(ff7_externals.battle_sub_42DAE5, 0xF);
 173: 	ff7_externals.battle_menu_update_6CE8B3 = get_relative_call(battle_main_loop, 0x368);
 174: 	ff7_externals.battle_sub_6DB0EE = get_relative_call(ff7_externals.battle_menu_update_6CE8B3, 0xD9);
 175: 	ff7_externals.is_battle_paused = (char*)get_absolute_value(ff7_externals.battle_menu_update_6CE8B3, 0xC3);
 176: 	ff7_externals.battle_actor_data = (battle_actor_data*)get_absolute_value(ff7_externals.battle_sub_6DB0EE, 0x276);
 177: 	ff7_externals.battle_menu_state_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_6DB0EE, 0x1B4), 64);
 178: 	ff7_externals.magic_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0xBF), 54);
 179: 	ff7_externals.battle_b3ddata_sub_428B12 = get_relative_call(ff7_externals.battle_sub_429AC0, 0x71);
 180: 	ff7_externals.graphics_render_sub_68A638 = get_relative_call(ff7_externals.battle_b3ddata_sub_428B12, 0x10A);
 181: 	ff7_externals.create_dx_sfx_something = get_relative_call(ff7_externals.graphics_render_sub_68A638, 0xD3);
 182: 	ff7_externals.load_p_file = get_relative_call(ff7_externals.create_dx_sfx_something, 0x144);
 183: 
 184: 	ff7_externals.comet2_sub_5A42E5 = get_relative_call(ff7_externals.magic_effects_fn_table[46], 0x1A);
 185: 	ff7_externals.comet2_unload_sub_5A4359 = get_absolute_value(ff7_externals.comet2_sub_5A42E5, 0x34);
 186: 
 187: 	ff7_externals.create_polygon_data = (polygon_data* (*)(uint32_t, uint32_t))get_relative_call(ff7_externals.load_p_file, 0x17);
 188: 	ff7_externals.create_polygon_lists = (void (*)(polygon_data*))get_relative_call(ff7_externals.load_p_file, 0x35B);
 189: 	ff7_externals.free_polygon_data = (void (*)(polygon_data*))get_relative_call(ff7_externals.load_p_file, 0x3C4);
 190: 
 191: 	common_externals.open_file = get_relative_call(ff7_externals.load_p_file, 0x3A);
 192: 
 193: 	file_module = common_externals.open_file - 0xE2;
 194: 	common_externals.close_file = file_module + 0xA1;
 195: 	common_externals.read_file = file_module + 0x611;
 196: 	common_externals.__read_file = file_module + 0x6A7;
 197: 	common_externals.write_file = file_module + 0x735;
 198: 	common_externals.alloc_read_file = (void* (*)(uint32_t, uint32_t, struct file*))(file_module + 0x830);
 199: 	common_externals.get_filesize = file_module + 0x84B;
 200: 	common_externals.tell_file = file_module + 0x8A1;
 201: 	common_externals.seek_file = file_module + 0x90A;
 202: 	common_externals.alloc_get_file = (void* (*)(file_context*, uint32_t*, char*))(file_module + 0xA0E);
 203: 
 204: 	common_externals.destroy_tex = (void (*)(tex_header*))get_relative_call(common_externals.load_tex_file, 0x16D);
 205: 	common_externals.destroy_tex_header = get_relative_call((uint32_t)common_externals.destroy_tex, 0x78);
 206: 
 207: 	ff7_externals.play_battle_music_call = main_loop + 0x300;
 208: 	ff7_externals.play_battle_end_music = (uint32_t(*)())get_relative_call(ff7_externals.battle_fanfare_music, 0x21);
 209: 	ff7_externals.play_battle_music_win_call = ff7_externals.battle_fanfare_music + 0x21;
 210: 	ff7_externals.battle_sub_42A0E7 = get_relative_call(ff7_externals.battle_sub_429AC0, 0xA4);
 211: 	ff7_externals.load_battle_stage = get_relative_call(ff7_externals.battle_sub_42A0E7, 0x78);
 212: 	ff7_externals.load_battle_stage_pc = get_relative_call(ff7_externals.load_battle_stage, 0x151);
 213: 	ff7_externals.read_battle_hrc = get_relative_call(ff7_externals.load_battle_stage_pc, 0x25);
 214: 
 215: 	ff7_externals.battle_location_id = (WORD*)get_absolute_value(ff7_externals.battle_sub_42A0E7, 0x5F);
 216: 
 217: 	ff7_externals.battle_regular_chdir = (void (*)(battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0x16);
 218: 	ff7_externals.battle_context_chdir = (void (*)(file_context*, battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0x2B);
 219: 	ff7_externals.swap_extension = (void (*)(char*, char*, char*))get_relative_call(ff7_externals.read_battle_hrc, 0x43);
 220: 	ff7_externals.destroy_battle_hrc = (void (*)(uint32_t, battle_hrc_header*))get_relative_call(ff7_externals.read_battle_hrc, 0xB3);
 221: 	ff7_externals.battle_regular_olddir = (void (*)(battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0xD2);
 222: 	ff7_externals.battle_context_olddir = (void (*)(file_context*, battle_chdir_struc*))get_relative_call(ff7_externals.read_battle_hrc, 0xE7);
 223: 
 224: 	ff7_externals.field_sub_60DCED = get_relative_call(field_main_loop, 0x37A);
 225: 	ff7_externals.field_load_models = get_relative_call(ff7_externals.field_sub_60DCED, 0x168);
 226: 	ff7_externals.field_models_eye_to_model = get_relative_call(ff7_externals.field_load_models, 0xA79);
 227: 	ff7_externals.field_load_animation = get_relative_call(ff7_externals.field_load_models, 0x8DF);
 228: 	ff7_externals.field_load_model_eye_tex = (int (*)(ff7_model_eye_texture_data*,field_animation_data*))get_relative_call(ff7_externals.field_load_models, 0xB90);
 229: 	ff7_externals.field_load_model_tex = (p_hundred* (*)(int, int, char*, struc_3*, game_obj*))get_relative_call((uint32_t)ff7_externals.field_load_model_eye_tex, 0x9D);
 230: 	ff7_externals.field_unload_model_tex = (void (*)(void*))get_relative_call((uint32_t)ff7_externals.field_load_model_eye_tex, 0x1DE);
 231: 	ff7_externals.create_struc_3_info_sub_67455E = (void (*)(struc_3*))get_relative_call((uint32_t)ff7_externals.field_load_model_eye_tex, 0x12);
 232: 	ff7_externals.load_animation = get_relative_call(ff7_externals.field_load_animation, 0x16D);
 233: 	ff7_externals.destroy_animation = (void (*)(anim_header*))get_relative_call(ff7_externals.load_animation, 0x162);
 234: 	ff7_externals.field_unk_909288 = (uint32_t*)get_absolute_value((uint32_t)ff7_externals.field_load_model_eye_tex, 0x1D);
 235: 
 236: 	ff7_externals.field_models_eye_blink_buffer = (ff7_model_eye_texture_data*)get_absolute_value(ff7_externals.field_load_models, 0xB8C);
 237: 	ff7_externals.field_models_data = (DWORD*)get_absolute_value(ff7_externals.field_load_models, 0xE);
 238: 
 239: 	ff7_externals.load_lgp = get_relative_call(main_loop, 0x450);
 240: 	ff7_externals.open_lgp_file = get_relative_call(ff7_externals.load_lgp, 0x1C);
 241: 	ff7_externals.__read = get_relative_call(common_externals.read_file, 0x4A);
 242: 
 243: 	ff7_externals.lgp_open_file = get_relative_call((uint32_t)common_externals.open_file, 0x234);
 244: 	ff7_externals.lgp_seek_file = get_relative_call((uint32_t)common_externals.open_file, 0x265);
 245: 	ff7_externals.lgp_read = get_relative_call((uint32_t)common_externals.read_file, 0x2E);
 246: 	ff7_externals.lgp_get_filesize = get_relative_call((uint32_t)ff7_externals.read_field_file, 0x71);
 247: 	ff7_externals.lgp_read_file = get_relative_call((uint32_t)ff7_externals.read_field_file, 0xDD);
 248: 
 249: 	ff7_externals.lzss_decode = (int (*)(char*, char*))get_relative_call((uint32_t)ff7_externals.read_field_file, 0xF2);
 250: 	ff7_externals.field_file_buffer = (char**)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0xB2);
 251: 	ff7_externals.field_file_section_ptrs = (DWORD*)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0x187);
 252: 	ff7_externals.known_field_buffer_size = (uint32_t*)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0xA4);
 253: 	ff7_externals.field_resuming_from_battle_CFF268 = (uint32_t*)get_absolute_value((uint32_t)ff7_externals.read_field_file, 0xB);
 254: 
 255: 	ff7_externals.lgp_fds = (FILE **)get_absolute_value(ff7_externals.lgp_seek_file, 0x17);
 256: 
 257: 	ff7_externals.context_chdir = get_relative_call((uint32_t)ff7_externals.battle_context_chdir, 0x3C);
 258: 	ff7_externals.lgp_chdir = get_relative_call(ff7_externals.context_chdir, 0x2A);
 259: 
 260: 	ff7_externals.lgp_lookup_tables = (lookup_table_entry **)get_absolute_value(ff7_externals.lgp_open_file, 0x194);
 261: 	ff7_externals.lgp_tocs = (lgp_toc_entry **)get_absolute_value(ff7_externals.lgp_open_file, 0x233);
 262: 	ff7_externals.lgp_folders = (lgp_folders *)get_absolute_value(ff7_externals.lgp_open_file, 0x42C);
 263: 
 264: 	ff7_externals.battle_sub_437DB0 = get_absolute_value(ff7_externals.battle_loop, 0x8D);
 265: 	ff7_externals.sub_5CB2CC = get_relative_call(ff7_externals.battle_sub_437DB0, 0x43);
 266: 	ff7_externals.battle_formation_id = (WORD*)get_absolute_value(ff7_externals.battle_sub_437DB0, 0x1FD);
 267: 	ff7_externals.battle_scene_bin_sub_5D1050 = get_relative_call(ff7_externals.battle_sub_437DB0, 0x15D);
 268: 	ff7_externals.engine_load_bin_file_sub_419210 = (int (*)(char *filename, int offset, int size, char **out_buffer, void (*callback)(void)))(get_relative_call(ff7_externals.battle_scene_bin_sub_5D1050, 0x85));
 269: 
 270: 	ff7_externals.play_midi = (void (*)(uint32_t))common_externals.play_midi;
 271: 	common_externals.master_midi_volume = (DWORD *)get_absolute_value(common_externals.set_master_midi_volume, 0x46);
 272: 	ff7_externals.midi_volume_control = (uint32_t *)get_absolute_value(common_externals.midi_init, 0x706);
 273: 	ff7_externals.midi_initialized = (uint32_t *)get_absolute_value(common_externals.midi_init, 0x3A);
 274: 
 275: 	ff7_externals.menu_sub_6CDA83 = get_relative_call(menu_main_loop, 0x112);
 276: 	ff7_externals.menu_sub_6CBD43 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0xAF);
 277: 	ff7_externals.menu_sub_701EE4 = get_relative_call(ff7_externals.menu_sub_6CBD43, 0x7);
 278: 	ff7_externals.phs_menu_sub = get_relative_call(ff7_externals.menu_sub_701EE4, 0xE3);
 279: 	ff7_externals.menu_battle_end_sub_6C9543 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0x20);
 280: 
 281: 	switch(version)
 282: 	{
 283: 		case VERSION_FF7_102_US:
 284: 			ff7_externals.menu_draw_party_member_stats = get_relative_call(ff7_externals.phs_menu_sub, 0x8FF);
 285: 			break;
 286: 		default:
 287: 			ff7_externals.menu_draw_party_member_stats = get_relative_call(ff7_externals.phs_menu_sub, 0x8F5);
 288: 			break;
 289: 	}
 290: 
 291: 	ff7_externals.party_member_to_char_map = (uint32_t *)get_absolute_value(ff7_externals.menu_draw_party_member_stats, 0x14);
 292: 
 293: 	ff7_externals.menu_start = get_absolute_value(main_loop, 0x627);
 294: 	ff7_externals.menu_sub_6CB56A = get_relative_call(ff7_externals.menu_sub_6CDA83, 0xDE);
 295: 	ff7_externals.menu_subs_call_table = (uint32_t *)get_absolute_value(ff7_externals.menu_sub_6CB56A, 0x2EC);
 296: 	ff7_externals.menu_tutorial_sub_6C49FD = (int (*)())get_relative_call(ff7_externals.menu_sub_6CB56A, 0x2B7);
 297: 	ff7_externals.timer_menu_sub = ff7_externals.menu_subs_call_table[0];
 298: 	ff7_externals.status_menu_sub = ff7_externals.menu_subs_call_table[5];
 299: 	ff7_externals.config_menu_sub = ff7_externals.menu_subs_call_table[8];
 300: 	ff7_externals.menu_sub_6FEDB0 = ff7_externals.menu_subs_call_table[10];
 301: 
 302: 	ff7_externals.config_initialize = get_relative_call(main_init_loop, 0x4B0);
 303: 
 304: 	ff7_externals.menu_tutorial_window_state = (BYTE*)get_absolute_value((uint32_t)ff7_externals.menu_tutorial_sub_6C49FD, 0x9);
 305: 	ff7_externals.menu_tutorial_window_text_ptr = (DWORD*)get_absolute_value((uint32_t)ff7_externals.menu_tutorial_sub_6C49FD, 0x18);
 306: 
 307: 	switch(version)
 308: 	{
 309: 		case VERSION_FF7_102_US:
 310: 			ff7_externals.write_save_file = (BOOL (*)(char))(get_relative_call(ff7_externals.menu_sub_6FEDB0, 0x1096));
 311: 			break;
 312: 		case VERSION_FF7_102_DE:
 313: 		case VERSION_FF7_102_FR:
 314: 			ff7_externals.write_save_file = (BOOL (*)(char))(get_relative_call(ff7_externals.menu_sub_6FEDB0, 0x10B2));
 315: 			break;
 316: 		case VERSION_FF7_102_SP:
 317: 			ff7_externals.write_save_file = (BOOL (*)(char))(get_relative_call(ff7_externals.menu_sub_6FEDB0, 0x10FE));
 318: 			break;
 319: 	}
 320: 
 321: 	ff7_externals.millisecond_counter = (DWORD *)get_absolute_value(ff7_externals.timer_menu_sub, 0xD06);
 322: 	ff7_externals.draw_status_limit_level_stats = get_relative_call(ff7_externals.status_menu_sub, 0x8E);
 323: 
 324: 	ff7_externals.menu_sub_6F5C0C = (void *(*)(uint32_t, uint32_t, uint8_t, uint8_t, uint32_t))(get_relative_call(ff7_externals.timer_menu_sub, 0x72F));
 325: 	ff7_externals.menu_sub_6FAC38 = (void *(*)(uint32_t, uint32_t, uint8_t, uint8_t, uint32_t))(get_relative_call(ff7_externals.timer_menu_sub, 0xD77));
 326: 
 327: 	ff7_externals.get_kernel_text = (char* (*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.draw_status_limit_level_stats, 0x10C);
 328: 
 329: 	ff7_externals.sub_5CF282 = get_relative_call(ff7_externals.sub_5CB2CC, 0x4E);
 330: 	ff7_externals.get_equipment_stats = get_relative_call(ff7_externals.sub_5CF282, 0x2F0);
 331: 
 332: 	ff7_externals.weapon_data_array = (weapon_data *)(get_absolute_value(ff7_externals.get_equipment_stats, 0x50) - 4);
 333: 	ff7_externals.armor_data_array = (armor_data *)(get_absolute_value(ff7_externals.get_equipment_stats, 0x78) - 2);
 334: 
 335: 	ff7_externals.field_sub_6388EE = get_relative_call(field_main_loop, 0xFF);
 336: 	ff7_externals.field_draw_everything = get_relative_call(ff7_externals.field_sub_6388EE, 0x11);
 337: 	ff7_externals.field_draw_pointer_hand_60D4F3 = get_relative_call(ff7_externals.field_draw_everything, 0x1A9);
 338: 	ff7_externals.field_submit_draw_pointer_hand_60D572 = get_relative_call(ff7_externals.field_draw_pointer_hand_60D4F3, 0x4F);
 339: 	ff7_externals.field_pick_tiles_make_vertices = get_relative_call(ff7_externals.field_draw_everything, 0xC9);
 340: 	ff7_externals.field_layer1_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x2D);
 341: 	ff7_externals.field_layer1_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer1_pick_tiles, 0x8B);
 342: 	ff7_externals.field_layer1_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer1_pick_tiles, 0xA2);
 343: 	ff7_externals.field_layer1_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer1_pick_tiles, 0xBF);
 344: 	ff7_externals.field_layer2_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x48);
 345: 	ff7_externals.field_layer2_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0x8C);
 346: 	ff7_externals.field_layer2_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0xA3);
 347: 	ff7_externals.field_layer2_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0xC0);
 348: 	ff7_externals.field_layer3_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x12);
 349: 	ff7_externals.field_layer3_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0xAB);
 350: 	ff7_externals.field_layer3_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0xC1);
 351: 	ff7_externals.field_layer3_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0xDD);
 352: 	ff7_externals.do_draw_layer3_CFFE3C = (int*)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x9);
 353: 	ff7_externals.field_layer3_flag_CFFE40 = (int*)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x3B1);
 354: 	ff7_externals.field_layer4_pick_tiles = get_relative_call(ff7_externals.field_pick_tiles_make_vertices, 0x5F);
 355: 	ff7_externals.field_layer4_tiles_num = (uint32_t *)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x90);
 356: 	ff7_externals.field_layer4_palette_sort = (uint32_t **)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0xA6);
 357: 	ff7_externals.field_layer4_tiles = (field_tile **)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0xC2);
 358: 	ff7_externals.do_draw_layer4_CFFEA4 = (int*)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x9);
 359: 	ff7_externals.field_layer4_flag_CFFEA8 = (int*)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x3F3);
 360: 	ff7_externals.field_layer_sub_623C0F = (double(*)(rotation_matrix*, int, int, int))get_relative_call(ff7_externals.field_layer3_pick_tiles, 0x7E);
 361: 	ff7_externals.field_layer_CFF1D8 = (int *)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x264);
 362: 	ff7_externals.field_palette_D00088 = (uint16_t *)get_absolute_value(ff7_externals.field_layer4_pick_tiles, 0x28A);
 363: 	ff7_externals.field_special_y_offset = (uint32_t *)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0x43);
 364: 	ff7_externals.field_bg_multiplier = (uint32_t *)get_absolute_value(ff7_externals.field_layer2_pick_tiles, 0x23);
 365: 	ff7_externals.add_page_tile = (void (*)(float, float, float, float, float, uint32_t, uint32_t))get_relative_call(ff7_externals.field_layer2_pick_tiles, 0x327);
 366: 	ff7_externals.field_triggers_header = (field_trigger_header**)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x134);
 367: 	ff7_externals.field_camera_rotation_matrix_CFF3D8 = (rotation_matrix*)get_absolute_value(ff7_externals.field_layer3_pick_tiles, 0x7A);
 368: 	ff7_externals.field_draw_gray_quads_644E90 = (void(*)())get_relative_call(ff7_externals.field_draw_everything, 0x360);
 369: 	ff7_externals.engine_draw_graphics_object = (void(*)(ff7_graphics_object*, ff7_game_obj*))get_relative_call(ff7_externals.field_draw_everything, 0x1D2);
 370: 
 371: 	ff7_externals.field_load_textures = get_relative_call(ff7_externals.field_sub_60DCED, 0x107);
 372: 	ff7_externals.field_convert_type2_layers = (void (*)())get_relative_call(ff7_externals.field_load_textures, 0xD);
 373: 	ff7_externals.make_struc3 = (void (*)(uint32_t, struc_3*))get_relative_call(ff7_externals.field_load_textures, 0xAC);
 374: 	ff7_externals.make_field_tex_header_pal = (void (*)(ff7_tex_header*))get_relative_call(ff7_externals.field_load_textures, 0x21F);
 375: 	ff7_externals.make_field_tex_header = (void (*)(ff7_tex_header*))get_relative_call(ff7_externals.field_load_textures, 0x23C);
 376: 	ff7_externals._load_texture = (ff7_graphics_object* (*)(uint32_t, uint32_t, struc_3*, char*, void*))get_relative_call(ff7_externals.field_load_textures, 0x2F8);
 377: 
 378: 	ff7_externals.read_field_background_data = get_relative_call(ff7_externals.field_sub_60DCED, 0x8B);
 379: 	ff7_externals.layer2_end_page = (WORD *)get_absolute_value(ff7_externals.read_field_background_data, 0x788);
 380: 
 381: 	ff7_externals.create_d3d2_indexed_primitive = get_relative_call((uint32_t)common_externals.generic_load_group, 0x22);
 382: 	ff7_externals.destroy_d3d2_indexed_primitive = get_relative_call(ff7_externals.create_d3d2_indexed_primitive, 0x290);
 383: 
 384: 	ff7_externals.enter_main = get_absolute_value(ff7_externals.world_loop_74BE49, 0x2AE);
 385: 
 386: 	ff7_externals.kernel_init = get_relative_call(ff7_externals.enter_main, 0xF1);
 387: 	ff7_externals.kernel_load_kernel2 = (void (*)(char*))get_relative_call(ff7_externals.kernel_init, 0x1FD);
 388: 	ff7_externals.kernel2_reset_counters = get_relative_call((uint32_t)ff7_externals.kernel_load_kernel2, 0x33);
 389: 
 390: 	ff7_externals.sub_4012DA = get_absolute_value(ff7_externals.kernel_init, 0x136);
 391: 	ff7_externals.kernel2_add_section = get_relative_call(ff7_externals.sub_4012DA, 0x4D);
 392: 	ff7_externals.kernel2_get_text = get_relative_call((uint32_t)ff7_externals.get_kernel_text, 0xF7);
 393: 	ff7_externals.kernel_1to9_sections = (char**)get_absolute_value(ff7_externals.sub_4012DA, 0x6F);
 394: 
 395: 	ff7_externals.draw_3d_model = get_relative_call(ff7_externals.field_draw_everything, 0x17F);
 396: 	ff7_externals.stack_push = (void (*)(struct stack*))get_relative_call(ff7_externals.draw_3d_model, 0x8E);
 397: 	ff7_externals.stack_top = (void* (*)(struct stack*))get_relative_call(ff7_externals.draw_3d_model, 0x9A);
 398: 	ff7_externals.stack_pop = (void (*)(struct stack*))get_relative_call(ff7_externals.draw_3d_model, 0x8FD);
 399: 	ff7_externals._root_animation = (void (*)(matrix*, anim_frame*, anim_header*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xD4);
 400: 	ff7_externals._frame_animation = (void (*)(uint32_t, matrix*, vector3<float>*, anim_frame*, anim_header*, hrc_bone*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xDB);
 401: 	ff7_externals.root_animation = (void (*)(matrix*, anim_frame*, anim_header*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xE7);
 402: 	ff7_externals.frame_animation = (void (*)(uint32_t, matrix*, vector3<float>*, anim_frame*, anim_header*, hrc_bone*, hrc_data*))get_absolute_value(ff7_externals.draw_3d_model, 0xEE);
 403: 	ff7_externals.model_mode = (uint32_t *)get_absolute_value(ff7_externals.draw_3d_model, 0x2A7);
 404: 
 405: 	ff7_externals.name_menu_sub_6CBD32 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0x9A);
 406: 	ff7_externals.name_menu_sub_719C08 = get_relative_call(ff7_externals.name_menu_sub_6CBD32, 0x7);
 407: 
 408: 	switch(version)
 409: 	{
 410: 		case VERSION_FF7_102_FR:
 411: 			ff7_externals.menu_sub_71894B = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x2B);
 412: 			ff7_externals.menu_sub_718DBE = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x77);
 413: 			ff7_externals.menu_sub_719B81 = get_relative_call(ff7_externals.name_menu_sub_719C08, 0xCC);
 414: 
 415: 			ff7_externals.set_default_input_settings_save = get_relative_call(ff7_externals.menu_sub_71894B, 0x189);
 416: 			break;
 417: 		default:
 418: 			ff7_externals.menu_sub_71894B = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x2A);
 419: 			ff7_externals.menu_sub_718DBE = get_relative_call(ff7_externals.name_menu_sub_719C08, 0x76);
 420: 			ff7_externals.menu_sub_719B81 = get_relative_call(ff7_externals.name_menu_sub_719C08, 0xCB);
 421: 
 422: 			ff7_externals.set_default_input_settings_save = get_relative_call(ff7_externals.menu_sub_71894B, 0x188);
 423: 			break;
 424: 	}
 425: 
 426: 	ff7_externals.keyboard_name_input = get_relative_call(ff7_externals.menu_sub_718DBE, 0x99);
 427:  	ff7_externals.restore_input_settings = get_relative_call(ff7_externals.menu_sub_719B81, 0x80);
 428: 
 429: 	ff7_externals.dinput_getdata2 = get_relative_call(ff7_externals.keyboard_name_input, 0x1C);
 430: 	common_externals.get_keyboard_state = get_relative_call(ff7_externals.keyboard_name_input, 0x6);
 431: 
 432: 	ff7_externals.init_game = get_absolute_value(ff7_externals.init_stuff, 0x336);
 433: 	ff7_externals.sub_41A1B0 = get_relative_call(ff7_externals.init_game, 0x85);
 434: 	ff7_externals.init_directinput = get_relative_call(ff7_externals.sub_41A1B0, 0x34);
 435: 	ff7_externals.dinput_createdevice_mouse = get_relative_call(ff7_externals.init_directinput, 0x48);
 436: 
 437: 	common_externals.dinput_acquire_keyboard = (int (*)())get_relative_call(common_externals.get_keyboard_state, 0x4F);
 438: 	common_externals.keyboard_device = (IDirectInputDeviceA**)get_absolute_value(common_externals.get_keyboard_state, 0x06);
 439: 	common_externals.keyboard_connected = (uint32_t*)get_absolute_value(common_externals.get_keyboard_state, 0x47);
 440: 
 441: 	ff7_externals.sub_69C69F = (void (*)(matrix*, ff7_light*))get_relative_call(ff7_externals.draw_3d_model, 0x882);
 442: 
 443: 	ff7_externals.coaster_sub_5E9051 = get_relative_call(coaster_main_loop, 0xC6);
 444: 	ff7_externals.coaster_sub_5EE150 = get_relative_call(ff7_externals.coaster_sub_5E9051, 0x3);
 445: 
 446: 	ff7_externals.cleanup_game = get_absolute_value(ff7_externals.init_stuff, 0x350);
 447: 	common_externals.midi_cleanup = get_relative_call(ff7_externals.cleanup_game, 0x72);
 448: 
 449: 	ff7_externals.sub_60DF96 = get_relative_call(ff7_externals.init_game, 0x42B);
 450: 	ff7_externals.sub_60EEB2 = get_relative_call(ff7_externals.sub_60DF96, 0x26);
 451: 	ff7_externals.open_flevel_siz = get_relative_call(ff7_externals.sub_60EEB2, 0x79F);
 452: 	ff7_externals.field_map_infos = get_absolute_value(ff7_externals.open_flevel_siz, 0xAF) - 0xBC;
 453: 
 454: 	common_externals.sfx_init = get_relative_call(main_init_loop, 0xC3);
 455: 	ff7_externals.sfx_initialized = (uint32_t*)get_absolute_value(common_externals.sfx_init, 0x21);
 456: 	common_externals.sfx_release = get_relative_call(common_externals.sfx_init, 0x1FC);
 457: 	common_externals.sfx_cleanup = get_relative_call(main_cleanup_loop, 0x64);
 458: 	common_externals.sfx_load = get_relative_call(main_init_loop, 0xE3);
 459: 	common_externals.sfx_unload = get_relative_call(main_cleanup_loop, 0x5C);
 460: 	ff7_externals.sound_operation = get_relative_call(ff7_externals.enter_main, 0xE4);
 461: 	common_externals.sfx_pause = get_relative_call(ff7_externals.sound_operation, 0x6E3);
 462: 	common_externals.sfx_resume = get_relative_call(ff7_externals.sound_operation, 0x6F1);
 463: 	common_externals.sfx_stop = get_relative_call(ff7_externals.sound_operation, 0x290);
 464: 	common_externals.play_sfx_on_channel = get_relative_call(ff7_externals.sound_operation, 0x2AB);
 465: 	common_externals.set_sfx_volume_on_channel = (uint32_t(*)(uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x3B3);
 466: 	common_externals.set_sfx_volume_trans_on_channel = (uint32_t(*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x437);
 467: 	common_externals.set_sfx_panning_on_channel = (uint32_t(*)(uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x4C7);
 468: 	common_externals.set_sfx_panning_trans_on_channel = (uint32_t(*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x54B);
 469: 	common_externals.set_sfx_frequency_on_channel = (uint32_t(*)(uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x5DB);
 470: 	common_externals.set_sfx_frequency_trans_on_channel = (uint32_t(*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x65F);
 471: 	common_externals.dsound_volume_table = (uint32_t*)get_absolute_value(uint32_t(common_externals.set_sfx_volume_on_channel), 0xCC);
 472: 	common_externals.play_sfx = (uint32_t(*)(uint32_t))get_relative_call(ff7_externals.sound_operation, 0x703);
 473: 	common_externals.play_sfx_effects = (uint32_t(*)(byte, uint32_t, uint32_t, uint32_t, uint32_t))get_relative_call(ff7_externals.sound_operation, 0x327);
 474: 	ff7_externals.sfx_play_effects_id_channel_6 = (DWORD *)get_absolute_value((uint32_t)common_externals.play_sfx_effects, 0x119);
 475: 	ff7_externals.sound_states = (ff7_field_sfx_state*)get_absolute_value(common_externals.play_sfx_on_channel, 0x28);
 476: 	common_externals.master_sfx_volume = (uint32_t*)get_absolute_value(common_externals.play_sfx_on_channel, 0x342);
 477: 	ff7_externals.sfx_fmt_header = (ff7_audio_fmt*)get_absolute_value(common_externals.sfx_load, 0x51);
 478: 
 479: 	common_externals.directsound_create = get_relative_call(common_externals.sfx_init, 0x11C);
 480: 	common_externals.directsound = (LPLPDIRECTSOUND)get_absolute_value(common_externals.directsound_create, 0x15);
 481: 	common_externals.directsound_createsoundbuffer = get_relative_call(common_externals.sfx_init, 0x16C);
 482: 	common_externals.directsound_release = get_relative_call(common_externals.sfx_init, 0x182);
 483: 
 484: 	ff7_externals.battle_clear_sound_flags = get_relative_call(ff7_externals.battle_sub_429AC0, 0x6C);
 485: 	ff7_externals.swirl_sound_effect = get_relative_call(swirl_main_loop, 0x8B);
 486: 	ff7_externals.sfx_load_and_play_with_speed = get_relative_call(ff7_externals.swirl_sound_effect, 0x3E);
 487: 
 488: 	ff7_externals.field_initialize_variables = get_relative_call(ff7_externals.field_sub_60DCED, 0x178);
 489: 	ff7_externals.music_lock_clear_fix = ff7_externals.field_initialize_variables + 0x2B8;
 490: 	ff7_externals.field_init_player_character_variables = get_relative_call(ff7_externals.field_initialize_variables, 0x31B);
 491: 	ff7_externals.field_init_event_wrapper_63BCA7 = get_relative_call(ff7_externals.field_initialize_variables, 0x29D);
 492: 	ff7_externals.field_init_event_60BACF = get_relative_call(ff7_externals.field_init_event_wrapper_63BCA7, 0x8);
 493: 	ff7_externals.field_init_field_objects_60BCFA = get_relative_call(ff7_externals.field_init_event_60BACF, 0x39);
 494: 	ff7_externals.execute_opcode = get_relative_call(ff7_externals.field_init_event_60BACF, 0x80);
 495: 	ff7_externals.modules_global_object = (ff7_modules_global_object*)get_absolute_value(ff7_externals.field_init_event_60BACF, 0x20);
 496: 	ff7_externals.field_global_object_ptr = (ff7_modules_global_object**)get_absolute_value(ff7_externals.field_init_event_60BACF, 0x1C);
 497: 
 498: 	common_externals.execute_opcode_table = (uint32_t*)get_absolute_value(ff7_externals.execute_opcode, 0x10D);
 499: 	ff7_externals.opcode_tutor = common_externals.execute_opcode_table[0x21];
 500: 	ff7_externals.opcode_goldu = common_externals.execute_opcode_table[0x39];
 501: 	ff7_externals.opcode_dlitm = common_externals.execute_opcode_table[0x59];
 502: 	ff7_externals.opcode_smtra = common_externals.execute_opcode_table[0x5B];
 503: 	ff7_externals.opcode_akao2 = common_externals.execute_opcode_table[0xDA];
 504: 	ff7_externals.opcode_akao = common_externals.execute_opcode_table[0xF2];
 505: 	ff7_externals.opcode_bmusc = common_externals.execute_opcode_table[0xF6];
 506: 	ff7_externals.opcode_fmusc = common_externals.execute_opcode_table[0xFC];
 507: 	ff7_externals.opcode_cmusc = common_externals.execute_opcode_table[0xFD];
 508: 	ff7_externals.opcode_gameover = common_externals.execute_opcode_table[0xFF];
 509: 	ff7_externals.opcode_message = common_externals.execute_opcode_table[0x40];
 510: 	ff7_externals.opcode_ask = common_externals.execute_opcode_table[0x48];
 511: 	ff7_externals.opcode_canm1_canm2 = common_externals.execute_opcode_table[0xB1];
 512: 	ff7_externals.opcode_wmode = common_externals.execute_opcode_table[0x52];
 513: 	ff7_externals.opcode_fade = common_externals.execute_opcode_table[0x6B];
 514: 	ff7_externals.opcode_shake = common_externals.execute_opcode_table[0x5E];
 515: 	ff7_externals.opcode_setbyte = common_externals.execute_opcode_table[0x80];
 516: 	ff7_externals.opcode_biton = common_externals.execute_opcode_table[0x82];
 517: 	ff7_externals.opcode_pc = common_externals.execute_opcode_table[0xA0];
 518: 	ff7_externals.opcode_kawai = common_externals.execute_opcode_table[0x28];
 519: 
 520: 	ff7_externals.field_opcode_08_sub_61D0D4 = get_relative_call(common_externals.execute_opcode_table[0x08], 0x5A);
 521: 	ff7_externals.field_opcode_08_09_set_rotation_61DB2C = (void(*)(short, byte, byte))get_relative_call(ff7_externals.field_opcode_08_sub_61D0D4, 0x196);
 522: 	ff7_externals.field_opcode_AA_2A_sub_616476 = get_relative_call(common_externals.execute_opcode_table[0xAA], 0x26);
 523: 	ff7_externals.field_opcode_turn_character_sub_616CB5 = get_relative_call(common_externals.execute_opcode_table[0xAB], 0x28);
 524: 	ff7_externals.field_get_rotation_final_636515 = (int(*)(vector3<int>*, vector3<int>*, int*))get_relative_call(ff7_externals.field_opcode_turn_character_sub_616CB5, 0x34F);
 525: 
 526: 	ff7_externals.field_event_data_ptr = (field_event_data**)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0xC1);
 527: 	ff7_externals.field_animation_data_ptr = (field_animation_data**)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0x199);
 528: 	ff7_externals.field_model_id_array = (byte*)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0x12);
 529: 	ff7_externals.animation_type_array = (char*)get_absolute_value(ff7_externals.opcode_canm1_canm2, 0x5D);
 530: 	ff7_externals.word_DB958A = (WORD *)get_absolute_value(common_externals.execute_opcode_table[0x23], 0x5);
 531: 
 532: 	ff7_externals.field_opcode_message_update_loop_630D50 = get_relative_call(ff7_externals.opcode_message, 0x3B);
 533: 	ff7_externals.field_text_box_window_create_631586 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x39);
 534: 	ff7_externals.field_text_box_window_opening_6317A9 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x5A);
 535: 	ff7_externals.field_text_box_window_paging_631945 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x6D);
 536: 	ff7_externals.field_text_box_window_reverse_paging_632CAA = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x80);
 537: 	ff7_externals.field_text_box_window_closing_632EB8 = get_relative_call(ff7_externals.field_opcode_message_update_loop_630D50, 0x235);
 538: 	ff7_externals.opcode_message_loop_code = (WORD*)get_absolute_value(ff7_externals.field_opcode_message_update_loop_630D50, 0x12);
 539: 	ff7_externals.current_dialog_string_pointer = (DWORD*)get_absolute_value(ff7_externals.field_text_box_window_create_631586, 0x154);
 540: 	ff7_externals.current_dialog_message_speed = (WORD*)get_absolute_value(ff7_externals.field_text_box_window_create_631586, 0x1C1);
 541: 	ff7_externals.field_entity_id_list = (char*)get_absolute_value(ff7_externals.field_text_box_window_create_631586, 0x1F);
 542: 
 543: 	ff7_externals.field_opcode_ask_update_loop_6310A1 = (int (*)(uint8_t, uint8_t, uint8_t, uint8_t, WORD*))get_relative_call(ff7_externals.opcode_ask, 0x8E);
 544: 	ff7_externals.opcode_ask_question_code = (WORD*)get_absolute_value((uint32_t)ff7_externals.field_opcode_ask_update_loop_6310A1, 0x2FE);
 545: 
 546: 	ff7_externals.field_music_helper = get_relative_call(ff7_externals.opcode_cmusc, 0x5E);
 547: 	ff7_externals.field_music_id_to_midi_id = (uint32_t (*)(int16_t))get_relative_call(ff7_externals.field_music_helper, 0x3B);
 548: 	ff7_externals.field_music_id_to_midi_id_call1 = ff7_externals.field_music_helper + 0x3B;
 549: 	ff7_externals.field_music_id_to_midi_id_call2 = ff7_externals.opcode_bmusc + 0x37;
 550: 	ff7_externals.field_music_id_to_midi_id_call3 = ff7_externals.opcode_fmusc + 0x37;
 551: 
 552: 	switch(version)
 553: 	{
 554: 		case VERSION_FF7_102_DE:
 555: 			ff7_externals.field_music_helper_sound_op_call = ff7_externals.field_music_helper + 0x147;
 556: 			break;
 557: 		default:
 558: 			ff7_externals.field_music_helper_sound_op_call = ff7_externals.field_music_helper + 0x106;
 559: 			break;
 560: 	}
 561: 
 562: 	ff7_externals.enter_gameover = get_absolute_value(main_loop, 0x1F7);
 563: 	ff7_externals.exit_gameover = get_absolute_value(main_loop, 0x213);
 564: 	ff7_externals.start_gameover = (void* (*)())get_relative_call(ff7_externals.enter_gameover, 0xC6);
 565: 	ff7_externals.gameover_sub_6C12B1 = (void* (*)())get_relative_call(ff7_externals.exit_gameover, 0x21);
 566: 	ff7_externals.on_gameover_enter = ff7_externals.enter_gameover + 0xC6;
 567: 	ff7_externals.on_gameover_exit = ff7_externals.exit_gameover + 0x21;
 568: 
 569: 	ff7_externals.enter_field = get_absolute_value(main_loop, 0x90D);
 570: 	ff7_externals.field_init_viewport_values = get_relative_call(main_init_loop, 0x375);
 571: 	ff7_externals.field_loop_sub_63C17F = get_relative_call(field_main_loop, 0x59);
 572: 	ff7_externals.field_update_models_positions = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x5DD);
 573: 	ff7_externals.field_update_single_model_position = (int (*)(int16_t))get_relative_call(ff7_externals.field_update_models_positions, 0x8BC);
 574: 	ff7_externals.field_update_model_animation_frame = (void (*)(int16_t))get_relative_call(ff7_externals.field_update_models_positions, 0x68D);
 575: 	ff7_externals.field_check_collision_with_target = (int (*)(field_event_data*, short))get_relative_call(ff7_externals.field_update_models_positions, 0x9AA);
 576: 	ff7_externals.field_get_linear_interpolated_value = (int (*)(int, int, int, int))get_relative_call(ff7_externals.field_update_models_positions, 0x122);
 577: 	ff7_externals.field_get_smooth_interpolated_value = (int (*)(int, int, int, int))get_relative_call(ff7_externals.field_update_models_positions, 0x1EC);
 578: 	ff7_externals.field_evaluate_encounter_rate_60B2C6 = (void (*)())get_relative_call(ff7_externals.field_update_models_positions, 0x90F);
 579: 	ff7_externals.field_animate_3d_models_6392BB = get_relative_call(field_main_loop, 0xF6);
 580: 	ff7_externals.field_blink_3d_model_649B50 = (void(*)(field_animation_data*, field_model_blink_data*))get_relative_call(ff7_externals.field_animate_3d_models_6392BB, 0x8A7);
 581: 	ff7_externals.field_sub_6A2736 = (int (*)(ff7_polygon_set*))get_relative_call((uint32_t)ff7_externals.field_blink_3d_model_649B50, 0xC4);
 582: 	ff7_externals.field_sub_6A2782 = (p_hundred** (*)(int idx, p_hundred *hundreddata, ff7_polygon_set *polygon_set))(get_relative_call(uint32_t(ff7_externals.field_blink_3d_model_649B50), 0x143));
 583: 	ff7_externals.field_model_blink_data_D000C8 = (field_model_blink_data*)get_absolute_value(ff7_externals.field_animate_3d_models_6392BB, 0x7E6);
 584: 	ff7_externals.field_apply_kawai_op_64A070 = get_relative_call(ff7_externals.field_animate_3d_models_6392BB, 0x726);
 585: 	ff7_externals.sub_64EC60 = get_relative_call(ff7_externals.field_apply_kawai_op_64A070, 0x964);
 586: 	ff7_externals.field_player_model_id = (short*)get_absolute_value(ff7_externals.field_update_models_positions, 0x45D);
 587: 	ff7_externals.field_n_models = (WORD*)get_absolute_value(ff7_externals.field_update_models_positions, 0x25);
 588: 	ff7_externals.field_update_camera_data = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0xFD);
 589: 	ff7_externals.field_camera_data = (ff7_camdata**)get_absolute_value(ff7_externals.field_update_camera_data, 0x84);
 590: 	ff7_externals.sub_40B27B = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0xEE);
 591: 	ff7_externals.word_CC0DD4 = (WORD*)get_absolute_value(ff7_externals.enter_field, 0x124);
 592: 	ff7_externals.word_CC1638 = (WORD*)get_absolute_value(ff7_externals.sub_40B27B, 0x25);
 593: 	ff7_externals.field_init_scripted_bg_movement = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x182);
 594: 	ff7_externals.field_update_scripted_bg_movement = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x187);
 595: 	ff7_externals.field_update_background_positions = (void (*)())get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x1A6);
 596: 	ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x62C);
 597: 	ff7_externals.field_submit_draw_arrow_63A171 = (void(*)(field_arrow_graphics_data*))get_relative_call(ff7_externals.compute_and_submit_draw_gateways_arrows_64DA3B, 0x357);
 598: 	ff7_externals.field_sub_64314F = get_relative_call((uint32_t)ff7_externals.field_update_background_positions, 0x288);
 599: 	ff7_externals.set_world_pos_based_on_player_pos_643C86 = (void(*)(vector2<short>*))get_relative_call(ff7_externals.field_update_scripted_bg_movement, 0x3D);
 600: 	ff7_externals.field_clip_with_camera_range_6438F6 = (void(*)(vector2<short>*))get_relative_call((uint32_t)ff7_externals.field_update_background_positions, 0x2B7);
 601: 	ff7_externals.field_layer3_clip_with_camera_range_643628 = get_relative_call((uint32_t)ff7_externals.field_update_background_positions, 0x2CA);
 602: 	ff7_externals.engine_set_game_engine_delta_values_661976 = (void (*)(int, int))get_relative_call(ff7_externals.field_sub_64314F, 0x2D);
 603: 	ff7_externals.engine_apply_matrix_product_66307D = get_relative_call(ff7_externals.field_sub_64314F, 0x45);
 604: 	ff7_externals.engine_convert_psx_matrix_to_float_matrix_row_version_661465 = (void (*)(rotation_matrix*, float*))get_relative_call(ff7_externals.engine_apply_matrix_product_66307D, 0x23);
 605: 	ff7_externals.engine_apply_matrix_product_to_vector_66CF7E = (void (*)(float*, vector3<float>*, vector3<float>*))get_relative_call(ff7_externals.engine_apply_matrix_product_66307D, 0x37);
 606: 	ff7_externals.field_bg_offset = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x3E8);
 607: 	ff7_externals.field_curr_delta_world_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x98F);
 608: 	ff7_externals.field_curr_delta_world_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x9AC);
 609: 	ff7_externals.scripted_world_initial_pos_x = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0xB8);
 610: 	ff7_externals.scripted_world_initial_pos_y = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0xE5);
 611: 	ff7_externals.scripted_world_final_pos_x = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x215);
 612: 	ff7_externals.scripted_world_final_pos_y = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x243);
 613: 	ff7_externals.scripted_world_move_n_steps = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x8A);
 614: 	ff7_externals.scripted_world_move_step_index = (short*)get_absolute_value(ff7_externals.field_update_scripted_bg_movement, 0x102);
 615: 	ff7_externals.field_world_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x403);
 616: 	ff7_externals.field_world_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x424);
 617: 	ff7_externals.field_cursor_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x5C3);
 618: 	ff7_externals.field_cursor_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x5F6);
 619: 	ff7_externals.field_viewport_xy_CFF204 = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_sub_64314F, 0x28);
 620: 	ff7_externals.field_max_half_viewport_width_height_CFF1F4 = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_sub_64314F, 0x58);
 621: 	ff7_externals.field_curr_half_viewport_width_height_CFF1FC = (vector2<int>*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x5AD);
 622: 	ff7_externals.field_bg_flag_CC15E4 = (WORD*)get_absolute_value((uint32_t)ff7_externals.field_update_background_positions, 0x129);
 623: 	ff7_externals.field_sub_640EB7 = get_relative_call(ff7_externals.field_draw_everything, 0x34);
 624: 	ff7_externals.field_sub_661B68 = get_relative_call(ff7_externals.field_sub_640EB7, 0x61);
 625: 	ff7_externals.field_prev_world_pos_x = (short*)get_absolute_value((uint32_t)ff7_externals.field_sub_640EB7, 0x6);
 626: 	ff7_externals.field_prev_world_pos_y = (short*)get_absolute_value((uint32_t)ff7_externals.field_sub_640EB7, 0x18);
 627: 	ff7_externals.engine_set_game_engine_world_coord_661B23 = (void (*)(int, int))get_relative_call(ff7_externals.field_sub_661B68, 0x1A);
 628: 	ff7_externals.engine_sub_67CCDE = (void (*)(float, float, float, float, float, float, float, ff7_game_obj*))get_relative_call(ff7_externals.field_sub_661B68, 0x72);
 629: 	ff7_externals.field_handle_screen_fading = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x634);
 630: 	ff7_externals.sub_62120E = get_relative_call(ff7_externals.enter_field, 0x229);
 631: 	ff7_externals.field_load_map_trigger_data_sub_6211C3 = (int(*)())get_relative_call(ff7_externals.sub_62120E, 0x3AA);
 632: 	ff7_externals.field_fade_screen_sub_63B84B = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x634);
 633: 	ff7_externals.field_calc_fade_color_sub_63AE66 = get_relative_call(ff7_externals.field_fade_screen_sub_63B84B, 0xE7);
 634: 
 635: 	ff7_externals.sfx_stop_channel_6 = get_relative_call(common_externals.sfx_cleanup, 0x16);
 636: 	ff7_externals.sfx_stop_channel_timer_handle = (UINT *)get_absolute_value(ff7_externals.sfx_stop_channel_6, 0x5);
 637: 
 638: 	ff7_externals.current_movie_frame = (WORD*)get_absolute_value(ff7_externals.field_loop_sub_63C17F, 0x133);
 639: 	ff7_externals.opening_movie_music_start_frame = (DWORD *)(ff7_externals.field_loop_sub_63C17F + 0x139);
 640: 	ff7_externals.opening_movie_play_midi_call = ff7_externals.field_loop_sub_63C17F + 0x145;
 641: 
 642: 	ff7_externals.byte_CC164C = (BYTE *)get_absolute_value(main_loop, 0x32A);
 643: 	ff7_externals.word_CC0DC6 = (WORD *)get_absolute_value(main_init_loop, 0x4BD);
 644: 
 645: 	ff7_externals.sub_5F5042 = get_relative_call(condor_main_loop, 0x69);
 646: 	ff7_externals.highway_loop_sub_650F36 = get_relative_call(highway_main_loop, 0x53);
 647: 	ff7_externals.snowboard_enter_sub_722C10 = get_absolute_value(main_loop, 0xB53);
 648: 	ff7_externals.snowboard_loop_sub_72381C = get_relative_call(snowboard_main_loop, 0x7D);
 649: 	ff7_externals.snowboard_exit_sub_722C52 = get_absolute_value(main_loop, 0xB5A);
 650: 	ff7_externals.sub_779E14 = get_relative_call(chocobo_main_loop, 0x70);
 651: 
 652: 	ff7_externals.condor_enter = get_absolute_value(main_loop, 0xA28);
 653: 	ff7_externals.condor_exit = get_absolute_value(main_loop, 0xA2F);
 654: 	ff7_externals.sub_5F7756 = get_relative_call(ff7_externals.condor_enter, 0x1B0);
 655: 	ff7_externals.sub_5F4273 = get_relative_call(ff7_externals.sub_5F7756, 0xA2);
 656: 	ff7_externals.sub_5F342C = get_relative_call(ff7_externals.sub_5F4273, 0xBF);
 657: 	ff7_externals.condor_uses_lgp = (DWORD*)get_absolute_value(ff7_externals.sub_5F342C, 0x7A);
 658: 
 659: 	ff7_externals.fps_limiter_swirl = get_relative_call(swirl_main_loop, 0xDE);
 660: 	ff7_externals.fps_limiter_battle = get_relative_call(battle_main_loop, 0x1DD);
 661: 	ff7_externals.fps_limiter_coaster = get_relative_call(coaster_main_loop, 0x51);
 662: 	ff7_externals.fps_limiter_condor = get_relative_call(ff7_externals.sub_5F5042, 0x5F);
 663: 	ff7_externals.fps_limiter_field = get_relative_call(ff7_externals.field_sub_6388EE, 0x58);
 664: 	ff7_externals.fps_limiter_highway = get_relative_call(ff7_externals.highway_loop_sub_650F36, 0xC3);
 665: 	ff7_externals.fps_limiter_snowboard = get_relative_call(ff7_externals.snowboard_loop_sub_72381C, 0x14);
 666: 	ff7_externals.fps_limiter_worldmap = get_relative_call(ff7_externals.world_loop_74BE49, 0x1D);
 667: 	ff7_externals.fps_limiter_chocobo = get_relative_call(ff7_externals.sub_779E14, 0x4D);
 668: 	ff7_externals.fps_limiter_submarine = get_relative_call(submarine_main_loop, 0x98);
 669: 	ff7_externals.fps_limiter_credits = get_relative_call(credits_main_loop, 0x1C);
 670: 	ff7_externals.fps_limiter_menu = get_relative_call(menu_main_loop, 0x16);
 671: 
 672: 	ff7_externals.battle_fps_menu_multiplier = battle_main_loop + 0x335;
 673: 	ff7_externals.submarine_minigame_status = (DWORD *)get_absolute_value(ff7_externals.fps_limiter_submarine, 0x48);
 674: 	ff7_externals.submarine_last_gametime = (time_t *)get_absolute_value(ff7_externals.fps_limiter_submarine, 0x26);
 675: 	ff7_externals.field_limit_fps = (DWORD *)get_absolute_value(ff7_externals.fps_limiter_field, 0x1F);
 676: 	ff7_externals.swirl_limit_fps = (DWORD *)get_absolute_value(ff7_externals.fps_limiter_swirl, 0x48);
 677: 
 678: 	ff7_externals.get_bank_value = (int16_t (*)(int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0xF1], 0x30);
 679: 	ff7_externals.set_bank_value = (int8_t (*)(int16_t, int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0xFA], 0x1A);
 680: 	ff7_externals.get_char_bank_value = (int8_t (*)(int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0x5E], 0x41);
 681: 	ff7_externals.sub_611BAE = get_relative_call(common_externals.execute_opcode_table[0x16], 0x4);
 682: 
 683: 	ff7_externals.wait_frames_ptr = (WORD*)get_absolute_value(common_externals.execute_opcode_table[0x24], 0x1C);
 684: 
 685: 	ff7_externals.world_mode_loop_sub_74DB8C = get_relative_call(ff7_externals.world_loop_74BE49, 0x114);
 686: 	ff7_externals.sub_767039 = (void (*)(DWORD*,DWORD*,DWORD*))get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x613);
 687: 	ff7_externals.wm_change_music = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x2CF);
 688: 	ff7_externals.wm_play_music_call = ff7_externals.wm_change_music + 0x5A;
 689: 
 690: 	ff7_externals.sub_630C48 = (int (*)(int16_t, int16_t, int16_t, int16_t, int16_t))get_relative_call(common_externals.execute_opcode_table[0x50], 0x174);
 691: 
 692: 	ff7_externals.current_entity_id = (byte*)get_absolute_value(common_externals.execute_opcode_table[0x5F], 0x06); // 0xCC0964
 693: 	ff7_externals.field_script_ptr = (byte**)get_absolute_value(ff7_externals.open_field_file, 0xEA); //0xCBF5E8
 694: 	ff7_externals.field_curr_script_position = (WORD*)get_absolute_value(common_externals.execute_opcode_table[0x5F], 0xE); //0xCC0CF8
 695: 	common_externals.field_game_moment = (WORD*)get_absolute_value(common_externals.execute_opcode_table[0x9D], 0xEA); //0xDC08DC
 696: 
 697: 	ff7_externals.sub_408074 = get_relative_call(main_loop, 0x681);
 698: 	ff7_externals.sub_60BB58 = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x16F);
 699: 	common_externals.update_field_entities = get_relative_call(ff7_externals.sub_60BB58, 0x3A); // 0x60C94D
 700: 
 701: 	common_externals.current_field_id = (WORD*)get_absolute_value(ff7_externals.sub_408074, 0x41); // 0xCC15D0
 702: 	common_externals.previous_field_id = (WORD*)get_absolute_value(ff7_externals.sub_408074, 0x4F); // 0xCC0DEC
 703: 	common_externals.update_entities_call = common_externals.update_field_entities + 0x461; // 0x60CDAE
 704: 
 705: 	ff7_externals.field_level_data_pointer = (byte**)ff7_externals.field_file_buffer; // 0xCFF594
 706: 
 707: 	ff7_externals.sub_408116 = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x2A);
 708: 	ff7_externals.word_CC16E8 = (char *)get_absolute_value(ff7_externals.sub_408116, 0x8E);
 709: 	common_externals.current_triangle_id = (int16_t *)((char *)ff7_externals.word_CC16E8 + 136 * ff7_externals.modules_global_object->field_model_id);
 710: 
 711: 	ff7_externals.sub_6499F7 = get_relative_call(ff7_externals.field_loop_sub_63C17F, 0x10C);
 712: 	ff7_externals.input_ok_button_status = (DWORD*)get_absolute_value(ff7_externals.sub_6499F7, 0x60);
 713: 	ff7_externals.input_run_button_status = (DWORD*)get_absolute_value(ff7_externals.sub_6499F7, 0x55);
 714: 
 715: 	ff7_externals.field_load_models_atoi = ff7_externals.field_load_models + 0x262;
 716: 
 717: 	// auto attack gamehacks
 718: 	ff7_externals.handle_actor_ready = ff7_externals.battle_menu_state_fn_table[0];
 719: 	ff7_externals.battle_menu_state = (WORD*)get_absolute_value(ff7_externals.handle_actor_ready, 0x17B);
 720: 	ff7_externals.set_battle_menu_state_data = get_relative_call(ff7_externals.handle_actor_ready, 0x187);
 721: 	ff7_externals.dispatch_chosen_battle_action = get_relative_call(ff7_externals.battle_sub_6DB0EE, 0x50E);
 722: 	ff7_externals.set_battle_targeting_data = get_relative_call(ff7_externals.battle_menu_state_fn_table[19], 0x11A);
 723: 	ff7_externals.issued_command_id = (byte*)get_absolute_value(ff7_externals.dispatch_chosen_battle_action, 0x12B);
 724: 	ff7_externals.issued_action_id = (uint16_t*)get_absolute_value(ff7_externals.dispatch_chosen_battle_action, 0x122);
 725: 	ff7_externals.issued_action_target_type = (byte*)get_absolute_value(ff7_externals.set_battle_targeting_data, 0x14E);
 726: 	ff7_externals.issued_action_target_index = (byte*)get_absolute_value(ff7_externals.set_battle_targeting_data, 0x164);
 727: 	// --------------------------------
 728: 
 729: 	// ---------- 60 FPS feature ------------
 730: 	// Camera
 731: 	ff7_externals.handle_camera_functions = get_relative_call(ff7_externals.battle_sub_42D992, 0xE3);
 732: 	ff7_externals.set_camera_focal_position_scripts = get_relative_call(ff7_externals.handle_camera_functions, 0x35);
 733: 	ff7_externals.set_camera_position_scripts = get_relative_call(ff7_externals.handle_camera_functions, 0x4B);
 734: 	ff7_externals.execute_camera_functions = get_relative_call(ff7_externals.handle_camera_functions, 0x55);
 735: 	ff7_externals.add_fn_to_camera_fn_array = get_relative_call(ff7_externals.set_camera_focal_position_scripts, 0xF40);
 736: 	ff7_externals.battle_camera_sub_5C52F8 = get_relative_call(ff7_externals.set_camera_focal_position_scripts, 0x10A8);
 737: 	ff7_externals.battle_camera_sub_5C3E6F = get_relative_call(ff7_externals.set_camera_position_scripts, 0x169E);
 738: 	ff7_externals.camera_fn_array = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x39), 16);
 739: 	ff7_externals.camera_fn_data = std::span((bcamera_fn_data*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x4D), 16);
 740: 	ff7_externals.battle_camera_position = std::span((bcamera_position*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0x331), 4);
 741: 	ff7_externals.battle_camera_focal_point = std::span((bcamera_position*)get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0x233), 4);
 742: 	ff7_externals.battle_camera_focal_scripts_8FEE30 = (byte*)get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0xC1);
 743: 	ff7_externals.battle_camera_position_scripts_8FEE2C = (byte*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0xC1);
 744: 	ff7_externals.battle_camera_global_scripts_9A13BC = (DWORD*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0x17);
 745: 	ff7_externals.battle_camera_position_scripts_9010D0 = (DWORD*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0xDC);
 746: 	ff7_externals.battle_camera_focal_scripts_901270 = (DWORD*)get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0xDC);
 747: 	ff7_externals.battle_camera_script_index = (byte*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0xD2);
 748: 	ff7_externals.battle_camera_script_offset = (DWORD*)get_absolute_value(ff7_externals.set_camera_position_scripts, 0x25);
 749: 	ff7_externals.camera_fn_index = (WORD*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x46);
 750: 	ff7_externals.camera_fn_counter = (WORD*)get_absolute_value(ff7_externals.add_fn_to_camera_fn_array, 0x54);
 751: 
 752: 	ff7_externals.battle_camera_position_sub_5C3D0D = get_absolute_value(ff7_externals.set_camera_position_scripts, 0x5DE);
 753: 	ff7_externals.battle_camera_position_sub_5C5B9C = get_absolute_value(ff7_externals.set_camera_position_scripts, 0x40A);
 754: 	ff7_externals.battle_camera_position_sub_5C557D = get_absolute_value(ff7_externals.set_camera_position_scripts, 0xE28);
 755: 	ff7_externals.battle_camera_focal_sub_5C5F5E = get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0xBDB);
 756: 	ff7_externals.battle_camera_focal_sub_5C5714 = get_absolute_value(ff7_externals.set_camera_focal_position_scripts, 0x67D);
 757: 
 758: 	ff7_externals.battle_sub_430DD0 = get_relative_call(ff7_externals.battle_loop, 0x99E);
 759: 	ff7_externals.battle_sub_429D8A = get_absolute_value(ff7_externals.battle_loop, 0x59);
 760: 	ff7_externals.update_battle_camera_sub_5C20CE = get_relative_call(ff7_externals.battle_sub_42D992, 0xFB);
 761: 	ff7_externals.set_battle_camera_sub_5C22BD = get_relative_call(ff7_externals.update_battle_camera_sub_5C20CE, 0x5A);
 762: 	ff7_externals.battle_camera_sub_5C22A9 = get_relative_call(ff7_externals.update_battle_camera_sub_5C20CE, 0x97);
 763: 	ff7_externals.compute_interpolation_to_formation_camera = get_relative_call(ff7_externals.battle_camera_sub_5C22A9, 0x3);
 764: 	ff7_externals.set_battle_camera_sub_5C2350 = get_relative_call(ff7_externals.battle_camera_sub_5C22A9, 0xA);
 765: 	ff7_externals.g_battle_camera_position = (vector3<short>*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x17);
 766: 	ff7_externals.g_battle_camera_focal_point = (vector3<short>*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x5E);
 767: 	ff7_externals.formation_camera = std::span((formation_camera*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x10), 4);
 768: 	ff7_externals.curr_formation_camera_idx = (byte*)get_absolute_value(ff7_externals.set_battle_camera_sub_5C22BD, 0x6);
 769: 	ff7_externals.battle_enter_frames_to_wait = (byte*)get_absolute_value(ff7_externals.battle_sub_429AC0, 0x14E);
 770: 	ff7_externals.g_variation_index = (byte*)get_absolute_value(ff7_externals.update_battle_camera_sub_5C20CE, 0x6F);
 771: 	ff7_externals.is_camera_moving_BFB2DC = (byte*)get_absolute_value(ff7_externals.update_battle_camera_sub_5C20CE, 0x1C1);
 772: 
 773: 	// Animation effects
 774: 	uint32_t battle_sub_42A5D0 = get_relative_call(ff7_externals.battle_sub_429AC0, 0x1A6);
 775: 	ff7_externals.battle_sub_42A5EB = get_relative_call(battle_sub_42A5D0, 0x14);
 776: 	ff7_externals.battle_sub_42E275 = get_relative_call(ff7_externals.battle_sub_42D992, 0x6C);
 777: 	uint32_t battle_sub_42E3CA = get_relative_call(ff7_externals.battle_sub_42D992, 0x48);
 778: 	ff7_externals.battle_sub_42E34A = get_relative_call(battle_sub_42E3CA, 0x70);
 779: 	uint32_t battle_sub_42DBD2 = get_relative_call(ff7_externals.battle_sub_42D992, 0x90);
 780: 	uint32_t battle_sub_42F21F = get_relative_call(battle_sub_42DBD2, 0x37);
 781: 	ff7_externals.battle_sub_5B9EC2 = get_relative_call(battle_sub_42F21F, 0x38);
 782: 	ff7_externals.battle_sub_5BD5E9 = get_relative_call(ff7_externals.battle_sub_5B9EC2, 0x41);
 783: 	uint32_t battle_sub_42DE61 = get_relative_call(ff7_externals.battle_sub_42D992, 0x9F);
 784: 	ff7_externals.run_summon_animations_script_5C1B81 = get_absolute_value(battle_sub_42DE61, 0x17E);
 785: 	ff7_externals.run_summon_animations_script_sub_5C1D9A = get_relative_call(ff7_externals.run_summon_animations_script_5C1B81, 0xA4);
 786: 	ff7_externals.run_animation_script = get_relative_call(ff7_externals.battle_sub_42A5EB, 0xB8);
 787: 	ff7_externals.add_fn_to_effect100_fn = get_relative_call(ff7_externals.run_animation_script, 0x48C2);
 788: 	ff7_externals.execute_effect100_fn = get_relative_call(ff7_externals.battle_sub_42D992, 0x12E);
 789: 	ff7_externals.add_fn_to_effect60_fn = get_relative_call(ff7_externals.run_animation_script, 0x394);
 790: 	ff7_externals.execute_effect60_fn = get_relative_call(ff7_externals.battle_sub_42D992, 0x129);
 791: 	ff7_externals.add_fn_to_effect10_fn = get_relative_call(ff7_externals.run_animation_script, 0x825);
 792: 	ff7_externals.execute_effect10_fn = get_relative_call(ff7_externals.battle_sub_42D992, 0x4D);
 793: 	uint32_t battle_sub_42B66A = get_relative_call(ff7_externals.run_animation_script, 0x460A);
 794: 	ff7_externals.battle_update_3d_model_data = get_relative_call(ff7_externals.run_animation_script, 0x623);
 795: 
 796: 	ff7_externals.effect100_array_data = std::span((effect100_data*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x5D), 100);
 797: 	ff7_externals.effect100_array_fn = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x48), 100);
 798: 	ff7_externals.effect100_counter = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x63);
 799: 	ff7_externals.effect100_array_idx = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect100_fn, 0x32);
 800: 	ff7_externals.effect60_array_data = std::span((effect60_data*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x5D), 60);
 801: 	ff7_externals.effect60_array_fn = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x48), 60);
 802: 	ff7_externals.effect60_array_idx = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x32);
 803: 	ff7_externals.effect60_counter = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect60_fn, 0x63);
 804: 	ff7_externals.effect10_array_data = std::span((effect10_data*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x5D), 10);
 805: 	ff7_externals.effect10_array_fn = std::span((uint32_t*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x48), 10);
 806: 	ff7_externals.effect10_array_idx = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x32);
 807: 	ff7_externals.effect10_counter = (uint16_t*)get_absolute_value(ff7_externals.add_fn_to_effect10_fn, 0x63);
 808: 	ff7_externals.g_actor_idle_scripts = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x304);
 809: 	ff7_externals.g_battle_model_state = std::span((battle_model_state*)get_absolute_value(battle_sub_42B66A, 0xD9), 10);
 810: 	ff7_externals.g_small_battle_model_state = std::span((battle_model_state_small*)get_absolute_value(ff7_externals.run_animation_script, 0x2BB9), 10);
 811: 	std::function<int(int)> shift_index = [](int index){return index - 0x2E;};
 812: 	ff7_externals.animation_script_pointers[shift_index(0x2E)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x81);
 813: 	ff7_externals.animation_script_pointers[shift_index(0x2F)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x90);
 814: 	ff7_externals.animation_script_pointers[shift_index(0x30)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x9F);
 815: 	ff7_externals.animation_script_pointers[shift_index(0x31)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xAE);
 816: 	ff7_externals.animation_script_pointers[shift_index(0x32)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xBD);
 817: 	ff7_externals.animation_script_pointers[shift_index(0x34)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xCC);
 818: 	ff7_externals.animation_script_pointers[shift_index(0x35)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xD8);
 819: 	ff7_externals.animation_script_pointers[shift_index(0x36)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xE4);
 820: 	ff7_externals.animation_script_pointers[shift_index(0x37)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xF0);
 821: 	ff7_externals.animation_script_pointers[shift_index(0x38)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xFC);
 822: 	ff7_externals.animation_script_pointers[shift_index(0x39)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x12D);
 823: 	ff7_externals.animation_script_pointers[shift_index(0x3A)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x139);
 824: 	ff7_externals.animation_script_pointers[shift_index(0x3B)] = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x145);
 825: 	ff7_externals.g_is_effect_loading = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x2D25);
 826: 	ff7_externals.g_is_battle_paused = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0xA);
 827: 	ff7_externals.special_actor_id = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x286B);
 828: 	ff7_externals.g_script_wait_frames = (byte*)get_absolute_value(ff7_externals.run_animation_script, 0x27E8);
 829: 	ff7_externals.g_script_args = std::span((int**)get_absolute_value(ff7_externals.run_animation_script, 0x3EA), 8);
 830: 	ff7_externals.limit_break_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0x40E), 80);
 831: 	ff7_externals.enemy_atk_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0x4B9), 157);
 832: 	ff7_externals.enemy_skill_effects_fn_table = std::span((uint32_t*)get_absolute_value(ff7_externals.battle_sub_427C22, 0x20A), 24);
 833: 
 834: 	// Enemy death animations
 835: 	uint32_t battle_run_enemy_deaths_42567E = get_relative_call(ff7_externals.run_animation_script, 0x4869);
 836: 	ff7_externals.battle_enemy_death_5BBD24 = get_absolute_value(battle_run_enemy_deaths_42567E, 0x37);
 837: 	ff7_externals.battle_enemy_death_sub_5BBE32 = get_relative_call(ff7_externals.battle_enemy_death_5BBD24, 0xF1);
 838: 	ff7_externals.battle_iainuki_death_5BCAAA = get_absolute_value(battle_run_enemy_deaths_42567E, 0x72);
 839: 	ff7_externals.battle_iainuki_death_sub_5BCBB8 = get_relative_call(ff7_externals.battle_iainuki_death_5BCAAA, 0xF1);
 840: 	ff7_externals.battle_boss_death_5BC48C = get_absolute_value(battle_run_enemy_deaths_42567E, 0x16A);
 841: 	ff7_externals.battle_boss_death_sub_5BC6ED = get_relative_call(ff7_externals.battle_boss_death_5BC48C, 0x144);
 842: 	ff7_externals.battle_boss_death_sub_5BC5EC = get_absolute_value(ff7_externals.battle_boss_death_5BC48C, 0x9F);
 843: 	ff7_externals.battle_boss_death_call_5BD436 = get_relative_call(ff7_externals.battle_boss_death_sub_5BC5EC, 0x7C);
 844: 	ff7_externals.field_battle_BFB2E0 = (int*)get_absolute_value(ff7_externals.battle_boss_death_sub_5BC5EC, 0x85);
 845: 	ff7_externals.battle_melting_death_5BC21F = get_absolute_value(battle_run_enemy_deaths_42567E, 0xF7);
 846: 	ff7_externals.battle_melting_death_sub_5BC32D = get_relative_call(ff7_externals.battle_melting_death_5BC21F, 0xF1);
 847: 	ff7_externals.battle_disintegrate_2_death_5BBA82 = get_absolute_value(battle_run_enemy_deaths_42567E, 0x132);
 848: 	ff7_externals.battle_disintegrate_2_death_sub_5BBBDE = get_relative_call(ff7_externals.battle_disintegrate_2_death_5BBA82, 0xFE);
 849: 	ff7_externals.field_float_battle_7B7680 = (float*)get_absolute_value(ff7_externals.battle_disintegrate_2_death_sub_5BBBDE, 0x10F);
 850: 	ff7_externals.battle_morph_death_5BC812 = get_absolute_value(battle_run_enemy_deaths_42567E, 0x1A2);
 851: 	ff7_externals.battle_morph_death_sub_5BC920 = get_relative_call(ff7_externals.battle_morph_death_5BC812, 0xF1);
 852: 	ff7_externals.battle_disintegrate_1_death_5BBF31 = get_absolute_value(battle_run_enemy_deaths_42567E, 0xAD);
 853: 	ff7_externals.battle_disintegrate_1_death_sub_5BC04D = get_relative_call(ff7_externals.battle_disintegrate_1_death_5BBF31, 0xFF);
 854: 	ff7_externals.battle_sub_42C0A7 = get_relative_call(ff7_externals.battle_disintegrate_1_death_sub_5BC04D, 0x8D);
 855: 	ff7_externals.effect10_array_data_8FE1F6 = (short*)get_absolute_value(ff7_externals.battle_disintegrate_1_death_sub_5BC04D, 0x123);
 856: 
 857: 	// Display string for actor actions
 858: 	ff7_externals.display_battle_action_text_42782A = get_absolute_value(ff7_externals.run_animation_script, 0x4906);
 859: 	ff7_externals.get_n_frames_display_action_string = get_relative_call(ff7_externals.run_animation_script, 0x4918);
 860: 	ff7_externals.field_byte_DC0E11 = (byte*)get_absolute_value(ff7_externals.get_n_frames_display_action_string, 0x6);
 861: 	uint32_t battle_sub_4351BD = get_relative_call(ff7_externals.battle_loop, 0x47C);
 862: 	uint32_t** battle_functions_table_7C2AC0 = (uint32_t**)get_absolute_value(battle_sub_4351BD, 0x3A);
 863: 	ff7_externals.battle_sub_434C8B = battle_functions_table_7C2AC0[1][1];
 864: 	uint32_t battle_sub_435789 = get_relative_call(ff7_externals.battle_loop, 0x3B8);
 865: 	ff7_externals.battle_sub_435D81 = get_relative_call(battle_sub_435789, 0x505);
 866: 
 867: 	// Display battle damage
 868: 	ff7_externals.battle_sub_425D29 = get_absolute_value(ff7_externals.run_animation_script, 0x2850);
 869: 	ff7_externals.battle_sub_425E5F = get_absolute_value(ff7_externals.battle_sub_425D29, 0xA8);
 870: 	ff7_externals.display_battle_damage_5BB410 = get_absolute_value(ff7_externals.battle_sub_425D29, 0x3D);
 871: 
 872: 	// Reduce actor size (for Mini status effect)
 873: 	ff7_externals.battle_sub_42CBF9 = get_relative_call(ff7_externals.battle_loop, 0x425);
 874: 	ff7_externals.battle_sub_5BDA0F = get_absolute_value(ff7_externals.battle_sub_42CBF9, 0x240);
 875: 
 876: 	// Character fade in/out
 877: 	ff7_externals.vincent_limit_fade_effect_sub_5D4240 = ff7_externals.limit_break_effects_fn_table[56];
 878: 	ff7_externals.battle_sub_5BD96D = get_absolute_value(ff7_externals.vincent_limit_fade_effect_sub_5D4240, 0x27);
 879: 	ff7_externals.battle_sub_5C1C8F = get_absolute_value(ff7_externals.run_summon_animations_script_5C1B81, 0x3F);
 880: 	uint32_t handle_fade_character_42C31C = get_relative_call(ff7_externals.battle_sub_5C1C8F, 0xEC);
 881: 	ff7_externals.battle_sub_5C18BC = get_absolute_value(ff7_externals.run_summon_animations_script_5C1B81, 0x30);
 882: 	ff7_externals.battle_sub_42A72D = get_relative_call(ff7_externals.battle_sub_429AC0, 0xD0);
 883: 
 884: 	// resting positions and rotations
 885: 	uint32_t battle_sub_426C9B = get_relative_call(ff7_externals.run_animation_script, 0x14C7);
 886: 	ff7_externals.battle_sub_426DE3 = get_absolute_value(battle_sub_426C9B, 0x5);
 887: 	ff7_externals.battle_sub_426941 = get_absolute_value(ff7_externals.run_animation_script, 0x1A5D);
 888: 	ff7_externals.battle_sub_426899 = get_absolute_value(ff7_externals.run_animation_script, 0x821);
 889: 	ff7_externals.battle_sub_4267F1 = get_absolute_value(ff7_externals.run_animation_script, 0xFF6);
 890: 	ff7_externals.battle_move_character_sub_426A26 = get_absolute_value(ff7_externals.run_animation_script, 0x1568);
 891: 	ff7_externals.field_battle_byte_BF2E1C = (byte*)get_absolute_value(ff7_externals.battle_move_character_sub_426A26, 0x86);
 892: 	ff7_externals.field_battle_byte_BE10B4 = (byte*)get_absolute_value(ff7_externals.battle_move_character_sub_426A26, 0x148);
 893: 	ff7_externals.battle_move_character_sub_42739D = get_absolute_value(ff7_externals.run_animation_script, 0x248E);
 894: 	ff7_externals.battle_move_character_sub_426F58 = get_absolute_value(ff7_externals.run_animation_script, 0x26AF);
 895: 	ff7_externals.resting_Y_array_data = (short*)get_absolute_value(ff7_externals.battle_move_character_sub_426F58, 0x122);
 896: 	ff7_externals.battle_move_character_sub_4270DE = get_absolute_value(ff7_externals.run_animation_script, 0x2357);
 897: 
 898: 	// aura animations (magic, limit breaks, enemy skill and summon)
 899: 	ff7_externals.handle_aura_effects_425520 = get_absolute_value(ff7_externals.run_animation_script, 0x3F7A);
 900: 	ff7_externals.run_aura_effects_5C0230 = get_relative_call(ff7_externals.handle_aura_effects_425520, 0x42);
 901: 	ff7_externals.limit_break_aura_effects_5C0572 = get_absolute_value(ff7_externals.run_aura_effects_5C0230, 0x72);
 902: 	ff7_externals.enemy_skill_aura_effects_5C06BF = get_absolute_value(ff7_externals.run_aura_effects_5C0230, 0x7E);
 903: 	ff7_externals.handle_summon_aura_5C0850 = get_absolute_value(ff7_externals.run_aura_effects_5C0230, 0x8F);
 904: 	ff7_externals.summon_aura_effects_5C0953 = get_absolute_value(ff7_externals.handle_summon_aura_5C0850, 0x31);
 905: 
 906: 	// effect 60 related
 907: 	ff7_externals.battle_sub_4276B6 = get_absolute_value(ff7_externals.run_animation_script, 0x3091);
 908: 	ff7_externals.battle_sub_4255B7 = get_absolute_value(ff7_externals.run_animation_script, 0x390);
 909: 	ff7_externals.battle_sub_5BCF9D = get_absolute_value(ff7_externals.battle_sub_429AC0, 0xDB);
 910: 	ff7_externals.battle_sub_5BD050 = get_relative_call(ff7_externals.battle_sub_5BCF9D, 0x95);
 911: 	ff7_externals.battle_sub_425AAD = get_absolute_value(ff7_externals.run_animation_script, 0x413);
 912: 	ff7_externals.battle_sub_427A6C = ff7_externals.enemy_atk_effects_fn_table[147];
 913: 	ff7_externals.battle_sub_427AF1 = get_absolute_value(ff7_externals.battle_sub_427A6C, 0x56);
 914: 	ff7_externals.battle_sub_427737 = get_absolute_value(ff7_externals.run_animation_script, 0x3158);
 915: 	ff7_externals.battle_sub_4277B1 = get_absolute_value(ff7_externals.run_animation_script, 0x472B);
 916: 	ff7_externals.battle_sub_5BCD42 = get_absolute_value(ff7_externals.run_animation_script, 0x66F);
 917: 	uint32_t battle_sub_5BE490 = get_relative_call(ff7_externals.run_animation_script, 0x3E6E);
 918: 	ff7_externals.battle_smoke_move_handler_5BE4E2 = get_absolute_value(battle_sub_5BE490, 0x5);
 919: 	ff7_externals.battle_sub_6CE81E = (void(*)())get_relative_call(ff7_externals.battle_sub_42D808, 0x117);
 920: 	ff7_externals.battle_play_sfx_sound_430D32 = (void(*)(uint16_t, short, char))get_relative_call(ff7_externals.battle_sub_427737, 0x35);
 921: 
 922: 	// Limit breaks
 923: 	uint32_t battle_sub_4E1627 = get_relative_call(ff7_externals.run_animation_script, 0x3848);
 924: 	ff7_externals.run_tifa_limit_effects = get_relative_call(battle_sub_4E1627, 0xD);
 925: 	uint32_t tifa_limit_1_2_main_4E2DF3 = get_absolute_value(ff7_externals.run_tifa_limit_effects, 0x47);
 926: 	ff7_externals.tifa_limit_1_2_sub_4E3D51 = get_absolute_value(tifa_limit_1_2_main_4E2DF3, 0x4BB);
 927: 	uint32_t tifa_limit_2_1_main_4E401E = get_absolute_value(ff7_externals.run_tifa_limit_effects, 0x67);
 928: 	ff7_externals.tifa_limit_2_1_sub_4E48D4 = get_absolute_value(tifa_limit_2_1_main_4E401E, 0x41A);
 929: 	uint32_t aerith_limit_2_1_main_45AE80 = ff7_externals.limit_break_effects_fn_table[16];
 930: 	uint32_t aerith_limit_2_1_sub_45AEA6 = get_relative_call(aerith_limit_2_1_main_45AE80, 0x1A);
 931: 	uint32_t aerith_limit_2_1_sub_45AEE8 = get_absolute_value(aerith_limit_2_1_sub_45AEA6, 0xE);
 932: 	uint32_t aerith_limit_2_1_sub_45AF39 = get_absolute_value(aerith_limit_2_1_sub_45AEE8, 0x5);
 933: 	ff7_externals.aerith_limit_2_1_sub_45B0CF = get_absolute_value(aerith_limit_2_1_sub_45AF39, 0x4A);
 934: 	uint32_t cloud_limit_2_2_main_466A31 = ff7_externals.limit_break_effects_fn_table[3];
 935: 	uint32_t cloud_limit_2_2_sub_466A57 = get_relative_call(cloud_limit_2_2_main_466A31, 0x1A);
 936: 	uint32_t cloud_limit_2_2_sub_466A7A = get_absolute_value(cloud_limit_2_2_sub_466A57, 0x15);
 937: 	uint32_t cloud_limit_2_2_sub_466CD2 = get_absolute_value(cloud_limit_2_2_sub_466A7A, 0x185);
 938: 	ff7_externals.cloud_limit_2_2_sub_467256 = get_absolute_value(cloud_limit_2_2_sub_466CD2, 0x38C);
 939: 	uint32_t aerith_limit_4_1_sub_473A70 = ff7_externals.limit_break_effects_fn_table[20];
 940: 	uint32_t aerith_limit_4_1_sub_473B84 = get_relative_call(aerith_limit_4_1_sub_473A70, 0xAA);
 941: 	uint32_t aerith_limit_4_1_sub_473C82 = get_relative_call(aerith_limit_4_1_sub_473B84, 0xB7);
 942: 	ff7_externals.aerith_limit_4_1_camera_473CC2 = get_absolute_value(aerith_limit_4_1_sub_473C82, 0x5);
 943: 	uint32_t vincent_limit_satan_slam_sub_45C0C0 = ff7_externals.limit_break_effects_fn_table[69];
 944: 	uint32_t vincent_limit_satan_slam_sub_45C1EA = get_relative_call(vincent_limit_satan_slam_sub_45C0C0, 0x87);
 945: 	uint32_t vincen_limit_satan_slam_sub_45C263 = get_absolute_value(vincent_limit_satan_slam_sub_45C1EA, 0x47);
 946: 	uint32_t vincent_limit_satan_slam_sub_45CEEA = get_relative_call(vincen_limit_satan_slam_sub_45C263, 0x228);
 947: 	ff7_externals.vincent_limit_satan_slam_camera_45CF2A = get_absolute_value(vincent_limit_satan_slam_sub_45CEEA, 0x5);
 948: 	uint32_t barret_limit_4_1_sub_468691 = ff7_externals.limit_break_effects_fn_table[13];
 949: 	uint32_t barret_limit_4_1_sub_468725 = get_relative_call(barret_limit_4_1_sub_468691, 0x88);
 950: 	uint32_t barret_limit_4_1_sub_468862 = get_relative_call(barret_limit_4_1_sub_468725, 0x11B);
 951: 	ff7_externals.barret_limit_4_1_camera_4688A2 = get_absolute_value(barret_limit_4_1_sub_468862, 0x5);
 952: 	ff7_externals.barret_limit_4_1_model_movement_4698EF = get_absolute_value(barret_limit_4_1_sub_468725, 0x101);
 953: 	ff7_externals.barret_limit_4_1_actor_id = (int*)get_absolute_value(ff7_externals.barret_limit_4_1_model_movement_4698EF, 0x82);
 954: 
 955: 	// Summons
 956: 	uint32_t battle_sub_5C0E39 = get_relative_call(ff7_externals.battle_sub_427C22, 0x4DE);
 957: 	ff7_externals.run_summon_animations_5C0E4B = get_absolute_value(battle_sub_5C0E39, 0x4);
 958: 	uint32_t run_chocomog_main_5099D6 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x223);
 959: 	uint32_t run_chocomog_sub_507BAD = get_relative_call(run_chocomog_main_5099D6, 0x2E);
 960: 	uint32_t run_chocomog_camera_handler_509AD0 = get_relative_call(run_chocomog_sub_507BAD, 0x9C);
 961: 	uint32_t run_chocomog_main_loop_50A9E0 = get_absolute_value(run_chocomog_sub_507BAD, 0x74);
 962: 	ff7_externals.run_chocomog_movement_50B1A3 = get_absolute_value(run_chocomog_main_loop_50A9E0, 0xD1);
 963: 	ff7_externals.run_chocomog_camera_509B10 = get_absolute_value(run_chocomog_camera_handler_509AD0, 0x5);
 964: 	uint32_t run_fat_chocobo_main_507B91 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x245);
 965: 	uint32_t run_fat_chocobo_sub_507BAD = get_relative_call(run_fat_chocobo_main_507B91, 0x10);
 966: 	uint32_t run_fat_chocobo_camera_handler_507C64 = get_relative_call(run_fat_chocobo_sub_507BAD, 0x87);
 967: 	uint32_t run_fat_chocobo_main_loop_508BED = get_absolute_value(run_fat_chocobo_sub_507BAD, 0x5F);
 968: 	ff7_externals.run_fat_chocobo_movement_509692 = get_absolute_value(run_fat_chocobo_main_loop_508BED, 0x103);
 969: 	ff7_externals.run_fat_chocobo_camera_507CA4 = get_absolute_value(run_fat_chocobo_camera_handler_507C64, 0x5);
 970: 	ff7_externals.run_fat_chocobo_camera_shake_5095F5 = get_absolute_value(run_fat_chocobo_main_loop_508BED, 0x18D);
 971: 	uint32_t run_summon_shiva_main_58E411 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x267);
 972: 	uint32_t run_summon_shiva_sub_58E4D8 = get_relative_call(run_summon_shiva_main_58E411, 0xBB);
 973: 	uint32_t run_summon_shiva_camera_handler_58E5CD = get_relative_call(run_summon_shiva_sub_58E4D8, 0xBB);
 974: 	ff7_externals.run_shiva_movement_592538 = get_absolute_value(run_summon_shiva_sub_58E4D8, 0x7B);
 975: 	ff7_externals.run_shiva_camera_58E60D = get_absolute_value(run_summon_shiva_camera_handler_58E5CD, 0x5);
 976: 	uint32_t run_ifrit_main_5927C1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x3FC);
 977: 	uint32_t run_ifrit_sub_5928FE = get_relative_call(run_ifrit_main_5927C1, 0x12F);
 978: 	uint32_t run_ifrit_camera_handler_5929F6 = get_relative_call(run_ifrit_sub_5928FE, 0xC5);
 979: 	uint32_t run_ifrit_main_loop_593A95 = get_absolute_value(run_ifrit_sub_5928FE, 0x9D);
 980: 	ff7_externals.run_ifrit_movement_596702 = get_absolute_value(run_ifrit_main_loop_593A95, 0x15B);
 981: 	ff7_externals.run_ifrit_camera_592A36 = get_absolute_value(run_ifrit_camera_handler_5929F6, 0x5);
 982: 	uint32_t run_summon_ramuh_main_596FF1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x311);
 983: 	uint32_t run_summon_ramuh_sub_59706F = get_relative_call(run_summon_ramuh_main_596FF1, 0x70);
 984: 	uint32_t run_summon_ramuh_sub_5971C6 = get_relative_call(run_summon_ramuh_sub_59706F, 0x13C);
 985: 	ff7_externals.run_ramuh_camera_597206 = get_absolute_value(run_summon_ramuh_sub_5971C6, 0x5);
 986: 	uint32_t run_titan_main_59B1DA = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x355);
 987: 	uint32_t run_titan_sub_59B273 = get_relative_call(run_titan_main_59B1DA, 0x8B);
 988: 	uint32_t run_titan_camera_handler_59B470 = get_relative_call(run_titan_sub_59B273, 0x1CA);
 989: 	ff7_externals.run_titan_camera_59B4B0 = get_absolute_value(run_titan_camera_handler_59B470, 0x5);
 990: 	uint32_t run_summon_odin_gunge_main_4A0AE1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x3DD);
 991: 	uint32_t run_summon_odin_gunge_sub_4A0B6D = get_relative_call(run_summon_odin_gunge_main_4A0AE1, 0x7F);
 992: 	uint32_t run_summon_odin_gunge_camera_handler_4A0F12 = get_relative_call(run_summon_odin_gunge_sub_4A0B6D, 0x1C0);
 993: 	uint32_t run_summon_odin_gunge_main_loop_4A0B6D = get_absolute_value(run_summon_odin_gunge_sub_4A0B6D, 0x163);
 994: 	ff7_externals.run_odin_gunge_movement_4A584D = get_absolute_value(run_summon_odin_gunge_main_loop_4A0B6D, 0x152);
 995: 	ff7_externals.run_odin_gunge_camera_4A0F52 = get_absolute_value(run_summon_odin_gunge_camera_handler_4A0F12, 0x5);
 996: 	uint32_t run_summon_odin_steel_main_4A5B61 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x3BB);
 997: 	uint32_t run_summon_odin_steel_sub_4A5BE5 = get_relative_call(run_summon_odin_steel_main_4A5B61, 0x77);
 998: 	uint32_t run_summon_odin_steel_main_loop_4A8B86 = get_absolute_value(run_summon_odin_steel_sub_4A5BE5, 0xA7);
 999: 	uint32_t run_summon_odin_steel_camera_handler_4A5CFC = get_relative_call(run_summon_odin_steel_sub_4A5BE5, 0xF3);
1000: 	ff7_externals.run_odin_steel_movement_4A6CB8 = get_absolute_value(run_summon_odin_steel_sub_4A5BE5, 0xCB);
1001: 	ff7_externals.run_odin_steel_sub_4A9908 = get_absolute_value(run_summon_odin_steel_main_loop_4A8B86, 0x43E);
1002: 	ff7_externals.run_odin_steel_camera_4A5D3C = get_absolute_value(run_summon_odin_steel_camera_handler_4A5CFC, 0x5);
1003: 	ff7_externals.field_odin_frames_AEEC14 = (WORD*)get_absolute_value(ff7_externals.run_odin_steel_sub_4A9908, 0x316);
1004: 	uint32_t run_leviathan_main_5B048B = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x333);
1005: 	uint32_t run_leviathan_sub_5B055B = get_relative_call(run_leviathan_main_5B048B, 0xC2);
1006: 	uint32_t run_leviathan_camera_handler_5B06D6 = get_relative_call(run_leviathan_sub_5B055B, 0x148);
1007: 	ff7_externals.run_leviathan_camera_5B0716 = get_absolute_value(run_leviathan_camera_handler_5B06D6, 0x5);
1008: 	uint32_t run_bahamut_main_4978B9 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x201);
1009: 	uint32_t run_bahamut_sub_497919 = get_relative_call(run_bahamut_main_4978B9, 0x52);
1010: 	uint32_t run_bahamut_camera_handler_4979F7 = get_relative_call(run_bahamut_sub_497919, 0xAB);
1011: 	ff7_externals.run_bahamut_movement_49ADEC = get_absolute_value(run_bahamut_sub_497919, 0x76);
1012: 	ff7_externals.run_bahamut_camera_497A37 = get_absolute_value(run_bahamut_camera_handler_4979F7, 0x5);
1013: 	uint32_t run_kujata_main_4F9891 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x2EF);
1014: 	uint32_t run_kujata_sub_4F9937 = get_relative_call(run_kujata_main_4F9891, 0x98);
1015: 	uint32_t run_kujata_camera_handler_4F9A0D = get_relative_call(run_kujata_sub_4F9937, 0x96);
1016: 	ff7_externals.run_kujata_camera_4F9A4D = get_absolute_value(run_kujata_camera_handler_4F9A0D, 0x5);
1017: 	uint32_t run_alexander_main_501491 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x2CD);
1018: 	uint32_t run_alexander_sub_501514 = get_relative_call(run_alexander_main_501491, 0x73);
1019: 	uint32_t run_alexander_camera_handler_5015F7 = get_relative_call(run_alexander_sub_501514, 0xA3);
1020: 	uint32_t run_alexander_main_loop_50265E = get_absolute_value(run_alexander_sub_501514, 0xC4);
1021: 	ff7_externals.run_alexander_movement_5078D8 = get_absolute_value(run_alexander_main_loop_50265E, 0x2E2);
1022: 	ff7_externals.run_alexander_camera_501637 = get_absolute_value(run_alexander_camera_handler_5015F7, 0x5);
1023: 	uint32_t run_summon_phoenix_main_515101 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x2AB);
1024: 	uint32_t run_summon_phoenix_sub_515127 = get_relative_call(run_summon_phoenix_main_515101, 0x1A);
1025: 	uint32_t run_summon_phoenix_camera_handler_5151F8 = get_relative_call(run_summon_phoenix_sub_515127, 0x91);
1026: 	ff7_externals.run_phoenix_main_loop_516297 = get_absolute_value(run_summon_phoenix_sub_515127, 0xB2);
1027: 	ff7_externals.run_phoenix_movement_518AFF = get_absolute_value(ff7_externals.run_phoenix_main_loop_516297, 0x310);
1028: 	ff7_externals.run_phoenix_camera_515238 = get_absolute_value(run_summon_phoenix_camera_handler_5151F8, 0x5);
1029: 	ff7_externals.run_bahamut_neo_main_48C2A1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x377);
1030: 	uint32_t run_bahamut_neo_sub_48C60B = get_relative_call(ff7_externals.run_bahamut_neo_main_48C2A1, 0x35D);
1031: 	uint32_t run_bahamut_neo_camera_handler_48C71D = get_relative_call(run_bahamut_neo_sub_48C60B, 0xD2);
1032: 	ff7_externals.run_bahamut_neo_movement_48D7BC = get_absolute_value(run_bahamut_neo_sub_48C60B, 0xAA);
1033: 	ff7_externals.run_bahamut_neo_camera_48C75D = get_absolute_value(run_bahamut_neo_camera_handler_48C71D, 0x5);
1034: 	uint32_t run_hades_main_4B6351 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x289);
1035: 	uint32_t run_hades_sub_4B636D = get_relative_call(run_hades_main_4B6351, 0x10);
1036: 	uint32_t run_hades_main_loop_4B636D = get_absolute_value(run_hades_sub_4B636D, 0x4);
1037: 	uint32_t run_hades_camera_handler_4B6568 = get_relative_call(run_hades_main_loop_4B636D, 0x1B7);
1038: 	ff7_externals.run_hades_camera_4B65A8 = get_absolute_value(run_hades_camera_handler_4B6568, 0x5);
1039: 	uint32_t run_typhoon_main_4D5751 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x41B);
1040: 	uint32_t run_typhoon_sub_4D57EF = get_relative_call(run_typhoon_main_4D5751, 0x91);
1041: 	uint32_t run_typhoon_main_loop_4D69A6 = get_absolute_value(run_typhoon_sub_4D57EF, 0x101);
1042: 	uint32_t run_typhoon_camera_handler_4D590C = get_relative_call(run_typhoon_sub_4D57EF, 0xF8);
1043: 	ff7_externals.run_typhoon_sub_4DA182 = get_absolute_value(run_typhoon_main_loop_4D69A6, 0x319);
1044: 	ff7_externals.run_typhoon_camera_4D594C = get_absolute_value(run_typhoon_camera_handler_4D590C, 0x5);
1045: 	uint32_t run_bahamut_zero_main_4835C1 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x399);
1046: 	uint32_t run_bahamut_zero_sub_483762 = get_relative_call(run_bahamut_zero_main_4835C1, 0x194);
1047: 	uint32_t run_bahamut_zero_camera_handler_483826 = get_relative_call(run_bahamut_zero_sub_483762, 0x94);
1048: 	ff7_externals.run_bahamut_zero_main_loop_484A16 = get_absolute_value(run_bahamut_zero_sub_483762, 0x5F);
1049: 	ff7_externals.run_bahamut_zero_movement_48BBFC = get_absolute_value(run_bahamut_zero_sub_483762, 0x6C);
1050: 	ff7_externals.run_bahamut_zero_camera_483866 = get_absolute_value(run_bahamut_zero_camera_handler_483826, 0x5);
1051: 	ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA = get_absolute_value(ff7_externals.run_bahamut_zero_main_loop_484A16, 0x2E8);
1052: 	ff7_externals.bahamut_zero_bg_star_graphics_data_7F6748 = get_absolute_value(ff7_externals.bahamut_zero_draw_bg_effect_sub_4859AA, 0x1BC);
1053: 	uint32_t run_summon_kotr_main_476842 = get_relative_call(ff7_externals.run_summon_animations_5C0E4B, 0x43A);
1054: 	ff7_externals.run_summon_kotr_sub_476857 = get_relative_call(run_summon_kotr_main_476842, 0xB);
1055: 	ff7_externals.run_summon_kotr_main_loop_478031 = get_absolute_value(ff7_externals.run_summon_kotr_sub_476857, 0x1AC);
1056: 	ff7_externals.run_summon_kotr_knight_script[0] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x2D3);
1057: 	ff7_externals.run_summon_kotr_knight_script[1] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x341);
1058: 	ff7_externals.run_summon_kotr_knight_script[2] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x3EA);
1059: 	ff7_externals.run_summon_kotr_knight_script[3] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x475);
1060: 	ff7_externals.run_summon_kotr_knight_script[4] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x532);
1061: 	ff7_externals.run_summon_kotr_knight_script[5] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x5BA);
1062: 	ff7_externals.run_summon_kotr_knight_script[6] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x666);
1063: 	ff7_externals.run_summon_kotr_knight_script[7] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x6F3);
1064: 	ff7_externals.run_summon_kotr_knight_script[8] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x79D);
1065: 	ff7_externals.run_summon_kotr_knight_script[9] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x869);
1066: 	ff7_externals.run_summon_kotr_knight_script[10] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x934);
1067: 	ff7_externals.run_summon_kotr_knight_script[11] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0x9CF);
1068: 	ff7_externals.run_summon_kotr_knight_script[12] = get_absolute_value(ff7_externals.run_summon_kotr_main_loop_478031, 0xAB8);
1069: 	ff7_externals.add_kotr_camera_fn_to_effect100_fn_476AAB = (void(*)(DWORD, DWORD, WORD))get_relative_call(ff7_externals.run_summon_kotr_sub_476857, 0x1C6);
1070: 	ff7_externals.run_kotr_camera_476AFB = get_absolute_value((uint32_t)ff7_externals.add_kotr_camera_fn_to_effect100_fn_476AAB, 0xA);
1071: 
1072: 	ff7_externals.battle_sub_661000 = (vector3<int>*(*)(int))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x38);
1073: 	ff7_externals.engine_set_game_engine_rot_matrix_663673 = (void(*)(rotation_matrix*))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x169);
1074: 	ff7_externals.engine_set_game_engine_position_663707 = (void(*)(rotation_matrix*))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x176);
1075: 	ff7_externals.engine_apply_translation_with_delta_662ECC = (void(*)(vector3<short>*, vector3<int>*, int*))get_relative_call(ff7_externals.run_ifrit_movement_596702, 0x193);
1076: 	ff7_externals.byte_BCC788 = (byte*)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x1C);
1077: 	ff7_externals.ifrit_vector3_int_ptr_BCC6A8 = (vector3<int>**)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x41);
1078: 	ff7_externals.battle_ifrit_model_position = (vector3<short>*)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x12D);
1079: 	ff7_externals.ifrit_rot_matrix_BCC768 = (rotation_matrix*)get_absolute_value(ff7_externals.run_ifrit_movement_596702, 0x165);
1080: 
1081: 	// Enemy attacks
1082: 	uint32_t battle_sub_5C1484 = ff7_externals.magic_effects_fn_table[7];
1083: 	uint32_t battle_sub_55FE60 = get_relative_call(battle_sub_5C1484, 0x33E);
1084: 	uint32_t battle_handle_chocobuckle_and_confu_sub_55FE9C = get_relative_call(battle_sub_55FE60, 0x12);
1085: 	uint32_t handler_chocobuckle_sub_5609DB = get_absolute_value(battle_handle_chocobuckle_and_confu_sub_55FE9C, 0x27);
1086: 	uint32_t handler_confu_magic_sub_55FEF2 = get_absolute_value(battle_handle_chocobuckle_and_confu_sub_55FE9C, 0x36);
1087: 	ff7_externals.run_chocobuckle_main_loop_560C32 = get_absolute_value(handler_chocobuckle_sub_5609DB, 0x6F);
1088: 	ff7_externals.run_confu_main_loop_5600BE = get_absolute_value(handler_confu_magic_sub_55FEF2, 0x6C);
1089: 	uint32_t battle_escape_magic_entrypoint_5D5720 = ff7_externals.magic_effects_fn_table[25];
1090: 	uint32_t battle_escape_magic_sub_5D573F = get_relative_call(battle_escape_magic_entrypoint_5D5720, 0x15);
1091: 	ff7_externals.battle_escape_magic_init_data_5D59B0 = get_relative_call(battle_escape_magic_sub_5D573F, 0x6);
1092: 	ff7_externals.battle_escape_magic_loop_5D602A = get_absolute_value(battle_escape_magic_sub_5D573F, 0x11);
1093: 	uint32_t bomb_blast_effects_5373D0 = ff7_externals.enemy_atk_effects_fn_table[67];
1094: 	uint32_t bomb_blast_effects_sub_5373E5 = get_relative_call(bomb_blast_effects_5373D0, 0xB);
1095: 	ff7_externals.bomb_blast_black_bg_effect_537427 = get_absolute_value(bomb_blast_effects_sub_5373E5, 0x34);
1096: 	uint32_t goblin_punch_effects_572C20 = ff7_externals.enemy_skill_effects_fn_table[17];
1097: 	uint32_t goblin_punch_effects_sub_572C3A = get_relative_call(goblin_punch_effects_572C20, 0x10);
1098: 	uint32_t goblin_punch_handler_572CE0 = get_absolute_value(goblin_punch_effects_sub_572C3A, 0x70);
1099: 	uint32_t goblin_punch_main_loop_572DE7 = get_absolute_value(goblin_punch_handler_572CE0, 0x21);
1100: 	ff7_externals.goblin_punch_flash_573291 = get_absolute_value(goblin_punch_main_loop_572DE7, 0x4B);
1101: 	uint32_t death_sentence_sub_565F50 = get_relative_call(battle_sub_5C1484, 0x15F);
1102: 	uint32_t death_sentence_sub_565F9C = get_relative_call(death_sentence_sub_565F50, 0x1A);
1103: 	uint32_t death_sentence_handler_566007 = get_absolute_value(death_sentence_sub_565F9C, 0x5B);
1104: 	ff7_externals.roulette_skill_main_loop_566287 = get_absolute_value(death_sentence_handler_566007, 0x2E);
1105: 	ff7_externals.death_sentence_main_loop_5661A0 = get_absolute_value(death_sentence_handler_566007, 0x138);
1106: 	uint32_t battle_sub_561C20 = get_relative_call(battle_sub_5C1484, 0x97);
1107: 	uint32_t death_kill_sub_561C3C = get_relative_call(battle_sub_561C20, 0x10);
1108: 	uint32_t death_kill_sub_561C87 = get_absolute_value(death_kill_sub_561C3C, 0x21);
1109: 	uint32_t death_kill_main_loop_561FAF = get_absolute_value(death_kill_sub_561C87, 0x93);
1110: 	ff7_externals.death_kill_sub_loop_562C60 = get_absolute_value(death_kill_main_loop_561FAF, 0x42);
1111: 	ff7_externals.death_kill_sub_loop_5624A5 = get_absolute_value(death_kill_main_loop_561FAF, 0x5F);
1112: 	uint32_t enemy_atk_sub_439B71 = ff7_externals.enemy_atk_effects_fn_table[143];
1113: 	uint32_t enemy_atk_sub_439B86 = get_relative_call(enemy_atk_sub_439B71, 0xB);
1114: 	uint32_t enemy_atk_sub_439C6B = get_absolute_value(enemy_atk_sub_439B86, 0x1C);
1115: 	uint32_t enemy_atk_sub_439EA0 = get_relative_call(enemy_atk_sub_439C6B, 0x214);
1116: 	ff7_externals.enemy_atk_camera_sub_439EE0 = get_absolute_value(enemy_atk_sub_439EA0, 0x5);
1117: 	uint32_t enemy_atk_sub_44A5A0 = ff7_externals.enemy_atk_effects_fn_table[150];
1118: 	uint32_t enemy_atk_sub_44A719 = get_relative_call(enemy_atk_sub_44A5A0, 0xB0);
1119: 	uint32_t enemy_atk_sub_44A792 = get_relative_call(enemy_atk_sub_44A719, 0x41);
1120: 	ff7_externals.enemy_atk_camera_sub_44A7D2 = get_absolute_value(enemy_atk_sub_44A792, 0x5);
1121: 	uint32_t enemy_atk_sub_44ECB1 = ff7_externals.enemy_atk_effects_fn_table[149];
1122: 	uint32_t enemy_atk_sub_44ED00 = get_relative_call(enemy_atk_sub_44ECB1, 0x44);
1123: 	uint32_t enemy_atk_sub_44ED80 = get_relative_call(enemy_atk_sub_44ED00, 0x48);
1124: 	ff7_externals.enemy_atk_camera_sub_44EDC0 = get_absolute_value(enemy_atk_sub_44ED80, 0x5);
1125: 	uint32_t enemy_atk_sub_427A6C = ff7_externals.enemy_atk_effects_fn_table[147];
1126: 	uint32_t enemy_atk_sub_4520C1 = get_relative_call(enemy_atk_sub_427A6C, 0x4D);
1127: 	uint32_t enemy_atk_sub_452170 = get_relative_call(enemy_atk_sub_4520C1, 0xA3);
1128: 	uint32_t enemy_atk_sub_45226D = get_relative_call(enemy_atk_sub_452170, 0xDC);
1129: 	ff7_externals.enemy_atk_camera_sub_4522AD = get_absolute_value(enemy_atk_sub_45226D, 0x5);
1130: 	uint32_t enemy_atk_sub_457B20 = ff7_externals.enemy_atk_effects_fn_table[142];
1131: 	uint32_t enemy_atk_sub_457B4C = get_relative_call(enemy_atk_sub_457B20, 0x22);
1132: 	uint32_t enemy_atk_sub_457C20 = get_relative_call(enemy_atk_sub_457B4C, 0xB4);
1133: 	ff7_externals.enemy_atk_camera_sub_457C60 = get_absolute_value(enemy_atk_sub_457C20, 0x5);
1134: 	ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0 = ff7_externals.enemy_atk_effects_fn_table[59];
1135: 	uint32_t pollensalta_cold_breath_atk_main_sub_547595 = get_relative_call(ff7_externals.pollensalta_cold_breath_atk_enter_sub_5474F0, 0x99);
1136: 	uint32_t pollensalta_cold_breath_atk_callback_sub_5455E7 = get_absolute_value(pollensalta_cold_breath_atk_main_sub_547595, 0x4);
1137: 	ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0 = get_absolute_value(pollensalta_cold_breath_atk_callback_sub_5455E7, 0x7);
1138: 	ff7_externals.pollensalta_cold_breath_atk_draw_bg_effect_547B94 = get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0, 0x16F);
1139: 	ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56 = get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_main_loop_5476B0, 0x39);
1140: 	ff7_externals.pollensalta_cold_breath_atk_draw_white_dots_547E75 = (void(*)(short))get_relative_call(ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56, 0x20);
1141: 	ff7_externals.pollensalta_cold_breath_white_dots_pos = std::span((vector4<short>*) get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56, 0x79), 400);
1142: 	ff7_externals.pollensalta_cold_breath_white_dot_rgb_scalar = (short*) get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_white_dot_effect_547D56, 0x1B);
1143: 	ff7_externals.pollensalta_cold_breath_bg_texture_ctx = get_absolute_value(ff7_externals.pollensalta_cold_breath_atk_draw_bg_effect_547B94, 0x2A);
1144: 	uint32_t pandora_box_skill_enter_5667E1 = ff7_externals.enemy_skill_effects_fn_table[23];
1145: 	uint32_t pandora_box_skill_main_566806 = get_relative_call(pandora_box_skill_enter_5667E1, 0x1A);
1146: 	uint32_t pandora_box_skill_sub_566871 = get_absolute_value(pandora_box_skill_main_566806, 0x30);
1147: 	uint32_t pandora_box_skill_main_loop_566E61 = get_absolute_value(pandora_box_skill_sub_566871, 0x1F);
1148: 	ff7_externals.pandora_box_skill_draw_bg_flash_effect_568371 = get_absolute_value(pandora_box_skill_main_loop_566E61, 0x162);
1149: 
1150: 	// Texture/Material animation
1151: 	uint32_t battle_leviathan_sub_5B2F18 = get_absolute_value(ff7_externals.battle_summon_leviathan_loop, 0x50E);
1152: 	ff7_externals.battle_animate_material_texture = get_relative_call(battle_leviathan_sub_5B2F18, 0x19F);
1153: 	ff7_externals.get_global_model_matrix_buffer_66100D = (rotation_matrix*(*)())get_relative_call(ff7_externals.battle_animate_material_texture, 0x5E);
1154: 	ff7_externals.get_draw_chain_68F860 = (struc_84*(*)(struc_49*, graphics_instance*))get_relative_call(ff7_externals.battle_animate_material_texture, 0x85);
1155: 	ff7_externals.battle_sub_5D1AAA = (p_hundred*(*)(int, ff7_polygon_set*))get_relative_call(ff7_externals.battle_animate_material_texture, 0xB3);
1156: 	ff7_externals.get_alpha_from_transparency_429343 = (int(*)(int))get_relative_call(ff7_externals.battle_animate_material_texture, 0xDF);
1157: 	ff7_externals.get_stored_color_66101A = (color_ui8(*)())get_relative_call(ff7_externals.battle_animate_material_texture, 0x110);
1158: 	ff7_externals.battle_sub_68CF75 = (void(*)(char, struc_173*))get_relative_call(ff7_externals.battle_animate_material_texture, 0x1CD);
1159: 	ff7_externals.create_rot_matrix_from_word_matrix_6617E9 = (void(*)(rotation_matrix*, matrix*))get_relative_call(ff7_externals.battle_animate_material_texture, 0x38B);
1160: 	ff7_externals.battle_animate_texture_spt = get_relative_call(ff7_externals.summon_aura_effects_5C0953, 0x16A);
1161: 	ff7_externals.get_draw_chain_671C71 = (struc_84*(*)(ff7_graphics_object*))get_relative_call(ff7_externals.battle_animate_texture_spt, 0x15F);
1162: 	ff7_externals.palette_extra_data_C06A00 = (palette_extra*)get_absolute_value(ff7_externals.battle_animate_material_texture, 0x2FA);
1163: 	ff7_externals.global_game_engine_data = (ff7_game_engine_data**)get_absolute_value((uint32_t)ff7_externals.get_global_model_matrix_buffer_66100D, 0x4);
1164: 
1165: 	// Battle menu
1166: 	uint32_t battle_sub_6D83C8 = get_relative_call(ff7_externals.battle_menu_update_6CE8B3, 0x77);
1167: 	uint32_t battle_sub_6D82EA = get_relative_call(battle_sub_6D83C8, 0xE0);
1168: 	ff7_externals.display_battle_menu_6D797C = get_relative_call(battle_sub_6D82EA, 0x59);
1169: 	ff7_externals.display_tifa_slots_handler_6E3135 = (void(*)())get_relative_call(ff7_externals.display_battle_menu_6D797C, 0x1C2);
1170: 	ff7_externals.battle_draw_text_ui_graphics_objects_call = battle_main_loop + 0x289;
1171: 	ff7_externals.battle_draw_box_ui_graphics_objects_call = battle_main_loop + 0x2CF;
1172: 	ff7_externals.battle_draw_call_42908C = (void(*)(int, int))get_relative_call(battle_main_loop, 0x2CF);
1173: 	ff7_externals.battle_set_do_render_menu_call = battle_main_loop + 0x32A;
1174: 	ff7_externals.battle_set_do_render_menu = get_relative_call(battle_main_loop, 0x32A);
1175: 	ff7_externals.g_do_render_menu = (int*)get_absolute_value(ff7_externals.battle_set_do_render_menu, 0x7);
1176: 	uint32_t battle_sub_4297B9 = get_relative_call(ff7_externals.battle_sub_42D992, 0x59);
1177: 	uint32_t battle_sub_42952E = get_relative_call(battle_sub_4297B9, 0x10);
1178: 	ff7_externals.battle_sub_42F3E8 = get_relative_call(battle_sub_42952E, 0xCD);
1179: 	uint32_t battle_sub_5B9B30 = get_relative_call(ff7_externals.battle_sub_42F3E8, 0x756);
1180: 	ff7_externals.battle_handle_status_effect_anim_5BA7C0 = get_relative_call(battle_sub_5B9B30, 0xB2);
1181: 	ff7_externals.battle_handle_player_mark_5B9C8E = get_relative_call(battle_sub_5B9B30, 0x123);
1182: 	ff7_externals.battle_update_targeting_info_6E6291 = get_relative_call(ff7_externals.battle_sub_6DB0EE, 0x1F9);
1183: 	ff7_externals.targeting_actor_id_DC3C98 = (byte*)get_absolute_value(ff7_externals.battle_update_targeting_info_6E6291, 0x684);
1184: 	ff7_externals.battle_menu_closing_window_box_6DAEF0 = get_relative_call(ff7_externals.battle_sub_6DB0EE, 0x1D8);
1185: 
1186: 	// 3D Battleground
1187: 	ff7_externals.update_3d_battleground = get_relative_call(ff7_externals.battle_sub_42D992, 0x4);
1188: 	ff7_externals.battleground_shake_train_42F088 = (void(*)())get_relative_call(ff7_externals.update_3d_battleground, 0xBF);
1189: 	ff7_externals.battleground_vertical_scrolling_42F126 = get_relative_call(ff7_externals.update_3d_battleground, 0x783);
1190: 	ff7_externals.battleground_midgar_flashback_rain_5BDC4F = get_relative_call(ff7_externals.update_3d_battleground, 0x3C);
1191: 
1192: 	// World externals
1193: 	ff7_externals.world_dword_DE68FC = (void(**)())get_absolute_value(ff7_externals.world_loop_74BE49, 0x123);
1194: 	ff7_externals.world_exit_74BD77 = get_absolute_value(main_loop, 0x993);
1195: 	ff7_externals.world_exit_destroy_graphics_objects_75A921 = (void(*)())get_relative_call(ff7_externals.world_exit_74BD77, 0x11);
1196: 	ff7_externals.world_init_variables_74E1E9 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x108);
1197: 	ff7_externals.world_sub_7641A7 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x210);
1198: 	ff7_externals.world_init_load_wm_bot_block_7533AF = (void(*)())get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x296);
1199: 	ff7_externals.run_world_event_scripts = get_relative_call(ff7_externals.world_sub_7641A7, 0x1D);
1200: 	ff7_externals.run_world_event_scripts_system_operations = get_relative_call(ff7_externals.run_world_event_scripts, 0xC7);
1201: 	ff7_externals.pop_world_script_stack = (int(*)())get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0x44);
1202: 	ff7_externals.world_animate_all_models = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5A1);
1203: 	ff7_externals.world_animate_single_model = get_relative_call(ff7_externals.world_animate_all_models, 0x20);
1204: 	ff7_externals.run_world_snake_ai_script_7562FF = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5AB);
1205: 	ff7_externals.world_sub_75EF46 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x44E);
1206: 	ff7_externals.world_sub_767540 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5BE);
1207: 	ff7_externals.world_sub_767641 = get_relative_call(ff7_externals.world_sub_767540, 0xCB);
1208: 	ff7_externals.get_world_encounter_rate = (int(*)())get_relative_call(ff7_externals.world_sub_767641, 0x110);
1209: 	ff7_externals.update_world_snake_position_7564CD = get_relative_call(ff7_externals.run_world_snake_ai_script_7562FF, 0x151);
1210: 	ff7_externals.is_update_snake_enabled_7562A9 = get_relative_call(ff7_externals.run_world_snake_ai_script_7562FF, 0x12);
1211: 	ff7_externals.animate_world_snake_75692A = get_relative_call(ff7_externals.run_world_snake_ai_script_7562FF, 0x16C);
1212: 	ff7_externals.sub_753366 = (bool (*)(short, short))get_relative_call(ff7_externals.animate_world_snake_75692A, 0x93);
1213: 	ff7_externals.world_draw_snake_texture_75D544 = (void (*)(short, short, short, short, world_snake_graphics_data*, short))get_relative_call(ff7_externals.animate_world_snake_75692A, 0x159);
1214: 	ff7_externals.world_snake_data_position_ptr_E2A18C = (vector4<short> **)get_absolute_value(ff7_externals.update_world_snake_position_7564CD, 0x2F);
1215: 	ff7_externals.world_snake_data_position_E29F80 = (vector4<short> *)get_absolute_value((uint32_t)ff7_externals.animate_world_snake_75692A, 0x2A);
1216: 	ff7_externals.world_snake_graphics_data_E2A490 = (world_snake_graphics_data *)get_absolute_value(ff7_externals.animate_world_snake_75692A, 0x3A);
1217: 	ff7_externals.world_snake_graphics_data_end_E2A6D0 = (world_snake_graphics_data *)get_absolute_value(ff7_externals.animate_world_snake_75692A, 0x4C);
1218: 	ff7_externals.snake_position_size_of_array_E2A100 = (vector4<short> *)get_absolute_value(ff7_externals.update_world_snake_position_7564CD, 0x3C);
1219: 	ff7_externals.world_opcode_message_sub_75EE86 = get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0xB6D);
1220: 	ff7_externals.world_opcode_ask_sub_75EEBB = get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0xBA1);
1221: 	ff7_externals.world_opcode_message = get_relative_call(ff7_externals.world_sub_75EF46, 0x8C);
1222: 	ff7_externals.world_opcode_ask = get_relative_call(ff7_externals.world_sub_75EF46, 0xAF);
1223: 	ff7_externals.world_text_box_window_opening_769A66 = get_relative_call(ff7_externals.world_opcode_message, 0x5A);
1224: 	ff7_externals.world_text_box_window_paging_769C02 = get_relative_call(ff7_externals.world_opcode_message, 0x6D);
1225: 	ff7_externals.world_text_box_reverse_paging_76ABE9 = get_relative_call(ff7_externals.world_opcode_message, 0x80);
1226: 	ff7_externals.world_text_box_window_closing_76ADF7 = get_relative_call(ff7_externals.world_opcode_message, 0x235);
1227: 	ff7_externals.world_update_player_74EA48 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x2D7);
1228: 	ff7_externals.world_get_player_model_id = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x1B);
1229: 	ff7_externals.world_get_current_key_input_status = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x4A);
1230: 	ff7_externals.world_get_player_walkmap_type = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x7DF);
1231: 	ff7_externals.world_get_player_walkmap_region = (int(*)())get_relative_call(ff7_externals.world_sub_767641, 0x2B);
1232: 	ff7_externals.world_sub_753D00 = (void(*)(vector3<short>*, short))get_relative_call(ff7_externals.run_world_event_scripts_system_operations, 0xDF9);
1233: 	ff7_externals.world_update_model_movement_762E87 = (void(*)(int, int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xCDF);
1234: 	ff7_externals.engine_apply_rotation_to_transform_matrix_6628DE = (void(*)(vector3<short>*, rotation_matrix*))get_relative_call(ff7_externals.world_update_player_74EA48, 0x733);
1235: 	ff7_externals.world_is_player_model_bitmask = (bool(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x9F);
1236: 	ff7_externals.world_copy_player_pos_to_param_762798 = (void(*)(vector4<int>*))get_relative_call(ff7_externals.world_update_player_74EA48, 0x7B8);
1237: 	ff7_externals.world_set_current_entity_to_player_entity = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x16);
1238: 	ff7_externals.world_add_y_pos_to_current_entity_761F22 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x7FD);
1239: 	ff7_externals.world_add_delta_movement_due_to_bridge_7591C2 = (void(*)(int*, int*))get_relative_call(ff7_externals.world_update_player_74EA48, 0xCAA);
1240: 	ff7_externals.world_current_entity_model_collision_detection_with_other_models_76296E = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xCE7);
1241: 	ff7_externals.world_get_unknown_flag_75335C = (int(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x3D);
1242: 	ff7_externals.world_get_minimap_mask = (short(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xBC8);
1243: 	ff7_externals.world_set_minimap_mask = (void(*)(short))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC00);
1244: 	ff7_externals.world_set_facing_and_direction_to_current_entity = (void(*)(short))get_relative_call(ff7_externals.world_update_player_74EA48, 0x6F3);
1245: 	ff7_externals.world_is_current_entity_animated_761F44 = (bool(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0x8D0);
1246: 	ff7_externals.world_sub_74D6BB = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xB71);
1247: 	ff7_externals.world_sub_74D6F6 = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xB82);
1248: 	ff7_externals.world_sub_762F75 = (void(*)(short, short, short))get_relative_call(ff7_externals.world_update_player_74EA48, 0x9A3);
1249: 	ff7_externals.world_run_special_opcode_7640BC = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC30);
1250: 	ff7_externals.world_set_camera_fade_speed_755B97 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC56);
1251: 	ff7_externals.world_set_world_control_lock_74D438 = (void(*)(int, int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC62);
1252: 	ff7_externals.world_sub_74C980 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xC76);
1253: 	ff7_externals.world_sub_753BE8 = (void(*)())get_relative_call(ff7_externals.world_update_player_74EA48, 0xC8A);
1254: 	ff7_externals.world_music_set_frequency_all_channels_75E6A8 = (void(*)(byte, char))get_relative_call(ff7_externals.world_update_player_74EA48, 0xB05);
1255: 	ff7_externals.world_sfx_play_or_stop_75E6CC = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0xCCF);
1256: 	ff7_externals.world_set_camera_view_type_74D3D1 = (void(*)(int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x79);
1257: 
1258: 	ff7_externals.world_compute_all_models_data_76323A = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5A1);
1259: 	ff7_externals.world_compute_3d_model_data_76328F = get_relative_call(ff7_externals.world_compute_all_models_data_76323A, 0x20);
1260: 	ff7_externals.world_sub_74D319 = get_relative_call(ff7_externals.world_compute_3d_model_data_76328F, 0x7D4);
1261: 	ff7_externals.world_sub_762F9A = get_relative_call(ff7_externals.world_compute_3d_model_data_76328F, 0x419);
1262: 
1263: 	ff7_externals.world_update_camera_74E8CE = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x40F);
1264: 	ff7_externals.world_snowstorm_get_camera_movement_758B12 = (int(*)(int, int))get_relative_call(ff7_externals.world_update_player_74EA48, 0x38C);
1265: 	ff7_externals.world_get_camera_rotation_x_74F916 = (int(*)())get_relative_call(ff7_externals.world_update_camera_74E8CE, 0x6);
1266: 	ff7_externals.world_highwind_height_lowerbound_DF5420 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x7EE);
1267: 	ff7_externals.world_mode_E045E4 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xC21);
1268: 	ff7_externals.previous_player_direction_DF5434 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xA5B);
1269: 	ff7_externals.world_is_control_enabled_DE6B5C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x25);
1270: 	ff7_externals.world_special_delta_movement_DE6A18 = (short*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x5D6);
1271: 	ff7_externals.world_y_player_pos_flag_DE6A14 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x875);
1272: 	ff7_externals.world_unk_rotation_value_E045E0 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x972);
1273: 	ff7_externals.world_event_current_entity_ptr_E39AD8 = (world_event_data**)get_absolute_value((uint32_t)ff7_externals.world_update_model_movement_762E87, 0x5);
1274: 	ff7_externals.world_event_current_entity_ptr_E3A7CC = (world_event_data**)get_absolute_value(ff7_externals.run_world_event_scripts_system_operations, 0x8E6);
1275: 	ff7_externals.world_progress_E28CB4 = (int*)get_absolute_value((uint32_t)ff7_externals.world_init_load_wm_bot_block_7533AF, 0xA1);
1276: 	ff7_externals.is_wait_frames_zero_E39BC0 = (int*)get_absolute_value(ff7_externals.run_world_event_scripts_system_operations, 0xD46);
1277: 	ff7_externals.world_prev_key_input_status_DFC470 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x35A);
1278: 	ff7_externals.world_map_type_E045E8 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x66);
1279: 	ff7_externals.world_movement_multiplier_DFC480 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xDA);
1280: 	ff7_externals.world_camera_var1_DF542C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x1BD);
1281: 	ff7_externals.world_camera_var2_DE6B4C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xD2F);
1282: 	ff7_externals.world_camera_var3_DE6A0C = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x179);
1283: 	ff7_externals.world_camera_viewtype_DFC4B4 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x54);
1284: 	ff7_externals.world_camera_front_DFC484 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0x39E);
1285: 	ff7_externals.world_camera_rotation_y_DFC474 = (int*)get_absolute_value(ff7_externals.world_update_player_74EA48, 0xD51);
1286: 	ff7_externals.world_camera_position_z_DFC478 = (int*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x79);
1287: 	ff7_externals.world_camera_delta_y_DE6A04 = (int*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0xAB);
1288: 	ff7_externals.world_current_camera_rotation_x_DE7418 = (short*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x117);
1289: 	ff7_externals.world_camera_rotation_z_DE6B70 = (int*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x149);
1290: 	ff7_externals.world_camera_x_rotation_array_E37120 = std::span((short*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x103), 512);
1291: 	ff7_externals.world_camera_position_matrix_DE6A20 = (rotation_matrix*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0xBF);
1292: 	ff7_externals.world_camera_direction_matrix_DFC448 = (rotation_matrix*)get_absolute_value(ff7_externals.world_update_camera_74E8CE, 0x162);
1293: 	ff7_externals.world_sub_75A1C6 = get_relative_call(ff7_externals.world_init_variables_74E1E9, 0x3A);
1294: 	ff7_externals.world_load_graphics_objects_75A5D5 = get_relative_call(ff7_externals.world_sub_75A1C6, 0x61);
1295: 	ff7_externals.world_init_load_map_meshes_graphics_objects_75A283 = get_relative_call(ff7_externals.world_load_graphics_objects_75A5D5, 0x340);
1296: 	ff7_externals.world_wm0_overworld_draw_all_74C179 = (void(*)())get_absolute_value(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283, 0xA7);
1297: 	ff7_externals.world_wm2_underwater_draw_all_74C3F0 = (void(*)())get_absolute_value(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283, 0xDF);
1298: 	ff7_externals.world_wm3_snowstorm_draw_all_74C589 = (void(*)())get_absolute_value(ff7_externals.world_init_load_map_meshes_graphics_objects_75A283, 0x117);
1299: 	ff7_externals.world_draw_all_3d_model_74C6B0 =  get_relative_call((uint32_t)ff7_externals.world_wm0_overworld_draw_all_74C179, 0x155);
1300: 	ff7_externals.world_draw_fade_quad_75551A = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x554);
1301: 	ff7_externals.world_sub_75079D = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x421);
1302: 	ff7_externals.world_sub_751EFC = get_relative_call(ff7_externals.world_sub_75079D, 0x1FB);
1303: 	ff7_externals.world_sub_75C02B = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x5A6);
1304: 	ff7_externals.world_sub_75C0FD = get_relative_call(ff7_externals.world_sub_75C02B, 0x43);
1305: 	ff7_externals.world_sub_75C283 = get_relative_call(ff7_externals.world_sub_75C0FD, 0x175);
1306: 	ff7_externals.world_culling_bg_meshes_75F263 = get_relative_call(ff7_externals.world_sub_751EFC, 0x7C6);
1307: 	ff7_externals.world_submit_draw_bg_meshes_75F68C = get_relative_call(ff7_externals.world_sub_751EFC, 0x7FD);
1308: 	ff7_externals.world_compute_skybox_data_754100 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x537);
1309: 	ff7_externals.world_submit_draw_clouds_and_meteor_7547A6 = get_relative_call(ff7_externals.world_mode_loop_sub_74DB8C, 0x547);
1310: 	ff7_externals.world_sub_75F0AD = get_relative_call(ff7_externals.world_sub_751EFC, 0x551);
1311: 	ff7_externals.world_sub_75042B = get_relative_call(ff7_externals.world_compute_3d_model_data_76328F, 0x37D);
1312: 	ff7_externals.world_player_pos_E04918 = (vector4<int>*)get_absolute_value(ff7_externals.world_sub_75042B, 0xE);
1313: 		ff7_externals.sub_74C9A5 = (int (*)())get_relative_call(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6, 0x09);
1314: 	ff7_externals.is_meteor_flag_on_E2AAE4 = (int*)get_absolute_value(ff7_externals.world_submit_draw_clouds_and_meteor_7547A6, 0x592);
1315: 	ff7_externals.engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF = get_relative_call(ff7_externals.world_compute_skybox_data_754100, 0x85);
1316: 	ff7_externals.engine_apply_4x4_matrix_product_between_matrices_66C6CD = (void (*)(struct matrix *, struct matrix *, struct matrix *))get_relative_call(ff7_externals.engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF, 0x16);
1317: 	ff7_externals.world_copy_position_75042B = (void (*)(vector4<int>* a1))get_relative_call(ff7_externals.world_sub_75C0FD, 0x52);
1318: 	ff7_externals.get_world_camera_front_rot_74D298 = (int (*)())get_relative_call(ff7_externals.world_sub_75C0FD, 0xF);
1319: 	ff7_externals.engine_apply_rotation_to_rot_matrix_662AD8 = (void (*)(vector3<short>*, transform_matrix*))get_relative_call(ff7_externals.world_sub_75C0FD, 0x28);
1320: 	ff7_externals.world_get_world_current_camera_rotation_x_74D3C6 = (short (*)())get_relative_call(ff7_externals.world_sub_75C0FD, 0x30);
1321: 	ff7_externals.world_submit_draw_effects_75C283 = (int (_stdcall *)(world_texture_data *, int, vector3<short>*, short))get_relative_call(ff7_externals.world_sub_75C0FD, 0x175);
1322: 	ff7_externals.dword_E35648 = (world_effect_2d_list_node**)get_absolute_value(ff7_externals.world_sub_75C0FD, 0x5B);
1323: 	ff7_externals.byte_96D6A8 = (byte*)get_absolute_value(ff7_externals.world_sub_75C0FD, 0x169);
1324: 
1325: 	// Swirl externals
1326: 	ff7_externals.swirl_main_loop = swirl_main_loop;
1327: 	ff7_externals.swirl_loop_sub_4026D4 = get_relative_call(swirl_main_loop, 0xC9);
1328: 	ff7_externals.swirl_enter_40164E = get_absolute_value(main_loop, 0x254);
1329: 	ff7_externals.swirl_enter_sub_401810 = get_relative_call(ff7_externals.swirl_enter_40164E, 0x160);
1330: 
1331: 	// --------------------------------
1332: 
1333: 	// battle dialogues
1334: 	ff7_externals.add_text_to_display_queue = get_relative_call(ff7_externals.battle_sub_42CBF9, 0x1C7);
1335: 	ff7_externals.update_display_text_queue = get_relative_call(ff7_externals.battle_sub_42D808, 0x2B);
1336: 	ff7_externals.set_battle_text_active = get_relative_call(ff7_externals.update_display_text_queue, 0x14A);
1337: 	ff7_externals.battle_sfx_play_effect_430D14 = get_relative_call(ff7_externals.update_display_text_queue, 0x46);
1338: 	ff7_externals.battle_sub_66C3BF = (int(*)())get_relative_call(ff7_externals.update_display_text_queue, 0x139);
1339: 	ff7_externals.battle_sub_43526A = get_relative_call(ff7_externals.battle_loop, 0x475);
1340: 	ff7_externals.battle_sub_5C8931 = get_relative_call(ff7_externals.battle_sub_43526A, 0x1F0);
1341: 	ff7_externals.run_enemy_ai_script = get_relative_call(ff7_externals.battle_sub_5C8931, 0xA0);
1342: 	ff7_externals.enqueue_script_action = get_relative_call(ff7_externals.run_enemy_ai_script, 0xB7F);
1343: 	ff7_externals.battle_sub_41B577 = get_relative_call(ff7_externals.battle_enter, 0x17);
1344: 	ff7_externals.battle_sub_41CCB2 = get_relative_call(ff7_externals.battle_sub_41B577, 0xB);
1345: 
1346: 	ff7_externals.battle_display_text_queue = std::span((battle_text_data*)get_absolute_value(ff7_externals.add_text_to_display_queue, 0x25), 64);
1347: 	ff7_externals.battle_context = (battle_ai_context*)get_absolute_value(ff7_externals.battle_sub_41CCB2, 0x5F);
1348: 	ff7_externals.anim_event_queue = std::span((battle_anim_event*)get_absolute_value(ff7_externals.battle_sub_42CBF9, 0x23), 64);
1349: 	ff7_externals.anim_event_index = (byte*)get_absolute_value(ff7_externals.battle_sub_42CBF9, 0x19);
1350: 	ff7_externals.g_is_battle_running_9AD1AC = (int*)get_absolute_value(battle_main_loop, 0x247);
1351: 	ff7_externals.field_battle_word_BF2E08 = (WORD*)get_absolute_value(ff7_externals.update_display_text_queue, 0xA);
1352: 	ff7_externals.field_battle_word_BF2032 = (WORD*)get_absolute_value(ff7_externals.update_display_text_queue, 0x12C);
1353: 	ff7_externals.g_active_actor_id = (byte*)get_absolute_value(ff7_externals.display_battle_action_text_42782A, 0x52);
1354: 	// --------------------------------
1355: 
1356: 	// Widescreen
1357: 	ff7_externals.field_culling_model_639252 = get_relative_call(ff7_externals.field_animate_3d_models_6392BB, 0x203);
1358: 	ff7_externals.field_sub_63AC66 = get_relative_call(ff7_externals.sub_60DF96, 0xB0);
1359: 	ff7_externals.field_sub_63AC3F = (void(*)(int, int, int, int))get_relative_call(ff7_externals.field_sub_63AC66, 0xD5);
1360: 
1361: 	ff7_externals.battle_draw_quad_5BD473 = get_relative_call(ff7_externals.battle_boss_death_call_5BD436, 0x16);
1362: 	ff7_externals.battle_sub_5895E0 = ff7_externals.enemy_atk_effects_fn_table[119];
1363: 	ff7_externals.battle_sub_589827 = get_relative_call(ff7_externals.battle_sub_5895E0, 0x10D);
1364: 	ff7_externals.battle_sub_58AC59 = get_absolute_value(ff7_externals.battle_sub_589827, 0x64);
1365: 	ff7_externals.battle_sub_58ACB9 = get_relative_call(ff7_externals.battle_sub_58AC59, 0x22);
1366: 	ff7_externals.ifrit_sub_595A05 = get_absolute_value(run_ifrit_main_loop_593A95, 0x51B);
1367: 	ff7_externals.engine_draw_sub_66A47E = (void(*)(int))get_relative_call(ff7_externals.ifrit_sub_595A05, 0x930);
1368: 	ff7_externals.battle_viewport_height = (int*)get_absolute_value(battle_main_loop, 0x151);
1369: 	ff7_externals.neo_bahamut_main_loop_48DA7A = get_absolute_value(run_bahamut_neo_sub_48C60B, 0xF3);
1370: 	ff7_externals.neo_bahamut_effect_sub_490F2A = get_absolute_value(ff7_externals.neo_bahamut_main_loop_48DA7A, 0x2CD);
1371: 	ff7_externals.odin_gunge_effect_sub_4A4BE6 = get_absolute_value(run_summon_odin_gunge_main_loop_4A0B6D, 0xA7);
1372: 	ff7_externals.odin_gunge_effect_sub_4A3A2E = get_absolute_value(run_summon_odin_gunge_main_loop_4A0B6D, 0x2D8);
1373: 	ff7_externals.typhoon_sub_4D6FF8 = get_relative_call(run_typhoon_main_loop_4D69A6, 0x4B7);
1374: 	ff7_externals.typhoon_effect_sub_4D7044 = get_absolute_value(ff7_externals.typhoon_sub_4D6FF8, 0xF);
1375: 	ff7_externals.typhoon_effect_sub_4DB15F = get_absolute_value(run_typhoon_main_loop_4D69A6, 0x416);
1376: 	ff7_externals.fat_chocobo_sub_5096F3 = get_absolute_value(run_fat_chocobo_main_loop_508BED, 0x110);
1377: 	uint32_t barret_limit_3_1_main_46FF90 = ff7_externals.limit_break_effects_fn_table[11];
1378: 	uint32_t barret_limit_3_1_sub_46FFAC = get_relative_call(barret_limit_3_1_main_46FF90, 0x10);
1379: 	uint32_t barret_limit_3_1_sub_470031 = get_absolute_value(barret_limit_3_1_sub_46FFAC, 0x44);
1380: 	ff7_externals.barret_limit_3_1_sub_4700F7 = get_absolute_value(barret_limit_3_1_sub_470031, 0x36);
1381: 	uint32_t shadow_flare_enemy_skill_entry_576FD0 = ff7_externals.enemy_skill_effects_fn_table[22];
1382: 	uint32_t shadow_flare_enemy_skill_sub_576FEA = get_relative_call(shadow_flare_enemy_skill_entry_576FD0, 0x10);
1383: 	uint32_t shadow_flare_enemy_skill_main_loop_57708E = get_absolute_value(shadow_flare_enemy_skill_sub_576FEA, 0x70);
1384: 	ff7_externals.shadow_flare_draw_white_bg_57747E = get_relative_call(shadow_flare_enemy_skill_main_loop_57708E, 0x6C);
1385: 
1386: 	ff7_externals.cdcheck_enter_sub = get_absolute_value(main_loop, 0x390);
1387: 	ff7_externals.credits_submit_draw_fade_quad_7AA89B = get_relative_call(credits_main_loop, 0xD9);
1388: 	ff7_externals.get_button_pressed = (int(*)(int))get_relative_call(credits_main_loop, 0x14C);
1389: 	ff7_externals.credits_main_loop = credits_main_loop;
1390: 	ff7_externals.menu_submit_draw_fade_quad_6CD64E = get_relative_call(ff7_externals.menu_battle_end_sub_6C9543, 0x104);
1391: 	ff7_externals.highway_submit_fade_quad_659532 = get_relative_call(ff7_externals.highway_loop_sub_650F36, 0x126);
1392: 	ff7_externals.chocobo_init_viewport_values_76D320 = get_relative_call(main_init_loop, 0x38B);
1393: 	uint32_t chocobo_sub_77C462 = get_relative_call(chocobo_main_loop, 0x5E);
1394: 	uint32_t chocobo_sub_77946A = get_relative_call(chocobo_sub_77C462, 0x649);
1395: 	ff7_externals.chocobo_submit_draw_fade_quad_77B1CE = get_relative_call(chocobo_sub_77946A, 0x33);
1396: 	ff7_externals.chocobo_submit_draw_water_quad_77A7D0 = get_relative_call(chocobo_sub_77C462, 0x30B);
1397: 	ff7_externals.generic_submit_quad_graphics_object_671D2A = (void(*)(int, int, int, int, int, int, float, DWORD*))get_relative_call(ff7_externals.chocobo_submit_draw_water_quad_77A7D0, 0x9F);
1398: 	ff7_externals.chocobo_fade_quad_data_97A498 = (byte*)get_absolute_value(chocobo_sub_77946A, 0x2F);
1399: 	ff7_externals.snowboard_draw_sky_and_mountains_72DAF0 = get_relative_call(ff7_externals.snowboard_loop_sub_72381C, 0x27);
1400: 	ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F = get_relative_call(ff7_externals.snowboard_draw_sky_and_mountains_72DAF0, 0x24D);
1401: 	ff7_externals.snowboard_sky_quad_pos_x_7B7DB8 = (float*)get_absolute_value(ff7_externals.snowboard_submit_draw_sky_quad_graphics_object_72E31F, 0x2E);
1402: 	uint32_t snowboard_callable_submit_draw_sub_723F60 = get_absolute_value(ff7_externals.snowboard_loop_sub_72381C, 0x10E);
1403: 	uint32_t snowboard_callable_draw_black_quad_7241E5 = get_absolute_value(snowboard_callable_submit_draw_sub_723F60, 0x15C);
1404: 	uint32_t snowboard_submit_draw_fade_black_quad_729926 = get_relative_call(snowboard_callable_draw_black_quad_7241E5, 0x31);
1405: 	ff7_externals.snowboard_submit_draw_black_quad_graphics_object_72DD94 = get_relative_call(snowboard_submit_draw_fade_black_quad_729926, 0xD);
1406: 	uint32_t snowboard_callable_draw_white_quad_7240D6 = get_absolute_value(snowboard_callable_submit_draw_sub_723F60, 0x165);
1407: 	uint32_t snowboard_submit_draw_white_fade_quad_729912 = get_relative_call(snowboard_callable_draw_white_quad_7240D6, 0x38);
1408: 	ff7_externals.snowboard_submit_draw_white_fade_quad_graphics_object_72DD53 = get_relative_call(snowboard_submit_draw_white_fade_quad_729912, 0xD);
1409: 	uint32_t snowboard_submit_draw_opaque_quad_72993A = get_relative_call(snowboard_callable_draw_white_quad_7240D6, 0xCC);
1410: 	ff7_externals.snowboard_submit_draw_opaque_quad_graphics_object_72DDD5 = get_relative_call(snowboard_submit_draw_opaque_quad_72993A, 0xD);
1411: 	ff7_externals.sub_735220 = get_relative_call(ff7_externals.snowboard_loop_sub_72381C, 0xBF);
1412: 	ff7_externals.sub_735332 = get_relative_call(ff7_externals.sub_735220, 0xE6);
1413: 	ff7_externals.snowboard_parse_model_vertices_732159 = get_relative_call(ff7_externals.sub_735332, 0x29);
1414: 	ff7_externals.sub_7322D6 = (char* (*)(tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x10E);
1415: 	ff7_externals.sub_732429 = (char* (*)(tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x12A);
1416: 	ff7_externals.sub_732546 = (char* (__thiscall *)(snowboard_this*, tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x162);
1417: 	ff7_externals.sub_732BB9 = (char* (*)(tmd_primitive_packet*, int, int))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x146);
1418: 	ff7_externals.sub_733479 = (matrix* (__thiscall *)(void*, const matrix*))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0x5F);
1419: 	ff7_externals.sub_733564 = (point4d* (__thiscall *)(void*, vector3<float>*, point4d*))get_relative_call(ff7_externals.snowboard_parse_model_vertices_732159, 0xDC);
1420: 	ff7_externals.snowboard_global_object_off_926290 = (DWORD*)get_absolute_value(ff7_externals.snowboard_parse_model_vertices_732159, 0x55);
1421: 	// --------------------------------
1422: 
1423: 	// Steam achievement
1424: 	uint32_t sub_434347 = get_relative_call(ff7_externals.battle_loop, 0x484);
1425: 	uint32_t* pointer_functions_7C2980 = (uint32_t*)get_absolute_value(sub_434347, 0x19C);
1426: 	ff7_externals.battle_enemy_killed_sub_433BD2 = pointer_functions_7C2980[0];
1427: 	ff7_externals.battle_sub_5C7F94 = get_relative_call(ff7_externals.battle_enemy_killed_sub_433BD2, 0x2AF);
1428: 	ff7_externals.menu_battle_end_mode = (uint16_t*)get_absolute_value(ff7_externals.menu_battle_end_sub_6C9543, 0x2C);
1429: 	uint32_t menu_sub_6CBD54 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0xC1);
1430: 	ff7_externals.menu_sub_71FF95 = get_relative_call(menu_sub_6CBD54, 0x7);
1431: 	ff7_externals.menu_shop_loop = get_relative_call(ff7_externals.menu_sub_71FF95, 0x84);
1432: 	if (version == VERSION_FF7_102_US) {
1433: 		ff7_externals.get_materia_gil = get_relative_call(ff7_externals.menu_shop_loop, 0x548);
1434: 	} else {
1435: 		ff7_externals.get_materia_gil = get_relative_call(ff7_externals.menu_shop_loop, 0x5C4);
1436: 	}
1437: 	ff7_externals.opcode_increase_gil_call = get_relative_call(ff7_externals.opcode_goldu, 0x38);
1438: 
1439: 	ff7_externals.display_battle_action_text_sub_6D71FA = get_relative_call(ff7_externals.display_battle_action_text_42782A, 0x77);
1440: 
1441: 	ff7_externals.opcode_add_materia_inventory_call = get_relative_call(ff7_externals.opcode_smtra, 0x72);
1442: 	ff7_externals.menu_sub_6CBCF3 = get_relative_call(ff7_externals.opcode_add_materia_inventory_call, 0x43);
1443: 	ff7_externals.menu_sub_705D16 = ff7_externals.menu_subs_call_table[4];
1444: 	ff7_externals.menu_sub_6CC17F = get_relative_call(ff7_externals.menu_sub_705D16, 0x1729);
1445: 
1446: 	ff7_externals.menu_decrease_item_quantity = get_relative_call(ff7_externals.opcode_dlitm, 0x38);
1447: 
1448: 	ff7_externals.sub_60FA7D = get_relative_call(ff7_externals.opcode_setbyte, 0x14);
1449: 
1450: 	uint32_t menu_sub_6CBD65 = get_relative_call(ff7_externals.menu_sub_6CDA83, 0x54);
1451: 	uint32_t menu_sub_722393 = get_relative_call(menu_sub_6CBD65, 0x4);
1452: 	ff7_externals.menu_sub_7212FB = get_relative_call(menu_sub_722393, 0x8B);
1453: 	switch(version) {
1454: 		case VERSION_FF7_102_US:
1455: 		case VERSION_FF7_102_SP:
1456: 			ff7_externals.load_save_file = get_relative_call(ff7_externals.menu_sub_7212FB, 0xE9D);
1457: 			break;
1458: 		case VERSION_FF7_102_DE:
1459: 		case VERSION_FF7_102_FR:
1460: 			ff7_externals.load_save_file = get_relative_call(ff7_externals.menu_sub_7212FB, 0xEC5);
1461: 			break;
1462: 	}
1463: 
1464: 	// --------------------------------
1465: }
1466: 
1467: inline void ff7_data(struct ff7_game_obj* game_object)
1468: {
1469: 	num_modes = sizeof(ff7_modes) / sizeof(ff7_modes[0]);
1470: 
1471: 	ff7_find_externals(game_object);
1472: 
1473: 	memcpy(modes, ff7_modes, sizeof(ff7_modes));
1474: 
1475: 	text_colors[TEXTCOLOR_GRAY] = 0x08;
1476: 	text_colors[TEXTCOLOR_BLUE] = 0x01;
1477: 	text_colors[TEXTCOLOR_RED] = 0x04;
1478: 	text_colors[TEXTCOLOR_PINK] = 0x05;
1479: 	text_colors[TEXTCOLOR_GREEN] = 0x02;
1480: 	text_colors[TEXTCOLOR_LIGHT_BLUE] = 0x09;
1481: 	text_colors[TEXTCOLOR_YELLOW] = 0x0E;
1482: 	text_colors[TEXTCOLOR_WHITE] = 0x0F;
1483: }
</file>

<file path="src/ff7_opengl.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //    Copyright (C) 2023 Marcin 'Maki' Gomulak                              //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "cfg.h"
 25: #include "ff7.h"
 26: #include "patch.h"
 27: #include "ff7/defs.h"
 28: #include "ff7_data.h"
 29: #include "ff7/widescreen.h"
 30: #include "ff7/time.h"
 31: #include "ff7/battle/defs.h"
 32: #include "ff7/field/defs.h"
 33: #include "ff7/world/defs.h"
 34: 
 35: unsigned char midi_fix[] = {0x8B, 0x4D, 0x14};
 36: WORD snowboard_fix[] = {0x0F, 0x10, 0x0F};
 37: 
 38: uint32_t ff7_credits_loop_gfx_begin_scene(uint32_t unknown, struct game_obj *game_object)
 39: {
 40: 	if (drawFFNxLogoFrame(game_object)) {
 41: 		if (ff7_externals.get_button_pressed(-1)) {
 42: 			stopDrawFFNxLogo();
 43: 		}
 44: 
 45: 		return 0;
 46: 	}
 47: 
 48: 	return common_begin_scene(unknown, game_object);
 49: }
 50: 
 51: void ff7_init_hooks(struct game_obj *_game_object)
 52: {
 53: 	struct ff7_game_obj *game_object = (struct ff7_game_obj *)_game_object;
 54: 
 55: 	common_externals.add_texture_format = game_object->externals->add_texture_format;
 56: 	common_externals.assert_calloc = game_object->externals->assert_calloc;
 57: 	common_externals.assert_malloc = game_object->externals->assert_malloc;
 58: 	common_externals.assert_free = game_object->externals->assert_free;
 59: 	common_externals.create_palette_for_tex = game_object->externals->create_palette_for_tex;
 60: 	common_externals.create_texture_format = game_object->externals->create_texture_format;
 61: 	common_externals.create_texture_set = game_object->externals->create_texture_set;
 62: 	common_externals.generic_light_polygon_set = game_object->externals->generic_light_polygon_set;
 63: 	common_externals.generic_load_group = game_object->externals->generic_load_group;
 64: 	common_externals.get_game_object = game_object->externals->get_game_object;
 65: 	ff7_externals.sub_6A2865 = game_object->externals->sub_6A2865;
 66: 	common_externals.make_pixelformat = game_object->externals->make_pixelformat;
 67: 
 68: 	ff7_data(game_object);
 69: 
 70: 	if (game_width == 1280)
 71: 		MessageBoxA(gameHwnd, "Using this driver with the old high-res patch is NOT recommended, there will be glitches.", "Warning", 0);
 72: 
 73: 	game_object->d3d2_flag = 1;
 74: 	game_object->nvidia_fix = 0;
 75: 
 76: 	// Load Models atoi function
 77: 	replace_call_function(ff7_externals.field_load_models_atoi, ff7_field_load_models_atoi);
 78: 
 79: 	// DirectInput hack, try to reacquire on any error
 80: 	memset_code(ff7_externals.dinput_getdata2 + 0x65, 0x90, 9);
 81: 	memset_code((uint32_t)common_externals.dinput_acquire_keyboard + 0x31, 0x90, 5);
 82: 
 83: 	// Allow mouse cursor to be shown
 84: 	replace_function(ff7_externals.dinput_createdevice_mouse, noop);
 85: 
 86: 	// TODO: Comment this if Chocobo's not visible in race
 87: 	// replace_function(ff7_externals.draw_3d_model, draw_3d_model);
 88: 
 89: 	// sub_6B27A9 hack, replace d3d code
 90: 	memset_code((uint32_t)ff7_externals.sub_6B27A9 + 25, 0x90, 6);
 91: 	replace_function(ff7_externals.sub_6B26C0, draw_single_triangle);
 92: 	replace_function(ff7_externals.sub_6B2720, sub_6B2720);
 93: 
 94: 	// replace framebuffer access routine with our own version
 95: 	replace_function(ff7_externals.sub_673F5C, sub_673F5C);
 96: 
 97: 	replace_function(ff7_externals.destroy_d3d2_indexed_primitive, destroy_d3d2_indexed_primitive);
 98: 
 99: 	replace_function(ff7_externals.load_animation, load_animation);
100: 	replace_function(ff7_externals.read_battle_hrc, read_battle_hrc);
101: 	replace_function(common_externals.destroy_tex_header, destroy_tex_header);
102: 	replace_function(ff7_externals.load_p_file, load_p_file);
103: 	replace_function(common_externals.load_tex_file, load_tex_file);
104: 
105: 	replace_function(ff7_externals.field_load_textures, ff7::field::field_load_textures);
106: 	replace_function(ff7_externals.field_layer1_pick_tiles, ff7::field::field_layer1_pick_tiles);
107: 	replace_function(ff7_externals.field_layer2_pick_tiles, ff7::field::field_layer2_pick_tiles);
108: 	replace_function(ff7_externals.field_layer3_pick_tiles, ff7::field::field_layer3_pick_tiles);
109: 	replace_function(ff7_externals.field_layer4_pick_tiles, ff7::field::field_layer4_pick_tiles);
110: 	patch_code_byte(ff7_externals.field_draw_everything + 0xE2, 0x1D);
111: 	patch_code_byte(ff7_externals.field_draw_everything + 0x353, 0x1D);
112: 	replace_function(ff7_externals.open_flevel_siz, ff7::field::field_open_flevel_siz);
113: 	replace_function(ff7_externals.field_init_scripted_bg_movement, ff7::field::field_init_scripted_bg_movement);
114: 	replace_function(ff7_externals.field_update_scripted_bg_movement, ff7::field::field_update_scripted_bg_movement);
115: 
116: 	replace_function(ff7_externals.get_equipment_stats, get_equipment_stats);
117: 
118: 	replace_function(common_externals.open_file, open_file);
119: 	replace_function(common_externals.read_file, read_file);
120: 	replace_function(common_externals.__read_file, __read_file);
121: 	replace_function(ff7_externals.__read, __read);
122: 	replace_function(common_externals.write_file, write_file);
123: 	replace_function(common_externals.close_file, close_file);
124: 	replace_function(common_externals.get_filesize, get_filesize);
125: 	replace_function(common_externals.tell_file, tell_file);
126: 	replace_function(common_externals.seek_file, seek_file);
127: 	replace_function(ff7_externals.open_lgp_file, open_lgp_file);
128: 	replace_function(ff7_externals.lgp_chdir, lgp_chdir);
129: 	replace_function(ff7_externals.lgp_open_file, lgp_open_file);
130: 	replace_function(ff7_externals.lgp_read, lgp_read);
131: 	replace_function(ff7_externals.lgp_read_file, lgp_read_file);
132: 	replace_function(ff7_externals.lgp_get_filesize, lgp_get_filesize);
133: 	replace_function(ff7_externals.lgp_seek_file, lgp_seek_file);
134: 
135: 	replace_function(ff7_externals.magic_thread_start, ff7::battle::magic_thread_start);
136: 
137: 	replace_function(ff7_externals.kernel2_reset_counters, kernel2_reset_counters);
138: 	replace_function(ff7_externals.kernel2_add_section, kernel2_add_section);
139: 	replace_function(ff7_externals.kernel2_get_text, kernel2_get_text);
140: 	patch_code_uint((uint32_t)ff7_externals.kernel_load_kernel2 + 0x1D, 20 * 65536);
141: 	replace_call_function(ff7_externals.kernel_init + 0x1FD, ff7_load_kernel2_wrapper);
142: 	replace_call_function(ff7_externals.battle_scene_bin_sub_5D1050 + 0x85, ff7::battle::load_scene_bin_chunk);
143: 
144: 	replace_function(ff7_externals.read_field_file, ff7_read_field_file);
145: 
146: 	// prevent FF7 from stopping the movie when the window gets unfocused
147: 	replace_function(ff7_externals.wm_activateapp, ff7_wm_activateapp);
148: 
149: 	// required for the soft reset
150: 	replace_function(ff7_externals.engine_exit_game_mode_sub_666C78, ff7_engine_exit_game_mode);
151: 
152: 	// required to fix missing gameover music and broken menu sound after playing it
153: 	replace_call_function(ff7_externals.on_gameover_enter, ff7_on_gameover_enter);
154: 	replace_call_function(ff7_externals.on_gameover_exit, ff7_on_gameover_exit);
155: 
156: 	// Disable DirectSound creation when using the external SFX layer
157: 	// TODO: We need to hook more functions in the engine as it causes crashes around the game the way it is now.
158: 	// if (use_external_sfx)
159: 	// {
160: 	// 	replace_function(common_externals.directsound_create, ff7_dsound_create);
161: 	// 	replace_function(common_externals.directsound_release, ff7_dsound_release);
162: 	// 	replace_function(common_externals.directsound_createsoundbuffer, ff7_dsound_createsoundbuffer);
163: 	// }
164: 
165: 	// ##################################
166: 	// animation glitch fixes
167: 	// ##################################
168: 
169: 	// phoenix camera animation glitch
170: 	memset_code(ff7_externals.run_phoenix_main_loop_516297 + 0x3A5, 0x90, 49);
171: 	memset_code(ff7_externals.run_phoenix_main_loop_516297 + 0x3F7, 0x90, 49);
172: 
173: 	// ##################################
174: 	// bugfixes to enhance game stability
175: 	// ##################################
176: 
177: 	// chocobo crash fix
178: 	memset_code(ff7_externals.chocobo_fix - 12, 0x90, 36);
179: 
180: 	// midi transition crash fix
181: 	memcpy_code(ff7_externals.midi_fix, midi_fix, sizeof(midi_fix));
182: 	memset_code(ff7_externals.midi_fix + sizeof(midi_fix), 0x90, 18 - sizeof(midi_fix));
183: 
184: 	// snowboard crash fix
185: 	memcpy(ff7_externals.snowboard_fix, snowboard_fix, sizeof(snowboard_fix));
186: 
187: 	// coaster aim fix
188: 	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x129, 5);
189: 	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x14A, 5);
190: 	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x16D, 5);
191: 	patch_code_byte(ff7_externals.coaster_sub_5EE150 + 0x190, 5);
192: 
193: 	// condor minigame load unit textures fix
194: 	replace_call_function(ff7_externals.sub_5F342C + 0x66E, ff7_condor_fix_unit_texture_load);
195: 	replace_call_function(ff7_externals.sub_5F342C + 0x7B9, ff7_condor_fix_unit_texture_load);
196: 	replace_call_function(ff7_externals.sub_5F342C + 0x904, ff7_condor_fix_unit_texture_load);
197: 	replace_call_function(ff7_externals.sub_5F342C + 0x977, ff7_condor_fix_unit_texture_load);
198: 	replace_call_function(ff7_externals.sub_5F342C + 0x9EA, ff7_condor_fix_unit_texture_load);
199: 	replace_call_function(ff7_externals.sub_5F342C + 0xA35, ff7_condor_fix_unit_texture_load);
200: 
201: 	// ##################################
202: 	// menu UI glitch fix
203: 	// ##################################
204: 	replace_call_function(ff7_externals.battle_set_do_render_menu_call, ff7::battle::battle_menu_enter);
205: 
206: 	// #####################
207: 	// widescreen / uncrop
208: 	// #####################
209: 	if(widescreen_enabled || enable_uncrop)
210: 		ff7_widescreen_hook_init();
211: 
212: 	if (enable_time_cycle)
213: 		ff7::time_hook_init();
214: 
215: 	// #####################
216: 	// new timer calibration
217: 	// #####################
218: 
219: 	// replace time diff
220: 	replace_function((uint32_t)common_externals.diff_time, qpc_diff_time);
221: 
222: 	if (ff7_fps_limiter >= FPS_LIMITER_DEFAULT)
223: 	{
224: 		// replace rdtsc timing
225: 		replace_function((uint32_t)common_externals.get_time, qpc_get_time);
226: 
227: 		// override the timer calibration
228: 		QueryPerformanceFrequency((LARGE_INTEGER *)&game_object->_countspersecond);
229: 		game_object->countspersecond = (double)game_object->_countspersecond;
230: 
231: 		replace_function(ff7_externals.fps_limiter_swirl, ff7_limit_fps);
232: 		replace_function(ff7_externals.fps_limiter_battle, ff7_limit_fps);
233: 		replace_function(ff7_externals.fps_limiter_coaster, ff7_limit_fps);
234: 		replace_function(ff7_externals.fps_limiter_condor, ff7_limit_fps);
235: 		replace_function(ff7_externals.fps_limiter_field, ff7_limit_fps);
236: 		replace_function(ff7_externals.fps_limiter_highway, ff7_limit_fps);
237: 		replace_function(ff7_externals.fps_limiter_snowboard, ff7_limit_fps);
238: 		replace_function(ff7_externals.fps_limiter_worldmap, ff7_limit_fps);
239: 		replace_function(ff7_externals.fps_limiter_chocobo, ff7_limit_fps);
240: 		replace_function(ff7_externals.fps_limiter_submarine, ff7_limit_fps);
241: 		replace_function(ff7_externals.fps_limiter_credits, ff7_limit_fps);
242: 		replace_function(ff7_externals.fps_limiter_menu, ff7_limit_fps);
243: 
244: 		if (ff7_fps_limiter >= FPS_LIMITER_30FPS)
245: 		{
246: 			battle_frame_multiplier = (ff7_fps_limiter == FPS_LIMITER_30FPS) ? 2 : 4;
247: 
248: 			patch_divide_code<byte>(ff7_externals.battle_fps_menu_multiplier, battle_frame_multiplier); // Works perfectly only in 30 FPS
249: 
250: 			ff7::battle::camera_hook_init();
251: 			ff7::battle::animations_hook_init();
252: 
253: 			if(ff7_fps_limiter == FPS_LIMITER_60FPS)
254: 			{
255: 				common_frame_multiplier = 2;
256: 
257: 				// Swirl mode 60FPS fix
258: 				patch_multiply_code<byte>(ff7_externals.swirl_main_loop + 0x184, common_frame_multiplier); // wait frames before swirling
259: 				patch_multiply_code<byte>(ff7_externals.swirl_loop_sub_4026D4 + 0x3E, common_frame_multiplier);
260: 				byte swirl_cmp_fix[7] = {0x82, 0xB9, 0x50, 0x11, 0x00, 0x00, 0x9C};
261: 				memcpy_code(ff7_externals.swirl_loop_sub_4026D4 + 0x10B, swirl_cmp_fix, sizeof(swirl_cmp_fix));
262: 				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1AB), common_frame_multiplier);
263: 				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1B1), common_frame_multiplier);
264: 				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1E4), common_frame_multiplier);
265: 				patch_divide_code<double>(get_absolute_value(ff7_externals.swirl_loop_sub_4026D4, 0x1EA), common_frame_multiplier);
266: 			}
267: 		}
268: 	}
269: 
270: 	// World fix (60 FPS, night cycle, external mesh)
271: 	ff7::world::world_hook_init();
272: 
273: 	// Field FPS fix (60FPS, 30FPS movies)
274: 	ff7::field::ff7_field_hook_init();
275: 
276: 	// ##########################
277: 	// field eye to model mapping
278: 	// ##########################
279: 	replace_function(ff7_externals.field_models_eye_to_model, ff7::field::ff7_field_models_eye_to_model);
280: 
281: 	// #####################
282: 	// red XIII eye blinking
283: 	// #####################
284: 	byte ff7_redxiii_eye_fix[] = "\xEC\x79\x90\x00\x00\x00\x00\x00";
285: 	memcpy_code((uint32_t)ff7_externals.field_models_eye_blink_buffer + 0x58, ff7_redxiii_eye_fix, sizeof(ff7_redxiii_eye_fix) - 1);
286: 
287: 	// ##################
288: 	// field eye blinking
289: 	// ##################
290: 	replace_function(uint32_t(ff7_externals.field_blink_3d_model_649B50), ff7::field::ff7_field_blink_eye_sub_649B50);
291: 	// allow eye condition to always match
292: 	memset_code(ff7_externals.opcode_kawai + 0x275, 0x90, 6);
293: 	memset_code(ff7_externals.opcode_kawai + 0x294, 0x90, 2);
294: 	// allow up to 128 eyes
295: 	memset_code(ff7_externals.opcode_kawai + 0x286, 0x7F, 1);
296: 	memset_code(ff7_externals.opcode_kawai + 0x2A1, 0x7F, 1);
297: 
298: 	// #####################
299: 	// field vertical center
300: 	// #####################
301: 	if(ff7_field_center || widescreen_enabled)
302: 	{
303: 		patch_code_byte(ff7_externals.field_init_viewport_values + 0x35, 16);
304: 		patch_code_int(ff7_externals.field_init_viewport_values + 0x6E, 240);
305: 	}
306: 
307: 	// ########################
308: 	// field direct color black
309: 	// ########################
310: 	patch_code_short(uint32_t(ff7_externals.field_convert_type2_layers) + 0xE3, 0x8000);
311: 
312: 	// #####################
313: 	// worldmap footsteps
314: 	// #####################
315: 	if(ff7_footsteps)
316: 		replace_call_function(ff7_externals.world_update_player_74EA48 + 0xCDF, ff7::world::world_update_model_movement);
317: 
318: 	// #####################
319: 	// worldmap fx effects ( forest trail, ocean trail with highwind, etc. )
320: 	// #####################
321: 	switch(version)
322: 		{
323: 			case VERSION_FF7_102_US:
324: 				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0x8);
325: 				break;
326: 			case VERSION_FF7_102_DE:
327: 				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0x20);
328: 				break;
329: 			case VERSION_FF7_102_FR:
330: 				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0x50);
331: 				break;
332: 			case VERSION_FF7_102_SP:
333: 				patch_code_byte(ff7_externals.world_sub_75C283 + 0x2A8, 0xB0);
334: 				break;
335: 		}
336: 
337: 	// #####################
338: 	// battle toggle
339: 	// #####################
340: 	replace_call_function(ff7_externals.field_battle_toggle, ff7_toggle_battle_field);
341: 	replace_call_function(ff7_externals.worldmap_battle_toggle, ff7_toggle_battle_worldmap);
342: 
343: 	// #####################
344: 	// auto attack toggle
345: 	// #####################
346: 	replace_call_function(ff7_externals.battle_menu_update_6CE8B3 + 0xD9, ff7_battle_menu_sub_6DB0EE);
347: 	replace_call_function(ff7_externals.handle_actor_ready + 0x187, ff7_set_battle_menu_state_data_at_full_atb);
348: 
349: 	// #####################
350: 	// gamepad
351: 	// #####################
352: 	replace_function(ff7_externals.get_gamepad, ff7_get_gamepad);
353: 	replace_function(ff7_externals.update_gamepad_status, ff7_update_gamepad_status);
354: 
355: 	// ###########################
356: 	// control battle/world camera
357: 	// ###########################
358: 	if(enable_analogue_controls) {
359: 		replace_call_function(ff7_externals.battle_sub_42D992 + 0xFB, ff7::battle::update_battle_camera);
360: 		replace_function((uint32_t)ff7_externals.field_clip_with_camera_range_6438F6, ff7::field::ff7_field_clip_with_camera_range);
361: 
362: 		// Disable show targets with R2 in battles
363:         memset_code(ff7_externals.handle_actor_ready + 0xA8, 0x90, 29);
364: 	}
365: 
366: 	//######################
367: 	// menu rendering fix
368: 	//######################
369: 	replace_call_function(ff7_externals.timer_menu_sub + 0x72F, ff7_menu_sub_6F5C0C);
370: 	replace_call_function(ff7_externals.timer_menu_sub + 0xD77, ff7_menu_sub_6FAC38);
371: 
372: 	//######################
373: 	// shadow lighting fix
374: 	//######################
375: 	if(enable_lighting)
376: 	    memset_code(ff7_externals.battle_sub_42F3E8 + 0xD7D, 0x90, 78); // Disable battle shadow draw call
377: 
378: 	//######################
379: 	// day night time cycle
380: 	//######################
381: 	if (enable_time_cycle)
382: 	{
383: 		replace_call_function(ff7_externals.battle_draw_text_ui_graphics_objects_call, ff7::battle::draw_ui_graphics_objects_wrapper);
384: 		replace_call_function(ff7_externals.battle_draw_box_ui_graphics_objects_call, ff7::battle::draw_ui_graphics_objects_wrapper);
385: 	}
386: 
387: 	if (game_lighting != GAME_LIGHTING_ORIGINAL)
388: 	{
389: 		// Disables unnecesary lighting in Chocobos applied throught the KAWAI op
390: 		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x864, 0x90, 5);
391: 		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x2E4, 0x90, 5);
392: 		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x3A3, 0x90, 5);
393: 		memset_code(ff7_externals.field_apply_kawai_op_64A070 + 0x23C, 0x90, 5);
394: 		// Disables unnecessary lighting in temple of the ancients rolling rocks
395: 		replace_function(ff7_externals.sub_64EC60, noop);
396: 	}
397: 
398: 	//#############################################
399: 	// steam save game preservation and other fixes
400: 	//#############################################
401: 	if (steam_edition)
402: 	{
403: 		switch(version)
404: 		{
405: 			case VERSION_FF7_102_US:
406: 				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x1096, ff7_write_save_file);
407: 				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
408: 				memset_code(ff7_externals.config_menu_sub + 0x8AC, 0x90, 0xE6);
409: 				break;
410: 			case VERSION_FF7_102_DE:
411: 				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x10B2, ff7_write_save_file);
412: 				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
413: 				memset_code(ff7_externals.config_menu_sub + 0x8B3, 0x90, 0xE6);
414: 				break;
415: 			case VERSION_FF7_102_FR:
416: 				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x10B2, ff7_write_save_file);
417: 				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
418: 				memset_code(ff7_externals.config_menu_sub + 0x8AC, 0x90, 0xE6);
419: 				break;
420: 			case VERSION_FF7_102_SP:
421: 				replace_call_function(ff7_externals.menu_sub_6FEDB0 + 0x10FE, ff7_write_save_file);
422: 				// Disable "Normal" setting in Controller section of the Config menu (it softlocks on Steam)
423: 				memset_code(ff7_externals.config_menu_sub + 0x8B3, 0x90, 0xE6);
424: 				break;
425: 		}
426: 
427: 		// Restore Steam release behavior on character name screen when using gamepads in Steam Input mode
428: 		// Aali driver used to patch out these three functions to fix this issue
429: 		replace_function(ff7_externals.set_default_input_settings_save, noop);
430: 		replace_function(ff7_externals.keyboard_name_input, noop);
431: 		replace_function(ff7_externals.restore_input_settings, noop);
432: 
433:     // Patch the default config bitmask so that "Customize" controller option is enabled by default
434:     memset_code(ff7_externals.config_initialize + 0x36, 0x45, 1);
435: 	}
436: 
437: 	//###############################
438: 	// steam achievement unlock calls
439: 	//###############################
440: 	if(steam_edition || enable_steam_achievements)
441: 	{
442: 		// BATTLE SQUARE
443: 		replace_call_function(ff7_externals.battle_sub_42A0E7 + 0x78, ff7::battle::load_battle_stage);
444: 
445: 		// GIL, MASTER MATERIA, BATTLE WON
446: 		replace_call_function(ff7_externals.battle_enemy_killed_sub_433BD2 + 0x2AF, ff7::battle::battle_sub_5C7F94);
447: 		replace_call_function(ff7_externals.menu_sub_6CDA83 + 0x20, ff7_menu_battle_end_sub_6C9543);
448: 		if (version == VERSION_FF7_102_US) {
449: 			replace_call_function(ff7_externals.menu_shop_loop + 0x327B, ff7_get_materia_gil);
450: 		} else {
451: 			replace_call_function(ff7_externals.menu_shop_loop + 0x3373, ff7_get_materia_gil);
452: 		}
453: 		replace_function(ff7_externals.opcode_increase_gil_call, ff7_opcode_increase_gil_call);
454: 
455: 		// 1ST LIMIT BREAK
456: 		replace_function(ff7_externals.display_battle_action_text_sub_6D71FA, ff7::battle::display_battle_action_text_sub_6D71FA);
457: 
458: 		// MATERIA GOT
459: 		replace_call_function(ff7_externals.opcode_add_materia_inventory_call + 0x43, ff7_menu_sub_6CBCF3);
460: 		replace_call_function(ff7_externals.menu_sub_705D16 + 0x1729, ff7_menu_sub_6CC17F);
461: 		replace_call_function(ff7_externals.menu_sub_705D16 + 0x1819, ff7_menu_sub_6CC17F);
462: 
463: 		// LAST LIMIT BREAK
464: 		replace_function(ff7_externals.menu_decrease_item_quantity, ff7_menu_decrease_item_quantity);
465: 
466: 		// GOLD CHOCOBO, YUFFIE, VINCENT: called through update_field_entities
467: 		replace_call_function(ff7_externals.opcode_setbyte + 0x14, ff7_chocobo_field_entity_60FA7D);
468: 		replace_call_function(ff7_externals.opcode_biton + 0x3A, ff7_character_regularly_field_entity_60FA7D);
469: 
470: 		// INITIALIZATION AT LOAD SAVE FILE
471: 		switch(version) {
472: 			case VERSION_FF7_102_US:
473: 			case VERSION_FF7_102_SP:
474: 				replace_call_function(ff7_externals.menu_sub_7212FB + 0xE9D, ff7_load_save_file);
475: 				break;
476: 			case VERSION_FF7_102_DE:
477: 			case VERSION_FF7_102_FR:
478: 				replace_call_function(ff7_externals.menu_sub_7212FB + 0xEC5, ff7_load_save_file);
479: 				break;
480: 		}
481: 	}
482: 
483: 	replace_call(ff7_externals.credits_main_loop + 0xAC, ff7_credits_loop_gfx_begin_scene);
484: 
485: 	//######################
486: 	// snowboard .P model vertices limit fix + allow float vertex data type
487: 	//######################
488: 	replace_function(ff7_externals.snowboard_parse_model_vertices_732159, ff7_snowboard_parse_model_vertices);
489: }
490: 
491: struct ff7_gfx_driver *ff7_load_driver(void* _game_object)
492: {
493: 	struct ff7_gfx_driver *ret = (ff7_gfx_driver *)external_calloc(1, sizeof(*ret));
494: 
495: 	ret->init = common_init;
496: 	ret->cleanup = common_cleanup;
497: 	ret->lock = common_lock;
498: 	ret->unlock = common_unlock;
499: 	ret->flip = common_flip;
500: 	ret->clear = common_clear;
501: 	ret->clear_all= common_clear_all;
502: 	ret->setviewport = common_setviewport;
503: 	ret->setbg = common_setbg;
504: 	ret->prepare_polygon_set = common_prepare_polygon_set;
505: 	ret->load_group = common_load_group;
506: 	ret->setmatrix = common_setmatrix;
507: 	ret->unload_texture = common_unload_texture;
508: 	ret->load_texture = common_load_texture;
509: 	ret->palette_changed = common_palette_changed;
510: 	ret->write_palette = common_write_palette;
511: 	ret->blendmode = common_blendmode;
512: 	ret->light_polygon_set = common_light_polygon_set;
513: 	ret->field_64 = common_field_64;
514: 	ret->setrenderstate = common_setrenderstate;
515: 	ret->_setrenderstate = common_setrenderstate;
516: 	ret->__setrenderstate = common_setrenderstate;
517: 	ret->field_74 = common_field_74;
518: 	ret->field_78 = common_field_78;
519: 	ret->draw_deferred = common_draw_deferred;
520: 	ret->field_80 = common_field_80;
521: 	ret->field_84 = common_field_84;
522: 	ret->begin_scene = common_begin_scene;
523: 	ret->end_scene = common_end_scene;
524: 	ret->field_90 = common_field_90;
525: 	ret->setrenderstate_flat2D = common_setrenderstate_2D;
526: 	ret->setrenderstate_smooth2D = common_setrenderstate_2D;
527: 	ret->setrenderstate_textured2D = common_setrenderstate_2D;
528: 	ret->setrenderstate_paletted2D = common_setrenderstate_2D;
529: 	ret->_setrenderstate_paletted2D = common_setrenderstate_2D;
530: 	ret->draw_flat2D = common_draw_2D;
531: 	ret->draw_smooth2D = common_draw_2D;
532: 	ret->draw_textured2D = common_draw_2D;
533: 	ret->draw_paletted2D = common_draw_paletted2D;
534: 	ret->setrenderstate_flat3D = common_setrenderstate_3D;
535: 	ret->setrenderstate_smooth3D = common_setrenderstate_3D;
536: 	ret->setrenderstate_textured3D = common_setrenderstate_3D;
537: 	ret->setrenderstate_paletted3D = common_setrenderstate_3D;
538: 	ret->_setrenderstate_paletted3D = common_setrenderstate_3D;
539: 	ret->draw_flat3D = common_draw_3D;
540: 	ret->draw_smooth3D = common_draw_3D;
541: 	ret->draw_textured3D = common_draw_3D;
542: 	ret->draw_paletted3D = common_draw_paletted3D;
543: 	ret->setrenderstate_flatlines = common_setrenderstate_2D;
544: 	ret->setrenderstate_smoothlines = common_setrenderstate_2D;
545: 	ret->draw_flatlines = common_draw_lines;
546: 	ret->draw_smoothlines = common_draw_lines;
547: 	ret->field_EC = common_field_EC;
548: 
549: 	return ret;
550: }
</file>

<file path="src/ff7.h">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //    Copyright (C) 2023 Marcin 'Maki' Gomulak                              //
  10: //                                                                          //
  11: //    This file is part of FFNx                                             //
  12: //                                                                          //
  13: //    FFNx is free software: you can redistribute it and/or modify          //
  14: //    it under the terms of the GNU General Public License as published by  //
  15: //    the Free Software Foundation, either version 3 of the License         //
  16: //                                                                          //
  17: //    FFNx is distributed in the hope that it will be useful,               //
  18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  20: //    GNU General Public License for more details.                          //
  21: /****************************************************************************/
  22: 
  23: #pragma once
  24: 
  25: #include <ddraw.h>
  26: #include <stdio.h>
  27: #include <array>
  28: #include <span>
  29: 
  30: #include "common.h"
  31: 
  32: #define FF7_MAX_NUM_MODEL_ENTITIES 32
  33: 
  34: /*
  35:  * Primitive types supported by the engine, mostly a 1:1 mapping to PSX GPU
  36:  * capabilities.
  37:  *
  38:  * Key:
  39:  * T/S/L - triangle/square(quad)/line
  40:  * F/G - flat/gouraud
  41:  * T - textured
  42:  * 2D/3D - self explanatory except 2D means no transforms at all, billboard sprites etc are still "3D"
  43:  */
  44: enum polygon_types
  45: {
  46: 	PT_TF2D = 0,
  47: 	PT_TF3D,
  48: 	PT_TG2D,
  49: 	PT_TG3D,
  50: 	PT_T2D,
  51: 	PT_T3D,
  52: 	PT_TGT2D,
  53: 	PT_TGT3D,
  54: 	PT_SF2D,
  55: 	PT_SF3D,
  56: 	PT_SG2D,
  57: 	PT_SG3D,
  58: 	PT_S2D,
  59: 	PT_S3D,
  60: 	PT_SGT2D,
  61: 	PT_SGT3D,
  62: 	polygon_type_10,
  63: 	polygon_type_11,
  64: 	PT_LF2D,
  65: 	PT_L2D,
  66: };
  67: 
  68: // FF7 modules, unknowns are either unused or not relevant to rendering
  69: enum ff7_game_modes
  70: {
  71: 	FF7_MODE_FIELD = 1,
  72: 	FF7_MODE_BATTLE,
  73: 	FF7_MODE_WORLDMAP,
  74: 	FF7_MODE_UNKNOWN4,
  75: 	FF7_MODE_MENU,
  76: 	FF7_MODE_HIGHWAY,
  77: 	FF7_MODE_CHOCOBO,
  78: 	FF7_MODE_SNOWBOARD,
  79: 	FF7_MODE_CONDOR,
  80: 	FF7_MODE_SUBMARINE,
  81: 	FF7_MODE_COASTER,
  82: 	FF7_MODE_CDCHECK,
  83: 	FF7_MODE_UNKNOWN13,
  84: 	FF7_MODE_SNOWBOARD2,
  85: 	FF7_MODE_UNKNOWN15,
  86: 	FF7_MODE_UNKNOWN16,
  87: 	FF7_MODE_BATTLE_MENU,
  88: 	FF7_MODE_UNKNOWN18,
  89: 	FF7_MODE_EXIT,
  90: 	FF7_MODE_MAIN_MENU,
  91: 	FF7_MODE_UNKNOWN21,
  92: 	FF7_MODE_INTRO,
  93: 	FF7_MODE_SWIRL,
  94: 	FF7_MODE_UNKNOWN24,
  95: 	FF7_MODE_ENDING2,
  96: 	FF7_MODE_GAMEOVER,
  97: 	FF7_MODE_CREDITS,
  98: 	FF7_MODE_UNKNOWN28,
  99: };
 100: 
 101: // 3D model flags
 102: enum model_modes
 103: {
 104: 	MDL_ROOT_ROTATION         = 0x0001,
 105: 	MDL_ROOT_ROTATION_NEGX    = 0x0002,
 106: 	MDL_ROOT_ROTATION_NEGY    = 0x0004,
 107: 	MDL_ROOT_ROTATION_NEGZ    = 0x0008,
 108: 	MDL_ROOT_TRANSLATION      = 0x0010,
 109: 	MDL_ROOT_TRANSLATION_NEGX = 0x0020,
 110: 	MDL_ROOT_TRANSLATION_NEGY = 0x0040,
 111: 	MDL_ROOT_TRANSLATION_NEGZ = 0x0080,
 112: 	MDL_USE_STRUC110_MATRIX   = 0x4000,
 113: 	MDL_USE_CAMERA_MATRIX     = 0x8000,
 114: };
 115: 
 116: enum class cmd_id
 117: {
 118: 	CMD_ATTACK = 0x01,
 119: 	CMD_MAGIC = 0x02,
 120: 	CMD_SUMMON = 0x03,
 121: 	CMD_ITEM = 0x04,
 122: 	CMD_STEAL = 0x05,
 123: 	CMD_SENSE = 0x06,
 124: 	CMD_COIN = 0x07,
 125: 	CMD_THROW = 0x08,
 126: 	CMD_MORPH = 0x09,
 127: 	CMD_DEATHBLOW = 0x0A,
 128: 	CMD_MANIPULATE = 0x0B,
 129: 	CMD_MIME = 0x0C,
 130: 	CMD_ENEMY_SKILL = 0x0D,
 131: 	CMD_MUG = 0x11,
 132: 	CMD_CHANGE = 0x12,
 133: 	CMD_DEFEND = 0x13,
 134: 	CMD_LIMIT = 0x14,
 135: 	CMD_W_MAGIC = 0x15,
 136: 	CMD_W_SUMMON = 0x16,
 137: 	CMD_W_ITEM = 0x17,
 138: 	CMD_SLASH_ALL = 0x18,
 139: 	CMD_DOUBLE_CUT = 0x19,
 140: 	CMD_FLASH = 0x1A,
 141: 	CMD_QUAD_CUT = 0x1B,
 142: 	CMD_ENEMY_ACTION = 0x20,
 143: 	CMD_POISONTICK = 0x23
 144: };
 145: 
 146: // internal structure for menu sprites (global values, may not be a structure at all)
 147: struct menu_objects
 148: {
 149: 	struct ff7_graphics_object *unknown1;
 150: 	struct ff7_graphics_object *unused;
 151: 	struct ff7_graphics_object *btl_win_a;
 152: 	struct ff7_graphics_object *btl_win_b;
 153: 	struct ff7_graphics_object *btl_win_c;
 154: 	struct ff7_graphics_object *btl_win_d;
 155: 	struct ff7_graphics_object *_btl_win;
 156: 	struct ff7_graphics_object *blend_btl_win_a;
 157: 	struct ff7_graphics_object *add_btl_win_a;
 158: 	struct ff7_graphics_object *add_btl_win_b;
 159: 	struct ff7_graphics_object *add_btl_win_c;
 160: 	struct ff7_graphics_object *add_btl_win_d;
 161: 	struct ff7_graphics_object *window_bg;
 162: 	struct ff7_graphics_object *blend_window_bg;
 163: 	struct ff7_graphics_object *unknown2;
 164: 	struct ff7_graphics_object *unknown3;
 165: 	struct ff7_graphics_object *unknown4;
 166: 	struct ff7_graphics_object *unknown5;
 167: 	struct ff7_graphics_object *menu_fade;
 168: 	struct ff7_graphics_object *font_a;
 169: 	struct ff7_graphics_object *font_b;
 170: 	struct ff7_graphics_object *menu_avatars[3];
 171: 	struct ff7_graphics_object *menu_avatars2[9];
 172: 	struct ff7_graphics_object *buster_tex;
 173: 	struct ff7_graphics_object *font;
 174: 	struct ff7_graphics_object *btl_win;
 175: 	struct ff7_graphics_object *blend_btl_win;
 176: 	struct ff7_graphics_object *add_btl_win;
 177: };
 178: 
 179: // file modes
 180: enum
 181: {
 182: 	FF7_FMODE_READ = 0,
 183: 	FF7_FMODE_READ_TEXT,
 184: 	FF7_FMODE_WRITE,
 185: 	FF7_FMODE_CREATE,
 186: };
 187: 
 188: /*
 189:  * This section defines some structures used internally by the FF7 game engine.
 190:  *
 191:  * Documentation for some of them can be found on the Qhimm wiki, a lot of
 192:  * information can be gleaned from the source code to this program but in many
 193:  * cases nothing is known except the size and general layout of the structure.
 194:  *
 195:  * Variable and structure names are mostly based on what they contain rather
 196:  * than what they are for, a lot of names may be wrong, inappropriate or
 197:  * downright misleading. Thread with caution!
 198:  */
 199: 
 200: struct list
 201: {
 202: 	uint32_t use_assert_alloc;
 203: 	uint32_t field_4;
 204: 	uint32_t nodes;
 205: 	struct list_node *head;
 206: 	struct list_node *tail;
 207: 	void *destructor;
 208: 	void *recursive_find_cb;
 209: 	uint32_t field_1C;
 210: };
 211: 
 212: struct list_node
 213: {
 214: 	struct list_node *next;
 215: 	void *object;
 216: };
 217: 
 218: struct file_context
 219: {
 220: 	uint32_t mode;
 221: 	uint32_t use_lgp;
 222: 	uint32_t lgp_num;
 223: 	void (*name_mangler)(char *, char *);
 224: };
 225: 
 226: struct ff7_file
 227: {
 228: 	char *name;
 229: 	struct lgp_file *fd;
 230: 	struct file_context context;
 231: };
 232: 
 233: struct ff7_indexed_vertices
 234: {
 235: 	uint32_t field_0;
 236: 	uint32_t field_4;
 237: 	uint32_t count;
 238: 	uint32_t vertexcount;
 239: 	uint32_t field_10;
 240: 	struct nvertex *vertices;
 241: 	uint32_t indexcount;
 242: 	uint32_t field_1C;
 243: 	WORD *indices;
 244: 	uint32_t field_24;
 245: 	unsigned char *palettes;
 246: 	uint32_t field_2C;
 247: 	struct ff7_graphics_object *graphics_object;
 248: };
 249: 
 250: struct ff7_graphics_object
 251: {
 252: 	uint32_t polytype;
 253: 	uint32_t field_4;
 254: 	uint32_t field_8;
 255: 	struct p_hundred *hundred_data;
 256: 	struct matrix_set *matrix_set;
 257: 	struct polygon_set *polygon_set;
 258: 	uint32_t field_18;
 259: 	uint32_t field_1C;
 260: 	uint32_t field_20;
 261: 	float u_offset;
 262: 	float v_offset;
 263: 	void *dx_sfx_2C;
 264: 	void *graphics_instance;
 265: 	uint32_t field_34;
 266: 	uint32_t vertices_per_shape;
 267: 	uint32_t indices_per_shape;
 268: 	uint32_t vertex_offset;
 269: 	uint32_t index_offset;
 270: 	uint32_t field_48;
 271: 	uint32_t field_4C;
 272: 	uint32_t field_50;
 273: 	uint32_t field_54;
 274: 	uint32_t field_58;
 275: 	uint32_t field_5C;
 276: 	uint32_t field_60;
 277: 	uint32_t field_64;
 278: 	uint32_t field_68;
 279: 	uint32_t field_6C;
 280: 	uint32_t field_70;
 281: 	uint32_t field_74;
 282: 	uint32_t field_78;
 283: 	uint32_t field_7C;
 284: 	uint32_t field_80;
 285: 	uint32_t field_84;
 286: 	uint32_t field_88;
 287: 	struct ff7_indexed_vertices *indexed_vertices;
 288: 	gfx_polysetrenderstate *func_90;
 289: 	gfx_draw_vertices *func_94;
 290: 	uint32_t use_matrix_pointer;
 291: 	struct matrix *matrix_pointer;
 292: 	struct matrix matrix;
 293: };
 294: 
 295: struct polygon_group
 296: {
 297: 	uint32_t field_0;
 298: 	uint32_t numvert;
 299: 	void *driver_data;
 300: 	uint32_t field_C;
 301: 	uint32_t normindexes;
 302: 	uint32_t vertices;
 303: 	uint32_t vertex_colors;
 304: 	uint32_t texcoords;
 305: 	uint32_t texture_set;
 306: };
 307: 
 308: struct struc_106
 309: {
 310: 	uint32_t field_0;
 311: 	uint32_t color;
 312: 	vector3<float> point;
 313: 	struct bgra_color d3dcol;
 314: };
 315: 
 316: struct ff7_light
 317: {
 318: 	uint32_t flags;
 319: 	uint32_t field_4;
 320: 	struct struc_106 *color_1;
 321: 	struct struc_106 *color_2;
 322: 	struct struc_106 *color_3;
 323: 	struct bgra_color global_light_color_abgr;
 324: 	struct bgra_color global_light_color_abgr_norm;
 325: 	uint32_t global_light_color_rgba;
 326: 	struct matrix field_38;
 327: 	struct matrix field_78;
 328: 	struct matrix field_B8;
 329: 	struct matrix field_F8;
 330: 	uint32_t field_138;
 331: 	struct matrix normal_matrix;
 332: 	uint32_t field_17C;
 333: 	uint32_t field_180;
 334: 	uint32_t field_184;
 335: 	uint32_t field_188;
 336: 	uint32_t field_18C;
 337: 	uint32_t field_190;
 338: 	uint32_t field_194;
 339: 	uint32_t field_198;
 340: 	struct matrix *matrix_pointer;
 341: 	uint32_t field_1A0;
 342: 	uint32_t field_1A4[256];
 343: 	uint32_t field_5A4;
 344: 	bgra_color_ui8 color;
 345: };
 346: 
 347: struct ff7_polygon_set
 348: {
 349: 	uint32_t field_0;
 350: 	uint32_t field_4;
 351: 	uint32_t field_8;
 352: 	uint32_t field_C;
 353: 	uint32_t numgroups;
 354: 	struct struc_49 field_14;
 355: 	uint32_t field_2C;
 356: 	struct polygon_data *polygon_data;
 357: 	struct p_hundred *hundred_data;
 358: 	uint32_t per_group_hundreds;
 359: 	struct p_hundred **hundred_data_group_array;
 360: 	struct matrix_set *matrix_set;
 361: 	struct ff7_light *light;
 362: 	uint32_t field_48;
 363: 	void *execute_buffers;			// IDirect3DExecuteBuffer **
 364: 	struct indexed_primitive **indexed_primitives;
 365: 	uint32_t field_54;
 366: 	uint32_t field_58;
 367: 	struct polygon_group *polygon_group_array;
 368: 	uint32_t field_60;
 369: 	uint32_t field_64;
 370: 	uint32_t field_68;
 371: 	uint32_t field_6C;
 372: 	uint32_t field_70;
 373: 	uint32_t field_74;
 374: 	uint32_t field_78;
 375: 	uint32_t field_7C;
 376: 	uint32_t field_80;
 377: 	uint32_t field_84;
 378: 	uint32_t field_88;
 379: 	uint32_t field_8C;
 380: 	uint32_t field_90;
 381: 	uint32_t has_struc_173;
 382: 	uint32_t field_98;
 383: 	struct struc_173 *struc_173;
 384: 	uint32_t field_A0;
 385: 	uint32_t field_A4;
 386: 	uint32_t field_A8;
 387: 	uint32_t field_AC;
 388: };
 389: 
 390: struct ff7_tex_header
 391: {
 392: 	uint32_t version;
 393: 	uint32_t field_4;
 394: 	uint32_t color_key;
 395: 	uint32_t field_C;
 396: 	uint32_t field_10;
 397: 	union
 398: 	{
 399: 		struct
 400: 		{
 401: 			uint32_t minbitspercolor;
 402: 			uint32_t maxbitspercolor;
 403: 			uint32_t minalphabits;
 404: 			uint32_t maxalphabits;
 405: 		} v1_1;
 406: 
 407: 		struct
 408: 		{
 409: 			uint32_t x;
 410: 			uint32_t y;
 411: 			uint32_t w;
 412: 			uint32_t h;
 413: 		} fb_tex;
 414: 	};
 415: 	union
 416: 	{
 417: 		struct
 418: 		{
 419: 			uint32_t minbitsperpixel;
 420: 			uint32_t maxbitsperpixel;
 421: 		} v1_2;
 422: 
 423: 		struct
 424: 		{
 425: 			char *psx_name;
 426: 			char *pc_name;
 427: 		} file;
 428: 	};
 429: 	uint32_t field_2C;
 430: 	uint32_t palettes;					// ?
 431: 	uint32_t palette_entries;			// ?
 432: 	uint32_t bpp;
 433: 	struct texture_format tex_format;
 434: 	uint32_t use_palette_colorkey;
 435: 	char *palette_colorkey;
 436: 	uint32_t reference_alpha;
 437: 	uint32_t blend_mode;
 438: 	uint32_t field_CC;
 439: 	uint32_t palette_index;
 440: 	unsigned char *image_data;
 441: 	unsigned char *old_palette_data;
 442: 	uint32_t field_DC;
 443: 	uint32_t field_E0;
 444: 	uint32_t *vram_positions;
 445: 	uint32_t y;
 446: };
 447: 
 448: struct ff7_texture_set
 449: {
 450: 	union
 451: 	{
 452: 		struct
 453: 		{
 454: 			void *ddsurface1;
 455: 			void *d3d2texture1;
 456: 			void *ddsurface2;
 457: 			void *d3d2texture2;
 458: 		} d3d;
 459: 
 460: 		struct
 461: 		{
 462: 			uint32_t external;
 463: 			struct gl_texture_set *gl_set;
 464: 			uint32_t width;
 465: 			uint32_t height;
 466: 		} ogl;
 467: 	};
 468: 
 469: 	uint32_t field_10;
 470: 	uint32_t field_14;
 471: 	uint32_t refcount;
 472: 	uint32_t field_1C;
 473: 	uint32_t field_20;
 474: 	uint32_t field_24;
 475: 	uint32_t field_28;
 476: 	uint32_t field_2C;
 477: 	uint32_t field_30;
 478: 	uint32_t field_34;
 479: 	uint32_t field_38;
 480: 	uint32_t field_3C;
 481: 	uint32_t field_40;
 482: 	uint32_t field_44;
 483: 	uint32_t field_48;
 484: 	uint32_t field_4C;
 485: 	uint32_t field_50;
 486: 	uint32_t field_54;
 487: 	uint32_t field_58;
 488: 	uint32_t field_5C;
 489: 	uint32_t field_60;
 490: 	uint32_t field_64;
 491: 	uint32_t field_68;
 492: 	uint32_t field_6C;
 493: 	uint32_t field_70;
 494: 	uint32_t field_74;
 495: 	uint32_t field_78;
 496: 	uint32_t *texturehandle;
 497: 	struct texture_format *texture_format;
 498: 	struct tex_header *tex_header;
 499: 	uint32_t palette_index;
 500: 	struct palette *palette;
 501: 	uint32_t field_90;
 502: 	uint32_t field_94;
 503: 	uint32_t field_98;
 504: 	uint32_t field_9C;
 505: };
 506: 
 507: struct field_layer
 508: {
 509: 	struct ff7_tex_header *tex_header;
 510: 	void *image_data;
 511: 	struct ff7_graphics_object *graphics_object;
 512: 	uint32_t present;
 513: 	uint32_t field_10;
 514: 	uint32_t field_14;
 515: 	WORD field_18;
 516: 	WORD type;
 517: };
 518: 
 519: struct field_object
 520: {
 521: 	char name[256];
 522: 	char field_100[256];
 523: 	char hrc_filename[256];
 524: 	char field_300[33];
 525: 	char field_321;
 526: 	char field_322;
 527: 	char field_323;
 528: 	char field_324;
 529: 	char field_325;
 530: 	char field_326;
 531: 	unsigned char r_ambient;
 532: 	unsigned char g_ambient;
 533: 	unsigned char b_ambient;
 534: 	unsigned char r_light1;
 535: 	unsigned char g_light1;
 536: 	unsigned char b_light1;
 537: 	unsigned char r_light2;
 538: 	unsigned char g_light2;
 539: 	unsigned char b_light2;
 540: 	unsigned char r_light3;
 541: 	unsigned char g_light3;
 542: 	unsigned char b_light3;
 543: 	unsigned char field_333;
 544: 	short x_light1;
 545: 	short y_light1;
 546: 	short z_light1;
 547: 	short x_light2;
 548: 	short y_light2;
 549: 	short z_light2;
 550: 	short x_light3;
 551: 	short y_light3;
 552: 	short z_light3;
 553: 	WORD field_346;
 554: 	WORD field_348;
 555: 	WORD num_animations;
 556: 	char anim_filenames[8880];
 557: 	char field_25FC[592];
 558: 	char field_284C[60];
 559: 	uint32_t field_2888;
 560: };
 561: 
 562: struct struc_110
 563: {
 564: 	uint32_t field_0;
 565: 	vector3<float> position;
 566: 	vector3<float> rotation;
 567: 	vector3<float> scale;
 568: 	float scale_factor;
 569: 	struct matrix matrix;
 570: 	vector3<float> *bone_positions;
 571: 	struct matrix *bone_matrices;
 572: };
 573: 
 574: struct battle_actor_data
 575: {
 576: 	uint32_t index;
 577: 	uint32_t level;
 578: 	uint32_t formation_entry;
 579: 	uint32_t command_index;
 580: 	uint32_t action_index;
 581: 	uint32_t field_14;
 582: 	uint32_t allowed_targets;
 583: 	uint32_t field_1C;
 584: 	uint32_t command_animation;
 585: 	uint32_t attack_effect;
 586: 	uint32_t field_28;
 587: 	uint32_t field_2C;
 588: 	uint32_t self_mask_1;
 589: 	uint32_t self_mask_2;
 590: 	uint32_t mp_cost;
 591: 	uint32_t action_accuracy;
 592: 	uint32_t damage_calc;
 593: 	uint32_t action_element;
 594: 	uint32_t action_power;
 595: 	uint32_t attack_power;
 596: 	uint32_t action_target_mask;
 597: 	uint32_t field_54[131];
 598: };
 599: 
 600: struct battle_actor_vars
 601: {
 602: 	uint32_t statusMask;		   // 0x00
 603: 	uint32_t stateFlags;		   // 0x04
 604: 	byte index;					   // 0x08
 605: 	byte level;					   // 0x09
 606: 	byte unknown0;				   // 0x0A
 607: 	byte elementDamageMask;		   // 0x0B
 608: 	byte characterID;			   // 0x0C
 609: 	byte physAtk;				   // 0x0D
 610: 	byte magAtk;				   // 0x0E
 611: 	byte pEvade;				   // 0x0F
 612: 	byte idleAnimScript;		   // 0x10
 613: 	byte damageAnimID;			   // 0x11
 614: 	byte backDamageMult;		   // 0x12
 615: 	byte sizeScale;				   // 0x13
 616: 	byte dexterity;				   // 0x14
 617: 	byte luck;					   // 0x15
 618: 	byte idleAnimHolder;		   // 0x16
 619: 	byte lastCovered;			   // 0x17
 620: 	uint16_t lastTargets;		   // 0x18
 621: 	uint16_t prevAttackerMask;	   // 0x1A
 622: 	uint16_t prevPhysAttackerMask; // 0x1C
 623: 	uint16_t prevMagAttackerMask;  // 0x1E
 624: 	uint16_t defense;			   // 0x20
 625: 	uint16_t mDefense;
 626: 	uint16_t formationID;
 627: 	uint16_t absorbedElementsMask;
 628: 	uint16_t currentMP;
 629: 	uint16_t maxMP;
 630: 	int currentHP;
 631: 	int maxHP;
 632: 	uint32_t unknown1;
 633: 	uint32_t unknown2;
 634: 	uint32_t unknown3;
 635: 	uint32_t unknown4;
 636: 	uint32_t initalStatusMasks;
 637: 	uint32_t unknown5;
 638: 	byte unknown6;
 639: 	byte mEvade;
 640: 	byte actorRow;
 641: 	byte cameraData;
 642: 	uint16_t gilStolen;
 643: 	uint16_t itemStolen;
 644: 	uint16_t unknown7;
 645: 	byte missAnimScript;
 646: 	byte APValue;
 647: 	uint32_t gilValue;
 648: 	uint32_t expValue;
 649: 	byte unused8;
 650: 	byte unused9;
 651: 	uint16_t unused10; // This is being used for the tactical elements mod, unused in original game
 652: 	byte unused12;
 653: 	byte unused13;
 654: 	byte unused14;
 655: 	byte unused15;
 656: };
 657: 
 658: struct battle_ai_context
 659: {
 660: 	byte lastCommandIdx;  // 00
 661: 	byte lastActionIdx;	  // 08
 662: 	byte bankAccessValue; // 10
 663: 	byte dummyByte;		  // 18
 664: 	byte battleType;	  // 20
 665: 	byte colorMask;		  // 30
 666: 	byte limitLevel;	  // 38
 667: 	byte unk3;			  // 40
 668: 	byte unk4;			  // 48
 669: 	byte pad;
 670: 	uint16_t activeActorMask;	 // 50
 671: 	uint16_t scriptOwnerMask;	 // 60
 672: 	uint16_t actionTargetMask;	 // 70
 673: 	uint16_t actorAlliesMask;	 // 80
 674: 	uint16_t activeAlliesMask;	 // 90
 675: 	uint16_t actorEnemiesMask;	 // A0
 676: 	uint16_t activeEnemiesMask;	 // B0
 677: 	uint16_t actorPartyMask;	 // C0
 678: 	uint16_t enemyActorsMask;	 // D0
 679: 	uint16_t allActorsMask;		 // E0
 680: 	uint16_t unkMask2;			 // F0
 681: 	uint16_t unkMask3;			 // 0x100
 682: 	uint16_t endBattleFlags;	 // 2110
 683: 	uint16_t lastActionElements; // 2120
 684: 	uint16_t unkDword3;			 // 130
 685: 	uint16_t battleFormationIdx; // 140
 686: 	uint16_t lastAbsActionIdx;	 // 150
 687: 	uint16_t unkBattleFlags;	 // 160
 688: 	uint16_t specialAttackFlags; // 170
 689: 	uint16_t unkLimitDivisor;	 // 180
 690: 	uint16_t unkDword;			 // 190
 691: 	uint16_t stringArgs;
 692: 	uint16_t somethingEmerald; // 1A0
 693: 	uint32_t partyGil;		   // 1C0
 694: 	battle_actor_vars actor_vars[10];
 695: };
 696: 
 697: struct battle_anim_event {
 698:     byte attackerID;
 699:     byte activeAllies;
 700:     byte spellEffectID;
 701:     byte commandIndex;
 702:     byte actionFlags;
 703:     byte animationScriptID;
 704:     uint16_t actionIndex;
 705:     uint16_t cameraData;
 706:     uint16_t damageEventQueueIdx;
 707: };
 708: 
 709: struct formation_camera{
 710: 	vector3<short> position;
 711: 	vector3<short> focal_point;
 712: };
 713: 
 714: struct bcamera_position{
 715: 	vector3<short> point;
 716: 	WORD unused_6;
 717: 	short current_position;
 718: 	short frames_to_wait;
 719: 	byte field_C;
 720: 	byte field_D;
 721: };
 722: 
 723: struct bcamera_fn_data{
 724: 	WORD field_0;
 725: 	WORD field_2;
 726: 	WORD n_frames;
 727: 	short field_6;
 728: 	short field_8;
 729: 	short field_A;
 730: 	short field_C;
 731: 	short field_E;
 732: 	short field_10;
 733: 	byte unused_12[6];
 734: 	byte field_18;
 735: 	byte unused_19[15];
 736: };
 737: 
 738: struct battle_model_state
 739: {
 740:     uint16_t characterID;     // BE1178, 0
 741:     uint16_t animScriptIndex; // BE117A, 2
 742:     byte actionFlags;
 743:     byte field_5;
 744:     short field_6;
 745:     uint16_t AnimationData; // BE1180, 8
 746:     uint16_t animScriptPtr; // BE1182, 0xA
 747:     uint16_t field_C;
 748:     uint16_t runningAnimIdx; // 0xE
 749:     uint16_t totalBones;
 750:     uint16_t height;
 751:     short field_14;
 752:     uint16_t initialXRotation;
 753:     uint16_t initialYRotation;
 754:     uint16_t initialZRotation;
 755:     uint16_t field_1C;
 756:     uint16_t field_1E;
 757:     uint16_t field_20;
 758:     byte animationEffect; // BE119A, 0x22
 759:     byte commandID;       // BE119B, 0x23
 760:     byte field_24;
 761:     byte field_25;
 762:     byte actorIsNotActing;
 763:     byte field_27;
 764:     byte field_28;
 765:     byte unkActorFlags;
 766:     byte field_2A;
 767:     byte bData0x12[16];         // 0x2B
 768:     byte isScriptExecuting;     // BE11B3, 0x3B
 769:     byte currentScriptPosition; // 0x3C
 770:     byte waitFrames;            // 0x3D
 771:     byte modelEffectFlags;      // 0x3E
 772:     byte field_3F;
 773:     uint32_t field_40;
 774:     uint32_t field_44;
 775:     uint32_t field_48;
 776:     uint32_t field_4C;
 777:     uint32_t field_50;
 778:     uint32_t field_54;
 779:     uint32_t field_58;
 780:     uint32_t field_5C;
 781:     uint32_t field_60;
 782:     uint32_t field_64;
 783:     uint32_t field_68;
 784:     uint32_t field_6C;
 785:     uint32_t field_70;
 786:     uint32_t field_74;
 787:     byte padding3[0xE6];       // 0x78
 788: 	vector3<uint16_t> modelRotation; // BE12D8, 0x15E
 789:     uint16_t field_164;
 790: 	vector3<short> modelPosition; // BE12DE, 0x166
 791:     uint32_t field_16C;
 792:     uint32_t *field_170;
 793:     uint32_t field_174;
 794:     byte padding5[0xA24];
 795:     uint32_t playedAnimFrames;
 796:     uint32_t currentPlayingFrame;
 797:     uint32_t tableRelativeModelAnimIdx;
 798:     uint32_t *modelDataPtr;
 799:     byte padding4[0xF18];
 800:     uint32_t setForLimitBreaks; // 0x1AC4
 801:     uint32_t field_1AC8;
 802:     float field_1ACC;
 803:     float field_1AD0;
 804:     float field_1AD4;
 805:     uint32_t padding_1AD8;
 806:     float field_1ADC;
 807:     uint32_t padding_1AE0;
 808:     uint32_t field_1AE4;
 809:     uint32_t field_1AE8;
 810: };
 811: 
 812: struct battle_model_state_small
 813: {
 814:     uint32_t field_0;
 815:     uint16_t bData68[4];
 816:     uint16_t field_C;
 817:     uint16_t bData76[6];
 818:     uint16_t bData88[6];
 819:     uint16_t actorIsNotActing;
 820:     uint16_t field_28;
 821:     uint16_t field_2A;
 822:     uint16_t someHPCopy;
 823:     uint16_t field_2E;
 824:     uint16_t someMPCopy;
 825:     byte modelDataIndex; // 0x032
 826:     byte field_33;
 827:     byte innateStatusMask;
 828:     byte field_35;
 829:     byte field_36;
 830:     byte field_37;
 831:     uint16_t field_38;
 832:     uint16_t field_3A;
 833:     uint16_t field_3C;
 834:     uint16_t actionIdx;
 835:     byte field_40;
 836:     byte field_41;
 837:     byte field_42;
 838:     byte field_43;
 839:     byte field_44;
 840:     byte field_45;
 841:     byte field_46;
 842:     byte field_47;
 843:     byte field_48;
 844:     byte field_49;
 845:     byte field_4A;
 846:     byte field_4B;
 847:     byte field_4C;
 848:     byte field_4D;
 849:     byte field_4E;
 850:     byte field_4F;
 851:     byte field_50;
 852:     byte field_51;
 853:     byte field_52;
 854:     byte field_53;
 855:     byte field_54;
 856:     byte field_55;
 857:     byte field_56;
 858:     byte field_57;
 859:     byte field_58;
 860:     byte field_59;
 861:     byte field_5A;
 862:     byte field_5B;
 863:     byte field_5C;
 864:     byte field_5D;
 865:     byte field_5E;
 866:     byte field_5F;
 867:     byte field_60;
 868:     byte field_61;
 869:     byte field_62;
 870:     byte field_63;
 871:     byte field_64;
 872:     byte field_65;
 873:     byte field_66;
 874:     byte field_67;
 875:     byte field_68;
 876:     byte field_69;
 877:     byte field_6A;
 878:     byte field_6B;
 879:     byte field_6C;
 880:     byte field_6D;
 881:     byte field_6E;
 882:     byte field_6F;
 883:     byte field_70;
 884:     byte field_71;
 885:     byte field_72;
 886:     byte field_73;
 887: };
 888: 
 889: struct effect100_data
 890: {
 891:     uint16_t field_0;
 892:     short field_2;
 893:     short n_frames;
 894:     short field_6;
 895:     short field_8;
 896:     short field_A;
 897:     short field_C;
 898:     short field_E;
 899:     int field_10;
 900:     int field_14;
 901:     byte field_18;
 902:     byte field_19;
 903: 	short field_1A;
 904:     byte field_1C[4];
 905: };
 906: 
 907: struct effect60_data
 908: {
 909:     uint16_t field_0;
 910:     short field_2;
 911:     short n_frames;
 912:     short field_6;
 913:     short field_8;
 914:     short field_A;
 915:     uint16_t padding;
 916:     short field_E;
 917:     int field_10;
 918:     int field_14;
 919:     byte field_18;
 920:     byte field_19[7];
 921: };
 922: 
 923: struct effect10_data
 924: {
 925:     uint16_t field_0;
 926:     short field_2;
 927:     short n_frames;
 928:     short field_6;
 929:     short field_8;
 930:     short field_A;
 931:     short field_C;
 932:     short field_E;
 933:     int field_10;
 934:     int field_14;
 935:     byte field_18;
 936:     byte field_19;
 937:     byte field_1A;
 938:     byte field_1B[5];
 939: };
 940: 
 941: struct material_anim_ctx
 942: {
 943:     uint32_t *materialRSD;
 944:     uint32_t negateColumnFlags;
 945:     WORD field_8;
 946:     short transparency;
 947:     short field_C;
 948:     short paletteIdx;
 949: };
 950: 
 951: struct palette_extra
 952: {
 953:     int x_offset;
 954:     p_hundred *aux_gfx_ptr;
 955:     int z_offset_2;
 956:     int y_offset;
 957:     int scroll_v;
 958:     int v_offset;
 959:     int z_offset;
 960:     int field_1C;
 961:     int field_20;
 962:     int field_24;
 963:     int field_28;
 964: };
 965: 
 966: struct page_spt
 967: {
 968:     int field_0;
 969:     short field_4;
 970:     short field_6;
 971:     short uScale;
 972:     short vScale;
 973:     short field_C;
 974:     short palette_something;
 975:     short field_10;
 976:     short field_12;
 977: };
 978: 
 979: struct tex_page_list
 980: {
 981:     WORD *field_0;
 982:     page_spt *page_spt_ptr;
 983: };
 984: 
 985: struct texture_spt
 986: {
 987:     int *spt_handle_copy;
 988:     tex_page_list *pages;
 989:     byte *spt_handle;
 990:     int tex_page_count;
 991:     uint32_t field_10[4];
 992:     ff7_graphics_object *game_drawable[4];
 993: };
 994: 
 995: struct texture_spt_anim_ctx
 996: {
 997:     texture_spt *effect_spt;
 998:     ff7_graphics_object *effectDrawable;
 999:     color_ui8 color;
1000:     WORD field_C;
1001:     WORD field_E;
1002: };
1003: 
1004: #pragma pack(push, 1)
1005: struct rotation_matrix
1006: {
1007:     short r3_sub_matrix[3][3];
1008:     int position[3];
1009: };
1010: #pragma pack(pop)
1011: 
1012: #pragma pack(push, 1)
1013: struct transform_matrix
1014: {
1015:   int16_t eye_x;
1016:   int16_t eye_y;
1017:   int16_t eye_z;
1018:   int16_t target_x;
1019:   int16_t target_y;
1020:   int16_t target_z;
1021:   int16_t up_x;
1022:   int16_t up_y;
1023:   int16_t up_z;
1024:   int pos_x;
1025:   int pos_y;
1026:   int pos_z;
1027: };
1028: #pragma pack(pop)
1029: 
1030: #pragma pack(push, 1)
1031: struct ff7_game_engine_data
1032: {
1033: 	float scale;
1034: 	byte field_4[4];
1035: 	double field_8;
1036: 	rotation_matrix rot_matrix;
1037: 	byte field_2E[2];
1038: 	DWORD field_30;
1039: 	DWORD field_34;
1040: 	float float_delta_x;
1041: 	float float_delta_y;
1042: 	vector2<int> world_coord;
1043: 	int do_not_transpose;
1044: 	color_ui8 primary_color;
1045: 	color_ui8 secondary_color;
1046: 	float field_54;
1047: 	float field_58;
1048: };
1049: #pragma pack(pop)
1050: 
1051: struct battle_text_data
1052: {
1053: 	short buffer_idx;
1054: 	short field_2;
1055: 	byte wait_frames;
1056: 	byte n_frames;
1057: };
1058: 
1059: struct battle_chdir_struc
1060: {
1061: 	uint32_t sucess;
1062: 	char olddir[200];
1063: };
1064: 
1065: struct battle_hrc_bone
1066: {
1067: 	uint32_t parent;
1068: 	float bone_length;
1069: 	uint32_t num_rsd;
1070: };
1071: 
1072: struct battle_hrc_header
1073: {
1074: 	uint32_t field_0;
1075: 	uint32_t field_4;
1076: 	uint32_t field_8;
1077: 	uint32_t bones;
1078: 	uint32_t field_10;
1079: 	uint32_t field_14;
1080: 	uint32_t num_textures;
1081: 	uint32_t num_animations_1;
1082: 	uint32_t animations_2_start_index;
1083: 	uint32_t num_weapons;
1084: 	uint32_t num_animations_2;
1085: 	uint32_t field_2C;
1086: 	struct battle_hrc_bone *bone_data;
1087: };
1088: 
1089: struct anim_frame_header
1090: {
1091: 	vector3<float> root_rotation;
1092: 	vector3<float> root_translation;
1093: };
1094: 
1095: struct anim_frame
1096: {
1097: 	struct anim_frame_header *header;
1098: 	vector3<float> *data;
1099: };
1100: 
1101: struct anim_header
1102: {
1103: 	union
1104: 	{
1105: 		struct
1106: 		{
1107: 			uint32_t version;
1108: 		} version;
1109: 
1110: 		struct
1111: 		{
1112: 			char *pc_name;
1113: 		} file;
1114: 	};
1115: 	uint32_t num_frames;
1116: 	uint32_t num_bones;
1117: 	char rotation_order[4];
1118: 	void *frame_data;
1119: 	struct anim_frame *anim_frames;
1120: 	uint32_t use_matrix_array;
1121: 	struct matrix *matrix_array;
1122: 	struct matrix *current_matrix_array;
1123: };
1124: 
1125: struct hrc_data
1126: {
1127: 	uint32_t field_0;
1128: 	uint32_t field_4;
1129: 	uint32_t debug;
1130: 	uint32_t flags;
1131: 	uint32_t num_bones;
1132: 	struct hrc_bone *bones;
1133: 	uint32_t field_18;
1134: 	struct list *bone_list;
1135: 	struct ff7_game_obj *game_object;
1136: 	struct matrix field_24;
1137: 	struct matrix field_64;
1138: 	uint32_t *field_A4;
1139: };
1140: 
1141: struct hrc_bone
1142: {
1143: 	char *bone_name;
1144: 	char *bone_parent;
1145: 	uint32_t parent_index;
1146: 	float bone_length;
1147: 	uint32_t num_rsd;
1148: 	char **rsd_names;
1149: 	struct rsd_array_member *rsd_array;
1150: };
1151: 
1152: struct bone_list_member
1153: {
1154: 	WORD bone_type;
1155: 	WORD bone_index;
1156: };
1157: 
1158: struct rsd_array_member
1159: {
1160: 	uint32_t field_0;
1161: 	struct rsd_data *rsd_data;
1162: };
1163: 
1164: struct rsd_data
1165: {
1166: 	struct matrix_set *matrix_set;
1167: 	struct ff7_polygon_set *polygon_set;
1168: 	struct pd_data *pd_data;
1169: };
1170: 
1171: #pragma pack(push, 1)
1172: struct ff7_hrc_polygon_data
1173: {
1174:   int version;
1175:   DWORD dword4;
1176:   DWORD number_of_frames;
1177:   DWORD dwordC;
1178:   DWORD dword10;
1179:   DWORD dword14;
1180:   BYTE gap18[4];
1181:   DWORD dword1C;
1182:   BYTE gap20[8];
1183:   DWORD dword28;
1184:   int fps;
1185:   DWORD dword30;
1186:   DWORD dword34;
1187:   struc_110 struc_110;
1188:   BYTE gapAC[4];
1189:   DWORD dwordB0;
1190:   hrc_data *hrc_data;
1191:   ff7_game_obj *game_obj;
1192:   __int64 lag;
1193:   unsigned __int64 current_time;
1194:   BYTE gapCC[8];
1195:   file_context file_contextD4;
1196: };
1197: #pragma pack(pop)
1198: 
1199: struct lgp_toc_entry
1200: {
1201: 	char name[16];
1202: 	uint32_t offset;
1203: 	WORD unknown1;
1204: 	WORD conflict;
1205: };
1206: 
1207: struct lookup_table_entry
1208: {
1209: 	unsigned short toc_offset;
1210: 	unsigned short num_files;
1211: };
1212: 
1213: struct conflict_entry
1214: {
1215: 	char name[128];
1216: 	unsigned short toc_index;
1217: };
1218: 
1219: struct conflict_list
1220: {
1221: 	uint32_t num_conflicts;
1222: 	struct conflict_entry *conflict_entries;
1223: };
1224: 
1225: struct lgp_folders
1226: {
1227: 	struct conflict_list conflicts[1000];
1228: };
1229: 
1230: struct hpmp_bar
1231: {
1232: 	WORD x;
1233: 	WORD y;
1234: 	WORD w;
1235: 	WORD h;
1236: 	WORD value1;
1237: 	WORD max_value;
1238: 	WORD healing_animation;
1239: 	WORD value2;
1240: 	uint32_t color;
1241: };
1242: 
1243: struct savemap_char
1244: {
1245: 	char id;
1246: 	char level;
1247: 	char field_2;
1248: 	char field_3;
1249: 	char field_4;
1250: 	char field_5;
1251: 	char dex;
1252: 	char field_7;
1253: 	char field_8;
1254: 	char field_9;
1255: 	char field_A;
1256: 	char field_B;
1257: 	char field_C;
1258: 	char field_D;
1259: 	char current_limit_level;
1260: 	unsigned char current_limit_bar;
1261: 	char name[12];
1262: 	char equipped_weapon;
1263: 	char equipped_armor;
1264: 	char field_1E;
1265: 	char flags;
1266: 	char field_20;
1267: 	unsigned char level_progress_bar;
1268: 	WORD learned_limit_break;
1269: 	WORD num_kills;
1270: 	WORD used_n_limit_1_1;
1271: 	WORD field_28;
1272: 	WORD field_2A;
1273: 	WORD hp;
1274: 	WORD base_hp;
1275: 	WORD mp;
1276: 	WORD base_mp;
1277: 	uint32_t field_34;
1278: 	WORD max_hp;
1279: 	WORD max_mp;
1280: 	uint32_t current_exp;
1281: 	uint32_t equipped_materia[16];
1282: 	uint32_t exp_to_next_level;
1283: };
1284: 
1285: struct chocobo_slot
1286: {
1287: 	WORD sprint_speed;
1288: 	WORD max_sprint_speed;
1289: 	WORD speed;
1290: 	WORD max_speed;
1291: 	char acceleration;
1292: 	char cooperation;
1293: 	char intelligence;
1294: 	char personality;
1295: 	char p_count;
1296: 	char n_races_won;
1297: 	boolean is_female;
1298: 	char type;
1299: };
1300: 
1301: #pragma pack(push,1)
1302: 
1303: struct savemap
1304: {
1305: 	uint32_t checksum;
1306: 	char preview_level;
1307: 	char preview_portraits[3];
1308: 	char preview_char_name[16];
1309: 	WORD preview_hp;
1310: 	WORD preview_maxhp;
1311: 	WORD preview_mp;
1312: 	WORD preview_maxmp;
1313: 	uint32_t preview_gil;
1314: 	uint32_t preview_seconds;
1315: 	char preview_location[32];
1316: 	char ul_window_red;
1317: 	char ul_window_green;
1318: 	char ul_window_blue;
1319: 	char ur_window_red;
1320: 	char ur_window_green;
1321: 	char ur_window_blue;
1322: 	char ll_window_red;
1323: 	char ll_window_green;
1324: 	char ll_window_blue;
1325: 	char lr_window_red;
1326: 	char lr_window_green;
1327: 	char lr_window_blue;
1328: 	savemap_char chars[9];
1329: 	byte party_members[3];
1330: 	char padding_4FB;
1331: 	WORD items[320];
1332: 	uint32_t materia[200];
1333: 	uint32_t stolen_materia[48];
1334: 	char field_B5C[32];
1335: 	uint32_t gil;
1336: 	uint32_t seconds;
1337: 	uint32_t countdown_timer;
1338: 	char field_B88[12];
1339: 	WORD current_mode;
1340: 	WORD current_location;
1341: 	WORD field_B98;
1342: 	WORD x;
1343: 	WORD y;
1344: 	WORD z_walkmeshtri;
1345: 	char field_BA0[467];
1346: 	char yuffie_reg_mask;
1347: 	char field_D74[80];
1348: 	chocobo_slot chocobo_slots_first[4];
1349: 	char field_E04[240];
1350: 	char vincent_reg_mask;
1351: 	char field_EF5[399];
1352: 	chocobo_slot chocobo_slots_last[2];
1353: 	WORD phs_lock;
1354: 	WORD phs_visi;
1355: 	char field_10A8[48];
1356: 	char battle_speed;
1357: 	char battle_msg_speed;
1358: 	char config_bitmap_1;
1359: 	char config_bitmap_2;
1360: 	char controller_mapping[16];
1361: 	char message_speed;
1362: 	char field_10ED[7];
1363: };
1364: 
1365: struct weapon_data
1366: {
1367: 	char field_0;
1368: 	char field_1;
1369: 	char field_2;
1370: 	char field_3;
1371: 	unsigned char attack_stat;
1372: 	char field_5;
1373: 	char field_6;
1374: 	char field_7;
1375: 	char field_8;
1376: 	char field_9;
1377: 	char field_A;
1378: 	char field_B;
1379: 	WORD field_C;
1380: 	WORD field_E;
1381: 	WORD field_10;
1382: 	WORD field_12;
1383: 	char stat_increase_types[4];
1384: 	char stat_increase_amounts[4];
1385: 	char field_1C[8];
1386: 	char field_24;
1387: 	char field_25;
1388: 	char field_26;
1389: 	char field_27;
1390: 	WORD field_28;
1391: 	WORD field_2A;
1392: };
1393: 
1394: struct armor_data
1395: {
1396: 	char field_0;
1397: 	char field_1;
1398: 	unsigned char defense_stat;
1399: 	unsigned char mdef_stat;
1400: 	char field_4;
1401: 	char field_5;
1402: 	char field_6;
1403: 	WORD field_7;
1404: 	char field_9[8];
1405: 	char field_11;
1406: 	WORD field_12;
1407: 	WORD field_14;
1408: 	WORD field_16;
1409: 	uint32_t field_18;
1410: 	uint32_t field_1C;
1411: 	WORD field_20;
1412: 	WORD field_22;
1413: };
1414: 
1415: struct party_member_data
1416: {
1417: 	char field_0;
1418: 	char field_1;
1419: 	char field_2;
1420: 	char field_3;
1421: 	char field_4;
1422: 	char field_5;
1423: 	char field_6;
1424: 	char field_7;
1425: 	WORD field_8;
1426: 	WORD field_A;
1427: 	WORD field_C;
1428: 	WORD field_E;
1429: 	WORD hp;
1430: 	WORD max_hp;
1431: 	WORD mp;
1432: 	WORD max_mp;
1433: 	WORD field_18;
1434: 	WORD field_1A;
1435: 	WORD field_1C;
1436: 	WORD field_1E;
1437: 	char field_20;
1438: 	char field_21;
1439: 	char field_22;
1440: 	char field_23;
1441: 	char field_24[24];
1442: 	WORD field_3C;
1443: 	WORD field_3E;
1444: 	WORD field_40;
1445: 	WORD field_42;
1446: 	uint32_t field_44;
1447: 	uint32_t field_48;
1448: 	uint32_t field_4C[24];
1449: 	char field_AC[8];
1450: 	uint32_t field_B4[21];
1451: 	uint32_t field_108[112];
1452: 	uint32_t field_2C8[32];
1453: 	uint32_t field_348[48];
1454: 	struct weapon_data weapon_data;
1455: 	uint32_t field_434;
1456: 	uint32_t field_438;
1457: 	uint32_t field_43C;
1458: };
1459: 
1460: #pragma pack(pop)
1461: 
1462: struct field_tile
1463: {
1464: 	short x;
1465: 	short y;
1466: 	float z;
1467: 	WORD field_8;
1468: 	WORD field_A;
1469: 	WORD img_x;
1470: 	WORD img_y;
1471: 	float u;
1472: 	float v;
1473: 	WORD fx_img_x;
1474: 	WORD fx_img_y;
1475: 	uint32_t field_1C;
1476: 	uint32_t field_20;
1477: 	uint32_t field_24;
1478: 	uint32_t field_28;
1479: 	WORD tile_size_x;
1480: 	WORD tile_size_y;
1481: 	WORD palette_index;
1482: 	WORD flags;
1483: 	char anim_group;
1484: 	char anim_bitmask;
1485: 	WORD field_36;
1486: 	char field_38[4096];
1487: 	WORD field_1038;
1488: 	WORD field_103A;
1489: 	uint32_t use_fx_page;
1490: 	uint32_t field_1040;
1491: 	uint32_t field_1044;
1492: 	uint32_t field_1048;
1493: 	uint32_t field_104C;
1494: 	char field_1050;
1495: 	char field_1051;
1496: 	char field_1052;
1497: 	char field_1053;
1498: 	WORD blend_mode;
1499: 	WORD page;
1500: 	WORD fx_page;
1501: 	WORD field_105A;
1502: };
1503: 
1504: struct struc_3
1505: {
1506: 	uint32_t field_0;
1507: 	uint32_t field_4;
1508: 	uint32_t convert_animations;
1509: 	uint32_t create_matrix_set;
1510: 	uint32_t field_10;
1511: 	uint32_t matrix_set_size;
1512: 	struct graphics_instance *graphics_instance;
1513: 	uint32_t field_1C;
1514: 	uint32_t blend_mode;
1515: 	uint32_t base_directory;
1516: 	struct ff7_tex_header *tex_header;
1517: 	uint32_t field_2C;
1518: 	uint32_t light;
1519: 	uint32_t field_34;
1520: 	float bone_scale_factor;
1521: 	uint32_t field_3C;
1522: 	struct file_context file_context;
1523: 	uint32_t field_50;
1524: 	uint32_t field_54;
1525: 	uint32_t field_58;
1526: 	uint32_t palette_index;
1527: 	uint32_t field_60;
1528: 	uint32_t field_64;
1529: 	uint32_t field_68;
1530: 	uint32_t field_6C;
1531: 	uint32_t field_70;
1532: };
1533: 
1534: struct wordmatrix
1535: {
1536: 	WORD _11;
1537: 	WORD _12;
1538: 	WORD _13;
1539: 	WORD _21;
1540: 	WORD _22;
1541: 	WORD _23;
1542: 	WORD _31;
1543: 	WORD _32;
1544: 	WORD _33;
1545: 	uint32_t _41;
1546: 	uint32_t _42;
1547: 	uint32_t _43;
1548: };
1549: 
1550: struct struc_154_2
1551: {
1552: 	short field_0;
1553: 	WORD field_2;
1554: 	WORD field_4;
1555: 	WORD field_6;
1556: 	WORD field_8;
1557: 	WORD field_A;
1558: 	WORD field_C;
1559: 	WORD field_E;
1560: 	uint32_t field_10;
1561: 	uint32_t field_14;
1562: 	unsigned char field_18[8];
1563: };
1564: 
1565: struct struc_154_3
1566: {
1567: 	short field_0;
1568: 	WORD field_2;
1569: 	WORD field_4;
1570: 	WORD field_6;
1571: 	WORD field_8;
1572: 	WORD field_A;
1573: 	WORD field_C;
1574: 	WORD field_E;
1575: 	uint32_t field_10;
1576: 	uint32_t field_14;
1577: 	unsigned char field_18[8];
1578: };
1579: 
1580: struct struc_154
1581: {
1582: 	short field_0;
1583: 	WORD field_2;
1584: 	WORD field_4;
1585: 	WORD field_6;
1586: 	WORD field_8;
1587: 	WORD field_A;
1588: 	WORD field_C;
1589: 	WORD field_E;
1590: 	uint32_t field_10;
1591: 	uint32_t field_14;
1592: 	unsigned char field_18[8];
1593: };
1594: 
1595: struct struc_205
1596: {
1597: 	short field_0;
1598: 	WORD field_2;
1599: 	WORD field_4;
1600: 	WORD field_6;
1601: 	WORD field_8;
1602: 	WORD field_A;
1603: 	WORD field_C;
1604: 	WORD field_E;
1605: 	uint32_t field_10;
1606: 	uint32_t field_14;
1607: 	unsigned char field_18[16];
1608: };
1609: 
1610: struct movie_obj
1611: {
1612: 	void *ddstream;
1613: 	uint32_t field_4;
1614: 	void *mediastream;
1615: 	uint32_t loop;
1616: 	uint32_t field_10;
1617: 	DDSURFACEDESC movie_sdesc;
1618: 	void *graphbuilder;
1619: 	uint32_t movie_surfaceheight;
1620: 	uint32_t field_88;
1621: 	void *amms;
1622: 	void *movie_surface;
1623: 	void *sample;
1624: 	uint32_t movie_left;
1625: 	uint32_t movie_top;
1626: 	uint32_t movie_right;
1627: 	uint32_t movie_bottom;
1628: 	uint32_t target_left;
1629: 	uint32_t target_top;
1630: 	uint32_t target_right;
1631: 	uint32_t target_bottom;
1632: 	void *sts1;
1633: 	void *vts1;
1634: 	void *sts2;
1635: 	void *vts2;
1636: 	void *st1;
1637: 	void *vt1;
1638: 	void *st2;
1639: 	void *vt2;
1640: 	uint32_t vt1handle;
1641: 	uint32_t vt2handle;
1642: 	uint32_t field_E0;
1643: 	uint32_t movie_surfacewidth;
1644: 	uint32_t field_E8;
1645: 	struct nvertex movie_vt2prim[4];
1646: 	struct nvertex movie_vt1prim[4];
1647: 	void *mediaseeking;
1648: 	uint32_t graphics_mode;
1649: 	uint32_t field_1F4;
1650: 	uint32_t field_1F8;
1651: 	uint32_t is_playing;
1652: 	uint32_t movie_end;
1653: 	uint32_t global_movie_flag;
1654: };
1655: 
1656: struct dll_gfx_externals
1657: {
1658: 	void *(*assert_free)(void *, const char *, uint32_t);
1659: 	void *(*assert_malloc)(uint32_t, const char *, uint32_t);
1660: 	void *(*assert_calloc)(uint32_t, uint32_t, const char *, uint32_t);
1661: 	struct texture_format *(*create_texture_format)();
1662: 	void (*add_texture_format)(struct texture_format *, struct game_obj *);
1663: 	struct game_obj *(*get_game_object)();
1664: 	uint32_t free_driver;
1665: 	uint32_t create_gfx_driver;
1666: 	void (*make_pixelformat)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, struct texture_format *);
1667: 	uint32_t gltexformat2texformat;
1668: 	uint32_t sub_686143;
1669: 	uint32_t sub_6861EC;
1670: 	uint32_t sub_68631E;
1671: 	uint32_t sub_686351;
1672: 	uint32_t pal_pixel2bgra;
1673: 	uint32_t pal_pixel2bgra_8bit;
1674: 	uint32_t texture_set_destroy_pal;
1675: 	struct palette *(*create_palette_for_tex)(uint32_t, struct tex_header *, struct texture_set *);
1676: 	uint32_t convert_texture;
1677: 	uint32_t texture_set_decref;
1678: 	struct texture_set *(*create_texture_set)();
1679: 	uint32_t write_palette;
1680: 	uint32_t rgba2d3dcol;
1681: 	uint32_t sub_6A5FEB;
1682: 	uint32_t sub_6A604A;
1683: 	uint32_t destroy_palette;
1684: 	uint32_t create_palette;
1685: 	uint32_t call_gfx_write_palette;
1686: 	uint32_t call_gfx_palette_changed;
1687: 	uint32_t sub_6A5A70;
1688: 	uint32_t sub_6A5BA0;
1689: 	uint32_t sub_6A5C3B;
1690: 	uint32_t sub_6A5CE2;
1691: 	void *(*sub_6A2865)(void *);
1692: 	gfx_load_group *generic_load_group;
1693: 	gfx_light_polygon_set *generic_light_polygon_set;
1694: };
1695: 
1696: struct ff7_audio_fmt
1697: {
1698: 	uint32_t length;
1699: 	uint32_t offset;
1700: 	uint32_t loop;
1701: 	uint32_t count;
1702: 	uint32_t loop_start;
1703: 	uint32_t loop_end;
1704: 	LPWAVEFORMATEX wave_format;
1705: };
1706: 
1707: struct ff7_game_obj
1708: {
1709: 	uint32_t do_quit;
1710: 	uint32_t dc_horzres;
1711: 	uint32_t dc_vertres;
1712: 	uint32_t dc_bitspixel;
1713: 	uint32_t window_pos_x;
1714: 	uint32_t window_pos_y;
1715: 	uint32_t window_size_x;
1716: 	uint32_t window_size_y;
1717: 	uint32_t window_minimized;
1718: 	uint32_t field_24;
1719: 	uint32_t field_28;
1720: 	uint32_t field_2C;
1721: 	double countspersecond;
1722: 	time_t _countspersecond;
1723: 	uint32_t field_40;
1724: 	uint32_t field_44;
1725: 	double fps;
1726: 	uint32_t tsc;
1727: 	uint32_t field_54;					// tsc high bits?
1728: 	HINSTANCE hinstance;
1729: 	HWND hwnd;
1730: 	uint32_t field_60;
1731: 	uint32_t field_64;
1732: 	uint32_t field_68;
1733: 	uint32_t field_6C;
1734: 	uint32_t field_70;
1735: 	void *dddevice;
1736: 	void *dd2interface;
1737: 	LPDIRECTDRAWSURFACE front_surface[3];
1738: 	DDSURFACEDESC front_surface_desc[3];
1739: 	uint32_t field_1CC;
1740: 	uint32_t field_1D0;
1741: 	IDirectDrawClipper* dd_clipper;
1742: 	uint32_t field_1D8;
1743: 	DDSURFACEDESC d3d_surfacedesc;
1744: 	void *dd_interface;
1745: 	uint32_t field_24C;
1746: 	DDSURFACEDESC dd_surfacedesc;
1747: 	struct list *d3ddev_list;
1748: 	void *d3dinterface;
1749: 	void *surface_d3ddev;			// IDirect3DDevice
1750: 	struct list *textureformat_list;
1751: 	void *d3ddev_struct;
1752: 	void *d3dviewport;
1753: 	void *d3dmaterial;
1754: 	uint32_t field_2D8;
1755: 	void *d3d2interface;
1756: 	void *d3d2device;
1757: 	void *d3dviewport2;
1758: 	struct list *list_2E8;
1759: 	struct polygon_set *polygon_set_2EC;
1760: 	struct polygon_set *polygon_set_2F0;
1761: 	struct stack *matrix_stack1;
1762: 	struct stack *matrix_stack2;
1763: 	struct matrix *camera_matrix;
1764: 	struct graphics_instance *graphics_instance;
1765: 	uint32_t field_304;
1766: 	uint32_t field_308;
1767: 	uint32_t field_30C;
1768: 	uint32_t field_310;
1769: 	uint32_t field_314;
1770: 	uint32_t field_318;
1771: 	uint32_t field_31C;
1772: 	uint32_t field_320;
1773: 	D3DDEVICEDESC d3d_halcaps;
1774: 	D3DDEVICEDESC d3d_helcaps;
1775: 	DDCAPS_DX5 halcaps;
1776: 	DDCAPS_DX5 helcaps;
1777: 	uint32_t field_794;
1778: 	uint32_t field_798;
1779: 	struct texture_format surface_tex_format;
1780: 	uint32_t in_scene;
1781: 	struct p_hundred *hundred_array[5];
1782: 	void *applog_debug1;
1783: 	uint32_t applog_debug2;
1784: 	void *dxdbg_file;
1785: 	uint32_t field_840;
1786: 	uint32_t field_844;
1787: 	uint32_t _res_x;
1788: 	uint32_t _res_y;
1789: 	uint32_t _res_w;
1790: 	uint32_t _res_h;
1791: 	uint32_t field_858;
1792: 	uint32_t field_85C;
1793: 	uint32_t field_860;
1794: 	uint32_t field_864;
1795: 	uint32_t field_868;
1796: 	uint32_t field_86C;
1797: 	uint32_t field_870;
1798: 	uint32_t field_874;
1799: 	uint32_t field_878;
1800: 	uint32_t field_87C;
1801: 	uint32_t field_880;
1802: 	uint32_t field_884;
1803: 	uint32_t field_888;
1804: 	uint32_t field_88C;
1805: 	struct matrix matrix_890;
1806: 	struct matrix matrix_8D0;
1807: 	void *dx_sfx_something;
1808: 	struct list *tex_list_pointer;
1809: 	struct stack *stack_918;
1810: 	uint32_t field_91C;
1811: 	void *_3d2d_something;
1812: 	uint32_t field_924;
1813: 	uint32_t field_928;
1814: 	uint32_t field_92C;
1815: 	uint32_t field_930;
1816: 	struct gfx_driver *gfx_driver;
1817: 	void *_3dobject_pool;
1818: 	uint32_t field_93C;
1819: 	struct p_hundred *current_hundred;
1820: 	struct struc_81 *field_944;
1821: 	uint32_t field_948;
1822: 	uint32_t field_94C;
1823: 	uint32_t field_950;
1824: 	uint32_t window_width;
1825: 	uint32_t window_height;
1826: 	uint32_t colordepth;
1827: 	uint32_t field_960;
1828: 	uint32_t is_fullscreen;
1829: 	uint32_t field_968;
1830: 	uint32_t no_hardware;
1831: 	uint32_t field_970;
1832: 	uint32_t show_cursor;
1833: 	uint32_t colorkey;
1834: 	uint32_t field_97C;
1835: 	uint32_t field_980;
1836: 	uint32_t d3d2_flag;
1837: 	uint32_t field_988;
1838: 	uint32_t field_98C;
1839: 	uint32_t field_990;
1840: 	uint32_t field_994;
1841: 	uint32_t matrix_stack_size;
1842: 	uint32_t field_99C;
1843: 	uint32_t field_9A0;
1844: 	uint32_t field_9A4;
1845: 	uint32_t field_9A8;
1846: 	uint32_t field_9AC;
1847: 	uint32_t random_seed;
1848: 	char *window_title;
1849: 	char *window_class;
1850: 	uint32_t use_custom_wndclass;
1851: 	WNDCLASSA wndclass_struct;
1852: 	uint32_t use_custom_dwStyle;
1853: 	DWORD dwStyle;
1854: 	struct main_obj engine_loop_obj;
1855: 	struct main_obj game_loop_obj;
1856: 	void *wm_activate;
1857: 	uint32_t field_A2C;
1858: 	uint32_t field_A30;
1859: 	uint32_t field_A34;
1860: 	uint32_t field_A38;
1861: 	uint32_t field_A3C;
1862: 	uint32_t field_A40;
1863: 	uint32_t field_A44;
1864: 	uint32_t field_A48;
1865: 	uint32_t field_A4C;
1866: 	uint32_t field_A50;
1867: 	uint32_t gfx_reset;
1868: 	uint32_t field_A58;
1869: 	uint32_t field_A5C;
1870: 	uint32_t current_gfx_driver;
1871: 	uint32_t field_A64;
1872: 	uint32_t field_A68;
1873: 	uint32_t field_A6C;
1874: 	uint32_t field_A70;
1875: 	uint32_t field_A74;
1876: 	uint32_t field_A78;
1877: 	void *gfx_driver_data;
1878: 	uint32_t field_A80;
1879: 	uint32_t field_A84;
1880: 	void *create_gfx_driver;
1881: 	struct dll_gfx_externals *externals;
1882: 	uint32_t nvidia_fix;
1883: 	uint32_t tnt_fix;
1884: 	uint32_t no_riva_fix;
1885: 	uint32_t field_A9C;
1886: };
1887: 
1888: struct ff7_gamepad_status
1889: {
1890: 	uint32_t pos_x;
1891: 	uint32_t pos_y;
1892: 	uint32_t dpad_up;
1893: 	uint32_t dpad_down;
1894: 	uint32_t dpad_left;
1895: 	uint32_t dpad_right;
1896: 	uint32_t button1;
1897: 	uint32_t button2;
1898: 	uint32_t button3;
1899: 	uint32_t button4;
1900: 	uint32_t button5;
1901: 	uint32_t button6;
1902: 	uint32_t button7;
1903: 	uint32_t button8;
1904: 	uint32_t button9;
1905: 	uint32_t button10;
1906: 	uint32_t button11;
1907: 	uint32_t button12;
1908: 	uint32_t button13;
1909: 	uint32_t button14;
1910: 	uint32_t button15;
1911: 	uint32_t button16;
1912: };
1913: 
1914: struct ff7_gfx_driver
1915: {
1916: 	gfx_init *init;
1917: 	gfx_cleanup *cleanup;
1918: 	gfx_lock *lock;
1919: 	gfx_unlock *unlock;
1920: 	gfx_flip *flip;
1921: 	gfx_clear *clear;
1922: 	gfx_clear_all *clear_all;
1923: 	gfx_setviewport *setviewport;
1924: 	gfx_setbg *setbg;
1925: 	uint32_t field_24;
1926: 	struct bgra_color field_28;			// ?
1927: 	uint32_t field_38;
1928: 	uint32_t field_3C;
1929: 	gfx_prepare_polygon_set *prepare_polygon_set;
1930: 	gfx_load_group *load_group;
1931: 	gfx_setmatrix *setmatrix;
1932: 	gfx_unload_texture *unload_texture;
1933: 	gfx_load_texture *load_texture;
1934: 	gfx_palette_changed *palette_changed;
1935: 	gfx_write_palette *write_palette;
1936: 	gfx_blendmode *blendmode;
1937: 	gfx_light_polygon_set *light_polygon_set;
1938: 	gfx_field_64 *field_64;
1939: 	gfx_setrenderstate *setrenderstate;
1940: 	gfx_setrenderstate *_setrenderstate;
1941: 	gfx_setrenderstate *__setrenderstate;
1942: 	gfx_field_74 *field_74;
1943: 	gfx_field_78 *field_78;
1944: 	gfx_draw_deferred *draw_deferred;
1945: 	gfx_field_80 *field_80;
1946: 	gfx_field_84 *field_84;
1947: 	gfx_begin_scene *begin_scene;
1948: 	gfx_end_scene *end_scene;
1949: 	gfx_field_90 *field_90;
1950: 	gfx_polysetrenderstate *setrenderstate_flat2D;
1951: 	gfx_polysetrenderstate *setrenderstate_smooth2D;
1952: 	gfx_polysetrenderstate *setrenderstate_textured2D;
1953: 	gfx_polysetrenderstate *setrenderstate_paletted2D;
1954: 	gfx_polysetrenderstate *_setrenderstate_paletted2D;
1955: 	gfx_draw_vertices *draw_flat2D;
1956: 	gfx_draw_vertices *draw_smooth2D;
1957: 	gfx_draw_vertices *draw_textured2D;
1958: 	gfx_draw_vertices *draw_paletted2D;
1959: 	gfx_polysetrenderstate *setrenderstate_flat3D;
1960: 	gfx_polysetrenderstate *setrenderstate_smooth3D;
1961: 	gfx_polysetrenderstate *setrenderstate_textured3D;
1962: 	gfx_polysetrenderstate *setrenderstate_paletted3D;
1963: 	gfx_polysetrenderstate *_setrenderstate_paletted3D;
1964: 	gfx_draw_vertices *draw_flat3D;
1965: 	gfx_draw_vertices *draw_smooth3D;
1966: 	gfx_draw_vertices *draw_textured3D;
1967: 	gfx_draw_vertices *draw_paletted3D;
1968: 	gfx_polysetrenderstate *setrenderstate_flatlines;
1969: 	gfx_polysetrenderstate *setrenderstate_smoothlines;
1970: 	gfx_draw_vertices *draw_flatlines;
1971: 	gfx_draw_vertices *draw_smoothlines;
1972: 	gfx_field_EC *field_EC;
1973: };
1974: 
1975: struct ff7_field_sfx_state {
1976: 	uint32_t u1;
1977: 	uint32_t volume1;
1978: 	uint32_t volume2;
1979: 	uint32_t u2;
1980: 	uint32_t u3;
1981: 	uint32_t u4;
1982: 	uint32_t pan1;
1983: 	uint32_t pan2;
1984: 	uint32_t u5;
1985: 	uint32_t u6;
1986: 	uint32_t u7;
1987: 	uint32_t byte;
1988: 	uint32_t u9;
1989: 	uint32_t u10;
1990: 	uint32_t u11;
1991: 	uint32_t frequency;
1992: 	uint32_t sound_id;
1993: 	IDirectSoundBuffer* buffer1;
1994: 	IDirectSoundBuffer* buffer2;
1995: 	uint32_t is_looped;
1996: 	uint32_t u12;
1997: };
1998: 
1999: struct ff7_camdata
2000: {
2001: 	// EYE
2002: 	vector3<short> eye;
2003: 	// TARGET
2004: 	vector3<short> target;
2005: 	// UP
2006: 	vector3<short> up;
2007: 	// FILLER?
2008: 	int16_t padding;
2009: 	// POSITION
2010: 	vector3<int> position;
2011: 	// PAN
2012: 	int16_t pan_x;
2013: 	int16_t pan_y;
2014: 	// ZOOM
2015: 	int16_t zoom;
2016: 	// FILLER?
2017: 	int16_t padding2;
2018: };
2019: 
2020: struct ff7_shake_bg_data
2021: {
2022: 	uint8_t do_shake;
2023: 	uint8_t shake_phase;
2024: 	char amp_index;
2025: 	char shake_curr_value;
2026: 	short shake_amplitude;
2027: 	short shake_initial;
2028: 	short shake_final;
2029: 	short shake_n_steps;
2030: 	short shake_idx;
2031: };
2032: 
2033: struct ff7_modules_global_object
2034: {
2035:   uint8_t field_0;
2036:   uint8_t game_mode;
2037:   uint16_t battle_id;
2038:   uint16_t field_model_pos_x;
2039:   uint16_t field_model_pos_y;
2040:   uint16_t field_8;
2041:   short field_A;
2042:   short field_C;
2043:   uint16_t field_E;
2044:   int16_t field_10;
2045:   uint8_t field_12;
2046:   uint8_t field_13;
2047:   uint8_t field_14;
2048:   uint8_t field_15;
2049:   short field_16;
2050:   uint16_t field_18;
2051:   uint16_t field_1A;
2052:   uint8_t field_1C;
2053:   byte world_move_mode;
2054:   char world_move_follow_model_id;
2055:   byte world_move_status;
2056:   uint16_t field_20;
2057:   uint16_t field_model_triangle_id;
2058:   uint16_t field_model_anim_id;
2059:   uint16_t previous_game_mode;
2060:   uint16_t num_models;
2061:   uint16_t field_model_id;
2062:   uint16_t field_2C;
2063:   uint16_t field_2E;
2064:   uint16_t field_30;
2065:   uint8_t field_32;
2066:   uint8_t field_33;
2067:   uint8_t field_34;
2068:   uint8_t field_35;
2069:   uint8_t field_36;
2070:   uint8_t SCRLO_flag;
2071:   uint8_t MPDSP_flag;
2072:   uint8_t MVCAM_flag;
2073:   uint8_t BGMOVIE_flag;
2074:   uint8_t BTLON_flag;
2075:   uint8_t field_3C;
2076:   uint8_t field_3D;
2077:   uint16_t field_3E;
2078:   uint16_t field_40;
2079:   uint16_t field_42;
2080:   uint32_t midi_id;
2081:   uint32_t field_48;
2082:   uint16_t fade_type;
2083:   uint16_t fade_adjustment;
2084:   uint16_t fade_speed;
2085:   short fade_r;
2086:   short fade_g;
2087:   short fade_b;
2088:   uint16_t field_58;
2089:   uint16_t field_5A;
2090:   uint16_t field_5C;
2091:   uint16_t nfade_r;
2092:   uint16_t nfade_g;
2093:   uint16_t nfade_b;
2094:   uint16_t field_id;
2095:   uint16_t field_66;
2096:   uint32_t current_key_input_status;
2097:   uint32_t previous_key_input_status;
2098:   uint16_t field_70;
2099:   uint16_t field_72;
2100:   uint16_t field_74;
2101:   uint16_t field_76;
2102:   uint32_t field_78;
2103:   uint16_t field_7C;
2104:   uint32_t field_80;
2105:   uint16_t field_84;
2106:   uint16_t field_86;
2107:   uint16_t MOVIE_frame;
2108:   ff7_shake_bg_data shake_bg_x;
2109:   ff7_shake_bg_data shake_bg_y;
2110:   uint16_t bg2_scroll_speed_x;
2111:   uint16_t bg2_scroll_speed_y;
2112:   uint16_t bg3_scroll_speed_x;
2113:   uint16_t bg3_scroll_speed_y;
2114:   uint16_t field_AE;
2115:   uint16_t field_B0;
2116:   uint8_t field_B2[64];
2117:   uint8_t background_sprite_layer[64];
2118:   uint16_t field_132;
2119:   uint32_t field_134;
2120: };
2121: 
2122: struct ff7_field_script_header {
2123: 	WORD unknown1;			// Always 0x0502
2124: 	char nEntities;			// Number of entities
2125: 	char nModels;			// Number of models
2126: 	WORD wStringOffset;		// Offset to strings
2127: 	WORD nAkaoOffsets;		// Specifies the number of Akao/tuto blocks/offsets
2128: 	WORD scale;             // Scale of field. For move and talk calculation (9bit fixed point).
2129: 	WORD blank[3];
2130: 	char szCreator[8];      // Field creator (never shown)
2131: 	char szName[8];			// Field name (never shown)
2132: };
2133: 
2134: struct field_event_data
2135: {
2136: 	WORD field_0;
2137: 	WORD padding_2;
2138: 	DWORD field_4;
2139: 	byte field_8;
2140: 	byte padding_9;
2141: 	WORD blink_wait_frames;
2142: 	vector3<int> model_pos;
2143: 	vector3<int> model_initial_pos;
2144: 	byte field_24[8];
2145: 	int field_2C;
2146: 	short movement_ladder_jump_steps;
2147: 	short movement_step_idx;
2148: 	byte padding_34;
2149: 	byte field_35;
2150: 	byte rotation_value;
2151: 	byte field_37;
2152: 	byte rotation_curr_value;
2153: 	byte rotation_n_steps;
2154: 	byte rotation_step_idx;
2155: 	byte rotation_steps_type;
2156: 	short rotation_initial;
2157: 	short rotation_final;
2158: 	short offset_position_x;
2159: 	short field_42;
2160: 	short offset_initial_x;
2161: 	short offset_final_x;
2162: 	short offset_position_y;
2163: 	short field_4A;
2164: 	short offset_initial_y;
2165: 	short offset_final_y;
2166: 	short offset_position_z;
2167: 	short field_52;
2168: 	short offset_initial_z;
2169: 	short offset_final_z;
2170: 	short offset_n_steps;
2171: 	short offset_step_idx;
2172: 	char offset_movement_phase;
2173: 	byte entity_id;
2174: 	byte field_5E;
2175: 	byte field_5F;
2176: 	byte field_60;
2177: 	byte field_61;
2178: 	byte field_62;
2179: 	char movement_type;
2180: 	char animation_id;
2181: 	byte padding_65;
2182: 	short animation_speed;
2183: 	short currentFrame;
2184: 	short lastFrame;
2185: 	short character_id;
2186: 	short field_direction_or_collision;
2187: 	short movement_phase;
2188: 	short collision_radius;
2189: 	short talk_radius;
2190: 	WORD movement_speed;
2191: 	short field_triangle_id;
2192: 	short field_7A;
2193: 	vector3<int> model_final_pos;
2194: };
2195: 
2196: struct field_animation_data
2197: {
2198: 	int field_0;
2199: 	int actor_x;
2200: 	int actor_y;
2201: 	int actor_z;
2202: 	byte field_10[16];
2203: 	byte eye_texture_idx;
2204: 	byte field_24[336];
2205: 	WORD field_174;
2206: 	WORD field_176;
2207: 	ff7_hrc_polygon_data *anim_frame_object;
2208: 	uint32_t *field_17C;
2209: 	p_hundred* custom_left_eye_tex;
2210:   p_hundred* static_left_eye_tex;
2211:   p_hundred* custom_right_eye_tex;
2212:   p_hundred* static_right_eye_tex;
2213: };
2214: 
2215: struct field_gateway
2216: {
2217: 	vector3<short> v1_exit_line;
2218: 	vector3<short> v2_exit_line;
2219: 	vector3<short> destination_vertex;
2220: 	SHORT field_id;
2221: 	byte unknown[4];
2222: };
2223: 
2224: struct field_trigger
2225: {
2226: 	vector3<short> v_corner1;
2227: 	vector3<short> v_corner2;
2228: 	byte bg_group_id;
2229: 	byte bg_frame_id;
2230: 	byte behavior;
2231: 	byte sound_id;
2232: };
2233: 
2234: struct field_arrow
2235: {
2236: 	int pos_x;
2237: 	int pos_y;
2238: 	int pos_z;
2239: 	int arrow_type;
2240: };
2241: 
2242: struct field_camera_range
2243: {
2244: 	short left;
2245: 	short top;
2246: 	short right;
2247: 	short bottom;
2248: };
2249: 
2250: struct field_trigger_header
2251: {
2252: 	byte field_name[9];
2253: 	byte control_direction;
2254: 	short focus_height;
2255: 	field_camera_range camera_range;
2256: 	byte field_14[4];
2257: 	short bg3_width;
2258: 	short bg3_height;
2259: 	short bg4_width;
2260: 	short bg4_height;
2261: 	short bg3_pos_x;
2262: 	short bg3_pos_y;
2263: 	short bg4_pos_x;
2264: 	short bg4_pos_y;
2265: 	short bg3_speed_x;
2266: 	short bg3_speed_y;
2267: 	short bg4_speed_x;
2268: 	short bg4_speed_y;
2269: 	short field_30[4];
2270: 	field_gateway gateways[12];
2271: 	field_trigger triggers[12];
2272: 	byte show_arrow_flag[12];
2273: 	field_arrow arrows[12];
2274: };
2275: 
2276: struct field_arrow_graphics_data
2277: {
2278: 	ff7_graphics_object *arrow_graphics_object;
2279: 	vector2<float> vertices[4];
2280: 	vector2<float> texture_uv[4];
2281: 	float z_value;
2282: 	int n_shapes;
2283: };
2284: 
2285: struct field_model_blink_data
2286: {
2287: 	byte blink_left_eye_mode;
2288:   byte blink_right_eye_mode;
2289:   char blink_mouth_mode;
2290:   char model_id;
2291: };
2292: 
2293: struct world_event_data
2294: {
2295: 	world_event_data *next_ptr;
2296: 	world_event_data *player_data_ptr;
2297: 	world_event_data *special_data_ptr;
2298: 	vector4<int> position;
2299: 	vector4<int> prev_position;
2300: 	byte field_28[20];
2301: 	short facing;
2302: 	byte field_42[2];
2303: 	short offset_y;
2304: 	short curr_script_position;
2305: 	byte field_48[2];
2306: 	WORD walkmap_type;
2307: 	short direction;
2308: 	byte field_4E[2];
2309: 	byte model_id;
2310: 	byte animation_is_loop_mask;
2311: 	byte model_id_special;
2312: 	byte animation_frame_idx;
2313: 	byte field_54;
2314: 	byte movement_speed;
2315: 	byte wait_frames;
2316: 	byte is_function_running_maybe;
2317: 	byte animation_speed;
2318: 	byte field_59[3];
2319: 	char vertical_speed;
2320: 	byte animation_id;
2321: 	byte field_5E;
2322: 	char vertical_speed_2;
2323: 	byte field_60[104];
2324: };
2325: 
2326: // Snowboard
2327: 
2328: struct tmd_3_fs_fp
2329: {
2330:   uint8_t r;
2331:   uint8_t g;
2332:   uint8_t b;
2333:   uint8_t mode2;
2334:   uint16_t normal0;
2335:   uint16_t vertex0;
2336:   uint16_t vertex1;
2337:   uint16_t vertex2;
2338: };
2339: 
2340: struct tmd_3_fs_gp
2341: {
2342:   uint8_t r0;
2343:   uint8_t g0;
2344:   uint8_t b0;
2345:   uint8_t mode2;
2346:   uint8_t r1;
2347:   uint8_t g1;
2348:   uint8_t b1;
2349:   uint8_t pad1;
2350:   uint8_t r2;
2351:   uint8_t g2;
2352:   uint8_t b2;
2353:   uint8_t pad2;
2354:   uint16_t normal0;
2355:   uint16_t vertex0;
2356:   uint16_t vertex1;
2357:   uint16_t vertex2;
2358: };
2359: 
2360: struct tmd_3_gs_fp
2361: {
2362:   uint8_t r;
2363:   uint8_t g;
2364:   uint8_t b;
2365:   uint8_t mode2;
2366:   uint16_t normal0;
2367:   uint16_t vertex0;
2368:   uint16_t normal1;
2369:   uint16_t vertex1;
2370:   uint16_t normal2;
2371:   uint16_t vertex2;
2372: };
2373: 
2374: struct tmd_3_gs_gp
2375: {
2376:   uint8_t r0;
2377:   uint8_t g0;
2378:   uint8_t b0;
2379:   uint8_t mode2;
2380:   uint8_t r1;
2381:   uint8_t g1;
2382:   uint8_t b1;
2383:   uint8_t pad1;
2384:   uint8_t r2;
2385:   uint8_t g2;
2386:   uint8_t b2;
2387:   uint8_t pad2;
2388:   uint16_t normal0;
2389:   uint16_t vertex0;
2390:   uint16_t normal1;
2391:   uint16_t vertex1;
2392:   uint16_t normal2;
2393:   uint16_t vertex2;
2394: };
2395: 
2396: struct tmd_3_ns_fp
2397: {
2398:   uint8_t r;
2399:   uint8_t g;
2400:   uint8_t b;
2401:   uint8_t mode2;
2402:   uint16_t vertex0;
2403:   uint16_t vertex1;
2404:   uint16_t vertex2;
2405:   uint16_t pad;
2406: };
2407: 
2408: struct tmd_3_ns_gp
2409: {
2410:   uint8_t r0;
2411:   uint8_t g0;
2412:   uint8_t b0;
2413:   uint8_t mode2;
2414:   uint8_t r1;
2415:   uint8_t g1;
2416:   uint8_t b1;
2417:   uint8_t pad1;
2418:   uint8_t r2;
2419:   uint8_t g2;
2420:   uint8_t b2;
2421:   uint8_t pad2;
2422:   uint16_t vertex0;
2423:   uint16_t vertex1;
2424:   uint16_t vertex2;
2425:   uint16_t pad;
2426: };
2427: 
2428: struct tmd_3_tx_fs_np
2429: {
2430:   uint8_t u0;
2431:   uint8_t v0;
2432:   uint16_t cba;
2433:   uint8_t u1;
2434:   uint8_t v1;
2435:   uint16_t tsb;
2436:   uint8_t u2;
2437:   uint8_t v2;
2438:   uint16_t pad;
2439:   uint16_t normal;
2440:   uint16_t vertex0;
2441:   uint16_t vertex1;
2442:   uint16_t vertex2;
2443: };
2444: 
2445: struct tmd_3_tx_gs_np
2446: {
2447:   uint8_t u0;
2448:   uint8_t v0;
2449:   uint16_t cba;
2450:   uint8_t u1;
2451:   uint8_t v1;
2452:   uint16_t tsb;
2453:   uint8_t u2;
2454:   uint8_t v2;
2455:   uint16_t pad;
2456:   uint16_t normal;
2457:   uint16_t vertex0;
2458:   uint16_t normal1;
2459:   uint16_t vertex1;
2460:   uint16_t normal2;
2461:   uint16_t vertex2;
2462: };
2463: 
2464: struct tmd_3_tx_ns_fp
2465: {
2466:   uint8_t u0;
2467:   uint8_t v0;
2468:   uint16_t cba;
2469:   uint8_t u1;
2470:   uint8_t v1;
2471:   uint16_t tsb;
2472:   uint8_t u2;
2473:   uint8_t v2;
2474:   uint16_t pad1;
2475:   uint8_t r;
2476:   uint8_t g;
2477:   uint8_t b;
2478:   uint8_t pad2;
2479:   uint16_t vertex0;
2480:   uint16_t vertex1;
2481:   uint16_t vertex2;
2482:   uint16_t pad;
2483: };
2484: 
2485: struct tmd_3_tx_ns_gp
2486: {
2487:   uint8_t u0;
2488:   uint8_t v0;
2489:   uint16_t cba;
2490:   uint8_t u1;
2491:   uint8_t v1;
2492:   uint16_t tsb;
2493:   uint8_t u2;
2494:   uint8_t v2;
2495:   uint16_t pad1;
2496:   uint8_t r0;
2497:   uint8_t g0;
2498:   uint8_t b0;
2499:   uint8_t pad2;
2500:   uint8_t r1;
2501:   uint8_t g1;
2502:   uint8_t b1;
2503:   uint8_t pad3;
2504:   uint8_t r2;
2505:   uint8_t g2;
2506:   uint8_t b2;
2507:   uint8_t pad4;
2508:   uint16_t vertex0;
2509:   uint16_t vertex1;
2510:   uint16_t vertex2;
2511:   uint16_t pad;
2512: };
2513: 
2514: struct tmd_header
2515: {
2516:   int32_t version;
2517:   int32_t flags;
2518:   int32_t nobjects;
2519: };
2520: 
2521: struct tmd_normal
2522: {
2523:   int16_t nx;
2524:   int16_t ny;
2525:   int16_t nz;
2526:   int16_t pad;
2527: };
2528: 
2529: struct tmd_primitive_header
2530: {
2531:   uint8_t olen;
2532:   uint8_t ilen;
2533:   uint8_t flag;
2534:   uint8_t mode;
2535: };
2536: 
2537: struct tmd_primitive_packet
2538: {
2539:   tmd_3_fs_fp tmd3fsfp;
2540:   tmd_3_gs_fp tmd3gsfp;
2541:   tmd_3_fs_gp tmd3fsgp;
2542:   tmd_3_gs_gp tmd3gsgp;
2543:   tmd_3_tx_fs_np tmd3txfsnp;
2544:   tmd_3_tx_gs_np tmd3txgsnp;
2545:   tmd_3_ns_fp tmd3nsfp;
2546:   tmd_3_ns_gp tmd3nsgp;
2547:   tmd_3_tx_ns_fp tmd3txnsfp;
2548:   tmd_3_tx_ns_gp tmd3txnsgp;
2549: };
2550: 
2551: struct tmd_vertex
2552: {
2553:   int16_t vx;
2554:   int16_t vy;
2555:   int16_t vz;
2556:   int16_t pad;
2557: };
2558: 
2559: struct tmd_vertex_float
2560: {
2561: 	float vx;
2562: 	float vy;
2563: 	float vz;
2564: 	float pad;
2565: };
2566: 
2567: struct tmd_object
2568: {
2569:   int32_t offsetverts;
2570:   int32_t nverts;
2571:   int32_t offsetnormals;
2572:   int32_t nnormals;
2573:   int32_t offsetprimitives;
2574:   int32_t nprimitives;
2575:   int32_t scale;
2576:   tmd_primitive_header *tmdprimitivelist;
2577:   tmd_primitive_packet *tmdprimitivelistpacket;
2578:   tmd_vertex *tmdvertexlist;
2579:   tmd_normal *tmdnormallist;
2580: };
2581: 
2582: struct tmdmodel
2583: {
2584:   tmd_header tmdheader;
2585:   tmd_object *tmdobjectlist;
2586: };
2587: 
2588: struct snowboard_this
2589: {
2590:   DWORD num_objects;
2591:   tmdmodel *model_data;
2592:   DWORD field_8;
2593:   DWORD field_C;
2594:   DWORD field_10;
2595:   float h_scale;
2596:   float v_scale;
2597: };
2598: 
2599: struct snowboard_object
2600: {
2601:   snowboard_this *_this;
2602:   int actor;
2603:   int actor_num_tmd_blocks;
2604:   char *field_C;
2605:   char *field_10;
2606:   char *field_14;
2607:   char *field_18;
2608:   char *field_1C;
2609:   char *field_20;
2610:   int field_24;
2611:   int field_28;
2612:   int field_2C;
2613:   int field_30;
2614:   int field_34;
2615:   int field_38;
2616:   int field_3C;
2617:   int field_40;
2618:   int field_44;
2619:   int field_48;
2620:   int field_4C;
2621:   int field_50;
2622:   int field_54;
2623:   int field_58;
2624:   int field_5C;
2625:   int field_60;
2626:   int field_64;
2627:   int field_68;
2628: };
2629: 
2630: struct world_texture_data
2631: {
2632: 	int field_0[2];
2633: 	short top_left_x;
2634: 	short top_left_y;
2635: 	uint8_t start_u_multiplier;
2636: 	uint8_t start_v_multiplier;
2637: 	uint8_t field_E[2];
2638: 	short top_right_x;
2639: 	short top_right_y;
2640: 	uint8_t end_u_multiplier;
2641: 	uint8_t field_15[3];
2642: 	short bottom_left_x;
2643: 	short bottom_left_y;
2644: 	uint8_t field_1C;
2645: 	uint8_t end_v_multiplier;
2646: 	uint8_t field_1E[2];
2647: 	short bottom_right_x;
2648: 	short bottom_right_y;
2649: 	uint8_t field_24[4];
2650: 	struct ff7_graphics_object* graphics_object;
2651: 	bgra_color_ui8 color;
2652: };
2653: 
2654: struct world_effect_2d_list_node
2655: {
2656:   world_effect_2d_list_node *next;
2657:   int x;
2658:   int y;
2659:   int z;
2660:   byte field_10[10];
2661:   __int16 rotation_y;
2662:   byte unknown_idx;
2663:   byte field_1C;
2664:   byte apply_rotation_y;
2665:   byte field_1E[5];
2666:   world_texture_data texture_data;
2667: };
2668: 
2669: struct world_snake_graphics_data
2670: {
2671: 	int field_0[2];
2672:     vector2<short> top_left_vertex;
2673:     uint8_t top_left_u;
2674:     uint8_t top_left_v;
2675:     short n_shapes;
2676:     vector2<short> top_right_vertex;
2677: 	uint8_t top_right_u;
2678: 	uint8_t top_right_v;
2679: 	uint8_t field_16[2];
2680: 	vector2<short> bottom_left_vertex;
2681: 	uint8_t bottom_left_u;
2682: 	uint8_t bottom_left_v;
2683: 	short delta_x;
2684: 	vector2<short> bottom_right_vertex;
2685: 	uint8_t bottom_right_u;
2686: 	uint8_t bottom_right_v;
2687: 	short delta_y;
2688: 	struct ff7_graphics_object* graphics_object;
2689: 	bgra_color_ui8 color;
2690: };
2691: 
2692: struct ff7_model_eye_texture_data
2693: {
2694:   int has_eyes;
2695:   char *custom_left_eye_filename;
2696:   char *static_left_eye_filename;
2697:   char *custom_right_eye_filename;
2698:   char *static_right_eye_filename;
2699: };
2700: 
2701: 
2702: // --------------- end of FF7 imports ---------------
2703: 
2704: struct ff7_model_custom_data
2705: {
2706: 	int has_mouth;
2707: 	int current_mouth_idx;
2708: 	char* mouth_tex_filename;
2709: 	p_hundred* mouth_tex;
2710: 	char *left_eye_tex_filename;
2711: 	char *right_eye_tex_filename;
2712: 	p_hundred* left_eye_tex;
2713: 	p_hundred* right_eye_tex;
2714: };
2715: 
2716: struct ff7_channel_6_state
2717: {
2718: 	float volume;
2719: 	float panning;
2720: };
2721: 
2722: // memory addresses and function pointers from FF7.exe
2723: struct ff7_externals
2724: {
2725: 	uint32_t chocobo_fix;
2726: 	uint32_t midi_fix;
2727: 	void *snowboard_fix;
2728: 	uint32_t cdcheck;
2729: 	uint32_t cdcheck_enter_sub;
2730: 	uint32_t get_inserted_cd_sub;
2731: 	DWORD* insertedCD;
2732: 	uint8_t* requiredCD;
2733: 	struct movie_obj *movie_object;
2734: 	void (*movie_sub_415231)(char *);
2735: 	void (*sub_665D9A)(struct matrix *, struct nvertex *, struct indexed_primitive *, struct p_hundred *, struct struc_186 *, struct ff7_game_obj *);
2736: 	void (*sub_671742)(uint32_t, struct p_hundred *, struct struc_186 *);
2737: 	void (*sub_6B27A9)(struct matrix *, struct indexed_primitive *, struct ff7_polygon_set *, struct p_hundred *, struct p_group *, void *, struct ff7_game_obj *);
2738: 	void (*sub_68D2B8)(uint32_t, struct ff7_polygon_set *, void *);
2739: 	void (*sub_665793)(struct matrix *, uint32_t, struct indexed_primitive *, struct ff7_polygon_set *, struct p_hundred *, struct p_group *, struct ff7_game_obj *);
2740: 	void (*matrix3x4)(struct matrix *);
2741: 	uint32_t matrix4x3_multiply;
2742: 	void *(*sub_6A2865)(void *);
2743: 	uint32_t sub_6B26C0;
2744: 	uint32_t sub_6B2720;
2745: 	uint32_t sub_673F5C;
2746: 	struct savemap *savemap;
2747: 	struct menu_objects *menu_objects;
2748: 	uint32_t magic_thread_start;
2749: 	void (*destroy_magic_effects)();
2750: 	uint32_t lgp_open_file;
2751: 	uint32_t lgp_read_file;
2752: 	uint32_t lgp_read;
2753: 	uint32_t lgp_get_filesize;
2754: 	uint32_t lgp_seek_file;
2755: 	int (*lzss_decode)(char*, char*);
2756: 	char** field_file_buffer;
2757: 	DWORD* field_file_section_ptrs;
2758: 	uint32_t* known_field_buffer_size;
2759: 	uint32_t* field_resuming_from_battle_CFF268;
2760: 	void (*draw_character)(uint32_t, uint32_t, char *, uint32_t, float);
2761: 	uint32_t destroy_field_bk;
2762: 	uint32_t destroy_field_tiles;
2763: 	struct field_layer **field_layers;
2764: 	WORD *num_field_entities;
2765: 	struct field_object **field_objects;
2766: 	uint32_t open_field_file;
2767: 	WORD *field_id;
2768: 	char *field_file_name;
2769: 	uint32_t read_field_file;
2770: 	uint32_t battle_enter;
2771: 	uint32_t battle_loop;
2772: 	battle_actor_data *battle_actor_data;
2773: 	DWORD *battle_mode;
2774: 	WORD *battle_location_id;
2775: 	WORD *battle_formation_id;
2776: 	uint32_t battle_sub_429AC0;
2777: 	uint32_t battle_sub_42D808;
2778: 	uint32_t battle_sub_42D992;
2779: 	uint32_t battle_sub_42DAE5;
2780: 	uint32_t battle_sub_427C22;
2781: 	uint32_t battle_menu_update_6CE8B3;
2782: 	uint32_t battle_sub_6DB0EE;
2783: 	char* is_battle_paused;
2784: 	std::span<uint32_t> battle_menu_state_fn_table;
2785: 	std::span<uint32_t> magic_effects_fn_table;
2786: 	uint32_t comet2_sub_5A42E5;
2787: 	uint32_t comet2_unload_sub_5A4359;
2788: 	uint32_t battle_b3ddata_sub_428B12;
2789: 	uint32_t graphics_render_sub_68A638;
2790: 	uint32_t create_dx_sfx_something;
2791: 	uint32_t load_p_file;
2792: 	struct polygon_data *(*create_polygon_data)(uint32_t, uint32_t);
2793: 	void (*create_polygon_lists)(struct polygon_data *);
2794: 	void (*free_polygon_data)(struct polygon_data *);
2795: 	uint32_t battle_sub_42A0E7;
2796: 	uint32_t load_battle_stage;
2797: 	uint32_t load_battle_stage_pc;
2798: 	uint32_t read_battle_hrc;
2799: 	void (*battle_regular_chdir)(struct battle_chdir_struc *);
2800: 	void (*battle_context_chdir)(struct file_context *, struct battle_chdir_struc *);
2801: 	void (*swap_extension)(char *, char *, char *);
2802: 	void (*destroy_battle_hrc)(uint32_t, struct battle_hrc_header *);
2803: 	void (*battle_regular_olddir)(struct battle_chdir_struc *);
2804: 	void (*battle_context_olddir)(struct file_context *, struct battle_chdir_struc *);
2805: 	uint32_t load_animation;
2806: 	uint32_t field_load_animation;
2807: 	uint32_t field_load_models;
2808: 	uint32_t field_models_eye_to_model;
2809: 	ff7_model_eye_texture_data* field_models_eye_blink_buffer;
2810: 	DWORD* field_models_data;
2811: 	int (*field_load_model_eye_tex)(ff7_model_eye_texture_data *eye_data, field_animation_data *anim_data);
2812: 	p_hundred* (*field_load_model_tex)(int idx1, int shademode, char *filename, struc_3 *tex_info, game_obj *game_object);
2813: 	void (*field_unload_model_tex)(void* eye_tex);
2814: 	void (*create_struc_3_info_sub_67455E)(struc_3 *tex_info);
2815: 	uint32_t field_sub_60DCED;
2816: 	int (*field_sub_6A2736)(ff7_polygon_set *polygon_set);
2817: 	p_hundred** (*field_sub_6A2782)(int idx, p_hundred *hundreddata, ff7_polygon_set *polygon_set);
2818: 	uint32_t* field_unk_909288;
2819: 	void (*destroy_animation)(struct anim_header *);
2820: 	uint32_t context_chdir;
2821: 	uint32_t lgp_chdir;
2822: 	struct lookup_table_entry **lgp_lookup_tables;
2823: 	struct lgp_toc_entry **lgp_tocs;
2824: 	struct lgp_folders *lgp_folders;
2825: 	uint32_t __read;
2826: 	uint32_t load_lgp;
2827: 	uint32_t open_lgp_file;
2828: 	FILE **lgp_fds;
2829: 	uint32_t battle_sub_437DB0;
2830: 	uint32_t battle_scene_bin_sub_5D1050;
2831: 	int (*engine_load_bin_file_sub_419210)(char *filename, int offset, int size, char **out_buffer, void (*callback)(void));
2832: 	uint32_t sub_5CB2CC;
2833: 	uint32_t *midi_volume_control;
2834: 	uint32_t *midi_initialized;
2835: 	uint32_t menu_sub_6CDA83;
2836: 	uint32_t menu_sub_6CBD43;
2837: 	uint32_t menu_sub_701EE4;
2838: 	uint32_t phs_menu_sub;
2839: 	uint32_t menu_draw_party_member_stats;
2840: 	uint32_t *party_member_to_char_map;
2841: 	uint32_t menu_sub_6CB56A;
2842: 	uint32_t menu_sub_6FEDB0;
2843: 	void *(*menu_sub_6F5C0C)(uint32_t,uint32_t,uint8_t,uint8_t,uint32_t);
2844: 	void *(*menu_sub_6FAC38)(uint32_t,uint32_t,uint8_t,uint8_t,uint32_t);
2845: 	BOOL (*write_save_file)(char);
2846: 	uint32_t *menu_subs_call_table;
2847: 	int (*menu_tutorial_sub_6C49FD)();
2848: 	BYTE* menu_tutorial_window_state;
2849: 	DWORD* menu_tutorial_window_text_ptr;
2850: 	uint32_t status_menu_sub;
2851: 	uint32_t draw_status_limit_level_stats;
2852: 	uint32_t timer_menu_sub;
2853: 	DWORD *millisecond_counter;
2854: 	char *(*get_kernel_text)(uint32_t, uint32_t, uint32_t);
2855: 	uint32_t sub_5CF282;
2856: 	uint32_t get_equipment_stats;
2857: 	struct weapon_data *weapon_data_array;
2858: 	struct armor_data *armor_data_array;
2859: 	uint32_t field_sub_6388EE;
2860: 	uint32_t field_draw_everything;
2861: 	uint32_t field_pick_tiles_make_vertices;
2862: 	uint32_t field_layer1_pick_tiles;
2863: 	uint32_t *field_layer1_tiles_num;
2864: 	uint32_t **field_layer1_palette_sort;
2865: 	field_tile **field_layer1_tiles;
2866: 	uint32_t field_layer2_pick_tiles;
2867: 	uint32_t *field_layer2_tiles_num;
2868: 	uint32_t **field_layer2_palette_sort;
2869: 	field_tile **field_layer2_tiles;
2870: 	uint32_t field_layer3_pick_tiles;
2871: 	uint32_t *field_layer3_tiles_num;
2872: 	uint32_t **field_layer3_palette_sort;
2873: 	field_tile **field_layer3_tiles;
2874: 	int *do_draw_layer3_CFFE3C;
2875: 	int *field_layer3_flag_CFFE40;
2876: 	uint32_t field_layer4_pick_tiles;
2877: 	uint32_t *field_layer4_tiles_num;
2878: 	uint32_t **field_layer4_palette_sort;
2879: 	field_tile **field_layer4_tiles;
2880: 	int *do_draw_layer4_CFFEA4;
2881: 	int *field_layer4_flag_CFFEA8;
2882: 	int *field_layer_CFF1D8;
2883: 	uint16_t *field_palette_D00088;
2884: 	uint32_t *field_special_y_offset;
2885: 	uint32_t *field_bg_multiplier;
2886: 	void (*add_page_tile)(float, float, float, float, float, uint32_t, uint32_t);
2887: 	double (*field_layer_sub_623C0F)(rotation_matrix*, int, int, int);
2888: 	void (*field_draw_gray_quads_644E90)();
2889: 	void (*engine_draw_graphics_object)(ff7_graphics_object*, ff7_game_obj*);
2890: 	field_trigger_header** field_triggers_header;
2891: 	rotation_matrix* field_camera_rotation_matrix_CFF3D8;
2892: 	uint32_t field_load_textures;
2893: 	void (*field_convert_type2_layers)();
2894: 	void (*make_struc3)(uint32_t, struct struc_3 *);
2895: 	void (*make_field_tex_header_pal)(struct ff7_tex_header *);
2896: 	void (*make_field_tex_header)(struct ff7_tex_header *);
2897: 	struct ff7_graphics_object *(*_load_texture)(uint32_t, uint32_t, struct struc_3 *, char *, void *);
2898: 	uint32_t read_field_background_data;
2899: 	WORD *layer2_end_page;
2900: 	uint32_t create_d3d2_indexed_primitive;
2901: 	uint32_t destroy_d3d2_indexed_primitive;
2902: 	uint32_t enter_main;
2903: 	uint32_t kernel_init;
2904: 	void (*kernel_load_kernel2)(char* filename);
2905: 	uint32_t kernel2_reset_counters;
2906: 	uint32_t sub_4012DA;
2907: 	uint32_t kernel2_add_section;
2908: 	uint32_t kernel2_get_text;
2909: 	char **kernel_1to9_sections;
2910: 	uint32_t draw_3d_model;
2911: 	void (*stack_push)(struct stack *);
2912: 	void *(*stack_top)(struct stack *);
2913: 	void (*stack_pop)(struct stack *);
2914: 	void (*_root_animation)(struct matrix *, struct anim_frame *, struct anim_header *, struct hrc_data *);
2915: 	void (*_frame_animation)(uint32_t, struct matrix *, vector3<float> *, struct anim_frame *, struct anim_header *, struct hrc_bone *, struct hrc_data *);
2916: 	void (*root_animation)(struct matrix *, struct anim_frame *, struct anim_header *, struct hrc_data *);
2917: 	void (*frame_animation)(uint32_t, struct matrix *, vector3<float> *, struct anim_frame *, struct anim_header *, struct hrc_bone *, struct hrc_data *);
2918: 	uint32_t *model_mode;
2919: 	uint32_t name_menu_sub_6CBD32;
2920: 	uint32_t name_menu_sub_719C08;
2921: 	uint32_t menu_sub_71894B;
2922: 	uint32_t menu_sub_718DBE;
2923: 	uint32_t menu_sub_719B81;
2924: 	uint32_t set_default_input_settings_save;
2925: 	uint32_t keyboard_name_input;
2926: 	uint32_t restore_input_settings;
2927: 	uint32_t dinput_getdata2;
2928: 	uint32_t init_stuff;
2929: 	uint32_t init_game;
2930: 	uint32_t sub_41A1B0;
2931: 	uint32_t init_directinput;
2932: 	uint32_t dinput_createdevice_mouse;
2933: 	void (*sub_69C69F)(struct matrix *, struct ff7_light *);
2934: 	uint32_t coaster_sub_5E9051;
2935: 	uint32_t coaster_sub_5EE150;
2936: 	uint32_t cleanup_game;
2937: 	uint32_t wm_activateapp;
2938: 	uint32_t get_gamepad;
2939: 	uint32_t update_gamepad_status;
2940: 	struct ff7_gamepad_status* gamepad_status;
2941: 	uint32_t music_is_locked;
2942: 	uint32_t field_initialize_variables;
2943: 	uint32_t music_lock_clear_fix;
2944: 	uint32_t sub_60DF96;
2945: 	uint32_t sub_60EEB2;
2946: 	uint32_t open_flevel_siz;
2947: 	uint32_t field_map_infos;
2948: 	uint32_t sound_operation;
2949: 	struct ff7_field_sfx_state* sound_states;
2950: 	uint32_t config_menu_sub;
2951:   uint32_t config_initialize;
2952: 	uint32_t call_menu_sound_slider_loop_sfx_up;
2953: 	uint32_t call_menu_sound_slider_loop_sfx_down;
2954: 	uint32_t menu_start;
2955: 	uint32_t battle_clear_sound_flags;
2956: 	uint32_t swirl_sound_effect;
2957: 	uint32_t field_init_player_character_variables;
2958: 	uint32_t field_init_event_wrapper_63BCA7;
2959: 	uint32_t field_init_event_60BACF;
2960: 	uint32_t field_init_field_objects_60BCFA;
2961: 	uint32_t execute_opcode;
2962: 	uint32_t opcode_goldu;
2963: 	uint32_t opcode_dlitm;
2964: 	uint32_t opcode_smtra;
2965: 	uint32_t opcode_akao;
2966: 	uint32_t opcode_akao2;
2967: 	uint32_t opcode_bmusc;
2968: 	uint32_t opcode_fmusc;
2969: 	uint32_t opcode_cmusc;
2970: 	uint32_t opcode_canm1_canm2;
2971: 	uint32_t opcode_fade;
2972: 	uint32_t opcode_shake;
2973: 	uint32_t field_opcode_08_sub_61D0D4;
2974: 	void (*field_opcode_08_09_set_rotation_61DB2C)(short, byte, byte);
2975: 	uint32_t field_opcode_AA_2A_sub_616476;
2976: 	uint32_t field_opcode_turn_character_sub_616CB5;
2977: 	int (*field_get_rotation_final_636515)(vector3<int>*, vector3<int>*, int*);
2978: 	uint32_t field_music_helper;
2979: 	uint32_t field_music_helper_sound_op_call;
2980: 	uint32_t (*field_music_id_to_midi_id)(int16_t);
2981: 	uint32_t field_music_id_to_midi_id_call1;
2982: 	uint32_t field_music_id_to_midi_id_call2;
2983: 	uint32_t field_music_id_to_midi_id_call3;
2984: 	uint32_t opcode_gameover;
2985: 	uint32_t opcode_message;
2986: 	uint32_t opcode_ask;
2987: 	uint32_t opcode_wmode;
2988: 	uint32_t opcode_tutor;
2989: 	uint32_t opcode_pc;
2990: 	uint32_t opcode_kawai;
2991: 	uint32_t *sfx_initialized;
2992: 	uint32_t sfx_play_summon;
2993: 	uint32_t sfx_load_and_play_with_speed;
2994: 	ff7_audio_fmt* sfx_fmt_header;
2995: 	DWORD *sfx_play_effects_id_channel_6;
2996: 	uint32_t sfx_stop_channel_6;
2997: 	UINT *sfx_stop_channel_timer_handle;
2998: 	uint32_t battle_summon_leviathan_loop;
2999: 	uint32_t battle_limit_omnislash_loop;
3000: 	void (*reset_game_obj_sub_5F4971)(struct game_obj*);
3001: 	uint32_t engine_exit_game_mode_sub_666C78;
3002: 	void* (*sub_666C13)(struct game_obj*);
3003: 	void* (*sub_670F9B)(void*);
3004: 	WORD* word_CC0828;
3005: 	BYTE* byte_CC0D89;
3006: 	WORD* word_DB958A;
3007: 	BYTE* byte_CC164C;
3008: 	WORD* word_CC0DC6;
3009: 	uint32_t enter_gameover;
3010: 	uint32_t exit_gameover;
3011: 	void* (*start_gameover)();
3012: 	void* (*gameover_sub_6C12B1)();
3013: 	uint32_t on_gameover_enter;
3014: 	uint32_t on_gameover_exit;
3015: 	BYTE (*sub_60B260)();
3016: 	BYTE(*sub_767C55)();
3017: 	uint32_t field_battle_toggle;
3018: 	uint32_t worldmap_battle_toggle;
3019: 	uint32_t enter_field;
3020: 	uint32_t field_init_viewport_values;
3021: 	uint32_t field_loop_sub_63C17F;
3022: 	uint32_t field_update_models_positions;
3023: 	int (*field_update_single_model_position)(short);
3024: 	void (*field_update_model_animation_frame)(short);
3025: 	int (*field_check_collision_with_target)(field_event_data*, short);
3026: 	int (*field_get_linear_interpolated_value)(int, int, int, int);
3027: 	int (*field_get_smooth_interpolated_value)(int, int, int, int);
3028: 	void (*field_evaluate_encounter_rate_60B2C6)();
3029: 	uint32_t field_animate_3d_models_6392BB;
3030: 	uint32_t field_apply_kawai_op_64A070;
3031: 	uint32_t sub_64EC60;
3032: 	field_model_blink_data* field_model_blink_data_D000C8;
3033: 	void (*field_blink_3d_model_649B50)(field_animation_data*, field_model_blink_data*);
3034: 	short *field_player_model_id;
3035: 	WORD *field_n_models;
3036: 	uint32_t field_update_camera_data;
3037: 	ff7_camdata** field_camera_data;
3038: 	uint32_t sub_40B27B;
3039: 	WORD* word_CC0DD4;
3040: 	WORD* word_CC1638;
3041: 	uint32_t field_init_scripted_bg_movement;
3042: 	uint32_t field_update_scripted_bg_movement;
3043: 	void (*field_update_background_positions)();
3044: 	uint32_t compute_and_submit_draw_gateways_arrows_64DA3B;
3045: 	void (*field_submit_draw_arrow_63A171)(field_arrow_graphics_data*);
3046: 	uint32_t field_draw_pointer_hand_60D4F3;
3047: 	uint32_t field_submit_draw_pointer_hand_60D572;
3048: 	uint32_t field_sub_64314F;
3049: 	void (*set_world_pos_based_on_player_pos_643C86)(vector2<short>*);
3050: 	void(*field_clip_with_camera_range_6438F6)(vector2<short>*);
3051: 	uint32_t field_layer3_clip_with_camera_range_643628;
3052: 	void (*engine_set_game_engine_delta_values_661976)(int, int);
3053: 	uint32_t engine_apply_matrix_product_66307D;
3054: 	void (*engine_convert_psx_matrix_to_float_matrix_row_version_661465)(rotation_matrix*, float*);
3055: 	void (*engine_apply_rotation_to_transform_matrix_6628DE)(vector3<short>*, rotation_matrix*);
3056: 	void (*engine_apply_matrix_product_to_vector_66CF7E)(float*, vector3<float>*, vector3<float>*);
3057: 	vector2<int>* field_bg_offset;
3058: 	short* field_curr_delta_world_pos_x;
3059: 	short* field_curr_delta_world_pos_y;
3060: 	short* scripted_world_initial_pos_x;
3061: 	short* scripted_world_initial_pos_y;
3062: 	short* scripted_world_final_pos_x;
3063: 	short* scripted_world_final_pos_y;
3064: 	short* scripted_world_move_n_steps;
3065: 	short* scripted_world_move_step_index;
3066: 	short* field_world_pos_x;
3067: 	short* field_world_pos_y;
3068: 	short* field_prev_world_pos_x;
3069: 	short* field_prev_world_pos_y;
3070: 	short* field_cursor_pos_x;
3071: 	short* field_cursor_pos_y;
3072: 	vector2<int>* field_viewport_xy_CFF204;
3073: 	vector2<int>* field_max_half_viewport_width_height_CFF1F4;
3074: 	vector2<int>* field_curr_half_viewport_width_height_CFF1FC;
3075: 	WORD* field_bg_flag_CC15E4;
3076: 	uint32_t field_sub_640EB7;
3077: 	uint32_t field_sub_661B68;
3078: 	void (*engine_set_game_engine_world_coord_661B23)(int, int);
3079: 	void (*engine_sub_67CCDE)(float, float, float, float, float, float, float, ff7_game_obj*);
3080: 	uint32_t field_handle_screen_fading;
3081: 	uint32_t field_opcode_message_update_loop_630D50;
3082: 	uint32_t field_text_box_window_create_631586;
3083: 	uint32_t field_text_box_window_opening_6317A9;
3084: 	uint32_t field_text_box_window_paging_631945;
3085: 	uint32_t field_text_box_window_reverse_paging_632CAA;
3086: 	uint32_t field_text_box_window_closing_632EB8;
3087: 	char* field_entity_id_list; // 0xCC0960
3088: 	DWORD* current_dialog_string_pointer; //0xCBF578
3089: 	WORD* current_dialog_message_speed; // 0xCC0418
3090: 	WORD* opcode_message_loop_code;
3091: 	int (*field_opcode_ask_update_loop_6310A1)(uint8_t, uint8_t, uint8_t, uint8_t, WORD*);
3092: 	WORD* opcode_ask_question_code;
3093: 	void (*play_midi)(uint32_t);
3094: 	WORD *current_movie_frame;
3095: 	uint32_t opening_movie_play_midi_call;
3096: 	DWORD *opening_movie_music_start_frame;
3097: 	uint32_t fps_limiter_swirl;
3098: 	uint32_t fps_limiter_battle;
3099: 	uint32_t fps_limiter_coaster;
3100: 	uint32_t fps_limiter_condor;
3101: 	uint32_t fps_limiter_field;
3102: 	uint32_t fps_limiter_highway;
3103: 	uint32_t fps_limiter_snowboard;
3104: 	uint32_t fps_limiter_worldmap;
3105: 	uint32_t fps_limiter_chocobo;
3106: 	uint32_t fps_limiter_submarine;
3107: 	uint32_t fps_limiter_credits;
3108: 	uint32_t fps_limiter_menu;
3109: 	uint32_t sub_5F5042;
3110: 	uint32_t highway_loop_sub_650F36;
3111: 	uint32_t sub_779E14;
3112: 	uint32_t battle_fps_menu_multiplier;
3113: 	DWORD *submarine_minigame_status;
3114: 	time_t *submarine_last_gametime;
3115: 	DWORD *field_limit_fps;
3116: 	DWORD *swirl_limit_fps;
3117: 	int16_t (*get_bank_value)(int16_t, int16_t);
3118: 	int8_t (*set_bank_value)(int16_t, int16_t, int16_t);
3119: 	int8_t (*get_char_bank_value)(int16_t, int16_t);
3120: 	uint32_t sub_611BAE;
3121: 	byte* current_entity_id;
3122: 	byte** field_script_ptr; //0xCBF5E8
3123: 	WORD* field_curr_script_position; //0xCC0CF8
3124: 	byte* field_model_id_array; //0xCBFB70
3125: 	field_event_data** field_event_data_ptr; // 0xCC0B60
3126: 	field_animation_data** field_animation_data_ptr; // 0xCFF738
3127: 	WORD* wait_frames_ptr; //0xCC0900
3128: 	char* animation_type_array; //0xCC0980
3129: 	ff7_modules_global_object *modules_global_object; // 0xCC0D88
3130: 	ff7_modules_global_object **field_global_object_ptr; // 0xCBF9D8
3131: 	void (*sub_767039)(DWORD*,DWORD*,DWORD*);
3132: 	uint32_t play_battle_music_call;
3133: 	uint32_t (*play_battle_end_music)();
3134: 	uint32_t play_battle_music_win_call;
3135: 	uint32_t wm_change_music;
3136: 	uint32_t wm_play_music_call;
3137: 	uint32_t battle_fight_end;
3138: 	uint32_t battle_fanfare_music;
3139: 	int (*sub_630C48)(int16_t, int16_t, int16_t, int16_t, int16_t);
3140: 	uint32_t sub_408074;
3141: 	uint32_t sub_60BB58;
3142: 	byte** field_level_data_pointer;
3143: 	uint32_t sub_408116;
3144: 	char *word_CC16E8;
3145: 	uint16_t* menu_battle_end_mode;
3146: 	uint32_t* pointer_functions_7C2980;
3147: 	uint32_t battle_enemy_killed_sub_433BD2;
3148: 	uint32_t battle_sub_5C7F94;
3149: 	uint32_t menu_battle_end_sub_6C9543;
3150: 	uint32_t menu_sub_71FF95, menu_shop_loop, get_materia_gil, opcode_increase_gil_call;
3151: 	uint32_t opcode_add_materia_inventory_call, menu_sub_6CBCF3, menu_sub_705D16, menu_sub_6CC17F;
3152: 	uint32_t display_battle_action_text_42782A;
3153: 	uint32_t display_battle_action_text_sub_6D71FA;
3154: 	uint32_t menu_decrease_item_quantity;
3155: 	uint32_t opcode_setbyte, opcode_biton;
3156: 	uint32_t sub_60FA7D;
3157: 	uint32_t menu_sub_7212FB;
3158: 	uint32_t load_save_file;
3159: 	uint32_t handle_actor_ready;
3160: 	WORD* battle_menu_state;
3161: 	uint32_t set_battle_menu_state_data;
3162: 	uint32_t dispatch_chosen_battle_action;
3163: 	uint32_t set_battle_targeting_data;
3164: 	uint16_t* issued_action_id;
3165: 	byte* issued_command_id;
3166: 	byte* issued_action_target_type;
3167: 	byte* issued_action_target_index;
3168: 	uint32_t field_load_models_atoi;
3169: 	uint32_t sub_6499F7;
3170: 	DWORD* input_ok_button_status;
3171: 	DWORD* input_run_button_status;
3172: 	uint32_t sub_62120E;
3173: 	int (*field_load_map_trigger_data_sub_6211C3)();
3174: 	uint32_t field_fade_screen_sub_63B84B;
3175: 	uint32_t field_calc_fade_color_sub_63AE66;
3176: 
3177: 	// battle camera script externals
3178: 	uint32_t handle_camera_functions;
3179: 	uint32_t set_camera_focal_position_scripts;
3180: 	uint32_t set_camera_position_scripts;
3181: 	uint32_t add_fn_to_camera_fn_array;
3182: 	uint32_t execute_camera_functions;
3183: 	uint32_t battle_camera_sub_5C52F8;
3184: 	uint32_t battle_camera_sub_5C3E6F;
3185: 	uint32_t battle_camera_position_sub_5C3D0D;
3186: 	uint32_t battle_camera_position_sub_5C557D;
3187: 	uint32_t battle_camera_position_sub_5C5B9C;
3188: 	uint32_t battle_camera_focal_sub_5C5F5E;
3189: 	uint32_t battle_camera_focal_sub_5C5714;
3190: 	uint32_t battle_sub_430DD0;
3191: 	uint32_t battle_sub_429D8A;
3192: 	uint32_t update_battle_camera_sub_5C20CE;
3193: 	uint32_t set_battle_camera_sub_5C22BD;
3194: 	uint32_t battle_camera_sub_5C22A9;
3195: 	uint32_t compute_interpolation_to_formation_camera;
3196: 	uint32_t set_battle_camera_sub_5C2350;
3197: 	std::span<bcamera_fn_data> camera_fn_data;
3198: 	std::span<bcamera_position> battle_camera_position;
3199: 	std::span<bcamera_position> battle_camera_focal_point;
3200: 	std::span<uint32_t> camera_fn_array;
3201: 	byte* battle_camera_focal_scripts_8FEE30;
3202: 	byte* battle_camera_position_scripts_8FEE2C;
3203: 	DWORD* battle_camera_global_scripts_9A13BC;
3204: 	DWORD* battle_camera_position_scripts_9010D0;
3205: 	DWORD* battle_camera_focal_scripts_901270;
3206: 	byte* battle_camera_script_index;
3207: 	DWORD* battle_camera_script_offset;
3208: 	WORD* camera_fn_index;
3209: 	WORD* camera_fn_counter;
3210: 	vector3<short>* g_battle_camera_position;
3211: 	vector3<short>* g_battle_camera_focal_point;
3212: 	std::span<formation_camera> formation_camera;
3213: 	byte* curr_formation_camera_idx;
3214: 	byte* battle_enter_frames_to_wait;
3215: 	byte* g_variation_index;
3216: 	byte* is_camera_moving_BFB2DC;
3217: 
3218: 	// animation script externals
3219: 	uint32_t battle_sub_42A5EB;
3220: 	uint32_t battle_sub_42E275;
3221: 	uint32_t battle_sub_42E34A;
3222: 	uint32_t battle_sub_5B9EC2;
3223: 	uint32_t battle_sub_5BD5E9;
3224: 	uint32_t run_summon_animations_script_5C1B81;
3225: 	uint32_t run_summon_animations_script_sub_5C1D9A;
3226: 	uint32_t run_animation_script;
3227: 	uint32_t add_fn_to_effect100_fn;
3228: 	uint32_t execute_effect100_fn;
3229: 	uint32_t add_fn_to_effect60_fn;
3230: 	uint32_t execute_effect60_fn;
3231: 	uint32_t add_fn_to_effect10_fn;
3232: 	uint32_t execute_effect10_fn;
3233: 	uint32_t battle_enemy_death_5BBD24;
3234: 	uint32_t battle_enemy_death_sub_5BBE32;
3235: 	uint32_t battle_iainuki_death_5BCAAA;
3236: 	uint32_t battle_iainuki_death_sub_5BCBB8;
3237: 	uint32_t battle_boss_death_5BC48C;
3238: 	uint32_t battle_boss_death_sub_5BC6ED;
3239: 	uint32_t battle_boss_death_sub_5BC5EC;
3240: 	uint32_t battle_boss_death_call_5BD436;
3241: 	uint32_t battle_melting_death_5BC21F;
3242: 	uint32_t battle_melting_death_sub_5BC32D;
3243: 	uint32_t battle_disintegrate_2_death_5BBA82;
3244: 	uint32_t battle_disintegrate_2_death_sub_5BBBDE;
3245: 	uint32_t battle_morph_death_5BC812;
3246: 	uint32_t battle_morph_death_sub_5BC920;
3247: 	uint32_t battle_disintegrate_1_death_5BBF31;
3248: 	uint32_t battle_disintegrate_1_death_sub_5BC04D;
3249: 	uint32_t battle_sub_42C0A7;
3250: 	uint32_t run_summon_animations_5C0E4B;
3251: 	uint32_t vincent_limit_fade_effect_sub_5D4240;
3252: 	uint32_t battle_sub_5BD96D;
3253: 	uint32_t battle_sub_425D29;
3254: 	uint32_t display_battle_damage_5BB410;
3255: 	uint32_t battle_sub_5BDA0F;
3256: 	uint32_t get_n_frames_display_action_string;
3257: 	uint32_t battle_sub_434C8B;
3258: 	uint32_t battle_sub_435D81;
3259: 	uint32_t battle_sub_426DE3;
3260: 	uint32_t battle_sub_426941;
3261: 	uint32_t battle_sub_426899;
3262: 	uint32_t battle_sub_4267F1;
3263: 	uint32_t battle_sub_5C1C8F;
3264: 	uint32_t battle_move_character_sub_426A26;
3265: 	uint32_t battle_move_character_sub_42739D;
3266: 	uint32_t battle_move_character_sub_426F58;
3267: 	uint32_t battle_move_character_sub_4270DE;
3268: 	uint32_t handle_aura_effects_425520;
3269: 	uint32_t run_aura_effects_5C0230;
3270: 	uint32_t limit_break_aura_effects_5C0572;
3271: 	uint32_t enemy_skill_aura_effects_5C06BF;
3272: 	uint32_t handle_summon_aura_5C0850;
3273: 	uint32_t summon_aura_effects_5C0953;
3274: 	uint32_t battle_sub_5C18BC;
3275: 	uint32_t battle_sub_4276B6;
3276: 	uint32_t battle_sub_4255B7;
3277: 	uint32_t battle_sub_425E5F;
3278: 	uint32_t battle_sub_5BCF9D;
3279: 	uint32_t battle_sub_425AAD;
3280: 	uint32_t battle_sub_427A6C;
3281: 	uint32_t battle_sub_427AF1;
3282: 	uint32_t battle_sub_427737;
3283: 	uint32_t battle_sub_4277B1;
3284: 	uint32_t battle_sub_5BCD42;
3285: 	uint32_t battle_sub_5BD050;
3286: 	uint32_t battle_smoke_move_handler_5BE4E2;
3287: 	uint32_t battle_sub_42A72D;
3288: 	void (*battle_play_sfx_sound_430D32)(uint16_t, short, char);
3289: 	uint32_t run_tifa_limit_effects;
3290: 	uint32_t tifa_limit_1_2_sub_4E3D51;
3291: 	uint32_t tifa_limit_2_1_sub_4E48D4;
3292: 	uint32_t aerith_limit_2_1_sub_45B0CF;
3293: 	uint32_t cloud_limit_2_2_sub_467256;
3294: 	uint32_t vincent_limit_satan_slam_camera_45CF2A;
3295: 	uint32_t barret_limit_4_1_camera_4688A2;
3296: 	uint32_t barret_limit_4_1_model_movement_4698EF;
3297: 	int *barret_limit_4_1_actor_id;
3298: 	uint32_t aerith_limit_4_1_camera_473CC2;
3299: 	uint32_t run_chocomog_movement_50B1A3;
3300: 	uint32_t run_chocomog_camera_509B10;
3301: 	uint32_t run_fat_chocobo_movement_509692;
3302: 	uint32_t run_fat_chocobo_camera_507CA4;
3303: 	uint32_t run_fat_chocobo_camera_shake_5095F5;
3304: 	uint32_t run_shiva_movement_592538;
3305: 	uint32_t run_shiva_camera_58E60D;
3306: 	uint32_t run_ifrit_movement_596702;
3307: 	uint32_t run_ifrit_camera_592A36;
3308: 	uint32_t run_ramuh_camera_597206;
3309: 	uint32_t run_titan_camera_59B4B0;
3310: 	uint32_t run_odin_gunge_movement_4A584D;
3311: 	uint32_t run_odin_gunge_camera_4A0F52;
3312: 	uint32_t run_odin_steel_movement_4A6CB8;
3313: 	uint32_t run_odin_steel_sub_4A9908;
3314: 	uint32_t run_odin_steel_camera_4A5D3C;
3315: 	uint32_t run_leviathan_camera_5B0716;
3316: 	uint32_t run_bahamut_movement_49ADEC;
3317: 	uint32_t run_bahamut_camera_497A37;
3318: 	uint32_t run_kujata_camera_4F9A4D;
3319: 	uint32_t run_alexander_movement_5078D8;
3320: 	uint32_t run_alexander_camera_501637;
3321: 	uint32_t run_phoenix_main_loop_516297;
3322: 	uint32_t run_phoenix_movement_518AFF;
3323: 	uint32_t run_phoenix_camera_515238;
3324: 	uint32_t run_bahamut_neo_main_48C2A1;
3325: 	uint32_t run_bahamut_neo_movement_48D7BC;
3326: 	uint32_t run_bahamut_neo_camera_48C75D;
3327: 	uint32_t run_hades_camera_4B65A8;
3328: 	uint32_t run_typhoon_camera_4D594C;
3329: 	uint32_t run_typhoon_sub_4DA182;
3330: 	uint32_t run_bahamut_zero_main_loop_484A16;
3331: 	uint32_t run_bahamut_zero_movement_48BBFC;
3332: 	uint32_t run_bahamut_zero_camera_483866;
3333: 	uint32_t bahamut_zero_draw_bg_effect_sub_4859AA;
3334: 	uint32_t bahamut_zero_bg_star_graphics_data_7F6748;
3335: 	uint32_t run_summon_kotr_sub_476857;
3336: 	uint32_t run_summon_kotr_main_loop_478031;
3337: 	std::array<uint32_t, 13> run_summon_kotr_knight_script;
3338: 	void(*add_kotr_camera_fn_to_effect100_fn_476AAB)(DWORD, DWORD, WORD);
3339: 	uint32_t run_kotr_camera_476AFB;
3340: 	vector3<int>* (*battle_sub_661000)(int);
3341: 	void (*engine_set_game_engine_rot_matrix_663673)(rotation_matrix*);
3342: 	void (*engine_set_game_engine_position_663707)(rotation_matrix*);
3343: 	void (*engine_apply_translation_with_delta_662ECC)(vector3<short>*, vector3<int>*, int*);
3344: 	uint32_t run_chocobuckle_main_loop_560C32;
3345: 	uint32_t run_confu_main_loop_5600BE;
3346: 	uint32_t battle_escape_magic_init_data_5D59B0;
3347: 	uint32_t battle_escape_magic_loop_5D602A;
3348: 	uint32_t bomb_blast_black_bg_effect_537427;
3349: 	uint32_t goblin_punch_flash_573291;
3350: 	uint32_t roulette_skill_main_loop_566287;
3351: 	uint32_t death_sentence_main_loop_5661A0;
3352: 	uint32_t death_kill_sub_loop_562C60;
3353: 	uint32_t death_kill_sub_loop_5624A5;
3354: 	uint32_t enemy_atk_camera_sub_439EE0;
3355: 	uint32_t enemy_atk_camera_sub_44A7D2;
3356: 	uint32_t enemy_atk_camera_sub_44EDC0;
3357: 	uint32_t enemy_atk_camera_sub_4522AD;
3358: 	uint32_t enemy_atk_camera_sub_457C60;
3359: 	uint32_t battle_update_3d_model_data;
3360: 	uint32_t battle_animate_material_texture;
3361: 	uint32_t battle_animate_texture_spt;
3362: 	rotation_matrix* (*get_global_model_matrix_buffer_66100D)();
3363: 	struc_84* (*get_draw_chain_68F860)(struc_49*, graphics_instance*);
3364: 	p_hundred* (*battle_sub_5D1AAA)(int, ff7_polygon_set*);
3365: 	int (*get_alpha_from_transparency_429343)(int);
3366: 	color_ui8 (*get_stored_color_66101A)();
3367: 	void (*battle_sub_68CF75)(char, struc_173*);
3368: 	void (*create_rot_matrix_from_word_matrix_6617E9)(rotation_matrix*, matrix*);
3369: 	struc_84* (*get_draw_chain_671C71)(ff7_graphics_object*);
3370: 	void (*battle_sub_6CE81E)();
3371: 	std::span<battle_model_state> g_battle_model_state;
3372: 	std::span<battle_model_state_small> g_small_battle_model_state;
3373: 	std::span<uint32_t> effect100_array_fn;
3374: 	std::span<effect100_data> effect100_array_data;
3375: 	uint16_t* effect100_counter;
3376: 	uint16_t* effect100_array_idx;
3377: 	std::span<uint32_t> effect60_array_fn;
3378: 	std::span<effect60_data> effect60_array_data;
3379: 	uint16_t* effect60_counter;
3380: 	uint16_t* effect60_array_idx;
3381: 	std::span<uint32_t> effect10_array_fn;
3382: 	std::span<effect10_data> effect10_array_data;
3383: 	uint16_t* effect10_counter;
3384: 	uint16_t* effect10_array_idx;
3385: 	short* effect10_array_data_8FE1F6;
3386: 	std::array<byte*, 14> animation_script_pointers;
3387: 	byte* g_is_effect_loading;
3388: 	byte* g_is_battle_paused;
3389: 	byte* g_actor_idle_scripts;
3390: 	byte* g_script_wait_frames;
3391: 	std::span<int*> g_script_args;
3392: 	byte* special_actor_id;
3393: 	int* field_battle_BFB2E0;
3394: 	float* field_float_battle_7B7680;
3395: 	byte* field_byte_DC0E11;
3396: 	byte* field_battle_byte_BF2E1C;
3397: 	byte* field_battle_byte_BE10B4;
3398: 	short* resting_Y_array_data;
3399: 	WORD* field_odin_frames_AEEC14;
3400: 	palette_extra* palette_extra_data_C06A00;
3401: 	ff7_game_engine_data** global_game_engine_data;
3402: 	std::span<uint32_t> limit_break_effects_fn_table;
3403: 	std::span<uint32_t> enemy_atk_effects_fn_table;
3404: 	std::span<uint32_t> enemy_skill_effects_fn_table;
3405: 	byte* byte_BCC788;
3406: 	vector3<int>** ifrit_vector3_int_ptr_BCC6A8;
3407: 	vector3<short>* battle_ifrit_model_position;
3408: 	rotation_matrix* ifrit_rot_matrix_BCC768;
3409: 	uint32_t pollensalta_cold_breath_atk_enter_sub_5474F0;
3410: 	uint32_t pollensalta_cold_breath_atk_main_loop_5476B0;
3411: 	uint32_t pollensalta_cold_breath_atk_draw_bg_effect_547B94;
3412: 	uint32_t pollensalta_cold_breath_atk_white_dot_effect_547D56;
3413: 	void (*pollensalta_cold_breath_atk_draw_white_dots_547E75)(short);
3414: 	std::span<vector4<short>> pollensalta_cold_breath_white_dots_pos;
3415: 	short* pollensalta_cold_breath_white_dot_rgb_scalar;
3416: 	uint32_t pollensalta_cold_breath_bg_texture_ctx;
3417: 	uint32_t pandora_box_skill_draw_bg_flash_effect_568371;
3418: 
3419: 	// battle menu
3420: 	uint32_t display_battle_menu_6D797C;
3421: 	void (*display_tifa_slots_handler_6E3135)();
3422: 	uint32_t battle_draw_text_ui_graphics_objects_call;
3423: 	uint32_t battle_draw_box_ui_graphics_objects_call;
3424: 	void (*battle_draw_call_42908C)(int, int);
3425: 	uint32_t battle_set_do_render_menu_call;
3426: 	uint32_t battle_set_do_render_menu;
3427: 	int *g_do_render_menu;
3428: 	uint32_t battle_sub_42F3E8;
3429: 	uint32_t battle_handle_player_mark_5B9C8E;
3430: 	uint32_t battle_handle_status_effect_anim_5BA7C0;
3431: 	uint32_t battle_update_targeting_info_6E6291;
3432: 	byte *targeting_actor_id_DC3C98;
3433: 	uint32_t battle_menu_closing_window_box_6DAEF0;
3434: 
3435: 	//battle 3d battleground
3436: 	uint32_t update_3d_battleground;
3437: 	void (*battleground_shake_train_42F088)();
3438: 	uint32_t battleground_vertical_scrolling_42F126;
3439: 	uint32_t battleground_midgar_flashback_rain_5BDC4F;
3440: 
3441: 	// battle dialogue
3442: 	uint32_t battle_sub_42CBF9;
3443: 	uint32_t add_text_to_display_queue;
3444: 	uint32_t update_display_text_queue;
3445: 	uint32_t set_battle_text_active;
3446: 	uint32_t battle_sfx_play_effect_430D14;
3447: 	int (*battle_sub_66C3BF)();
3448: 	uint32_t battle_sub_43526A;
3449: 	uint32_t battle_sub_5C8931;
3450: 	uint32_t run_enemy_ai_script;
3451: 	uint32_t enqueue_script_action;
3452: 	uint32_t battle_sub_41B577;
3453: 	uint32_t battle_sub_41CCB2;
3454: 	std::span<battle_text_data> battle_display_text_queue;
3455: 	battle_ai_context *battle_context;
3456: 	std::span<battle_anim_event> anim_event_queue;
3457: 	byte* anim_event_index;
3458: 	int* g_is_battle_running_9AD1AC;
3459: 	WORD* field_battle_word_BF2E08;
3460: 	WORD* field_battle_word_BF2032;
3461: 	byte* g_active_actor_id;
3462: 
3463: 	// world stuff
3464: 	uint32_t world_mode_loop_sub_74DB8C;
3465: 	uint32_t world_exit_74BD77;
3466: 	uint32_t world_loop_74BE49;
3467: 	void (**world_dword_DE68FC)();
3468: 	void (*world_exit_destroy_graphics_objects_75A921)();
3469: 	uint32_t world_init_variables_74E1E9;
3470: 	uint32_t world_sub_7641A7;
3471: 	void (*world_init_load_wm_bot_block_7533AF)();
3472: 	uint32_t run_world_event_scripts;
3473: 	uint32_t run_world_event_scripts_system_operations;
3474: 	uint32_t world_animate_all_models;
3475: 	uint32_t world_animate_single_model;
3476: 	uint32_t run_world_snake_ai_script_7562FF;
3477: 	uint32_t update_world_snake_position_7564CD;
3478: 	uint32_t is_update_snake_enabled_7562A9;
3479: 	uint32_t animate_world_snake_75692A;
3480: 	bool (*sub_753366)(short, short);
3481: 	void (*world_draw_snake_texture_75D544)(short, short, short, short, world_snake_graphics_data*, short);
3482: 	vector4<short>** world_snake_data_position_ptr_E2A18C;
3483: 	vector4<short>* world_snake_data_position_E29F80;
3484: 	vector4<short>* snake_position_size_of_array_E2A100;
3485: 	world_snake_graphics_data* world_snake_graphics_data_E2A490;
3486: 	world_snake_graphics_data* world_snake_graphics_data_end_E2A6D0;
3487: 	uint32_t world_sub_75EF46;
3488: 	uint32_t world_sub_767540;
3489: 	uint32_t world_sub_767641;
3490: 	uint32_t world_opcode_message_sub_75EE86;
3491: 	uint32_t world_opcode_ask_sub_75EEBB;
3492: 	uint32_t world_opcode_message;
3493: 	uint32_t world_opcode_ask;
3494: 	uint32_t world_text_box_window_opening_769A66;
3495: 	uint32_t world_text_box_window_paging_769C02;
3496: 	uint32_t world_text_box_reverse_paging_76ABE9;
3497: 	uint32_t world_text_box_window_closing_76ADF7;
3498: 	uint32_t world_compute_all_models_data_76323A;
3499: 	uint32_t world_compute_3d_model_data_76328F;
3500: 	uint32_t world_sub_74D319;
3501: 	uint32_t world_sub_762F9A;
3502: 	int (*get_world_encounter_rate)();
3503: 	int (*pop_world_script_stack)();
3504: 	uint32_t world_update_player_74EA48;
3505: 	int (*world_get_player_model_id)();
3506: 	int (*world_get_current_key_input_status)();
3507: 	int (*world_get_player_walkmap_type)();
3508: 	int (*world_get_player_walkmap_region)();
3509: 	void(*world_sub_753D00)(vector3<short>*, short);
3510: 	void(*world_update_model_movement_762E87)(int, int);
3511: 	bool (*world_is_player_model_bitmask)(int);
3512: 	void (*world_copy_player_pos_to_param_762798)(vector4<int>*);
3513: 	void (*world_set_current_entity_to_player_entity)();
3514: 	void (*world_add_y_pos_to_current_entity_761F22)(int);
3515: 	void (*world_add_delta_movement_due_to_bridge_7591C2)(int*, int*);
3516: 	void (*world_current_entity_model_collision_detection_with_other_models_76296E)();
3517: 	int (*world_get_unknown_flag_75335C)();
3518: 	short (*world_get_minimap_mask)();
3519: 	void (*world_set_minimap_mask)(short);
3520: 	void (*world_set_facing_and_direction_to_current_entity)(short);
3521: 	bool (*world_is_current_entity_animated_761F44)();
3522: 	void (*world_sub_74D6BB)();
3523: 	void (*world_sub_74D6F6)();
3524: 	void (*world_sub_762F75)(short, short, short);
3525: 	void (*world_run_special_opcode_7640BC)(int);
3526: 	void (*world_set_camera_fade_speed_755B97)(int);
3527: 	void (*world_set_world_control_lock_74D438)(int, int);
3528: 	void (*world_sub_74C980)(int);
3529: 	void (*world_sub_753BE8)();
3530: 	void (*world_music_set_frequency_all_channels_75E6A8)(byte, char);
3531: 	void (*world_sfx_play_or_stop_75E6CC)(int);
3532: 	void (*world_set_camera_view_type_74D3D1)(int);
3533: 	uint32_t world_update_camera_74E8CE;
3534: 	int (*world_snowstorm_get_camera_movement_758B12)(int, int);
3535: 	int (*world_get_camera_rotation_x_74F916)();
3536: 	int* world_highwind_height_lowerbound_DF5420;
3537: 	int* world_mode_E045E4;
3538: 	int* previous_player_direction_DF5434;
3539: 	int* world_is_control_enabled_DE6B5C;
3540: 	short* world_special_delta_movement_DE6A18;
3541: 	int* world_y_player_pos_flag_DE6A14;
3542: 	int* world_unk_rotation_value_E045E0;
3543: 	world_event_data** world_event_current_entity_ptr_E39AD8;
3544: 	world_event_data** world_event_current_entity_ptr_E3A7CC;
3545: 	int* world_progress_E28CB4;
3546: 	int* is_wait_frames_zero_E39BC0;
3547: 	int* world_prev_key_input_status_DFC470;
3548: 	int* world_map_type_E045E8;
3549: 	int* world_movement_multiplier_DFC480;
3550: 	int* world_camera_var1_DF542C;
3551: 	int* world_camera_var2_DE6B4C;
3552: 	int* world_camera_var3_DE6A0C;
3553: 	int* world_camera_viewtype_DFC4B4;
3554: 	int* world_camera_front_DFC484;
3555: 	int* world_camera_rotation_y_DFC474;
3556: 	int* world_camera_position_z_DFC478;
3557: 	int* world_camera_delta_y_DE6A04;
3558: 	int* world_camera_rotation_z_DE6B70;
3559: 	short* world_current_camera_rotation_x_DE7418;
3560: 	std::span<short> world_camera_x_rotation_array_E37120;
3561: 	rotation_matrix* world_camera_position_matrix_DE6A20;
3562: 	rotation_matrix* world_camera_direction_matrix_DFC448;
3563: 	vector4<int>* world_player_pos_E04918;
3564: 	uint32_t world_sub_75A1C6;
3565: 	uint32_t world_load_graphics_objects_75A5D5;
3566: 	uint32_t world_init_load_map_meshes_graphics_objects_75A283;
3567: 	void (*world_wm0_overworld_draw_all_74C179)();
3568: 	void (*world_wm2_underwater_draw_all_74C3F0)();
3569: 	void (*world_wm3_snowstorm_draw_all_74C589)();
3570: 	uint32_t world_draw_all_3d_model_74C6B0;
3571: 	uint32_t world_draw_fade_quad_75551A;
3572: 	uint32_t world_sub_75079D;
3573: 	uint32_t world_sub_751EFC;
3574: 	uint32_t world_sub_75C02B;
3575: 	uint32_t world_sub_75C0FD;
3576: 	uint32_t world_sub_75C283;
3577: 	uint32_t world_sub_75F0AD;
3578: 	uint32_t world_sub_75042B;
3579: 	uint32_t world_culling_bg_meshes_75F263;
3580: 	uint32_t world_submit_draw_bg_meshes_75F68C;
3581: 	uint32_t world_compute_skybox_data_754100;
3582: 	uint32_t world_submit_draw_clouds_and_meteor_7547A6;
3583: 	int (*sub_74C9A5)();
3584: 	int* is_meteor_flag_on_E2AAE4;
3585: 	uint32_t engine_apply_4x4_matrix_product_with_game_obj_matrix_67D2BF;
3586: 	void (*engine_apply_4x4_matrix_product_between_matrices_66C6CD)(struct matrix *, struct matrix *, struct matrix *);
3587: 	void (*world_copy_position_75042B)(vector4<int>* a1);
3588: 	int (*get_world_camera_front_rot_74D298)();
3589: 	void (*engine_apply_rotation_to_rot_matrix_662AD8)(vector3<short>*, transform_matrix*);
3590: 	short (*world_get_world_current_camera_rotation_x_74D3C6)();
3591: 	int (_stdcall *world_submit_draw_effects_75C283)(world_texture_data*, int, vector3<short>*, short);
3592: 	world_effect_2d_list_node** dword_E35648;
3593: 	byte* byte_96D6A8;
3594: 
3595: 	uint32_t swirl_main_loop;
3596: 	uint32_t swirl_loop_sub_4026D4;
3597: 	uint32_t swirl_enter_40164E;
3598: 	uint32_t swirl_enter_sub_401810;
3599: 
3600: 	uint32_t field_culling_model_639252;
3601: 	uint32_t field_sub_63AC66;
3602: 	void (*field_sub_63AC3F)(int, int, int, int);
3603: 	uint32_t battle_draw_quad_5BD473;
3604: 	uint32_t battle_sub_5895E0;
3605: 	uint32_t battle_sub_589827;
3606: 	uint32_t battle_sub_58AC59;
3607: 	uint32_t battle_sub_58ACB9;
3608: 	uint32_t ifrit_sub_595A05;
3609: 	void (*engine_draw_sub_66A47E)(int);
3610: 	int* battle_viewport_height;
3611: 	uint32_t neo_bahamut_main_loop_48DA7A;
3612: 	uint32_t neo_bahamut_effect_sub_490F2A;
3613: 	uint32_t odin_gunge_effect_sub_4A4BE6;
3614: 	uint32_t odin_gunge_effect_sub_4A3A2E;
3615: 	uint32_t typhoon_effect_sub_4DB15F;
3616: 	uint32_t typhoon_sub_4D6FF8;
3617: 	uint32_t typhoon_effect_sub_4D7044;
3618: 	uint32_t fat_chocobo_sub_5096F3;
3619: 	uint32_t barret_limit_3_1_sub_4700F7;
3620: 	uint32_t shadow_flare_draw_white_bg_57747E;
3621: 	uint32_t credits_submit_draw_fade_quad_7AA89B;
3622: 	uint32_t menu_submit_draw_fade_quad_6CD64E;
3623: 	int (*get_button_pressed)(int);
3624: 	uint32_t credits_main_loop;
3625: 	uint32_t highway_submit_fade_quad_659532;
3626: 	uint32_t chocobo_enter_76D597;
3627: 	uint32_t chocobo_initialize_variables_76BAFD;
3628: 	uint32_t chocobo_init_viewport_values_76D320;
3629: 	uint32_t chocobo_submit_draw_fade_quad_77B1CE;
3630: 	uint32_t chocobo_submit_draw_water_quad_77A7D0;
3631: 	void(*generic_submit_quad_graphics_object_671D2A)(int, int, int, int, int, int, float, DWORD*) ;
3632: 	byte* chocobo_fade_quad_data_97A498;
3633: 
3634: 	// snowboard
3635: 	uint32_t snowboard_enter_sub_722C10;
3636: 	uint32_t snowboard_loop_sub_72381C;
3637: 	uint32_t snowboard_exit_sub_722C52;
3638: 	uint32_t snowboard_draw_sky_and_mountains_72DAF0;
3639: 	uint32_t snowboard_submit_draw_sky_quad_graphics_object_72E31F;
3640: 	float* snowboard_sky_quad_pos_x_7B7DB8;
3641: 	uint32_t snowboard_submit_draw_black_quad_graphics_object_72DD94;
3642: 	uint32_t snowboard_submit_draw_white_fade_quad_graphics_object_72DD53;
3643: 	uint32_t snowboard_submit_draw_opaque_quad_graphics_object_72DDD5;
3644: 	uint32_t snowboard_parse_model_vertices_732159;
3645: 	uint32_t sub_735220;
3646: 	uint32_t sub_735332;
3647: 	char* (*sub_7322D6)(tmd_primitive_packet*, int, int);
3648: 	char* (*sub_732429)(tmd_primitive_packet*, int, int);
3649: 	char* (*sub_732BB9)(tmd_primitive_packet*, int, int);
3650: 	char* (__thiscall *sub_732546)(snowboard_this*, tmd_primitive_packet*, int, int);
3651: 	matrix* (__thiscall *sub_733479)(void*, const matrix*);
3652: 	point4d* (__thiscall *sub_733564)(void*, vector3<float>*, point4d*);
3653: 	DWORD* snowboard_global_object_off_926290;
3654: 
3655: 	// condor
3656: 	uint32_t condor_enter;
3657: 	uint32_t condor_exit;
3658: 	uint32_t sub_5F7756;
3659: 	uint32_t sub_5F4273;
3660: 	uint32_t sub_5F342C;
3661: 	DWORD* condor_uses_lgp;
3662: };
3663: 
3664: uint32_t ff7gl_load_group(uint32_t group_num, struct matrix_set *matrix_set, struct p_hundred *hundred_data, struct p_group *group_data, struct polygon_data *polygon_data, struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object);
3665: void ff7gl_field_78(struct ff7_polygon_set *polygon_set, struct ff7_game_obj *game_object);
3666: void ff7_init_hooks(struct game_obj *_game_object);
3667: struct ff7_gfx_driver *ff7_load_driver(void *game_object);
</file>

<file path="src/ff8_data.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2020 Marcin Gomulak                                     //
  9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <stdio.h>
 24: 
 25: #include "ff8_data.h"
 26: 
 27: #include "ff8.h"
 28: #include "globals.h"
 29: #include "patch.h"
 30: #include "ff8/battle/effects.h"
 31: 
 32: #include "log.h"
 33: 
 34: void ff8_set_main_loop(uint32_t driver_mode, uint32_t main_loop)
 35: {
 36: 	uint32_t i;
 37: 
 38: 	for(i = 0; i < num_modes; i++) if(ff8_modes[i].driver_mode == driver_mode) ff8_modes[i].main_loop = main_loop;
 39: }
 40: 
 41: void ff8_find_externals()
 42: {
 43: 	common_externals.winmain = get_relative_call(ff8_externals.start, 0xDB);
 44: 	common_externals.create_window = get_relative_call(common_externals.winmain, 0x114);
 45: 	common_externals.engine_wndproc = (WNDPROC)get_absolute_value(common_externals.create_window, 0x34);
 46: 
 47: 	ff8_externals.main_entry = get_relative_call(common_externals.winmain, 0x4D);
 48: 
 49: 	if (JP_VERSION)
 50: 	{
 51: 		ff8_externals.main_entry = get_relative_call(ff8_externals.main_entry, 0x0);
 52: 	}
 53: 
 54: 	ff8_externals.archive_path_prefix = (char *)get_absolute_value(ff8_externals.main_entry, 0x2E);
 55: 	ff8_externals.manage_time_engine_sub_569971 = get_relative_call(common_externals.winmain, 0x23);
 56: 	ff8_externals.enable_rdtsc_sub_40AA00 = (int (*)(int))get_relative_call(ff8_externals.manage_time_engine_sub_569971, 0x21);
 57: 	common_externals.get_time = (uint64_t (*)(uint64_t*))get_relative_call(common_externals.winmain, 0x20E);
 58: 	common_externals.diff_time = (uint64_t (*)(uint64_t*,uint64_t*,uint64_t*))get_relative_call(common_externals.winmain, 0x41E);
 59: 	ff8_externals.init_config = get_relative_call(ff8_externals.main_entry, 0x73);
 60: 	ff8_externals.pubintro_init = get_absolute_value(ff8_externals.main_entry, 0x158);
 61: 	ff8_externals.pubintro_cleanup = get_absolute_value(ff8_externals.main_entry, 0x162);
 62: 	ff8_externals.pubintro_enter_main = get_absolute_value(ff8_externals.main_entry, 0x16C);
 63: 
 64: 	if (JP_VERSION)
 65: 	{
 66: 		ff8_externals.init_config = get_relative_call(ff8_externals.init_config, 0x0);
 67: 		ff8_externals.pubintro_init = get_relative_call(ff8_externals.pubintro_init, 0x0);
 68: 		ff8_externals.pubintro_cleanup = get_relative_call(ff8_externals.pubintro_cleanup, 0x0);
 69: 	}
 70: 
 71: 	ff8_externals.sub_467C00 = get_relative_call(ff8_externals.pubintro_init, 0xB5);
 72: 	ff8_externals.input_init = get_relative_call(ff8_externals.pubintro_init, 0xBA);
 73: 	ff8_externals.ff8input_cfg_read = get_relative_call(ff8_externals.input_init, 0x5);
 74: 	ff8_externals.sub_468810 = get_relative_call(ff8_externals.sub_467C00, 0x59);
 75: 	ff8_externals.dinput_get_input_device_capabilities_number_of_buttons = get_relative_call(ff8_externals.sub_467C00, 0xA8);
 76: 	ff8_externals.sub_468BD0 = get_relative_call(ff8_externals.sub_468810, 0x5B);
 77: 	common_externals.dinput_hack1 = ff8_externals.sub_468BD0 + 0x64;
 78: 
 79: 	ff8_externals.pubintro_exit = get_absolute_value(ff8_externals.main_entry, 0x176);
 80: 	ff8_externals.pubintro_main_loop = get_absolute_value(ff8_externals.main_entry, 0x180);
 81: 	ff8_externals.credits_main_loop = get_absolute_value(ff8_externals.pubintro_main_loop, 0x6D);
 82: 	ff8_externals.go_to_main_menu_main_loop = get_absolute_value(ff8_externals.credits_main_loop, 0xE2);
 83: 	ff8_externals.main_menu_enter = get_absolute_value(ff8_externals.go_to_main_menu_main_loop, 0x19);
 84: 	ff8_externals.main_menu_main_loop = get_absolute_value(ff8_externals.go_to_main_menu_main_loop, 0x2B);
 85: 
 86: 	ff8_set_main_loop(MODE_CREDITS, ff8_externals.credits_main_loop);
 87: 	ff8_set_main_loop(MODE_MAIN_MENU, ff8_externals.main_menu_main_loop);
 88: 
 89: 	ff8_externals.config_worldmap_fog_disabled = (uint8_t *)get_absolute_value(ff8_externals.main_entry, 0x1C1);
 90: 	ff8_externals.config_worldmap_color_anim_disabled = (uint8_t *)get_absolute_value(ff8_externals.main_entry, 0x1C7);
 91: 	ff8_externals.config_worldmap_textured_anim_disabled = (uint8_t *)get_absolute_value(ff8_externals.main_entry, 0x1CC);
 92: 
 93: 	ff8_externals.load_credits_image = get_relative_call(ff8_externals.credits_main_loop, 0xBF);
 94: 
 95: 	ff8_externals.sub_52FE80 = get_relative_call(ff8_externals.load_credits_image, 0xA4);
 96: 	ff8_externals.input_fill_keystate = (void(*)())get_relative_call(ff8_externals.sub_52FE80, 0xC8);
 97: 	ff8_externals.input_get_keyscan = (int(*)(int,int))get_relative_call(ff8_externals.sub_52FE80, 0xD1);
 98: 	ff8_externals.credits_loop_state = (DWORD*)get_absolute_value(ff8_externals.load_credits_image, 0x7);
 99: 	ff8_externals.credits_counter = (DWORD *)get_absolute_value(ff8_externals.load_credits_image, 0x59);
100: 	ff8_externals.credits_current_image_global_counter_start = (DWORD *)get_absolute_value(ff8_externals.load_credits_image, 0x1CB);
101: 	ff8_externals.credits_current_step_image = (DWORD *)get_absolute_value(ff8_externals.load_credits_image, 0x1BC);
102: 	ff8_externals.sub_470630 = get_absolute_value(ff8_externals.main_menu_main_loop, 0xE4);
103: 	ff8_externals.main_loop = get_absolute_value(ff8_externals.sub_470630, 0x24);
104: 
105: 	ff8_externals.reg_get_data_drive = (uint32_t(*)(char*, DWORD))get_relative_call(ff8_externals.init_config, 0x21);
106: 	ff8_externals.get_disk_number = get_relative_call(ff8_externals.main_loop, 0x1A);
107: 	ff8_externals.disk_data_path = (char*)get_absolute_value(ff8_externals.get_disk_number, 0xF);
108: 	ff8_externals.set_game_paths = (void (*)(int, char*, const char*))get_relative_call(ff8_externals.init_config, 0x3E);
109: 	if (JP_VERSION)
110: 	{
111: 		ff8_externals.set_game_paths = (void (*)(int, char*, const char*))get_relative_call(uint32_t(ff8_externals.set_game_paths), 0x0);
112: 	}
113: 	ff8_externals.app_path = (const char*)get_absolute_value(uint32_t(ff8_externals.set_game_paths), 0x9A);
114: 
115: 	ff8_externals.savemap = (savemap_ff8*)get_absolute_value(ff8_externals.pubintro_enter_main, 0x9);
116: 	ff8_externals.savemap_field = (savemap_ff8_field_h**)get_absolute_value(ff8_externals.main_loop, 0x21);
117: 
118: 	if (JP_VERSION)
119: 	{
120: 		ff8_externals.sm_pc_read = (uint32_t(*)(char*, void*))get_relative_call(ff8_externals.main_loop, 0x9C + 3);
121: 		ff8_externals.cdcheck_main_loop = get_absolute_value(ff8_externals.main_loop, 0xBB + 3);
122: 		common_externals._mode = (WORD *)get_absolute_value(ff8_externals.main_loop, 0x115 + 3);
123: 		ff8_externals.field_main_exit = get_absolute_value(ff8_externals.main_loop, 0x13C + 3);
124: 		ff8_externals.field_main_loop = get_absolute_value(ff8_externals.main_loop, 0x144 + 3);
125: 		common_externals.current_field_id = (WORD*)get_absolute_value(ff8_externals.main_loop, 0x21F + 6);
126: 		ff8_externals.worldmap_enter_main = get_absolute_value(ff8_externals.main_loop, 0x2C0 + 4);
127: 		ff8_externals.worldmap_main_loop = get_absolute_value(ff8_externals.main_loop, 0x2D0 + 4);
128: 		ff8_externals.battle_enter = get_absolute_value(ff8_externals.main_loop, 0x330 + 4);
129: 		ff8_externals.battle_main_loop = get_absolute_value(ff8_externals.main_loop, 0x340 + 4);
130: 		// Search battle sound function to find play/stop midi related methods
131: 		ff8_externals.sm_battle_sound = get_relative_call(ff8_externals.main_loop, 0x487 + 5);
132: 		ff8_externals.swirl_enter = get_absolute_value(ff8_externals.main_loop, 0x493 + 5);
133: 		ff8_externals.swirl_main_loop = get_absolute_value(ff8_externals.main_loop, 0x4A3 + 5);
134: 		ff8_externals.sub_470250 = get_relative_call(ff8_externals.main_loop, 0x6E7 - 15);
135: 	}
136: 	else
137: 	{
138: 		ff8_externals.sm_pc_read = (uint32_t(*)(char*, void*))get_relative_call(ff8_externals.main_loop, 0x9C);
139: 		ff8_externals.cdcheck_main_loop = get_absolute_value(ff8_externals.main_loop, 0xBB);
140: 		common_externals._mode = (WORD *)get_absolute_value(ff8_externals.main_loop, 0x115);
141: 		ff8_externals.field_main_exit = get_absolute_value(ff8_externals.main_loop, 0x13C);
142: 		ff8_externals.field_main_loop = get_absolute_value(ff8_externals.main_loop, 0x144);
143: 		common_externals.current_field_id = (WORD*)get_absolute_value(ff8_externals.main_loop, 0x21F);
144: 		ff8_externals.worldmap_enter_main = get_absolute_value(ff8_externals.main_loop, 0x2C0);
145: 		ff8_externals.worldmap_main_loop = get_absolute_value(ff8_externals.main_loop, 0x2D0);
146: 		ff8_externals.battle_enter = get_absolute_value(ff8_externals.main_loop, 0x330);
147: 		ff8_externals.battle_main_loop = get_absolute_value(ff8_externals.main_loop, 0x340);
148: 		// Search battle sound function to find play/stop midi related methods
149: 		ff8_externals.sm_battle_sound = get_relative_call(ff8_externals.main_loop, 0x487);
150: 		ff8_externals.swirl_enter = get_absolute_value(ff8_externals.main_loop, 0x493);
151: 		ff8_externals.swirl_main_loop = get_absolute_value(ff8_externals.main_loop, 0x4A3);
152: 		ff8_externals.sub_470250 = get_relative_call(ff8_externals.main_loop, 0x6E7);
153: 	}
154: 
155: 	ff8_externals.psxvram_texture_pages_free = get_relative_call(ff8_externals.field_main_exit, 0x58);
156: 	ff8_externals.sub_4672C0 = get_relative_call(ff8_externals.psxvram_texture_pages_free, 0x5A);
157: 	ff8_externals.psxvram_texture_page_free = get_relative_call(ff8_externals.psxvram_texture_pages_free, 0x21);
158: 	ff8_externals.psxvram_texture_page_tex_header_free = get_relative_call(ff8_externals.psxvram_texture_page_free, 0x98);
159: 	ff8_externals.engine_set_init_time = get_relative_call(ff8_externals.battle_enter, 0x35);
160: 	ff8_externals.sub_460B60 = get_relative_call(ff8_externals.swirl_enter, 0x9);
161: 
162: 	common_externals.debug_print2 = get_relative_call(uint32_t(ff8_externals.sm_pc_read), 0x16);
163: 	ff8_externals.moriya_filesystem_open = get_relative_call(uint32_t(ff8_externals.sm_pc_read), 0x21);
164: 	ff8_externals.moriya_filesystem_seek = get_relative_call(uint32_t(ff8_externals.sm_pc_read), 0x77);
165: 	ff8_externals.moriya_filesystem_read = get_relative_call(uint32_t(ff8_externals.sm_pc_read), 0xB7);
166: 	ff8_externals.moriya_filesystem_close = get_relative_call(uint32_t(ff8_externals.sm_pc_read), 0xDD);
167: 	ff8_externals.read_or_uncompress_fs_data = get_relative_call(ff8_externals.moriya_filesystem_read, 0x5C);
168: 	ff8_externals.lzs_uncompress = get_relative_call(ff8_externals.read_or_uncompress_fs_data, 0x1E6);
169: 	ff8_externals.free_file_container = (void(*)(ff8_file_container*))get_relative_call(ff8_externals.moriya_filesystem_close, 0x1F);
170: 	ff8_externals.sub_archive_get_filename = (void(*)(const char*,char*))get_relative_call(ff8_externals.moriya_filesystem_open, 0x126);
171: 	ff8_externals.temp_fs_path_cache = (char *)get_absolute_value(ff8_externals.moriya_filesystem_open, 0x161);
172: 	ff8_externals.archive_open = (ff8_file_container*(*)(char*,char*,char*))get_relative_call(ff8_externals.moriya_filesystem_open, 0x27D);
173: 
174: 	ff8_externals.cdcheck_sub_52F9E0 = get_relative_call(ff8_externals.cdcheck_main_loop, 0x95);
175: 
176: 	ff8_set_main_loop(MODE_CDCHECK, ff8_externals.cdcheck_main_loop);
177: 	ff8_set_main_loop(MODE_SWIRL, ff8_externals.swirl_main_loop);
178: 	ff8_set_main_loop(MODE_BATTLE, ff8_externals.battle_main_loop);
179: 	ff8_set_main_loop(MODE_FIELD, ff8_externals.field_main_loop);
180: 	ff8_set_main_loop(MODE_WORLDMAP, ff8_externals.worldmap_main_loop);
181: 
182: 	ff8_externals.sub_47CCB0 = get_relative_call(ff8_externals.battle_main_loop, 0x1B3);
183: 	ff8_externals.sub_534640 = get_relative_call(ff8_externals.sub_47CCB0, 0xF1);
184: 	ff8_externals.sub_4972A0 = get_relative_call(ff8_externals.sub_534640, 0x51);
185: 	ff8_externals.load_fonts = get_relative_call(ff8_externals.sub_4972A0, 0x16);
186: 
187: 	ff8_externals.engine_reset_viewport_sub_4972D0 = get_relative_call(ff8_externals.main_menu_enter, 0xD);
188: 	ff8_externals.engine_setviewport_sub_45B4C0 = get_relative_call(ff8_externals.field_main_loop, 0x39);
189: 	ff8_externals.engine_setviewport_sub_41E070 = (void*(*)(int, int, int, int, void*))get_relative_call(ff8_externals.engine_setviewport_sub_45B4C0, 0x6B);
190: 	ff8_externals.dword_B7CE28 = (uint32_t*)get_absolute_value(ff8_externals.engine_setviewport_sub_45B4C0, 0x53);
191: 	ff8_externals.flag_d3d_renderer_related_dword_1CCFD94 = (uint32_t*)get_absolute_value(ff8_externals.engine_setviewport_sub_45B4C0, 0x5D);
192: 	ff8_externals.ssigpu_viewport_x_dword_1CA89D8 = (int32_t*)get_absolute_value(ff8_externals.engine_setviewport_sub_45B4C0, 0x1C);
193: 	ff8_externals.ssigpu_viewport_y_dword_1CA89DC = (int32_t*)get_absolute_value(ff8_externals.engine_setviewport_sub_45B4C0, 0x22);
194: 	ff8_externals.ssigpu_viewport_width_dword_B7CBF8 = (int32_t*)get_absolute_value(ff8_externals.engine_setviewport_sub_45B4C0, 0x28);
195: 	ff8_externals.ssigpu_viewport_height_dword_B7CBFC = (int32_t*)get_absolute_value(ff8_externals.engine_setviewport_sub_45B4C0, 0x2E);
196: 	ff8_externals.current_viewport_x_dword_1A7764C = (int32_t*)get_absolute_value(ff8_externals.worldmap_enter_main, 0x15);
197: 	ff8_externals.current_viewport_y_dword_1A77648 = (int32_t*)get_absolute_value(ff8_externals.worldmap_enter_main, 0x1B);
198: 	ff8_externals.current_viewport_width_dword_1A77654 = (int32_t*)get_absolute_value(ff8_externals.worldmap_enter_main, 0x21);
199: 	ff8_externals.current_viewport_height_dword_1A77650 = (int32_t*)get_absolute_value(ff8_externals.worldmap_enter_main, 0x2B);
200: 
201: 	ff8_externals.sub_537F30 = get_relative_call(ff8_externals.sub_534640, 0x2E);
202: 	ff8_externals.sub_5391B0 = get_relative_call(ff8_externals.sub_537F30, 0x58);
203: 	ff8_externals.sub_534560 = get_relative_call(ff8_externals.sub_534640, 0x5B);
204: 	ff8_externals.cardgame_funcs = (uint32_t *)get_absolute_value(ff8_externals.sub_534560, 0x5D);
205: 	ff8_externals.sub_536C30 = ff8_externals.cardgame_funcs[1];
206: 	ff8_externals.cardgame_func_534340 = ff8_externals.cardgame_funcs[2];
207: 	ff8_externals.cargame_func_535C90 = ff8_externals.cardgame_funcs[3];
208: 	ff8_externals.cardgame_func_534BC0 = (int(*)())ff8_externals.cardgame_funcs[4];
209: 	ff8_externals.sub_536CB0 = get_absolute_value(ff8_externals.sub_536C30, 0x14);
210: 	ff8_externals.card_texts_off_B96968 = (uint8_t **)get_absolute_value(ff8_externals.sub_536CB0, 0x59);
211: 	ff8_externals.sub_536C80 = get_absolute_value(ff8_externals.sub_536C30, 0x25);
212: 	ff8_externals.sub_5366D0 = get_absolute_value(ff8_externals.cargame_func_535C90, 0x42);
213: 	ff8_externals.cardgame_tim_texture_intro = (uint8_t *)get_absolute_value(ff8_externals.sub_536C80, 0x3);
214: 	ff8_externals.cardgame_tim_texture_game = (uint8_t *)get_absolute_value(ff8_externals.sub_5366D0, 0x119);
215: 	ff8_externals.cardgame_tim_texture_cards = (uint8_t *)get_absolute_value(ff8_externals.sub_534640, 0x11B);
216: 	ff8_externals.cardgame_tim_texture_icons = (uint8_t *)get_absolute_value(ff8_externals.sub_534640, 0x125);
217: 	ff8_externals.sub_539500 = get_relative_call(ff8_externals.sub_534640, 0x110);
218: 	ff8_externals.cardgame_tim_texture_font = (uint8_t *)get_absolute_value(ff8_externals.sub_539500, 0x1);
219: 	ff8_externals.is_card_game = (uint32_t*)get_absolute_value(ff8_externals.sub_47CCB0, *(uint32_t *)(ff8_externals.sub_47CCB0 + 0xF2) + 0xF7);
220: 	ff8_externals.cardgame_add_card_to_squall_534840 = get_relative_call((uint32_t)ff8_externals.cardgame_func_534BC0, 0x181);
221: 	ff8_externals.cardgame_sub_536DE0 = get_relative_call(ff8_externals.cardgame_func_534340, 0x2);
222: 	ff8_externals.cardgame_sub_537110 = get_absolute_value(ff8_externals.cardgame_sub_536DE0, 0x15);
223: 	ff8_externals.cardgame_update_card_with_location_5347F0 = get_relative_call(ff8_externals.cardgame_sub_537110, 0xFD);
224: 	ff8_externals.cardgame_sub_535D00 = (int(*)(void*))get_absolute_value(ff8_externals.cargame_func_535C90, 0x19);
225: 
226: 	ff8_externals.loc_47D490 = ff8_externals.sub_47CCB0 + 0xDA + 0x4 + *((int32_t *)(ff8_externals.sub_47CCB0 + 0xDA));
227: 	ff8_externals.sub_500870 = get_relative_call(ff8_externals.loc_47D490, 0x85);
228: 	ff8_externals.sub_500C00 = get_relative_call(ff8_externals.sub_500870, 0x31);
229: 	ff8_externals.sub_500CC0 = get_absolute_value(ff8_externals.sub_500C00, 0x9A);
230: 	ff8_externals.sub_506C90 = get_relative_call(ff8_externals.sub_500CC0, 0x7F);
231: 	ff8_externals.sub_506CF0 = get_absolute_value(ff8_externals.sub_506C90, 0x2F);
232: 	ff8_externals.sub_5084B0 = get_relative_call(ff8_externals.sub_506CF0, 0x2A);
233: 	ff8_externals.battle_open_file_wrapper = get_relative_call(ff8_externals.sub_5084B0, 0x1B);
234: 	ff8_externals.battle_open_file = get_relative_call(ff8_externals.battle_open_file_wrapper, 0x14);
235: 	ff8_externals.battle_filenames = (char **)get_absolute_value(ff8_externals.battle_open_file, 0x11);
236: 
237: 	ff8_externals.sub_47D890 = get_relative_call(ff8_externals.sub_506CF0, 0x59);
238: 	ff8_externals.sub_505DF0 = get_relative_call(ff8_externals.sub_506CF0, 0xAA);
239: 	ff8_externals.sub_4A94D0 = get_relative_call(ff8_externals.sub_47D890, 0x9);
240: 	ff8_externals.sub_4BCBE0 = get_relative_call(ff8_externals.sub_4A94D0, 0x1E0);
241: 	ff8_externals.sub_4C8B10 = get_relative_call(ff8_externals.sub_4BCBE0, 0x8E);
242: 	ff8_externals.battle_pause_sub_4CD140 = get_absolute_value(ff8_externals.sub_4C8B10, 0x3);
243: 	ff8_externals.battle_pause_window_sub_4CD350 = get_relative_call(ff8_externals.battle_pause_sub_4CD140, JP_VERSION ? 0x1F1 : 0x225);
244: 	ff8_externals.is_alternative_pause_menu = (uint32_t *)get_absolute_value(ff8_externals.battle_pause_window_sub_4CD350, 0x6B);
245: 	ff8_externals.pause_menu_option_state = (uint32_t *)get_absolute_value(ff8_externals.battle_pause_window_sub_4CD350, 0x9C);
246: 	ff8_externals.battle_menu_state = (void *)get_absolute_value(ff8_externals.battle_pause_window_sub_4CD350, 0x29);
247: 	ff8_externals.sub_4A7210 = get_relative_call(ff8_externals.battle_pause_window_sub_4CD350, 0xC3);
248: 
249: 	ff8_externals.battle_load_textures_sub_500900 = get_relative_call(ff8_externals.sub_47CCB0, 0x98D);
250: 	ff8_externals.loc_5005A0 = ff8_externals.battle_load_textures_sub_500900 + 0x9D + 0x4 + *((int32_t *)(ff8_externals.battle_load_textures_sub_500900 + 0x9D));
251: 	ff8_externals.battle_upload_texture_to_vram = get_relative_call(ff8_externals.loc_5005A0, 0xD1);
252: 	ff8_externals.copy_psx_vram_part = get_relative_call(ff8_externals.battle_upload_texture_to_vram, 0x8D);
253: 
254: 	ff8_externals.fonts = (font_object **)get_absolute_value(ff8_externals.load_fonts, JP_VERSION ? 0x17 : 0x16);
255: 
256: 	common_externals.assert_malloc = (void* (*)(uint32_t, const char*, uint32_t))get_relative_call(ff8_externals.load_fonts, JP_VERSION ? 0x29 : 0x2A);
257: 
258: 	ff8_externals.sub_471F70 = get_relative_call(ff8_externals.field_main_loop, 0x148);
259: 	ff8_externals.field_fade_transition_sub_472990 = get_relative_call(ff8_externals.field_main_loop, 0x19E);
260: 	ff8_externals.sub_45CDD0 = get_relative_call(ff8_externals.field_fade_transition_sub_472990, 0x5C);
261: 
262: 	if (JP_VERSION)
263: 	{
264: 		ff8_externals.sub_4767B0 = get_relative_call(ff8_externals.sub_471F70, 0x4FE - 2);
265: 		common_externals.update_field_entities = get_relative_call(ff8_externals.sub_4767B0, 0x14E + 1);
266: 		ff8_externals.sub_4789A0 = get_relative_call(ff8_externals.sub_4767B0, 0x40F + 3);
267: 		ff8_externals.stop_cdrom = (uint32_t(*)())get_relative_call(ff8_externals.sub_4767B0, 0xB46 - 13);
268: 		ff8_externals.stop_cdrom_field_call = ff8_externals.sub_4767B0 + 0xB46 - 0xD;
269: 		ff8_externals.sub_47CA90 = (char (*)())get_relative_call(ff8_externals.sub_4789A0, 0x674);
270: 	}
271: 	else
272: 	{
273: 		ff8_externals.sub_4767B0 = get_relative_call(ff8_externals.sub_471F70, 0x4FE);
274: 		common_externals.update_field_entities = get_relative_call(ff8_externals.sub_4767B0, 0x14E);
275: 		ff8_externals.sub_4789A0 = get_relative_call(ff8_externals.sub_4767B0, 0x40F);
276: 		ff8_externals.stop_cdrom = (uint32_t(*)())get_relative_call(ff8_externals.sub_4767B0, 0xB46);
277: 		ff8_externals.stop_cdrom_field_call = ff8_externals.sub_4767B0 + 0xB46;
278: 		ff8_externals.sub_47CA90 = (char (*)())get_relative_call(ff8_externals.sub_4789A0, 0x68B);
279: 	}
280: 
281: 	ff8_externals.battle_trigger_field = uint32_t(ff8_externals.sub_47CA90) + 0x15;
282: 	ff8_externals.field_update_seed_level_52B140 = get_relative_call(common_externals.update_field_entities, 0x120);
283: 	ff8_externals.field_update_rinoa_limit_breaks_52B320 = get_relative_call(common_externals.update_field_entities, 0x183);
284: 	ff8_externals.check_game_is_paused = (int32_t(*)(int32_t))get_relative_call(ff8_externals.field_main_loop, 0x16C);
285: 	ff8_externals.is_game_paused = (DWORD*)get_absolute_value((uint32_t)ff8_externals.check_game_is_paused, 0x78);
286: 	ff8_externals.pause_menu = (int(*)(int))get_relative_call(uint32_t(ff8_externals.check_game_is_paused), 0x88);
287: 	ff8_externals.init_pause_menu = get_relative_call(uint32_t(ff8_externals.check_game_is_paused), 0xE2);
288: 	ff8_externals.pause_menu_with_vibration = (int(*)(int))(ff8_externals.init_pause_menu - 0x290);
289: 	ff8_externals.ff8_draw_icon_or_key1 = get_relative_call(uint32_t(ff8_externals.pause_menu_with_vibration), 0x1CF);
290: 	ff8_externals.get_icon_sp1_data = get_relative_call(ff8_externals.ff8_draw_icon_or_key1, 0x2);
291: 	ff8_externals.draw_controller_or_keyboard_icons = get_relative_call(ff8_externals.ff8_draw_icon_or_key1, 0x40);
292: 	ff8_externals.get_command_key = get_relative_call(ff8_externals.draw_controller_or_keyboard_icons, 0x31);
293: 	ff8_externals.sub_49BB30 = get_relative_call(ff8_externals.ff8_draw_icon_or_key1, 0xF6);
294: 	ff8_externals.vibration_apply = get_relative_call(uint32_t(ff8_externals.pause_menu_with_vibration), 0xB4);
295: 	ff8_externals.vibration_set_is_enabled = get_relative_call(uint32_t(ff8_externals.pause_menu_with_vibration), 0xF3);
296: 	ff8_externals.vibration_get_is_enabled = get_relative_call(uint32_t(ff8_externals.pause_menu_with_vibration), 0xA9);
297: 	ff8_externals.get_keyon = (int(*)(int, int))get_relative_call(uint32_t(ff8_externals.pause_menu_with_vibration), 0xC9);
298: 	ff8_externals.get_vibration_capability = get_relative_call(uint32_t(ff8_externals.pause_menu_with_vibration), 0xE3);
299: 	ff8_externals.vibrate_data_main = (uint8_t **)get_absolute_value(uint32_t(ff8_externals.pause_menu_with_vibration), 0x261);
300: 	ff8_externals.set_vibration = get_relative_call(uint32_t(ff8_externals.pause_menu_with_vibration), 0x26A);
301: 	ff8_externals.gamepad_states = (ff8_gamepad_state *)(get_absolute_value(ff8_externals.get_vibration_capability, 0xE + 3) - 0xB);
302: 	ff8_externals.vibration_objects = (ff8_vibrate_struc *)get_absolute_value(ff8_externals.set_vibration, 0x2 + 1);
303: 	ff8_externals.vibration_clear_intensity = get_relative_call(ff8_externals.sub_471F70, 0x276);
304: 	ff8_externals.open_battle_vibrate_vib = get_relative_call(ff8_externals.pubintro_exit, 0x18);
305: 	ff8_externals.vibrate_data_battle = (uint8_t **)get_absolute_value(ff8_externals.open_battle_vibrate_vib, 0x6);
306: 
307: 	common_externals.get_movie_frame = get_relative_call(common_externals.update_field_entities, 0x26);
308: 
309: 	common_externals.execute_opcode_table = (uint32_t*)get_absolute_value(common_externals.update_field_entities, 0x65A);
310: 	ff8_externals.opcode_pshm_w = common_externals.execute_opcode_table[0x0C];
311: 	ff8_externals.opcode_popm_b = (int(*)(void*, int))common_externals.execute_opcode_table[0x0B];
312: 	ff8_externals.opcode_popm_w = (int(*)(void*, int))common_externals.execute_opcode_table[0x0D];
313: 	ff8_externals.opcode_effectplay2 = common_externals.execute_opcode_table[0x21];
314: 	ff8_externals.opcode_mapjump = common_externals.execute_opcode_table[0x29];
315: 	ff8_externals.opcode_mes = common_externals.execute_opcode_table[0x47];
316: 	ff8_externals.opcode_messync = common_externals.execute_opcode_table[0x48];
317: 	ff8_externals.opcode_ask = common_externals.execute_opcode_table[0x4A];
318: 	ff8_externals.opcode_winclose = common_externals.execute_opcode_table[0x4C];
319: 	ff8_externals.opcode_movie = common_externals.execute_opcode_table[0x4F];
320: 	ff8_externals.opcode_moviesync = common_externals.execute_opcode_table[0x50];
321: 	ff8_externals.opcode_spuready = common_externals.execute_opcode_table[0x56];
322: 	ff8_externals.opcode_amesw = common_externals.execute_opcode_table[0x64];
323: 	ff8_externals.opcode_ames = common_externals.execute_opcode_table[0x65];
324: 	ff8_externals.opcode_battle = common_externals.execute_opcode_table[0x69];
325: 	ff8_externals.opcode_aask = common_externals.execute_opcode_table[0x6F];
326: 	ff8_externals.opcode_setvibrate = common_externals.execute_opcode_table[0xA1];
327: 	ff8_externals.opcode_movieready = common_externals.execute_opcode_table[0xA3];
328: 	ff8_externals.opcode_musicload = common_externals.execute_opcode_table[0xB5];
329: 	ff8_externals.opcode_crossmusic = common_externals.execute_opcode_table[0xBA];
330: 	ff8_externals.opcode_dualmusic = common_externals.execute_opcode_table[0xBB];
331: 	ff8_externals.opcode_musicvoltrans = common_externals.execute_opcode_table[0xC1];
332: 	ff8_externals.opcode_musicvolfade = common_externals.execute_opcode_table[0xC2];
333: 	ff8_externals.opcode_mesmode = common_externals.execute_opcode_table[0x106];
334: 	ff8_externals.opcode_ramesw = common_externals.execute_opcode_table[0x116];
335: 	ff8_externals.opcode_menuname = common_externals.execute_opcode_table[0x129];
336: 	ff8_externals.opcode_choicemusic = common_externals.execute_opcode_table[0x135];
337: 	ff8_externals.opcode_drawpoint = common_externals.execute_opcode_table[0x137];
338: 	ff8_externals.opcode_cardgame = (int(*)(int))common_externals.execute_opcode_table[0x13A];
339: 	ff8_externals.opcode_musicskip = common_externals.execute_opcode_table[0x144];
340: 	ff8_externals.opcode_musicvolsync = common_externals.execute_opcode_table[0x149];
341: 	ff8_externals.opcode_getmusicoffset = common_externals.execute_opcode_table[0x16F];
342: 	ff8_externals.opcode_tuto = common_externals.execute_opcode_table[0x177];
343: 	ff8_externals.opcode_addgil = (int(*)(void*))common_externals.execute_opcode_table[0x151];
344: 	ff8_externals.opcode_addseedlevel = (int(*)(void*))common_externals.execute_opcode_table[0x153];
345: 
346: 	ff8_externals.cardgame_deck_id_1DCD7AD = (uint8_t*)get_absolute_value((uint32_t)ff8_externals.opcode_cardgame, 0xAE);
347: 	ff8_externals.vibrate_data_field = (uint8_t*)get_absolute_value(ff8_externals.opcode_setvibrate, 0x27);
348: 	ff8_externals.current_tutorial_id = (BYTE*)get_absolute_value(ff8_externals.opcode_tuto, 0x2A);
349: 
350: 	common_externals.cross_fade_midi = get_relative_call(ff8_externals.opcode_crossmusic, 0x5C);
351: 	ff8_externals.music_load = get_relative_call(ff8_externals.opcode_musicload, 0x8C);
352: 
353: 	common_externals.prepare_movie = get_relative_call(ff8_externals.opcode_movieready, 0x99);
354: 	common_externals.release_movie_objects = get_relative_call(common_externals.prepare_movie, 0x19E);
355: 	common_externals.start_movie = get_relative_call(ff8_externals.opcode_movie, 0xC3);
356: 	common_externals.update_movie_sample = get_relative_call(common_externals.start_movie, 0x74);
357: 	ff8_externals.draw_movie_frame = get_relative_call(ff8_externals.opcode_moviesync, 0x1C);
358: 	common_externals.stop_movie = get_relative_call(common_externals.update_movie_sample, 0x3E2);
359: 	ff8_externals.movie_object = (ff8_movie_obj *)get_absolute_value(common_externals.prepare_movie, 0xDB);
360: 
361: 	ff8_externals.opcode_drawpoint_sub_4A0850 = (int(*)(int, int))get_relative_call(ff8_externals.opcode_drawpoint, 0x6B7);
362: 	ff8_externals.drawpoint_messages = get_absolute_value(ff8_externals.opcode_drawpoint, 0xD6);
363: 	ff8_externals.enable_gf_sub_47E480 = get_relative_call(common_externals.execute_opcode_table[0x129], 0x6E);
364: 
365: 	common_externals.debug_print = get_relative_call(common_externals.update_movie_sample, 0x141);
366: 
367: 	ff8_externals._load_texture = get_relative_call(ff8_externals.load_fonts, JP_VERSION ? 0x31B : 0x197);
368: 	ff8_externals.sub_4076B6 = get_relative_call(ff8_externals._load_texture, 0x16D);
369: 	ff8_externals.sub_41AC34 = get_relative_call(ff8_externals.sub_4076B6, 0x46);
370: 	ff8_externals.load_texture_data = get_relative_call(ff8_externals.sub_41AC34, 0x168);
371: 	common_externals.load_tex_file = get_relative_call(ff8_externals.load_texture_data, 0x103);
372: 	common_externals.create_tex_header = (tex_header* (*)())get_relative_call(common_externals.load_tex_file, 0xD);
373: 	common_externals.assert_calloc = (void* (*)(uint32_t, uint32_t, const char*, uint32_t))get_relative_call((uint32_t)common_externals.create_tex_header, 0x15);
374: 	common_externals.open_file = get_relative_call(common_externals.load_tex_file, 0x27);
375: 	common_externals.read_file = get_relative_call(common_externals.load_tex_file, 0x49);
376: 	common_externals.alloc_read_file = (void* (*)(uint32_t, uint32_t, struct file *))get_relative_call(common_externals.load_tex_file, 0xB3);
377: 	common_externals.close_file = get_relative_call(common_externals.load_tex_file, 0x15B);
378: 	common_externals.destroy_tex = (void (*)(tex_header*))get_relative_call(common_externals.load_tex_file, 0x16D);
379: 	common_externals.destroy_tex_header = get_relative_call((uint32_t)common_externals.destroy_tex, 0x78);
380: 	common_externals.assert_free = (void* (*)(void*, const char*, uint32_t))get_relative_call(common_externals.destroy_tex_header, 0x21);
381: 	common_externals.get_game_object = (game_obj* (*)())get_relative_call((uint32_t)common_externals.destroy_tex, 0x6);
382: 
383: 	ff8_externals.fs_archive_search_filename = (int(*)(const char *, ff8_file_fi_infos *, const ff8_file_container *))get_relative_call(common_externals.open_file, 0x28D);
384: 	ff8_externals.ff8_fs_archive_search_filename2 = (int(*)(const char *, ff8_file_fi_infos *, const ff8_file_container *))get_relative_call(uint32_t(ff8_externals.fs_archive_search_filename), 0x10);
385: 	ff8_externals.fs_archive_get_fl_filepath = (char *(*)(int, const ff8_file_fl *))get_relative_call(uint32_t(ff8_externals.ff8_fs_archive_search_filename2), 0x40);
386: 	ff8_externals._open = get_relative_call(common_externals.open_file, 0x2CE);
387: 	ff8_externals._sopen = (int(*)(const char*, int, int, ...))get_relative_call(ff8_externals._open, 0xE);
388: 	ff8_externals.fopen = get_relative_call(ff8_externals.ff8input_cfg_read, 0x33);
389: 	ff8_externals._fsopen = (FILE *(*)(const char*, const char*, int))get_relative_call(ff8_externals.fopen, 0xA);
390: 	ff8_externals.strcpy_with_malloc = (char*(*)(const char*))get_relative_call(common_externals.open_file, 0x2F2);
391: 
392: 	ff8_externals.dd_d3d_start = get_relative_call(ff8_externals.pubintro_init, 0x75);
393: 	ff8_externals.create_d3d_gfx_driver = get_relative_call(ff8_externals.dd_d3d_start, 0x88);
394: 	ff8_externals.d3d_init = get_absolute_value(ff8_externals.create_d3d_gfx_driver, 0x1B);
395: 	ff8_externals.sub_40BFEB = get_absolute_value(ff8_externals.d3d_init, 0x1370);
396: 	common_externals.create_texture_format = (struct texture_format* (*)())get_relative_call(ff8_externals.sub_40BFEB, 0x2B);
397: 
398: 	ff8_externals.tim2tex = get_relative_call(ff8_externals.sub_41AC34, 0xFC);
399: 	ff8_externals.sub_41BC76 = get_relative_call(ff8_externals.tim2tex, 0x72);
400: 	common_externals.make_pixelformat = (void (*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, struct texture_format*))get_relative_call(ff8_externals.sub_41BC76, 0x102);
401: 
402: 	common_externals.add_texture_format = (void (*)(struct texture_format*, game_obj*))get_relative_call(ff8_externals.sub_40BFEB, 0xBF);
403: 
404: 	ff8_externals.d3d_load_texture = get_absolute_value(ff8_externals.create_d3d_gfx_driver, 0x9D);
405: 	common_externals.create_texture_set = (texture_set* (*)())get_relative_call(ff8_externals.d3d_load_texture, 0x6B);
406: 
407: 	common_externals.create_palette_for_tex = (palette* (*)(uint32_t, tex_header*, texture_set*))get_relative_call(ff8_externals.d3d_load_texture, 0x316);
408: 
409: 	ff8_externals.movie_hack1 = common_externals.update_movie_sample + 0xA5;
410: 	ff8_externals.movie_hack2 = common_externals.update_movie_sample + 0x1DF;
411: 
412: 	ff8_externals.sub_559910 = get_relative_call(ff8_externals.swirl_main_loop, 0x1A);
413: 
414: 	ff8_externals.swirl_sub_56D1D0 = get_relative_call(ff8_externals.battle_main_loop, 0x285);
415: 	ff8_externals.swirl_sub_56D390 = get_relative_call(ff8_externals.swirl_sub_56D1D0, 0x2A);
416: 	ff8_externals.swirl_texture1 = (ff8_graphics_object **)get_absolute_value(ff8_externals.swirl_sub_56D1D0, 0x1);
417: 
418: 	ff8_externals.sub_45D610 = get_relative_call(ff8_externals.sub_52FE80, 0x90);
419: 	ff8_externals.sub_45D080 = get_relative_call(ff8_externals.sub_45D610, 0x5);
420: 	ff8_externals.sub_464BD0 = get_relative_call(ff8_externals.sub_45D080, 0x208);
421: 	ff8_externals.sub_4653B0 = get_relative_call(ff8_externals.sub_464BD0, 0x79);
422: 	ff8_externals.sub_465720 = get_relative_call(ff8_externals.sub_464BD0, 0xAF);
423: 
424: 	ff8_externals.ssigpu_callbacks_1 = (uint32_t *)get_absolute_value(ff8_externals.sub_45D080, 0x21E);
425: 	ff8_externals.ssigpu_callbacks_2 = (uint32_t *)get_absolute_value(ff8_externals.sub_45D080, 0x122);
426: 	ff8_externals.sub_461E00 = ff8_externals.ssigpu_callbacks_1[52];
427: 	ff8_externals.sub_461220 = get_relative_call(ff8_externals.sub_461E00, 0x50);
428: 	ff8_externals.dword_1CA8848 = get_absolute_value(ff8_externals.sub_461E00, 0x56);
429: 	ff8_externals.sub_462AD0 = get_relative_call(ff8_externals.ssigpu_callbacks_1[116], 0x13);
430: 	ff8_externals.sub_462DF0 = get_relative_call(ff8_externals.sub_462AD0, 0x62);
431: 	ff8_externals.ssigpu_tx_select_2_sub_465CE0 = get_relative_call(ff8_externals.sub_462DF0, 0x33);
432: 	ff8_externals.sub_464F70 = (int(*)(struc_50*,texture_page*,int,int,int,int,int,int,int,uint8_t*))get_relative_call(ff8_externals.ssigpu_tx_select_2_sub_465CE0, 0x281);
433: 	ff8_externals.read_vram_1 = (void(*)(uint8_t*,int,uint8_t*,int,signed int,int,int))get_relative_call(uint32_t(ff8_externals.sub_464F70), 0x2C5);
434: 	ff8_externals.sub_464DB0 = get_relative_call(ff8_externals.ssigpu_tx_select_2_sub_465CE0, 0x2CF);
435: 	ff8_externals.write_palette_texture_set_sub_466190 = get_relative_call(ff8_externals.ssigpu_tx_select_2_sub_465CE0, 0x315);
436: 	ff8_externals.read_vram_palette_sub_467370 = get_relative_call(ff8_externals.write_palette_texture_set_sub_466190, 0x2C);
437: 	ff8_externals.write_palette_to_driver_sub_467310 = get_relative_call(ff8_externals.write_palette_texture_set_sub_466190, 0x7E);
438: 	ff8_externals.read_vram_2_paletted = (void(*)(uint8_t*,int,uint8_t*,int,signed int,int,int,uint16_t*))get_relative_call(ff8_externals.sub_464DB0, 0xEC);
439: 	ff8_externals.sub_4649A0 = get_relative_call(ff8_externals.ssigpu_callbacks_2[100], 0x33);
440: 	ff8_externals.read_vram_3_paletted = (void(*)(uint8_t*,uint8_t*,signed int,int,int,uint16_t*))get_relative_call(ff8_externals.sub_4649A0, 0x13F);
441: 
442: 	ff8_externals.sub_559E40 = get_relative_call(ff8_externals.swirl_main_loop, 0x28);
443: 	ff8_externals.sub_559F30 = get_relative_call(ff8_externals.sub_559E40, 0xC1);
444: 
445: 	if(NV_VERSION)
446: 	{
447: 		ff8_externals.nvidia_hack1 = get_absolute_value(ff8_externals.sub_559F30, 0x3E);
448: 		ff8_externals.nvidia_hack2 = get_absolute_value(ff8_externals.sub_559F30, 0xAC);
449: 	}
450: 
451: 	ff8_externals.sprite_viewport = (sprite_viewport *)get_absolute_value(ff8_externals.sub_4972A0, 0xB);
452: 	ff8_externals.menu_viewport = (sprite_viewport*)get_absolute_value(ff8_externals.engine_reset_viewport_sub_4972D0, 0xB);
453: 
454: 	ff8_externals.sub_497380 = get_relative_call(ff8_externals.main_menu_main_loop, 0xAA);
455: 	ff8_externals.sub_4B3410 = get_relative_call(ff8_externals.sub_497380, 0xAC);
456: 	ff8_externals.sub_4B3310 = get_relative_call(ff8_externals.sub_497380, 0xD3);
457: 	ff8_externals.sub_4B3140 = get_relative_call(ff8_externals.sub_4B3310, 0xC8);
458: 	ff8_externals.sub_4BDB30 = get_relative_call(ff8_externals.sub_4B3140, 0x4);
459: 	ff8_externals.menu_callbacks = (ff8_menu_callback *)get_absolute_value(ff8_externals.sub_4BDB30, 0x11);
460: 	ff8_externals.menu_use_items_sub_4F81F0 = (char(*)(int))get_absolute_value(uint32_t(ff8_externals.menu_callbacks[2].func), 0x8);
461: 	ff8_externals.menu_cards_render = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[7].func), 0x5);
462: 	ff8_externals.sub_534AD0 = get_relative_call(ff8_externals.menu_cards_render, 0x76);
463: 	ff8_externals.card_texts_off_B96504 = (uint8_t **)get_absolute_value(ff8_externals.sub_534AD0, 0xB1);
464: 	ff8_externals.sub_4EFC00 = get_relative_call(ff8_externals.menu_cards_render, 0x2B6);
465: 	ff8_externals.sub_4EFCD0 = get_absolute_value(ff8_externals.sub_4EFC00, 0xB0);
466: 	ff8_externals.menu_config_render = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[8].func), 0x3);
467: 	ff8_externals.menu_config_render_submenu = get_relative_call(ff8_externals.menu_config_render, 0x101);
468: 	ff8_externals.menu_config_controller = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[8].func), 0x8);
469: 	ff8_externals.menu_config_input_desc = (ff8_menu_config_input *)get_absolute_value(uint32_t(ff8_externals.menu_callbacks[8].func), 0x39);
470: 	ff8_externals.menu_config_input_desc_keymap = (ff8_menu_config_input_keymap *)get_absolute_value(uint32_t(ff8_externals.menu_callbacks[8].func), 0x110);
471: 	ff8_externals.menu_shop_sub_4EBE40 = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[11].func), 0x39);
472: 	ff8_externals.menu_junkshop_sub_4EA890 = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[12].func), 0x10);
473: 	ff8_externals.main_menu_render_sub_4E5550 = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[16].func), 0x3);
474: 	ff8_externals.main_menu_controller = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[16].func), 0x8);
475: 	ff8_externals.sub_4C2FF0 = get_relative_call(uint32_t(ff8_externals.menu_callbacks[16].func), 0x2B);
476: 	ff8_externals.menu_sub_4D4D30 = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[23].func), 0x8);
477: 	ff8_externals.menu_chocobo_world_controller = get_absolute_value(uint32_t(ff8_externals.menu_callbacks[27].func), 0xB);
478: 	ff8_externals.create_save_file_sub_4C6E50 = get_relative_call(ff8_externals.main_menu_controller, JP_VERSION ? 0x1004 : 0xF8D);
479: 	ff8_externals.create_save_chocobo_world_file_sub_4C6620 = get_relative_call(ff8_externals.menu_chocobo_world_controller, 0x9F6);
480: 	ff8_externals.add_item_to_player_sub_47ED00 = (int(*)(int, char))get_relative_call(ff8_externals.menu_chocobo_world_controller, JP_VERSION ? 0x17FE : 0x1814);
481: 	ff8_externals.menu_chocobo_sub_4FF8F0 = (void(*)())get_relative_call(ff8_externals.menu_chocobo_world_controller, JP_VERSION ? 0x13BA : 0x13D0);
482: 	ff8_externals.update_seed_exp_4C30E0 = (void(*)(int))get_relative_call(ff8_externals.menu_sub_4D4D30, JP_VERSION ? 0x929 : 0x928);
483: 	ff8_externals.menu_shop_update_gil_and_items_4EB9F0 = (void(*)(int))get_relative_call(ff8_externals.menu_shop_sub_4EBE40, 0x4E4);
484: 	ff8_externals.sub_4ABC40 = (int(*)(int,int))get_relative_call(ff8_externals.menu_junkshop_sub_4EA890, JP_VERSION ? 0x5F0 : 0x5C1);
485: 	ff8_externals.sub_4EA770 = (int(*)(int,uint32_t))get_relative_call(ff8_externals.menu_junkshop_sub_4EA890, JP_VERSION ? 0x63A : 0x60B);
486: 	ff8_externals.get_text_data = get_relative_call(ff8_externals.main_menu_render_sub_4E5550, 0x203);
487: 	ff8_externals.sub_4BE4D0 = get_relative_call(ff8_externals.sub_4B3410, 0x68);
488: 	ff8_externals.sub_4BECC0 = get_relative_call(ff8_externals.sub_4BE4D0, 0x39);
489: 	ff8_externals.menu_draw_text = get_relative_call(ff8_externals.sub_4BECC0, 0x127);
490: 	ff8_externals.get_character_width = (uint32_t (*)(uint32_t))get_relative_call(ff8_externals.menu_draw_text, JP_VERSION ? 0x1E1 : 0x1D0);
491: 	ff8_externals.ff8input_cfg_reset = get_relative_call(ff8_externals.menu_config_controller, 0x185);
492: 	ff8_externals.menu_data_1D76A9C = (uint32_t*)get_absolute_value(ff8_externals.menu_shop_sub_4EBE40, 0xE);
493: 	ff8_externals.menu_shop_staged_items_1D8D058 = std::span((uint8_t*)get_absolute_value(ff8_externals.menu_shop_sub_4EBE40, 0x1C3), 200);
494: 
495: 	ff8_externals.open_lzs_image = get_relative_call(ff8_externals.load_credits_image, 0x27);
496: 	ff8_externals.credits_open_file = (uint32_t (*)(char*,char*))get_relative_call(ff8_externals.open_lzs_image, 0x72);
497: 	ff8_externals.upload_psx_vram = get_relative_call(ff8_externals.open_lzs_image, 0xB9);
498: 	ff8_externals.psxvram_buffer = (uint8_t *)get_absolute_value(ff8_externals.upload_psx_vram, 0x34);
499: 	ff8_externals.sub_464850 = (void (*)(uint32_t, uint32_t, uint32_t, uint32_t))get_relative_call(ff8_externals.upload_psx_vram, 0x8A);
500: 
501: 	ff8_externals.psx_texture_pages = (struc_51 *)get_absolute_value(ff8_externals.sub_464BD0, 0x10);
502: 
503: 	ff8_externals.read_field_data = get_relative_call(ff8_externals.sub_471F70, 0x23A);
504: 	ff8_externals.upload_mim_file = get_relative_call(ff8_externals.read_field_data, JP_VERSION ? 0x723 : 0x729);
505: 	ff8_externals.upload_pmp_file = get_relative_call(ff8_externals.read_field_data, JP_VERSION ? 0x80C : 0x812);
506: 	ff8_externals.field_filename = (char *)get_absolute_value(ff8_externals.read_field_data, 0xF0);
507: 
508: 	ff8_externals.field_scripts_init = (int(*)(int,int,int,int))(get_relative_call(ff8_externals.read_field_data, JP_VERSION ? 0xEDC : 0xE49));
509: 	ff8_externals.field_state_background_count = (uint8_t *)get_absolute_value(uint32_t(ff8_externals.field_scripts_init), 0x2CD + 0x1);
510: 	ff8_externals.field_state_backgrounds = (ff8_field_state_background **)get_absolute_value(uint32_t(ff8_externals.field_scripts_init), 0x50B + 0x2);
511: 	ff8_externals.load_field_models = get_relative_call(ff8_externals.read_field_data, JP_VERSION ? 0xFA2 : 0xF0F);
512: 	ff8_externals.chara_one_read_file = get_relative_call(ff8_externals.load_field_models, 0x15F);
513: 	ff8_externals.chara_one_seek_file = get_relative_call(ff8_externals.load_field_models, 0x582);
514: 	ff8_externals.chara_one_set_data_start = get_relative_call(ff8_externals.load_field_models, 0xAFF);
515: 	ff8_externals.chara_one_data_start = (uint8_t **)get_absolute_value(ff8_externals.chara_one_set_data_start, 0x5);
516: 	ff8_externals.chara_one_upload_texture = get_relative_call(ff8_externals.load_field_models, 0xB72);
517: 
518: 	ff8_externals.worldmap_sub_53F310 = get_relative_call(ff8_externals.worldmap_enter_main, 0xA7);
519: 
520: 	ff8_externals.engine_eval_process_input = get_relative_call(ff8_externals.pubintro_main_loop, 0x4);
521: 	ff8_externals.engine_eval_keyboard_gamepad_input = (void (*)())get_relative_call(ff8_externals.engine_eval_process_input, 0x16);
522: 	ff8_externals.has_keyboard_gamepad_input = (void (*)())get_relative_call(ff8_externals.engine_eval_process_input, 0x1B);
523: 	ff8_externals.engine_eval_is_button_pressed = get_relative_call((uint32_t)ff8_externals.engine_eval_keyboard_gamepad_input, 0x4A6);
524: 	ff8_externals.engine_input_confirmed_buttons = (uint32_t*)get_absolute_value(ff8_externals.engine_eval_is_button_pressed, 0x62);
525: 	ff8_externals.engine_input_valid_buttons = (uint32_t*)get_absolute_value(ff8_externals.engine_eval_is_button_pressed, 0x3C);
526: 	ff8_externals.engine_gamepad_button_pressed = (BYTE*)get_absolute_value((uint32_t)ff8_externals.has_keyboard_gamepad_input, 0x22);
527: 	ff8_externals.engine_mapped_buttons = (DWORD*)get_absolute_value((uint32_t)ff8_externals.engine_eval_keyboard_gamepad_input, 0xB9);
528: 
529: 	common_externals.get_keyboard_state = get_relative_call((uint32_t)ff8_externals.engine_eval_keyboard_gamepad_input, 0x11);
530: 	ff8_externals.dinput_init_gamepad = get_relative_call(ff8_externals.sub_468810, 0xB4);
531: 	ff8_externals.dinput_update_gamepad_status = get_relative_call((uint32_t)ff8_externals.engine_eval_keyboard_gamepad_input, 0x1B);
532: 	ff8_externals.dinput_gamepad_device = (LPDIRECTINPUTDEVICE8A)get_absolute_value(ff8_externals.dinput_update_gamepad_status, 0x16);
533: 	ff8_externals.dinput_gamepad_state = (LPDIJOYSTATE2)get_absolute_value(ff8_externals.dinput_update_gamepad_status, 0x1B);
534: 
535: 	common_externals.dinput_acquire_keyboard = (int (*)())get_relative_call(common_externals.get_keyboard_state, 0x34);
536: 	common_externals.keyboard_device = (IDirectInputDeviceA**)get_absolute_value(common_externals.get_keyboard_state, 0x01);
537: 	common_externals.keyboard_connected = (uint32_t*)get_absolute_value(common_externals.get_keyboard_state, 0x2C);
538: 
539: 	common_externals.sfx_init = get_relative_call(ff8_externals.pubintro_init, 0xD8); // sub_469640
540: 	common_externals.directsound_create = get_relative_call(common_externals.sfx_init, 0x5D); // sub_46DBF0
541: 	common_externals.directsound = (LPLPDIRECTSOUND)get_absolute_value(common_externals.directsound_create, 0x26);
542: 	common_externals.directsound_release = get_relative_call(common_externals.sfx_init, 0xD5);
543: 
544: 	common_externals.midi_init = get_relative_call(ff8_externals.pubintro_init, 0x130);
545: 	ff8_externals.music_path = (char*)get_absolute_value(ff8_externals.pubintro_init, 0x136);
546: 	common_externals.midi_cleanup = get_relative_call(ff8_externals.pubintro_cleanup, 0x44);
547: 	common_externals.sfx_cleanup = get_relative_call(ff8_externals.pubintro_cleanup, 0x49);
548: 	common_externals.wav_cleanup = get_relative_call(common_externals.sfx_cleanup, 0x0);
549: 	ff8_externals.volume_update = get_relative_call(ff8_externals.field_main_loop, 0x28C);
550: 	ff8_externals.volume_music_update = get_relative_call(ff8_externals.volume_update, 0x6);
551: 
552: 	ff8_externals.outputdebugstringa = get_absolute_value(ff8_externals.sm_battle_sound, 0x1B);
553: 	ff8_externals.sdmusicplay = get_relative_call(ff8_externals.sm_battle_sound, 0x164);
554: 	ff8_externals.sd_music_play = (uint32_t(*)(uint32_t, char*, uint32_t))get_relative_call(ff8_externals.sdmusicplay, 0x17);
555: 	ff8_externals.current_music_ids = (uint32_t*)get_absolute_value(uint32_t(ff8_externals.sd_music_play), 0x1AA);
556: 	ff8_externals.play_wav = get_relative_call(uint32_t(ff8_externals.sd_music_play), 0x1DC);
557: 	common_externals.play_wav = get_relative_call(ff8_externals.play_wav, 0x73);
558: 
559: 	common_externals.play_midi = get_relative_call(uint32_t(ff8_externals.sd_music_play), 0x20C);
560: 
561: 	ff8_externals.dmusic_segment_connect_to_dls = get_relative_call(common_externals.play_midi, 0x247);
562: 	ff8_externals.load_midi_segment = get_relative_call(common_externals.midi_init, 0xC8);
563: 	ff8_externals.choice_music = get_relative_call(ff8_externals.opcode_choicemusic, 0x5D);
564: 	ff8_externals.sd_music_play_at = get_relative_call(ff8_externals.opcode_musicskip, 0x46);
565: 	ff8_externals.load_and_play_midi_segment = get_relative_call(ff8_externals.choice_music, 0x99);
566: 	ff8_externals.load_midi_segment_from_id = get_relative_call(ff8_externals.choice_music, 0xD0);
567: 	ff8_externals.stop_midi_segments = get_relative_call(ff8_externals.load_and_play_midi_segment, 0xB);
568: 	ff8_externals.play_midi_segments = get_relative_call(ff8_externals.choice_music, 0x172);
569: 
570: 	common_externals.get_midi_name = (char* (*)(uint32_t))get_relative_call(common_externals.play_midi, 0x21C);
571: 
572: 	ff8_externals.sub_46B800 = get_relative_call(ff8_externals.sm_battle_sound, 0x52);
573: 	ff8_externals.stop_music = get_relative_call(ff8_externals.sub_46B800, 0xB);
574: 	common_externals.set_midi_volume_trans = get_relative_call(ff8_externals.opcode_musicvoltrans, 0x49); // Formally music_volume_trans
575: 	common_externals.set_midi_volume_fade = get_relative_call(ff8_externals.opcode_musicvolfade, 0x59); // Formally music_volume_fade
576: 	ff8_externals.dmusicperf_set_volume_sub_46C6F0 = (BOOL (*)(uint32_t, int32_t))get_relative_call(ff8_externals.stop_music, 0x22);
577: 	common_externals.set_midi_volume = get_relative_call(ff8_externals.sm_battle_sound, 0x173); // Formally set_music_volume
578: 	common_externals.master_midi_volume = (DWORD*)get_absolute_value(uint32_t(ff8_externals.dmusicperf_set_volume_sub_46C6F0), 0x24);
579: 	common_externals.stop_wav = get_relative_call(ff8_externals.stop_music, 0x14);
580: 	common_externals.stop_midi = get_relative_call(ff8_externals.stop_music, 0x2A);
581: 
582: 	ff8_externals.sub_46C050 = get_relative_call(ff8_externals.sm_battle_sound, 0x5C);
583: 	common_externals.remember_midi_playing_time = get_relative_call(ff8_externals.sub_46C050, 0x00);
584: 
585: 	common_externals.midi_status = get_relative_call(ff8_externals.sm_battle_sound, 0x14);
586: 
587: 	ff8_externals.load_cdrom = (uint32_t(*)())get_relative_call(ff8_externals.opcode_spuready, 0x4B);
588: 	ff8_externals.load_cdrom_call = ff8_externals.opcode_spuready + 0x4B;
589: 	ff8_externals.play_cdrom = (uint32_t(*)(uint32_t, uint32_t, uint32_t))get_relative_call(ff8_externals.opcode_spuready, 0x60);
590: 	ff8_externals.play_cdrom_call = ff8_externals.opcode_spuready + 0x60;
591: 	ff8_externals.stop_cdrom_cleanup_call = ff8_externals.pubintro_init + 0x183;
592: 
593: 	// Pause/Resume functions
594: 	ff8_externals.sub_501B60 = get_relative_call(ff8_externals.battle_load_textures_sub_500900, -0x2A2);
595: 	ff8_externals.pause_music_and_sfx = get_relative_call(ff8_externals.sub_501B60, 0x54);
596: 	common_externals.pause_wav = get_relative_call(ff8_externals.pause_music_and_sfx, 0xF);
597: 	common_externals.pause_midi = get_relative_call(ff8_externals.pause_music_and_sfx, 0x17);
598: 	ff8_externals.restart_music_and_sfx = get_relative_call(ff8_externals.sub_501B60, 0xB3);
599: 	common_externals.restart_wav = get_relative_call(ff8_externals.restart_music_and_sfx, 0xF);
600: 	common_externals.restart_midi = get_relative_call(ff8_externals.restart_music_and_sfx, 0x17);
601: 
602: 	// SFX
603: 	ff8_externals.sfx_play_to_current_playing_channel = get_relative_call(ff8_externals.opcode_effectplay2, 0x5F);
604: 	common_externals.play_sfx_on_channel = get_relative_call(ff8_externals.sfx_play_to_current_playing_channel, 0x35);
605: 	common_externals.sfx_load = get_relative_call(common_externals.play_sfx_on_channel, 0x89);
606: 	ff8_externals.sfx_unload_all = get_relative_call(common_externals.sfx_cleanup, 0x5);
607: 	common_externals.sfx_unload = get_relative_call(ff8_externals.sfx_unload_all, 0x4);
608: 	ff8_externals.sfx_pause_all = get_relative_call(ff8_externals.pause_music_and_sfx, 0x1C);
609: 	common_externals.sfx_pause = get_relative_call(ff8_externals.sfx_pause_all, 0x1B);
610: 	ff8_externals.sfx_resume_all = get_relative_call(ff8_externals.restart_music_and_sfx, 0x1C);
611: 	common_externals.sfx_resume = get_relative_call(ff8_externals.sfx_resume_all, 0x1B);
612: 	ff8_externals.sfx_stop_all2 = get_relative_call(ff8_externals.sm_battle_sound, 0x18C);
613: 	ff8_externals.sfx_stop_all = get_relative_call(ff8_externals.sfx_stop_all2, 0x0);
614: 	common_externals.sfx_stop = get_relative_call(ff8_externals.sfx_stop_all, 0x1B);
615: 	ff8_externals.sfx_set_volume = get_relative_call(common_externals.play_sfx_on_channel, 0xA1);
616: 	ff8_externals.sfx_get_master_volume = (int(*)())(ff8_externals.sfx_set_volume - 0x10);
617: 	ff8_externals.sfx_set_master_volume = (void(*)(uint32_t))(uint32_t(ff8_externals.sfx_get_master_volume) - 0xE0);
618: 	common_externals.master_sfx_volume = (uint32_t *)get_absolute_value(uint32_t(ff8_externals.sfx_get_master_volume), 0x1);
619: 	ff8_externals.sfx_current_channel_is_playing = get_relative_call(ff8_externals.sfx_play_to_current_playing_channel, 0xB);
620: 	ff8_externals.sfx_is_playing = get_relative_call(ff8_externals.sfx_current_channel_is_playing - 0x88, 0x0);
621: 	ff8_externals.sfx_set_panning = get_relative_call(common_externals.play_sfx_on_channel, 0x115);
622: 	ff8_externals.sfx_audio_fmt = (ff8_audio_fmt **)get_absolute_value(common_externals.sfx_init, 0x21B);
623: 	ff8_externals.sfx_sound_count = (uint16_t *)get_absolute_value(common_externals.sfx_init, 0x22C);
624: 
625: 	// Search DirectSoundBuffer initialization
626: 	ff8_externals.directsound_create_secondary_buffer = get_relative_call(common_externals.sfx_load, 0x22A);
627: 	common_externals.directsound_buffer_flags_1 = ff8_externals.directsound_create_secondary_buffer + 0x34 - 2;
628: 
629: 	ff8_externals.sub_5304B0 = (int (*)())get_relative_call(common_externals.update_movie_sample, 0x3D9);
630: 
631: 	ff8_externals.enable_framelimiter = (uint32_t *)get_absolute_value(common_externals.stop_movie, 0x49);
632: 
633: 	ff8_externals.byte_1CE4907 = (unsigned char *)get_absolute_value(common_externals.update_movie_sample, 0x363);
634: 	ff8_externals.byte_1CE4901 = (unsigned char *)get_absolute_value(common_externals.update_movie_sample, 0x37D);
635: 	ff8_externals.byte_1CE490D = (unsigned char *)get_absolute_value(common_externals.update_movie_sample, 0x3BE);
636: 
637: 	ff8_externals.sub_45B310 = get_relative_call(ff8_externals.pubintro_init, 0x91);
638: 	ff8_externals.sub_45B460 = get_relative_call(ff8_externals.sub_45B310, 0x0);
639: 	ff8_externals.ssigpu_init = get_relative_call(ff8_externals.sub_45B460, 0x26);
640: 	ff8_externals.sub_blending_capability = (uint32_t *)get_absolute_value(ff8_externals.sub_45B460, 0x19);
641: 	ff8_externals.loc_460BB0 = get_relative_call(ff8_externals.sub_45B460, 0x47);
642: 	ff8_externals.d3dcaps = (uint32_t *)get_absolute_value(ff8_externals.ssigpu_init, 0x6C);
643: 	ff8_externals.psx_floats1 = (float *)get_absolute_value(ff8_externals.loc_460BB0, 0x3);
644: 
645: 	if(FF8_US_VERSION)
646: 	{
647: 		ff8_externals.worldmap_sub_53F310_call_24D = ff8_externals.worldmap_sub_53F310 + 0x24D;
648: 		ff8_externals.worldmap_wmset_set_pointers_sub_542DA0 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x24D);
649: 		ff8_externals.worldmap_section17_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_wmset_set_pointers_sub_542DA0, 0x1ED);
650: 		ff8_externals.worldmap_section18_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_wmset_set_pointers_sub_542DA0, 0x20A);
651: 		ff8_externals.worldmap_section38_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x296);
652: 		ff8_externals.worldmap_section39_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x321);
653: 		ff8_externals.worldmap_section40_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x349);
654: 		ff8_externals.worldmap_section41_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x3B0);
655: 		ff8_externals.worldmap_section42_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x3BB);
656: 		ff8_externals.worldmap_prepare_tim_for_upload = (uint32_t(*)(uint8_t*,ff8_tim*))get_relative_call(ff8_externals.worldmap_sub_53F310, 0x2A9);
657: 		ff8_externals.worldmap_sub_548020 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x3C5);
658: 		ff8_externals.worldmap_sub_53F310_call_2A9 = ff8_externals.worldmap_sub_53F310 + 0x2A9;
659: 		ff8_externals.worldmap_sub_53F310_call_30D = ff8_externals.worldmap_sub_53F310 + 0x30D;
660: 		ff8_externals.worldmap_sub_53F310_call_330 = ff8_externals.worldmap_sub_53F310 + 0x330;
661: 		ff8_externals.worldmap_sub_53F310_call_366 = ff8_externals.worldmap_sub_53F310 + 0x366;
662: 		ff8_externals.worldmap_sub_53F310_call_3B5 = ff8_externals.worldmap_sub_53F310 + 0x3B5;
663: 		ff8_externals.worldmap_sub_554AA0 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x3B5);
664: 		ff8_externals.worldmap_sub_554AA0_call_C2 = ff8_externals.worldmap_sub_554AA0 + 0xC2;
665: 		ff8_externals.worldmap_sub_53F310_loc_53F7EE = ff8_externals.worldmap_sub_53F310 + 0x4DE;
666: 		ff8_externals.worldmap_sub_541970_upload_tim = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x330);
667: 		ff8_externals.worldmap_sub_545E20 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x60C);
668: 		ff8_externals.worldmap_chara_one = get_relative_call(ff8_externals.worldmap_sub_545E20, 0x68);
669: 		ff8_externals.worldmap_sub_5531F0 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x614);
670: 		ff8_externals.worldmap_alter_uv_sub_553B40 = get_relative_call(ff8_externals.worldmap_sub_5531F0, 0x25C);
671: 		ff8_externals.open_file_world = (int32_t(*)(const char*, int32_t, uint32_t, void *))get_relative_call(ff8_externals.worldmap_sub_5531F0, 0x395);
672: 		ff8_externals.open_file_world_sub_52D670_texl_call1 = ff8_externals.worldmap_sub_5531F0 + 0x395;
673: 		ff8_externals.open_file_world_sub_52D670_texl_call2 = ff8_externals.worldmap_sub_5531F0 + 0x69A;
674: 		ff8_externals.upload_psxvram_texl_pal_call1 = ff8_externals.worldmap_sub_5531F0 + 0x2F2;
675: 		ff8_externals.upload_psxvram_texl_pal_call2 = ff8_externals.worldmap_sub_5531F0 + 0x3F4;
676: 
677: 		ff8_externals.show_vram_window = (void (*)())get_relative_call(ff8_externals.worldmap_main_loop, 0xA0);
678: 		ff8_externals.refresh_vram_window = (void (*)())get_relative_call(ff8_externals.worldmap_main_loop, 0xA5);
679: 		ff8_externals.worldmap_with_fog_sub_53FAC0 = get_relative_call(ff8_externals.worldmap_main_loop, 0x134);
680: 		ff8_externals.worldmap_input_update_sub_559240 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x1E);
681: 		ff8_externals.sub_554940 = get_relative_call(ff8_externals.worldmap_input_update_sub_559240, 0x23D);
682: 		ff8_externals.sub_554940_call_130 = ff8_externals.sub_554940 + 0x130;
683: 		ff8_externals.sub_541AE0 = get_relative_call(ff8_externals.sub_554940, 0x130);
684: 		ff8_externals.sub_554BC0 = get_relative_call(ff8_externals.worldmap_input_update_sub_559240, 0x25B);
685: 		ff8_externals.sub_557140 = get_relative_call(ff8_externals.worldmap_input_update_sub_559240, 0x263);
686: 		ff8_externals.sub_54B460 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x5D7);
687: 
688: 		ff8_externals.sub_549E80 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x1D5);
689: 		ff8_externals.sub_550070 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x278);
690: 		ff8_externals.vibrate_data_world = (uint8_t *)get_absolute_value(ff8_externals.sub_550070, 0xA82);
691: 		ff8_externals.sub_53BB90 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x2D4);
692: 		ff8_externals.sub_53E2A0 = get_relative_call(ff8_externals.sub_53BB90, 0x327);
693: 		ff8_externals.sub_53E6B0 = get_relative_call(ff8_externals.sub_53E2A0, 0x36B);
694: 		ff8_externals.sub_4023D0 = get_relative_call(ff8_externals.sub_53BB90, 0xAB1);
695: 		ff8_externals.worldmap_fog_filter_polygons_in_block_1 = get_relative_call(ff8_externals.sub_53BB90, 0x42D);
696: 		ff8_externals.worldmap_has_polygon_condition_2045C90 = get_absolute_value(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x29);
697: 		ff8_externals.worldmap_polygon_condition_2045C8C = get_absolute_value(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x59);
698: 		ff8_externals.worldmap_sub_45DF20 = get_relative_call(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x1FC);
699: 		ff8_externals.sub_45E3A0 = get_relative_call(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x4A4);
700: 		ff8_externals.worldmap_fog_filter_polygons_in_block_2 = get_relative_call(ff8_externals.sub_53BB90, 0x442);
701: 		ff8_externals.sub_53C750 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x2DB);
702: 		ff8_externals.sub_54E9B0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x369);
703: 		ff8_externals.sub_54FDA0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x375);
704: 		ff8_externals.sub_54D7E0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x3C2);
705: 		ff8_externals.world_dialog_assign_text_sub_543790 = (int (*)(int,int,char*))get_relative_call(ff8_externals.sub_54D7E0, 0x72);
706: 		ff8_externals.world_dialog_question_assign_text_sub_5438D0 = (int (*)(int, int, char*, int, int, int, uint8_t))get_relative_call(ff8_externals.sub_54D7E0, 0x119);
707: 		ff8_externals.sub_544630 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x3D2);
708: 		ff8_externals.sub_545EA0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x4BF);
709: 		ff8_externals.sub_5484B0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x5C9);
710: 		ff8_externals.sub_54A230 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x5CF);
711: 		ff8_externals.sub_543CB0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0xA55);
712: 		ff8_externals.worldmap_update_steps_sub_6519D0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x8DB);
713: 		ff8_externals.set_drawpoint_state_521D90 = (void(*)(uint8_t, char))get_relative_call(ff8_externals.sub_54E9B0, 0x845);
714: 
715: 		ff8_externals.sub_545F10 = get_relative_call(ff8_externals.sub_545EA0, 0x20);
716: 
717: 		ff8_externals.sub_546100 = get_relative_call(ff8_externals.sub_545F10, 0x58);
718: 
719: 		ff8_externals.battle_trigger_worldmap = ff8_externals.worldmap_with_fog_sub_53FAC0 + 0x4E6;
720: 	}
721: 	else
722: 	{
723: 		ff8_externals.worldmap_sub_53F310_call_24D = ff8_externals.worldmap_sub_53F310 + 0x249;
724: 		ff8_externals.worldmap_wmset_set_pointers_sub_542DA0 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x249);
725: 		ff8_externals.worldmap_section17_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_wmset_set_pointers_sub_542DA0, 0x21C);
726: 		ff8_externals.worldmap_section18_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_wmset_set_pointers_sub_542DA0, 0x23C);
727: 		ff8_externals.worldmap_section38_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x292);
728: 		ff8_externals.worldmap_section39_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x33D);
729: 		ff8_externals.worldmap_section40_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x365);
730: 		ff8_externals.worldmap_section41_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x3D1);
731: 		ff8_externals.worldmap_section42_position = (uint32_t **)get_absolute_value(ff8_externals.worldmap_sub_53F310, 0x3DC);
732: 		ff8_externals.worldmap_prepare_tim_for_upload = (uint32_t(*)(uint8_t*,ff8_tim*))get_relative_call(ff8_externals.worldmap_sub_53F310, 0x2AC);
733: 		ff8_externals.worldmap_sub_548020 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x3E6);
734: 		ff8_externals.worldmap_sub_53F310_call_2A9 = ff8_externals.worldmap_sub_53F310 + 0x2AC;
735: 		ff8_externals.worldmap_sub_53F310_call_30D = ff8_externals.worldmap_sub_53F310 + 0x325;
736: 		ff8_externals.worldmap_sub_53F310_call_330 = ff8_externals.worldmap_sub_53F310 + 0x34C;
737: 		ff8_externals.worldmap_sub_53F310_call_366 = ff8_externals.worldmap_sub_53F310 + 0x382;
738: 		ff8_externals.worldmap_sub_53F310_call_3B5 = ff8_externals.worldmap_sub_53F310 + 0x3D6;
739: 		ff8_externals.worldmap_sub_554AA0 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x3D6);
740: 		ff8_externals.worldmap_sub_554AA0_call_C2 = ff8_externals.worldmap_sub_554AA0 + 0xCC;
741: 		ff8_externals.worldmap_sub_53F310_loc_53F7EE = ff8_externals.worldmap_sub_53F310 + 0x507;
742: 		ff8_externals.worldmap_sub_541970_upload_tim = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x34C);
743: 		ff8_externals.worldmap_sub_545E20 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x635);
744: 		ff8_externals.worldmap_chara_one = get_relative_call(ff8_externals.worldmap_sub_545E20, 0x6B);
745: 		ff8_externals.worldmap_sub_5531F0 = get_relative_call(ff8_externals.worldmap_sub_53F310, 0x63D);
746: 		ff8_externals.worldmap_alter_uv_sub_553B40 = get_relative_call(ff8_externals.worldmap_sub_5531F0, 0x253);
747: 		ff8_externals.open_file_world = (int32_t(*)(const char*, int32_t, uint32_t, void *))get_relative_call(ff8_externals.worldmap_sub_5531F0, 0x38F);
748: 		ff8_externals.open_file_world_sub_52D670_texl_call1 = ff8_externals.worldmap_sub_5531F0 + 0x38F;
749: 		ff8_externals.open_file_world_sub_52D670_texl_call2 = ff8_externals.worldmap_sub_5531F0 + 0x68E;
750: 		ff8_externals.upload_psxvram_texl_pal_call1 = ff8_externals.worldmap_sub_5531F0 + 0x2EC;
751: 		ff8_externals.upload_psxvram_texl_pal_call2 = ff8_externals.worldmap_sub_5531F0 + 0x3F0;
752: 
753: 		ff8_externals.show_vram_window = (void (*)())get_relative_call(ff8_externals.worldmap_main_loop, 0xA3);
754: 		ff8_externals.refresh_vram_window = (void (*)())get_relative_call(ff8_externals.worldmap_main_loop, 0xA8);
755: 		ff8_externals.worldmap_with_fog_sub_53FAC0 = get_relative_call(ff8_externals.worldmap_main_loop, 0x137);
756: 		ff8_externals.worldmap_input_update_sub_559240 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x1C);
757: 		ff8_externals.sub_554940 = get_relative_call(ff8_externals.worldmap_input_update_sub_559240, 0x23A);
758: 		ff8_externals.sub_554940_call_130 = ff8_externals.sub_554940 + 0x13C;
759: 		ff8_externals.sub_541AE0 = get_relative_call(ff8_externals.sub_554940, 0x13C);
760: 		ff8_externals.sub_554BC0 = get_relative_call(ff8_externals.worldmap_input_update_sub_559240, 0x258);
761: 		ff8_externals.sub_557140 = get_relative_call(ff8_externals.worldmap_input_update_sub_559240, 0x260);
762: 		ff8_externals.sub_54B460 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x5D9);
763: 
764: 		ff8_externals.sub_549E80 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x1D6);
765: 		ff8_externals.sub_550070 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x279);
766: 		ff8_externals.vibrate_data_world = (uint8_t *)get_absolute_value(ff8_externals.sub_550070, 0xAFA);
767: 		ff8_externals.sub_53BB90 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x2D5);
768: 		ff8_externals.sub_53E2A0 = get_relative_call(ff8_externals.sub_53BB90, 0x336);
769: 		ff8_externals.sub_53E6B0 = get_relative_call(ff8_externals.sub_53E2A0, 0x39A);
770: 		ff8_externals.sub_4023D0 = get_relative_call(ff8_externals.sub_53BB90, 0xAE5);
771: 		ff8_externals.worldmap_fog_filter_polygons_in_block_1 = get_relative_call(ff8_externals.sub_53BB90, 0x43B);
772: 		ff8_externals.worldmap_has_polygon_condition_2045C90 = get_absolute_value(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x51);
773: 		ff8_externals.worldmap_polygon_condition_2045C8C = get_absolute_value(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x5D);
774: 		ff8_externals.worldmap_sub_45DF20 = get_relative_call(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x202);
775: 		ff8_externals.sub_45E3A0 = get_relative_call(ff8_externals.worldmap_fog_filter_polygons_in_block_1, 0x4B8);
776: 		ff8_externals.worldmap_fog_filter_polygons_in_block_2 = get_relative_call(ff8_externals.sub_53BB90, 0x450);
777: 		if (JP_VERSION)
778: 		{
779: 			ff8_externals.sub_4023D0 = get_relative_call(ff8_externals.sub_4023D0, 0x0);
780: 		}
781: 		ff8_externals.sub_53C750 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x2DC);
782: 		ff8_externals.sub_54E9B0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x36A);
783: 		ff8_externals.sub_54FDA0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x376);
784: 		ff8_externals.sub_54D7E0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x3C4);
785: 		ff8_externals.world_dialog_assign_text_sub_543790 = (int (*)(int,int,char*))get_relative_call(ff8_externals.sub_54D7E0, 0x6F);
786: 		ff8_externals.world_dialog_question_assign_text_sub_5438D0 = (int (*)(int, int, char*, int, int, int, uint8_t))get_relative_call(ff8_externals.sub_54D7E0, 0x116);
787: 		ff8_externals.sub_544630 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x3D5);
788: 		ff8_externals.sub_545EA0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x4C1);
789: 		ff8_externals.sub_5484B0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x5CB);
790: 		ff8_externals.sub_54A230 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, 0x5D1);
791: 		ff8_externals.sub_543CB0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, JP_VERSION ? 0xA3C : 0xA47);
792: 		ff8_externals.worldmap_update_steps_sub_6519D0 = get_relative_call(ff8_externals.worldmap_with_fog_sub_53FAC0, JP_VERSION ? 0x8C4 : 0x8CD);
793: 		ff8_externals.set_drawpoint_state_521D90 = (void(*)(uint8_t, char))get_relative_call(ff8_externals.sub_54E9B0, 0x85F);
794: 
795: 		ff8_externals.sub_545F10 = get_relative_call(ff8_externals.sub_545EA0, 0x1C);
796: 
797: 		ff8_externals.sub_546100 = get_relative_call(ff8_externals.sub_545F10, 0x54);
798: 
799: 		ff8_externals.sub_54A0D0 = 0x54A0D0;
800: 
801: 		ff8_externals.battle_trigger_worldmap = ff8_externals.worldmap_with_fog_sub_53FAC0 + 0x4EA;
802: 	}
803: 
804: 	ff8_externals.worldmap_update_seed_level_651C10 = get_relative_call(ff8_externals.worldmap_update_steps_sub_6519D0, 0x152);
805: 	ff8_externals.worldmap_windows_idx_map = (char*)get_absolute_value((uint32_t)ff8_externals.world_dialog_assign_text_sub_543790, 0x3B);
806: 
807: 	ff8_externals.sub_548080 = get_relative_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE, 0x9B);
808: 	ff8_externals.sub_541C80 = (int (*)(WORD*))get_relative_call(ff8_externals.battle_trigger_worldmap, 0);
809: 
810: 	ff8_externals.sub_558D70 = get_relative_call(ff8_externals.sub_54B460, 0x3F3);
811: 
812: 	common_externals.current_field_name = (char*)get_absolute_value(ff8_externals.opcode_effectplay2, 0x75);
813: 	common_externals.previous_field_id = (WORD*)get_absolute_value(ff8_externals.sub_470250, 0x13);
814: 	common_externals.update_entities_call = common_externals.update_field_entities + 0x657;
815: 
816: 	ff8_externals.field_get_dialog_string = get_relative_call(ff8_externals.opcode_mes, 0x5D);
817: 	ff8_externals.set_window_object = get_relative_call(ff8_externals.opcode_mes, 0x66);
818: 	ff8_externals.windows = (ff8_win_obj*)get_absolute_value(ff8_externals.set_window_object, 0x11);
819: 
820: 	ff8_externals.sub_470440 = get_absolute_value(ff8_externals.credits_main_loop, 0xD2);
821: 	ff8_externals.sub_49ACD0 = get_relative_call(ff8_externals.sub_470440, JP_VERSION ? 0x9C : 0x98);
822: 	ff8_externals.sub_4A0880 = get_relative_call(ff8_externals.sub_49ACD0, 0x58);
823: 	ff8_externals.sub_4A09A0 = get_absolute_value(ff8_externals.sub_4A0880, 0x25);
824: 	ff8_externals.sub_49FC10 = get_relative_call(ff8_externals.sub_4A09A0, 0xCF);
825: 	ff8_externals.ff8_draw_icon_or_key2 = get_relative_call(ff8_externals.sub_49FC10, 0xF4);
826: 	ff8_externals.dword_1D2B808 = (uint32_t *)get_absolute_value(ff8_externals.ff8_draw_icon_or_key2, 0x41);
827: 	ff8_externals.ff8_draw_icon_or_key3 = ff8_externals.ff8_draw_icon_or_key2 + 0x110;
828: 	ff8_externals.ff8_draw_icon_or_key4 = ff8_externals.ff8_draw_icon_or_key3 + 0xF0;
829: 	ff8_externals.ff8_draw_icon_or_key5 = ff8_externals.ff8_draw_icon_or_key4 + 0x120;
830: 	ff8_externals.ff8_draw_icon_or_key6 = ff8_externals.ff8_draw_icon_or_key5 + 0x110;
831: 	ff8_externals.battle_boost_cross_icon_display_1D76604 = (uint8_t *)get_absolute_value(ff8_externals.ff8_draw_icon_or_key5, 0xD5);
832: 	ff8_externals.sub_49FE60 = get_relative_call(ff8_externals.ff8_draw_icon_or_key6, 0xC9);
833: 	ff8_externals.sub_4A0C00 = get_absolute_value(ff8_externals.sub_4A0880, 0x33);
834: 	ff8_externals.show_dialog = (char(*)(int32_t, uint32_t, int16_t))get_relative_call(ff8_externals.sub_4A0C00, 0x5F);
835: 
836: 	ff8_externals.sub_485460 = get_relative_call(ff8_externals.sub_47CCB0, 0xB13);
837: 	ff8_externals.sub_485610 = get_relative_call(ff8_externals.sub_485460, 0xDC);
838: 	ff8_externals.sub_48D1A0 = get_absolute_value(ff8_externals.sub_485610, 0x78A);
839: 	ff8_externals.sub_4AD7D0 = get_relative_call(ff8_externals.sub_48D1A0, 0x44);
840: 	ff8_externals.sub_4AD8D0 = get_absolute_value(ff8_externals.sub_4AD7D0, 0xC8);
841: 	ff8_externals.sub_4AB4F0 = get_relative_call(ff8_externals.sub_4AD8D0, 0x159);
842: 	ff8_externals.sub_4AB190 = get_relative_call(ff8_externals.sub_4AB4F0, 0x20);
843: 
844: 	ff8_externals.battle_check_won_sub_486500 = get_relative_call(ff8_externals.sub_47CCB0, 0xA82);
845: 	ff8_externals.battle_sub_494D40 = (void(*)())get_relative_call(ff8_externals.battle_check_won_sub_486500, 0x66);
846: 	ff8_externals.battle_result_state_1CFF6E7 = (byte*)get_absolute_value(ff8_externals.battle_check_won_sub_486500, 0x1);
847: 
848: 	ff8_externals.battle_sub_4877F0 = get_relative_call(ff8_externals.sub_485610, 0x6F);
849: 	ff8_externals.battle_sub_48D200 = get_relative_call(ff8_externals.sub_485610, 0x323);
850: 	ff8_externals.battle_ai_opcode_sub_487DF0 = get_relative_call(ff8_externals.battle_sub_4877F0, 0x82);
851: 	ff8_externals.update_tutorial_info_4AD170 = (void(*)(int))get_relative_call(ff8_externals.battle_ai_opcode_sub_487DF0, FF8_US_VERSION ? 0x216C : (JP_VERSION ? 0x2148 : 0x2176));
852: 	ff8_externals.battle_get_draw_magic_amount_48FD20 = (int(*)(int, int, int))get_relative_call(ff8_externals.battle_sub_48D200, FF8_US_VERSION ? 0x354 : (JP_VERSION ? 0x36F : 0x355));
853: 	ff8_externals.sub_48B7E0 = get_relative_call(ff8_externals.sub_47CCB0, 0x8F0);
854: 	ff8_externals.compute_char_stats_sub_495960 = get_relative_call(ff8_externals.sub_48B7E0, 0xA3);
855: 	ff8_externals.sub_4954B0 = (void(*)(int))get_relative_call(ff8_externals.compute_char_stats_sub_495960, 0x68);
856: 	ff8_externals.compute_char_max_hp_496310 = (int(*)(int, int))get_relative_call(ff8_externals.compute_char_stats_sub_495960, 0x94);
857: 	ff8_externals.get_char_level_4961D0 = (int(*)(int, int))get_relative_call(ff8_externals.compute_char_stats_sub_495960, 0x82);
858: 	ff8_externals.char_comp_stats_1CFF000 = std::span((ff8_char_computed_stats*)get_absolute_value(ff8_externals.compute_char_stats_sub_495960, 0x2A), 3);
859: 
860: 	ff8_externals.sub_4A84E0 = get_relative_call(ff8_externals.battle_main_loop, 0x142);
861: 	ff8_externals.sub_4AD400 = get_relative_call(ff8_externals.sub_4A84E0, 0x2DB);
862: 	ff8_externals.sub_4BB840 = get_relative_call(ff8_externals.sub_4AD400, 0xCB);
863: 	ff8_externals.battle_current_active_character_id = (BYTE*)get_absolute_value(ff8_externals.sub_4BB840, 0x13);
864: 	ff8_externals.battle_new_active_character_id = (BYTE*)get_absolute_value(ff8_externals.sub_4BB840, 0x37);
865: 
866: 	ff8_externals.global_battle_encounter_id_1CFF6E0 = (WORD*)(get_absolute_value(ff8_externals.opcode_battle, 0x50) - 2);
867: 	ff8_externals.battle_encounter_id = (WORD*)get_absolute_value(ff8_externals.opcode_battle, 0x66);
868: 
869: 	ff8_externals.sub_4AB450 = get_relative_call(ff8_externals.sub_47CCB0, 0xA5F);
870: 	ff8_externals.battle_get_monster_name_sub_495100 = get_relative_call(ff8_externals.sub_4AB450, 0x40);
871: 	ff8_externals.battle_char_struct_dword_1D27B10 = (BYTE**)get_absolute_value(ff8_externals.battle_get_monster_name_sub_495100, 0xF);
872: 
873: 	ff8_externals.sub_4AA920 = get_relative_call(ff8_externals.sub_4AB190, 0xED);
874: 	ff8_externals.battle_get_actor_name_sub_47EAF0 = get_relative_call(ff8_externals.sub_4AA920, 0x97);
875: 	ff8_externals.byte_1CFF1C3 = (BYTE*)get_absolute_value(ff8_externals.battle_get_actor_name_sub_47EAF0, 0x15);
876: 	ff8_externals.unk_1CFDC70 = (char*)get_absolute_value(ff8_externals.battle_get_actor_name_sub_47EAF0, 0x1E);
877: 	ff8_externals.unk_1CFDC7C = (char*)get_absolute_value(ff8_externals.battle_get_actor_name_sub_47EAF0, 0x28);
878: 	ff8_externals.word_1CF75EC = (WORD*)get_absolute_value(ff8_externals.battle_get_actor_name_sub_47EAF0, 0x39);
879: 	ff8_externals.unk_1CFF84C = (char*)get_absolute_value(ff8_externals.battle_get_actor_name_sub_47EAF0, 0x44);
880: 	ff8_externals.unk_1CF3E48 = (char*)get_absolute_value(ff8_externals.battle_get_actor_name_sub_47EAF0, 0x57);
881: 	ff8_externals.dword_1CF3EE0 = (DWORD*)get_absolute_value(ff8_externals.battle_get_actor_name_sub_47EAF0, 0x4B);
882: 
883: 	ff8_externals.battle_current_actor_talking = (DWORD*)get_absolute_value(ff8_externals.sub_485610, 0x36E);
884: 
885: 	ff8_externals.sub_502380 = get_relative_call(ff8_externals.sub_500CC0, 0x69);
886: 	ff8_externals.sub_50A790 = get_relative_call(ff8_externals.sub_502380, 0x51);
887: 	ff8_externals.sub_50A9A0 = get_absolute_value(ff8_externals.sub_50A790, 0x7C);
888: 	ff8_externals.battle_read_effect_sub_50AF20 = get_relative_call(ff8_externals.sub_50A9A0, 0xF4);
889: 	ff8_externals.func_off_battle_effects_C81774 = (DWORD*)get_absolute_value(ff8_externals.battle_read_effect_sub_50AF20, 0x2C);
890: 	ff8_externals.battle_magic_id = (int*)get_absolute_value(ff8_externals.battle_read_effect_sub_50AF20, 0x3E);
891: 	ff8_externals.sub_571870 = get_relative_call(ff8_externals.battle_read_effect_sub_50AF20, 0x63);
892: 	ff8_externals.func_off_battle_effect_textures_50AF93 = (DWORD*)get_absolute_value(ff8_externals.battle_read_effect_sub_50AF20, 0x6B);
893: 
894: 	ff8_externals.sub_6C3640 = get_relative_call(ff8_externals.func_off_battle_effects_C81774[FF8BattleEffect::Quezacotl], 0x5);
895: 	ff8_externals.sub_6C3760 = get_absolute_value(ff8_externals.sub_6C3640, 0x8B);
896: 	ff8_externals.vibrate_data_summon_quezacotl = (uint8_t **)get_absolute_value(ff8_externals.sub_6C3760, 0xB0);
897: 
898: 	ff8_externals.sub_B586F0 = get_absolute_value(ff8_externals.func_off_battle_effects_C81774[FF8BattleEffect::Leviathan], 0x45);
899: 	ff8_externals.sub_B64B80 = get_relative_call(ff8_externals.sub_B586F0, 0x1B5);
900: 	ff8_externals.leviathan_funcs_B64C3C = (DWORD *)get_absolute_value(ff8_externals.sub_B64B80, 0xBF);
901: 	ff8_externals.mag_data_palette_sub_B66560 = get_relative_call(ff8_externals.leviathan_funcs_B64C3C[FF8BattleEffectOpcode::UploadPalette75], 0x13);
902: 	ff8_externals.effect_struct_27973EC = (DWORD **)get_absolute_value(ff8_externals.mag_data_palette_sub_B66560, 0x4);
903: 	ff8_externals.mag_data_dword_2798A68 = (uint8_t **)get_absolute_value(ff8_externals.mag_data_palette_sub_B66560, 0x19);
904: 	ff8_externals.effect_struct_2797624 = (DWORD **)get_absolute_value(ff8_externals.mag_data_palette_sub_B66560, 0x28);
905: 	ff8_externals.battle_set_action_upload_raw_palette_sub_B666F0 = get_relative_call(ff8_externals.leviathan_funcs_B64C3C[FF8BattleEffectOpcode::UploadPalette75], 0xD4);
906: 	ff8_externals.battle_set_action_upload_raw_palette_sub_B66400 = get_relative_call(ff8_externals.battle_set_action_upload_raw_palette_sub_B666F0, 0x141);
907: 
908: 	ff8_externals.sub_B63230 = get_relative_call(ff8_externals.leviathan_funcs_B64C3C[FF8BattleEffectOpcode::UploadTexture39], 0x9);
909: 	ff8_externals.mag_data_texture_sub_B66560 = get_relative_call(ff8_externals.sub_B63230, 0xA);
910: 	ff8_externals.dword_27973E8 = (BYTE**)get_absolute_value(ff8_externals.mag_data_texture_sub_B66560, 0x8F);
911: 
912: 	ff8_externals.load_magic_data_sub_571B80 = get_relative_call(ff8_externals.func_off_battle_effect_textures_50AF93[0], 0x5);
913: 	ff8_externals.load_magic_data_sub_571900 = get_relative_call(ff8_externals.load_magic_data_sub_571B80, 0x1E);
914: 	ff8_externals.load_magic_data_sub_5718E0 = get_relative_call(ff8_externals.func_off_battle_effect_textures_50AF93[198], 0x5);
915: 
916: 	ff8_externals.sub_84D110 = get_absolute_value(ff8_externals.func_off_battle_effects_C81774[FF8BattleEffect::Scan], 0x28);
917: 	ff8_externals.sub_84D1F0 = get_absolute_value(ff8_externals.sub_84D110, 0x14);
918: 	ff8_externals.sub_84D230 = get_absolute_value(ff8_externals.sub_84D1F0, 0x9);
919: 	ff8_externals.sub_84D2C0 = get_absolute_value(ff8_externals.sub_84D230, 0xC);
920: 	ff8_externals.sub_84D4B0 = get_absolute_value(ff8_externals.sub_84D2C0, 0x3C);
921: 	ff8_externals.sub_84F2A0 = get_absolute_value(ff8_externals.sub_84D4B0, 0x39);
922: 	ff8_externals.sub_84F860 = get_absolute_value(ff8_externals.sub_84F2A0, 0x14);
923: 	ff8_externals.sub_84F8D0 = get_absolute_value(ff8_externals.sub_84F860, 0xD);
924: 	ff8_externals.scan_get_text_sub_B687C0 = get_relative_call(ff8_externals.sub_84F8D0, 0x88);
925: 	ff8_externals.battle_entities_1D27BCB = get_absolute_value(ff8_externals.scan_get_text_sub_B687C0, 0x18);
926: 	ff8_externals.scan_text_positions = get_absolute_value(ff8_externals.scan_get_text_sub_B687C0, 0x20);
927: 	ff8_externals.scan_text_data = get_absolute_value(ff8_externals.scan_get_text_sub_B687C0, 0x27);
928: 	ff8_externals.get_card_name = get_relative_call(ff8_externals.sub_4EFCD0, 0x89);
929: 	ff8_externals.card_name_positions = get_absolute_value(ff8_externals.get_card_name, 0xB);
930: 
931: 	ff8_externals.battle_menu_loop_4A2690 = get_absolute_value(ff8_externals.battle_main_loop, 0x216);
932: 	ff8_externals.battle_menu_sub_4A6660 = get_relative_call(ff8_externals.battle_menu_loop_4A2690, 0xAF);
933: 	ff8_externals.battle_menu_sub_4A3D20 = get_relative_call(ff8_externals.battle_menu_sub_4A6660, 0);
934: 	ff8_externals.battle_menu_sub_4A3EE0 = get_relative_call(ff8_externals.battle_menu_sub_4A3D20, 0x12A);
935: 	ff8_externals.battle_menu_add_exp_and_stat_bonus_496CB0 = (int(*)(int, uint16_t))get_relative_call(ff8_externals.battle_menu_sub_4A3EE0, 0x581);
936: 	ff8_externals.character_data_1CFE74C = (byte*)get_absolute_value((uint32_t)ff8_externals.battle_menu_add_exp_and_stat_bonus_496CB0, 0xD);
937: 	ff8_externals.battle_sub_485160 = get_relative_call(ff8_externals.sub_47CCB0, 0xB18);
938: 	ff8_externals.battle_sub_48FE20 = get_relative_call(ff8_externals.battle_sub_485160, 0x91);
939: 	ff8_externals.battle_sub_494410 = get_relative_call(ff8_externals.battle_sub_48FE20, FF8_US_VERSION ? 0x139C : (JP_VERSION ? 0x1300 : 0x1301));
940: 	ff8_externals.battle_sub_494AF0 = (void(*)(int, int, int, int))get_relative_call(ff8_externals.battle_sub_494410, 0x525);
941: 
942: 	ff8_externals.fps_limiter = get_relative_call(ff8_externals.field_main_loop, 0x261);
943: 	if (JP_VERSION)
944: 	{
945: 		ff8_externals.fps_limiter = get_relative_call(ff8_externals.fps_limiter, 0x0);
946: 	}
947: 	ff8_externals.time_volume_change_related_1A78BE0 = (double *)get_absolute_value(ff8_externals.fps_limiter, 0x3F);
948: 
949: 	ff8_externals.game_mode_obj_1D9CF88 = (uint32_t*)get_absolute_value(uint32_t(ff8_externals.sub_47CA90), 0xCD);
950: 	ff8_externals.field_vars_stack_1CFE9B8 = get_absolute_value(ff8_externals.opcode_pshm_w, 0x1E);
951: 
952: 	common_externals.current_triangle_id = 0x0;
953: 	common_externals.field_game_moment = (WORD*)(ff8_externals.field_vars_stack_1CFE9B8 + 0x100); //0x1CFEAB8
954: }
955: 
956: void ff8_data()
957: {
958: 	num_modes = sizeof(ff8_modes) / sizeof(ff8_modes[0]);
959: 
960: 	ff8_find_externals();
961: 
962: 	memcpy(modes, ff8_modes, sizeof(ff8_modes));
963: 
964: 	text_colors[TEXTCOLOR_GRAY] = 0x08;
965: 	text_colors[TEXTCOLOR_BLUE] = 0x01;
966: 	text_colors[TEXTCOLOR_RED] = 0x04;
967: 	text_colors[TEXTCOLOR_PINK] = 0x05;
968: 	text_colors[TEXTCOLOR_GREEN] = 0x02;
969: 	text_colors[TEXTCOLOR_LIGHT_BLUE] = 0x09;
970: 	text_colors[TEXTCOLOR_YELLOW] = 0x0E;
971: 	text_colors[TEXTCOLOR_WHITE] = 0x0F;
972: }
</file>

<file path="src/ff8_data.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2020 Marcin Gomulak                                     //
 9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include "common.h"
26: #include "ff8.h"
27: 
28: // FF8 game mode definitions
29: static struct game_mode ff8_modes[] = {
30: 	{FF8_MODE_CREDITS,       "MODE_CREDITS",       MODE_CREDITS,       true },
31: 	{FF8_MODE_FIELD,         "MODE_FIELD",         MODE_FIELD,         true },
32: 	{FF8_MODE_WORLDMAP,      "MODE_WORLDMAP",      MODE_WORLDMAP,      true },
33: 	{FF8_MODE_SWIRL,         "MODE_SWIRL",         MODE_SWIRL,         true },
34: 	{FF8_MODE_AFTER_BATTLE,  "MODE_AFTER_BATTLE",  MODE_AFTER_BATTLE,  true },
35: 	{FF8_MODE_5,             "MODE_5",             MODE_UNKNOWN,       true },
36: 	{FF8_MODE_MENU,          "MODE_MENU",          MODE_MENU,          true },
37: 	{FF8_MODE_7,             "MODE_7",             MODE_UNKNOWN,       true },
38: 	{FF8_MODE_CARDGAME,      "MODE_CARDGAME",      MODE_CARDGAME,      true },
39: 	{FF8_MODE_9,             "MODE_9",             MODE_UNKNOWN,       true },
40: 	{FF8_MODE_TUTO,          "MODE_TUTO",          MODE_UNKNOWN,       true },
41: 	{FF8_MODE_11,            "MODE_11",            MODE_UNKNOWN,       true },
42: 	{FF8_MODE_INTRO,         "MODE_INTRO",         MODE_INTRO,         true },
43: 	{FF8_MODE_100,           "MODE_100",           MODE_UNKNOWN,       true },
44: 	{FF8_MODE_MAIN_MENU,     "MODE_MAIN_MENU",     MODE_MAIN_MENU,     true },
45: 	{FF8_MODE_BATTLE,        "MODE_BATTLE",        MODE_BATTLE,        true }
46: };
47: 
48: void ff8_set_main_loop(uint32_t driver_mode, uint32_t main_loop);
49: void ff8_find_externals();
50: void ff8_data();
</file>

<file path="src/ff8_opengl.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //                                                                          //
  10: //    This file is part of FFNx                                             //
  11: //                                                                          //
  12: //    FFNx is free software: you can redistribute it and/or modify          //
  13: //    it under the terms of the GNU General Public License as published by  //
  14: //    the Free Software Foundation, either version 3 of the License         //
  15: //                                                                          //
  16: //    FFNx is distributed in the hope that it will be useful,               //
  17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  19: //    GNU General Public License for more details.                          //
  20: /****************************************************************************/
  21: 
  22: #include "globals.h"
  23: #include "common.h"
  24: #include "ff8.h"
  25: #include "fake_dd.h"
  26: #include "patch.h"
  27: #include "log.h"
  28: #include "macro.h"
  29: #include "movies.h"
  30: #include "gl.h"
  31: #include "gamepad.h"
  32: #include "joystick.h"
  33: #include "gamehacks.h"
  34: #include "utils.h"
  35: #include "vibration.h"
  36: #include "ff8/file.h"
  37: #include "ff8/vram.h"
  38: #include "ff8/save_data.h"
  39: #include "metadata.h"
  40: #include "achievement.h"
  41: #include "widescreen.h"
  42: 
  43: unsigned char texture_reload_fix1[] = {0x5B, 0x5F, 0x5E, 0x5D, 0x81, 0xC4, 0x10, 0x01, 0x00, 0x00};
  44: unsigned char texture_reload_fix2[] = {0x5F, 0x5E, 0x5D, 0x5B, 0x81, 0xC4, 0x8C, 0x00, 0x00, 0x00};
  45: int left_stick_y = 0x80;
  46: int left_stick_x = 0x80;
  47: int right_stick_y = 0x80;
  48: int right_stick_x = 0x80;
  49: 
  50: std::chrono::time_point<std::chrono::high_resolution_clock> intro_credits_music_start_time;
  51: constexpr int intro_credits_fade_frames = 33;
  52: constexpr int intro_credits_adjusted_frames = 438; // Instead of 374 in the Game
  53: constexpr int intro_credits_frames_between_music_start_and_first_image = 180;
  54: 
  55: int (*ff8_opcode_old_battle)(int);
  56: 
  57: void ff8gl_field_78(struct ff8_polygon_set *polygon_set, struct ff8_game_obj *game_object)
  58: {
  59: 	struct matrix_set *matrix_set;
  60: 	struct p_hundred *hundred_data = 0;
  61: 	uint32_t group_counter;
  62: 
  63: 	if(trace_all) ffnx_trace("dll_gfx: field_78\n");
  64: 
  65: 	if(!game_object->in_scene) return;
  66: 
  67: 	if(polygon_set == 0) return;
  68: 
  69: 	if(polygon_set->field_0 == 0) return;
  70: 
  71: 	matrix_set = polygon_set->matrix_set;
  72: 
  73: 	hundred_data = 0;
  74: 
  75: 	if(polygon_set->field_2C) hundred_data = polygon_set->hundred_data;
  76: 
  77: 	group_counter = 0;
  78: 
  79: 	while(group_counter < polygon_set->numgroups)
  80: 	{
  81: 		uint32_t defer = false;
  82: 		uint32_t zsort = false;
  83: 
  84: 		if(polygon_set->per_group_hundreds) hundred_data = polygon_set->hundred_data_group_array[group_counter];
  85: 
  86: 		if(hundred_data)
  87: 		{
  88: 			if(game_object->field_91C && hundred_data->zsort) zsort = true;
  89: 			else if(!game_object->field_928) defer = (hundred_data->options & (BIT(V_ALPHABLEND) | BIT(V_TMAPBLEND)));
  90: 		}
  91: 
  92: 		if(!defer) common_setrenderstate(hundred_data, (struct game_obj *)game_object);
  93: 
  94: 		if(matrix_set && matrix_set->matrix_projection) gl_set_d3dprojection_matrix(matrix_set->matrix_projection);
  95: 
  96: 		if(hundred_data) hundred_data = &hundred_data[1];
  97: 
  98: 		group_counter++;
  99: 	}
 100: }
 101: 
 102: void ff8gl_field_54(struct texture_set *texture_set, struct game_obj *game_object)
 103: {
 104: 	if (trace_all) ffnx_trace("field_54\n");
 105: }
 106: 
 107: void ff8gl_field_58(struct texture_set *texture_set, struct game_obj *game_object)
 108: {
 109: 	if (trace_all) ffnx_trace("field_58\n");
 110: }
 111: 
 112: void ff8gl_field_5C(struct texture_set *texture_set, struct game_obj *game_object)
 113: {
 114: 	if (trace_all) ffnx_trace("field_5C\n");
 115: }
 116: 
 117: void ff8gl_field_60(struct palette *palette, struct texture_set *texture_set)
 118: {
 119: 	if(trace_all) ffnx_trace("field_60\n");
 120: }
 121: 
 122: void ff8gl_field_84(uint32_t unknown, struct game_obj *game_object)
 123: {
 124: 	if (trace_all) ffnx_trace("field_84\n");
 125: }
 126: 
 127: void ff8gl_field_88()
 128: {
 129: 	if (trace_all) ffnx_trace("field_88\n");
 130: }
 131: 
 132: void ff8_destroy_tex_header(struct ff8_tex_header *tex_header)
 133: {
 134: 	if(!tex_header) return;
 135: 
 136: 	if((uint32_t)tex_header->file.pc_name > 32) external_free(tex_header->file.pc_name);
 137: 
 138: 	external_free(tex_header->old_palette_data);
 139: 	external_free(tex_header->palette_colorkey);
 140: 	external_free(tex_header->tex_format.palette_data);
 141: 	external_free(tex_header->image_data);
 142: 
 143: 	external_free(tex_header);
 144: }
 145: 
 146: struct ff8_tex_header *ff8_load_tex_file(struct ff8_file_context* file_context, char *filename)
 147: {
 148: 	struct ff8_tex_header *ret = (struct ff8_tex_header *)common_externals.create_tex_header();
 149: 	struct ff8_file* file = ff8_open_file(file_context, filename);
 150: 	uint32_t i, len;
 151: 
 152: 	if(!file) goto error;
 153: 	if(!ff8_read_file(sizeof(*ret), ret, file)) goto error;
 154: 
 155: 	ret->image_data = 0;
 156: 	ret->old_palette_data = 0;
 157: 	ret->palette_colorkey = 0;
 158: 	ret->tex_format.palette_data = 0;
 159: 
 160: 	if(ret->version != 2) goto error;
 161: 	else
 162: 	{
 163: 		if(ret->tex_format.use_palette)
 164: 		{
 165: 			ret->tex_format.palette_data = (uint32_t*)common_externals.alloc_read_file(4, ret->tex_format.palette_size, (struct file *)file);
 166: 			if(!ret->tex_format.palette_data) goto error;
 167: 		}
 168: 
 169: 		ret->image_data = (unsigned char*)common_externals.alloc_read_file(ret->tex_format.bytesperpixel, ret->tex_format.width * ret->tex_format.height, (struct file *)file);
 170: 		if(!ret->image_data) goto error;
 171: 
 172: 		if(ret->use_palette_colorkey)
 173: 		{
 174: 			ret->palette_colorkey = (char*)common_externals.alloc_read_file(1, ret->palettes, (struct file *)file);
 175: 			if(!ret->palette_colorkey) goto error;
 176: 		}
 177: 	}
 178: 
 179: 	ret->file.pc_name = (char*)external_malloc(1024);
 180: 
 181: 	len = _snprintf(ret->file.pc_name, 1024, "%s", &filename[7]);
 182: 
 183: 	for(i = 0; i < len; i++)
 184: 	{
 185: 		if(ret->file.pc_name[i] == '.')
 186: 		{
 187: 			if(!_strnicmp(&ret->file.pc_name[i], ".TEX", 4)) ret->file.pc_name[i] = 0;
 188: 			else ret->file.pc_name[i] = '_';
 189: 		}
 190: 	}
 191: 
 192: 	ff8_close_file(file);
 193: 	return ret;
 194: 
 195: error:
 196: 	ff8_destroy_tex_header(ret);
 197: 	ff8_close_file(file);
 198: 	return 0;
 199: }
 200: 
 201: #define TEXRELOAD_BUFFER_SIZE 64
 202: 
 203: struct
 204: {
 205: 	char *image_data;
 206: 	uint32_t size;
 207: 	struct ff8_texture_set *texture_set;
 208: } reload_buffer[TEXRELOAD_BUFFER_SIZE] = {};
 209: uint32_t reload_buffer_index = 0;
 210: 
 211: // this function is wedged into the middle of a function designed to reload a Direct3D texture
 212: // when the image data changes
 213: void texture_reload_hack(struct texture_page *texture_page, struct ff8_texture_set *texture_set)
 214: {
 215: 	uint32_t i;
 216: 	uint32_t size;
 217: 	VOBJ(tex_header, tex_header, texture_set->tex_header);
 218: 
 219: 	size = VREF(tex_header, tex_format.width) * VREF(tex_header, tex_format.height) * VREF(tex_header, tex_format.bytesperpixel);
 220: 
 221: 	// a circular buffer holds the last TEXRELOAD_BUFFER_SIZE textures that went through here
 222: 	// and their respective image data so that we can see if anything actually changed and avoid
 223: 	// unnecessary texture reloads
 224: 	for(i = 0; i < TEXRELOAD_BUFFER_SIZE; i++)
 225: 	{
 226: 		if(reload_buffer[i].texture_set == texture_set && reload_buffer[i].size == size && memcmp(reload_buffer[i].image_data, VREF(tex_header, image_data), size) == 0)
 227: 		{
 228: 			return;
 229: 		}
 230: 	}
 231: 
 232: 	TexturePacker::TiledTex tiledTex = texturePacker.getTiledTex(VREF(tex_header, image_data));
 233: 	Tim::Bpp texBpp = Tim::Bpp(texture_page->color_key);
 234: 
 235: 	if (tiledTex.isValid() && texBpp != tiledTex.bpp()) {
 236: 		if(trace_all || trace_vram) ffnx_trace("%s: ignore reload because BPP does not match 0x%X (bpp vram=%d, bpp tex=%d, source bpp tex=%d) image_data=0x%X\n", __func__, texture_set, tiledTex.bpp(), VREF(tex_header, tex_format.bytesperpixel), texBpp, VREF(tex_header, image_data));
 237: 
 238: 		return;
 239: 	}
 240: 
 241: 	if (texBpp != Tim::Bpp16) {
 242: 		const std::list<TexturePacker::IdentifiedTexture> &textures = texturePacker.matchTextures(tiledTex, false, true);
 243: 
 244: 		if (textures.empty()) {
 245: 			if(trace_all || trace_vram) ffnx_trace("%s: ignore reload because no animated texture matches the current texture set 0x%X (bpp vram=%d, bpp tex=%d, source bpp tex=%d) image_data=0x%X\n", __func__, texture_set, tiledTex.bpp(), VREF(tex_header, tex_format.bytesperpixel), texBpp, VREF(tex_header, image_data));
 246: 
 247: 			return;
 248: 		}
 249: 	}
 250: 
 251: 	common_unload_texture((struct texture_set *)texture_set);
 252: 	common_load_texture((struct texture_set *)texture_set, texture_set->tex_header, texture_set->texture_format);
 253: 
 254: 	reload_buffer[reload_buffer_index].texture_set = texture_set;
 255: 	if (reload_buffer[reload_buffer_index].image_data != nullptr && reload_buffer[reload_buffer_index].size != size) {
 256: 		driver_free(reload_buffer[reload_buffer_index].image_data);
 257: 		reload_buffer[reload_buffer_index].image_data = nullptr;
 258: 	}
 259: 	if (reload_buffer[reload_buffer_index].image_data == nullptr) {
 260: 		reload_buffer[reload_buffer_index].image_data = (char*)driver_malloc(size);
 261: 	}
 262: 	memcpy(reload_buffer[reload_buffer_index].image_data, VREF(tex_header, image_data), size);
 263: 	reload_buffer[reload_buffer_index].size = size;
 264: 	reload_buffer_index = (reload_buffer_index + 1) % TEXRELOAD_BUFFER_SIZE;
 265: 
 266: 	stats.texture_reloads++;
 267: 
 268: 	if(trace_all || trace_vram) ffnx_trace("texture_reload_hack: 0x%X (bpp=%d, sourceBpp=%d) image_data=0x%X\n", texture_set, VREF(tex_header, tex_format.bytesperpixel), texBpp, VREF(tex_header, image_data));
 269: }
 270: 
 271: void texture_reload_hack1(struct texture_page *texture_page, uint32_t unknown1, uint32_t unknown2)
 272: {
 273: 	struct ff8_texture_set *texture_set = (struct ff8_texture_set *)texture_page->tri_gfxobj->hundred_data->texture_set;
 274: 
 275: 	texture_reload_hack(texture_page, texture_set);
 276: }
 277: 
 278: void texture_reload_hack2(struct texture_page *texture_page, uint32_t unknown1, uint32_t unknown2)
 279: {
 280: 	struct ff8_texture_set *texture_set = (struct ff8_texture_set *)texture_page->sub_tri_gfxobj->hundred_data->texture_set;
 281: 
 282: 	texture_reload_hack(texture_page, texture_set);
 283: }
 284: 
 285: void ff8_unload_texture(struct ff8_texture_set *texture_set)
 286: {
 287: 	uint32_t i;
 288: 
 289: 	// remove any references to this texture
 290: 	for(i = 0; i < TEXRELOAD_BUFFER_SIZE; i++) if(reload_buffer[i].texture_set == texture_set) reload_buffer[i].texture_set = 0;
 291: }
 292: 
 293: void swirl_sub_56D390(uint32_t x, uint32_t y, uint32_t w, uint32_t h)
 294: {
 295: 	static struct tex_header *last_tex_header = 0;
 296: 	struct tex_header *tex_header = make_framebuffer_tex(256, 256, x, y, w, h, false);
 297: 
 298: 	if(last_tex_header) ff8_destroy_tex_header((struct ff8_tex_header *)last_tex_header);
 299: 
 300: 	if(trace_all) ffnx_trace("swirl_sub_56D390: (%i, %i) %ix%i 0x%x (0x%x)\n", x, y, w, h, *ff8_externals.swirl_texture1, tex_header);
 301: 
 302: 	struct ff8_texture_set *texture_set = (struct ff8_texture_set *)(*ff8_externals.swirl_texture1)->hundred_data->texture_set;
 303: 
 304: 	common_unload_texture((*ff8_externals.swirl_texture1)->hundred_data->texture_set);
 305: 	common_load_texture((*ff8_externals.swirl_texture1)->hundred_data->texture_set, tex_header, texture_set->texture_format);
 306: 
 307: 	last_tex_header = tex_header;
 308: }
 309: 
 310: void ff8_wm_set_render_to_vram_current_screen_flag_before_battle()
 311: {
 312: 	if(trace_all) ffnx_trace("%s\n", __func__);
 313: 
 314: 	// There is currently an visual issue in the last worldmap frame before swirl if this flag is enabled
 315: 	// We lose the shadows, but keep the full battle transition effect
 316: 	*ff8_externals.sub_blending_capability = false;
 317: 
 318: 	// Disable software frame rendering to VRAM (by not doing anything here) because it is not needed anymore
 319: }
 320: 
 321: void ff8_swirl_init(float a1)
 322: {
 323: 	if(trace_all) ffnx_trace("%s\n", __func__);
 324: 
 325: 	// Reenable the flag that was disabled in worldmap
 326: 	*ff8_externals.sub_blending_capability = true;
 327: 
 328: 	((void(*)(float))ff8_externals.sub_460B60)(a1);
 329: }
 330: 
 331: int ff8_init_gamepad()
 332: {
 333: 	if (xinput_connected)
 334: 	{
 335: 		if (gamepad.Refresh())
 336: 			return TRUE;
 337: 	}
 338: 	else
 339: 	{
 340: 		if (joystick.Refresh())
 341:     	return TRUE;
 342: 	}
 343: 
 344: 	return FALSE;
 345: }
 346: 
 347: int ff8_get_analog_value(int8_t port, int type, int8_t offset)
 348: {
 349: 	if (type == 0) {
 350: 		return right_stick_x;
 351: 	}
 352: 
 353: 	if (type == 1) {
 354: 		return right_stick_y;
 355: 	}
 356: 
 357: 	if (type == 2) {
 358: 		return left_stick_x;
 359: 	}
 360: 
 361: 	if (type == 3) {
 362: 		return left_stick_y;
 363: 	}
 364: 
 365: 	return -1;
 366: }
 367: 
 368: int ff8_get_analog_value_wm(int8_t port, int type, int8_t offset)
 369: {
 370: 	if (left_stick_x != 0x80 || left_stick_y != 0x80) {
 371: 		int *keyscans = *(int **)(ff8_externals.worldmap_input_update_sub_559240 + (FF8_US_VERSION ? 0x64 : 0x61));
 372: 		int index = **(int **)(ff8_externals.worldmap_input_update_sub_559240 + (FF8_US_VERSION ? 0x9 : 0x6));
 373: 		keyscans[index] &= 0x0FFF; // Remove d-pad keys
 374: 	}
 375: 
 376: 	return ff8_get_analog_value(port, type, offset);
 377: }
 378: 
 379: LPDIJOYSTATE2 ff8_update_gamepad_status()
 380: {
 381: 	ff8_externals.dinput_gamepad_state->rgdwPOV[0] = -1;
 382: 	ff8_externals.dinput_gamepad_state->lX = 0;
 383: 	ff8_externals.dinput_gamepad_state->lY = 0;
 384: 	ff8_externals.dinput_gamepad_state->lRx = 0;
 385: 	ff8_externals.dinput_gamepad_state->lRy = 0;
 386: 
 387: 	nxVibrationEngine.rumbleUpdate();
 388: 
 389: 	int lX = 0, lY = 0, rX = 0, rY = 0;
 390: 
 391: 	if (xinput_connected)
 392: 	{
 393: 		if (!gamepad.Refresh() || !gamehacks.canInputBeProcessed()) return 0;
 394: 
 395: 		if ((gamepad.leftStickY > 0.5f) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_UP))
 396: 		{
 397: 			ff8_externals.dinput_gamepad_state->lY = 0xFFFFFFFFFFFFFFFF;
 398: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 0;
 399: 		}
 400: 		else if ((gamepad.leftStickY < -0.5f) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_DOWN))
 401: 		{
 402: 			ff8_externals.dinput_gamepad_state->lY = -0xFFFFFFFFFFFFFFFF;
 403: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 18000;
 404: 		}
 405: 
 406: 		if ((gamepad.leftStickX < -0.5f) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_LEFT))
 407: 		{
 408: 			ff8_externals.dinput_gamepad_state->lX = 0xFFFFFFFFFFFFFFFF;
 409: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 27000;
 410: 		}
 411: 		else if ((gamepad.leftStickX > 0.5f) || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_RIGHT))
 412: 		{
 413: 			ff8_externals.dinput_gamepad_state->lX = -0xFFFFFFFFFFFFFFFF;
 414: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 9000;
 415: 		}
 416: 
 417: 		lY = int(gamepad.leftStickY * 0x80);
 418: 		lX = int(gamepad.leftStickX * 0x80);
 419: 		rY = int(gamepad.rightStickY * 0x80);
 420: 		rX = int(gamepad.rightStickX * 0x80);
 421: 
 422: 		if (gamepad.rightStickY > 0.5f)
 423: 			ff8_externals.dinput_gamepad_state->lRy = 0xFFFFFFFFFFFFFFFF;
 424: 		else if (gamepad.rightStickY < -0.5f)
 425: 			ff8_externals.dinput_gamepad_state->lRy = -0xFFFFFFFFFFFFFFFF;
 426: 
 427: 		if (gamepad.rightStickX > 0.5f)
 428: 			ff8_externals.dinput_gamepad_state->lRx = -0xFFFFFFFFFFFFFFFF;
 429: 		else if (gamepad.rightStickX < -0.5f)
 430: 			ff8_externals.dinput_gamepad_state->lRx = 0xFFFFFFFFFFFFFFFF;
 431: 
 432: 		ff8_externals.dinput_gamepad_state->lZ = 0;
 433: 		ff8_externals.dinput_gamepad_state->lRz = 0;
 434: 		ff8_externals.dinput_gamepad_state->rglSlider[0] = 0;
 435: 		ff8_externals.dinput_gamepad_state->rglSlider[1] = 0;
 436: 		ff8_externals.dinput_gamepad_state->rgdwPOV[1] = -1;
 437: 		ff8_externals.dinput_gamepad_state->rgdwPOV[2] = -1;
 438: 		ff8_externals.dinput_gamepad_state->rgdwPOV[3] = -1;
 439: 		ff8_externals.dinput_gamepad_state->rgbButtons[0] = gamepad.IsPressed(steam_stock_launcher ? XINPUT_GAMEPAD_A : XINPUT_GAMEPAD_X) ? 0x80 : 0; // Cross (Steam)/Square
 440: 		ff8_externals.dinput_gamepad_state->rgbButtons[1] = gamepad.IsPressed(steam_stock_launcher ? XINPUT_GAMEPAD_B : XINPUT_GAMEPAD_A) ? 0x80 : 0; // Circle (Steam)/Cross
 441: 		ff8_externals.dinput_gamepad_state->rgbButtons[2] = gamepad.IsPressed(steam_stock_launcher ? XINPUT_GAMEPAD_X : XINPUT_GAMEPAD_B) ? 0x80 : 0; // Square (Steam)/Circle
 442: 		ff8_externals.dinput_gamepad_state->rgbButtons[3] = gamepad.IsPressed(XINPUT_GAMEPAD_Y) ? 0x80 : 0; // Triangle
 443: 		ff8_externals.dinput_gamepad_state->rgbButtons[4] = gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_SHOULDER) ? 0x80 : 0; // L1
 444: 		ff8_externals.dinput_gamepad_state->rgbButtons[5] = gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_SHOULDER) ? 0x80 : 0; // R1
 445: 		ff8_externals.dinput_gamepad_state->rgbButtons[6] = (steam_stock_launcher ? gamepad.IsPressed(XINPUT_GAMEPAD_BACK) : gamepad.leftTrigger > 0.85f) ? 0x80 : 0; // SELECT (Steam)/L2
 446: 		ff8_externals.dinput_gamepad_state->rgbButtons[7] = (steam_stock_launcher ? gamepad.IsPressed(XINPUT_GAMEPAD_START) : gamepad.rightTrigger > 0.85f) ? 0x80 : 0; // START (Steam)/R2
 447: 		ff8_externals.dinput_gamepad_state->rgbButtons[8] = (steam_stock_launcher ? gamepad.leftTrigger > 0.85f : gamepad.IsPressed(XINPUT_GAMEPAD_BACK)) ? 0x80 : 0; // L2 (Steam)/SELECT
 448: 		ff8_externals.dinput_gamepad_state->rgbButtons[9] = (steam_stock_launcher ? gamepad.rightTrigger > 0.85f : gamepad.IsPressed(XINPUT_GAMEPAD_START)) ? 0x80 : 0; // R2 (Steam)/START
 449: 		ff8_externals.dinput_gamepad_state->rgbButtons[10] = gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_THUMB) ? 0x80 : 0; // L3
 450: 		ff8_externals.dinput_gamepad_state->rgbButtons[11] = gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_THUMB) ? 0x80 : 0; // R3
 451: 		ff8_externals.dinput_gamepad_state->rgbButtons[12] = gamepad.IsPressed(0x400) ? 0x80 : 0; // PS Button
 452: 	}
 453: 	else
 454: 	{
 455: 		if (!joystick.Refresh() || !gamehacks.canInputBeProcessed()) return 0;
 456: 
 457: 		if ((joystick.GetState()->lY < joystick.GetDeadZone(-0.5f)) || joystick.GetState()->rgdwPOV[0] == 0)
 458: 		{
 459: 			ff8_externals.dinput_gamepad_state->lY = 0xFFFFFFFFFFFFFFFF;
 460: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 0;
 461: 		}
 462: 		else if ((joystick.GetState()->lY > joystick.GetDeadZone(0.5f)) || joystick.GetState()->rgdwPOV[0] == 18000)
 463: 		{
 464: 			ff8_externals.dinput_gamepad_state->lY = -0xFFFFFFFFFFFFFFFF;
 465: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 18000;
 466: 		}
 467: 
 468: 		if ((joystick.GetState()->lX < joystick.GetDeadZone(-0.5f)) || joystick.GetState()->rgdwPOV[0] == 27000)
 469: 		{
 470: 			ff8_externals.dinput_gamepad_state->lX = 0xFFFFFFFFFFFFFFFF;
 471: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 27000;
 472: 		}
 473: 		else if ((joystick.GetState()->lX > joystick.GetDeadZone(0.5f)) || joystick.GetState()->rgdwPOV[0] == 9000)
 474: 		{
 475: 			ff8_externals.dinput_gamepad_state->lX = -0xFFFFFFFFFFFFFFFF;
 476: 			ff8_externals.dinput_gamepad_state->rgdwPOV[0] = 9000;
 477: 		}
 478: 
 479: 		lY = -int(joystick.GetState()->lY * 0x80 / SHRT_MAX);
 480: 		lX = int(joystick.GetState()->lX * 0x80 / SHRT_MAX);
 481: 		rY = -int(joystick.GetState()->lRy * 0x80 / SHRT_MAX);
 482: 		rX = int(joystick.GetState()->lRx * 0x80 / SHRT_MAX);
 483: 
 484: 		if (joystick.GetState()->lRy < joystick.GetDeadZone(-0.5f))
 485: 			ff8_externals.dinput_gamepad_state->lRy = 0xFFFFFFFFFFFFFFFF;
 486: 		else if (joystick.GetState()->lRy > joystick.GetDeadZone(0.5f))
 487: 			ff8_externals.dinput_gamepad_state->lRy = -0xFFFFFFFFFFFFFFFF;
 488: 
 489: 		if (joystick.GetState()->lRx > joystick.GetDeadZone(0.5f))
 490: 			ff8_externals.dinput_gamepad_state->lRx = -0xFFFFFFFFFFFFFFFF;
 491: 		else if (joystick.GetState()->lRx < joystick.GetDeadZone(-0.5f))
 492: 			ff8_externals.dinput_gamepad_state->lRx = 0xFFFFFFFFFFFFFFFF;
 493: 
 494: 		ff8_externals.dinput_gamepad_state->lZ = 0;
 495: 		ff8_externals.dinput_gamepad_state->lRz = 0;
 496: 		ff8_externals.dinput_gamepad_state->rglSlider[0] = 0;
 497: 		ff8_externals.dinput_gamepad_state->rglSlider[1] = 0;
 498: 		ff8_externals.dinput_gamepad_state->rgdwPOV[1] = -1;
 499: 		ff8_externals.dinput_gamepad_state->rgdwPOV[2] = -1;
 500: 		ff8_externals.dinput_gamepad_state->rgdwPOV[3] = -1;
 501: 		ff8_externals.dinput_gamepad_state->rgbButtons[0] = joystick.GetState()->rgbButtons[0] & 0x80 ? 0x80 : 0; // Square
 502: 		ff8_externals.dinput_gamepad_state->rgbButtons[1] = joystick.GetState()->rgbButtons[1] & 0x80 ? 0x80 : 0; // Cross
 503: 		ff8_externals.dinput_gamepad_state->rgbButtons[2] = joystick.GetState()->rgbButtons[2] & 0x80 ? 0x80 : 0; // Circle
 504: 		ff8_externals.dinput_gamepad_state->rgbButtons[3] = joystick.GetState()->rgbButtons[3] & 0x80 ? 0x80 : 0; // Triangle
 505: 		ff8_externals.dinput_gamepad_state->rgbButtons[4] = joystick.GetState()->rgbButtons[4] & 0x80 ? 0x80 : 0; // L1
 506: 		ff8_externals.dinput_gamepad_state->rgbButtons[5] = joystick.GetState()->rgbButtons[5] & 0x80 ? 0x80 : 0; // R1
 507: 		ff8_externals.dinput_gamepad_state->rgbButtons[6] = joystick.GetState()->rgbButtons[6] & 0x80 ? 0x80 : 0; // L2
 508: 		ff8_externals.dinput_gamepad_state->rgbButtons[7] = joystick.GetState()->rgbButtons[7] & 0x80 ? 0x80 : 0; // R2
 509: 		ff8_externals.dinput_gamepad_state->rgbButtons[8] = joystick.GetState()->rgbButtons[8] & 0x80 ? 0x80 : 0; // SELECT
 510: 		ff8_externals.dinput_gamepad_state->rgbButtons[9] = joystick.GetState()->rgbButtons[9] & 0x80 ? 0x80 : 0; // START
 511: 		ff8_externals.dinput_gamepad_state->rgbButtons[10] = joystick.GetState()->rgbButtons[10] & 0x80 ? 0x80 : 0; // L3
 512: 		ff8_externals.dinput_gamepad_state->rgbButtons[11] = joystick.GetState()->rgbButtons[11] & 0x80 ? 0x80 : 0; // R3
 513: 		ff8_externals.dinput_gamepad_state->rgbButtons[12] = joystick.GetState()->rgbButtons[12] & 0x80 ? 0x80 : 0; // PS Button
 514: 	}
 515: 
 516: 	left_stick_y = -lY + 0x80;
 517: 	if (left_stick_y > 255) left_stick_y = 255;
 518: 	if (left_stick_y < 0) left_stick_y = 0;
 519: 
 520: 	left_stick_x = lX + 0x80;
 521: 	if (left_stick_x > 255) left_stick_x = 255;
 522: 	if (left_stick_x < 0) left_stick_x = 0;
 523: 
 524: 	int mul = (left_stick_x - 128) * (left_stick_x - 128) + (left_stick_y - 128) * (left_stick_y - 128);
 525: 	if (mul < 1600) {
 526: 		left_stick_y = 0x80;
 527: 		left_stick_x = 0x80;
 528: 	}
 529: 
 530: 	right_stick_y = -rY + 0x80;
 531: 	if (right_stick_y > 255) right_stick_y = 255;
 532: 	if (right_stick_y < 0) right_stick_y = 0;
 533: 
 534: 	right_stick_x = rX + 0x80;
 535: 	if (right_stick_x > 255) right_stick_x = 255;
 536: 	if (right_stick_x < 0) right_stick_x = 0;
 537: 
 538: 	mul = (right_stick_x - 128) * (right_stick_x - 128) + (right_stick_y - 128) * (right_stick_y - 128);
 539: 	if (mul < 1600) {
 540: 		right_stick_y = 0x80;
 541: 		right_stick_x = 0x80;
 542: 	}
 543: 
 544: 	return ff8_externals.dinput_gamepad_state;
 545: }
 546: 
 547: int ff8_get_input_device_capabilities_number_of_buttons(int a1)
 548: {
 549: 	return xinput_connected ? 10 : std::min<DWORD>(joystick.GetCaps()->dwButtons, 10);
 550: }
 551: 
 552: int ff8_draw_gamepad_icon_or_keyboard_key(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos, int icon_id, uint16_t x, uint16_t y)
 553: {
 554: 	// Keep the "keys" if it is a keyboard and not a gamepad
 555: 	if (icon_id >= 128 && icon_id < 140)
 556: 	{
 557: 		BYTE is_gamepad = *ff8_externals.engine_gamepad_button_pressed != 0;
 558: 
 559: 		if (is_gamepad)
 560: 		{
 561: 			int val = ((int(*)(int,int,int))ff8_externals.get_command_key)(is_gamepad, icon_id - 128, 0);
 562: 
 563: 			if (val == 0) {
 564: 				val = ((int(*)(int,int,int))ff8_externals.get_command_key)(!is_gamepad, icon_id - 128, 0);
 565: 			}
 566: 
 567: 			int rgbButton = val - 224;
 568: 
 569: 			switch (rgbButton)
 570: 			{
 571: 				case 0: // Cross (Steam)/Square
 572: 					return steam_stock_launcher ? 134 : 135;
 573: 				case 1: // Circle (Steam)/Cross
 574: 					return steam_stock_launcher ? 133 : 134;
 575: 				case 2: // Square (Steam)/Circle
 576: 					return steam_stock_launcher ? 135 : 133;
 577: 				case 3: // Triangle
 578: 					return 132;
 579: 				case 4: // L1
 580: 					return 130;
 581: 				case 5: // R1
 582: 					return 131;
 583: 				case 6: // SELECT (Steam)/L2
 584: 					return steam_stock_launcher ? 136 : 128;
 585: 				case 7: // START (Steam)/R2
 586: 					return steam_stock_launcher ? 139 : 129;
 587: 				case 8: // L2 (Steam)/SELECT
 588: 					return steam_stock_launcher ? 128 : 136;
 589: 				case 9: // R2 (Steam)/START
 590: 					return steam_stock_launcher ? 129 : 139;
 591: 			}
 592: 		}
 593: 
 594: 		((void(*)(int, ff8_draw_menu_sprite_texture_infos*, int, uint16_t, uint16_t))ff8_externals.draw_controller_or_keyboard_icons)(a1, draw_infos, icon_id, x, y);
 595: 
 596: 		return -1;
 597: 	}
 598: 
 599: 	return icon_id;
 600: }
 601: 
 602: unsigned int *ff8_draw_icon_get_icon_sp1_infos(int icon_id, int &states_count)
 603: {
 604: 	int *icon_sp1_data = ((int*(*)())ff8_externals.get_icon_sp1_data)();
 605: 
 606: 	if (icon_id >= icon_sp1_data[0])
 607: 	{
 608: 		states_count = 0;
 609: 
 610: 		return nullptr;
 611: 	}
 612: 
 613: 	states_count = HIWORD(icon_sp1_data[icon_id + 1]);
 614: 
 615: 	return (unsigned int *)((char *)icon_sp1_data + uint16_t(icon_sp1_data[icon_id + 1]));
 616: }
 617: 
 618: ff8_draw_menu_sprite_texture_infos *ff8_draw_icon_or_key(
 619: 	int a1, ff8_draw_menu_sprite_texture_infos *draw_infos,
 620: 	int icon_id, uint16_t x, uint16_t y, int a6, int field10_modifier = 0,
 621: 	bool no_a6_mask = false,
 622: 	bool override_field4_8_with_a6 = false,
 623: 	bool yfix = false
 624: ) {
 625: 	icon_id = ff8_draw_gamepad_icon_or_keyboard_key(a1, draw_infos, icon_id, x, y);
 626: 	if (icon_id < 0)
 627: 	{
 628: 		return draw_infos;
 629: 	}
 630: 
 631: 	int states_count = 0;
 632: 	unsigned int *sp1_section_data = ff8_draw_icon_get_icon_sp1_infos(icon_id, states_count);
 633: 
 634: 	if (sp1_section_data == nullptr)
 635: 	{
 636: 		return draw_infos;
 637: 	}
 638: 
 639: 	for (int i = states_count; i > 0; --i)
 640: 	{
 641: 		draw_infos->field_0 = 0x5000000;
 642: 		draw_infos->field_10 = (sp1_section_data[0] & 0x7CFFFFF) + ((0x3810 + field10_modifier) << 16);
 643: 		if (override_field4_8_with_a6)
 644: 		{
 645: 			draw_infos->field_8 = ((a6 & 0xFFFFFF) | 0x64000000) | (((HIBYTE(a6) >> 1) & 2) << 24);
 646: 			draw_infos->field_4 = ((HIBYTE(a6) & 3) << 5) | 0xE100041E;
 647: 		}
 648: 		else
 649: 		{
 650: 			draw_infos->field_8 = no_a6_mask ? a6 | (((sp1_section_data[0] >> 26) & 2) << 24) : (a6 & 0x3FFFFFF) | (((sp1_section_data[0] >> 26) & 2 | 0x64) << 24);
 651: 			draw_infos->field_4 = (sp1_section_data[0] >> 25) & 0x60 | 0xE100041E;
 652: 		}
 653: 		draw_infos->field_14 = sp1_section_data[1] & 0xFF00FF;
 654: 		draw_infos->x_related = x + (int16_t(sp1_section_data[1]) >> 8);
 655: 		draw_infos->y_related = y + (int32_t(sp1_section_data[1]) >> 24);
 656: 		if (yfix && *ff8_externals.battle_boost_cross_icon_display_1D76604) {
 657: 			*((uint8_t *)draw_infos + 11) |= 2u;
 658: 		}
 659: 		((void(*)(int, ff8_draw_menu_sprite_texture_infos*))ff8_externals.sub_49BB30)(a1, draw_infos);
 660: 		if (!no_a6_mask) {
 661: 			draw_infos += 1;
 662: 		}
 663: 		sp1_section_data += 2;
 664: 	}
 665: 
 666: 	return draw_infos;
 667: }
 668: 
 669: ff8_draw_menu_sprite_texture_infos *ff8_draw_icon_or_key1(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos, int icon_id, uint16_t x, uint16_t y, int a6)
 670: {
 671: 	return ff8_draw_icon_or_key(a1, draw_infos, icon_id, x, y, a6);
 672: }
 673: 
 674: ff8_draw_menu_sprite_texture_infos *ff8_draw_icon_or_key2(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos, int *icon_sp1_data, int icon_id, uint16_t x, uint16_t y)
 675: {
 676: 	return ff8_draw_icon_or_key(a1, draw_infos, icon_id, x, y, *ff8_externals.dword_1D2B808);
 677: }
 678: 
 679: ff8_draw_menu_sprite_texture_infos *ff8_draw_icon_or_key3(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos, int *icon_sp1_data, int icon_id, uint16_t x, uint16_t y, int a6)
 680: {
 681: 	return ff8_draw_icon_or_key(a1, draw_infos, icon_id, x, y, a6, 0, true);
 682: }
 683: 
 684: ff8_draw_menu_sprite_texture_infos *ff8_draw_icon_or_key4(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos, int *icon_sp1_data, int icon_id, uint16_t x, uint16_t y, int a6, int a7)
 685: {
 686: 	return ff8_draw_icon_or_key(a1, draw_infos, icon_id, x, y, a6, a7, false, true);
 687: }
 688: 
 689: ff8_draw_menu_sprite_texture_infos *ff8_draw_icon_or_key5(int a1, ff8_draw_menu_sprite_texture_infos *draw_infos, int icon_id, uint16_t x, uint16_t y, int a6, int a7)
 690: {
 691: 	return ff8_draw_icon_or_key(a1, draw_infos, icon_id, x, y, a6, a7, true, false, true);
 692: }
 693: 
 694: ff8_draw_menu_sprite_texture_infos_short *ff8_draw_icon_or_key6(int a1, ff8_draw_menu_sprite_texture_infos_short *draw_infos, int icon_id, uint16_t x, uint16_t y, int a6, int a7) {
 695: 	// We should not cast like this, but that's what the game does
 696: 	icon_id = ff8_draw_gamepad_icon_or_keyboard_key(a1, reinterpret_cast<ff8_draw_menu_sprite_texture_infos *>(draw_infos), icon_id, x, y);
 697: 	if (icon_id < 0)
 698: 	{
 699: 		return draw_infos;
 700: 	}
 701: 
 702: 	int states_count = 0;
 703: 	unsigned int *sp1_section_data = ff8_draw_icon_get_icon_sp1_infos(icon_id, states_count);
 704: 
 705: 	if (sp1_section_data == nullptr)
 706: 	{
 707: 		return draw_infos;
 708: 	}
 709: 
 710: 	for (int i = states_count; i > 0; --i)
 711: 	{
 712: 		draw_infos->field_0 = 0x4000000;
 713: 		draw_infos->field_C = (sp1_section_data[0] & 0x7CFFFFF) + ((0x3810 + a7) << 16);
 714: 		draw_infos->field_4 = a6 | (((sp1_section_data[0] >> 26) & 2) << 24);
 715: 		draw_infos->field_10 = sp1_section_data[1] & 0xFF00FF;
 716: 		draw_infos->x_related = x + (int16_t(sp1_section_data[1]) >> 8);
 717: 		draw_infos->y_related = y + (sp1_section_data[1] >> 24);
 718: 		((void(*)(int, ff8_draw_menu_sprite_texture_infos_short*))ff8_externals.sub_49FE60)(a1, draw_infos);
 719: 		draw_infos += 1;
 720: 		sp1_section_data += 2;
 721: 	}
 722: 
 723: 	return draw_infos;
 724: }
 725: 
 726: int ff8_is_window_active()
 727: {
 728: 	if (gameHwnd == GetActiveWindow() || ff8_always_capture_input)
 729: 	{
 730: 		ff8_externals.engine_eval_keyboard_gamepad_input();
 731: 		ff8_externals.has_keyboard_gamepad_input();
 732: 
 733: 		if (simulate_OK_button)
 734: 		{
 735: 			// Flag the button OK as pressed
 736: 			ff8_externals.engine_input_confirmed_buttons[1] = ff8_externals.engine_input_valid_buttons[1] = 0x40;
 737: 
 738: 			// End simulation right here before we press this button by mistake in other windows
 739: 			simulate_OK_button = false;
 740: 		}
 741: 	}
 742: 
 743: 	return 0;
 744: }
 745: 
 746: bool ff8_skip_movies()
 747: {
 748: 	uint32_t mode = getmode_cached()->driver_mode;
 749: 
 750: 	if (ff8_externals.movie_object->movie_is_playing)
 751: 	{
 752: 		if (mode == MODE_FIELD)
 753: 		{
 754: 			// Prevent game acting weird or wrong if movie is skipped
 755: 			if (
 756: 				*common_externals.current_field_id == 339 // dosea_2
 757: 			)
 758: 			{
 759: 				return false;
 760: 			}
 761: 
 762: 			// Force last frame for field scripts
 763: 			ff8_externals.movie_object->movie_current_frame = 0xFFFF;
 764: 			(*ff8_externals.savemap_field)->current_frame = 0xFFFF;
 765: 			ff8_externals.sub_5304B0();
 766: 		}
 767: 		else if (mode == MODE_CREDITS)
 768: 		{
 769: 			if (enable_ffmpeg_videos)
 770: 				ff8_stop_movie();
 771: 			else
 772: 				((void(*)())common_externals.stop_movie)();
 773: 		}
 774: 
 775: 		return true;
 776: 	}
 777: 	else
 778: 	{
 779: 		if (mode == MODE_CREDITS)
 780: 		{
 781: 			*ff8_externals.credits_counter = 256;
 782: 			*ff8_externals.credits_loop_state = 18;
 783: 
 784: 			return true;
 785: 		}
 786: 	}
 787: 
 788: 	return false;
 789: }
 790: 
 791: int ff8_opcode_battle(int unk)
 792: {
 793: 	int ret = ff8_opcode_old_battle(unk);
 794: 
 795: 	next_battle_scene_id = *ff8_externals.battle_encounter_id;
 796: 	next_music_is_battle = true;
 797: 
 798: 	return ret;
 799: }
 800: 
 801: int ff8_toggle_battle_field()
 802: {
 803: 	int ret = 0;
 804: 
 805: 	if (gamehacks.wantsBattle()) ret = ff8_externals.sub_47CA90();
 806: 
 807: 	if (ret > 0)
 808: 	{
 809: 		next_battle_scene_id = *ff8_externals.battle_encounter_id;
 810: 		next_music_is_battle = true;
 811: 	}
 812: 
 813: 	return ret;
 814: }
 815: 
 816: int ff8_toggle_battle_worldmap(WORD* battle_id)
 817: {
 818: 	int ret = 0;
 819: 
 820: 	if (gamehacks.wantsBattle()) ret = ff8_externals.sub_541C80(battle_id);
 821: 
 822: 	if (ret > 0)
 823: 	{
 824: 		next_battle_scene_id = *battle_id;
 825: 		next_music_is_battle = true;
 826: 	}
 827: 
 828: 	return ret;
 829: }
 830: 
 831: uint32_t ff8_retry_configured_drive(char* filename, uint8_t* data)
 832: {
 833: 	int32_t res = ff8_externals.sm_pc_read(filename, data);
 834: 
 835: 	if (!res) {
 836: 		char dataDrive[8];
 837: 		char modifiedFilename[MAX_PATH];
 838: 
 839: 		ff8_externals.reg_get_data_drive(dataDrive, 4);
 840: 		dataDrive[7] = '\0'; // For safety
 841: 
 842: 		if (trace_files || trace_all) ffnx_trace("%s: filename=%s, dataDrive=%s, diskDataPath=%s\n", __func__, filename, dataDrive, ff8_externals.disk_data_path);
 843: 
 844: 		if (GetDriveTypeA(dataDrive) == DRIVE_CDROM) {
 845: 			strcpy(modifiedFilename, dataDrive);
 846: 			char* filenameNoDrive = strrchr(filename, ':');
 847: 			if (filenameNoDrive != nullptr) {
 848: 				strncat(modifiedFilename, filenameNoDrive + 1, MAX_PATH);
 849: 
 850: 				if (strncmp(modifiedFilename, filename, MAX_PATH) != 0) {
 851: 					res = ff8_externals.sm_pc_read(modifiedFilename, data);
 852: 
 853: 					if (res) {
 854: 						strncpy(ff8_externals.disk_data_path, dataDrive, 260);
 855: 						strncat(ff8_externals.disk_data_path, "\\", 260);
 856: 
 857: 						if (trace_files || trace_all) ffnx_trace("%s: diskDataPath changed %s\n", __func__, ff8_externals.disk_data_path);
 858: 					}
 859: 				}
 860: 			}
 861: 		}
 862: 	}
 863: 
 864: 	return res;
 865: }
 866: 
 867: uint32_t ff8_credits_main_loop_gfx_begin_scene(uint32_t unknown, struct game_obj *game_object)
 868: {
 869: 	if (drawFFNxLogoFrame(game_object)) {
 870: 		ff8_externals.input_fill_keystate();
 871: 
 872: 		if (((ff8_externals.input_get_keyscan(0, 0) & ff8_externals.input_get_keyscan(1, 0)) & 0xF0) != 0) {
 873: 			stopDrawFFNxLogo();
 874: 		}
 875: 
 876: 		return 0;
 877: 	}
 878: 
 879: 	return common_begin_scene(unknown, game_object);
 880: }
 881: 
 882: int credits_controller_music_play(void *data)
 883: {
 884: 	int ret = ((int(*)(void*))ff8_externals.sdmusicplay)(data);
 885: 
 886: 	intro_credits_music_start_time = highResolutionNow();
 887: 
 888: 	return ret;
 889: }
 890: 
 891: int credits_controller_input_call()
 892: {
 893: 	if (*ff8_externals.credits_counter == 0) {
 894: 		int frameCountAdjusted =
 895: 			intro_credits_frames_between_music_start_and_first_image
 896: 			+ *ff8_externals.credits_current_step_image * intro_credits_adjusted_frames
 897: 			+ intro_credits_fade_frames;
 898: 
 899: 		int realFramesEllapsed = int((60.0 / 1000.0) * (elapsedMicroseconds(intro_credits_music_start_time) / 1000.0));
 900: 		int waitFor = frameCountAdjusted - realFramesEllapsed;
 901: 
 902: 		// Add frames on each image display
 903: 		if (waitFor > 0) {
 904: 			*ff8_externals.credits_current_image_global_counter_start += waitFor;
 905: 		}
 906: 	}
 907: 
 908: 	return ((int(*)())ff8_externals.sub_52FE80)();
 909: }
 910: 
 911: char new_game_text_cache[64] = "";
 912: char load_game_text_cache[64] = "";
 913: 
 914: char *ff8_get_text_cached(int pool_id, int cat_id, int text_id, int a4, char *cache)
 915: {
 916: 	if (*cache == '\0') {
 917: 		memcpy(cache, ((char*(*)(int,int,int,int))ff8_externals.get_text_data)(pool_id, cat_id, text_id, a4), sizeof(new_game_text_cache));
 918: 	}
 919: 
 920: 	return cache;
 921: }
 922: 
 923: char *ff8_get_text_cached_new_game(int pool_id, int cat_id, int text_id, int a4)
 924: {
 925: 	return ff8_get_text_cached(pool_id, cat_id, text_id, a4, new_game_text_cache);
 926: }
 927: 
 928: char *ff8_get_text_cached_load_game(int pool_id, int cat_id, int text_id, int a4)
 929: {
 930: 	return ff8_get_text_cached(pool_id, cat_id, text_id, a4, load_game_text_cache);
 931: }
 932: 
 933: int ff8_create_save_file(int slot, char* save)
 934: {
 935: 	int ret = ((int(*)(int,char*))ff8_externals.create_save_file_sub_4C6E50)(slot, save);
 936: 
 937: 	uint8_t savefile_slot = slot > 1 ? 2 : 1;
 938: 	uint8_t savefile_save = atoi(&save[strlen(save) - 2]) + 1;
 939: 	ffnx_trace("Save: user saved in slot%d_save%02i\n", savefile_slot, savefile_save);
 940: 	metadataPatcher.updateFF8(savefile_slot, savefile_save);
 941: 
 942: 	return ret;
 943: }
 944: 
 945: int ff8_create_save_file_chocobo_world(int unused, int data_source, int offset, size_t size)
 946: {
 947: 	int ret = ((int(*)(int,int,int,size_t))ff8_externals.create_save_chocobo_world_file_sub_4C6620)(unused, data_source, offset, size);
 948: 
 949: 	ffnx_trace("Save: user saved in slot:choco\n");
 950: 	if (ret > 0) metadataPatcher.updateFF8(3, 0);
 951: 
 952: 	return ret;
 953: }
 954: 
 955: int ff8_cardgame_postgame_func_534BC0()
 956: {
 957: 	g_FF8SteamAchievements->unlockPlayTripleTriadAchievement();
 958: 	return ff8_externals.cardgame_func_534BC0();
 959: }
 960: 
 961: void ff8_cardgame_enter_hook_sub_460B60(float a1)
 962: {
 963: 	g_FF8SteamAchievements->initOwnedTripleTriadRareCards(ff8_externals.savemap->triple_triad);
 964: 	((void(*)(float))ff8_externals.sub_460B60)(a1);
 965: }
 966: 
 967: void ff8_cardgame_exit_hook_sub_4972A0()
 968: {
 969: 	g_FF8SteamAchievements->unlockLoserTripleTriadAchievement(ff8_externals.savemap->triple_triad);
 970: 	((void(*)())ff8_externals.sub_4972A0)();
 971: }
 972: 
 973: int ff8_cardgame_add_card_to_squall_original(int card_idx)
 974: {
 975: 	// update known cards
 976: 	if (card_idx >= 77)
 977: 		ff8_externals.savemap->triple_triad.cards_rare[(card_idx - 77) / 8] |= 1 << ((card_idx - 77) % 8);
 978: 	else
 979: 		ff8_externals.savemap->triple_triad.cards[card_idx] |= 0x80u;
 980: 
 981: 	// add card to squall
 982: 	if (card_idx >= 77)
 983: 	{
 984: 		ff8_externals.savemap->triple_triad.card_locations[card_idx - 77] = 240; // SQUALL
 985: 		return 0;
 986: 	}
 987: 	else if ((ff8_externals.savemap->triple_triad.cards[card_idx] & 0x7Fu) >= 100)
 988: 	{
 989: 		return -1;
 990: 	}
 991: 	else
 992: 	{
 993: 		++ff8_externals.savemap->triple_triad.cards[card_idx];
 994: 		return 0;
 995: 	}
 996: }
 997: 
 998: int ff8_cardgame_add_card_to_squall(int card_idx)
 999: {
1000: 	int ret = ff8_cardgame_add_card_to_squall_original(card_idx);
1001: 	g_FF8SteamAchievements->unlockCollectorTripleTriadAchievement(ff8_externals.savemap->triple_triad);
1002: 	return ret;
1003: }
1004: 
1005: int ff8_cardgame_update_card_with_location_original(int card_idx, int card_location)
1006: {
1007: 	if ( card_idx >= 77 )
1008: 	{
1009: 		ff8_externals.savemap->triple_triad.card_locations[card_idx - 77] = card_location;
1010: 		return 0;
1011: 	}
1012: 	else
1013: 	{
1014: 		byte card_value = ff8_externals.savemap->triple_triad.cards[card_idx];
1015: 		if ( card_location == 240 ) // SQUALL location
1016: 		{
1017: 			if ((card_value & 0x7Fu) < 100)
1018: 			{
1019: 				ff8_externals.savemap->triple_triad.cards[card_idx] = card_value + 1;
1020: 				return 0;
1021: 			}
1022: 		}
1023: 		else if ((card_value & 0x7F) != 0)
1024: 		{
1025: 			ff8_externals.savemap->triple_triad.cards[card_idx] = card_value - 1;
1026: 			return 0;
1027: 		}
1028: 		return -1;
1029: 	}
1030: }
1031: 
1032: int ff8_cardgame_update_card_with_location(int card_idx, int card_location)
1033: {
1034: 	int ret = ff8_cardgame_update_card_with_location_original(card_idx, card_location);
1035: 	if (card_location == 240) // Squall location
1036: 	{
1037: 		g_FF8SteamAchievements->unlockCollectorTripleTriadAchievement(ff8_externals.savemap->triple_triad);
1038: 	}
1039: 	return ret;
1040: }
1041: 
1042: int ff8_cardgame_sub_535D00(void* tt_data)
1043: {
1044: 	uint16_t prev_card_wins = ff8_externals.savemap->triple_triad.victory_count;
1045: 	int ret = ff8_externals.cardgame_sub_535D00(tt_data);
1046: 	if (ff8_externals.savemap->triple_triad.victory_count > prev_card_wins)
1047: 	{
1048: 		g_FF8SteamAchievements->increaseCardWinsAndUnlockProfessionalAchievement();
1049: 	}
1050: 	return ret;
1051: }
1052: 
1053: int ff8_field_opcode_CARDGAME(int field_data)
1054: {
1055: 	int ret = ff8_externals.opcode_cardgame(field_data);
1056: 	if (ret == 2) // cardgame exited
1057: 	{
1058: 		uint8_t deck_id = *ff8_externals.cardgame_deck_id_1DCD7AD;
1059: 		int cardgame_result = *(int*)(field_data + 324);
1060: 		if (deck_id == 202 && cardgame_result == 0) // Won against quistis
1061: 		{
1062: 			g_FF8SteamAchievements->unlockCardClubMasterAchievement(ff8_externals.savemap->field);
1063: 		}
1064: 	}
1065: 	return ret;
1066: }
1067: 
1068: void ff8_enable_gf_sub_47E480(int gf_idx)
1069: {
1070: 	ff8_externals.savemap->gfs[gf_idx].exists |= 1u;
1071: 	// NOTE: This function for Diablos is called when starting his battle
1072: 	if (gf_idx != SteamAchievementsFF8::DIABLOS_GF_IDX) {
1073: 		g_FF8SteamAchievements->unlockGuardianForceAchievement(gf_idx);
1074: 	}
1075: }
1076: 
1077: void ff8_update_seed_exp_4C30E0(int seed_lvl)
1078: {
1079: 	ff8_externals.update_seed_exp_4C30E0(seed_lvl);
1080: 	g_FF8SteamAchievements->unlockTopSeedRankAchievement(ff8_externals.savemap->field_header.seedExp);
1081: }
1082: 
1083: int ff8_field_opcode_POPM_W(void* field_data, int memory_offset)
1084: {
1085: 	int ret = ff8_externals.opcode_popm_w(field_data, memory_offset);
1086: 	if (memory_offset == 16) // seed exp
1087: 	{
1088: 		g_FF8SteamAchievements->unlockTopSeedRankAchievement(ff8_externals.savemap->field_header.seedExp);
1089: 	}
1090: 	if (memory_offset == 256 && ff8_externals.savemap->field.game_moment == 3000) // Ragnarok found
1091: 	{
1092: 		g_FF8SteamAchievements->unlockRagnarokAchievement();
1093: 	}
1094: 	return ret;
1095: }
1096: 
1097: int ff8_field_opcode_POPM_B(void* field_data, int memory_offset)
1098: {
1099: 	int ret = ff8_externals.opcode_popm_b(field_data, memory_offset);
1100: 	if (memory_offset == 0x130 || memory_offset == 0x131) // timber maniacs offset
1101: 	{
1102: 		g_FF8SteamAchievements->unlockTimberManiacsAchievement(ff8_externals.savemap->field.timber_maniacs);
1103: 	}
1104: 	return ret;
1105: }
1106: 
1107: int ff8_field_opcode_ADDSEEDLEVEL(void* field_data)
1108: {
1109: 	int ret = ff8_externals.opcode_addseedlevel(field_data);
1110: 	g_FF8SteamAchievements->unlockTopSeedRankAchievement(ff8_externals.savemap->field_header.seedExp);
1111: 	return ret;
1112: }
1113: 
1114: void ff8_field_update_seed_level()
1115: {
1116: 	((void(*)())ff8_externals.field_update_seed_level_52B140)();
1117: 	g_FF8SteamAchievements->unlockTopSeedRankAchievement(ff8_externals.savemap->field_header.seedExp);
1118: 	g_FF8SteamAchievements->unlockMaxGilAchievement(ff8_externals.savemap->gil);
1119: 	g_FF8SteamAchievements->unlockFirstSalaryAchievement();
1120: }
1121: 
1122: void ff8_worldmap_update_seed_level()
1123: {
1124: 	((void(*)())ff8_externals.worldmap_update_seed_level_651C10)();
1125: 	g_FF8SteamAchievements->unlockTopSeedRankAchievement(ff8_externals.savemap->field_header.seedExp);
1126: 	g_FF8SteamAchievements->unlockMaxGilAchievement(ff8_externals.savemap->gil);
1127: 	g_FF8SteamAchievements->unlockFirstSalaryAchievement();
1128: }
1129: 
1130: // Replacing a specific call that is called when player remodel weapon just before assigning the new
1131: // weapon id to the character
1132: int ff8_menu_junkshop_get_char_id_hook_4ABC40(int chars_available_bitmap, int char_idx)
1133: {
1134: 	int char_id = ff8_externals.sub_4ABC40(chars_available_bitmap, char_idx);
1135: 	g_FF8SteamAchievements->initPreviousWeaponIdBeforeUpgrade(char_id, ff8_externals.savemap->chars[char_id].weapon_id);
1136: 	return char_id;
1137: }
1138: 
1139: // Replacing a specific call that is called when player remodel weapon just after assigning the new
1140: // weapon id to the character
1141: int ff8_menu_junkshop_hook_4EA770(int a1, uint32_t a2)
1142: {
1143: 	int ret = ff8_externals.sub_4EA770(a1, a2);
1144: 	g_FF8SteamAchievements->unlockUpgradeWeaponAchievement(*ff8_externals.savemap);
1145: 	return ret;
1146: }
1147: 
1148: // Replacing a call done before computing max HP for a character in order to get the
1149: // index "party_char_id"
1150: void ff8_hook_sub_4954B0(int party_char_id)
1151: {
1152: 	ff8_externals.sub_4954B0(party_char_id);
1153: 	g_FF8SteamAchievements->initStatCharIdUnderStatCompute(party_char_id);
1154: }
1155: 
1156: int ff8_compute_char_max_hp_496310(int multiplier, int char_id)
1157: {
1158: 	int max_hp_mul = ff8_externals.compute_char_max_hp_496310(multiplier, char_id);
1159: 	byte stat_char_id = g_FF8SteamAchievements->getStatCharIdUnderStatCompute();
1160: 	if (stat_char_id != 0xFFu) {
1161: 		int max_hp = ff8_externals.char_comp_stats_1CFF000[stat_char_id].unk3[14] * max_hp_mul / 100;
1162: 		g_FF8SteamAchievements->unlockMaxHpAchievement(max_hp);
1163: 	}
1164: 	return max_hp_mul;
1165: }
1166: 
1167: int ff8_field_opcode_ADDGIL(void* field_data)
1168: {
1169: 	int ret = ff8_externals.opcode_addgil(field_data);
1170: 	g_FF8SteamAchievements->unlockMaxGilAchievement(ff8_externals.savemap->gil);
1171: 	return ret;
1172: }
1173: 
1174: void ff8_menu_shop_sub_4EBE40(byte* menu_data)
1175: {
1176: 	uint16_t menu_op = *(uint16_t*)(menu_data + 16);
1177: 	bool is_menu_sell_buy = ((*ff8_externals.menu_data_1D76A9C) & 0x40) != 0;
1178: 	((void(*)(byte*))ff8_externals.menu_shop_sub_4EBE40)(menu_data);
1179: 	byte is_sell = *(byte*)(menu_data + 70);
1180: 	if (menu_op == 12 && is_menu_sell_buy && is_sell)
1181: 	{
1182: 		uint32_t gil = *(uint32_t*)(menu_data + 40);
1183: 		g_FF8SteamAchievements->unlockMaxGilAchievement(gil);
1184: 	}
1185: }
1186: 
1187: int ff8_battle_menu_add_exp_and_bonus_496CB0(int party_char_id, uint16_t exp)
1188: {
1189: 	byte char_id = *(ff8_externals.character_data_1CFE74C + party_char_id);
1190: 	int ret = ff8_externals.battle_menu_add_exp_and_stat_bonus_496CB0(party_char_id, exp);
1191: 	if (char_id != 0xFF) {
1192: 		int level = ff8_externals.get_char_level_4961D0(ff8_externals.savemap->chars[char_id].exp, char_id);
1193: 		g_FF8SteamAchievements->unlockTopLevelAchievement(level);
1194: 	}
1195: 	if (*ff8_externals.global_battle_encounter_id_1CFF6E0 == SteamAchievementsFF8::DIABLOS_ENCOUNTER_ID) {
1196: 		g_FF8SteamAchievements->unlockGuardianForceAchievement(SteamAchievementsFF8::DIABLOS_GF_IDX);
1197: 	}
1198: 	return ret;
1199: }
1200: 
1201: // Replace a function that is called before increasing the kills of a character
1202: void ff8_battle_after_enemy_kill_sub_494AF0(int party_char_id, int monster_id, int current_actor_second_byte, int a2)
1203: {
1204: 	ff8_externals.battle_sub_494AF0(party_char_id, monster_id, current_actor_second_byte, a2);
1205: 	g_FF8SteamAchievements->increaseKillsAndTryUnlockAchievement();
1206: }
1207: 
1208: int ff8_opcode_drawpoint_sub_4A0850(int a1, int draw_magic_count)
1209: {
1210: 	int ret = ff8_externals.opcode_drawpoint_sub_4A0850(a1, draw_magic_count);
1211: 	g_FF8SteamAchievements->increaseMagicDrawsAndTryUnlockAchievement();
1212: 	return ret;
1213: }
1214: 
1215: void ff8_set_drawpoint_state_52D190(uint8_t drawpoint_id, char value)
1216: {
1217: 	ff8_externals.set_drawpoint_state_521D90(drawpoint_id, value);
1218: 	g_FF8SteamAchievements->increaseMagicDrawsAndTryUnlockAchievement();
1219: }
1220: 
1221: int ff8_battle_get_magic_draw_amount_48FD20(int actor_idx, int monster_id, int magic_id)
1222: {
1223: 	int ret = ff8_externals.battle_get_draw_magic_amount_48FD20(actor_idx, monster_id, magic_id);
1224: 	g_FF8SteamAchievements->increaseMagicStockAndTryUnlockAchievement();
1225: 	return ret;
1226: }
1227: 
1228: char ff8_menu_use_item_sub_4F81F0(int menu_data_pointer)
1229: {
1230: 	uint16_t mode = *(uint16_t*)(menu_data_pointer + 16);
1231: 	char ret = ff8_externals.menu_use_items_sub_4F81F0(menu_data_pointer);
1232: 	if (mode == 111) // Show quistis blue magic unlocked message
1233: 	{
1234: 		g_FF8SteamAchievements->unlockQuistisLimitBreaksAchievement(ff8_externals.savemap->lb.quistis_lb);
1235: 	}
1236: 	return ret;
1237: }
1238: 
1239: int ff8_play_sfx_at_unlock_rinoa_limit_break(int a1, int a2, uint32_t a3, uint32_t a4)
1240: {
1241: 	int ret = ((int(*)(int, int, uint32_t, uint32_t))ff8_externals.sfx_play_to_current_playing_channel)(a1, a2, a3, a4);
1242: 	g_FF8SteamAchievements->unlockRinoaLimitBreaksAchievement(ff8_externals.savemap->lb.angelo_completed_lb);
1243: 	return ret;
1244: }
1245: 
1246: void ff8_obtain_proof_of_omega(int tut_info_id)
1247: {
1248: 	ff8_externals.update_tutorial_info_4AD170(tut_info_id);
1249: 	g_FF8SteamAchievements->unlockOmegaDestroyedAchievement();
1250: }
1251: 
1252: void ff8_battle_after_set_result_to_won_sub_494D40()
1253: {
1254: 	ff8_externals.battle_sub_494D40();
1255: 	if (*ff8_externals.global_battle_encounter_id_1CFF6E0 == 750 && *ff8_externals.battle_result_state_1CFF6E7 == 4) { // Won Pupu encounter
1256: 		g_FF8SteamAchievements->unlockPupuQuestAchievement(ff8_externals.savemap->worldmap.pupu_quest);
1257: 	}
1258: }
1259: 
1260: int ff8_menu_choco_add_item_to_player_47ED00(int item_id, char quantity)
1261: {
1262: 	int ret = ff8_externals.add_item_to_player_sub_47ED00(item_id, quantity);
1263: 	g_FF8SteamAchievements->unlockChocoLootAchievement();
1264: 	return ret;
1265: }
1266: 
1267: void ff8_menu_chocobo_sub_4FF8F0()
1268: {
1269: 	ff8_externals.menu_chocobo_sub_4FF8F0();
1270: 	g_FF8SteamAchievements->unlockTopLevelBokoAchievement(ff8_externals.savemap->choco_world.level);
1271: }
1272: 
1273: int ff8_world_sub_54D7E0(WORD* a1)
1274: {
1275: 	bool obel_quest_was_finished = ff8_externals.savemap->worldmap.obel_quest[2] & 1;
1276: 	int ret = ((int(*)(WORD*))ff8_externals.sub_54D7E0)(a1);
1277: 	if (!obel_quest_was_finished && (ff8_externals.savemap->worldmap.obel_quest[2] & 1))
1278: 	{
1279: 		g_FF8SteamAchievements->unlockObelLakeQuestAchievement();
1280: 	}
1281: 	return ret;
1282: }
1283: 
1284: // NOTE:Re-implementation of the function to add item to player items (sub_47ED00)
1285: // because the original function in FF8 exe code has been completely replaced
1286: int ff8_add_item_to_player(int item_id, char quantity)
1287: {
1288: 	if (!item_id) {
1289: 		return 0;
1290: 	}
1291: 
1292: 	savemap_ff8_item *items = ff8_externals.savemap->items.items;
1293: 	for (int i = 0; i < 198; ++i)
1294: 	{
1295: 		if (items[i].item_id == item_id )
1296: 		{
1297: 			items[i].item_quantity += quantity;
1298: 			if (items[i].item_quantity < 100) {
1299: 				return 0;
1300: 			} else {
1301: 				items[i].item_quantity = 100;
1302: 				return 1;
1303: 			}
1304: 		}
1305: 	}
1306: 
1307: 	int open_slot = 0;
1308: 	for (open_slot = 0; open_slot < 198 && items[open_slot].item_id; open_slot++);
1309: 	if (open_slot >= 198) {
1310: 		return 1;
1311: 	}
1312: 	items[open_slot].item_id = item_id;
1313: 	items[open_slot].item_quantity += quantity;
1314: 	if (items[open_slot].item_quantity < 100) {
1315: 		return 0;
1316: 	} else {
1317: 		items[open_slot].item_quantity = 100;
1318: 		return 1;
1319: 	}
1320: }
1321: 
1322: int ff8_add_item_to_player_wrapper(int item_id, char quantity)
1323: {
1324: 	int ret = ff8_add_item_to_player(item_id, quantity);
1325: 	if (SteamAchievementsFF8::itemIsMagazine(item_id)) {
1326: 		g_FF8SteamAchievements->unlockMagazineAddictAchievement(ff8_externals.savemap->items);
1327: 	}
1328: 	return ret;
1329: }
1330: 
1331: void ff8_menu_shop_update_gil_and_items(int gil)
1332: {
1333: 	bool bought_magazine = false;
1334: 	savemap_ff8_item *items = ff8_externals.savemap->items.items;
1335: 	for (int i = 0; i < 198; ++i)
1336: 	{
1337: 		if (SteamAchievementsFF8::itemIsMagazine(items[i].item_id)
1338: 			&& ff8_externals.menu_shop_staged_items_1D8D058[items[i].item_id] > items[i].item_quantity)
1339: 		{
1340: 			bought_magazine = true;
1341: 			break;
1342: 		}
1343: 	}
1344: 
1345: 	ff8_externals.menu_shop_update_gil_and_items_4EB9F0(gil);
1346: 
1347: 	if (bought_magazine)
1348: 	{
1349: 		g_FF8SteamAchievements->unlockMagazineAddictAchievement(ff8_externals.savemap->items);
1350: 	}
1351: }
1352: 
1353: int ff8_limit_fps()
1354: {
1355: 	static time_t last_gametime;
1356: 	time_t gametime;
1357: 	double framerate = 30.0f;
1358: 
1359: 	struct ff8_game_obj *game_object = (ff8_game_obj *)common_externals.get_game_object();
1360: 	struct game_mode *mode = getmode_cached();
1361: 
1362: 	// For cross music play (vanilla music only)
1363: 	qpc_get_time(&gametime);
1364: 	*ff8_externals.time_volume_change_related_1A78BE0 = (1000.0 / game_object->countspersecond) * qpc_diff_time(&gametime, &last_gametime, nullptr);
1365: 
1366: 	if (ff8_fps_limiter < FPS_LIMITER_60FPS)
1367: 	{
1368: 		switch (mode->driver_mode)
1369: 		{
1370: 		case MODE_BATTLE:
1371: 			if (ff8_fps_limiter < FPS_LIMITER_30FPS) framerate = 15.0f;
1372: 			break;
1373: 		case MODE_CREDITS:
1374: 		case MODE_CARDGAME:
1375: 			framerate = 60.0f;
1376: 			break;
1377: 		}
1378: 	}
1379: 	else
1380: 	{
1381: 		switch (mode->driver_mode)
1382: 		{
1383: 		case MODE_FIELD:
1384: 		case MODE_WORLDMAP:
1385: 		case MODE_BATTLE:
1386: 		case MODE_SWIRL:
1387: 		case MODE_CREDITS:
1388: 			framerate = 60.0f;
1389: 			break;
1390: 		}
1391: 	}
1392: 
1393: 	framerate *= gamehacks.getCurrentSpeedhack();
1394: 	double frame_time = game_object->countspersecond / framerate;
1395: 
1396: 	do qpc_get_time(&gametime);
1397: 	while (gametime > last_gametime && qpc_diff_time(&gametime, &last_gametime, nullptr) < frame_time);
1398: 
1399: 	last_gametime = gametime;
1400: 
1401: 	return 0;
1402: }
1403: 
1404: void* ff8_engine_set_wide_viewport(int x, int y, int w, int h)
1405: {
1406: 	*ff8_externals.current_viewport_x_dword_1A7764C = wide_viewport_x;
1407: 	*ff8_externals.current_viewport_y_dword_1A77648 = wide_viewport_y;
1408: 	*ff8_externals.current_viewport_width_dword_1A77654 = wide_viewport_width;
1409: 	*ff8_externals.current_viewport_height_dword_1A77650 = wide_viewport_height;
1410: 
1411: 	*ff8_externals.ssigpu_viewport_x_dword_1CA89D8 = wide_viewport_x;
1412: 	*ff8_externals.ssigpu_viewport_y_dword_1CA89DC = wide_viewport_y;
1413: 	*ff8_externals.ssigpu_viewport_width_dword_B7CBF8 = wide_viewport_width;
1414: 	*ff8_externals.ssigpu_viewport_height_dword_B7CBFC = wide_viewport_height;
1415: 
1416: 	if ( w >= 540 || h >= 380 )
1417: 	{
1418: 		if ( *ff8_externals.dword_B7CE28 != -1 )
1419: 			*ff8_externals.flag_d3d_renderer_related_dword_1CCFD94 = *ff8_externals.dword_B7CE28;
1420: 	}
1421: 	else
1422: 	{
1423: 		int tmp = *ff8_externals.flag_d3d_renderer_related_dword_1CCFD94;
1424: 		*ff8_externals.flag_d3d_renderer_related_dword_1CCFD94 = 0;
1425: 		*ff8_externals.dword_B7CE28 = tmp;
1426: 	}
1427: 
1428: 	return ff8_externals.engine_setviewport_sub_41E070(wide_viewport_x, wide_viewport_y, wide_viewport_width, wide_viewport_height, common_externals.get_game_object());
1429: }
1430: 
1431: void ff8_widescreen_hook_init() {
1432: 	// Viewport fixes
1433: 	replace_function(ff8_externals.engine_setviewport_sub_45B4C0, ff8_engine_set_wide_viewport);
1434: 
1435: 	// Menu
1436: 	ff8_externals.menu_viewport[2].scale_x = 2.0;
1437: 	ff8_externals.menu_viewport[2].offset_x = -64.0;
1438: }
1439: 
1440: void ff8_init_hooks(struct game_obj *_game_object)
1441: {
1442: 	struct ff8_game_obj *game_object = (struct ff8_game_obj *)_game_object;
1443: 
1444: 	game_object->dddevice = &_fake_dddevice;
1445: 	game_object->front_surface[0] = &_fake_dd_front_surface;
1446: 	game_object->front_surface[1] = &_fake_dd_back_surface;
1447: 	game_object->dd2interface = &_fake_dddevice;
1448: 	game_object->d3d2device = &_fake_d3d2device;
1449: 
1450: 	if (ff8_ssigpu_debug)
1451: 		ff8_externals.show_vram_window();
1452: 
1453: 	replace_function(ff8_externals.engine_eval_process_input, ff8_is_window_active);
1454: 
1455: 	replace_function(ff8_externals.swirl_sub_56D390, swirl_sub_56D390);
1456: 	replace_call(ff8_externals.worldmap_with_fog_sub_53FAC0 + (FF8_US_VERSION ? 0xB3C: (JP_VERSION ? 0xB24 : 0xB2F)), ff8_wm_set_render_to_vram_current_screen_flag_before_battle);
1457: 	replace_call(ff8_externals.swirl_enter + 0x9, ff8_swirl_init);
1458: 
1459: 	replace_function(common_externals.destroy_tex_header, ff8_destroy_tex_header);
1460: 	replace_function(common_externals.load_tex_file, ff8_load_tex_file);
1461: 
1462: 	replace_function(common_externals.open_file, ff8_open_file);
1463: 	replace_call(uint32_t(ff8_externals.fs_archive_search_filename) + 0x10, ff8_fs_archive_search_filename2);
1464: 	replace_call(ff8_externals.moriya_filesystem_open + 0x126, ff8_fs_archive_sub_archive_get_filename);
1465: 	// Open temp.fs/temp.fl/temp.fi
1466: 	replace_call(ff8_externals.moriya_filesystem_open + 0x705, ff8_fs_archive_open_temp);
1467: 	// Search file in temp.fs archive (field)
1468: 	replace_call(ff8_externals.moriya_filesystem_open + 0x776, ff8_fs_archive_search_filename_sub_archive);
1469: 	// Search file in FS archive
1470: 	replace_call(ff8_externals.moriya_filesystem_open + 0x83C, ff8_fs_archive_search_filename_sub_archive);
1471: 	replace_function(ff8_externals._open, ff8_open);
1472: 	replace_function(ff8_externals.fopen, ff8_fopen);
1473: 	replace_call(ff8_externals.moriya_filesystem_close + 0x1F, ff8_fs_archive_free_file_container_sub_archive);
1474: 
1475: 	ff8_read_file = (uint32_t(*)(uint32_t, void *, struct ff8_file *))common_externals.read_file;
1476: 	ff8_close_file = (void (*)(struct ff8_file *))common_externals.close_file;
1477: 
1478: 	// #####################
1479: 	// Adding LZ4 support to FS archives
1480: 	// #####################
1481: 
1482: 	// Insert a call to ff8_fs_archive_patch_compression to pass the compression type
1483: 	// 83 BD D4 FD FF FF 01|0F 84(addrCompre)|E9(addrUnkComp)
1484: 	// 51|E8 (addrPatch)|83 C4 04|E9(addrCompre) 90 90 90 90
1485: 	uint32_t read_or_uncompress_fs_data_jump_to_uncompress = *(uint32_t *)(ff8_externals.read_or_uncompress_fs_data + 0x54 + 2);
1486: 	memcpy_code(ff8_externals.read_or_uncompress_fs_data + 0x4D, "\x51\xE8\x00\x00\x00\x00\x83\xC4\x04\xE9\x00\x00\x00\x00\x90\x90\x90\x90", 18);
1487: 	replace_call(ff8_externals.read_or_uncompress_fs_data + 0x4D + 1, ff8_fs_archive_patch_compression);
1488: 	patch_code_dword(ff8_externals.read_or_uncompress_fs_data + 0x4D + 10, read_or_uncompress_fs_data_jump_to_uncompress - 1);
1489: 	// Obtain the compressed and the uncompressed sizes
1490: 	replace_call(ff8_externals.read_or_uncompress_fs_data + 0x153, ff8_fs_archive_malloc_source_data);
1491: 	replace_call(ff8_externals.read_or_uncompress_fs_data + 0x188, ff8_fs_archive_malloc_target_data);
1492: 	// Replace the LZS algorithm by LZ4 if compression type is 2
1493: 	replace_call(ff8_externals.read_or_uncompress_fs_data + 0x1E6, ff8_fs_archive_uncompress_data);
1494: 
1495: 	memset_code(ff8_externals.movie_hack1, 0x90, 14);
1496: 	memset_code(ff8_externals.movie_hack2, 0x90, 8);
1497: 
1498: 	ff8_externals.d3dcaps[0] = true; // Has DDSCAPS_OVERLAY capability in Hardware Emulation Layer + Enable alpha on textures
1499: 	ff8_externals.d3dcaps[1] = true; // Enable alpha on textures
1500: 	ff8_externals.d3dcaps[2] = false; // Emulate substractive blending via non-paletted texture if enabled
1501: 	ff8_externals.d3dcaps[3] = true; // Seems to divide by 2 one vertex if disabled
1502: 	ff8_externals.d3dcaps[4] = false;
1503: 	*ff8_externals.sub_blending_capability = true;
1504: 	patch_code_byte(ff8_externals.sub_45CDD0 + 0x12, 2); // Force comparison to current driver, to enable substractive blending in field fade in/out
1505: 
1506: 	// Fix save format
1507: 	if (version == VERSION_FF8_12_FR_NV || version == VERSION_FF8_12_SP_NV || version == VERSION_FF8_12_IT_NV)
1508: 	{
1509: 		unsigned char ff8fr_savefix1[] = "\xC0\xEA\x03\x8A\x41\x6D\x80\xE2"
1510: 																		 "\x01\x24\xFE\x0A\xD0\x88\x51\x6D";
1511: 		unsigned char ff8fr_savefix2[] = "\x8A\x50\x6D\xC0\xE9\x03\x80\xE1"
1512: 																		 "\x01\x80\xE2\xFE\x0A\xCA\x88\x48"
1513: 																		 "\x6D";
1514: 
1515: 		memcpy_code(ff8_externals.sub_53BB90 + 0x952, ff8fr_savefix1, sizeof(ff8fr_savefix1) - 1);
1516: 		memcpy_code(ff8_externals.sub_53C750 + 0x8B0, ff8fr_savefix1, sizeof(ff8fr_savefix1) - 1);
1517: 
1518: 		memcpy_code(ff8_externals.sub_544630 + 0xE2, ff8fr_savefix2, sizeof(ff8fr_savefix2) - 1);
1519: 
1520: 		patch_code_byte(ff8_externals.sub_544630 + 0x12F, 0x7D);
1521: 
1522: 		patch_code_byte(ff8_externals.sub_548080 + 0x174, 0x6E);
1523: 		patch_code_byte(ff8_externals.sub_548080 + 0x1A3, 0x6E);
1524: 		patch_code_byte(ff8_externals.sub_548080 + 0x1C7, 0x6E);
1525: 		patch_code_byte(ff8_externals.sub_548080 + 0x1E5, 0x6E);
1526: 
1527: 		patch_code_byte(ff8_externals.sub_549E80 + 0x1CE, 0x6E);
1528: 
1529: 		patch_code_byte(ff8_externals.sub_546100 + 0x952, 0x6D);
1530: 		patch_code_byte(ff8_externals.sub_546100 + 0x9A6, 0x74);
1531: 
1532: 		patch_code_byte(ff8_externals.sub_546100 + 0xA23, 0x7C);
1533: 		patch_code_byte(ff8_externals.sub_546100 + 0xA67, 0x7C);
1534: 		patch_code_byte(ff8_externals.sub_546100 + 0xA90, 0x7C);
1535: 
1536: 		patch_code_byte(ff8_externals.sub_54A0D0 + 0x151, 0x6E);
1537: 
1538: 		patch_code_byte(ff8_externals.sub_54D7E0 + 0xB6, 0x74);
1539: 		patch_code_byte(ff8_externals.sub_54D7E0 + 0xE0, 0x74);
1540: 		patch_code_byte(ff8_externals.sub_54D7E0 + 0x14A, 0x7C);
1541: 
1542: 		patch_code_byte(ff8_externals.sub_54FDA0 + 0x51, 0x70);
1543: 		patch_code_byte(ff8_externals.sub_54FDA0 + 0xB6, 0x70);
1544: 		patch_code_byte(ff8_externals.sub_54FDA0 + 0x17F, 0x70);
1545: 		patch_code_byte(ff8_externals.sub_54FDA0 + 0x1C7, 0x70);
1546: 		patch_code_byte(ff8_externals.sub_54FDA0 + 0x1DB, 0x70);
1547: 	}
1548: 
1549: 	// Update the metadata file when a save file is modified
1550: 	if (steam_edition)
1551: 	{
1552: 		replace_call(ff8_externals.main_menu_controller + (JP_VERSION ? 0x1004 : 0xF8D), ff8_create_save_file);
1553: 		replace_call(ff8_externals.menu_chocobo_world_controller + 0x9F6, ff8_create_save_file_chocobo_world);
1554: 		replace_call(ff8_externals.menu_chocobo_world_controller + (JP_VERSION ? 0xF8D : 0xFA3), ff8_create_save_file_chocobo_world);
1555: 		replace_call(ff8_externals.menu_chocobo_world_controller + (JP_VERSION ? 0x11A5 : 0x11BB), ff8_create_save_file_chocobo_world);
1556: 		replace_call(ff8_externals.menu_chocobo_world_controller + (JP_VERSION ? 0x13D6 : 0x13EC), ff8_create_save_file_chocobo_world);
1557: 	}
1558: 
1559: 	// don't set system speaker config to stereo
1560: 	memset_code(common_externals.directsound_create + 0x6D, 0x90, 34);
1561: 
1562: 	if (ff8_externals.nvidia_hack1)
1563: 		patch_code_double(ff8_externals.nvidia_hack1, 0.0);
1564: 	if (ff8_externals.nvidia_hack2)
1565: 		patch_code_float(ff8_externals.nvidia_hack2, 0.0f);
1566: 
1567: 	memcpy_code(ff8_externals.sub_4653B0 + 0xA5, texture_reload_fix1, sizeof(texture_reload_fix1));
1568: 	replace_function(ff8_externals.sub_4653B0 + 0xA5 + sizeof(texture_reload_fix1), texture_reload_hack1);
1569: 
1570: 	memcpy_code(ff8_externals.sub_465720 + 0xB3, texture_reload_fix2, sizeof(texture_reload_fix2));
1571: 	replace_function(ff8_externals.sub_465720 + 0xB3 + sizeof(texture_reload_fix2), texture_reload_hack2);
1572: 
1573: 	// #####################
1574: 	// new timer calibration
1575: 	// #####################
1576: 
1577: 	// replace time diff
1578: 	replace_function((uint32_t)common_externals.diff_time, qpc_diff_time);
1579: 
1580: 	if (ff8_fps_limiter >= FPS_LIMITER_DEFAULT)
1581: 	{
1582: 		// replace rdtsc timing
1583: 		replace_function((uint32_t)common_externals.get_time, qpc_get_time);
1584: 
1585: 		// override the timer calibration
1586: 		QueryPerformanceFrequency((LARGE_INTEGER *)&game_object->_countspersecond);
1587: 		game_object->countspersecond = (double)game_object->_countspersecond;
1588: 
1589: 		replace_function(ff8_externals.fps_limiter, ff8_limit_fps);
1590: 	}
1591: 
1592: 	// Gamepad
1593: 	replace_function(ff8_externals.dinput_init_gamepad, ff8_init_gamepad);
1594: 	replace_function(ff8_externals.dinput_update_gamepad_status, ff8_update_gamepad_status);
1595: 	replace_function(ff8_externals.dinput_get_input_device_capabilities_number_of_buttons, ff8_get_input_device_capabilities_number_of_buttons);
1596: 
1597: 	if (steam_stock_launcher)
1598: 	{
1599: 		// Create ff8input.cfg with the same default values than the FF8_Launcher
1600: 
1601: 		// When the game starts without ff8input.cfg file
1602: 		patch_code_byte(ff8_externals.input_init + 0x29, 225); // 226 => 225
1603: 		patch_code_byte(ff8_externals.input_init + 0x3C, 224); // 225 => 224
1604: 		patch_code_byte(ff8_externals.input_init + 0x53, 226); // 224 => 226
1605: 		patch_code_byte(ff8_externals.input_init + 0xA7, 232); // 230 => 232
1606: 		patch_code_byte(ff8_externals.input_init + 0xBA, 233); // 231 => 233
1607: 		patch_code_byte(ff8_externals.input_init + 0xD1, 230); // 232 => 230
1608: 		patch_code_byte(ff8_externals.input_init + 0xE4, 231); // 233 => 231
1609: 
1610: 		// When the player reset the controls in the game menu
1611: 		patch_code_byte(ff8_externals.ff8input_cfg_reset + 0xD8, 225); // 226 => 225
1612: 		patch_code_byte(ff8_externals.ff8input_cfg_reset + 0xEB, 224); // 225 => 224
1613: 		patch_code_byte(ff8_externals.ff8input_cfg_reset + 0x102, 226); // 224 => 226
1614: 		patch_code_byte(ff8_externals.ff8input_cfg_reset + 0x156, 232); // 230 => 232
1615: 		patch_code_byte(ff8_externals.ff8input_cfg_reset + 0x169, 233); // 231 => 233
1616: 		patch_code_byte(ff8_externals.ff8input_cfg_reset + 0x180, 230); // 232 => 230
1617: 		patch_code_byte(ff8_externals.ff8input_cfg_reset + 0x193, 231); // 233 => 231
1618: 	}
1619: 
1620: 	// #####################
1621: 	// Analog 360 patch
1622: 	// #####################
1623: 	// Field
1624: 	replace_call(ff8_externals.sub_4789A0 + (JP_VERSION ? 0x320 : 0x336), ff8_get_analog_value); // Test if available
1625: 	replace_call(ff8_externals.sub_4789A0 + (JP_VERSION ? 0x331 : 0x347), ff8_get_analog_value); // lX
1626: 	replace_call(ff8_externals.sub_4789A0 + (JP_VERSION ? 0x345 : 0x35B), ff8_get_analog_value); // lY
1627: 	// Worldmap
1628: 	replace_call(ff8_externals.worldmap_input_update_sub_559240 + (FF8_US_VERSION ? 0xC2 : 0xBF), ff8_get_analog_value_wm); // lX
1629: 	replace_call(ff8_externals.worldmap_input_update_sub_559240 + (FF8_US_VERSION ? 0xD2 : 0xCF), ff8_get_analog_value); // lY
1630: 	replace_call(ff8_externals.worldmap_input_update_sub_559240 + (FF8_US_VERSION ? 0xE2 : 0xDF), ff8_get_analog_value); // rX
1631: 	replace_call(ff8_externals.worldmap_input_update_sub_559240 + (FF8_US_VERSION ? 0xF2 : 0xEF), ff8_get_analog_value); // rY
1632: 
1633: 	// Do not alter worldmap texture UVs (Maki's patch) http://forums.qhimm.com/index.php?topic=16327.0
1634: 	if (FF8_US_VERSION)
1635: 	{
1636: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x180, 0); // +-2 replaced by 0
1637: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x18A, 0);
1638: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x198, 0);
1639: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1A2, 0);
1640: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1B2, 0);
1641: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1BC, 0);
1642: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1CC, 0);
1643: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1D6, 0);
1644: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1E6, 0);
1645: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1F0, 0);
1646: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1F8, 0);
1647: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x202, 0);
1648: 	}
1649: 	else
1650: 	{
1651: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x19F, 0);
1652: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1AA, 0);
1653: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1BB, 0);
1654: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1C6, 0);
1655: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1D9, 0);
1656: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1E4, 0);
1657: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x1F7, 0);
1658: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x202, 0);
1659: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x215, 0);
1660: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x220, 0);
1661: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x229, 0);
1662: 		patch_code_byte(ff8_externals.worldmap_alter_uv_sub_553B40 + 0x234, 0);
1663: 	}
1664: 
1665: 	// #####################
1666: 	// battle toggle
1667: 	// #####################
1668: 	replace_call_function(ff8_externals.sub_4789A0 + (JP_VERSION ? 0x674 : 0x68B), ff8_toggle_battle_field);
1669: 	replace_call_function(ff8_externals.battle_trigger_worldmap, ff8_toggle_battle_worldmap);
1670: 
1671: 	// Allow squaresoft logo skip by pressing a button
1672: 	patch_code_byte(ff8_externals.load_credits_image + 0x5FD, 0); // if (intro_step >= 0) ...
1673: 	// Add FFNx Logo
1674: 	replace_call(ff8_externals.credits_main_loop + 0x6D, ff8_credits_main_loop_gfx_begin_scene);
1675: 	// Fix credits intro synchronization with the music
1676: 	replace_call(ff8_externals.load_credits_image + 0x164, credits_controller_music_play);
1677: 	replace_call(ff8_externals.load_credits_image + 0x305, credits_controller_input_call);
1678: 
1679: 	if (!steam_edition) {
1680: 		// Look again with the DataDrive specified in the register
1681: 		replace_call(ff8_externals.get_disk_number + 0x6E, ff8_retry_configured_drive);
1682: 		replace_call(ff8_externals.cdcheck_sub_52F9E0 + 0x15E, ff8_retry_configured_drive);
1683: 	}
1684: 
1685: 	// Force SFX IDs for Quezacotl
1686: 	patch_code_dword(int(ff8_externals.vibrate_data_summon_quezacotl) - 16, 240030); // 240030 - 240000 + 370 = ID 400
1687: 	patch_code_dword(int(ff8_externals.vibrate_data_summon_quezacotl) - 12, 240033); // 240033 - 240000 + 370 = ID 403
1688: 	patch_code_dword(int(ff8_externals.vibrate_data_summon_quezacotl) - 8, 240036); // 240036 - 240000 + 370 = ID 406
1689: 	patch_code_dword(int(ff8_externals.vibrate_data_summon_quezacotl) - 4, 240039); // 240039 - 240000 + 370 = ID 409
1690: 
1691: 	if (!FF8_US_VERSION && !JP_VERSION) {
1692: 		// Fix "New Game" and "Load Game" texts converted to "Doomtrain" and "Alexander" when starting a new game
1693: 		replace_call(ff8_externals.main_menu_render_sub_4E5550 + 0x203, ff8_get_text_cached_new_game);
1694: 		replace_call(ff8_externals.main_menu_render_sub_4E5550 + 0x222, ff8_get_text_cached_load_game);
1695: 	}
1696: 
1697: 	if (ff8_use_gamepad_icons) {
1698: 		// Replace the whole function to conditionnally show PlayStation icons or keyboard keys
1699: 		replace_function(ff8_externals.ff8_draw_icon_or_key1, ff8_draw_icon_or_key1);
1700: 		replace_function(ff8_externals.ff8_draw_icon_or_key2, ff8_draw_icon_or_key2);
1701: 		replace_function(ff8_externals.ff8_draw_icon_or_key3, ff8_draw_icon_or_key3);
1702: 		replace_function(ff8_externals.ff8_draw_icon_or_key4, ff8_draw_icon_or_key4);
1703: 		replace_function(ff8_externals.ff8_draw_icon_or_key5, ff8_draw_icon_or_key5);
1704: 		replace_function(ff8_externals.ff8_draw_icon_or_key6, ff8_draw_icon_or_key6);
1705: 	}
1706: 
1707: 	// All possible message and ask windows
1708: 	ff8_opcode_old_battle = (int (*)(int))ff8_externals.opcode_battle;
1709: 	patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x69], (DWORD)&ff8_opcode_battle);
1710: 
1711: 	//###############################
1712: 	// steam achievement unlock calls
1713: 	//###############################
1714: 	if(steam_edition || enable_steam_achievements)
1715: 	{
1716: 		// triple triad
1717: 		patch_code_dword((uint32_t)&ff8_externals.cardgame_funcs[4], (uint32_t)&ff8_cardgame_postgame_func_534BC0);
1718: 		replace_call(ff8_externals.sub_534640 + 0x8D, (void*)ff8_cardgame_enter_hook_sub_460B60);
1719: 		replace_call(ff8_externals.sub_534640 + 0x51, (void*)ff8_cardgame_exit_hook_sub_4972A0);
1720: 		replace_function(ff8_externals.cardgame_add_card_to_squall_534840, (void*)ff8_cardgame_add_card_to_squall);
1721: 		replace_function(ff8_externals.cardgame_update_card_with_location_5347F0, (void*)ff8_cardgame_update_card_with_location);
1722: 		patch_code_dword(ff8_externals.cargame_func_535C90 + 0x19, (uint32_t)&ff8_cardgame_sub_535D00);
1723: 
1724: 		// cc master
1725: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x13A], (uint32_t)&ff8_field_opcode_CARDGAME);
1726: 
1727: 		// guardian forces
1728: 		replace_function(ff8_externals.enable_gf_sub_47E480, (void*)ff8_enable_gf_sub_47E480);
1729: 
1730: 		// seed rank A (also max GIL)
1731: 		replace_call(ff8_externals.menu_sub_4D4D30 + (JP_VERSION ? 0x929 : 0x928), (void*)ff8_update_seed_exp_4C30E0);
1732: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x0D], (uint32_t)&ff8_field_opcode_POPM_W);
1733: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x153], (uint32_t)&ff8_field_opcode_ADDSEEDLEVEL);
1734: 		replace_call(common_externals.update_field_entities + 0x120, (void*)ff8_field_update_seed_level);
1735: 		replace_call(ff8_externals.worldmap_update_steps_sub_6519D0 + 0x152, (void*)ff8_worldmap_update_seed_level);
1736: 
1737: 		// handyman: upgrade weapon
1738: 		replace_call(ff8_externals.menu_junkshop_sub_4EA890 + (JP_VERSION ? 0x5F0 : 0x5C1), (void*)ff8_menu_junkshop_get_char_id_hook_4ABC40);
1739: 		replace_call(ff8_externals.menu_junkshop_sub_4EA890 + (JP_VERSION ? 0x63A : 0x60B), (void*)ff8_menu_junkshop_hook_4EA770);
1740: 
1741: 		// max HP
1742: 		replace_call(ff8_externals.compute_char_stats_sub_495960 + 0x68, (void*)ff8_hook_sub_4954B0);
1743: 		replace_call(ff8_externals.compute_char_stats_sub_495960 + 0x94, (void*)ff8_compute_char_max_hp_496310);
1744: 
1745: 		// max GIL
1746: 		replace_call((uint32_t)ff8_externals.menu_callbacks[11].func + 0x1F0, (void*)ff8_menu_shop_sub_4EBE40);
1747: 		patch_code_dword((uint32_t)ff8_externals.menu_callbacks[11].func + 0x39, (uint32_t)ff8_menu_shop_sub_4EBE40);
1748: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x151], (uint32_t)&ff8_field_opcode_ADDGIL);
1749: 
1750: 		// max LEVEL
1751: 		replace_call(ff8_externals.battle_menu_sub_4A3EE0 + 0x581, (void*)ff8_battle_menu_add_exp_and_bonus_496CB0);
1752: 
1753: 		// kills
1754: 		replace_call(ff8_externals.battle_sub_494410 + 0x525, (void*)ff8_battle_after_enemy_kill_sub_494AF0);
1755: 
1756: 		// draw magic from draw points
1757: 		replace_call(ff8_externals.opcode_drawpoint + 0x6B7, (void*)ff8_opcode_drawpoint_sub_4A0850);
1758: 		replace_call(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x845 : 0x85F), (void*)ff8_set_drawpoint_state_52D190);
1759: 
1760: 		// draw magic via stock in battle
1761: 		replace_call(ff8_externals.battle_sub_48D200 + (FF8_US_VERSION ? 0x354 : (JP_VERSION ? 0x36F : 0x355)), (void*)ff8_battle_get_magic_draw_amount_48FD20);
1762: 
1763: 		// timber maniacs
1764: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x0B], (uint32_t)&ff8_field_opcode_POPM_B);
1765: 
1766: 		// quistis blue magics
1767: 		replace_call((uint32_t)ff8_externals.menu_callbacks[2].func + 0x152, (void*)ff8_menu_use_item_sub_4F81F0);
1768: 		patch_code_dword((uint32_t)ff8_externals.menu_callbacks[2].func + 0x8, (uint32_t)ff8_menu_use_item_sub_4F81F0);
1769: 
1770: 		// dog trainer rinoa
1771: 		replace_call(ff8_externals.field_update_rinoa_limit_breaks_52B320 + 0x5D, (void*)ff8_play_sfx_at_unlock_rinoa_limit_break);
1772: 		replace_call(ff8_externals.worldmap_update_steps_sub_6519D0 + 0x225, (void*)ff8_play_sfx_at_unlock_rinoa_limit_break);
1773: 
1774: 		// omega destroyed
1775: 		replace_call(ff8_externals.battle_ai_opcode_sub_487DF0 + (FF8_US_VERSION ? 0x216C : (JP_VERSION ? 0x2148 : 0x2176)), (void*)ff8_obtain_proof_of_omega);
1776: 
1777: 		// pupu side quest
1778: 		replace_call(ff8_externals.battle_check_won_sub_486500 + 0x66, (void*)ff8_battle_after_set_result_to_won_sub_494D40);
1779: 
1780: 		// chocobo world
1781: 		replace_call(ff8_externals.menu_chocobo_world_controller + (JP_VERSION ? 0x17FE : 0x1814), (void*)ff8_menu_choco_add_item_to_player_47ED00);
1782: 		replace_call(ff8_externals.menu_chocobo_world_controller + (JP_VERSION ? 0x13BA : 0x13D0), (void*)ff8_menu_chocobo_sub_4FF8F0);
1783: 		// chocobo achievement is implemented in aask opcode (voice section)
1784: 
1785: 		// magazine addict
1786: 		replace_function((uint32_t)ff8_externals.add_item_to_player_sub_47ED00, (void*)ff8_add_item_to_player_wrapper);
1787: 		replace_call(ff8_externals.menu_shop_sub_4EBE40 + 0x11A7, (void*)ff8_menu_shop_update_gil_and_items);
1788: 
1789: 		// obel lake quest
1790: 		replace_call(ff8_externals.worldmap_with_fog_sub_53FAC0 + (FF8_US_VERSION ? 0x3C2 : 0x3C4), (void*)ff8_world_sub_54D7E0);
1791: 	}
1792: 
1793: 	// #####################
1794: 	// widescreen / uncrop
1795: 	// #####################
1796: 	if(widescreen_enabled)
1797: 		ff8_widescreen_hook_init();
1798: }
1799: 
1800: struct ff8_gfx_driver *ff8_load_driver(void* _game_object)
1801: {
1802: 	struct ff8_gfx_driver *ret = (ff8_gfx_driver *)external_calloc(1, sizeof(*ret));
1803: 
1804: 	ret->init = common_init;
1805: 	ret->cleanup = common_cleanup;
1806: 	ret->lock = common_lock;
1807: 	ret->unlock = common_unlock;
1808: 	ret->flip = common_flip;
1809: 	ret->clear = common_clear;
1810: 	ret->clear_all= common_clear_all;
1811: 	ret->setviewport = common_setviewport;
1812: 	ret->setbg = common_setbg;
1813: 	ret->prepare_polygon_set = common_prepare_polygon_set;
1814: 	ret->load_group = common_externals.generic_load_group;
1815: 	ret->setmatrix = common_setmatrix;
1816: 	ret->unload_texture = common_unload_texture;
1817: 	ret->load_texture = common_load_texture;
1818: 	ret->field_54 = ff8gl_field_54;
1819: 	ret->field_58 = ff8gl_field_58;
1820: 	ret->field_5C = ff8gl_field_5C;
1821: 	ret->field_60 = ff8gl_field_60;
1822: 	ret->palette_changed = common_palette_changed;
1823: 	ret->write_palette = common_write_palette;
1824: 	ret->blendmode = common_blendmode;
1825: 	ret->light_polygon_set = common_light_polygon_set;
1826: 	ret->field_64 = common_field_64;
1827: 	ret->setrenderstate = common_setrenderstate;
1828: 	ret->_setrenderstate = common_setrenderstate;
1829: 	ret->__setrenderstate = common_setrenderstate;
1830: 	ret->field__84 = ff8gl_field_84;
1831: 	ret->field_88 = ff8gl_field_88;
1832: 	ret->field_74 = common_field_74;
1833: 	ret->field_78 = common_field_78;
1834: 	ret->draw_deferred = common_draw_deferred;
1835: 	ret->field_80 = common_field_80;
1836: 	ret->field_84 = common_field_84;
1837: 	ret->begin_scene = common_begin_scene;
1838: 	ret->end_scene = common_end_scene;
1839: 	ret->field_90 = common_field_90;
1840: 	ret->setrenderstate_flat2D = common_setrenderstate_2D;
1841: 	ret->setrenderstate_smooth2D = common_setrenderstate_2D;
1842: 	ret->setrenderstate_textured2D = common_setrenderstate_2D;
1843: 	ret->setrenderstate_paletted2D = common_setrenderstate_2D;
1844: 	ret->_setrenderstate_paletted2D = common_setrenderstate_2D;
1845: 	ret->draw_flat2D = common_draw_2D;
1846: 	ret->draw_smooth2D = common_draw_2D;
1847: 	ret->draw_textured2D = common_draw_2D;
1848: 	ret->draw_paletted2D = common_draw_paletted2D;
1849: 	ret->setrenderstate_flat3D = common_setrenderstate_3D;
1850: 	ret->setrenderstate_smooth3D = common_setrenderstate_3D;
1851: 	ret->setrenderstate_textured3D = common_setrenderstate_3D;
1852: 	ret->setrenderstate_paletted3D = common_setrenderstate_3D;
1853: 	ret->_setrenderstate_paletted3D = common_setrenderstate_3D;
1854: 	ret->draw_flat3D = common_draw_3D;
1855: 	ret->draw_smooth3D = common_draw_3D;
1856: 	ret->draw_textured3D = common_draw_3D;
1857: 	ret->draw_paletted3D = common_draw_paletted3D;
1858: 	ret->setrenderstate_flatlines = common_setrenderstate_2D;
1859: 	ret->setrenderstate_smoothlines = common_setrenderstate_2D;
1860: 	ret->draw_flatlines = common_draw_lines;
1861: 	ret->draw_smoothlines = common_draw_lines;
1862: 	ret->field_EC = common_field_EC;
1863: 
1864: 	return ret;
1865: }
</file>

<file path="src/ff8.h">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2020 Marcin Gomulak                                     //
   9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  10: //                                                                          //
  11: //    This file is part of FFNx                                             //
  12: //                                                                          //
  13: //    FFNx is free software: you can redistribute it and/or modify          //
  14: //    it under the terms of the GNU General Public License as published by  //
  15: //    the Free Software Foundation, either version 3 of the License         //
  16: //                                                                          //
  17: //    FFNx is distributed in the hope that it will be useful,               //
  18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  20: //    GNU General Public License for more details.                          //
  21: /****************************************************************************/
  22: 
  23: #pragma once
  24: 
  25: #include <cstdint>
  26: #include <span>
  27: #include <stdint.h>
  28: #include <stdio.h>
  29: #include <windows.h>
  30: #include <ddraw.h>
  31: #include <dinput.h>
  32: 
  33: #include "common_imports.h"
  34: #include "ff8/save_data.h"
  35: 
  36: // FF7 modules, unknowns are either unused or not relevant to rendering
  37: enum ff8_game_modes
  38: {
  39: 	FF8_MODE_CREDITS = 0,
  40: 	FF8_MODE_FIELD,
  41: 	FF8_MODE_WORLDMAP,
  42: 	FF8_MODE_SWIRL,
  43: 	FF8_MODE_AFTER_BATTLE,
  44: 	FF8_MODE_5,
  45: 	FF8_MODE_MENU,
  46: 	FF8_MODE_7,
  47: 	FF8_MODE_CARDGAME, // And battle
  48: 	FF8_MODE_9,
  49: 	FF8_MODE_TUTO,
  50: 	FF8_MODE_11,
  51: 	FF8_MODE_INTRO,
  52: 	FF8_MODE_100 = 100,
  53: 	FF8_MODE_MAIN_MENU = 200,
  54: 	FF8_MODE_BATTLE = 999
  55: };
  56: 
  57: /*
  58:  * This section defines some structures used internally by the FF8 game engine.
  59:  *
  60:  * Documentation for some of them can be found on the Qhimm wiki, a lot of
  61:  * information can be gleaned from the source code to this program but in many
  62:  * cases nothing is known except the size and general layout of the structure.
  63:  *
  64:  * Variable and structure names are mostly based on what they contain rather
  65:  * than what they are for, a lot of names may be wrong, inappropriate or
  66:  * downright misleading. Thread with caution!
  67:  */
  68: 
  69: struct wm_polygon_source
  70: {
  71: 	WORD unknown1;
  72: 	WORD unknown2;
  73: 	WORD unknown3;
  74: 	unsigned char u0;
  75: 	unsigned char v0;
  76: 	unsigned char u1;
  77: 	unsigned char v1;
  78: 	unsigned char u2;
  79: 	unsigned char v2;
  80: };
  81: 
  82: struct ssigpu_packet52
  83: {
  84: 	uint32_t unknown1;
  85: 	unsigned char b0;
  86: 	unsigned char g0;
  87: 	unsigned char r0;
  88: 	unsigned char command;
  89: 	WORD y0;
  90: 	WORD x0;
  91: 	unsigned char v0;
  92: 	unsigned char u0;
  93: 	WORD clut;
  94: 	unsigned char b1;
  95: 	unsigned char g1;
  96: 	unsigned char r1;
  97: 	unsigned char unused1;
  98: 	WORD y1;
  99: 	WORD x1;
 100: 	unsigned char v1;
 101: 	unsigned char u1;
 102: 	WORD texture;
 103: 	unsigned char b2;
 104: 	unsigned char g2;
 105: 	unsigned char r2;
 106: 	unsigned char unused2;
 107: 	WORD y2;
 108: 	WORD x2;
 109: 	unsigned char v2;
 110: 	unsigned char u2;
 111: 	WORD unused3;
 112: };
 113: 
 114: struct psxvram_rect
 115: {
 116: 	WORD x;
 117: 	WORD y;
 118: 	WORD w;
 119: 	WORD h;
 120: };
 121: 
 122: struct sprite_viewport
 123: {
 124: 	float width;
 125: 	float height;
 126: 	float field_8;
 127: 	float field_C;
 128: 	float scale_x;
 129: 	float scale_y;
 130: 	float offset_x;
 131: 	float offset_y;
 132: };
 133: 
 134: struct font_object
 135: {
 136: 	uint32_t dummy1[0x12];
 137: 	struct ff8_graphics_object *font_a;
 138: 	struct ff8_graphics_object *font_b;
 139: };
 140: 
 141: struct struc_38
 142: {
 143: 	uint32_t field_0;
 144: 	uint32_t field_4;
 145: 	uint32_t field_8;
 146: 	uint32_t field_C;
 147: 	uint32_t field_10;
 148: 	uint32_t field_14;
 149: 	uint32_t field_18;
 150: 	uint32_t field_1C;
 151: 	uint32_t field_20;
 152: 	struct ff8_graphics_object *graphics_object;
 153: };
 154: 
 155: struct ff8_file_fi_infos
 156: {
 157: 	int size;
 158: 	int pos;
 159: 	int compression;
 160: };
 161: 
 162: struct ff8_file_context
 163: {
 164: 	int mode; // 0= _O_BINARY, 1= _O_TEXT, 2= _O_BINARY | _O_CREAT | _O_RDWR, 3= _O_BINARY | _O_CREAT | _O_TRUNC | _O_RDWR
 165: 	int field_4;
 166: 	char* field_8;
 167: 	void (*filename_callback)(const char*, char*);
 168: 	struct ff8_file_container* file_container;
 169: };
 170: 
 171: struct ff8_file_fl
 172: {
 173: 	int file_count;
 174: 	char **filenames_pointers;
 175: 	int filenames_data_size;
 176: 	char* filenames_data;
 177: 	int callback;
 178: };
 179: 
 180: struct ff8_file
 181: {
 182: 	int is_open;
 183: 	const char* filename;
 184: 	int fd;
 185: 	struct ff8_file_context file_context;
 186: 	int field_20;
 187: 	int current_pos;
 188: 	struct ff8_file_fi_infos fi_infos;
 189: 	struct ff8_file_container* file_container;
 190: };
 191: 
 192: struct ff8_file_container
 193: {
 194: 	int initialized;
 195: 	int first_fi_info_position;
 196: 	struct ff8_file* fs_disk_file_metadata;
 197: 	struct ff8_file_fl* fl_infos;
 198: 	struct ff8_file_fi_infos* fi_infos;
 199: };
 200: 
 201: struct ff8_indexed_vertices
 202: {
 203: 	uint32_t field_0;
 204: 	uint32_t field_4;
 205: 	uint32_t count;
 206: 	uint32_t vertexcount;
 207: 	uint32_t field_10;
 208: 	struct nvertex *vertices;
 209: 	uint32_t indexcount;
 210: 	uint32_t field_1C;
 211: 	WORD *indices;
 212: 	uint32_t field_24;
 213: 	unsigned char *palettes;
 214: 	struct ff8_graphics_object *graphics_object;
 215: };
 216: 
 217: struct ff8_graphics_object
 218: {
 219: 	uint32_t type;
 220: 	uint32_t field_4;
 221: 	uint32_t field_8;
 222: 	uint32_t has_texture_set;
 223: 	struct p_hundred *hundred_data;
 224: 	struct matrix_set *matrix_set;
 225: 	struct polygon_set *polygon_set;
 226: 	uint32_t is_tim_header;
 227: 	uint32_t field_20;
 228: 	uint32_t field_24;
 229: 	float u_offset;
 230: 	float v_offset;
 231: 	void *dx_sfx_2C;
 232: 	void *tex_info_filename_and_more;
 233: 	uint32_t field_38;
 234: 	uint32_t vertices_per_shape;
 235: 	uint32_t indices_per_shape;
 236: 	uint32_t vertex_offset;
 237: 	uint32_t index_offset;
 238: 	uint32_t field_4C;
 239: 	uint32_t field_50;
 240: 	uint32_t field_54;
 241: 	uint32_t field_58;
 242: 	uint32_t field_5C;
 243: 	uint32_t field_60;
 244: 	uint32_t field_64;
 245: 	uint32_t field_68;
 246: 	uint32_t field_6C;
 247: 	uint32_t field_70;
 248: 	uint32_t field_74;
 249: 	uint32_t field_78;
 250: 	uint32_t field_7C;
 251: 	uint32_t field_80;
 252: 	uint32_t field_84;
 253: 	uint32_t field_88;
 254: 	uint32_t field_8C;
 255: 	struct ff8_indexed_vertices *indexed_vertices;
 256: 	uint32_t field_94;
 257: 	uint32_t field_98;
 258: 	gfx_polysetrenderstate* setrenderstate;
 259: 	gfx_draw_vertices* draw;
 260: 	uint32_t use_matrix_pointer;
 261: 	struct matrix* matrix_pointer;
 262: 	struct matrix matrix;
 263: };
 264: 
 265: struct ff8_polygon_set
 266: {
 267: 	uint32_t field_0;
 268: 	uint32_t field_4;
 269: 	uint32_t field_8;
 270: 	uint32_t field_C;
 271: 	uint32_t field_10;
 272: 	uint32_t numgroups;
 273: 	struct struc_49 field_14;
 274: 	uint32_t field_2C;
 275: 	struct polygon_data *polygon_data;
 276: 	struct p_hundred *hundred_data;
 277: 	uint32_t per_group_hundreds;
 278: 	struct p_hundred **hundred_data_group_array;
 279: 	struct matrix_set *matrix_set;
 280: 	uint32_t field_44;
 281: 	uint32_t field_48;
 282: 	void *execute_buffers;			// IDirect3DExecuteBuffer **
 283: 	struct indexed_primitive **indexed_primitives;
 284: 	uint32_t field_54;
 285: 	uint32_t field_58;
 286: 	struct p_group *polygon_group_array;
 287: 	// unknown up to 0xB0
 288: };
 289: 
 290: struct ff8_tex_header
 291: {
 292: 	uint32_t version;
 293: 	uint32_t field_4;
 294: 	uint32_t color_key;
 295: 	uint32_t field_C;
 296: 	uint32_t field_10;
 297: 	union
 298: 	{
 299: 		struct
 300: 		{
 301: 			uint32_t minbitspercolor;
 302: 			uint32_t maxbitspercolor;
 303: 			uint32_t minalphabits;
 304: 			uint32_t maxalphabits;
 305: 		} v1_1;
 306: 
 307: 		struct
 308: 		{
 309: 			uint32_t x;
 310: 			uint32_t y;
 311: 			uint32_t w;
 312: 			uint32_t h;
 313: 		} fb_tex;
 314: 	};
 315: 	union
 316: 	{
 317: 		struct
 318: 		{
 319: 			uint32_t minbitsperpixel;
 320: 			uint32_t maxbitsperpixel;
 321: 		} v1_2;
 322: 
 323: 		struct
 324: 		{
 325: 			char *psx_name;
 326: 			char *pc_name;
 327: 		} file;
 328: 	};
 329: 	uint32_t field_2C;
 330: 	uint32_t palettes;					// ?
 331: 	uint32_t palette_entries;			// ?
 332: 	uint32_t bpp;
 333: 	struct texture_format tex_format;
 334: 	uint32_t use_palette_colorkey;
 335: 	char *palette_colorkey;
 336: 	uint32_t reference_alpha;
 337: 	uint32_t blend_mode;
 338: 	uint32_t field_CC;
 339: 	uint32_t palette_index;
 340: 	uint32_t field_D4;
 341: 	unsigned char *image_data;
 342: 	unsigned char *old_palette_data;
 343: 	uint32_t field_DC;
 344: 	uint32_t field_E0;
 345: 	uint32_t *vram_positions;
 346: 	uint32_t y;
 347: };
 348: 
 349: struct ff8_texture_set
 350: {
 351: 	union
 352: 	{
 353: 		struct
 354: 		{
 355: 			void *ddsurface1;
 356: 			void *d3d2texture1;
 357: 			void *ddsurface2;
 358: 			void *d3d2texture2;
 359: 		} d3d;
 360: 
 361: 		struct
 362: 		{
 363: 			uint32_t external;
 364: 			struct gl_texture_set *gl_set;
 365: 			uint32_t width;
 366: 			uint32_t height;
 367: 		} ogl;
 368: 	};
 369: 
 370: 	uint32_t field_10;
 371: 	uint32_t field_14;
 372: 	uint32_t refcount;
 373: 	uint32_t field_1C;
 374: 	uint32_t field_20;
 375: 	uint32_t field_24;
 376: 	uint32_t field_28;
 377: 	uint32_t field_2C;
 378: 	uint32_t field_30;
 379: 	uint32_t field_34;
 380: 	uint32_t field_38;
 381: 	uint32_t field_3C;
 382: 	uint32_t field_40;
 383: 	uint32_t field_44;
 384: 	uint32_t field_48;
 385: 	uint32_t field_4C;
 386: 	uint32_t field_50;
 387: 	uint32_t field_54;
 388: 	uint32_t field_58;
 389: 	uint32_t field_5C;
 390: 	uint32_t field_60;
 391: 	uint32_t field_64;
 392: 	uint32_t field_68;
 393: 	uint32_t field_6C;
 394: 	uint32_t field_70;
 395: 	uint32_t field_74;
 396: 	uint32_t field_78;
 397: 	uint32_t dummy1[5];
 398: 	uint32_t *texturehandle;
 399: 	struct texture_format *texture_format;
 400: 	struct tex_header *tex_header;
 401: 	uint32_t palette_index;
 402: 	struct palette *palette;
 403: 	uint32_t field_90;
 404: 	uint32_t field_94;
 405: 	uint32_t field_98;
 406: 	uint32_t field_9C;
 407: };
 408: 
 409: struct struc_color_texture {
 410: 		uint32_t field_0;
 411: 		uint8_t r;
 412: 		uint8_t g;
 413: 		uint8_t b;
 414: 		uint8_t _padding;
 415: 		int16_t x;
 416: 		int16_t y;
 417: 		int16_t w;
 418: 		int16_t h;
 419: };
 420: 
 421: struct texture_page
 422: {
 423: 	uint32_t field_0;
 424: 	uint32_t x;
 425: 	uint32_t y;
 426: 	uint32_t width;
 427: 	uint32_t height;
 428: 	uint32_t color_key;
 429: 	float u;
 430: 	float v;
 431: 	uint32_t field_20;
 432: 	struct ff8_graphics_object *tri_gfxobj;
 433: 	struct ff8_graphics_object *quad_gfxobj;
 434: 	struct ff8_graphics_object *noblend_tri_gfxobj;
 435: 	struct ff8_graphics_object *noblend_quad_gfxobj;
 436: 	struct ff8_graphics_object *avg_tri_gfxobj;
 437: 	struct ff8_graphics_object *avg_quad_gfxobj;
 438: 	struct ff8_graphics_object *add_tri_gfxobj;
 439: 	struct ff8_graphics_object *add_quad_gfxobj;
 440: 	struct ff8_graphics_object *sub_tri_gfxobj;
 441: 	struct ff8_graphics_object *sub_quad_gfxobj;
 442: 	struct ff8_graphics_object *mode3_tri_gfxobj;
 443: 	struct ff8_graphics_object *mode3_quad_gfxobj;
 444: 	struct ff8_tex_header *tex_header;
 445: 	char *image_data;
 446: 	struct ff8_tex_header* sub_tex_header;
 447: 	char* sub_image_data;
 448: };
 449: 
 450: struct struc_50
 451: {
 452: 	uint32_t initialized;
 453: 	struct texture_page texture_page[8];
 454: 	uint32_t texture_page_enabled;
 455: 	uint32_t field_328;
 456: 	uint32_t vram_needs_reload;
 457: 	uint32_t palette_index;
 458: 	char dummy[256];
 459: 	uint32_t vram_x;
 460: 	uint32_t vram_y;
 461: 	uint32_t vram_width;
 462: 	uint32_t vram_height;
 463: 	uint16_t *vram_palette_data;
 464: 	uint16_t vram_palette_pos; // 10-bit | 6-bit
 465: 	uint16_t padding;
 466: };
 467: 
 468: struct struc_51
 469: {
 470: 	struct struc_50 struc_50_array[32];
 471: };
 472: 
 473: struct ff8_tim
 474: {
 475: 	uint16_t img_x;
 476: 	uint16_t img_y;
 477: 	uint16_t img_w;
 478: 	uint16_t img_h;
 479: 	uint8_t *img_data;
 480: 	uint16_t pal_x;
 481: 	uint16_t pal_y;
 482: 	uint16_t pal_w;
 483: 	uint16_t pal_h;
 484: 	uint16_t *pal_data;
 485: };
 486: 
 487: struct ff8_camdata
 488: {
 489: 	// EYE
 490: 	int16_t eye_x;
 491: 	int16_t eye_y;
 492: 	int16_t eye_z;
 493: 	// TARGET
 494: 	int16_t target_x;
 495: 	int16_t target_y;
 496: 	int16_t target_z;
 497: 	// UP
 498: 	int16_t up_x;
 499: 	int16_t up_y;
 500: 	int16_t up_z;
 501: 	// FILLER?
 502: 	int16_t padding;
 503: 	// POSITION
 504: 	int32_t pos_x;
 505: 	int32_t pos_y;
 506: 	int32_t pos_z;
 507: 	// PAN
 508: 	int16_t pan_x;
 509: 	int16_t pan_y;
 510: 	// ZOOM
 511: 	int16_t zoom;
 512: 	// FILLER?
 513: 	int16_t padding2;
 514: 	// CONTROL
 515: 	uint8_t flag;
 516: 	// MARKER 'END'
 517: 	uint8_t end[3];
 518: };
 519: 
 520: struct ff8_movie_obj
 521: {
 522: 	WORD movie_current_frame;
 523: 	WORD movie_total_frames;
 524: 	uint32_t movie_surface_height;
 525: 	void *bink_struct;
 526: 	struct ff8_camdata *camdata_start;
 527: 	unsigned char camdata_buffer[312320];
 528: 	unsigned char movie_surface_desc[0x7C];
 529: 	void *movie_back_surface;
 530: 	uint32_t movie_surface_x;
 531: 	struct ff8_camdata *camdata_pointer;
 532: 	uint32_t movie_surface_y;
 533: 	void *movie_dd_surface;
 534: 	struct ff8_game_obj *movie_game_object;
 535: 	uint32_t movie_intro_pak;
 536: 	uint32_t movie_is_playing;
 537: 	uint32_t field_4C4AC;
 538: 	uint32_t field_4C4B0;
 539: 	uint32_t field_4C4B4;
 540: 	uint32_t movie_resolution;
 541: 	HANDLE movie_file_handle;
 542: 	uint32_t bink_copy_flags;
 543: };
 544: 
 545: struct ff8_win_obj
 546: {
 547: 	uint32_t x;
 548: 	uint32_t y;
 549: 	char *text_data1;
 550: 	char *text_data2;
 551: 	uint16_t field_10;
 552: 	uint16_t field_12;
 553: 	uint16_t field_14;
 554: 	uint8_t field_16;
 555: 	uint8_t field_17;
 556: 	uint8_t win_id;
 557: 	uint8_t field_19;
 558: 	uint16_t mode1;
 559: 	int16_t open_close_transition;
 560: 	int16_t field_1E;
 561: 	uint32_t field_20;
 562: 	uint32_t state;
 563: 	uint8_t field_28;
 564: 	uint8_t first_question;
 565: 	uint8_t last_question;
 566: 	uint8_t current_choice_question;
 567: 	uint8_t field_2C;
 568: 	uint8_t field_2D;
 569: 	uint8_t field_2E;
 570: 	uint8_t field_2F;
 571: 	uint16_t field_30;
 572: 	uint8_t field_32;
 573: 	uint8_t field_33;
 574: 	uint32_t callback1;
 575: 	uint32_t callback2;
 576: };
 577: 
 578: struct ff8_gamepad_vibration_state_entry {
 579: 	uint8_t analog_disabled;
 580: 	uint8_t analog_flags;
 581: 	int16_t keyscan;
 582: 	uint8_t analog_rx;
 583: 	uint8_t analog_ry;
 584: 	uint8_t analog_lx;
 585: 	uint8_t analog_ly;
 586: 	int16_t field_8;
 587: 	int16_t field_A;
 588: 	int16_t field_C;
 589: 	int16_t field_E;
 590: 	int16_t keyon;
 591: 	int16_t keyscan_invert;
 592: };
 593: 
 594: struct ff8_gamepad_vibration_state {
 595: 	uint8_t field_0;
 596: 	uint8_t field_1;
 597: 	uint8_t field_2;
 598: 	uint8_t field_3;
 599: 	uint16_t field_4;
 600: 	uint8_t right_motor_speed;
 601: 	uint8_t left_motor_speed;
 602: 	uint8_t field_8;
 603: 	uint8_t field_9;
 604: 	uint8_t vibration_active;
 605: 	uint8_t vibration_capable;
 606: 	uint8_t field_C[4];
 607: 	uint8_t field_10[4];
 608: 	uint32_t field_14;
 609: 	uint8_t entries_offset;
 610: 	uint8_t field_19;
 611: 	uint8_t field_1A;
 612: 	uint8_t vibrate_option_enabled;
 613: 	ff8_gamepad_vibration_state_entry entries[8];
 614: 	uint32_t field_BC;
 615: 	uint16_t field_C0;
 616: 	uint8_t port_id;
 617: 	uint8_t gamepad_options; // is_enabled (1-bit) | u40 | u20 | u10 | u8 | analog sensitivity (1 to 4, 3-bits)
 618: };
 619: 
 620: struct ff8_driver_input_state {
 621: 	ff8_gamepad_vibration_state_entry entry;
 622: 	uint32_t field_14;
 623: 	uint32_t field_18;
 624: 	uint32_t field_1C;
 625: 	uint32_t field_20;
 626: };
 627: 
 628: struct ff8_gamepad_state {
 629: 	ff8_gamepad_vibration_state state_by_port[2];
 630: 	ff8_driver_input_state driver_state_by_port[2];
 631: };
 632: 
 633: struct ff8_vibrate_motor_struc
 634: {
 635: 	uint8_t *data_start;
 636: 	uint8_t *data_end;
 637: 	int16_t counter;
 638: 	uint16_t data_size;
 639: 	uint8_t enabled;
 640: 	uint8_t padding_D;
 641: 	uint8_t padding_E;
 642: 	uint8_t padding_F;
 643: };
 644: 
 645: struct ff8_vibrate_struc
 646: {
 647: 	ff8_vibrate_motor_struc sub_struc_left;
 648: 	ff8_vibrate_motor_struc sub_struc_right;
 649: 	uint16_t field_20;
 650: 	uint8_t intensity;
 651: 	uint8_t field_23;
 652: };
 653: 
 654: struct ff8_menu_config_input {
 655: 	int16_t text_id_name;
 656: 	uint16_t text_id_value1;
 657: 	uint16_t text_id_value2;
 658: 	uint16_t type;
 659: 	uint16_t mask;
 660: 	uint16_t value;
 661: 	void(*callback_change_state)();
 662: };
 663: 
 664: struct ff8_menu_config_input_keymap {
 665: 	uint8_t field_0;
 666: 	uint8_t field_1;
 667: 	uint8_t field_2;
 668: 	uint8_t field_3;
 669: 	uint8_t text_id;
 670: 	uint8_t padd_5;
 671: 	uint8_t padd_6;
 672: 	uint8_t padd_7;
 673: };
 674: 
 675: struct ff8_draw_menu_sprite_texture_infos {
 676: 	uint32_t field_0;
 677: 	uint32_t field_4;
 678: 	uint32_t field_8;
 679: 	uint16_t x_related;
 680: 	uint16_t y_related;
 681: 	uint32_t field_10;
 682: 	uint32_t field_14;
 683: };
 684: 
 685: struct ff8_draw_menu_sprite_texture_infos_short {
 686: 	uint32_t field_0;
 687: 	uint32_t field_4;
 688: 	uint16_t x_related;
 689: 	uint16_t y_related;
 690: 	uint32_t field_C;
 691: 	uint32_t field_10;
 692: };
 693: 
 694: struct ff8_audio_fmt
 695: {
 696: 	uint32_t length;
 697: 	uint32_t offset;
 698: 	uint8_t loop;
 699: 	uint8_t count;
 700: 	uint8_t unk1;
 701: 	uint8_t unk2;
 702: 	uint32_t loop_start;
 703: 	uint32_t loop_end;
 704: 	LPWAVEFORMATEX wave_format;
 705: };
 706: 
 707: struct ff8_game_obj
 708: {
 709: 	uint32_t do_quit;
 710: 	uint32_t dc_horzres;
 711: 	uint32_t dc_vertres;
 712: 	uint32_t dc_bitspixel;
 713: 	uint32_t field_10;
 714: 	uint32_t field_14;
 715: 	uint32_t field_18;
 716: 	uint32_t field_1C;
 717: 	uint32_t field_20;
 718: 	uint32_t field_24;
 719: 	uint32_t field_28;
 720: 	uint32_t field_2C;
 721: 	double countspersecond;
 722: 	time_t _countspersecond;
 723: 	uint32_t field_40;
 724: 	uint32_t field_44;
 725: 	double fps;
 726: 	uint32_t tsc;
 727: 	uint32_t field_54;					// tsc high bits?
 728: 	HINSTANCE hinstance;
 729: 	HWND hwnd;
 730: 	uint32_t field_60;
 731: 	uint32_t field_64;
 732: 	uint32_t field_68;
 733: 	uint32_t field_6C;
 734: 	uint32_t field_70;
 735: 	void *dddevice;
 736: 	void *dd2interface;
 737: 	void *front_surface[3];
 738: 	DDSURFACEDESC front_surface_desc[3];
 739: 	uint32_t field_1CC;
 740: 	uint32_t field_1D0;
 741: 	IDirectDrawClipper* dd_clipper;
 742: 	uint32_t field_1D8;
 743: 	DDSURFACEDESC d3d_surfacedesc;
 744: 	void *dd_interface;
 745: 	uint32_t field_24C;
 746: 	DDSURFACEDESC dd_surfacedesc;
 747: 	struct list *d3ddev_list;
 748: 	void *d3dinterface;
 749: 	void *surface_d3ddev;			// IDirect3DDevice
 750: 	struct list *textureformat_list;
 751: 	void *d3ddev_struct;
 752: 	void *d3dviewport;
 753: 	void *d3dmaterial;
 754: 	uint32_t field_2D8;
 755: 	void *d3d2interface;
 756: 	uint32_t dummy1[0xD];
 757: 	void *d3d2device;
 758: 	void *d3dviewport2;
 759: 	uint32_t dummy2[0x6];
 760: 	struct list *list_2E8;
 761: 	struct polygon_set *polygon_set_2EC;
 762: 	struct polygon_set *polygon_set_2F0;
 763: 	struct stack *matrix_stack1;
 764: 	struct stack *matrix_stack2;
 765: 	struct matrix *camera_matrix;
 766: 	struct graphics_instance *graphics_instance;
 767: 	uint32_t field_304;
 768: 	uint32_t field_308;
 769: 	uint32_t field_30C;
 770: 	uint32_t field_310;
 771: 	uint32_t field_314;
 772: 	uint32_t field_318;
 773: 	uint32_t field_31C;
 774: 	uint32_t field_320;
 775: 	D3DDEVICEDESC d3d_halcaps;
 776: 	D3DDEVICEDESC d3d_helcaps;
 777: 	DDCAPS_DX5 halcaps;
 778: 	DDCAPS_DX5 helcaps;
 779: 	uint32_t dummy3[0xD];
 780: 	uint32_t field_794;
 781: 	uint32_t field_798;
 782: 	struct texture_format surface_tex_format;
 783: 	uint32_t in_scene;
 784: 	struct p_hundred *hundred_array[5];
 785: 	void *applog_debug1;
 786: 	uint32_t applog_debug2;
 787: 	void *dxdbg_file;
 788: 	uint32_t field_840;
 789: 	uint32_t field_844;
 790: 	uint32_t _res_x;
 791: 	uint32_t _res_y;
 792: 	uint32_t _res_w;
 793: 	uint32_t _res_h;
 794: 	uint32_t field_858;
 795: 	uint32_t field_85C;
 796: 	uint32_t field_860;
 797: 	uint32_t field_864;
 798: 	uint32_t field_868;
 799: 	uint32_t field_86C;
 800: 	uint32_t field_870;
 801: 	uint32_t field_874;
 802: 	uint32_t field_878;
 803: 	uint32_t field_87C;
 804: 	uint32_t field_880;
 805: 	uint32_t field_884;
 806: 	uint32_t field_888;
 807: 	uint32_t field_88C;
 808: 	struct matrix matrix_890;
 809: 	struct matrix matrix_8D0;
 810: 	void *dx_sfx_something;
 811: 	struct list *tex_list_pointer;
 812: 	struct stack *stack_918;
 813: 	uint32_t field_91C;
 814: 	void *_3d2d_something;
 815: 	uint32_t field_924;
 816: 	uint32_t field_928;
 817: 	uint32_t field_92C;
 818: 	uint32_t field_930;
 819: 	uint32_t dummy4[0x30];
 820: 	struct gfx_driver *gfx_driver;
 821: 	void *_3dobject_pool;
 822: 	uint32_t field_93C;
 823: 	struct p_hundred *current_hundred;
 824: 	struct struc_81 *field_944;
 825: 	uint32_t field_948;
 826: 	uint32_t field_94C;
 827: 	uint32_t field_950;
 828: 	uint32_t window_width;
 829: 	uint32_t window_height;
 830: 	uint32_t colordepth;
 831: 	uint32_t field_960;
 832: 	uint32_t is_fullscreen;
 833: 	uint32_t field_968;
 834: 	uint32_t no_hardware;
 835: 	uint32_t field_970;
 836: 	uint32_t show_cursor;
 837: 	uint32_t colorkey;
 838: 	uint32_t field_97C;
 839: 	uint32_t field_980;
 840: 	uint32_t d3d2_flag;
 841: 	uint32_t field_988;
 842: 	uint32_t field_98C;
 843: 	uint32_t field_990;
 844: 	uint32_t field_994;
 845: 	uint32_t matrix_stack_size;
 846: 	uint32_t field_99C;
 847: 	uint32_t field_9A0;
 848: 	uint32_t field_9A4;
 849: 	uint32_t field_9A8;
 850: 	uint32_t field_9AC;
 851: 	uint32_t random_seed;
 852: 	char *window_title;
 853: 	char *window_class;
 854: 	uint32_t use_custom_wndclass;
 855: 	WNDCLASSA wndclass_struct;
 856: 	uint32_t use_custom_dwStyle;
 857: 	DWORD dwStyle;
 858: 	struct main_obj engine_loop_obj;
 859: 	struct main_obj game_loop_obj;
 860: 	void *wm_activate;
 861: 	uint32_t field_A2C;
 862: 	uint32_t field_A30;
 863: 	uint32_t field_A34;
 864: 	uint32_t field_A38;
 865: 	uint32_t field_A3C;
 866: 	uint32_t field_A40;
 867: 	uint32_t field_A44;
 868: 	uint32_t field_A48;
 869: 	uint32_t field_A4C;
 870: 	uint32_t field_A50;
 871: 	uint32_t gfx_reset;
 872: 	uint32_t field_A58;
 873: 	uint32_t field_A5C;
 874: 	uint32_t dummy5[2];
 875: 	uint32_t current_gfx_driver;
 876: 	uint32_t field_A64;
 877: 	uint32_t field_A68;
 878: 	uint32_t field_A6C;
 879: 	uint32_t field_A70;
 880: 	uint32_t field_A74;
 881: 	uint32_t field_A78;
 882: 	void *gfx_driver_data;
 883: 	uint32_t field_A80;
 884: 	uint32_t field_A84;
 885: 	void *create_gfx_driver;
 886: 	uint32_t field_BD4;
 887: 	uint32_t field_BD8;
 888: 	uint32_t field_BDC;
 889: 	uint32_t field_BE0;
 890: 	uint32_t field_BE4;
 891: 	uint32_t field_BE8;
 892: 	uint32_t no_8bit_textures;
 893: 	uint32_t field_BF0;
 894: 	uint32_t tnt_fix;
 895: 	uint32_t field_BF8;
 896: 	uint32_t field_BFC;
 897: 	uint32_t field_C00;
 898: 	uint32_t field_C04;
 899: 	uint32_t field_C08;
 900: 	uint32_t field_C0C;
 901: };
 902: 
 903: struct ff8_gfx_driver
 904: {
 905: 	gfx_init *init;
 906: 	gfx_cleanup *cleanup;
 907: 	gfx_lock *lock;
 908: 	gfx_unlock *unlock;
 909: 	gfx_flip *flip;
 910: 	gfx_clear *clear;
 911: 	gfx_clear_all *clear_all;
 912: 	gfx_setviewport *setviewport;
 913: 	gfx_setbg *setbg;
 914: 	uint32_t field_24;
 915: 	struct bgra_color field_28;			// ?
 916: 	uint32_t field_38;
 917: 	uint32_t field_3C;
 918: 	gfx_prepare_polygon_set *prepare_polygon_set;
 919: 	gfx_load_group *load_group;
 920: 	gfx_setmatrix *setmatrix;
 921: 	gfx_unload_texture *unload_texture;
 922: 	gfx_load_texture *load_texture;
 923: 	void *field_54;
 924: 	void *field_58;
 925: 	void *field_5C;
 926: 	void *field_60;
 927: 	gfx_palette_changed *palette_changed;
 928: 	gfx_write_palette *write_palette;
 929: 	gfx_blendmode *blendmode;
 930: 	gfx_light_polygon_set *light_polygon_set;
 931: 	gfx_field_64 *field_64;
 932: 	gfx_setrenderstate *setrenderstate;
 933: 	gfx_setrenderstate *_setrenderstate;
 934: 	gfx_setrenderstate *__setrenderstate;
 935: 	gfx_field_74 *field_74;
 936: 	gfx_field_78 *field_78;
 937: 	void *field__84;
 938: 	void *field_88;
 939: 	gfx_draw_deferred *draw_deferred;
 940: 	gfx_field_80 *field_80;
 941: 	gfx_field_84 *field_84;
 942: 	gfx_begin_scene *begin_scene;
 943: 	gfx_end_scene *end_scene;
 944: 	gfx_field_90 *field_90;
 945: 	gfx_polysetrenderstate *setrenderstate_flat2D;
 946: 	gfx_polysetrenderstate *setrenderstate_smooth2D;
 947: 	gfx_polysetrenderstate *setrenderstate_textured2D;
 948: 	gfx_polysetrenderstate *setrenderstate_paletted2D;
 949: 	gfx_polysetrenderstate *_setrenderstate_paletted2D;
 950: 	gfx_draw_vertices *draw_flat2D;
 951: 	gfx_draw_vertices *draw_smooth2D;
 952: 	gfx_draw_vertices *draw_textured2D;
 953: 	gfx_draw_vertices *draw_paletted2D;
 954: 	gfx_polysetrenderstate *setrenderstate_flat3D;
 955: 	gfx_polysetrenderstate *setrenderstate_smooth3D;
 956: 	gfx_polysetrenderstate *setrenderstate_textured3D;
 957: 	gfx_polysetrenderstate *setrenderstate_paletted3D;
 958: 	gfx_polysetrenderstate *_setrenderstate_paletted3D;
 959: 	gfx_draw_vertices *draw_flat3D;
 960: 	gfx_draw_vertices *draw_smooth3D;
 961: 	gfx_draw_vertices *draw_textured3D;
 962: 	gfx_draw_vertices *draw_paletted3D;
 963: 	gfx_polysetrenderstate *setrenderstate_flatlines;
 964: 	gfx_polysetrenderstate *setrenderstate_smoothlines;
 965: 	gfx_draw_vertices *draw_flatlines;
 966: 	gfx_draw_vertices *draw_smoothlines;
 967: 	gfx_field_EC *field_EC;
 968: };
 969: 
 970: struct ff8_field_state_common {
 971: 	uint8_t stack_data[0x140];
 972: 	uint32_t field_140;
 973: 	uint32_t field_144;
 974: 	uint32_t field_148;
 975: 	uint32_t field_14c;
 976: 	uint32_t field_150;
 977: 	uint32_t field_154;
 978: 	uint32_t field_158;
 979: 	uint32_t field_15c;
 980: 	uint32_t execution_flags; // bgdraw: 0x10, bganime/rbganime: 0x980 (0x800: animation ongoing)
 981: 	uint32_t field_164;
 982: 	uint32_t field_168;
 983: 	uint32_t field_16c;
 984: 	uint32_t field_170;
 985: 	uint8_t field_174; // has anim?
 986: 	uint8_t field_175; // has anim mask?
 987: 	uint16_t current_instruction_position; // field_176
 988: 	uint32_t field_178;
 989: 	uint32_t field_17c;
 990: 	uint32_t field_180;
 991: 	uint8_t stack_current_position; // field_184
 992: 	uint8_t field_185;
 993: 	uint8_t field_186;
 994: 	uint8_t field_187;
 995: };
 996: 
 997: struct ff8_field_state_background {
 998: 	ff8_field_state_common common;
 999: 	uint16_t bgstate; // field_188, set to -1 if off
1000: 	uint16_t field_18a;
1001: 	uint16_t bgparam_anim_start; // field_18c
1002: 	uint16_t bgparam_anim_end; // field_18e
1003: 	uint16_t bgparam_anim_speed1; // field_190
1004: 	uint16_t bgparam_anim_speed2; // field_192
1005: 	uint16_t bgparam_anim_flags; // field_194
1006: 	uint16_t field_196;
1007: 	uint32_t field_198;
1008: 	uint16_t bgshadeloop_remember_stack_pointer; // field_19c
1009: 	uint16_t bgshade_add_value; // field_19e
1010: 	uint16_t field_1a0; // bgshadeloop
1011: 	uint16_t field_1a2; // bgshadeloop
1012: 	uint8_t field_1a4; // bgshadeloop
1013: 	uint8_t field_1a5; // bgshadeloop
1014: 	uint8_t field_1a6; // bgshadeloop
1015: 	uint8_t bgshade_color1r; // field_1a7
1016: 	uint8_t bgshade_color1g; // field_1a8
1017: 	uint8_t bgshade_color1b; // field_1a9
1018: 	uint8_t bgshade_color2r; // field_1aa
1019: 	uint8_t bgshade_color2g; // field_1ab
1020: 	uint8_t bgshade_color2b; // field_1ac
1021: 	uint8_t bgshade_color1r_2; // field_1ad
1022: 	uint8_t bgshade_color1g_2; // field_1ae
1023: 	uint8_t bgshade_color1b_2; // field_1af
1024: 	uint8_t bgshade_color2r_2; // field_1b0
1025: 	uint8_t bgshade_color2g_2; // field_1b1
1026: 	uint8_t bgshade_color2b_2; // field_1b2
1027: 	uint8_t field_1b3;
1028: };
1029: 
1030: struct ff8_char_computed_stats {
1031: 	uint8_t unk1[370];
1032: 	uint16_t curr_hp;
1033: 	uint16_t max_hp;
1034: 	uint8_t unk2[66];
1035: 	uint8_t stat_multiplier;
1036: 	uint8_t unk3[23];
1037: };
1038: 
1039: struct ff8_menu_callback {
1040: 	void (*func)(int);
1041: 	uint32_t field_4;
1042: };
1043: 
1044: // --------------- end of FF8 imports ---------------
1045: 
1046: // memory addresses and function pointers from FF8.exe
1047: struct ff8_externals
1048: {
1049: 	struct font_object **fonts;
1050: 	uint32_t movie_hack1;
1051: 	uint32_t movie_hack2;
1052: 	uint32_t swirl_sub_56D390;
1053: 	uint32_t nvidia_hack1;
1054: 	uint32_t nvidia_hack2;
1055: 	struct sprite_viewport *sprite_viewport; // 0xB86D40
1056: 	struct sprite_viewport *menu_viewport; // 0xB86DA0
1057: 	uint32_t main_loop; // 0x4706B0
1058: 	uint32_t sub_47CCB0;
1059: 	uint32_t sub_534640;
1060: 	uint32_t sub_4972A0;
1061: 	uint32_t load_fonts;
1062: 	uint32_t cdcheck_main_loop;
1063: 	uint32_t cdcheck_sub_52F9E0;
1064: 	uint32_t main_entry;
1065: 	uint8_t *config_worldmap_fog_disabled;
1066: 	uint8_t *config_worldmap_color_anim_disabled;
1067: 	uint8_t *config_worldmap_textured_anim_disabled;
1068: 	uint32_t init_config;
1069: 	uint32_t (*reg_get_data_drive)(char*, DWORD);
1070: 	void (*set_game_paths)(int, char *, const char *);
1071: 	uint32_t (*sm_pc_read)(char*,void*);
1072: 	uint32_t get_disk_number;
1073: 	char* disk_data_path;
1074: 	const char *app_path;
1075: 	uint32_t swirl_enter;
1076: 	uint32_t swirl_main_loop;
1077: 	uint32_t sub_460B60;
1078: 	uint32_t field_main_loop;
1079: 	uint32_t field_main_exit;
1080: 	uint32_t psxvram_texture_pages_free;
1081: 	uint32_t psxvram_texture_page_free;
1082: 	uint32_t psxvram_texture_page_tex_header_free;
1083: 	uint32_t engine_set_init_time;
1084: 	uint32_t sub_4672C0;
1085: 	uint32_t sub_471F70;
1086: 	uint32_t field_fade_transition_sub_472990;
1087: 	uint32_t sub_45CDD0;
1088: 	uint32_t sub_4767B0;
1089: 	uint32_t sub_4789A0;
1090: 	char (*sub_47CA90)();
1091: 	uint32_t field_update_seed_level_52B140;
1092: 	uint32_t field_update_rinoa_limit_breaks_52B320;
1093: 	uint32_t battle_trigger_field;
1094: 	uint32_t battle_trigger_worldmap;
1095: 	uint32_t _load_texture;
1096: 	uint32_t sub_4076B6;
1097: 	uint32_t sub_41AC34;
1098: 	uint32_t load_texture_data;
1099: 	uint32_t pubintro_init;
1100: 	uint32_t sub_467C00;
1101: 	uint32_t sub_468810;
1102: 	uint32_t dinput_get_input_device_capabilities_number_of_buttons;
1103: 	uint32_t get_command_key;
1104: 	uint32_t sub_468BD0;
1105: 	uint32_t pubintro_cleanup;
1106: 	uint32_t pubintro_enter_main;
1107: 	uint32_t pubintro_exit;
1108: 	uint32_t pubintro_main_loop;
1109: 	uint32_t credits_main_loop;
1110: 	uint32_t go_to_main_menu_main_loop;
1111: 	uint32_t main_menu_enter;
1112: 	uint32_t main_menu_main_loop;
1113: 	DWORD* credits_loop_state;
1114: 	DWORD* credits_counter;
1115: 	DWORD* credits_current_image_global_counter_start;
1116: 	DWORD* credits_current_step_image;
1117: 	uint32_t sub_470630;
1118: 	uint32_t dd_d3d_start;
1119: 	uint32_t create_d3d_gfx_driver;
1120: 	uint32_t d3d_init;
1121: 	uint32_t sub_40BFEB;
1122: 	uint32_t tim2tex;
1123: 	uint32_t sub_41BC76;
1124: 	uint32_t d3d_load_texture;
1125: 	uint32_t sub_559910;
1126: 	uint32_t swirl_sub_56D1D0;
1127: 	uint32_t load_credits_image;
1128: 	void (*input_fill_keystate)();
1129: 	int (*input_get_keyscan)(int, int);
1130: 	uint32_t sub_52FE80;
1131: 	uint32_t sub_45D610;
1132: 	uint32_t sub_45D080;
1133: 	uint32_t sub_464BD0;
1134: 	uint32_t sub_4653B0;
1135: 	uint32_t sub_559E40;
1136: 	uint32_t sub_559F30;
1137: 	uint32_t sub_497380;
1138: 	uint32_t sub_4B3410;
1139: 	uint32_t sub_4B3310;
1140: 	uint32_t sub_4B3140;
1141: 	uint32_t sub_4BDB30;
1142: 	ff8_menu_callback *menu_callbacks;
1143: 	char (*menu_use_items_sub_4F81F0)(int);
1144: 	uint32_t menu_cards_render;
1145: 	uint32_t sub_534AD0;
1146: 	uint8_t **card_texts_off_B96504;
1147: 	uint32_t sub_4EFC00;
1148: 	uint32_t sub_4EFCD0;
1149: 	uint32_t menu_config_controller;
1150: 	uint32_t menu_config_render;
1151: 	uint32_t menu_config_render_submenu;
1152: 	ff8_menu_config_input *menu_config_input_desc;
1153: 	ff8_menu_config_input_keymap *menu_config_input_desc_keymap;
1154: 	uint32_t menu_junkshop_sub_4EA890;
1155: 	uint32_t menu_shop_sub_4EBE40;
1156: 	uint32_t main_menu_render_sub_4E5550;
1157: 	uint32_t main_menu_controller;
1158: 	uint32_t sub_4C2FF0;
1159: 	uint32_t menu_sub_4D4D30;
1160: 	uint32_t menu_chocobo_world_controller;
1161: 	uint32_t create_save_file_sub_4C6E50;
1162: 	uint32_t create_save_chocobo_world_file_sub_4C6620;
1163: 	void (*menu_chocobo_sub_4FF8F0)();
1164: 	void (*menu_shop_update_gil_and_items_4EB9F0)(int);
1165: 	int (*add_item_to_player_sub_47ED00)(int, char);
1166: 	void (*update_seed_exp_4C30E0)(int);
1167: 	int (*sub_4ABC40)(int, int);
1168: 	int (*sub_4EA770)(int, uint32_t);
1169: 	uint32_t* menu_data_1D76A9C;
1170: 	std::span<uint8_t> menu_shop_staged_items_1D8D058;
1171: 	uint32_t get_text_data;
1172: 	uint32_t sub_4BE4D0;
1173: 	uint32_t sub_4BECC0;
1174: 	uint32_t menu_draw_text;
1175: 	uint32_t (*get_character_width)(uint32_t);
1176: 	struct ff8_graphics_object **swirl_texture1;
1177: 	uint32_t sub_48D0A0;
1178: 	uint32_t open_lzs_image;
1179: 	uint32_t (*credits_open_file)(char *, char *);
1180: 	uint32_t upload_psx_vram;
1181: 	uint32_t copy_psx_vram_part;
1182: 	void (*sub_464850)(uint32_t, uint32_t, uint32_t, uint32_t);
1183: 	uint8_t *psxvram_buffer;
1184: 	struct struc_51 *psx_texture_pages; // One per bpp (bpp 4, 8 and 16)
1185: 	uint32_t read_field_data;
1186: 	uint32_t upload_mim_file;
1187: 	uint32_t upload_pmp_file;
1188: 	char *field_filename;
1189: 	int (*field_scripts_init)(int, int, int, int);
1190: 	uint8_t *field_state_background_count;
1191: 	ff8_field_state_background **field_state_backgrounds;
1192: 	uint32_t load_field_models;
1193: 	uint32_t chara_one_read_file;
1194: 	uint32_t chara_one_seek_file;
1195: 	uint32_t chara_one_set_data_start;
1196: 	uint8_t **chara_one_data_start;
1197: 	uint32_t chara_one_upload_texture;
1198: 	uint32_t worldmap_main_loop;
1199: 	uint32_t worldmap_enter_main;
1200: 	uint32_t worldmap_sub_53F310;
1201: 	uint32_t worldmap_sub_53F310_call_24D;
1202: 	uint32_t worldmap_sub_53F310_call_2A9;
1203: 	uint32_t worldmap_sub_53F310_call_30D;
1204: 	uint32_t worldmap_sub_53F310_call_330;
1205: 	uint32_t worldmap_sub_53F310_call_366;
1206: 	uint32_t worldmap_sub_53F310_call_3B5;
1207: 	uint32_t worldmap_sub_53F310_loc_53F7EE;
1208: 	uint32_t worldmap_wmset_set_pointers_sub_542DA0;
1209: 	uint32_t worldmap_sub_541970_upload_tim;
1210: 	uint32_t worldmap_sub_548020;
1211: 	uint32_t worldmap_sub_5531F0;
1212: 	uint32_t worldmap_sub_554AA0;
1213: 	uint32_t worldmap_sub_554AA0_call_C2;
1214: 	uint32_t worldmap_alter_uv_sub_553B40;
1215: 	uint32_t worldmap_sub_545E20;
1216: 	uint32_t worldmap_chara_one;
1217: 	int32_t (*open_file_world)(const char*, int32_t, uint32_t, void *);
1218: 	uint32_t open_file_world_sub_52D670_texl_call1;
1219: 	uint32_t open_file_world_sub_52D670_texl_call2;
1220: 	uint32_t upload_psxvram_texl_pal_call1;
1221: 	uint32_t upload_psxvram_texl_pal_call2;
1222: 	uint32_t **worldmap_section17_position;
1223: 	uint32_t **worldmap_section18_position;
1224: 	uint32_t **worldmap_section38_position;
1225: 	uint32_t **worldmap_section39_position;
1226: 	uint32_t **worldmap_section40_position;
1227: 	uint32_t **worldmap_section41_position;
1228: 	uint32_t **worldmap_section42_position;
1229: 	uint32_t (*worldmap_prepare_tim_for_upload)(uint8_t *, ff8_tim *);
1230: 	uint32_t engine_eval_process_input;
1231: 	void (*engine_eval_keyboard_gamepad_input)();
1232: 	uint32_t engine_eval_is_button_pressed;
1233: 	uint32_t *engine_input_confirmed_buttons;
1234: 	uint32_t *engine_input_valid_buttons;
1235: 	void (*has_keyboard_gamepad_input)();
1236: 	uint32_t dinput_update_gamepad_status;
1237: 	LPDIRECTINPUTDEVICE8A dinput_gamepad_device;
1238: 	LPDIJOYSTATE2 dinput_gamepad_state;
1239: 	uint32_t dinput_init_gamepad;
1240: 	BYTE* engine_gamepad_button_pressed;
1241: 	DWORD* engine_mapped_buttons;
1242: 	uint32_t draw_movie_frame;
1243: 	struct ff8_movie_obj *movie_object;
1244: 	int (*sub_5304B0)();
1245: 	uint32_t *enable_framelimiter;
1246: 	unsigned char *byte_1CE4907;
1247: 	unsigned char *byte_1CE4901;
1248: 	unsigned char *byte_1CE490D;
1249: 	uint32_t sub_45B310;
1250: 	uint32_t sub_45B460;
1251: 	uint32_t ssigpu_init;
1252: 	uint32_t *sub_blending_capability;
1253: 	uint32_t *d3dcaps;
1254: 	uint32_t loc_460BB0;
1255: 	float *psx_floats1;
1256: 	uint32_t sub_53BB90;
1257: 	uint32_t worldmap_fog_filter_polygons_in_block_1;
1258: 	uint32_t worldmap_polygon_condition_2045C8C;
1259: 	uint32_t worldmap_has_polygon_condition_2045C90;
1260: 	uint32_t worldmap_sub_45DF20;
1261: 	uint32_t sub_45E3A0;
1262: 	uint32_t worldmap_fog_filter_polygons_in_block_2;
1263: 	uint32_t sub_461E00;
1264: 	uint32_t dword_1CA8848;
1265: 	uint32_t sub_53E2A0;
1266: 	uint32_t sub_53E6B0;
1267: 	uint32_t sub_4023D0;
1268: 	uint32_t sub_53C750;
1269: 	uint32_t sub_544630;
1270: 	uint32_t sub_548080;
1271: 	uint32_t sub_549E80;
1272: 	uint32_t sub_546100;
1273: 	uint32_t sub_54A0D0;
1274: 	uint32_t sub_54D7E0;
1275: 	uint32_t sub_54FDA0;
1276: 	uint32_t worldmap_with_fog_sub_53FAC0;
1277: 	void (*set_drawpoint_state_521D90)(uint8_t, char);
1278: 	char* worldmap_windows_idx_map;
1279: 	int (*world_dialog_assign_text_sub_543790)(int,int,char*);
1280: 	int (*world_dialog_question_assign_text_sub_5438D0)(int, int, char*, int, int, int, uint8_t);
1281: 	uint32_t sub_543CB0;
1282: 	uint32_t sub_5484B0;
1283: 	uint32_t sub_54A230;
1284: 	uint32_t worldmap_update_steps_sub_6519D0;
1285: 	uint32_t worldmap_update_seed_level_651C10;
1286: 	uint32_t sub_54E9B0;
1287: 	uint32_t sub_550070;
1288: 	int (*sub_541C80)(WORD*);
1289: 	uint32_t worldmap_input_update_sub_559240;
1290: 	uint32_t sub_554940;
1291: 	uint32_t sub_554940_call_130;
1292: 	uint32_t sub_541AE0;
1293: 	uint32_t sub_554BC0;
1294: 	uint32_t sub_557140;
1295: 	uint32_t sub_54B460;
1296: 	uint32_t sub_558D70;
1297: 	uint32_t sub_545EA0;
1298: 	uint32_t sub_545F10;
1299: 	uint32_t sub_465720;
1300: 	uint32_t sm_battle_sound;
1301: 	uint32_t outputdebugstringa;
1302: 	uint32_t sdmusicplay;
1303: 	uint32_t(*sd_music_play)(uint32_t, char*, uint32_t);
1304: 	uint32_t sd_music_play_at;
1305: 	uint32_t* current_music_ids;
1306: 	uint32_t sub_46B800;
1307: 	uint32_t stop_music;
1308: 	uint32_t set_midi_volume;
1309: 	BOOL (*dmusicperf_set_volume_sub_46C6F0)(uint32_t, int32_t);
1310: 	uint32_t sub_46C050;
1311: 	uint32_t sub_501B60;
1312: 	uint32_t pause_music_and_sfx;
1313: 	uint32_t restart_music_and_sfx;
1314: 	uint32_t directsound_create_secondary_buffer;
1315: 	uint32_t start;
1316: 	uint32_t battle_enter;
1317: 	uint32_t battle_main_loop;
1318: 	void (*show_vram_window)();
1319: 	void (*refresh_vram_window)();
1320: 	char* music_path;
1321: 	uint32_t opcode_effectplay2;
1322: 	uint32_t opcode_mes;
1323: 	uint32_t opcode_ames;
1324: 	uint32_t opcode_amesw;
1325: 	uint32_t opcode_ramesw;
1326: 	uint32_t opcode_ask;
1327: 	uint32_t opcode_aask;
1328: 	uint32_t opcode_messync;
1329: 	uint32_t opcode_winclose;
1330: 	uint32_t opcode_mesmode;
1331: 	uint32_t opcode_movie;
1332: 	uint32_t opcode_moviesync;
1333: 	uint32_t opcode_spuready;
1334: 	uint32_t opcode_movieready;
1335: 	uint32_t opcode_setvibrate;
1336: 	uint32_t opcode_musicload;
1337: 	uint32_t opcode_crossmusic;
1338: 	uint32_t opcode_dualmusic;
1339: 	uint32_t opcode_choicemusic;
1340: 	uint32_t opcode_musicvoltrans;
1341: 	uint32_t opcode_musicvolfade;
1342: 	uint32_t opcode_musicskip;
1343: 	uint32_t opcode_musicvolsync;
1344: 	uint32_t opcode_getmusicoffset;
1345: 	uint32_t opcode_drawpoint;
1346: 	int (*opcode_cardgame)(int);
1347: 	uint32_t opcode_battle;
1348: 	uint32_t opcode_tuto;
1349: 	uint32_t opcode_mapjump;
1350: 	uint32_t opcode_pshm_w;
1351: 	int (*opcode_popm_w)(void*, int);
1352: 	int (*opcode_popm_b)(void*, int);
1353: 	uint32_t opcode_menuname;
1354: 	int (*opcode_addgil)(void*);
1355: 	int (*opcode_addseedlevel)(void*);
1356: 	uint8_t* cardgame_deck_id_1DCD7AD;
1357: 	BYTE* current_tutorial_id;
1358: 	uint32_t dmusic_segment_connect_to_dls;
1359: 	uint32_t choice_music;
1360: 	uint32_t load_midi_segment;
1361: 	uint32_t load_midi_segment_from_id;
1362: 	uint32_t play_midi_segments;
1363: 	uint32_t load_and_play_midi_segment;
1364: 	uint32_t stop_midi_segments;
1365: 	uint32_t volume_update;
1366: 	uint32_t volume_music_update;
1367: 	uint32_t music_load;
1368: 	uint32_t play_wav;
1369: 	uint32_t (*load_cdrom)();
1370: 	uint32_t load_cdrom_call;
1371: 	uint32_t (*play_cdrom)(uint32_t, uint32_t, uint32_t);
1372: 	uint32_t play_cdrom_call;
1373: 	uint32_t (*stop_cdrom)();
1374: 	uint32_t stop_cdrom_field_call;
1375: 	uint32_t stop_cdrom_cleanup_call;
1376: 	savemap_ff8_field_h** savemap_field;
1377: 	savemap_ff8* savemap;
1378: 	int32_t (*check_game_is_paused)(int32_t);
1379: 	DWORD* is_game_paused;
1380: 	uint32_t sub_470250;
1381: 	uint32_t *ssigpu_callbacks_1;
1382: 	uint32_t *ssigpu_callbacks_2;
1383: 	uint32_t sub_462AD0;
1384: 	uint32_t sub_462DF0;
1385: 	uint32_t sub_461220;
1386: 	uint32_t ssigpu_tx_select_2_sub_465CE0;
1387: 	uint32_t write_palette_texture_set_sub_466190;
1388: 	uint32_t read_vram_palette_sub_467370;
1389: 	uint32_t write_palette_to_driver_sub_467310;
1390: 	int (*sub_464F70)(struc_50 *, texture_page *, int, int, int, int, int, int, int, uint8_t *);
1391: 	void(*read_vram_1)(uint8_t *, int, uint8_t *, int, signed int, int, int);
1392: 	void(*read_vram_2_paletted)(uint8_t *, int, uint8_t *, int, signed int, int, int, uint16_t *);
1393: 	void(*read_vram_3_paletted)(uint8_t *, uint8_t *, signed int, int, int, uint16_t *);
1394: 	uint32_t sub_464DB0;
1395: 	uint32_t sub_4649A0;
1396: 	char *archive_path_prefix;
1397: 	int(*fs_archive_search_filename)(const char *, ff8_file_fi_infos *, const ff8_file_container *);
1398: 	int(*ff8_fs_archive_search_filename2)(const char *, ff8_file_fi_infos *, const ff8_file_container *);
1399: 	char *(*fs_archive_get_fl_filepath)(int, const ff8_file_fl *);
1400: 	uint32_t _open;
1401: 	int(*_sopen)(const char*, int, int, ...);
1402: 	uint32_t fopen;
1403: 	FILE *(*_fsopen)(const char*, const char*, int);
1404: 	uint32_t input_init;
1405: 	uint32_t ff8input_cfg_read;
1406: 	uint32_t ff8input_cfg_reset;
1407: 	char *(*strcpy_with_malloc)(const char *);
1408: 	uint32_t moriya_filesystem_open;
1409: 	uint32_t moriya_filesystem_seek;
1410: 	uint32_t moriya_filesystem_read;
1411: 	uint32_t moriya_filesystem_close;
1412: 	uint32_t read_or_uncompress_fs_data;
1413: 	uint32_t lzs_uncompress;
1414: 	void(*free_file_container)(ff8_file_container *);
1415: 	ff8_file_container*(*archive_open)(char*,char*,char*);
1416: 	void(*sub_archive_get_filename)(const char*,char*);
1417: 	char *temp_fs_path_cache;
1418: 	uint32_t field_get_dialog_string;
1419: 	uint32_t set_window_object;
1420: 	ff8_win_obj *windows;
1421: 	BYTE* field_dialog_current_choice;
1422: 	uint32_t sub_470440;
1423: 	uint32_t sub_49ACD0;
1424: 	uint32_t sub_4A0880;
1425: 	uint32_t sub_4A09A0;
1426: 	uint32_t sub_49FC10;
1427: 	uint32_t sub_4A0C00;
1428: 	uint32_t *dword_1D2B808;
1429: 	char(*show_dialog)(int32_t, uint32_t, int16_t);
1430: 	int(*pause_menu_with_vibration)(int);
1431: 	uint32_t ff8_draw_icon_or_key1;
1432: 	uint32_t ff8_draw_icon_or_key2;
1433: 	uint32_t ff8_draw_icon_or_key3;
1434: 	uint32_t ff8_draw_icon_or_key4;
1435: 	uint32_t ff8_draw_icon_or_key5;
1436: 	uint32_t ff8_draw_icon_or_key6;
1437: 	uint8_t *battle_boost_cross_icon_display_1D76604;
1438: 	int(*pause_menu)(int);
1439: 	uint32_t init_pause_menu;
1440: 	uint32_t sub_49BB30;
1441: 	uint32_t sub_49FE60;
1442: 	uint32_t get_icon_sp1_data;
1443: 	uint32_t draw_controller_or_keyboard_icons;
1444: 	uint32_t get_vibration_capability;
1445: 	uint32_t vibration_apply;
1446: 	uint32_t vibration_set_is_enabled;
1447: 	uint32_t vibration_get_is_enabled;
1448: 	int(*get_keyon)(int, int);
1449: 	uint32_t set_vibration;
1450: 	ff8_gamepad_state *gamepad_states;
1451: 	ff8_vibrate_struc *vibration_objects;
1452: 	uint32_t vibration_clear_intensity;
1453: 	uint8_t *vibrate_data_world;
1454: 	uint32_t open_battle_vibrate_vib;
1455: 	uint8_t **vibrate_data_main;
1456: 	uint8_t **vibrate_data_battle;
1457: 	uint8_t *vibrate_data_field;
1458: 	uint32_t sub_537F30;
1459: 	uint32_t sub_5391B0;
1460: 	uint32_t sub_534560;
1461: 	uint32_t sub_536C30;
1462: 	uint32_t cardgame_func_534340;
1463: 	uint32_t cargame_func_535C90;
1464: 	int(*cardgame_func_534BC0)();
1465: 	uint32_t sub_536CB0;
1466: 	uint8_t **card_texts_off_B96968;
1467: 	uint32_t sub_536C80;
1468: 	uint32_t sub_5366D0;
1469: 	uint32_t sub_539500;
1470: 	uint32_t *cardgame_funcs;
1471: 	uint8_t *cardgame_tim_texture_intro;
1472: 	uint8_t *cardgame_tim_texture_game;
1473: 	uint8_t *cardgame_tim_texture_cards;
1474: 	uint8_t *cardgame_tim_texture_icons;
1475: 	uint8_t *cardgame_tim_texture_font;
1476: 	uint32_t* is_card_game;
1477: 	uint32_t cardgame_add_card_to_squall_534840;
1478: 	uint32_t cardgame_sub_536DE0;
1479: 	uint32_t cardgame_sub_537110;
1480: 	uint32_t cardgame_update_card_with_location_5347F0;
1481: 	int (*cardgame_sub_535D00)(void*);
1482: 	uint32_t sfx_play_to_current_playing_channel;
1483: 	uint32_t sfx_unload_all;
1484: 	uint32_t sfx_pause_all;
1485: 	uint32_t sfx_resume_all;
1486: 	uint32_t sfx_stop_all2;
1487: 	uint32_t sfx_stop_all;
1488: 	void(*sfx_set_master_volume)(uint32_t);
1489: 	int(*sfx_get_master_volume)();
1490: 	uint32_t sfx_set_volume;
1491: 	uint32_t sfx_current_channel_is_playing;
1492: 	uint32_t sfx_is_playing;
1493: 	uint32_t sfx_set_panning;
1494: 	uint16_t *sfx_sound_count;
1495: 	ff8_audio_fmt **sfx_audio_fmt;
1496: 	uint32_t manage_time_engine_sub_569971;
1497: 	int (*enable_rdtsc_sub_40AA00)(int enable);
1498: 	uint32_t loc_47D490;
1499: 	uint32_t sub_500870;
1500: 	uint32_t sub_500C00;
1501: 	uint32_t sub_500CC0;
1502: 	uint32_t sub_506C90;
1503: 	uint32_t sub_506CF0;
1504: 	uint32_t sub_5084B0;
1505: 	uint32_t battle_open_file_wrapper;
1506: 	uint32_t battle_open_file;
1507: 	char **battle_filenames;
1508: 	uint32_t battle_load_textures_sub_500900;
1509: 	uint32_t loc_5005A0;
1510: 	uint32_t battle_upload_texture_to_vram;
1511: 	uint32_t sub_485460;
1512: 	uint32_t sub_485610;
1513: 	uint32_t sub_48D1A0;
1514: 	uint32_t sub_4AD7D0;
1515: 	uint32_t sub_4AD8D0;
1516: 	uint32_t sub_4AB4F0;
1517: 	uint32_t sub_4AB190;
1518: 	uint32_t sub_4A84E0;
1519: 	uint32_t sub_4AD400;
1520: 	uint32_t sub_4BB840;
1521: 	uint32_t battle_check_won_sub_486500;
1522: 	void(*battle_sub_494D40)();
1523: 	uint32_t battle_sub_4877F0;
1524: 	uint32_t battle_sub_48D200;
1525: 	uint32_t battle_ai_opcode_sub_487DF0;
1526: 	int (*battle_get_draw_magic_amount_48FD20)(int, int, int);
1527: 	void(*update_tutorial_info_4AD170)(int);
1528: 	uint32_t sub_48B7E0;
1529: 	void(*sub_4954B0)(int);
1530: 	uint32_t compute_char_stats_sub_495960;
1531: 	int(*compute_char_max_hp_496310)(int, int);
1532: 	int(*get_char_level_4961D0)(int, int);
1533: 	std::span<ff8_char_computed_stats> char_comp_stats_1CFF000;
1534: 	BYTE* battle_current_active_character_id;
1535: 	BYTE* battle_new_active_character_id;
1536: 	WORD* global_battle_encounter_id_1CFF6E0;
1537: 	WORD* battle_encounter_id;
1538: 	BYTE* battle_result_state_1CFF6E7; // 2: escaped, 4: won, 1-3: other type, 5: unknown
1539: 	uint32_t sub_4AB450;
1540: 	uint32_t battle_get_monster_name_sub_495100;
1541: 	uint32_t sub_4AA920;
1542: 	uint32_t battle_get_actor_name_sub_47EAF0;
1543: 	BYTE** battle_char_struct_dword_1D27B10;
1544: 	BYTE* byte_1CFF1C3;
1545: 	char* unk_1CFDC70;
1546: 	char* unk_1CFDC7C;
1547: 	WORD* word_1CF75EC;
1548: 	char* unk_1CFF84C;
1549: 	char* unk_1CF3E48;
1550: 	DWORD* dword_1CF3EE0;
1551: 	DWORD* battle_current_actor_talking;
1552: 	uint32_t sub_502380;
1553: 	uint32_t sub_50A790;
1554: 	uint32_t sub_50A9A0;
1555: 	uint32_t battle_read_effect_sub_50AF20;
1556: 	DWORD* func_off_battle_effects_C81774;
1557: 	int* battle_magic_id;
1558: 	uint32_t sub_571870;
1559: 	DWORD* func_off_battle_effect_textures_50AF93;
1560: 	uint32_t sub_6C3640;
1561: 	uint32_t sub_6C3760;
1562: 	uint8_t **vibrate_data_summon_quezacotl;
1563: 	uint32_t load_magic_data_sub_571B80;
1564: 	uint32_t load_magic_data_sub_5718E0;
1565: 	uint32_t load_magic_data_sub_571900;
1566: 	uint32_t sub_47D890;
1567: 	uint32_t sub_505DF0;
1568: 	uint32_t sub_4A94D0;
1569: 	uint32_t sub_4BCBE0;
1570: 	uint32_t sub_4C8B10;
1571: 	uint32_t battle_pause_sub_4CD140;
1572: 	uint32_t *is_alternative_pause_menu;
1573: 	uint32_t *pause_menu_option_state;
1574: 	void *battle_menu_state;
1575: 	uint32_t battle_pause_window_sub_4CD350;
1576: 	uint32_t sub_4A7210;
1577: 	uint32_t sub_B586F0;
1578: 	uint32_t sub_B64B80;
1579: 	DWORD* leviathan_funcs_B64C3C;
1580: 	uint32_t mag_data_palette_sub_B66560;
1581: 	DWORD** effect_struct_27973EC;
1582: 	uint8_t** mag_data_dword_2798A68;
1583: 	DWORD** effect_struct_2797624;
1584: 	uint32_t sub_B63230;
1585: 	uint32_t mag_data_texture_sub_B66560;
1586: 	BYTE** dword_27973E8;
1587: 	uint32_t battle_set_action_upload_raw_palette_sub_B666F0;
1588: 	uint32_t battle_set_action_upload_raw_palette_sub_B66400;
1589: 	uint32_t sub_84D110;
1590: 	uint32_t sub_84D1F0;
1591: 	uint32_t sub_84D230;
1592: 	uint32_t sub_84D2C0;
1593: 	uint32_t sub_84D4B0;
1594: 	uint32_t sub_84F2A0;
1595: 	uint32_t sub_84F860;
1596: 	uint32_t sub_84F8D0;
1597: 	uint32_t scan_get_text_sub_B687C0;
1598: 	uint32_t battle_entities_1D27BCB;
1599: 	uint32_t scan_text_data;
1600: 	uint32_t scan_text_positions;
1601: 	uint32_t fps_limiter;
1602: 	double *time_volume_change_related_1A78BE0;
1603: 	uint32_t* game_mode_obj_1D9CF88;
1604: 	uint32_t field_vars_stack_1CFE9B8;
1605: 	uint32_t get_card_name;
1606: 	uint32_t card_name_positions;
1607: 	uint32_t drawpoint_messages;
1608: 	int(*opcode_drawpoint_sub_4A0850)(int, int);
1609: 	uint32_t enable_gf_sub_47E480;
1610: 	uint32_t battle_menu_loop_4A2690;
1611: 	uint32_t battle_menu_sub_4A6660;
1612: 	uint32_t battle_menu_sub_4A3D20;
1613: 	uint32_t battle_menu_sub_4A3EE0;
1614: 	int(*battle_menu_add_exp_and_stat_bonus_496CB0)(int, uint16_t);
1615: 	byte* character_data_1CFE74C;
1616: 	uint32_t battle_sub_485160;
1617: 	uint32_t battle_sub_48FE20;
1618: 	uint32_t battle_sub_494410;
1619: 	void (*battle_sub_494AF0)(int, int, int, int);
1620: 	uint32_t engine_reset_viewport_sub_4972D0;
1621: 	uint32_t engine_setviewport_sub_45B4C0;
1622: 	void* (*engine_setviewport_sub_41E070)(int, int, int, int, void*);
1623: 	uint32_t *dword_B7CE28;
1624: 	uint32_t *flag_d3d_renderer_related_dword_1CCFD94;
1625: 	int32_t *ssigpu_viewport_x_dword_1CA89D8;
1626: 	int32_t *ssigpu_viewport_y_dword_1CA89DC;
1627: 	int32_t *ssigpu_viewport_width_dword_B7CBF8;
1628: 	int32_t *ssigpu_viewport_height_dword_B7CBFC;
1629: 	int32_t *current_viewport_x_dword_1A7764C;
1630: 	int32_t *current_viewport_y_dword_1A77648;
1631: 	int32_t *current_viewport_width_dword_1A77654;
1632: 	int32_t *current_viewport_height_dword_1A77650;
1633: };
1634: 
1635: void ff8gl_field_78(struct ff8_polygon_set *polygon_set, struct ff8_game_obj *game_object);
1636: void ff8_unload_texture(struct ff8_texture_set *texture_set);
1637: void ff8_init_hooks(struct game_obj *_game_object);
1638: struct ff8_gfx_driver *ff8_load_driver(void* game_object);
1639: LPDIJOYSTATE2 ff8_update_gamepad_status();
1640: bool ff8_skip_movies();
</file>

<file path="src/field.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <imgui.h>
 24: #include <stdint.h>
 25: 
 26: #include "globals.h"
 27: #include "common.h"
 28: #include "patch.h"
 29: #include "log.h"
 30: #include "utils.h"
 31: 
 32: #include "field.h"
 33: 
 34: #include "ff7/field/model.h"
 35: 
 36: // Data for debug map jumps
 37: int target_triangle = 0;
 38: int target_field = 0;
 39: byte map_patch_storage[7] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // Place to store the original bytes so that we can patch back after a map jump
 40: bool map_changing = false;
 41: 
 42: // FF7 only
 43: int (*opcode_old_kawai)();
 44: int (*opcode_old_pc)();
 45: 
 46: byte get_field_bank_value(int16_t bank)
 47: {
 48: 	switch(bank)
 49: 	{
 50: 	case 0:
 51: 		return (get_field_parameter<byte>(0) >> 4) & 0xF;
 52: 	case 1:
 53: 		return get_field_parameter<byte>(0) & 0xF;
 54: 	case 2:
 55: 		return (get_field_parameter<byte>(1) >> 4) & 0xF;
 56: 	case 3:
 57: 		return get_field_parameter<byte>(1) & 0xF;
 58: 	case 4:
 59: 		return (get_field_parameter<byte>(2) >> 4) & 0xF;
 60: 	case 5:
 61: 		return get_field_parameter<byte>(2) & 0xF;
 62: 	default:
 63: 		return 0;
 64: 	}
 65: }
 66: 
 67: int opcode_kawai_eye_texture() {
 68: 	byte num_params = get_field_parameter<byte>(0);
 69: 	byte subcode = get_field_parameter<byte>(1);
 70: 
 71: 	if (subcode == 0x0) // EYETX
 72: 	{
 73: 		byte left_eye_index = get_field_parameter<byte>(2);
 74: 		byte right_eye_index = get_field_parameter<byte>(3);
 75: 		byte mouth_index = get_field_parameter<byte>(4);
 76: 
 77: 		field_animation_data* animation_data = *ff7_externals.field_animation_data_ptr;
 78: 		byte curr_entity_id = *ff7_externals.current_entity_id;
 79: 		byte curr_model_id = ff7_externals.field_model_id_array[curr_entity_id];
 80: 		byte curr_eye_index = animation_data[curr_model_id].eye_texture_idx;
 81: 
 82: 		ff7::field::ff7_model_data[curr_model_id].current_mouth_idx = mouth_index;
 83: 
 84: 		if (trace_all || trace_opcodes)
 85: 		{
 86: 			ffnx_trace("opcode[KAWAI]: num_params=%u,subcode=0x%x,left_eye_index=%u,right_eye_index=%u,mouth_index=%u\n", num_params, subcode, left_eye_index, right_eye_index, mouth_index);
 87: 			ffnx_trace("subcode[EYETX]: curr_entity_id=%u,curr_model_id=%u,curr_eye_index=%u\n", curr_entity_id, curr_model_id, curr_eye_index);
 88: 		}
 89: 	}
 90: 
 91: 	return opcode_old_kawai();
 92: }
 93: 
 94: int opcode_pc_map_change() {
 95: 	if (map_changing)
 96: 	{
 97: 		byte* level_data = *ff7_externals.field_level_data_pointer;
 98: 		uint32_t walkmesh_offset = *(uint32_t*)(level_data + 0x16);
 99: 		vertex_3s* triangle_data = (vertex_3s*)(level_data + walkmesh_offset + 8 + 24 * target_triangle);
100: 
101: 		// Calculates the centroid of the walkmesh triangle
102: 		int x = (triangle_data[0].x + triangle_data[1].x + triangle_data[2].x) / 3;
103: 		int y = (triangle_data[0].y + triangle_data[1].y + triangle_data[2].y) / 3;
104: 
105: 		ff7_externals.modules_global_object->field_model_pos_x = x;
106: 		ff7_externals.modules_global_object->field_model_pos_y = y;
107: 		ff7_externals.modules_global_object->field_model_triangle_id = target_triangle;
108: 		map_changing = false;
109: 	}
110: 
111: 	return opcode_old_pc();
112: }
113: 
114: int field_calc_window_pos(int16_t WINDOW_ID, int16_t X, int16_t Y, int16_t W, int16_t H)
115: {
116: 	return ff7_externals.sub_630C48(WINDOW_ID, X, ff7_field_center ? Y + 8 : Y, W, H);
117: }
118: 
119: int ff7_calc_opcode_type_2_fade_color(int16_t r, int16_t g, int16_t b)
120: {
121: 	uint8_t fade_b = (256 - b) * (256 - ff7_externals.modules_global_object->fade_adjustment / 2) / 256;
122: 	uint8_t fade_g = (256 - g) * (256 - ff7_externals.modules_global_object->fade_adjustment / 2) / 256;
123: 	uint8_t fade_r = (256 - r) * (256 - ff7_externals.modules_global_object->fade_adjustment / 2) / 256;
124: 
125: 	return 0xFF000000 | (fade_r << 16) | (fade_g << 8) | fade_b;
126: }
127: 
128: int ff8_field_init_from_file(int unk1, int unk2, int unk3, int unk4)
129: {
130: 	int ret = ff8_externals.field_scripts_init(unk1, unk2, unk3, unk4);
131: 
132: 	// Current triangle id address changes on each field on FF8
133: 	// Loop through objects until we find the one that has a valid triangle ID
134: 	for(int i = 0; i < MAXBYTE; i++)
135: 	{
136: 		common_externals.current_triangle_id = (int16_t*)(*ff8_externals.game_mode_obj_1D9CF88 + 0x264 * i + 0x1FA);
137: 		if (*common_externals.current_triangle_id != 0) break;
138: 	}
139: 
140: 	return ret;
141: }
142: 
143: void field_init()
144: {
145: 	if (!ff8)
146: 	{
147: 		// Proxies the PC field opcode to reposition the player after a forced map change
148: 		opcode_old_pc = (int (*)())ff7_externals.opcode_pc;
149: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0xA0], (DWORD)&opcode_pc_map_change);
150: 
151: 		opcode_old_kawai = (int (*)())ff7_externals.opcode_kawai;
152: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x28], (DWORD)&opcode_kawai_eye_texture);
153: 
154: 		// Proxy the window calculation formula so we can offset windows vertically
155: 		replace_call_function(common_externals.execute_opcode_table[0x50] + 0x174, field_calc_window_pos);
156: 
157: 		// Proxy FADE opcode color calculation
158: 		byte opcode_fade_patch[] = {0x0F, 0xBF, 0x45, 0x10, 0x50, 0x0F, 0xBF, 0x45, 0x0C, 0x50, 0x0F, 0xBF, 0x45, 0x08, 0x50, 0xE8, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xC4, 0x0C};
159: 		memcpy_code(ff7_externals.field_calc_fade_color_sub_63AE66 + 0x244, opcode_fade_patch, sizeof(opcode_fade_patch));
160: 		memset_code(ff7_externals.field_calc_fade_color_sub_63AE66 + 0x244 + sizeof(opcode_fade_patch), 0x90, 0xE1 - sizeof(opcode_fade_patch));
161: 		replace_call_function(ff7_externals.field_calc_fade_color_sub_63AE66 + 0x244 + 0xF, ff7_calc_opcode_type_2_fade_color);
162: 
163: 		// Init custom eyes and mouths structs
164: 		for(int i = 0; i < FF7_MAX_NUM_MODEL_ENTITIES; i++)
165: 		{
166: 			ff7::field::ff7_model_data[i].left_eye_tex_filename = (char*)external_calloc(sizeof(char), sizeof(basedir) + 1024);
167: 			ff7::field::ff7_model_data[i].right_eye_tex_filename = (char*)external_calloc(sizeof(char), sizeof(basedir) + 1024);
168: 			ff7::field::ff7_model_data[i].current_mouth_idx = 0;
169: 			ff7::field::ff7_model_data[i].mouth_tex_filename = (char*)external_calloc(sizeof(char), sizeof(basedir) + 1024);
170: 			ff7::field::ff7_model_data[i].mouth_tex = NULL;
171: 		}
172: 	}
173: 	else
174: 	{
175: 		// Proxy the field init file read
176: 		replace_call_function(ff8_externals.read_field_data + (JP_VERSION ? 0xEDC : 0xE49), ff8_field_init_from_file);
177: 	}
178: }
179: 
180: int map_jump_ff7()
181: {
182: 	// Restores the original field update code
183: 	memcpy_code(common_externals.update_entities_call, map_patch_storage, 7);
184: 
185: 	byte* current_executing_code = get_field_parameter_address<byte>(-1);
186: 
187: 	// Inject MAPJUMP coordinates
188: 	memset(current_executing_code, 0, 10);
189: 	*(current_executing_code) = 0x60; // MAPJUMP
190: 	*(WORD*)(current_executing_code + 1) = target_field;
191: 
192: 	int (*mapjump)() = (int (*)())common_externals.execute_opcode_table[0x60];
193: 	return mapjump();
194: }
195: 
196: int map_jump_ff8(byte* entity, int arg)
197: {
198: 	// Forces the entity to be able to trigger a map jump
199: 	entity[0x175] |= 0x01;
200: 
201: 	// Restores the original field update code
202: 	memcpy_code(common_externals.update_entities_call, map_patch_storage, 7);
203: 	map_changing = false;
204: 
205: 	// Executes the field script to change map
206: 	int (**field_functions)(byte*, uint32_t) = (int (**)(byte*, uint32_t))common_externals.execute_opcode_table;
207: 	field_functions[0xB9](entity, 0); // KILLTIMER
208: 	field_functions[0x07](entity, target_field); // PSHN_L
209: 	field_functions[0x07](entity, target_triangle); // PSHN_L
210: 	return field_functions[0x5C](entity, 0); // MAPJUMP
211: }
212: 
213: void field_debug(bool *isOpen)
214: {
215: 	if (!ImGui::Begin("Field Debug", isOpen, ImGuiWindowFlags_::ImGuiWindowFlags_AlwaysAutoResize))
216: 	{
217: 		ImGui::End();
218: 		return;
219: 	}
220: 
221: 	if (getmode_cached()->driver_mode != MODE_FIELD)
222: 	{
223: 		ImGui::Text("Not currently on a field.");
224: 		ImGui::End();
225: 		return;
226: 	}
227: 
228: 	ImGui::Text("Game Moment: %u", *common_externals.field_game_moment);
229: 	ImGui::Text("Current field ID: %u", *common_externals.current_field_id);
230: 	if (common_externals.current_triangle_id != 0) ImGui::Text("Current triangle ID: %d", *common_externals.current_triangle_id);
231: 	ImGui::Text("Previous field ID: %u", *common_externals.previous_field_id);
232: 	ImGui::Separator();
233: 
234: 	// Inputs for changing field map
235: 	ImGui::Text("Switch Field"); ImGui::SetNextItemWidth(100);
236: 	ImGui::InputInt("Field ID", &target_field); ImGui::SameLine(200); ImGui::SetNextItemWidth(100);
237: 	ImGui::InputInt("Triangle ID", &target_triangle);
238: 
239: 	if (ImGui::Button("Change") && !map_changing) {
240: 		// Injects a call into where the field entities are checked
241: 		memcpy(map_patch_storage, (void*)common_externals.update_entities_call, 7); // Make a copy of the existing CALL
242: 		patch_code_dword(common_externals.update_entities_call, 0x00E89090); // Places 2 NOPs and a CALL
243: 		replace_call(common_externals.update_entities_call + 2, ff8 ? (void*)&map_jump_ff8 : (void*)&map_jump_ff7);
244: 		map_changing = true;
245: 	}
246: 	ImGui::End();
247: }
</file>

<file path="src/field.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include "globals.h"
26: 
27: void field_init();
28: void field_debug(bool *isOpen);
29: 
30: template<typename T>
31: T* get_field_parameter_address(int id)
32: {
33: 	byte* scriptPtr = *ff7_externals.field_script_ptr;
34: 	return (T*)(&scriptPtr[ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] + id + 1]);
35: }
36: 
37: template<typename T>
38: T get_field_parameter(int id)
39: {
40: 	return *get_field_parameter_address<T>(id);
41: }
42: 
43: template<typename T>
44: void set_field_parameter(int id, T value)
45: {
46: 	byte* scriptPtr = *ff7_externals.field_script_ptr;
47: 	*(T*)(&scriptPtr[ff7_externals.field_curr_script_position[*ff7_externals.current_entity_id] + id + 1]) = value;
48: }
49: 
50: byte get_field_bank_value(int16_t bank);
51: 
52: byte* get_level_data_pointer();
</file>

<file path="src/game_cfg.cpp">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #include "game_cfg.h"
24: 
25: #include "patch.h"
26: #include "globals.h"
27: #include "cfg.h"
28: #include "log.h"
29: 
30: void normalize_path_win(char *name)
31: {
32: 	int idx = 0;
33: 	while (name[idx] != 0)
34: 	{
35: 		if (name[idx] == '/') name[idx] = '\\';
36: 		idx++;
37: 	}
38: }
39: 
40: void set_game_paths(int install_options, char *_app_path, const char *_dataDrive)
41: {
42: 	char fileName[MAX_PATH] = {};
43: 
44: 	if (!app_path.empty())
45: 	{
46: 		ffnx_info("Overriding AppPath with %s\n", app_path.c_str());
47: 		strncpy(fileName, app_path.c_str(), sizeof(fileName));
48: 		_app_path = fileName;
49: 		normalize_path_win(_app_path);
50: 	}
51: 
52: 	if (!steam_edition && !data_drive.empty())
53: 	{
54: 		ffnx_info("Overriding DataDrive with %s\n", data_drive.c_str());
55: 		_dataDrive = data_drive.c_str();
56: 	}
57: 
58: 	ff8_externals.set_game_paths(install_options, _app_path, _dataDrive);
59: }
60: 
61: void game_cfg_init()
62: {
63: 	if (ff8)
64: 	{
65: 		replace_call(ff8_externals.init_config + 0x3E, set_game_paths);
66: 	}
67: }
</file>

<file path="src/game_cfg.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: #pragma once
23: 
24: void game_cfg_init();
</file>

<file path="src/gamehacks.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "gamehacks.h"
 23: #include "audio.h"
 24: #include "ff7/defs.h"
 25: #include "gamepad.h"
 26: #include "joystick.h"
 27: 
 28: GameHacks gamehacks;
 29: 
 30: // PRIVATE
 31: 
 32: void GameHacks::toggleSpeedhack()
 33: {
 34: 	speedhack_enabled = !speedhack_enabled;
 35: 
 36: 	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Current Speedhack: %s", speedhack_enabled ? "ENABLED" : "DISABLED");
 37: 
 38: 	holdInput();
 39: }
 40: 
 41: void GameHacks::resetSpeedhack()
 42: {
 43: 	speedhack_current_speed = speedhack_min;
 44: }
 45: 
 46: void GameHacks::increaseSpeedhack()
 47: {
 48: 	speedhack_enabled = true;
 49: 
 50: 	if ((speedhack_current_speed + speedhack_step) <= speedhack_max) speedhack_current_speed += speedhack_step;
 51: 
 52: 	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Current Speedhack: %2.1lfx", speedhack_current_speed);
 53: 
 54: 	holdInput();
 55: }
 56: 
 57: void GameHacks::decreaseSpeedhack()
 58: {
 59: 	speedhack_enabled = true;
 60: 
 61: 	if ((speedhack_current_speed - speedhack_step) >= speedhack_min) speedhack_current_speed -= speedhack_step;
 62: 
 63: 	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Current Speedhack: %2.1lfx", speedhack_current_speed);
 64: 
 65: 	holdInput();
 66: }
 67: 
 68: void GameHacks::toggleBattleMode()
 69: {
 70: 	battle_wanted = !battle_wanted;
 71: 
 72: 	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Battle mode: %s", battle_wanted ? "ENABLED" : "DISABLED");
 73: 
 74: 	holdInput();
 75: }
 76: 
 77: void GameHacks::toggleAutoAttackMode()
 78: {
 79: 	auto_attack_mode = !auto_attack_mode;
 80: 
 81: 	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Auto attack mode: %s", auto_attack_mode ? "ENABLED" : "DISABLED");
 82: 
 83: 	holdInput();
 84: }
 85: 
 86: void GameHacks::toggleMusicOnBattlePause()
 87: {
 88: 	if (!ff8) {
 89: 		if (*ff7_externals.is_battle_paused && use_external_music) {
 90: 			if (nxAudioEngine.isMusicPlaying())
 91: 				nxAudioEngine.pauseMusic();
 92: 			else
 93: 				nxAudioEngine.resumeMusic();
 94: 		}
 95: 	}
 96: }
 97: 
 98: void GameHacks::toggleAutoText()
 99: {
100: 	enable_voice_auto_text = !enable_voice_auto_text;
101: 
102: 	show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Voice auto text mode: %s", enable_voice_auto_text ? "ENABLED" : "DISABLED");
103: 
104: 	holdInput();
105: }
106: 
107: void GameHacks::skipMovies()
108: {
109: 	if (!ff8)
110: 	{
111: 		if (ff7_skip_movies())
112: 		{
113: 			show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "FMV Skipped");
114: 
115: 			holdInput();
116: 		}
117: 		else clear_popup_msg();
118: 	}
119: 	else
120: 	{
121: 		if (ff8_skip_movies())
122: 		{
123: 			show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "FMV Skipped");
124: 
125: 			holdInput();
126: 		}
127: 		else clear_popup_msg();
128: 	}
129: }
130: 
131: void GameHacks::softReset()
132: {
133: 	if (!ff8) ff7_do_reset = true;
134: 
135: 	resetSpeedhack();
136: 
137: 	holdInput();
138: 
139: 	clear_popup_msg();
140: }
141: 
142: // PUBLIC
143: 
144: void GameHacks::init()
145: {
146: 	resetSpeedhack();
147: 
148: 	if (speedhack_current_speed > 1.0) speedhack_enabled = true;
149: }
150: 
151: void GameHacks::processKeyboardInput(UINT msg, WPARAM wParam, LPARAM lParam)
152: {
153: 	isKeyboardShortcutMode = false;
154: 	switch (msg)
155: 	{
156: 	case WM_KEYDOWN:
157: 		if ((::GetKeyState(VK_CONTROL) & 0x8000) != 0)
158: 		{
159: 			isKeyboardShortcutMode = true;
160: 			switch (wParam)
161: 			{
162: 			case 'A':
163: 				toggleAutoAttackMode();
164: 				break;
165: 			case 'B':
166: 				toggleBattleMode();
167: 				break;
168: 			case 'M':
169: 				toggleMusicOnBattlePause();
170: 				break;
171: 			case 'R':
172: 				softReset();
173: 				break;
174: 			case 'S':
175: 				skipMovies();
176: 				break;
177: 			case 'T':
178: 				toggleAutoText();
179: 				break;
180: 			case VK_UP:
181: 				increaseSpeedhack();
182: 				break;
183: 			case VK_DOWN:
184: 				decreaseSpeedhack();
185: 				break;
186: 			case VK_LEFT:
187: 			case VK_RIGHT:
188: 				toggleSpeedhack();
189: 				break;
190: 			}
191: 		}
192: 		break;
193: 	}
194: }
195: 
196: void GameHacks::processGamepadInput()
197: {
198: 	if(isGamepadShortcutMode && get_popup_time() == 0) isGamepadShortcutMode = false;
199: 
200: 	if (xinput_connected)
201: 	{
202: 		if (gamepad.Refresh())
203: 		{
204: 			if(gamepad.IsIdle())
205: 			{
206: 				hold_input_for_frames = 0;
207: 				enable_hold_input = true;
208: 			}
209: 
210: 			if(hold_input_for_frames > 0)
211: 			{
212: 				drawnInput();
213: 				return;
214: 			}
215: 
216: 			if (gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_THUMB)) // L2
217: 			{
218: 				isGamepadShortcutMode = !isGamepadShortcutMode;
219: 				if(isGamepadShortcutMode) show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Waiting for shortcut input..");
220: 				else clear_popup_msg();
221: 				holdInput();
222: 			}
223: 
224: 			if(!isGamepadShortcutMode) return;
225: 
226: 			// Soft reset on START+SELECT
227: 			if (
228: 				gamepad.IsPressed(XINPUT_GAMEPAD_BACK) &&
229: 				gamepad.IsPressed(XINPUT_GAMEPAD_START)
230: 				)
231: 				softReset();
232: 			// Increase in-game speed on R1
233: 			else if (
234: 				gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_SHOULDER)
235: 				)
236: 				increaseSpeedhack();
237: 			// Decrease in-game speed on L1
238: 			else if (
239: 				gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_SHOULDER)
240: 				)
241: 				decreaseSpeedhack();
242: 			// Toggle Speedhack on L2/R2
243: 			else if (
244: 				gamepad.leftTrigger > 0.85f ||
245: 				gamepad.rightTrigger > 0.85f
246: 				)
247: 				toggleSpeedhack();
248: 			// Toggle battle mode on Circle
249: 			else if (
250: 				gamepad.IsPressed(XINPUT_GAMEPAD_B)
251: 				)
252: 				toggleBattleMode();
253: 			// Toggle auto attack mode on Triangle
254: 			else if (
255: 				gamepad.IsPressed(XINPUT_GAMEPAD_Y)
256: 				)
257: 				toggleAutoAttackMode();
258: 			// Skip Movies on Square
259: 			else if (
260: 				gamepad.IsPressed(XINPUT_GAMEPAD_X)
261: 				)
262: 				skipMovies();
263: 		}
264: 	}
265: 	else
266: 	{
267: 		if (joystick.Refresh())
268: 		{
269: 			if(joystick.IsIdle())
270: 			{
271: 				hold_input_for_frames = 0;
272: 				enable_hold_input = true;
273: 			}
274: 
275: 			if(hold_input_for_frames > 0)
276: 			{
277: 				drawnInput();
278: 				return;
279: 			}
280: 
281: 			if (joystick.GetState()->rgbButtons[10] & 0x80) // L2
282: 			{
283: 				isGamepadShortcutMode = !isGamepadShortcutMode;
284: 				if(isGamepadShortcutMode) show_popup_msg(TEXTCOLOR_LIGHT_BLUE, "Waiting for shortcut input..");
285: 				else clear_popup_msg();
286: 				holdInput();
287: 			}
288: 
289: 			if(!isGamepadShortcutMode) return;
290: 
291: 			// Soft reset on START+SELECT
292: 			if (
293: 				(joystick.GetState()->rgbButtons[8] & 0x80) &&
294: 				(joystick.GetState()->rgbButtons[9] & 0x80)
295: 				)
296: 				softReset();
297: 			// Increase in-game speed on R1
298: 			else if (
299: 				joystick.GetState()->rgbButtons[5] & 0x80
300: 				)
301: 				increaseSpeedhack();
302: 			// Decrease in-game speed on L1
303: 			else if (
304: 				joystick.GetState()->rgbButtons[4] & 0x80
305: 				)
306: 				decreaseSpeedhack();
307: 			// Toggle Speedhack on L2/R2
308: 			else if (
309: 				(joystick.GetState()->rgbButtons[6] & 0x80) ||
310: 				(joystick.GetState()->rgbButtons[7] & 0x80)
311: 				)
312: 				toggleSpeedhack();
313: 			// Toggle battle mode on Circle
314: 			else if (
315: 				joystick.GetState()->rgbButtons[2] & 0x80
316: 				)
317: 				toggleBattleMode();
318: 			// Toggle auto attack mode on Triangle
319: 			else if (
320: 				joystick.GetState()->rgbButtons[3] & 0x80
321: 				)
322: 				toggleAutoAttackMode();
323: 			// Skip Movies on Square
324: 			else if (
325: 				joystick.GetState()->rgbButtons[0] & 0x80
326: 				)
327: 				skipMovies();
328: 		}
329: 	}
330: }
331: 
332: double GameHacks::getCurrentSpeedhack()
333: {
334: 	return speedhack_enabled ? speedhack_current_speed : 1.0;
335: }
336: 
337: bool GameHacks::wantsBattle()
338: {
339: 	return battle_wanted;
340: }
341: 
342: bool GameHacks::isAutoAttack()
343: {
344: 	return auto_attack_mode;
345: }
346: 
347: void GameHacks::holdInput()
348: {
349: 	if(!enable_hold_input) return;
350: 	hold_input_for_frames = 30; // ~1 sec
351: 	enable_hold_input = false;
352: }
353: 
354: void GameHacks::drawnInput()
355: {
356: 	if (hold_input_for_frames > 0) hold_input_for_frames--;
357: }
358: 
359: bool GameHacks::canInputBeProcessed()
360: {
361: 	return !isGamepadShortcutMode && !isKeyboardShortcutMode;
362: }
</file>

<file path="src/gamehacks.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <stdint.h>
25: #include <windows.h>
26: 
27: class GameHacks
28: {
29: private:
30: 	uint16_t hold_input_for_frames = 0;
31: 	bool enable_hold_input = true;
32: 
33: 	bool speedhack_enabled;
34: 	double speedhack_current_speed;
35: 	bool battle_wanted = true;
36: 	bool auto_attack_mode = false;
37: 
38: 	// SPEEDHACK
39: 	void toggleSpeedhack();
40: 	void resetSpeedhack();
41: 	void increaseSpeedhack();
42: 	void decreaseSpeedhack();
43: 
44: 	// BATTLE
45: 	void toggleBattleMode();
46: 	void toggleAutoAttackMode();
47: 	void toggleMusicOnBattlePause();
48: 
49: 	// MOVIES
50: 	void skipMovies();
51: 
52: 	// SOFT RESET
53: 	void softReset();
54: 
55: 	// INPUT VALIDATION
56: 	void holdInput();
57: 	void drawnInput();
58: 
59: 	// VOICE AUTO TEXT
60: 	void toggleAutoText();
61: 
62: public:
63: 	void init();
64: 
65: 	// GLOBALS
66: 	void processKeyboardInput(UINT msg, WPARAM wParam, LPARAM lParam);
67: 	void processGamepadInput();
68: 
69: 	// SPEEDHACK
70: 	double getCurrentSpeedhack();
71: 
72: 	// BATTLE
73: 	bool wantsBattle();
74: 	bool isAutoAttack();
75: 
76: 	// INPUT VALIDATION
77: 	bool canInputBeProcessed();
78: 
79: private:
80: 	bool isKeyboardShortcutMode = false;
81: 	bool isGamepadShortcutMode = false;
82: };
83: 
84: extern GameHacks gamehacks;
</file>

<file path="src/gamepad.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <cmath>
 23: 
 24: #include "gamepad.h"
 25: 
 26: Gamepad gamepad;
 27: 
 28: int Gamepad::GetPort() const
 29: {
 30:     return cId + 1;
 31: }
 32: 
 33: XINPUT_GAMEPAD* Gamepad::GetState()
 34: {
 35:     return &state.Gamepad;
 36: }
 37: 
 38: const XINPUT_VIBRATION &Gamepad::GetVibrationState() const
 39: {
 40:     return vibration;
 41: }
 42: 
 43: bool Gamepad::Vibrate(WORD wLeftMotorSpeed, WORD wRightMotorSpeed)
 44: {
 45:     vibration.wLeftMotorSpeed = wLeftMotorSpeed;
 46:     vibration.wRightMotorSpeed = wRightMotorSpeed;
 47: 
 48:     if (cId == -1)
 49:         CheckConnection();
 50: 
 51:     if (cId != -1)
 52:     {
 53:         if (XInputSetState(cId, &vibration) != ERROR_SUCCESS)
 54:         {
 55:             cId = -1;
 56:             return false;
 57:         }
 58: 
 59:         return true;
 60:     }
 61: 
 62:     return false;
 63: }
 64: 
 65: bool Gamepad::CheckConnection()
 66: {
 67:     int controllerId = -1;
 68: 
 69:     for (DWORD i = 0; i < XUSER_MAX_COUNT && controllerId == -1; i++)
 70:     {
 71:         XINPUT_STATE state;
 72:         ZeroMemory(&state, sizeof(XINPUT_STATE));
 73: 
 74:         if (XInputGetState(i, &state) == ERROR_SUCCESS)
 75:             controllerId = i;
 76:     }
 77: 
 78:     cId = controllerId;
 79: 
 80:     return controllerId != -1;
 81: }
 82: 
 83: // Returns false if the controller has been disconnected
 84: bool Gamepad::Refresh()
 85: {
 86:     if (cId == -1)
 87:         CheckConnection();
 88: 
 89:     if (cId != -1)
 90:     {
 91:         ZeroMemory(&state, sizeof(XINPUT_STATE));
 92:         if (XInputGetState(cId, &state) != ERROR_SUCCESS)
 93:         {
 94:             cId = -1;
 95:             return false;
 96:         }
 97: 
 98:         float normLX = fmaxf(-1, (float)state.Gamepad.sThumbLX / 32767);
 99:         float normLY = fmaxf(-1, (float)state.Gamepad.sThumbLY / 32767);
100: 
101:         leftStickX = (abs(normLX) < deadzoneX ? 0 : (abs(normLX) - deadzoneX) * (normLX / abs(normLX)));
102:         leftStickY = (abs(normLY) < deadzoneY ? 0 : (abs(normLY) - deadzoneY) * (normLY / abs(normLY)));
103: 
104:         if (deadzoneX > 0) leftStickX *= 1 / (1 - deadzoneX);
105:         if (deadzoneY > 0) leftStickY *= 1 / (1 - deadzoneY);
106: 
107:         float normRX = fmaxf(-1, (float)state.Gamepad.sThumbRX / 32767);
108:         float normRY = fmaxf(-1, (float)state.Gamepad.sThumbRY / 32767);
109: 
110:         rightStickX = (abs(normRX) < deadzoneX ? 0 : (abs(normRX) - deadzoneX) * (normRX / abs(normRX)));
111:         rightStickY = (abs(normRY) < deadzoneY ? 0 : (abs(normRY) - deadzoneY) * (normRY / abs(normRY)));
112: 
113:         if (deadzoneX > 0) rightStickX *= 1 / (1 - deadzoneX);
114:         if (deadzoneY > 0) rightStickY *= 1 / (1 - deadzoneY);
115: 
116:         leftTrigger = (float)state.Gamepad.bLeftTrigger / 255;
117:         rightTrigger = (float)state.Gamepad.bRightTrigger / 255;
118: 
119:         return true;
120:     }
121:     return false;
122: }
123: 
124: bool Gamepad::IsPressed(WORD button) const
125: {
126:     return (state.Gamepad.wButtons & button) != 0;
127: }
128: 
129: bool Gamepad::IsIdle()
130: {
131:   return  !(gamepad.leftStickY > 0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_UP)) &&
132:           !(gamepad.leftStickY < -0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_DOWN)) &&
133:           !(gamepad.leftStickX < -0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_LEFT)) &&
134:           !(gamepad.leftStickX > 0.5f || gamepad.IsPressed(XINPUT_GAMEPAD_DPAD_RIGHT)) &&
135:           !gamepad.IsPressed(XINPUT_GAMEPAD_X) &&
136:           !gamepad.IsPressed(XINPUT_GAMEPAD_A) &&
137:           !gamepad.IsPressed(XINPUT_GAMEPAD_B) &&
138:           !gamepad.IsPressed(XINPUT_GAMEPAD_Y) &&
139:           !gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_SHOULDER)&&
140:           !gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_SHOULDER) &&
141:           !(gamepad.leftTrigger > 0.85f) &&
142:           !(gamepad.rightTrigger > 0.85f) &&
143:           !gamepad.IsPressed(XINPUT_GAMEPAD_BACK) &&
144:           !gamepad.IsPressed(XINPUT_GAMEPAD_START) &&
145:           !gamepad.IsPressed(XINPUT_GAMEPAD_START) &&
146:           !gamepad.IsPressed(XINPUT_GAMEPAD_LEFT_THUMB) &&
147:           !gamepad.IsPressed(XINPUT_GAMEPAD_RIGHT_THUMB) &&
148:           !gamepad.IsPressed(0x400);
149: }
</file>

<file path="src/gamepad.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <Windows.h>
25: #include <Xinput.h>
26: 
27: // Kudos to https://katyscode.wordpress.com/2013/08/30/xinput-tutorial-part-1-adding-gamepad-support-to-your-windows-game/
28: class Gamepad
29: {
30: private:
31:     int cId;
32:     XINPUT_STATE state;
33:     XINPUT_VIBRATION vibration;
34: 
35:     float deadzoneX;
36:     float deadzoneY;
37: 
38: public:
39:     Gamepad() : deadzoneX(0.05f), deadzoneY(0.02f) {}
40:     Gamepad(float dzX, float dzY) : deadzoneX(dzX), deadzoneY(dzY) {}
41: 
42:     float leftStickX;
43:     float leftStickY;
44:     float rightStickX;
45:     float rightStickY;
46:     float leftTrigger;
47:     float rightTrigger;
48: 
49:     int  GetPort() const;
50:     XINPUT_GAMEPAD* GetState();
51:     const XINPUT_VIBRATION &GetVibrationState() const;
52:     bool CheckConnection();
53:     // Get state from remote device
54:     bool Refresh();
55:     bool Vibrate(WORD wLeftMotorSpeed, WORD wRightMotorSpeed);
56:     bool IsPressed(WORD) const;
57:     bool IsIdle();
58: };
59: 
60: extern Gamepad gamepad;
</file>

<file path="src/gl.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include <map>
 26: #include <string>
 27: #include <vector>
 28: 
 29: #include "common.h"
 30: 
 31: #define VERTEX 1
 32: #define LVERTEX 2
 33: #define TLVERTEX 3
 34: 
 35: enum DrawCallType
 36: {
 37: 	DCT_CLEAR = 0,
 38: 	DCT_BLIT,
 39: 	DCT_DRAW,
 40: 	DCT_DRAW_MOVIE,
 41: 	DCT_BATTLE_DEPTH_CLEAR,
 42: 	DCT_ZOOM,
 43: 	DCT_WORLD_EXTERNAL_MESH,
 44: 	DCT_CLOUD_EXTERNAL_MESH,
 45: };
 46: 
 47: struct driver_state
 48: {
 49: 	struct texture_set *texture_set;
 50: 	uint32_t texture_handle;
 51: 	uint32_t blend_mode;
 52: 	uint32_t viewport[4];
 53: 	uint32_t fb_texture;
 54: 	uint32_t wireframe;
 55: 	uint32_t texture_filter;
 56: 	uint32_t cullface;
 57: 	uint32_t nocull;
 58: 	uint32_t depthtest;
 59: 	uint32_t depthmask;
 60: 	uint32_t shademode;
 61: 	uint32_t alphatest;
 62: 	uint32_t alphafunc;
 63: 	uint32_t alpharef;
 64: 	struct matrix world_view_matrix;
 65: 	struct matrix d3dprojection_matrix;
 66: };
 67: 
 68: struct deferred_draw
 69: {
 70: 	uint32_t primitivetype;
 71: 	uint32_t vertextype;
 72: 	uint32_t vertexcount;
 73: 	uint32_t count;
 74: 	struct nvertex* vertices;
 75: 	vector3<float>* normals;
 76: 	WORD *indices;
 77: 	struct boundingbox* boundingbox;
 78: 	uint32_t clip;
 79: 	uint32_t mipmap;
 80: 	struct driver_state state;
 81: 	struct light_data* lightdata;
 82: 	DrawCallType draw_call_type;
 83: 	struct texture_set *fb_texture_set;
 84: 	struct tex_header *fb_tex_header;
 85: 	uint32_t clear_color;
 86: 	uint32_t clear_depth;
 87: 	struct game_obj *game_object;
 88: 	uint32_t movie_buffer_index;
 89: 	bool is_time_filter_enabled;
 90: 	bool is_fog_enabled;
 91: };
 92: 
 93: struct deferred_sorted_draw
 94: {
 95: 	deferred_draw deferred_draw;
 96: 	double z;
 97: 	uint32_t drawn;
 98: };
 99: 
100: struct gl_texture_set
101: {
102: 	uint32_t textures;
103: 	uint32_t force_filter;
104: 	uint32_t force_zsort;
105: 	uint32_t disable_lighting;
106: 	uint32_t default_texture_id;
107: 	// ANIMATED TEXTURES
108: 	uint32_t is_animated;
109: 	std::map<std::string, uint32_t> animated_textures;
110: 	// ADDITIONAL TEXTURES
111: 	std::map<uint16_t, uint32_t> additional_textures;
112: };
113: 
114: extern struct matrix d3dviewport_matrix;
115: 
116: extern struct driver_state current_state;
117: 
118: extern uint32_t current_program;
119: 
120: extern int max_texture_size;
121: 
122: typedef void (*draw_field_shadow_callback)(void);
123: 
124: void gl_draw_movie_quad(uint32_t width, uint32_t height);
125: void gl_save_state(struct driver_state *dest);
126: void gl_load_state(struct driver_state *src);
127: uint32_t gl_defer_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex* vertices, struct vector3<float>* normals, uint32_t vertexcount, WORD* indices, uint32_t count, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap);
128: uint32_t gl_defer_sorted_draw(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, uint32_t clip, uint32_t mipmap, uint32_t force_defer);
129: uint32_t gl_defer_blit_framebuffer(struct texture_set *texture_set, struct tex_header *tex_header);
130: uint32_t gl_defer_clear_buffer(uint32_t clear_color, uint32_t clear_depth, struct game_obj *game_object);
131: uint32_t gl_defer_yuv_frame(uint32_t buffer_index);
132: uint32_t gl_defer_battle_depth_clear();
133: uint32_t gl_defer_zoom();
134: uint32_t gl_defer_world_external_mesh();
135: uint32_t gl_defer_cloud_external_mesh();
136: void gl_draw_deferred(draw_field_shadow_callback shadow_callback);
137: struct boundingbox calculateSceneAabb();
138: void gl_draw_sorted_deferred();
139: void gl_check_deferred(struct texture_set *texture_set);
140: void gl_cleanup_deferred();
141: uint32_t gl_special_case(uint32_t primitivetype, uint32_t vertextype, struct nvertex *vertices, uint32_t vertexcount, WORD *indices, uint32_t count, struct graphics_object *graphics_object, uint32_t clip, uint32_t mipmap);
142: void gl_calculate_normals(std::vector<vector3<float>>* normals, struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata);
143: void gl_draw_without_lighting(struct indexed_primitive* ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip);
144: void gl_draw_with_lighting(struct indexed_primitive *ip, struct polygon_data *polydata, struct light_data* lightdata, uint32_t clip);
145: void gl_draw_indexed_primitive(uint32_t, uint32_t, struct nvertex *, struct vector3<float>* normals, uint32_t, WORD *, uint32_t, struct graphics_object *, struct boundingbox* boundingbox, struct light_data* lightdata, uint32_t clip, uint32_t mipmap);
146: void gl_set_worldview_matrix(struct matrix *matrix);
147: void gl_set_d3dprojection_matrix(struct matrix *matrix);
148: void gl_set_blend_func(uint32_t);
149: bool gl_check_texture_dimensions(uint32_t width, uint32_t height, char *source);
150: void gl_replace_texture(struct texture_set *texture_set, uint32_t palette_index, uint32_t new_texture);
151: void gl_upload_texture(struct texture_set *texture_set, uint32_t palette_index, void *image_data, uint32_t format);
152: void gl_bind_texture_set(struct texture_set *);
153: void gl_set_texture(uint32_t texture, struct gl_texture_set* gl_set);
154: uint32_t gl_draw_text(uint32_t x, uint32_t y, uint32_t color, uint32_t alpha, char *fmt, ...);
</file>

<file path="src/globals.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #pragma once
 23: 
 24: #include <mimalloc-new-delete.h>
 25: #include <windows.h>
 26: #include <toml++/toml.h>
 27: 
 28: #if defined(__cplusplus)
 29: extern "C" {
 30: #endif
 31: 
 32: #include <libavcodec/avcodec.h>
 33: #include <libavformat/avformat.h>
 34: #include <libavutil/imgutils.h>
 35: #include <libswscale/swscale.h>
 36: #include <libswresample/swresample.h>
 37: 
 38: #if defined(__cplusplus)
 39: }
 40: #endif
 41: 
 42: #include "ff7.h"
 43: #include "ff8.h"
 44: 
 45: #define FFNX_API __declspec(dllexport)
 46: 
 47: extern HINSTANCE gameHinstance;
 48: extern HWND gameHwnd;
 49: 
 50: extern MEMORYSTATUSEX last_ram_state;
 51: extern uint32_t version;
 52: extern uint32_t steam_edition;
 53: extern uint32_t steam_stock_launcher;
 54: extern uint32_t estore_edition;
 55: extern uint32_t ff7_japanese_edition;
 56: extern uint32_t ff7_do_reset;
 57: 
 58: #define BASEDIR_LENGTH 512
 59: extern char basedir[BASEDIR_LENGTH];
 60: 
 61: extern uint32_t game_width;
 62: extern uint32_t game_height;
 63: extern uint32_t x_offset;
 64: extern uint32_t y_offset;
 65: extern uint32_t widescreen_enabled;
 66: 
 67: extern struct texture_format *texture_format;
 68: 
 69: extern struct ff7_externals ff7_externals;
 70: extern struct ff8_externals ff8_externals;
 71: extern struct common_externals common_externals;
 72: extern struct driver_stats stats;
 73: 
 74: extern char popup_msg[];
 75: extern uint32_t popup_ttl;
 76: extern uint32_t popup_color;
 77: 
 78: extern struct game_mode modes[];
 79: extern uint32_t num_modes;
 80: 
 81: extern uint32_t text_colors[];
 82: 
 83: extern uint32_t ff8;
 84: 
 85: extern uint32_t frame_counter;
 86: extern double frame_rate;
 87: extern int battle_frame_multiplier;
 88: extern int common_frame_multiplier;
 89: 
 90: extern bool xinput_connected;
 91: extern bool simulate_OK_button;
 92: extern GamepadAnalogueIntent gamepad_analogue_intent;
 93: 
 94: extern bool next_music_is_battle;
 95: extern uint16_t next_battle_scene_id;
 96: 
 97: extern char *get_current_field_name();
 98: extern uint32_t noop();
 99: extern uint32_t noop_a1(uint32_t a1);
100: extern uint32_t noop_a2(uint32_t a1, uint32_t a2);
101: extern uint32_t noop_a3(uint32_t a1, uint32_t a2, uint32_t a3);
</file>

<file path="src/hext.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "hext.h"
 23: #include "log.h"
 24: #include "patch.h"
 25: #include "utils.h"
 26: #include <fstream>
 27: #include <filesystem>
 28: #include <io.h>
 29: 
 30: Hext hextPatcher;
 31: 
 32: // PRIVATE
 33: 
 34: int Hext::getAddress(std::string token)
 35: {
 36:     int ret;
 37: 
 38:     std::vector<std::string> sparts = split(token, "[+-]+");
 39:     std::vector<int> iparts;
 40: 
 41:     if (ends_with(sparts[0], "^"))
 42:     {
 43:         std::stringstream ss;
 44:         int *ptr = (int*)(std::stoi(sparts[0].substr(0, sparts[0].length() - 1), nullptr, 16) + inGlobalOffset);
 45:         ss << std::hex << *ptr;
 46:         sparts[0] = ss.str();
 47:     }
 48: 
 49:     for (auto &part : sparts)
 50:     {
 51:         iparts.push_back(
 52:             std::stoi(part, nullptr, 16)
 53:         );
 54:     }
 55: 
 56:     ret = iparts[0];
 57: 
 58:     if (contains(token, "+"))
 59:     {
 60:         ret += iparts[1];
 61:     }
 62:     else if (contains(token, "-"))
 63:     {
 64:         ret -= iparts[1];
 65:     }
 66: 
 67:     return ret + inGlobalOffset;
 68: }
 69: 
 70: std::vector<char> Hext::getBytes(std::string token)
 71: {
 72:     std::vector<char> ret;
 73: 
 74:     if (contains(token, ":"))
 75:     {
 76:         std::vector<std::string> parts = split(token, "[:]+");
 77:         int count = std::stoi(parts[1], nullptr, 0);
 78:         while (count > 0)
 79:         {
 80:             ret.push_back(std::stoi(parts[0], nullptr, 16));
 81:             count--;
 82:         }
 83:     }
 84:     else
 85:     {
 86:         std::vector<std::string> bytes = split(token, "[\\s,\\t]+");
 87: 
 88:         for (auto byte : bytes)
 89:         {
 90:             ret.push_back(std::stoi(byte, nullptr, 16));
 91:         }
 92:     }
 93: 
 94:     return ret;
 95: }
 96: 
 97: bool Hext::hasCheckpoint(std::string token)
 98: {
 99:     if (starts_with(token, "!"))
100:     {
101:         return true;
102:     }
103: 
104:     return false;
105: }
106: 
107: bool Hext::parseCheckpoint(std::string token, std::string checkpoint)
108: {
109:     if (starts_with(token, "!"))
110:     {
111:         if (contains(token, checkpoint))
112:         {
113:             return true;
114:         }
115:     }
116: 
117:     return false;
118: }
119: 
120: bool Hext::parseCommands(std::string token)
121: {
122:     if (starts_with(token, "<<"))
123:     {
124:         replaceOnce(token, "<<", "");
125: 
126:         trim(token);
127: 
128:         ffnx_trace("%s\n", token.data());
129: 
130:         return true;
131:     }
132: 
133:     return false;
134: }
135: 
136: bool Hext::parseComment(std::string token)
137: {
138:     if (isMultilineComment)
139:     {
140:         if (ends_with(token, "}}")) isMultilineComment = false;
141:         return true;
142:     }
143: 
144:     if (starts_with(token, "{{"))
145:     {
146:         isMultilineComment = true;
147:         return true;
148:     }
149: 
150:     if (starts_with(token, "#")) return true;
151:     if (starts_with(token, "{")) return true;
152:     if (starts_with(token, ".")) return true;
153: 
154:     return false;
155: }
156: 
157: bool Hext::parseGlobalOffset(std::string token)
158: {
159:     if (starts_with(token, "+"))
160:     {
161:         inGlobalOffset = std::stoi(token.substr(1), nullptr, 16);
162: 
163:         return true;
164:     }
165:     else if (starts_with(token, "-"))
166:     {
167:         inGlobalOffset = -std::stoi(token.substr(1), nullptr, 16);
168: 
169:         return true;
170:     }
171: 
172:     return false;
173: }
174: 
175: bool Hext::parseMemoryPermission(std::string token)
176: {
177:     if (contains(token, ":"))
178:     {
179:         DWORD dummy;
180: 
181:         std::vector<std::string> parts = split(token, "[:]+");
182:         int addr = getAddress(parts[0]);
183:         int length = std::stoi(parts[1], nullptr, 16);
184: 
185:         VirtualProtect((LPVOID)addr, length, PAGE_EXECUTE_READWRITE, &dummy);
186: 
187:         return true;
188:     }
189: 
190:     return false;
191: }
192: 
193: bool Hext::parseMemoryPatch(std::string token)
194: {
195:     if (contains(token, "="))
196:     {
197:         DWORD dummy;
198: 
199:         std::vector<std::string> parts = split(token, "[=]+");
200:         int addr = getAddress(parts[0]);
201:         std::vector<char> bytes = getBytes(parts[1]);
202: 
203:         memcpy_code(addr, bytes.data(), bytes.size());
204: 
205:         return true;
206:     }
207: 
208:     return false;
209: }
210: 
211: // PUBLIC
212: 
213: void Hext::apply(std::string filename)
214: {
215:     std::string line;
216:     std::ifstream ifs(filename);
217: 
218:     while (std::getline(ifs, line))
219:     {
220:         if (line.empty()) continue;
221: 
222:         // Check if delayed, if so it should not be applied
223:         if (hasCheckpoint(line)) {
224:             ifs.close();
225:             return;
226:         }
227: 
228:         // Check if is a comment
229:         if (parseComment(line)) continue;
230: 
231:         // Check if is a command
232:         if (parseCommands(line)) continue;
233: 
234:         // Check if is a global offset
235:         if (parseGlobalOffset(line)) continue;
236: 
237:         // Check if is a memory permission range
238:         if (parseMemoryPermission(line)) continue;
239: 
240:         // Check if is a memory patch instruction
241:         if (parseMemoryPatch(line)) continue;
242:     }
243: 
244:     ifs.close();
245: 
246:     ffnx_trace("Applied Hext patch: %s\n", filename.c_str());
247: }
248: 
249: void Hext::applyDelayed(std::string filename, std::string checkpoint)
250: {
251:     std::string line;
252:     std::ifstream ifs(filename);
253: 
254:     bool matchCheckpoint = false;
255: 
256:     while (std::getline(ifs, line))
257:     {
258:         if (line.empty()) continue;
259: 
260:         // Check if is a comment
261:         if (parseComment(line)) continue;
262: 
263:         // Check if is a delayed patch.
264:         if (parseCheckpoint(line, checkpoint)) {
265:             matchCheckpoint = true;
266: 
267:             continue;
268:         }
269: 
270:         if (matchCheckpoint)
271:         {
272:             // Check if is a command
273:             if (parseCommands(line)) continue;
274: 
275:             // Check if is a global offset
276:             if (parseGlobalOffset(line)) continue;
277: 
278:             // Check if is a memory permission range
279:             if (parseMemoryPermission(line)) continue;
280: 
281:             // Check if is a memory patch instruction
282:             if (parseMemoryPatch(line)) continue;
283:         }
284:         else
285:         {
286:             break;
287:         }
288:     }
289: 
290:     ifs.close();
291: 
292:     if (matchCheckpoint) ffnx_trace("Applied delayed Hext patch: %s\n", filename.c_str());
293: }
294: 
295: void Hext::applyAll(std::string checkpoint)
296: {
297:     if (fileExists(hext_patching_path.c_str()))
298:     {
299:         if (!checkpoint.empty())
300:         {
301:             for (const auto& entry : std::filesystem::directory_iterator(hext_patching_path))
302:             {
303:                 if (entry.is_regular_file()) {
304:                     applyDelayed(entry.path().string(), checkpoint);
305:                 }
306: 
307:                 inGlobalOffset = 0;
308:             }
309:         }
310:         else
311:         {
312:             for (const auto& entry : std::filesystem::directory_iterator(hext_patching_path))
313:             {
314:                 if (entry.is_regular_file()) {
315:                     apply(entry.path().string());
316:                 }
317: 
318:                 inGlobalOffset = 0;
319:             }
320:         }
321:     }
322: }
</file>

<file path="src/hext.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: /*
23: 	HEXT Specification by DLPB
24: 
25: 	See https://forums.qhimm.com/index.php?topic=13574.0
26: 
27: 	This implementation may differ from the original specification as new required functionalities will be implemented,
28: 	in order to ease modders life.
29: */
30: 
31: #pragma once
32: 
33: #include <string>
34: #include <vector>
35: 
36: class Hext {
37: private:
38: 	int inGlobalOffset;
39: 	bool isMultilineComment = false;
40: 
41: 	int getAddress(std::string token);
42: 	std::vector<char> getBytes(std::string token);
43: 
44: 	bool hasCheckpoint(std::string token);
45: 	bool parseCheckpoint(std::string token, std::string checkpoint);
46: 	bool parseCommands(std::string token);
47: 	bool parseComment(std::string token);
48: 	bool parseGlobalOffset(std::string token);
49: 	bool parseMemoryPermission(std::string token);
50: 	bool parseMemoryPatch(std::string token);
51: 
52: public:
53: 	void apply(std::string filename);
54: 	void applyDelayed(std::string filename, std::string checkpoint);
55: 	void applyAll(std::string checkpoint = std::string());
56: };
57: 
58: extern Hext hextPatcher;
</file>

<file path="src/input.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <windowsx.h>
 23: #include <dinput.h>
 24: #include "input.h"
 25: #include "gamehacks.h"
 26: #include "globals.h"
 27: 
 28: byte keys[256];
 29: bool blockKeys = false;
 30: 
 31: void SetBlockKeysFromGame(bool block) {
 32:     blockKeys = block;
 33: }
 34: 
 35: void MouseDown(MouseEventArgs e)
 36: {
 37:     for (MouseListener* listener : mouseListeners)
 38:         listener->MouseDown(e);
 39: }
 40: 
 41: void MouseUp(MouseEventArgs e)
 42: {
 43:     for (MouseListener* listener : mouseListeners)
 44:         listener->MouseUp(e);
 45: }
 46: 
 47: void MouseWheel(MouseEventArgs e)
 48: {
 49:     for (MouseListener* listener : mouseListeners)
 50:         listener->MouseWheel(e);
 51: }
 52: 
 53: void MouseMove(MouseEventArgs e)
 54: {
 55:     for (MouseListener* listener : mouseListeners)
 56:         listener->MouseMove(e);
 57: }
 58: 
 59: void KeyUp(KeyEventArgs e)
 60: {
 61:     for (KeyListener* listener : keyListeners)
 62:         listener->KeyUp(e);
 63: }
 64: 
 65: void KeyDown(KeyEventArgs e)
 66: {
 67:     for (KeyListener* listener : keyListeners)
 68:         listener->KeyDown(e);
 69: }
 70: 
 71: void KeyPress(KeyPressEventArgs e)
 72: {
 73:     for (KeyListener* listener : keyListeners)
 74:         listener->KeyPress(e);
 75: }
 76: 
 77: void RefreshDevices()
 78: {
 79: 
 80: }
 81: 
 82: // Handles inputs coming from the WindowProc function - originates from DispatchMessage in the message loop
 83: bool HandleInputEvents(UINT msg, WPARAM wParam, LPARAM lParam)
 84: {
 85:     switch (msg) {
 86:     case WM_LBUTTONDOWN:
 87:     case WM_RBUTTONDOWN:
 88:     case WM_MBUTTONDOWN:
 89:     case WM_XBUTTONDOWN:
 90:     {
 91:         int button = 0;
 92:         if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) { button = 1; }
 93:         if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) { button = 2; }
 94:         if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) { button = 3; }
 95:         if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 4 : 5; }
 96:         MouseDown(MouseEventArgs{
 97:             (int)button,
 98:             0,
 99:             GET_X_LPARAM(lParam),
100:             GET_Y_LPARAM(lParam),
101:             });
102:         return true;
103:     }
104:     case WM_LBUTTONUP:
105:     case WM_RBUTTONUP:
106:     case WM_MBUTTONUP:
107:     case WM_XBUTTONUP:
108:     {
109:         int button = 0;
110:         if (msg == WM_LBUTTONUP) { button = 1; }
111:         if (msg == WM_RBUTTONUP) { button = 2; }
112:         if (msg == WM_MBUTTONUP) { button = 3; }
113:         if (msg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 4 : 5; }
114:         MouseUp(MouseEventArgs{
115:             (int)button,
116:             0,
117:             GET_X_LPARAM(lParam),
118:             GET_Y_LPARAM(lParam)
119:             });
120:         return true;
121:     }
122:     case WM_MOUSEWHEEL:
123:         MouseWheel(MouseEventArgs{
124:             0,
125:             GET_WHEEL_DELTA_WPARAM(wParam) / WHEEL_DELTA,
126:             GET_X_LPARAM(lParam),
127:             GET_Y_LPARAM(lParam)
128:             });
129:         return true;
130:     case WM_MOUSEMOVE:
131:         MouseMove(MouseEventArgs{
132:             0,
133:             0,
134:             GET_X_LPARAM(lParam),
135:             GET_Y_LPARAM(lParam)
136:             });
137:         return true;
138:     case WM_KEYDOWN:
139:     case WM_SYSKEYDOWN:
140:         KeyDown(KeyEventArgs{
141:             (int)wParam,
142:             (bool)((lParam >> 24) & 1)
143:             });
144:         return true;
145:     case WM_KEYUP:
146:     case WM_SYSKEYUP:
147:         KeyUp(KeyEventArgs{
148:             (int)wParam,
149:             (bool)((lParam >> 24) & 1)
150:             });
151:         return true;
152:     case WM_CHAR:
153:         KeyPress(KeyPressEventArgs{
154:             (int)wParam
155:             });
156:         return true;
157:     case WM_DEVICECHANGE:
158:         RefreshDevices();
159:         return true;
160:     }
161:     return false;
162: }
163: 
164: // Handles polling the keyboard input using DirectInput
165: byte* GetGameKeyState()
166: {
167:     IDirectInputDeviceA* keyboard_device = *common_externals.keyboard_device;
168:     if (keyboard_device != NULL)
169:     {
170:         if (blockKeys || !gamehacks.canInputBeProcessed())
171:         {
172:             std::memset(keys, 0, 256);
173:             return keys;
174:         }
175: 
176:         // This is the existing functionality but retries on any error rather than just DIERR_INPUTLOST
177:         if (keyboard_device->GetDeviceState(256, keys) == 0)
178:             return keys;
179: 
180:         *common_externals.keyboard_connected = 0;
181:         if (common_externals.dinput_acquire_keyboard() != 0 && keyboard_device->GetDeviceState(256, keys) != 0)
182:             return keys;
183:     }
184:     return NULL;
185: }
</file>

<file path="src/input.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <windows.h>
25: #include <vector>
26: 
27: struct KeyEventArgs
28: {
29: 	int keyValue;
30: 	bool isExtended;
31: };
32: 
33: struct KeyPressEventArgs
34: {
35: 	int keyChar;
36: };
37: 
38: struct MouseEventArgs
39: {
40: 	int button;
41: 	int delta;
42: 	int x;
43: 	int y;
44: };
45: 
46: class MouseListener
47: {
48: public:
49: 	virtual void MouseDown(MouseEventArgs e) = 0;
50: 	virtual void MouseUp(MouseEventArgs e) = 0;
51: 	virtual void MouseWheel(MouseEventArgs e) = 0;
52: 	virtual void MouseMove(MouseEventArgs e) = 0;
53: };
54: 
55: class KeyListener
56: {
57: public:
58: 	virtual void KeyUp(KeyEventArgs e) = 0;
59: 	virtual void KeyDown(KeyEventArgs e) = 0;
60: 	virtual void KeyPress(KeyPressEventArgs e) = 0;
61: };
62: 
63: std::vector<MouseListener*> mouseListeners;
64: std::vector<KeyListener*> keyListeners;
65: 
66: void SetBlockKeysFromGame(bool block = false);
67: bool HandleInputEvents(UINT msg, WPARAM wParam, LPARAM lParam);
68: byte* GetGameKeyState();
</file>

<file path="src/joystick.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <wbemidl.h>
 23: #include <oleauto.h>
 24: 
 25: #include "joystick.h"
 26: #include "log.h"
 27: 
 28: #ifndef SAFE_RELEASE
 29: #define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }
 30: #endif
 31: 
 32: Joystick joystick;
 33: 
 34: BOOL CALLBACK Joystick::staticEnumerateGameControllers(LPCDIDEVICEINSTANCE devInst, LPVOID pvRef)
 35: {
 36: 	Joystick* inputHandlerInstance = (Joystick*)pvRef;
 37: 	return inputHandlerInstance->enumerateGameControllers(devInst);
 38: }
 39: 
 40: BOOL CALLBACK Joystick::staticSetGameControllerProperties(LPCDIDEVICEOBJECTINSTANCE devObjInst, LPVOID pvRef)
 41: {
 42:   // the game controller
 43: 	LPDIRECTINPUTDEVICE8 gameController = (LPDIRECTINPUTDEVICE8)pvRef;
 44: 	gameController->Unacquire();
 45: 
 46:   // structure to hold game controller range properties
 47: 	DIPROPRANGE gameControllerRange;
 48: 
 49: 	// set the range to -32768 and 32768
 50: 	gameControllerRange.lMin = SHRT_MIN;
 51: 	gameControllerRange.lMax = SHRT_MAX;
 52: 
 53: 	// set the size of the structure
 54: 	gameControllerRange.diph.dwSize = sizeof(DIPROPRANGE);
 55: 	gameControllerRange.diph.dwHeaderSize = sizeof(DIPROPHEADER);
 56: 
 57: 	// set the object that we want to change
 58: 	gameControllerRange.diph.dwHow = DIPH_BYID;
 59: 	gameControllerRange.diph.dwObj = devObjInst->dwType;
 60: 
 61: 	// now set the range for the axis
 62: 	if (FAILED(gameController->SetProperty(DIPROP_RANGE, &gameControllerRange.diph)))
 63: 		return DIENUM_STOP;
 64: 
 65: 	return DIENUM_CONTINUE;
 66: }
 67: 
 68: BOOL Joystick::enumerateGameControllers(LPCDIDEVICEINSTANCE devInst)
 69: {
 70:   if(isXInputDevice(&devInst->guidProduct))
 71:     return DIENUM_CONTINUE;
 72: 
 73: 	// enumerate devices
 74: 	LPDIRECTINPUTDEVICE8 gameController;
 75: 
 76: 	// create interface for the current game controller
 77: 	if (FAILED(dev->CreateDevice(devInst->guidInstance, &gameController, NULL)))
 78: 		return DIENUM_CONTINUE;
 79: 	else
 80: 	{
 81:     if (trace_all || trace_gamepad)
 82:     {
 83:       // get game controller name
 84:       DIDEVICEINSTANCE deviceInfo;
 85:       deviceInfo.dwSize = sizeof(DIDEVICEINSTANCE);
 86:       gameController->GetDeviceInfo(&deviceInfo);
 87:       ffnx_trace("Found DInput Gamepad #%d: %s\n", gameControllers.size(), deviceInfo.tszInstanceName);
 88:     }
 89: 
 90: 		// store the game controller
 91: 		gameControllers.push_back(gameController);
 92: 		return DIENUM_CONTINUE;
 93: 	}
 94: }
 95: 
 96: LPDIJOYSTATE2 Joystick::GetState()
 97: {
 98:   return &currentState;
 99: }
100: 
101: LPDIDEVCAPS Joystick::GetCaps()
102: {
103:   return &caps;
104: }
105: 
106: bool Joystick::CheckConnection()
107: {
108:   if (dev == nullptr)
109:   {
110:     // initialize the main DirectInput 8 device
111:     if (FAILED(DirectInput8Create(gameHinstance, DIRECTINPUT_VERSION, IID_IDirectInput8, (void **)&dev, NULL)))
112:       return false;
113: 
114:     gameControllers.clear();
115: 
116:     // enumerate all available game controllers. Attempt to fetch the ones that support force feedback
117:     if (FAILED(dev->EnumDevices(DI8DEVCLASS_GAMECTRL, &staticEnumerateGameControllers, this, DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK)))
118:       return false;
119: 
120:     // If the collection is empty it means the API call was successful but no device was found. Re-iterate without force feedback this time.
121:     if (!gameControllers.empty())
122:       gameControllerSupportsVibration = true;
123:     else
124:     {
125:       if (FAILED(dev->EnumDevices(DI8DEVCLASS_GAMECTRL, &staticEnumerateGameControllers, this, DIEDFL_ATTACHEDONLY)))
126:         return false;
127:     }
128: 
129:     if (gameControllers.empty())
130:       return false;
131: 
132:     gameController = gameControllers.at(0);
133: 
134:     // Get controller capabilities
135:     caps.dwSize = sizeof(DIDEVCAPS);
136: 
137:     if (FAILED(gameController->GetCapabilities(&caps)))
138:       return false;
139: 
140:     if (trace_all || trace_gamepad)
141:     {
142:       // get game controller name
143:       DIDEVICEINSTANCE deviceInfo;
144:       deviceInfo.dwSize = sizeof(DIDEVICEINSTANCE);
145:       gameController->GetDeviceInfo(&deviceInfo);
146:       ffnx_trace("Using Gamepad: %s (Supports Force Feedback: %s)\n", deviceInfo.tszInstanceName, gameControllerSupportsVibration ? "yes" : "no");
147:     }
148: 
149:     // set cooperative level
150:     if (FAILED(gameController->SetCooperativeLevel(gameHwnd, ((ff8 && ff8_always_capture_input) ? DISCL_BACKGROUND : DISCL_FOREGROUND) | DISCL_NONEXCLUSIVE)))
151:       return false;
152: 
153:     // set data format
154:     if (FAILED(gameController->SetDataFormat(&c_dfDIJoystick2)))
155:       return false;
156: 
157:     // set range and dead zone of joystick axes
158:     if (FAILED(gameController->EnumObjects(&staticSetGameControllerProperties, gameController, DIDFT_AXIS)))
159:       return false;
160: 
161:     // get game controller max force feedback supported magnitude
162:     if (gameControllerSupportsVibration)
163:     {
164:       gameControllerInfo.dwSize = sizeof(DIDEVICEOBJECTINSTANCE);
165: 
166:       if (FAILED(gameController->GetObjectInfo(&gameControllerInfo, DIDFT_AXIS, DIPH_BYID)))
167:         return false;
168:     }
169:   }
170: 
171:   // clean joystick states
172:   ZeroMemory(&currentState, sizeof(DIJOYSTATE2));
173: 
174:   return gameController != nullptr;
175: }
176: 
177: // poll
178: bool Joystick::Refresh()
179: {
180:   HRESULT hr;
181: 
182:   // Return if no joystick detected
183:   if (!CheckConnection()) return false;
184: 
185:   // poll the device to read the current state
186:   hr = gameController->Poll();
187: 
188:   if (FAILED(hr))
189:   {
190:     // DirectInput lost the device, try to re-acquire it
191:     hr = gameController->Acquire();
192:     while (hr == DIERR_INPUTLOST)
193:       hr = gameController->Acquire();
194: 
195:     // return if a fatal error is encountered
196:     if ((hr == DIERR_INVALIDPARAM) || (hr == DIERR_NOTINITIALIZED))
197:       return false;
198: 
199:     // if another application has control of this device, we have to wait for our turn
200:     if (hr == DIERR_OTHERAPPHASPRIO)
201:       return false;
202:   }
203: 
204:   // now if everything is okay, we can get the state of the device
205:   if (FAILED(hr = gameController->GetDeviceState(sizeof(DIJOYSTATE2), &currentState)))
206:     return false;
207: 
208:   return true;
209: }
210: 
211: bool Joystick::HasAnalogTriggers()
212: {
213:   return caps.dwAxes >=6;
214: }
215: 
216: void Joystick::Clean()
217: {
218:   for (LPDIRECTINPUTDEVICE8 controller : gameControllers)
219:     SAFE_RELEASE(controller);
220: 
221:   SAFE_RELEASE(dev);
222: 
223:   dev = nullptr;
224:   gameController = nullptr;
225:   gameControllers.clear();
226: }
227: 
228: LONG Joystick::GetDeadZone(float percent)
229: {
230:   return SHRT_MAX * percent;
231: }
232: 
233: bool Joystick::HasForceFeedback()
234: {
235:   return gameControllerSupportsVibration;
236: }
237: 
238: DWORD Joystick::GetMaxVibration()
239: {
240:   return gameControllerSupportsVibration ? gameControllerInfo.dwFFMaxForce : 0;
241: }
242: 
243: void Joystick::Vibrate(WORD leftMotorSpeed, WORD rightMotorSpeed)
244: {
245:   if (gameControllerSupportsVibration)
246:   {
247:     DWORD      dwAxes[2] = { DIJOFS_X, DIJOFS_Y };
248:     LONG       lDirection[2] = { leftMotorSpeed, rightMotorSpeed };
249: 
250:     DIPERIODIC diPeriodic;      // type-specific parameters
251:     DIENVELOPE diEnvelope;      // envelope
252:     DIEFFECT   diEffect;        // general parameters
253: 
254:     // setup the periodic structure
255:     diPeriodic.dwMagnitude = DI_FFNOMINALMAX;
256:     diPeriodic.lOffset = 0;
257:     diPeriodic.dwPhase = 0;
258:     diPeriodic.dwPeriod = (DWORD) (0.05 * DI_SECONDS);
259: 
260:     // set the modulation envelope
261:     diEnvelope.dwSize = sizeof(DIENVELOPE);
262:     diEnvelope.dwAttackLevel = 0;
263:     diEnvelope.dwAttackTime = (DWORD) (0.01 * DI_SECONDS);
264:     diEnvelope.dwFadeLevel = 0;
265:     diEnvelope.dwFadeTime = (DWORD) (3.0 * DI_SECONDS);
266: 
267:     // set up the effect structure itself
268:     diEffect.dwSize = sizeof(DIEFFECT);
269:     diEffect.dwFlags = DIEFF_POLAR | DIEFF_OBJECTOFFSETS;
270:     diEffect.dwDuration = (DWORD) INFINITE; // (1 * DI_SECONDS);
271: 
272:     // set up details of effect
273:     diEffect.dwSamplePeriod = 0;               // = default
274:     diEffect.dwGain = DI_FFNOMINALMAX;         // no scaling
275:     diEffect.dwTriggerButton = DIJOFS_BUTTON0; // connect effect to trigger button
276:     diEffect.dwTriggerRepeatInterval = 0;
277:     diEffect.cAxes = 2;
278:     diEffect.rgdwAxes = dwAxes;
279:     diEffect.rglDirection = &lDirection[0];
280:     diEffect.lpEnvelope = &diEnvelope;
281:     diEffect.cbTypeSpecificParams = sizeof(diPeriodic);
282:     diEffect.lpvTypeSpecificParams = &diPeriodic;
283: 
284:     // create the effect and get the interface to it
285:     if (SUCCEEDED(gameController->CreateEffect(GUID_Square, &diEffect, &gameControllerEffect, NULL)))
286:       // Play the effect
287:       gameControllerEffect->Start(1, DIES_SOLO);
288:   }
289: }
290: 
291: bool Joystick::IsIdle()
292: {
293:   return  !(joystick.GetState()->lY < joystick.GetDeadZone(-0.5f) || joystick.GetState()->rgdwPOV[0] == 0) &&
294:           !(joystick.GetState()->lY > joystick.GetDeadZone(0.5f) || joystick.GetState()->rgdwPOV[0] == 18000) &&
295:           !(joystick.GetState()->lX < joystick.GetDeadZone(-0.5f) || joystick.GetState()->rgdwPOV[0] == 27000) &&
296:           !(joystick.GetState()->lX > joystick.GetDeadZone(0.5f) || joystick.GetState()->rgdwPOV[0] == 9000) &&
297:           !(joystick.GetState()->rgbButtons[0] & 0x80) &&
298:           !(joystick.GetState()->rgbButtons[1] & 0x80) &&
299:           !(joystick.GetState()->rgbButtons[2] & 0x80) &&
300:           !(joystick.GetState()->rgbButtons[3] & 0x80) &&
301:           !(joystick.GetState()->rgbButtons[4] & 0x80) &&
302:           !(joystick.GetState()->rgbButtons[5] & 0x80) &&
303:           !(joystick.GetState()->rgbButtons[6] & 0x80) &&
304:           !(joystick.GetState()->rgbButtons[7] & 0x80) &&
305:           !(joystick.GetState()->rgbButtons[8] & 0x80) &&
306:           !(joystick.GetState()->rgbButtons[9] & 0x80) &&
307:           !(joystick.GetState()->rgbButtons[10] & 0x80) &&
308:           !(joystick.GetState()->rgbButtons[11] & 0x80) &&
309:           !(joystick.GetState()->rgbButtons[12] & 0x80);
310: }
311: 
312: //-----------------------------------------------------------------------------
313: // Enum each PNP device using WMI and check each device ID to see if it contains
314: // "IG_" (ex. "VID_045E&PID_028E&IG_00").  If it does, then it's an XInput device
315: // Unfortunately this information can not be found by just using DirectInput
316: //-----------------------------------------------------------------------------
317: BOOL Joystick::isXInputDevice(const GUID* pGuidProductFromDirectInput)
318: {
319:   IWbemLocator*           pIWbemLocator  = NULL;
320:   IEnumWbemClassObject*   pEnumDevices   = NULL;
321:   IWbemClassObject*       pDevices[20]   = {0};
322:   IWbemServices*          pIWbemServices = NULL;
323:   BSTR                    bstrNamespace  = NULL;
324:   BSTR                    bstrDeviceID   = NULL;
325:   BSTR                    bstrClassName  = NULL;
326:   DWORD                   uReturned      = 0;
327:   bool                    bIsXinputDevice= false;
328:   UINT                    iDevice        = 0;
329:   VARIANT                 var;
330:   HRESULT                 hr;
331: 
332:   // CoInit if needed
333:   hr = CoInitialize(NULL);
334:   bool bCleanupCOM = SUCCEEDED(hr);
335: 
336:   // So we can call VariantClear() later, even if we never had a successful IWbemClassObject::Get().
337:   VariantInit(&var);
338: 
339:   // Create WMI
340:   hr = CoCreateInstance(__uuidof(WbemLocator), NULL, CLSCTX_INPROC_SERVER, __uuidof(IWbemLocator), (LPVOID*) &pIWbemLocator);
341: 
342:   if(FAILED(hr) || pIWbemLocator == NULL)
343:     goto LCleanup;
344: 
345:   bstrNamespace = SysAllocString(L"\\\\.\\root\\cimv2"); if(bstrNamespace == NULL) goto LCleanup;
346:   bstrClassName = SysAllocString(L"Win32_PNPEntity");    if(bstrClassName == NULL) goto LCleanup;
347:   bstrDeviceID  = SysAllocString(L"DeviceID");           if(bstrDeviceID == NULL)  goto LCleanup;
348: 
349:   // Connect to WMI
350:   hr = pIWbemLocator->ConnectServer(bstrNamespace, NULL, NULL, 0L, 0L, NULL, NULL, &pIWbemServices);
351:   if(FAILED(hr) || pIWbemServices == NULL)
352:     goto LCleanup;
353: 
354:   // Switch security level to IMPERSONATE.
355:   CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
356: 
357:   hr = pIWbemServices->CreateInstanceEnum(bstrClassName, 0, NULL, &pEnumDevices);
358:   if(FAILED(hr) || pEnumDevices == NULL)
359:     goto LCleanup;
360: 
361:   // Loop over all devices
362:   for(;;)
363:   {
364:     // Get 20 at a time
365:     hr = pEnumDevices->Next(10000, 20, pDevices, &uReturned);
366: 
367:     if(FAILED(hr))
368:       goto LCleanup;
369: 
370:     if(uReturned == 0)
371:       break;
372: 
373:     for(iDevice=0; iDevice<uReturned; iDevice++)
374:     {
375:       // For each device, get its device ID
376:       hr = pDevices[iDevice]->Get(bstrDeviceID, 0L, &var, NULL, NULL);
377:       if(SUCCEEDED(hr) && var.vt == VT_BSTR && var.bstrVal != NULL)
378:       {
379:         // Check if the device ID contains "IG_".  If it does, then it's an XInput device
380:         // This information can not be found from DirectInput
381:         if(wcsstr(var.bstrVal, L"IG_"))
382:         {
383:           // If it does, then get the VID/PID from var.bstrVal
384:           DWORD dwPid = 0, dwVid = 0;
385:           WCHAR* strVid = wcsstr(var.bstrVal, L"VID_");
386: 
387:           if(strVid && swscanf(strVid, L"VID_%4X", &dwVid) != 1)
388:             dwVid = 0;
389: 
390:           WCHAR* strPid = wcsstr(var.bstrVal, L"PID_");
391: 
392:           if(strPid && swscanf(strPid, L"PID_%4X", &dwPid) != 1)
393:             dwPid = 0;
394: 
395:           // Compare the VID/PID to the DInput device
396:           DWORD dwVidPid = MAKELONG(dwVid, dwPid);
397:           if(dwVidPid == pGuidProductFromDirectInput->Data1)
398:           {
399:             bIsXinputDevice = true;
400:             goto LCleanup;
401:           }
402:         }
403:       }
404:       VariantClear(&var);
405:       SAFE_RELEASE(pDevices[iDevice]);
406:     }
407:   }
408: 
409: LCleanup:
410:   VariantClear(&var);
411:   if(bstrNamespace)
412:     SysFreeString(bstrNamespace);
413:   if(bstrDeviceID)
414:     SysFreeString(bstrDeviceID);
415:   if(bstrClassName)
416:     SysFreeString(bstrClassName);
417:   for(iDevice=0; iDevice<20; iDevice++)
418:     SAFE_RELEASE(pDevices[iDevice]);
419:   SAFE_RELEASE(pEnumDevices);
420:   SAFE_RELEASE(pIWbemLocator);
421:   SAFE_RELEASE(pIWbemServices);
422: 
423:   if(bCleanupCOM)
424:     CoUninitialize();
425: 
426:   return bIsXinputDevice;
427: }
</file>

<file path="src/joystick.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <vector>
25: #include <dinput.h>
26: 
27: // Inspired by https://bell0bytes.eu/directinput/
28: 
29: // the joystick class (DirectInput)
30: class Joystick
31: {
32: private:
33:   LPDIRECTINPUT8 dev = nullptr;                          // dinput interface
34:   LPDIRECTINPUTDEVICE8 gameController = nullptr;         // the actual joystick device
35:   LPDIRECTINPUTEFFECT  gameControllerEffect = nullptr;   // force feedback effect object
36:   DIDEVICEOBJECTINSTANCE gameControllerInfo;             // the device object info
37:   DIDEVCAPS caps;                                        // the device capabilities
38:   DIJOYSTATE2 currentState;			                         // the state of the joystick in the current frame
39: 
40:   BOOL enumerateGameControllers(LPCDIDEVICEINSTANCE devInst);
41:   std::vector<LPDIRECTINPUTDEVICE8> gameControllers;	// a vector of all available game controllers
42: 
43:   BOOL isXInputDevice(const GUID *pGuidProductFromDirectInput);
44: 
45:   static BOOL CALLBACK staticEnumerateGameControllers(LPCDIDEVICEINSTANCE devInst, LPVOID pvRef);
46:   static BOOL CALLBACK staticSetGameControllerProperties(LPCDIDEVICEOBJECTINSTANCE devObjInst, LPVOID pvRef);
47: 
48:   BOOL gameControllerSupportsVibration = false;
49: 
50: public:
51:   LPDIJOYSTATE2 GetState();
52:   LPDIDEVCAPS GetCaps();
53:   bool CheckConnection();
54:   bool Refresh();
55:   bool HasAnalogTriggers();
56:   bool HasForceFeedback();
57:   void Clean();
58:   void Vibrate(WORD leftMotorSpeed, WORD rightMotorSpeed);
59:   bool IsIdle();
60: 
61:   LONG GetDeadZone(float percent);
62:   DWORD GetMaxVibration();
63: };
64: 
65: extern Joystick joystick;
</file>

<file path="src/lighting_debug.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2023 Cosmos                                             //
  3: //                                                                          //
  4: //    This file is part of FFNx                                             //
  5: //                                                                          //
  6: //    FFNx is free software: you can redistribute it and/or modify          //
  7: //    it under the terms of the GNU General Public License as published by  //
  8: //    the Free Software Foundation, either version 3 of the License         //
  9: //                                                                          //
 10: //    FFNx is distributed in the hope that it will be useful,               //
 11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 13: //    GNU General Public License for more details.                          //
 14: /****************************************************************************/
 15: 
 16: #include "lighting_debug.h"
 17: #include "lighting.h"
 18: #include "cfg.h"
 19: #include "common.h"
 20: 
 21: #include <imgui.h>
 22: #include <math.h>
 23: 
 24: void lighting_debug(bool* isOpen)
 25: {
 26:     if (!ImGui::Begin("Lighting Debug", isOpen, ImGuiWindowFlags_::ImGuiWindowFlags_AlwaysAutoResize))
 27:     {
 28:         ImGui::End();
 29:         return;
 30:     }
 31: 
 32:     if (!(getmode_cached()->driver_mode == MODE_FIELD || getmode_cached()->driver_mode == MODE_BATTLE || getmode_cached()->driver_mode == MODE_WORLDMAP))
 33: 	{
 34: 		ImGui::Text("Not currently on a battle/field or worldmap.");
 35: 		ImGui::End();
 36: 		return;
 37: 	}
 38: 
 39:     ImGui::Text("Group ID: %s", lighting.getConfigGroup().c_str());
 40: 
 41:     bool isLightingEnabled = enable_lighting;
 42:     if (ImGui::Checkbox("Enable Lighting", &isLightingEnabled))
 43:     {
 44:         enable_lighting = isLightingEnabled;
 45:     }
 46:     bool isPbrTexturesEnabled = lighting.isPbrTextureEnabled();
 47:     if (ImGui::Checkbox("Enable PBR Textures", &isPbrTexturesEnabled))
 48:     {
 49:         lighting.setPbrTextureEnabled(isPbrTexturesEnabled);
 50:     }
 51:     bool isEnvironmentLightingEnabled = lighting.isEnvironmentLightingEnabled();
 52:     if (ImGui::Checkbox("Enable Environment Lighting", &isEnvironmentLightingEnabled))
 53:     {
 54:         lighting.setEnvironmentLightingEnabled(isEnvironmentLightingEnabled);
 55:     }
 56:     int gameLightingMode = game_lighting;
 57:     if (ImGui::Combo("Game Lighting", &gameLightingMode, "Original (CPU)\0Per-Vertex (GPU)\0Per-Pixel (GPU)\0"))
 58:     {
 59:         game_lighting = gameLightingMode;
 60:     }
 61:     ImGui::BeginGroup();
 62:     if (ImGui::Button("Load config from disk")) {
 63:         lighting.reload();
 64:     }
 65:     ImGui::SameLine();
 66:     if (ImGui::Button("Save config to disk")) {
 67:         lighting.save();
 68:     }
 69:     ImGui::EndGroup();
 70:     if (ImGui::CollapsingHeader("Direct Lighting", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
 71:     {
 72:         vector3<float> lightDirVector = lighting.getWorldLightDir();
 73:         float lightRotation[3] = { lightDirVector.x , lightDirVector.y };
 74:         if (ImGui::DragFloat2("Light Rotation", lightRotation, 1.0f))
 75:         {
 76:             lightRotation[0] = std::max(0.0f, std::min(180.0f, lightRotation[0]));
 77:             lightRotation[1] = std::max(0.0f, std::min(360.0f, lightRotation[1]));
 78:             lighting.setWorldLightDir(lightRotation[0], lightRotation[1], 0.0f);
 79:             lighting.setConfigEntry("light_rotation_vertical", lightRotation[0]);
 80: 	        lighting.setConfigEntry("light_rotation_horizontal", lightRotation[1]);
 81:         }
 82:         float lightIntensity = lighting.getLightIntensity();
 83:         if (ImGui::DragFloat("Intensity##0", &lightIntensity, 0.01f, 0.0f, 100.0f))
 84:         {
 85:             lighting.setLightIntensity(lightIntensity);
 86:             lighting.setConfigEntry("light_intensity", lightIntensity);
 87:         }
 88:         vector3<float> lightColorPoint3d = lighting.getLightColor();
 89:         float lightColor[3] = { lightColorPoint3d.x, lightColorPoint3d.y, lightColorPoint3d.z };
 90:         if (ImGui::ColorEdit3("Color##0", lightColor))
 91:         {
 92:             lighting.setLightColor(lightColor[0], lightColor[1], lightColor[2]);
 93:             lighting.setConfigEntry("light_color", toml::array(lightColor[0], lightColor[1], lightColor[2]));
 94:         }
 95:     }
 96:     if (ImGui::CollapsingHeader("Indirect Lighting", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
 97:     {
 98:         float ambientIntensity = lighting.getAmbientIntensity();
 99:         if (ImGui::DragFloat("Intensity##1", &ambientIntensity, 0.01f, 0.0f, 100.0f))
100:         {
101:             lighting.setAmbientIntensity(ambientIntensity);
102:             lighting.setConfigEntry("ambient_light_intensity", ambientIntensity);
103:         }
104: 
105:         vector3<float> ambientLightColorPoint3d = lighting.getAmbientLightColor();
106:         float ambientLightColor[3] = { ambientLightColorPoint3d.x, ambientLightColorPoint3d.y, ambientLightColorPoint3d.z };
107:         if (ImGui::ColorEdit3("Color##1", ambientLightColor))
108:         {
109:             lighting.setAmbientLightColor(ambientLightColor[0], ambientLightColor[1], ambientLightColor[2]);
110:             lighting.setConfigEntry("ambient_light_color", toml::array(ambientLightColor[0], ambientLightColor[1], ambientLightColor[2]));
111:         }
112:     }
113:     if (ImGui::CollapsingHeader("Material", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
114:     {
115:         float roughness = lighting.getRoughness();
116:         if (ImGui::DragFloat("Roughness", &roughness, 0.01f, 0.0f, 1.0f))
117:         {
118:             lighting.setRoughness(roughness);
119:         }
120:         float metallic = lighting.getMetallic();
121:         if (ImGui::DragFloat("Metallic", &metallic, 0.01f, 0.0f, 1.0f))
122:         {
123:             lighting.setMetallic(metallic);
124:         }
125:         float specular = lighting.getSpecular();
126:         if (ImGui::DragFloat("Specular", &specular, 0.01f, 0.0f, 1.0f))
127:         {
128:             lighting.setSpecular(specular);
129:         }
130:         float roughnessScale = lighting.getRoughnessScale();
131:         if (ImGui::DragFloat("Roughness Scale", &roughnessScale, 0.01f, 0.0f, 2.0f))
132:         {
133:             lighting.setRoughnessScale(roughnessScale);
134:         }
135:         float metallicScale = lighting.getMetallicScale();
136:         if (ImGui::DragFloat("Metallic Scale", &metallicScale, 0.01f, 0.0f, 2.0f))
137:         {
138:             lighting.setMetallicScale(metallicScale);
139:         }
140:         float specularScale = lighting.getSpecularScale();
141:         if (ImGui::DragFloat("Specular Scale", &specularScale, 0.01f, 0.0f, 2.0f))
142:         {
143:             lighting.setSpecularScale(specularScale);
144:         }
145:     }
146:     if (ImGui::CollapsingHeader("Shadow map (common)", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
147:     {
148:         bool isShadowFaceCullingEnabled = lighting.isShadowFaceCullingEnabled();
149:         if (ImGui::Checkbox("Face culling", &isShadowFaceCullingEnabled))
150:         {
151:             lighting.setShadowFaceCullingEnabled(isShadowFaceCullingEnabled);
152:         }
153:         int shadowMapResolution = lighting.getShadowMapResolution();
154:         if (ImGui::SliderInt("Resolution", &shadowMapResolution, 512, 4096))
155:         {
156:             lighting.setShadowMapResolution(shadowMapResolution);
157:         }
158:         float shadowConstantBias = lighting.getShadowConstantBias();
159:         if (ImGui::DragFloat("Constant Bias", &shadowConstantBias, 0.001f, 0.0f, 1.0f))
160:         {
161:             lighting.setShadowConstantBias(shadowConstantBias);
162:         }
163:     }
164:     if (ImGui::CollapsingHeader("Battle shadow map", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
165:     {
166:         float shadowMapArea = lighting.getShadowMapArea();
167:         if (ImGui::DragFloat("Area##0", &shadowMapArea, 10.0f, 0.0f, 100000.0f))
168:         {
169:             lighting.setShadowMapArea(shadowMapArea);
170:         }
171:         float shadowMapNearFarSize = lighting.getShadowMapNearFarSize();
172:         if (ImGui::DragFloat("Near/far size##0", &shadowMapNearFarSize, 10.0f, 0.0f, 100000.0f))
173:         {
174:             lighting.setShadowMapNearFarSize(shadowMapNearFarSize);
175:         }
176:     }
177:     if (ImGui::CollapsingHeader("Field shadow map", ImGuiTreeNodeFlags_DefaultOpen| ImGuiTreeNodeFlags_SpanAvailWidth))
178:     {
179:         float fieldShadowOcclusion = lighting.getFieldShadowOcclusion();
180:         if (ImGui::DragFloat("Occlusion", &fieldShadowOcclusion, 0.01f, 0.0f, 1.0f))
181:         {
182:             lighting.setFieldShadowOcclusion(fieldShadowOcclusion);
183:             lighting.setConfigEntry("shadowmap_occlusion", fieldShadowOcclusion);
184:         }
185:         float fieldShadowMapArea = lighting.getFieldShadowMapArea();
186:         if (ImGui::DragFloat("Area##1", &fieldShadowMapArea, 10.0f, 0.0f, 100000.0f))
187:         {
188:             lighting.setFieldShadowMapArea(fieldShadowMapArea);
189:             lighting.setConfigEntry("shadowmap_area", fieldShadowMapArea);
190:         }
191:         float fieldShadowMapNearFarSize = lighting.getFieldShadowMapNearFarSize();
192:         if (ImGui::DragFloat("Near/far size##1", &fieldShadowMapNearFarSize, 10.0f, 0.0f, 100000.0f))
193:         {
194:             lighting.setFieldShadowMapNearFarSize(fieldShadowMapNearFarSize);
195:             lighting.setConfigEntry("shadowmap_near_far_size", fieldShadowMapNearFarSize);
196:         }
197:         float fieldShadowDistance = lighting.getFieldShadowFadeStartDistance();
198:         if (ImGui::DragFloat("Fade Start Distance", &fieldShadowDistance, 1.0f, 0.0f, 1000.0f))
199:         {
200:             lighting.setFieldShadowFadeStartDistance(fieldShadowDistance);
201:             lighting.setConfigEntry("shadowmap_fade_start_distance", fieldShadowDistance);
202:         }
203:         float fieldShadowFadeRange = lighting.getFieldShadowFadeRange();
204:         if (ImGui::DragFloat("Fade Range", &fieldShadowFadeRange, 1.0f, 0.0f, 1000.0f))
205:         {
206:             lighting.setFieldShadowFadeRange(fieldShadowFadeRange);
207:             lighting.setConfigEntry("shadowmap_fade_range", fieldShadowDistance);
208:         }
209:         float walkMeshExtrudeSize = lighting.getWalkmeshExtrudeSize();
210:         if (ImGui::DragFloat("Walkmesh extrude size", &walkMeshExtrudeSize, 0.01f, 0.0f, 100.0f))
211:         {
212:             lighting.setWalkmeshExtrudeSize(walkMeshExtrudeSize);
213:         }
214:         float offset = lighting.getWalkmeshPosOffset();
215:         if (ImGui::DragFloat("Walkmesh offset", &offset, 0.01f, -100.0f, 100.0f))
216:         {
217:             lighting.setWalkmeshPosOffset(offset);
218:         }
219:     }
220:     if (ImGui::CollapsingHeader("Debug", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_SpanAvailWidth))
221:     {
222:         int debugOutput = lighting.GetDebugOutput();
223:         if (ImGui::Combo("Debug Output", &debugOutput, "Disabled\0Color\0Normal\0Roughness\0Metallic\0AO\0Specular\0IBL (Specular)\0IBL (Diffuse)\0"))
224:         {
225:             lighting.setDebugOutput(static_cast<DebugOutput>(debugOutput));
226:         }
227:         bool isHide2dEnabled = lighting.isHide2dEnabled();
228:         if (ImGui::Checkbox("Hide 2D", &isHide2dEnabled))
229:         {
230:             lighting.setHide2dEnabled(isHide2dEnabled);
231:         }
232:         bool isShowWalkmeshEnabled = lighting.isShowWalkmeshEnabled();
233:         if (ImGui::Checkbox("Show walkmesh", &isShowWalkmeshEnabled))
234:         {
235:             lighting.setShowWalkmeshEnabled(isShowWalkmeshEnabled);
236:         }
237:     }
238:     ImGui::End();
239: }
</file>

<file path="src/lighting_debug.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2023 Cosmos                                             //
 3: //                                                                          //
 4: //    This file is part of FFNx                                             //
 5: //                                                                          //
 6: //    FFNx is free software: you can redistribute it and/or modify          //
 7: //    it under the terms of the GNU General Public License as published by  //
 8: //    the Free Software Foundation, either version 3 of the License         //
 9: //                                                                          //
10: //    FFNx is distributed in the hope that it will be useful,               //
11: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
12: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
13: //    GNU General Public License for more details.                          //
14: /****************************************************************************/
15: 
16: #pragma once
17: 
18: void lighting_debug(bool* isOpen);
</file>

<file path="src/lighting.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //    Copyright (C) 2023 Cosmos                                             //
  10: //                                                                          //
  11: //    This file is part of FFNx                                             //
  12: //                                                                          //
  13: //    FFNx is free software: you can redistribute it and/or modify          //
  14: //    it under the terms of the GNU General Public License as published by  //
  15: //    the Free Software Foundation, either version 3 of the License         //
  16: //                                                                          //
  17: //    FFNx is distributed in the hope that it will be useful,               //
  18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  20: //    GNU General Public License for more details.                          //
  21: /****************************************************************************/
  22: 
  23: #include "lighting.h"
  24: #include "gl.h"
  25: #include "globals.h"
  26: #include "renderer.h"
  27: #include "macro.h"
  28: #include "cfg.h"
  29: #include "utils.h"
  30: #include <fstream>
  31: 
  32: Lighting lighting;
  33: 
  34: std::string Lighting::getConfigGroup()
  35: {
  36: 	const struct game_mode *mode = getmode_cached();
  37: 	std::string ret;
  38: 	char *field_name = nullptr;
  39: 
  40: 	switch(mode->driver_mode)
  41: 	{
  42: 		case MODE_FIELD:
  43: 			ret.append("field_");
  44: 			field_name = get_current_field_name();
  45: 			if (field_name) ret.append(field_name);
  46: 			break;
  47: 		case MODE_BATTLE:
  48: 			ret.append("bat_");
  49: 			ret.append(std::to_string(ff7_externals.modules_global_object->battle_id));
  50: 			break;
  51: 	}
  52: 
  53: 	return ret;
  54: }
  55: 
  56: auto Lighting::getConfigEntry(char *key)
  57: {
  58: 	std::string groupKey = getConfigGroup();
  59: 
  60: 	if (!groupKey.empty() && config.contains(groupKey))
  61: 	{
  62: 		auto ret = config[groupKey][key];
  63: 		if (ret) return ret;
  64: 	}
  65: 
  66: 	return config[key];
  67: }
  68: 
  69: void Lighting::loadConfig()
  70: {
  71: 	try
  72: 	{
  73: 		if (enable_devtools && fileExists(configDevToolsPath))
  74: 			config = toml::parse_file(configDevToolsPath);
  75: 		else
  76: 			config = toml::parse_file(configPath);
  77: 	}
  78: 	catch (const toml::parse_error &err)
  79: 	{
  80: 		config = toml::parse("");
  81: 	}
  82: }
  83: 
  84: void Lighting::initParamsFromConfig()
  85: {
  86: 	struct game_mode *mode = getmode_cached();
  87: 
  88: 	float lightRotationV = getConfigEntry("light_rotation_vertical").value_or(60.0);
  89: 	lightRotationV = std::max(0.0f, std::min(180.0f, lightRotationV));
  90: 	float lightRotationH = getConfigEntry("light_rotation_horizontal").value_or(60.0);
  91: 	lightRotationH = std::max(0.0f, std::min(360.0f, lightRotationH));
  92: 	lighting.setWorldLightDir(lightRotationV, lightRotationH, 0.0f);
  93: 
  94: 	float lightIntensity = getConfigEntry("light_intensity").value_or(4.0);
  95: 	lighting.setLightIntensity(lightIntensity);
  96: 
  97: 	toml::array *lightColorArray = getConfigEntry("light_color").as_array();
  98: 	if (lightColorArray != nullptr && lightColorArray->size() == 3)
  99: 	{
 100: 		float r = lightColorArray->get(0)->value<float>().value_or(1.0);
 101: 		float g = lightColorArray->get(1)->value<float>().value_or(1.0);
 102: 		float b = lightColorArray->get(2)->value<float>().value_or(1.0);
 103: 		lighting.setLightColor(r, g, b);
 104: 	}
 105: 
 106: 	float ambientLightIntensity = getConfigEntry("ambient_light_intensity").value_or(1.0);
 107: 	lighting.setAmbientIntensity(ambientLightIntensity);
 108: 
 109: 	toml::array *ambientLightColorArray = getConfigEntry("ambient_light_color").as_array();
 110: 	if (ambientLightColorArray != nullptr && ambientLightColorArray->size() == 3)
 111: 	{
 112: 		float r = ambientLightColorArray->get(0)->value<float>().value_or(1.0);
 113: 		float g = ambientLightColorArray->get(1)->value<float>().value_or(1.0);
 114: 		float b = ambientLightColorArray->get(2)->value<float>().value_or(1.0);
 115: 		lighting.setAmbientLightColor(r, g, b);
 116: 	}
 117: 
 118: 	float roughness = config["material_roughness"].value_or(0.7);
 119: 	lighting.setRoughness(roughness);
 120: 
 121: 	float metallic = config["material_metallic"].value_or(0.5);
 122: 	lighting.setMetallic(metallic);
 123: 
 124: 	float specular = config["material_specular"].value_or(0.1);
 125: 	lighting.setSpecular(specular);
 126: 
 127: 	int shadowMapResolution = config["shadowmap_resolution"].value_or(2048);
 128: 	shadowMapResolution = std::max(0, std::min(16384, shadowMapResolution));
 129: 	lighting.setShadowMapResolution(shadowMapResolution);
 130: 
 131: 	if (mode->driver_mode == MODE_FIELD)
 132: 	{
 133: 		float occlusion = getConfigEntry("shadowmap_occlusion").value_or(0.3);
 134: 		lighting.setFieldShadowOcclusion(occlusion);
 135: 
 136: 		float area = getConfigEntry("shadowmap_area").value_or(3000.0);
 137: 		lighting.setFieldShadowMapArea(area);
 138: 
 139: 		float nearFarSize = getConfigEntry("shadowmap_near_far_size").value_or(3000.0);
 140: 		lighting.setFieldShadowMapNearFarSize(nearFarSize);
 141: 
 142: 		float fadeStartDistance = getConfigEntry("shadowmap_fade_start_distance").value_or(1000.0);
 143: 		lighting.setFieldShadowFadeStartDistance(fadeStartDistance);
 144: 
 145: 		float fadeStartRange = getConfigEntry("shadowmap_fade_range").value_or(100.0);
 146: 		lighting.setFieldShadowFadeRange(fadeStartRange);
 147: 	}
 148: }
 149: 
 150: void Lighting::updateLightMatrices(const vector3<float>& center)
 151: {
 152: 	struct game_mode *mode = getmode_cached();
 153: 
 154: 	float rotMatrix[16];
 155: 	float degreeToRadian = M_PI / 180.0f;
 156: 	bx::mtxRotateXYZ(rotMatrix, lightingState.worldLightRot.x * degreeToRadian,
 157: 									 lightingState.worldLightRot.y * degreeToRadian, lightingState.worldLightRot.z * degreeToRadian);
 158: 
 159: 	const float forwardVector[4] = {0.0f, 0.0f, -1.0f, 0.0};
 160: 	float worldSpaceLightDir[4] = {0.0f, 0.0f, 0.0f, 0.0};
 161: 	bx::vec4MulMtx(worldSpaceLightDir, forwardVector, rotMatrix);
 162: 
 163: 	float area = lightingState.shadowMapArea;
 164: 	float nearFarSize = lightingState.shadowMapNearFarSize;
 165: 
 166: 	if (mode->driver_mode == MODE_FIELD)
 167: 	{
 168: 		// In Field mode the z axis is the up vector so we swap y and z axis
 169: 		float tmp = worldSpaceLightDir[1];
 170: 		worldSpaceLightDir[1] = worldSpaceLightDir[2];
 171: 		worldSpaceLightDir[2] = -tmp;
 172: 
 173: 		area = lightingState.fieldShadowMapArea;
 174: 		nearFarSize = lightingState.fieldShadowMapNearFarSize;
 175: 	}
 176: 	if (mode->driver_mode == MODE_WORLDMAP)
 177:     {
 178: 		worldSpaceLightDir[1] *= -1.0f;
 179:         worldSpaceLightDir[2] *= -1.0f;
 180: 		worldSpaceLightDir[3] *= -1.0f;
 181: 	}
 182: 
 183: 	// Transform light direction into view space
 184: 	float viewSpaceLightDir[4];
 185: 	bx::vec4MulMtx(viewSpaceLightDir, worldSpaceLightDir, newRenderer.getViewMatrix());
 186: 
 187:     const bx::Vec3 at = { center.x, center.y, center.z };
 188:     const bx::Vec3 eye = { center.x + viewSpaceLightDir[0],
 189:                            center.y + viewSpaceLightDir[1],
 190:                            center.z + viewSpaceLightDir[2] };
 191: 
 192: 	bx::Vec3 up = {0, 1, 0};
 193: 	const bx::Vec3 viewDir = {worldSpaceLightDir[0], worldSpaceLightDir[1], worldSpaceLightDir[2]};
 194: 	if (bx::abs(bx::dot(viewDir, up)) > 0.999)
 195: 	{
 196: 		up = {1.0, 0.0, 0.0};
 197: 	}
 198: 
 199: 	// Light view matrix
 200: 	bx::mtxLookAt(lightingState.lightViewMatrix, eye, at, up);
 201: 
 202: 	// Light projection matrix
 203: 	bx::mtxOrtho(lightingState.lightProjMatrix, -area, area, -area, area,
 204: 							 -nearFarSize, nearFarSize, 0.0f, bgfx::getCaps()->homogeneousDepth);
 205: 
 206: 	// Light view projection matrix
 207: 	bx::mtxMul(lightingState.lightViewProjMatrix, lightingState.lightViewMatrix, lightingState.lightProjMatrix);
 208: 
 209: 	// Matrix for converting from NDC to texture coordinates
 210: 	const float sy = bgfx::getCaps()->originBottomLeft ? 0.5f : -0.5f;
 211: 	const float sz = bgfx::getCaps()->homogeneousDepth ? 0.5f : 1.0f;
 212: 	const float tz = bgfx::getCaps()->homogeneousDepth ? 0.5f : 0.0f;
 213: 	const float mtxCrop[16] =
 214: 			{
 215: 					0.5f,
 216: 					0.0f,
 217: 					0.0f,
 218: 					0.0f,
 219: 					0.0f,
 220: 					sy,
 221: 					0.0f,
 222: 					0.0f,
 223: 					0.0f,
 224: 					0.0f,
 225: 					sz,
 226: 					0.0f,
 227: 					0.5f,
 228: 					0.5f,
 229: 					tz,
 230: 					1.0f,
 231: 			};
 232: 
 233: 	float mtxTmp[16];
 234: 	bx::mtxMul(mtxTmp, lightingState.lightProjMatrix, mtxCrop);
 235: 	bx::mtxMul(lightingState.lightViewProjTexMatrix, lightingState.lightViewMatrix, mtxTmp);
 236: 
 237: 	// Inverse of all light transformations above
 238: 	bx::mtxInverse(lightingState.lightInvViewProjTexMatrix, lightingState.lightViewProjTexMatrix);
 239: }
 240: 
 241: void Lighting::ff7_load_ibl()
 242: {
 243: 	struct game_mode *mode = getmode_cached();
 244: 	static uint32_t prev_mode = -1;
 245: 	static char filename[64]{0};
 246: 	static char specularFullpath[MAX_PATH];
 247: 	static char diffuseFullpath[MAX_PATH];
 248: 	static WORD last_field_id = 0, last_battle_id = 0;
 249: 
 250: 	switch (mode->driver_mode)
 251: 	{
 252: 	case MODE_BATTLE:
 253: 		if (mode->driver_mode != prev_mode || last_battle_id != ff7_externals.modules_global_object->battle_id)
 254: 		{
 255: 			last_battle_id = ff7_externals.modules_global_object->battle_id;
 256: 
 257: 			sprintf(filename, "bat_%d", last_battle_id);
 258: 			sprintf(specularFullpath, "%s/%s/ibl/%s_s.dds", basedir, external_lighting_path.c_str(), filename);
 259: 			sprintf(diffuseFullpath, "%s/%s/ibl/%s_d.dds", basedir, external_lighting_path.c_str(), filename);
 260: 
 261: 			newRenderer.prepareSpecularIbl(specularFullpath);
 262: 			newRenderer.prepareDiffuseIbl(diffuseFullpath);
 263: 		}
 264: 		break;
 265: 	case MODE_FIELD:
 266: 		if (mode->driver_mode != prev_mode || last_field_id != *ff7_externals.field_id)
 267: 		{
 268: 			last_field_id = *ff7_externals.field_id;
 269: 
 270: 			sprintf(filename, "field_%d", last_field_id);
 271: 			sprintf(specularFullpath, "%s/%s/ibl/%s_s.dds", basedir, external_lighting_path.c_str(), filename);
 272: 			sprintf(diffuseFullpath, "%s/%s/ibl/%s_d.dds", basedir, external_lighting_path.c_str(), filename);
 273: 
 274: 			newRenderer.prepareSpecularIbl(specularFullpath);
 275: 			newRenderer.prepareDiffuseIbl(diffuseFullpath);
 276: 		}
 277: 		break;
 278: 	default:
 279: 		break;
 280: 	}
 281: 
 282: 	prev_mode = mode->driver_mode;
 283: }
 284: 
 285: void Lighting::ff7_create_walkmesh(std::vector<struct walkmeshEdge> &edges)
 286: {
 287: 	byte *level_data = *ff7_externals.field_level_data_pointer;
 288: 	if (!level_data)
 289: 	{
 290: 		return;
 291: 	}
 292: 
 293: 	uint32_t walkmesh_offset = *(uint32_t *)(level_data + 0x16);
 294: 
 295: 	WORD numTris = *(WORD *)(level_data + walkmesh_offset + 4);
 296: 
 297: 	for (int i = 0; i < numTris; ++i)
 298: 	{
 299: 		vertex_3s *triangle_data = (vertex_3s *)(level_data + walkmesh_offset + 8 + 24 * i);
 300: 
 301: 		for (int j = 0; j < 3; ++j)
 302: 		{
 303: 			struct nvertex vertex;
 304: 			vertex._.x = triangle_data[j].x;
 305: 			vertex._.y = triangle_data[j].y;
 306: 			vertex._.z = triangle_data[j].z;
 307: 			vertex.color.w = 1.0f;
 308: 			vertex.color.r = 0xff;
 309: 			vertex.color.g = 0xff;
 310: 			vertex.color.b = 0xff;
 311: 			vertex.color.a = 0xff;
 312: 
 313: 			vertex.u = 0.0;
 314: 			vertex.v = 0.0;
 315: 
 316: 			walkMeshVertices.push_back(vertex);
 317: 			walkMeshIndices.push_back(walkMeshIndices.size());
 318: 		}
 319: 
 320: 		int vId0 = walkMeshVertices.size() - 3;
 321: 		int vId1 = walkMeshVertices.size() - 3 + 1;
 322: 		int vId2 = walkMeshVertices.size() - 3 + 2;
 323: 		walkmeshEdge e0;
 324: 		e0.v0 = vId0;
 325: 		e0.v1 = vId1;
 326: 		e0.ov = vId2;
 327: 		e0.prevEdge = -1;
 328: 		e0.nextEdge = -1;
 329: 		e0.isBorder = false;
 330: 		e0.perpDir = {0.0f, 0.0f, 0.0f};
 331: 		walkmeshEdge e1;
 332: 		e1.v0 = vId1;
 333: 		e1.v1 = vId2;
 334: 		e1.ov = vId0;
 335: 		e1.prevEdge = -1;
 336: 		e1.nextEdge = -1;
 337: 		e1.isBorder = false;
 338: 		e1.perpDir = {0.0f, 0.0f, 0.0f};
 339: 		walkmeshEdge e2;
 340: 		e2.v0 = vId2;
 341: 		e2.v1 = vId0;
 342: 		e2.ov = vId1;
 343: 		e2.prevEdge = -1;
 344: 		e2.nextEdge = -1;
 345: 		e2.isBorder = false;
 346: 		e2.perpDir = {0.0f, 0.0f, 0.0f};
 347: 		edges.push_back(e0);
 348: 		edges.push_back(e1);
 349: 		edges.push_back(e2);
 350: 	}
 351: }
 352: 
 353: // creates the field walkmesh for rendering
 354: void Lighting::createFieldWalkmesh(float extrudeSize)
 355: {
 356: 	static WORD last_field_id = 0;
 357: 
 358: 	if (*ff7_externals.field_id == last_field_id)
 359: 	{
 360: 		return;
 361: 	}
 362: 
 363: 	walkMeshVertices.clear();
 364: 	walkMeshIndices.clear();
 365: 
 366: 	std::vector<struct walkmeshEdge> edges;
 367: 
 368: 	// Get the walkmesh triangles and edges
 369: 	ff7_create_walkmesh(edges);
 370: 
 371: 	// Detect triangle edges that are external borders of the walkmesh
 372: 	// Border edges will be use to extrude a small area where field shadows will fade out
 373: 	// This is done to prevent sharp discontinuities at the walkmesh borders
 374: 	extractWalkmeshBorderData(edges);
 375: 
 376: 	// Extract previous and next adjacent border edges
 377: 	// Calculate extrude direction for each border edge
 378: 	createWalkmeshBorderExtrusionData(edges);
 379: 
 380: 	// Create triangles for the border extrusion
 381: 	createWalkmeshBorder(edges, extrudeSize);
 382: 
 383: 	last_field_id = *ff7_externals.field_id;
 384: }
 385: 
 386: void Lighting::extractWalkmeshBorderData(std::vector<struct walkmeshEdge> &edges)
 387: {
 388: 	int numEdges = edges.size();
 389: 	for (int i = 0; i < numEdges; ++i)
 390: 	{
 391: 		auto &e = edges[i];
 392: 		vector3<float> pos0 = walkMeshVertices[e.v0]._;
 393: 		vector3<float> pos1 = walkMeshVertices[e.v1]._;
 394: 
 395: 		bool isBorder = true;
 396: 		for (int j = 0; j < numEdges; ++j)
 397: 		{
 398: 			if (j == i)
 399: 			{
 400: 				continue;
 401: 			}
 402: 
 403: 			auto &other_e = edges[j];
 404: 			vector3<float> other_pos0 = walkMeshVertices[other_e.v0]._;
 405: 			vector3<float> other_pos1 = walkMeshVertices[other_e.v1]._;
 406: 
 407: 			float errorMargin = 0.001f;
 408: 			if (std::abs(pos0.x - other_pos0.x) < errorMargin && std::abs(pos0.y - other_pos0.y) < errorMargin && std::abs(pos0.z - other_pos0.z) < errorMargin &&
 409: 					std::abs(pos1.x - other_pos1.x) < errorMargin && std::abs(pos1.y - other_pos1.y) < errorMargin && std::abs(pos1.z - other_pos1.z) < errorMargin)
 410: 			{
 411: 				isBorder = false;
 412: 			}
 413: 
 414: 			if (std::abs(pos1.x - other_pos0.x) < errorMargin && std::abs(pos1.y - other_pos0.y) < errorMargin && std::abs(pos1.z - other_pos0.z) < errorMargin &&
 415: 					std::abs(pos0.x - other_pos1.x) < errorMargin && std::abs(pos0.y - other_pos1.y) < errorMargin && std::abs(pos0.z - other_pos1.z) < errorMargin)
 416: 			{
 417: 				isBorder = false;
 418: 			}
 419: 		}
 420: 		e.isBorder = isBorder;
 421: 
 422: 		if (isBorder)
 423: 		{
 424: 			auto &v0 = walkMeshVertices[e.v0];
 425: 			auto &v1 = walkMeshVertices[e.v1];
 426: 		}
 427: 	}
 428: }
 429: 
 430: void Lighting::createWalkmeshBorderExtrusionData(std::vector<struct walkmeshEdge> &edges)
 431: {
 432: 	int numEdges = edges.size();
 433: 	for (int i = 0; i < numEdges; ++i)
 434: 	{
 435: 		auto &e = edges[i];
 436: 		if (!e.isBorder)
 437: 		{
 438: 			continue;
 439: 		}
 440: 
 441: 		vector3<float> pos0 = walkMeshVertices[e.v0]._;
 442: 		vector3<float> pos1 = walkMeshVertices[e.v1]._;
 443: 
 444: 		for (int j = 0; j < numEdges; ++j)
 445: 		{
 446: 			if (j == i)
 447: 			{
 448: 				continue;
 449: 			}
 450: 
 451: 			auto &other_e = edges[j];
 452: 			if (!other_e.isBorder)
 453: 			{
 454: 				continue;
 455: 			}
 456: 
 457: 			vector3<float> other_pos0 = walkMeshVertices[other_e.v0]._;
 458: 			vector3<float> other_pos1 = walkMeshVertices[other_e.v1]._;
 459: 
 460: 			float errorMargin = 0.1f;
 461: 			;
 462: 			if ((std::abs(pos0.x - other_pos0.x) < errorMargin && std::abs(pos0.y - other_pos0.y) < errorMargin && std::abs(pos0.z - other_pos0.z) < errorMargin) ||
 463: 					(std::abs(pos0.x - other_pos1.x) < errorMargin && std::abs(pos0.y - other_pos1.y) < errorMargin && std::abs(pos0.z - other_pos1.z) < errorMargin))
 464: 			{
 465: 				e.prevEdge = j;
 466: 			}
 467: 
 468: 			if ((std::abs(pos1.x - other_pos0.x) < errorMargin && std::abs(pos1.y - other_pos0.y) < errorMargin && std::abs(pos1.z - other_pos0.z) < errorMargin) ||
 469: 					(std::abs(pos1.x - other_pos1.x) < errorMargin && std::abs(pos1.y - other_pos1.y) < errorMargin && std::abs(pos1.z - other_pos1.z) < errorMargin))
 470: 			{
 471: 				e.nextEdge = j;
 472: 			}
 473: 
 474: 			vector3<float> pos0 = walkMeshVertices[e.v0]._;
 475: 			vector3<float> pos1 = walkMeshVertices[e.v1]._;
 476: 			vector3<float> ovPos = walkMeshVertices[e.ov]._;
 477: 
 478: 			vector3<float> triCenter;
 479: 			add_vector(&pos0, &pos1, &triCenter);
 480: 			add_vector(&triCenter, &ovPos, &triCenter);
 481: 			divide_vector(&triCenter, 2.0f, &triCenter);
 482: 
 483: 			vector3<float> edgeDir0;
 484: 			subtract_vector(&pos1, &pos0, &edgeDir0);
 485: 			normalize_vector(&edgeDir0);
 486: 			vector3<float> edgeDir1;
 487: 			subtract_vector(&ovPos, &pos0, &edgeDir1);
 488: 			normalize_vector(&edgeDir1);
 489: 			vector3<float> normal;
 490: 			cross_product(&edgeDir0, &edgeDir1, &normal);
 491: 
 492: 			vector3<float> perpDir;
 493: 			cross_product(&edgeDir0, &normal, &perpDir);
 494: 			normalize_vector(&perpDir);
 495: 
 496: 			vector3<float> ovDir0;
 497: 			subtract_vector(&pos0, &ovPos, &ovDir0);
 498: 			normalize_vector(&ovDir0);
 499: 
 500: 			vector3<float> ovDir1;
 501: 			subtract_vector(&pos1, &ovPos, &ovDir1);
 502: 			normalize_vector(&ovDir1);
 503: 
 504: 			if (dot_product(&ovDir0, &perpDir) < 0.0)
 505: 			{
 506: 				multiply_vector(&perpDir, -1.0f, &perpDir);
 507: 			}
 508: 
 509: 			e.perpDir = perpDir;
 510: 		}
 511: 	}
 512: }
 513: 
 514: void Lighting::createWalkmeshBorder(std::vector<struct walkmeshEdge> &edges, float extrudeSize)
 515: {
 516: 	int numEdges = edges.size();
 517: 	for (int i = 0; i < numEdges; ++i)
 518: 	{
 519: 		auto &e = edges[i];
 520: 		if (e.isBorder == false)
 521: 		{
 522: 			continue;
 523: 		}
 524: 
 525: 		vector3<float> pos0 = walkMeshVertices[e.v0]._;
 526: 		vector3<float> pos1 = walkMeshVertices[e.v1]._;
 527: 
 528: 		if (e.prevEdge == -1 || e.nextEdge == -1)
 529: 			continue;
 530: 
 531: 		auto &prevEdge = edges[e.prevEdge];
 532: 		auto &nextEdge = edges[e.nextEdge];
 533: 
 534: 		vector3<float> capExtrudeDir0;
 535: 		add_vector(&e.perpDir, &prevEdge.perpDir, &capExtrudeDir0);
 536: 		normalize_vector(&capExtrudeDir0);
 537: 
 538: 		vector3<float> capExtrudeDir1;
 539: 		add_vector(&e.perpDir, &nextEdge.perpDir, &capExtrudeDir1);
 540: 		normalize_vector(&capExtrudeDir1);
 541: 
 542: 		// Extrude triangle 0
 543: 		vector3<float> extrudePos0;
 544: 		{
 545: 			vector3<float> perpDir = {capExtrudeDir0.x, capExtrudeDir0.y, capExtrudeDir0.z};
 546: 			float cos = dot_product(&e.perpDir, &capExtrudeDir0);
 547: 
 548: 			vector3<float> extrudeOffset;
 549: 			multiply_vector(&perpDir, extrudeSize / cos, &extrudeOffset);
 550: 
 551: 			add_vector(&pos0, &extrudeOffset, &extrudePos0);
 552: 
 553: 			struct nvertex v0;
 554: 			v0._.x = pos1.x;
 555: 			v0._.y = pos1.y;
 556: 			v0._.z = pos1.z;
 557: 			v0.color.w = 1.0f;
 558: 			v0.color.r = 0xff;
 559: 			v0.color.g = 0x00;
 560: 			v0.color.b = 0x00;
 561: 			v0.color.a = 0xff;
 562: 			walkMeshVertices.push_back(v0);
 563: 			walkMeshIndices.push_back(walkMeshIndices.size());
 564: 
 565: 			struct nvertex v1;
 566: 			v1._.x = pos0.x;
 567: 			v1._.y = pos0.y;
 568: 			v1._.z = pos0.z;
 569: 			v1.color.w = 1.0f;
 570: 			v1.color.r = 0xff;
 571: 			v1.color.g = 0x00;
 572: 			v1.color.b = 0x00;
 573: 			v1.color.a = 0xff;
 574: 
 575: 			walkMeshVertices.push_back(v1);
 576: 			walkMeshIndices.push_back(walkMeshIndices.size());
 577: 
 578: 			struct nvertex v2;
 579: 			v2._.x = extrudePos0.x;
 580: 			v2._.y = extrudePos0.y;
 581: 			v2._.z = extrudePos0.z;
 582: 			v2.color.w = 1.0f;
 583: 			v2.color.r = 0xff;
 584: 			v2.color.g = 0x00;
 585: 			v2.color.b = 0x00;
 586: 			v2.color.a = 0x00;
 587: 
 588: 			walkMeshVertices.push_back(v2);
 589: 			walkMeshIndices.push_back(walkMeshIndices.size());
 590: 		}
 591: 
 592: 		// Extrude triangle 1
 593: 		vector3<float> extrudePos1;
 594: 		{
 595: 			vector3<float> perpDir = {capExtrudeDir1.x, capExtrudeDir1.y, capExtrudeDir1.z};
 596: 			float cos = dot_product(&e.perpDir, &capExtrudeDir1);
 597: 
 598: 			vector3<float> extrudeOffset;
 599: 			multiply_vector(&perpDir, extrudeSize / cos, &extrudeOffset);
 600: 
 601: 			add_vector(&pos1, &extrudeOffset, &extrudePos1);
 602: 
 603: 			struct nvertex v0;
 604: 			v0._.x = extrudePos1.x;
 605: 			v0._.y = extrudePos1.y;
 606: 			v0._.z = extrudePos1.z;
 607: 			v0.color.w = 1.0f;
 608: 			v0.color.r = 0xff;
 609: 			v0.color.g = 0x00;
 610: 			v0.color.b = 0x00;
 611: 			v0.color.a = 0x00;
 612: 
 613: 			walkMeshVertices.push_back(v0);
 614: 			walkMeshIndices.push_back(walkMeshIndices.size());
 615: 
 616: 			struct nvertex v1;
 617: 			v1._.x = pos1.x;
 618: 			v1._.y = pos1.y;
 619: 			v1._.z = pos1.z;
 620: 			v1.color.w = 1.0f;
 621: 			v1.color.r = 0xff;
 622: 			v1.color.g = 0x00;
 623: 			v1.color.b = 0x00;
 624: 			v1.color.a = 0xff;
 625: 
 626: 			walkMeshVertices.push_back(v1);
 627: 			walkMeshIndices.push_back(walkMeshIndices.size());
 628: 
 629: 			struct nvertex v2;
 630: 			v2._.x = extrudePos0.x;
 631: 			v2._.y = extrudePos0.y;
 632: 			v2._.z = extrudePos0.z;
 633: 			v2.color.w = 1.0f;
 634: 			v2.color.r = 0xff;
 635: 			v2.color.g = 0x00;
 636: 			v2.color.b = 0x00;
 637: 			v2.color.a = 0x00;
 638: 
 639: 			walkMeshVertices.push_back(v2);
 640: 			walkMeshIndices.push_back(walkMeshIndices.size());
 641: 		}
 642: 	}
 643: }
 644: 
 645: struct boundingbox Lighting::calcFieldSceneAabb(struct boundingbox *sceneAabb)
 646: {
 647: 	byte *level_data = *ff7_externals.field_level_data_pointer;
 648: 	if (!level_data)
 649: 	{
 650: 		return *sceneAabb;
 651: 	}
 652: 
 653: 	uint32_t walkmesh_offset = *(uint32_t *)(level_data + 0x16);
 654: 
 655: 	std::vector<struct nvertex> vertices;
 656: 	std::vector<WORD> indices;
 657: 	std::vector<struct walkmeshEdge> edges;
 658: 
 659: 	WORD numTris = *(WORD *)(level_data + walkmesh_offset + 4);
 660: 
 661: 	vector3<float> boundingMin = {FLT_MAX, FLT_MAX, FLT_MAX};
 662: 	vector3<float> boundingMax = {FLT_MIN, FLT_MIN, FLT_MIN};
 663: 
 664: 	// Calculates walkmesh AABB
 665: 	for (int i = 0; i < numTris; ++i)
 666: 	{
 667: 		vertex_3s *triangle_data = (vertex_3s *)(level_data + walkmesh_offset + 8 + 24 * i);
 668: 
 669: 		for (int j = 0; j < 3; ++j)
 670: 		{
 671: 			boundingMin.x = std::min(boundingMin.x, static_cast<float>(triangle_data[j].x));
 672: 			boundingMin.y = std::min(boundingMin.y, static_cast<float>(triangle_data[j].y));
 673: 			boundingMin.z = std::min(boundingMin.z, static_cast<float>(triangle_data[j].z));
 674: 			boundingMax.x = std::max(boundingMax.x, static_cast<float>(triangle_data[j].x));
 675: 			boundingMax.y = std::max(boundingMax.y, static_cast<float>(triangle_data[j].y));
 676: 			boundingMax.z = std::max(boundingMax.z, static_cast<float>(triangle_data[j].z));
 677: 		}
 678: 	}
 679: 
 680: 	// Calculates walkmesh AABB in view space
 681: 	struct boundingbox bb;
 682: 	bb.min_x = FLT_MAX;
 683: 	bb.min_y = FLT_MAX;
 684: 	bb.min_z = FLT_MAX;
 685: 	bb.max_x = FLT_MIN;
 686: 	bb.max_y = FLT_MIN;
 687: 	bb.max_z = FLT_MIN;
 688: 
 689: 	vector3<float> corners[8] = {{boundingMin.x, boundingMin.y, boundingMin.z},
 690: 															 {boundingMin.x, boundingMin.y, boundingMax.z},
 691: 															 {boundingMin.x, boundingMax.y, boundingMin.z},
 692: 															 {boundingMin.x, boundingMax.y, boundingMax.z},
 693: 															 {boundingMax.x, boundingMin.y, boundingMin.z},
 694: 															 {boundingMax.x, boundingMin.y, boundingMax.z},
 695: 															 {boundingMax.x, boundingMax.y, boundingMin.z},
 696: 															 {boundingMax.x, boundingMax.y, boundingMax.z}};
 697: 
 698: 	for (int j = 0; j < 8; ++j)
 699: 	{
 700: 		vector3<float> cornerViewSpace;
 701: 		struct matrix viewMatrix;
 702: 		::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
 703: 		transform_point(&viewMatrix, &corners[j], &cornerViewSpace);
 704: 
 705: 		bb.min_x = std::min(bb.min_x, cornerViewSpace.x);
 706: 		bb.min_y = std::min(bb.min_y, cornerViewSpace.y);
 707: 		bb.min_z = std::min(bb.min_z, cornerViewSpace.z);
 708: 
 709: 		bb.max_x = std::max(bb.max_x, cornerViewSpace.x);
 710: 		bb.max_y = std::max(bb.max_y, cornerViewSpace.y);
 711: 		bb.max_z = std::max(bb.max_z, cornerViewSpace.z);
 712: 	}
 713: 
 714: 	bb.min_x = std::min(bb.min_x, sceneAabb->min_x);
 715: 	bb.min_y = std::min(bb.min_y, sceneAabb->min_y);
 716: 	bb.min_z = std::min(bb.min_z, sceneAabb->min_z);
 717: 
 718: 	bb.max_x = std::max(bb.max_x, sceneAabb->max_x);
 719: 	bb.max_y = std::max(bb.max_y, sceneAabb->max_y);
 720: 	bb.max_z = std::max(bb.max_z, sceneAabb->max_z);
 721: 
 722: 	return bb;
 723: }
 724: 
 725: void Lighting::init()
 726: {
 727: 	sprintf(configPath, "%s/%s/config.toml", basedir, external_lighting_path.c_str());
 728: 	sprintf(configDevToolsPath, "%s/%s/config.devtools.toml", basedir, external_lighting_path.c_str());
 729: 
 730: 	reload();
 731: }
 732: 
 733: void Lighting::reload()
 734: {
 735: 	loadConfig();
 736: 	initParamsFromConfig();
 737: }
 738: 
 739: void Lighting::save()
 740: {
 741: 	std::ofstream ofs(configDevToolsPath);
 742: 	ofs << config << std::endl;
 743: }
 744: 
 745: void Lighting::draw(struct game_obj *game_object)
 746: {
 747: 	VOBJ(game_obj, game_object, game_object);
 748: 	struct game_mode *mode = getmode_cached();
 749: 	static WORD last_field_id = 0, last_battle_id = 0;
 750: 
 751: 	ff7_load_ibl();
 752: 
 753: 	struct boundingbox sceneAabb = calculateSceneAabb();
 754: 
 755: 	switch(mode->driver_mode)
 756: 	{
 757: 		case MODE_FIELD:
 758: 		{
 759: 			// Refresh the configuration if we're on a new field
 760: 			if (last_field_id != *ff7_externals.field_id)
 761: 			{
 762: 				last_field_id = *ff7_externals.field_id;
 763: 				initParamsFromConfig();
 764: 			}
 765: 
 766: 			struct boundingbox fieldSceneAabb = calcFieldSceneAabb(&sceneAabb);
 767: 
 768: 			// Light view frustum pointing to scene AABB center
 769: 			vector3<float> center = {
 770: 				0.5f * (fieldSceneAabb.min_x + fieldSceneAabb.max_x),
 771: 				0.5f * (fieldSceneAabb.min_y + fieldSceneAabb.max_y),
 772: 				0.5f * (fieldSceneAabb.min_z + fieldSceneAabb.max_z) };
 773: 
 774: 				float viewSpaceCenter[4];
 775: 	float centerFloat[4];
 776: 	centerFloat[0] = center.x;
 777: 	centerFloat[1] = center.y;
 778: 	centerFloat[2] = center.z;
 779: 	centerFloat[3] = 1;
 780: 	bx::vec4MulMtx(viewSpaceCenter, centerFloat, newRenderer.getViewMatrix());
 781: 			updateLightMatrices(center);
 782: 			gl_draw_deferred(&drawFieldShadowCallback);
 783: 			break;
 784: 		}
 785: 		case MODE_WORLDMAP:
 786: 		{
 787: 			int world_pos_x = ff7_externals.world_player_pos_E04918->x;
 788: 			int world_pos_y = ff7_externals.world_player_pos_E04918->y;
 789: 			int world_pos_z = ff7_externals.world_player_pos_E04918->z;
 790: 
 791: 			// Light view frustum pointing to player position
 792: 			vector3<float> center = {
 793: 				static_cast<float>(world_pos_x),
 794: 				static_cast<float>(world_pos_y),
 795: 				static_cast<float>(world_pos_z)};
 796: 
 797: 			struct matrix viewMatrix;
 798:     		::memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
 799: 			vector3<float> centerViewSpace;
 800: 			transform_point(&viewMatrix, &center, &centerViewSpace);
 801: 
 802: 			updateLightMatrices(centerViewSpace);
 803: 			gl_draw_deferred(nullptr);
 804: 		}
 805: 		break;
 806: 		case MODE_BATTLE:
 807: 		{
 808: 			// Refresh the configuration if we're on a new battle
 809: 			if (last_battle_id != ff7_externals.modules_global_object->battle_id)
 810: 			{
 811: 				last_battle_id = ff7_externals.modules_global_object->battle_id;
 812: 				initParamsFromConfig();
 813: 			}
 814: 		}
 815: 		default:
 816: 		{
 817: 			// Light view frustum pointing to scene AABB center
 818: 			vector3<float> center = {
 819: 				0.5f * (sceneAabb.min_x + sceneAabb.max_x),
 820: 				0.5f * (sceneAabb.min_y + sceneAabb.max_y),
 821: 				0.5f * (sceneAabb.min_z + sceneAabb.max_z) };
 822: 
 823: 			updateLightMatrices(center);
 824: 			gl_draw_deferred(nullptr);
 825: 			break;
 826: 		}
 827: 	}
 828: }
 829: 
 830: void drawFieldShadowCallback()
 831: {
 832: 	lighting.createFieldWalkmesh(lighting.getWalkmeshExtrudeSize());
 833: 
 834: 	auto walkMeshVertices = lighting.getWalkmeshVertices();
 835: 	auto walkMeshIndices = lighting.getWalkmeshIndices();
 836: 
 837: 	newRenderer.bindVertexBuffer(walkMeshVertices.data(), 0, walkMeshVertices.size());
 838: 	newRenderer.bindIndexBuffer(walkMeshIndices.data(), walkMeshIndices.size());
 839: 
 840: 	newRenderer.setPrimitiveType();
 841: 	newRenderer.isTLVertex(false);
 842: 	newRenderer.setCullMode(RendererCullMode::BACK);
 843: 	newRenderer.setBlendMode(RendererBlendMode::BLEND_AVG);
 844: 	newRenderer.isFBTexture(false);
 845: 	newRenderer.doDepthTest(true);
 846: 	newRenderer.doDepthWrite(false);
 847: 
 848: 	// Create a world matrix
 849: 	struct matrix worldMatrix;
 850: 	identity_matrix(&worldMatrix);
 851: 
 852: 	// WalkMesh offset to adjust vertical position of walkmesh so that it is just under the character feets
 853: 	worldMatrix._43 = lighting.getWalkmeshPosOffset();
 854: 
 855: 	// View matrix
 856: 	struct matrix viewMatrix;
 857: 	memcpy(&viewMatrix.m[0][0], newRenderer.getViewMatrix(), sizeof(viewMatrix.m));
 858: 
 859: 	// Create a world view matrix
 860: 	struct matrix worldViewMatrix;
 861: 	multiply_matrix(&worldMatrix, &viewMatrix, &worldViewMatrix);
 862: 	newRenderer.setWorldViewMatrix(&worldViewMatrix);
 863: 
 864: 	newRenderer.drawFieldShadow();
 865: }
 866: 
 867: const LightingState &Lighting::getLightingState()
 868: {
 869: 	return lightingState;
 870: }
 871: 
 872: void Lighting::setPbrTextureEnabled(bool isEnabled)
 873: {
 874: 	lightingState.lightingSettings[0] = isEnabled;
 875: }
 876: 
 877: bool Lighting::isPbrTextureEnabled()
 878: {
 879: 	return lightingState.lightingSettings[0];
 880: }
 881: 
 882: void Lighting::setEnvironmentLightingEnabled(bool isEnabled)
 883: {
 884: 	lightingState.lightingSettings[1] = isEnabled;
 885: }
 886: 
 887: bool Lighting::isEnvironmentLightingEnabled()
 888: {
 889: 	return lightingState.lightingSettings[1];
 890: }
 891: 
 892: void Lighting::setWorldLightDir(float dirX, float dirY, float dirZ)
 893: {
 894: 	lightingState.worldLightRot.x = dirX;
 895: 	lightingState.worldLightRot.y = dirY;
 896: 	lightingState.worldLightRot.z = dirZ;
 897: }
 898: 
 899: vector3<float> Lighting::getWorldLightDir()
 900: {
 901: 	return lightingState.worldLightRot;
 902: }
 903: 
 904: void Lighting::setLightIntensity(float intensity)
 905: {
 906: 	lightingState.lightData[3] = intensity;
 907: }
 908: 
 909: float Lighting::getLightIntensity()
 910: {
 911: 	return lightingState.lightData[3];
 912: }
 913: 
 914: void Lighting::setLightColor(float r, float g, float b)
 915: {
 916: 	lightingState.lightData[0] = r;
 917: 	lightingState.lightData[1] = g;
 918: 	lightingState.lightData[2] = b;
 919: }
 920: 
 921: vector3<float> Lighting::getLightColor()
 922: {
 923: 	vector3<float> color = {lightingState.lightData[0],
 924: 													lightingState.lightData[1],
 925: 													lightingState.lightData[2]};
 926: 	return color;
 927: }
 928: 
 929: void Lighting::setAmbientIntensity(float intensity)
 930: {
 931: 	lightingState.ambientLightData[3] = intensity;
 932: }
 933: 
 934: float Lighting::getAmbientIntensity()
 935: {
 936: 	return lightingState.ambientLightData[3];
 937: }
 938: 
 939: void Lighting::setAmbientLightColor(float r, float g, float b)
 940: {
 941: 	lightingState.ambientLightData[0] = r;
 942: 	lightingState.ambientLightData[1] = g;
 943: 	lightingState.ambientLightData[2] = b;
 944: }
 945: 
 946: vector3<float> Lighting::getAmbientLightColor()
 947: {
 948: 	vector3<float> color = {lightingState.ambientLightData[0],
 949: 													lightingState.ambientLightData[1],
 950: 													lightingState.ambientLightData[2]};
 951: 	return color;
 952: }
 953: 
 954: void Lighting::setIblMipCount(int mipCount)
 955: {
 956: 	lightingState.iblData[0] = mipCount;
 957: }
 958: 
 959: bool Lighting::isDisabledLightingTexture(const std::string &textureName)
 960: {
 961: 	toml::array *disabledTextures = config["disable_lighting_textures"].as_array();
 962: 	if (disabledTextures && !disabledTextures->empty() && disabledTextures->is_homogeneous(toml::node_type::string))
 963: 	{
 964: 		int count = disabledTextures->size();
 965: 		for (int i = 0; i < count; ++i)
 966: 		{
 967: 			auto disabledTextureName = disabledTextures->get(i)->value<std::string>();
 968: 			if (disabledTextureName.has_value() && textureName == disabledTextureName.value())
 969: 			{
 970: 				return true;
 971: 			}
 972: 		}
 973: 	}
 974: 
 975: 	return false;
 976: }
 977: 
 978: void Lighting::setRoughness(float roughness)
 979: {
 980: 	lightingState.materialData[0] = roughness;
 981: }
 982: 
 983: float Lighting::getRoughness()
 984: {
 985: 	return lightingState.materialData[0];
 986: }
 987: 
 988: void Lighting::setMetallic(float metallic)
 989: {
 990: 	lightingState.materialData[1] = metallic;
 991: }
 992: 
 993: float Lighting::getMetallic()
 994: {
 995: 	return lightingState.materialData[1];
 996: }
 997: 
 998: void Lighting::setSpecular(float specular)
 999: {
1000: 	lightingState.materialData[2] = specular;
1001: }
1002: 
1003: float Lighting::getSpecular()
1004: {
1005: 	return lightingState.materialData[2];
1006: }
1007: 
1008: void Lighting::setRoughnessScale(float scale)
1009: {
1010: 	lightingState.materialScaleData[0] = scale;
1011: }
1012: 
1013: float Lighting::getRoughnessScale()
1014: {
1015: 	return lightingState.materialScaleData[0];
1016: }
1017: 
1018: void Lighting::setMetallicScale(float scale)
1019: {
1020: 	lightingState.materialScaleData[1] = scale;
1021: }
1022: 
1023: float Lighting::getMetallicScale()
1024: {
1025: 	return lightingState.materialScaleData[1];
1026: }
1027: 
1028: void Lighting::setSpecularScale(float scale)
1029: {
1030: 	lightingState.materialScaleData[2] = scale;
1031: }
1032: 
1033: float Lighting::getSpecularScale()
1034: {
1035: 	return lightingState.materialScaleData[2];
1036: }
1037: 
1038: void Lighting::setShadowFaceCullingEnabled(bool isEnabled)
1039: {
1040: 	lightingState.isShadowMapFaceCullingEnabled = isEnabled;
1041: }
1042: 
1043: bool Lighting::isShadowFaceCullingEnabled()
1044: {
1045: 	return lightingState.isShadowMapFaceCullingEnabled;
1046: }
1047: 
1048: void Lighting::setShadowMapResolution(int resolution)
1049: {
1050: 	lightingState.shadowData[3] = resolution;
1051: 	newRenderer.prepareShadowMap();
1052: }
1053: 
1054: int Lighting::getShadowMapResolution()
1055: {
1056: 	return lightingState.shadowData[3];
1057: }
1058: 
1059: void Lighting::setShadowConstantBias(float bias)
1060: {
1061: 	lightingState.shadowData[0] = bias;
1062: }
1063: 
1064: float Lighting::getShadowConstantBias()
1065: {
1066: 	return lightingState.shadowData[0];
1067: }
1068: 
1069: void Lighting::setShadowMapArea(float area)
1070: {
1071: 	lightingState.shadowMapArea = area;
1072: }
1073: 
1074: float Lighting::getShadowMapArea()
1075: {
1076: 	return lightingState.shadowMapArea;
1077: }
1078: 
1079: void Lighting::setShadowMapNearFarSize(float size)
1080: {
1081: 	lightingState.shadowMapNearFarSize = size;
1082: }
1083: 
1084: float Lighting::getShadowMapNearFarSize()
1085: {
1086: 	return lightingState.shadowMapNearFarSize;
1087: }
1088: 
1089: void Lighting::setFieldShadowMapArea(float area)
1090: {
1091: 	lightingState.fieldShadowMapArea = area;
1092: }
1093: 
1094: float Lighting::getFieldShadowMapArea()
1095: {
1096: 	return lightingState.fieldShadowMapArea;
1097: }
1098: 
1099: void Lighting::setFieldShadowMapNearFarSize(float size)
1100: {
1101: 	lightingState.fieldShadowMapNearFarSize = size;
1102: }
1103: 
1104: float Lighting::getFieldShadowMapNearFarSize()
1105: {
1106: 	return lightingState.fieldShadowMapNearFarSize;
1107: }
1108: 
1109: void Lighting::setFieldShadowOcclusion(float value)
1110: {
1111: 	lightingState.fieldShadowData[0] = value;
1112: }
1113: 
1114: float Lighting::getFieldShadowOcclusion()
1115: {
1116: 	return lightingState.fieldShadowData[0];
1117: }
1118: 
1119: void Lighting::setFieldShadowFadeStartDistance(float value)
1120: {
1121: 	lightingState.fieldShadowData[1] = value;
1122: }
1123: 
1124: float Lighting::getFieldShadowFadeStartDistance()
1125: {
1126: 	return lightingState.fieldShadowData[1];
1127: }
1128: 
1129: void Lighting::setFieldShadowFadeRange(float value)
1130: {
1131: 	lightingState.fieldShadowData[2] = value;
1132: }
1133: 
1134: float Lighting::getFieldShadowFadeRange()
1135: {
1136: 	return lightingState.fieldShadowData[2];
1137: }
1138: 
1139: void Lighting::setWalkmeshExtrudeSize(float size)
1140: {
1141: 	lightingState.walkMeshExtrudeSize = size;
1142: }
1143: 
1144: float Lighting::getWalkmeshExtrudeSize()
1145: {
1146: 	return lightingState.walkMeshExtrudeSize;
1147: }
1148: 
1149: void Lighting::setWalkmeshPosOffset(float offset)
1150: {
1151: 	lightingState.walkMeshPosOffset = offset;
1152: }
1153: 
1154: float Lighting::getWalkmeshPosOffset()
1155: {
1156: 	return lightingState.walkMeshPosOffset;
1157: }
1158: 
1159: const std::vector<nvertex> &Lighting::getWalkmeshVertices()
1160: {
1161: 	return walkMeshVertices;
1162: }
1163: 
1164: const std::vector<WORD> &Lighting::getWalkmeshIndices()
1165: {
1166: 	return walkMeshIndices;
1167: }
1168: 
1169: void Lighting::setHide2dEnabled(bool isEnabled)
1170: {
1171: 	lightingState.lightingDebugData[0] = isEnabled;
1172: }
1173: 
1174: bool Lighting::isHide2dEnabled()
1175: {
1176: 	return lightingState.lightingDebugData[0];
1177: }
1178: 
1179: void Lighting::setShowWalkmeshEnabled(bool isEnabled)
1180: {
1181: 	lightingState.lightingDebugData[1] = isEnabled;
1182: }
1183: 
1184: bool Lighting::isShowWalkmeshEnabled()
1185: {
1186: 	return lightingState.lightingDebugData[1];
1187: }
1188: 
1189: void Lighting::setDebugOutput(DebugOutput output)
1190: {
1191: 	lightingState.lightingDebugData[2] = output;
1192: }
1193: 
1194: DebugOutput Lighting::GetDebugOutput()
1195: {
1196: 	return static_cast<DebugOutput>(lightingState.lightingDebugData[2]);
1197: }
</file>

<file path="src/lighting.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include "common_imports.h"
 26: 
 27: #include <vector>
 28: #include <toml++/toml.h>
 29: #include <windows.h>
 30: 
 31: enum DebugOutput
 32: {
 33:     DEBUG_OUTPUT_DISABLED = 0,
 34:     DEBUG_OUTPUT_COLOR,
 35:     DEBUG_OUTPUT_NORMALMAP,
 36:     DEBUG_OUTPUT_ROUGHNESS,
 37:     DEBUG_OUTPUT_METALLIC,
 38:     DEBUG_OUTPUT_AO,
 39:     DEBUG_OUTPUT_SPECULAR,
 40:     DEBUG_OUTPUT_IBL_SPECULAR,
 41:     DEBUG_OUTPUT_IBL_DIFFUSE,
 42: };
 43: 
 44: struct walkmeshEdge
 45: {
 46:     int v0;                      // edge vertex index 0
 47:     int v1;                      // edge vertex index 1
 48:     int ov;                      // opposite vertex index
 49:     int prevEdge;                // previous vertex index
 50:     int nextEdge;	             // next vertex index
 51:     bool isBorder;               // border edge flag
 52:     vector3<float> perpDir;      // perpendicular direction
 53: };
 54: 
 55: struct LightingState
 56: {
 57:     float lightViewMatrix[16];
 58:     float lightProjMatrix[16];
 59:     float lightInvViewProjTexMatrix[16];
 60:     float lightViewProjMatrix[16];
 61:     float lightViewProjTexMatrix[16];
 62: 
 63:     float lightingSettings[4] = { 1.0, 1.0, 1.0, 0.0 };
 64:     float lightDirData[4] = { 0.3, -1.0, -0.3, 0.0 };
 65:     float lightData[4] = { 1.0, 1.0, 1.0, 4.0 };
 66:     float ambientLightData[4] = { 1.0, 1.0, 1.0, 1.0 };
 67:     float materialData[4] = { 0.7, 0.5, 0.1, 0.0 };
 68:     float materialScaleData[4] = { 1.0, 1.0, 1.0, 1.0 };
 69:     float shadowData[4] = { 0.001, 0.0, 0.0, 2048.0 };
 70:     float fieldShadowData[4] = { 0.3, 1000.0, 100.0, 0.0 };
 71:     float iblData[4] = { 1.0, 0.0, 0.0, 0.0 };
 72: 
 73:     float lightingDebugData[4] = { 0.0, 0.0, 0.0, 0.0 };
 74: 
 75:     // Light Direction
 76:     vector3<float> worldLightRot = { 60.0, 60.0, 0.0 };
 77: 
 78:     // Shadowmap face culling
 79:     bool isShadowMapFaceCullingEnabled = false;
 80: 
 81:     // Battle shadowmap frustum parameters
 82:     float shadowMapArea = 20000.0f;
 83:     float shadowMapNearFarSize = 20000.0f;
 84: 
 85:     // Field shadowmap frustum parameters
 86:     float fieldShadowMapArea = 3000.0f;
 87:     float fieldShadowMapNearFarSize = 3000.0f;
 88: 
 89:     // Field Shadow walkmesh parameters
 90:     float walkMeshExtrudeSize = 20.0;
 91:     float walkMeshPosOffset = -11.0;
 92: };
 93: 
 94: class Lighting
 95: {
 96: private:
 97:     LightingState lightingState;
 98: 
 99:     // Config
100:     char configPath[MAX_PATH];
101:     char configDevToolsPath[MAX_PATH];
102:     toml::parse_result config;
103: 
104:     std::vector<nvertex> walkMeshVertices;
105:     std::vector<WORD> walkMeshIndices;
106: 
107:     auto getConfigEntry(char* key);
108: 
109:     void loadConfig();
110:     void initParamsFromConfig();
111: 
112:     void ff7_load_ibl();
113: 
114:     void ff7_create_walkmesh(std::vector<struct walkmeshEdge>& edges);
115: 
116:     void extractWalkmeshBorderData(std::vector<struct walkmeshEdge>& edges);
117:     void createWalkmeshBorderExtrusionData(std::vector<struct walkmeshEdge>& edges);
118:     void createWalkmeshBorder(std::vector<struct walkmeshEdge>& edges, float extrudeSize);
119:     struct boundingbox calcFieldSceneAabb(struct boundingbox* sceneAbb);
120: 
121: public:
122:     void init();
123:     void reload();
124:     void save();
125: 
126:     void updateLightMatrices(const vector3<float>& center);
127:     void draw(struct game_obj* game_object);
128: 
129:     const LightingState& getLightingState();
130: 
131:     // Config
132:     std::string getConfigGroup();
133:     void setConfigEntry(const char* key, auto value);
134: 
135:     // Lighting
136:     void setPbrTextureEnabled(bool isEnabled);
137:     bool isPbrTextureEnabled();
138:     void setEnvironmentLightingEnabled(bool isEnabled);
139:     bool isEnvironmentLightingEnabled();
140:     void setWorldLightDir(float dirX, float dirY, float dirZ);
141:     vector3<float> getWorldLightDir();
142:     void setLightIntensity(float intensity);
143:     float getLightIntensity();
144:     void setLightColor(float r, float g, float b);
145:     vector3<float> getLightColor();
146:     void setAmbientIntensity(float intensity);
147:     float getAmbientIntensity();
148:     void setAmbientLightColor(float r, float g, float b);
149:     vector3<float> getAmbientLightColor();
150:     void setIblMipCount(int mipCount);
151:     bool isDisabledLightingTexture(const std::string& textureName);
152: 
153:     // Material
154:     void setRoughness(float roughness);
155:     float getRoughness();
156:     void setMetallic(float metallic);
157:     float getMetallic();
158:     void setSpecular(float metallic);
159:     float getSpecular();
160:     void setRoughnessScale(float scale);
161:     float getRoughnessScale();
162:     void setMetallicScale(float scale);
163:     float getMetallicScale();
164:     void setSpecularScale(float scale);
165:     float getSpecularScale();
166: 
167:     // Shadow (common)
168:     void setShadowFaceCullingEnabled(bool isEnabled);
169:     bool isShadowFaceCullingEnabled();
170:     void setShadowMapResolution(int size);
171:     int getShadowMapResolution();
172:     void setShadowConstantBias(float bias);
173:     float getShadowConstantBias();
174: 
175:     // Battle Shadow
176:     void setShadowMapArea(float area);
177:     float getShadowMapArea();
178:     void setShadowMapNearFarSize(float size);
179:     float getShadowMapNearFarSize();
180: 
181:     // Field Shadow
182:     void createFieldWalkmesh(float extrudeSize);
183:     void setFieldShadowMapArea(float area);
184:     float getFieldShadowMapArea();
185:     void setFieldShadowMapNearFarSize(float size);
186:     float getFieldShadowMapNearFarSize();
187:     void setFieldShadowOcclusion(float value);
188:     float getFieldShadowOcclusion();
189:     void setFieldShadowFadeStartDistance(float value);
190:     float getFieldShadowFadeStartDistance();
191:     void setFieldShadowFadeRange(float value);
192:     float getFieldShadowFadeRange();
193:     void setWalkmeshExtrudeSize(float size);
194:     float getWalkmeshExtrudeSize();
195:     void setWalkmeshPosOffset(float size);
196:     float getWalkmeshPosOffset();
197:     const std::vector<nvertex>& getWalkmeshVertices();
198:     const std::vector<WORD>& getWalkmeshIndices();
199: 
200:     // Lighting Debug
201:     void setHide2dEnabled(bool isEnabled);
202:     bool isHide2dEnabled();
203:     void setShowWalkmeshEnabled(bool isEnabled);
204:     bool isShowWalkmeshEnabled();
205:     void setDebugOutput(DebugOutput output);
206:     DebugOutput GetDebugOutput();
207: };
208: 
209: inline void Lighting::setConfigEntry(const char *key, auto value)
210: {
211: 	std::string groupKey = getConfigGroup();
212: 
213: 	if (!groupKey.empty())
214: 	{
215: 		if (config.contains(groupKey))
216: 			config[groupKey].as_table()->insert_or_assign(key, value);
217: 		else
218: 			config.insert_or_assign(groupKey, toml::table{ {key, value} });
219: 	}
220: 	else
221: 		config.insert_or_assign(key, value);
222: }
223: 
224: void drawFieldShadowCallback();
225: 
226: extern Lighting lighting;
</file>

<file path="src/log.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <string>
 23: #include <stdio.h>
 24: #include <windows.h>
 25: 
 26: #include "log.h"
 27: #include "hext.h"
 28: #include "utils.h"
 29: 
 30: #define FFNX_DEBUG_BUFFER_SIZE 4096
 31: 
 32: FILE *app_log;
 33: 
 34: void open_applog(char *path)
 35: {
 36: 	app_log = fopen(path, "wb");
 37: 
 38: 	if(!app_log) MessageBoxA(gameHwnd, "Failed to open log file", "Error", 0);
 39: }
 40: 
 41: void plugin_trace(const char *fmt, ...)
 42: {
 43: 	va_list args;
 44: 	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];
 45: 
 46: 	va_start(args, fmt);
 47: 
 48: 	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);
 49: 
 50: 	va_end(args);
 51: 
 52: 	ffnx_trace("%s", tmp_str);
 53: }
 54: 
 55: void plugin_info(const char *fmt, ...)
 56: {
 57: 	va_list args;
 58: 	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];
 59: 
 60: 	va_start(args, fmt);
 61: 
 62: 	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);
 63: 
 64: 	va_end(args);
 65: 
 66: 	ffnx_info("%s", tmp_str);
 67: }
 68: 
 69: void plugin_glitch(const char *fmt, ...)
 70: {
 71: 	va_list args;
 72: 	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];
 73: 
 74: 	va_start(args, fmt);
 75: 
 76: 	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);
 77: 
 78: 	va_end(args);
 79: 
 80: 	ffnx_glitch("%s", tmp_str);
 81: }
 82: 
 83: void plugin_error(const char *fmt, ...)
 84: {
 85: 	va_list args;
 86: 	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];
 87: 
 88: 	va_start(args, fmt);
 89: 
 90: 	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);
 91: 
 92: 	va_end(args);
 93: 
 94: 	ffnx_error("%s", tmp_str);
 95: }
 96: 
 97: void debug_print(const char *str)
 98: {
 99: 	char tmp_str[FFNX_DEBUG_BUFFER_SIZE + 16];
100: 
101: 	sprintf(tmp_str, "[%08i] %s", frame_counter, str);
102: 
103: 	fwrite(tmp_str, 1, strlen(tmp_str), app_log);
104: 	fflush(app_log);
105: }
106: 
107: void show_popup_msg(uint8_t text_color, const char* fmt, ...)
108: {
109: 	va_list args;
110: 	char tmp_str[1024];
111: 
112: 	va_start(args, fmt);
113: 
114: 	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);
115: 
116: 	va_end(args);
117: 
118: 	strcpy(popup_msg, tmp_str);
119: 	popup_ttl = POPUP_TTL_MAX;
120: 	popup_color = text_colors[text_color];
121: }
122: 
123: void clear_popup_msg()
124: {
125: 	popup_ttl = 0;
126: }
127: 
128: uint32_t get_popup_time()
129: {
130: 	return popup_ttl;
131: }
132: 
133: void external_debug_print(const char *str)
134: {
135: 	std::string msg(str);
136: 	msg.erase(std::remove(msg.begin(), msg.end(), '\n'), msg.end());
137: 	trim(msg);
138: 
139: 	if (msg.length() == 0) return;
140: 
141: 	if (ff8)
142: 	{
143: 		if (starts_with(msg, "Patch")) return;
144: 	}
145: 	else
146: 	{
147: 		if (starts_with(msg, "SET VOLUME")) return;
148: 	}
149: 
150: 	hextPatcher.applyAll(msg);
151: 
152: 	msg += "\n";
153: 
154: 	if (show_applog) debug_print(msg.c_str());
155: 	if (show_error_popup) show_popup_msg(TEXTCOLOR_GRAY, str);
156: }
157: 
158: void external_debug_print2(const char *fmt, ...)
159: {
160: 	va_list args;
161: 	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];
162: 
163: 	va_start(args, fmt);
164: 
165: 	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);
166: 
167: 	va_end(args);
168: 
169: 	external_debug_print(tmp_str);
170: }
171: 
172: void debug_printf(const char *prefix, uint32_t color, const char *fmt, ...)
173: {
174: 	va_list args;
175: 	char tmp_str[FFNX_DEBUG_BUFFER_SIZE];
176: 	char tmp_str2[FFNX_DEBUG_BUFFER_SIZE];
177: 
178: 	va_start(args, fmt);
179: 
180: 	vsnprintf(tmp_str, sizeof(tmp_str), fmt, args);
181: 
182: 	va_end(args);
183: 
184: 	if ( prefix == nullptr)
185: 		_snprintf(tmp_str2, sizeof(tmp_str2), "%s", tmp_str);
186: 	else
187: 		_snprintf(tmp_str2, sizeof(tmp_str2), "%s: %s", prefix, tmp_str);
188: 	debug_print(tmp_str2);
189: }
190: 
191: void windows_error(uint32_t error)
192: {
193: 	char tmp_str[200];
194: 
195: 	if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error == 0 ? GetLastError() : error, 0, tmp_str, sizeof(tmp_str), 0)) debug_print(tmp_str);
196: }
</file>

<file path="src/log.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: // Header include necessary due to macro dependencies
25: #include "cfg.h"
26: #include "common.h"
27: #include "globals.h"
28: 
29: #define ffnx_error(x, ...) debug_printf("ERROR", text_colors[TEXTCOLOR_RED], (x), ## __VA_ARGS__)
30: #define ffnx_warning(x, ...) debug_printf("WARNING", text_colors[TEXTCOLOR_YELLOW], (x), ## __VA_ARGS__)
31: #define ffnx_info(x, ...) debug_printf("INFO", text_colors[TEXTCOLOR_WHITE], (x), ## __VA_ARGS__)
32: #define ffnx_dump(x, ...) debug_printf("DUMP", text_colors[TEXTCOLOR_PINK], (x), ## __VA_ARGS__)
33: #define ffnx_trace(x, ...) debug_printf("TRACE", text_colors[TEXTCOLOR_GREEN], (x), ## __VA_ARGS__)
34: #define ffnx_glitch(x, ...) debug_printf("GLITCH", text_colors[TEXTCOLOR_GRAY], (x), ## __VA_ARGS__)
35: #define ffnx_unexpected(x, ...) debug_printf("UNEXPECTED", text_colors[TEXTCOLOR_LIGHT_BLUE], (x), ## __VA_ARGS__)
36: 
37: #define ffnx_glitch_once(x, ...) { static uint32_t glitch_ ## __LINE__ = false; if(!glitch_ ## __LINE__) { ffnx_glitch(x, ## __VA_ARGS__); glitch_ ## __LINE__ = true; } }
38: #define ffnx_unexpected_once(x, ...) { static uint32_t unexpected_ ## __LINE__ = false; if(!unexpected_ ## __LINE__) { ffnx_unexpected(x, ## __VA_ARGS__); unexpected_ ## __LINE__ = true; } }
39: 
40: void open_applog(char *path);
41: 
42: void plugin_trace(const char *fmt, ...);
43: void plugin_info(const char *fmt, ...);
44: void plugin_glitch(const char *fmt, ...);
45: void plugin_error(const char *fmt, ...);
46: 
47: void external_debug_print(const char *str);
48: void external_debug_print2(const char *fmt, ...);
49: 
50: void show_popup_msg(uint8_t text_color, const char* fmt, ...);
51: void clear_popup_msg();
52: uint32_t get_popup_time();
53: 
54: void debug_printf(const char *, uint32_t, const char *, ...);
55: 
56: void windows_error(uint32_t error);
</file>

<file path="src/macro.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #define LIST_FOR_EACH(X, Y) for((X) = (Y)->head; (X); (X) = (X)->next)
25: 
26: /*
27:  * Versioned structure macros, used to access FF7 and FF8 data in a portable
28:  * way. Allows massive, relatively straightforward code reuse between the two
29:  * games. Watch out for block statements and using expressions with side
30:  * effects! These macros can have unintended effects if you're not careful.
31:  */
32: 
33: /*
34:  * VOBJ - Define a versioned object, structure must have FF7 and FF8 variants
35:  * named ff7_<type name> and ff8_<type name> respectively.
36:  * X - type name
37:  * Y - object name
38:  * Z - initial value
39:  */
40: #define VOBJ(X,Y,Z) struct ff7_ ## X *ff7_ ## Y = ff8 ? 0 : (struct ff7_ ## X *)(Z); struct ff8_ ## X *ff8_ ## Y = ff8 ? (struct ff8_ ## X *)(Z) : 0
41: 
42: /*
43:  * VPTR - Access the raw pointer contained in an object.
44:  * X - object
45:  */
46: #define VPTR(X) (ff8 ? (void *)ff8_ ## X : (void *)ff7_ ## X)
47: 
48:  /*
49:   * VPTRCAST - Access the raw pointer contained in an object, casting to a defined type
50:   * T - object type
51:   * X - object
52:   */
53: #define VPTRCAST(T, X) (ff8 ? (struct T *)ff8_ ## X : (struct T *)ff7_ ## X)
54: 
55: /*
56:  * VASS - Assign a new pointer to an object.
57:  * T - object type
58:  * X - object
59:  * Y - new value
60:  */
61: #define VASS(T,X,Y) { if(ff8) ff8_ ## X = (struct ff8_ ## T *)(Y); else ff7_ ## X = (struct ff7_ ## T *)(Y); }
62: 
63: /*
64:  * VREF - Retrieve the value of a member of an object.
65:  * X - object
66:  * Y - member name (member must be identical in both versions of the structure!)
67:  */
68: #define VREF(X,Y) (ff8 ? ff8_ ## X->Y : ff7_ ## X->Y)
69: 
70: /*
71:  * VREFP - Create a pointer to a member.
72:  * X - object
73:  * Y - member name (member must be identical in both versions of the structure!)
74:  */
75: #define VREFP(X,Y) (ff8 ? &(ff8_ ## X->Y) : &(ff7_ ## X->Y))
76: 
77: /*
78:  * VRASS - Assign a value to a member.
79:  * X - object
80:  * Y - member name (member must be identical in both versions of the structure!)
81:  */
82: #define VRASS(X,Y,Z) { if(ff8) ff8_ ## X->Y = (Z); else ff7_ ## X->Y = (Z); }
83: 
84: /*
85:  * UNSAFE_VREF - Retrieve the value of a member of an object WITHOUT type safety.
86:  * T - object type
87:  * X - object
88:  * Y - member name (types can be different in the different versions)
89:  */
90: #define UNSAFE_VREF(T,X,Y) (ff8 ? (struct T *)ff8_ ## X->Y : (struct T *)ff7_ ## X->Y)
91: 
92: #define BGRA2RGBA(n) (((n >> 24) & 0xFF) << 24 | (n & 0xFF) << 16 | ((n >> 8) & 0xFF) << 8 | ((n >> 16) & 0xFF))
93: 
94: #define BGRA_R(x) (x >> 16 & 0xFF)
95: #define BGRA_G(x) (x >> 8 & 0xFF)
96: #define BGRA_B(x) (x & 0xFF)
97: #define BGRA_A(x) (x >> 24 & 0xFF)
98: 
99: #define BIT(x) (1 << x)
</file>

<file path="src/matrix.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <string.h>
 23: #include <math.h>
 24: 
 25: #include "math.h"
 26: #include "log.h"
 27: 
 28: void add_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest)
 29: {
 30: 	dest->x = a->x + b->x;
 31: 	dest->y = a->y + b->y;
 32: 	dest->z = a->z + b->z;
 33: }
 34: 
 35: void subtract_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest)
 36: {
 37: 	dest->x = a->x - b->x;
 38: 	dest->y = a->y - b->y;
 39: 	dest->z = a->z - b->z;
 40: }
 41: 
 42: void multiply_vector(vector3<float> *vector, float scalar, vector3<float> *dest)
 43: {
 44: 	dest->x = vector->x * scalar;
 45: 	dest->y = vector->y * scalar;
 46: 	dest->z = vector->z * scalar;
 47: }
 48: 
 49: void divide_vector(vector3<float> *vector, float scalar, vector3<float> *dest)
 50: {
 51: 	dest->x = vector->x / scalar;
 52: 	dest->y = vector->y / scalar;
 53: 	dest->z = vector->z / scalar;
 54: }
 55: 
 56: float vector_length(vector3<float> *vector)
 57: {
 58: 	return sqrtf(vector->x * vector->x + vector->y * vector->y + vector->z * vector->z);
 59: }
 60: 
 61: void normalize_vector(vector3<float> *vector)
 62: {
 63: 	float length = vector_length(vector);
 64: 
 65: 	divide_vector(vector, length, vector);
 66: }
 67: 
 68: float dot_product(vector3<float> *a, vector3<float> *b)
 69: {
 70: 	return a->x * b->x + a->y * b->y + a->z * b->z;
 71: }
 72: 
 73: void cross_product(vector3<float> *a, vector3<float> *b, vector3<float> *dest)
 74: {
 75: 	dest->x = a->y * b->z - a->z * b->y;
 76: 	dest->y = a->z * b->x - a->x * b->z;
 77: 	dest->z = a->x * b->y - a->y * b->x;
 78: }
 79: 
 80: void transform_point(struct matrix *matrix, vector3<float> *point, vector3<float> *dest)
 81: {
 82: 	dest->x = matrix->_11 * point->x + matrix->_21 * point->y + matrix->_31 * point->z + matrix->_41;
 83: 	dest->y = matrix->_12 * point->x + matrix->_22 * point->y + matrix->_32 * point->z + matrix->_42;
 84: 	dest->z = matrix->_13 * point->x + matrix->_23 * point->y + matrix->_33 * point->z + matrix->_43;
 85: }
 86: 
 87: void transform_point_w(struct matrix *matrix, vector3<float> *point, struct point4d *dest)
 88: {
 89: 	dest->x = matrix->_11 * point->x + matrix->_21 * point->y + matrix->_31 * point->z + matrix->_41;
 90: 	dest->y = matrix->_12 * point->x + matrix->_22 * point->y + matrix->_32 * point->z + matrix->_42;
 91: 	dest->z = matrix->_13 * point->x + matrix->_23 * point->y + matrix->_33 * point->z + matrix->_43;
 92: 	dest->w = matrix->_14 * point->x + matrix->_24 * point->y + matrix->_34 * point->z + matrix->_44;
 93: }
 94: 
 95: void transform_point4d(struct matrix *matrix, struct point4d *point, struct point4d *dest)
 96: {
 97: 	dest->x = matrix->_11 * point->x + matrix->_21 * point->y + matrix->_31 * point->z + matrix->_41 * point->w;
 98: 	dest->y = matrix->_12 * point->x + matrix->_22 * point->y + matrix->_32 * point->z + matrix->_42 * point->w;
 99: 	dest->z = matrix->_13 * point->x + matrix->_23 * point->y + matrix->_33 * point->z + matrix->_43 * point->w;
100: 	dest->w = matrix->_14 * point->x + matrix->_24 * point->y + matrix->_34 * point->z + matrix->_44 * point->w;
101: }
102: 
103: void transpose_matrix(struct matrix *matrix, struct matrix *dest)
104: {
105: 	dest->_11 = matrix->_11;
106: 	dest->_12 = matrix->_21;
107: 	dest->_13 = matrix->_31;
108: 	dest->_14 = matrix->_41;
109: 	dest->_21 = matrix->_12;
110: 	dest->_22 = matrix->_22;
111: 	dest->_23 = matrix->_32;
112: 	dest->_24 = matrix->_42;
113: 	dest->_31 = matrix->_13;
114: 	dest->_32 = matrix->_23;
115: 	dest->_33 = matrix->_33;
116: 	dest->_34 = matrix->_43;
117: 	dest->_41 = matrix->_14;
118: 	dest->_42 = matrix->_24;
119: 	dest->_43 = matrix->_34;
120: 	dest->_44 = matrix->_44;
121: }
122: 
123: void multiply_matrix(struct matrix *a, struct matrix *b, struct matrix *dest)
124: {
125: 
126: #define MMUL(I, J, N) a->m[I - 1][N - 1] * b->m[N - 1][J - 1]
127: #define MMUL1(I, J) dest->m[I - 1][J - 1] = MMUL(I, J, 1) + MMUL(I, J, 2) + MMUL(I, J, 3) + MMUL(I, J, 4)
128: #define MMULROW(I) MMUL1(I, 1); MMUL1(I, 2); MMUL1(I, 3); MMUL1(I, 4)
129: 
130: 	MMULROW(1);
131: 	MMULROW(2);
132: 	MMULROW(3);
133: 	MMULROW(4);
134: }
135: 
136: void multiply_matrix_unary(struct matrix *a, struct matrix *b)
137: {
138: 	struct matrix tmp;
139: 
140: 	memcpy(&tmp, a, sizeof(tmp));
141: 	multiply_matrix(&tmp, b, a);
142: }
143: 
144: void identity_matrix(struct matrix *matrix)
145: {
146: 	matrix->_11 = 1.0f;
147: 	matrix->_12 = 0.0f;
148: 	matrix->_13 = 0.0f;
149: 	matrix->_14 = 0.0f;
150: 	matrix->_21 = 0.0f;
151: 	matrix->_22 = 1.0f;
152: 	matrix->_23 = 0.0f;
153: 	matrix->_24 = 0.0f;
154: 	matrix->_31 = 0.0f;
155: 	matrix->_32 = 0.0f;
156: 	matrix->_33 = 1.0f;
157: 	matrix->_34 = 0.0f;
158: 	matrix->_41 = 0.0f;
159: 	matrix->_42 = 0.0f;
160: 	matrix->_43 = 0.0f;
161: 	matrix->_44 = 1.0f;
162: }
163: 
164: void uniform_scaling_matrix(float scale, struct matrix *matrix)
165: {
166: 	identity_matrix(matrix);
167: 
168: 	matrix->_11 = scale;
169: 	matrix->_22 = scale;
170: 	matrix->_33 = scale;
171: }
172: 
173: void scaling_matrix(vector3<float> *scale, struct matrix *matrix)
174: {
175: 	identity_matrix(matrix);
176: 
177: 	matrix->_11 = scale->x;
178: 	matrix->_22 = scale->y;
179: 	matrix->_33 = scale->z;
180: }
181: 
182: void rotation_matrix_x(float angle, struct matrix *matrix)
183: {
184: 	identity_matrix(matrix);
185: 
186: 	matrix->_22 = cosf(angle);
187: 	matrix->_23 = sinf(angle);
188: 	matrix->_32 = -sinf(angle);
189: 	matrix->_33 = cosf(angle);
190: }
191: 
192: void rotation_matrix_y(float angle, struct matrix *matrix)
193: {
194: 	identity_matrix(matrix);
195: 
196: 	matrix->_11 = cosf(angle);
197: 	matrix->_13 = -sinf(angle);
198: 	matrix->_31 = sinf(angle);
199: 	matrix->_33 = cosf(angle);
200: }
201: 
202: void rotation_matrix_z(float angle, struct matrix *matrix)
203: {
204: 	identity_matrix(matrix);
205: 
206: 	matrix->_11 = cosf(angle);
207: 	matrix->_12 = sinf(angle);
208: 	matrix->_21 = -sinf(angle);
209: 	matrix->_22 = cosf(angle);
210: }
211: 
212: void rotate_matrix_x(float angle, struct matrix *matrix)
213: {
214: 	struct matrix tmp;
215: 
216: 	rotation_matrix_x(angle, &tmp);
217: 	multiply_matrix_unary(matrix, &tmp);
218: }
219: 
220: void rotate_matrix_y(float angle, struct matrix *matrix)
221: {
222: 	struct matrix tmp;
223: 
224: 	rotation_matrix_y(angle, &tmp);
225: 	multiply_matrix_unary(matrix, &tmp);
226: }
227: 
228: void rotate_matrix_z(float angle, struct matrix *matrix)
229: {
230: 	struct matrix tmp;
231: 
232: 	rotation_matrix_z(angle, &tmp);
233: 	multiply_matrix_unary(matrix, &tmp);
234: }
235: 
236: float determinant_3x3(struct matrix *m)
237: {
238: 	return m->_11 * m->_22 * m->_33 + m->_12 * m->_23 * m->_31 + m->_13 * m->_21 * m->_32 -
239: 		m->_11 * m->_23 * m->_32 - m->_12 * m->_21 * m->_33 - m->_13 * m->_22 * m->_31;
240: }
241: 
242: void inverse_matrix(struct matrix *matrix, struct matrix *dest)
243: {
244: 	float det = determinant_3x3(matrix);
245: 
246: 	if((det >= 0.99 && det <= 1.01) || (det <= -0.99 && det >= -1.01))
247: 	{
248: 		vector3<float> translation;
249: 
250: 		transpose_matrix(matrix, dest);
251: 		dest->_14 = matrix->_14;
252: 		dest->_24 = matrix->_24;
253: 		dest->_34 = matrix->_34;
254: 		dest->_44 = matrix->_44;
255: 
256: 		transform_point(dest, (vector3<float> *)&matrix->_41, &translation);
257: 
258: 		dest->_41 = -translation.x;
259: 		dest->_42 = -translation.y;
260: 		dest->_43 = -translation.z;
261: 	}
262: 	else ffnx_glitch_once("Non-uniform scaling: %f\n", det);
263: }
</file>

<file path="src/matrix.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #pragma once
 23: 
 24: #define DEG2RAD(X) ((X) * (M_PI/180.0f))
 25: 
 26: struct matrix
 27: {
 28: 	union
 29: 	{
 30: 		struct
 31: 		{
 32: 			float _11;
 33: 			float _12;
 34: 			float _13;
 35: 			float _14;
 36: 			float _21;
 37: 			float _22;
 38: 			float _23;
 39: 			float _24;
 40: 			float _31;
 41: 			float _32;
 42: 			float _33;
 43: 			float _34;
 44: 			float _41;
 45: 			float _42;
 46: 			float _43;
 47: 			float _44;
 48: 		};
 49: 
 50: 		float m[4][4];
 51: 	};
 52: };
 53: 
 54: template <typename T>
 55: struct vector2
 56: {
 57: 	T x;
 58: 	T y;
 59: };
 60: 
 61: template <typename T>
 62: struct vector3
 63: {
 64: 	T x;
 65: 	T y;
 66: 	T z;
 67: };
 68: 
 69: template <typename T>
 70: struct vector4
 71: {
 72: 	T x;
 73: 	T y;
 74: 	T z;
 75: 	T w;
 76: };
 77: 
 78: struct point4d
 79: {
 80: 	float x;
 81: 	float y;
 82: 	float z;
 83: 	float w;
 84: };
 85: 
 86: void add_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest);
 87: void subtract_vector(vector3<float> *a, vector3<float> *b, vector3<float> *dest);
 88: void multiply_vector(vector3<float> *vector, float scalar, vector3<float> *dest);
 89: void divide_vector(vector3<float> *vector, float scalar, vector3<float> *dest);
 90: float vector_length(vector3<float> *vector);
 91: void normalize_vector(vector3<float> *vector);
 92: float dot_product(vector3<float> *a, vector3<float> *b);
 93: void cross_product(vector3<float> *a, vector3<float> *b, vector3<float> *dest);
 94: void transform_point(struct matrix *matrix, vector3<float> *point, vector3<float> *dest);
 95: void transform_point_w(struct matrix *matrix, vector3<float> *point, struct point4d *dest);
 96: void transform_point4d(struct matrix *matrix, struct point4d *point, struct point4d *dest);
 97: void transpose_matrix(struct matrix *matrix, struct matrix *dest);
 98: void multiply_matrix(struct matrix *a, struct matrix *b, struct matrix *dest);
 99: void multiply_matrix_unary(struct matrix *a, struct matrix *b);
100: void identity_matrix(struct matrix *matrix);
101: void uniform_scaling_matrix(float scale, struct matrix *matrix);
102: void scaling_matrix(vector3<float> *scale, struct matrix *matrix);
103: void rotation_matrix_x(float angle, struct matrix *matrix);
104: void rotation_matrix_y(float angle, struct matrix *matrix);
105: void rotation_matrix_z(float angle, struct matrix *matrix);
106: void rotate_matrix_x(float angle, struct matrix *matrix);
107: void rotate_matrix_y(float angle, struct matrix *matrix);
108: void rotate_matrix_z(float angle, struct matrix *matrix);
109: void inverse_matrix(struct matrix *matrix, struct matrix *dest);
</file>

<file path="src/metadata.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <shlwapi.h>
 23: #include <chrono>
 24: 
 25: #include "metadata.h"
 26: #include "log.h"
 27: #include "utils.h"
 28: 
 29: Metadata metadataPatcher;
 30: 
 31: // PRIVATE
 32: void Metadata::loadXml()
 33: {
 34:     ffnx_trace("Metadata: loading metadata.xml\n");
 35: 
 36:     // Load Metadata
 37:     doc.load_file(savePath);
 38: }
 39: 
 40: void Metadata::saveXml()
 41: {
 42:     ffnx_trace("Metadata: saving metadata.xml\n");
 43: 
 44:     // Save Metadata
 45:     doc.save_file(savePath);
 46: }
 47: 
 48: void Metadata::calcNow()
 49: {
 50:     std::chrono::milliseconds nowMS = std::chrono::duration_cast<std::chrono::milliseconds>(
 51:         std::chrono::system_clock::now().time_since_epoch()
 52:     );
 53: 
 54:     now = std::to_string(nowMS.count());
 55: }
 56: 
 57: // PUBLIC
 58: void Metadata::init()
 59: {
 60:     ffnx_trace("Metadata: Initializing manager.\n");
 61: 
 62:     // Get Save Path
 63:     get_userdata_path(userPath, sizeof(userPath), true);
 64: 
 65:     // Get Metadata Path
 66:     strcpy(savePath, userPath);
 67:     PathAppendA(savePath, "metadata.xml");
 68: 
 69:     // Save userID
 70:     userID.assign(strrchr(userPath, '_') + 1);
 71: }
 72: 
 73: void Metadata::updateFF7(uint8_t save)
 74: {
 75:     char currentSave[260]{ 0 };
 76:     BYTE dataBuffer[64 * 1024 + 8]{0};
 77:     int dataSize = userID.length();
 78: 
 79:     loadXml();
 80: 
 81:     // Append save file name
 82:     strcpy(currentSave, userPath);
 83:     sprintf(currentSave + strlen(currentSave), R"(\save%02i.ff7)", save);
 84: 
 85:     // Hash existing save files
 86:     if (fileExists(currentSave))
 87:     {
 88:         ffnx_trace("Metadata: calculating hash for %s\n", currentSave);
 89: 
 90:         FILE* file = fopen(currentSave, "rb");
 91: 
 92:         fseek(file, 0, SEEK_END);
 93:         int fileSize = ftell(file);
 94:         fseek(file, 0, SEEK_SET);
 95:         fread(dataBuffer, 1, fileSize, file);
 96:         fclose(file);
 97: 
 98:         memcpy(dataBuffer + fileSize, userID.data(), userID.length());
 99: 
100:         dataSize += fileSize;
101:     }
102:     else
103:     {
104:         memcpy(dataBuffer, userID.data(), userID.length());
105:     }
106:     std::string md5 = md5_hash(dataBuffer, dataSize);
107: 
108:     // Update metadata
109:     calcNow();
110:     for (pugi::xml_node gamestatus : doc.children())
111:     {
112:         for (pugi::xml_node savefiles : gamestatus.children())
113:         {
114:             if (std::atoi(savefiles.attribute("block").value()) == (save+1))
115:             {
116:                 ffnx_trace("Metadata: updating timestamp and signature for %s\n", currentSave);
117: 
118:                 for (pugi::xml_node child : savefiles.children())
119:                 {
120:                     if (strcmp(child.name(), "timestamp") == 0)
121:                     {
122:                         child.text().set(now.data());
123:                     }
124: 
125:                     if (strcmp(child.name(), "signature") == 0)
126:                     {
127:                         child.text().set(md5.data());
128:                     }
129:                 }
130:             }
131:         }
132:     }
133: 
134:     // Flush
135:     saveXml();
136: }
137: 
138: void Metadata::updateFF8(uint8_t slot, uint8_t save)
139: {
140:     char currentSave[260]{ 0 };
141:     BYTE dataBuffer[8 * 1024 + 8]{0};
142:     int dataSize = userID.length();
143: 
144:     loadXml();
145: 
146:     // Append save file name
147:     strcpy(currentSave, userPath);
148:     if (slot > 2) {
149:         strcpy(currentSave + strlen(currentSave), "\\chocorpg.ff8");
150:     } else {
151:         sprintf(currentSave + strlen(currentSave), R"(\slot%d_save%02i.ff8)", slot, save);
152:     }
153: 
154:     // Hash existing save files
155:     if (fileExists(currentSave))
156:     {
157:         ffnx_trace("Metadata: calculating hash for %s\n", currentSave);
158: 
159:         FILE* file = fopen(currentSave, "rb");
160: 
161:         fseek(file, 0, SEEK_END);
162:         int fileSize = ftell(file);
163:         fseek(file, 0, SEEK_SET);
164:         fread(dataBuffer, 1, fileSize, file);
165:         fclose(file);
166: 
167:         memcpy(dataBuffer + fileSize, userID.data(), userID.length());
168: 
169:         dataSize += fileSize;
170:     }
171:     else
172:     {
173:         memcpy(dataBuffer, userID.data(), userID.length());
174:     }
175:     std::string md5 = md5_hash(dataBuffer, dataSize);
176: 
177:     // Update metadata
178:     calcNow();
179:     for (pugi::xml_node gamestatus : doc.children())
180:     {
181:         for (pugi::xml_node savefile : gamestatus.children())
182:         {
183:             if ((
184:                 strcmp(savefile.attribute("type").value(), "choco") == 0 && slot > 2) ||
185:                 (std::atoi(savefile.attribute("num").value()) == save && std::atoi(savefile.attribute("slot").value()) == slot)
186:             )
187:             {
188:                 ffnx_trace("Metadata: updating timestamp and signature for %s\n", currentSave);
189: 
190:                 for (pugi::xml_node child : savefile.children())
191:                 {
192:                     if (strcmp(child.name(), "timestamp") == 0)
193:                     {
194:                         child.text().set(now.data());
195:                     }
196: 
197:                     if (strcmp(child.name(), "signature") == 0)
198:                     {
199:                         child.text().set(md5.data());
200:                     }
201:                 }
202:             }
203:         }
204:     }
205: 
206:     // Flush
207:     saveXml();
208: }
</file>

<file path="src/metadata.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <io.h>
25: 
26: #include <pugiconfig.hpp>
27: #include <pugixml.hpp>
28: 
29: class Metadata
30: {
31: private:
32: 	pugi::xml_document doc;
33: 
34: 	std::string now;
35: 	std::string userID;
36: 	char userPath[260]{ 0 };
37: 	char savePath[260]{ 0 };
38: 
39: 	void calcNow();
40: 	void loadXml();
41: 	void saveXml();
42: 
43: public:
44: 	void init();
45: 	void updateFF7(uint8_t save);
46: 	void updateFF8(uint8_t slot, uint8_t save);
47: };
48: 
49: extern Metadata metadataPatcher;
</file>

<file path="src/movies.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include "audio.h"
 24: #include "movies.h"
 25: #include "patch.h"
 26: #include "ff7/widescreen.h"
 27: #include "video/movies.h"
 28: #include "redirect.h"
 29: #include "achievement.h"
 30: 
 31: enum MovieAudioLayers {
 32: 	MUSIC = 0,
 33: 	VOICE
 34: };
 35: 
 36: char movie_music_path[512];
 37: char movie_voice_path[512];
 38: 
 39: uint8_t ff8_movie_cam_buffer[2*1024*1024]; // 2MB
 40: 
 41: uint32_t ff7_prepare_movie(char *name, uint32_t loop, struct dddevice **dddevice, uint32_t dd2interface)
 42: {
 43: 	char drivename[4];
 44: 	char dirname[256];
 45: 	char filename[128];
 46: 	char fmvName[512];
 47: 	char newFmvName[512];
 48: 
 49: 	if(trace_all || trace_movies) ffnx_trace("prepare_movie %s\n", name);
 50: 
 51: 	ff7_externals.movie_object->loop = loop;
 52: 	ff7_externals.movie_sub_415231(name);
 53: 
 54: 	ff7_externals.movie_object->field_1F8 = 1;
 55: 	ff7_externals.movie_object->is_playing = 0;
 56: 	ff7_externals.movie_object->movie_end = 0;
 57: 	ff7_externals.movie_object->global_movie_flag = 0;
 58: 	ff7_externals.movie_object->field_E0 = !((struct ff7_game_obj *)common_externals.get_game_object())->field_968;
 59: 
 60: 	_splitpath(name, drivename, dirname, filename, NULL);
 61: 	_snprintf(fmvName, sizeof(fmvName), "%s%s%s.%s", drivename, dirname, filename, ffmpeg_video_ext.c_str());
 62: 
 63: 	redirect_path_with_override(fmvName, newFmvName, sizeof(newFmvName));
 64: 
 65: 	_splitpath(newFmvName, drivename, dirname, filename, NULL);
 66: 	// Remove extension
 67: 	_snprintf(movie_music_path, sizeof(movie_music_path), "%s%s%s", drivename, dirname, filename);
 68: 	_snprintf(movie_voice_path, sizeof(movie_voice_path), "%s%s%s_va", drivename, dirname, filename);
 69: 
 70: 	bool has_ext_audio_file = nxAudioEngine.canPlayMovieAudio(movie_music_path);
 71: 	ffmpeg_prepare_movie(newFmvName, !has_ext_audio_file);
 72: 	if (!has_ext_audio_file) nxAudioEngine.setStreamMasterVolume(ffmpeg_video_volume / 100.0f);
 73: 
 74: 	ff7_externals.movie_object->global_movie_flag = 1;
 75: 
 76: 	// Required by > 15 FPS movies
 77: 	movie_fps_ratio = ffmpeg_get_fps_ratio();
 78: 	if (movie_fps_ratio > 1)
 79: 	{
 80: 		if (strcmp(filename, "opening") == 0)
 81: 		{
 82: 			*ff7_externals.opening_movie_music_start_frame = *ff7_externals.opening_movie_music_start_frame * movie_fps_ratio;
 83: 		}
 84: 	}
 85: 	// ---------------------------
 86: 
 87: 	if(widescreen_enabled)
 88: 		widescreen.initMovieParamsFromConfig(filename);
 89: 
 90: 	if(steam_edition || enable_steam_achievements)
 91: 		g_FF7SteamAchievements->initMovieStats(std::string(filename));
 92: 
 93: 	return true;
 94: }
 95: 
 96: uint32_t ff7_update_movie_sample(LPDIRECTDRAWSURFACE surface)
 97: {
 98: 	uint32_t movie_end;
 99: 
100: 	ff7_externals.movie_object->movie_end = 0;
101: 
102: 	if(!ff7_externals.movie_object->is_playing) return false;
103: 
104: retry:
105: 	// Use native movie fps limiter if it's not been playback in fields ( no 3d models drawn on top )
106: 	movie_end = !ffmpeg_update_movie_sample(!(*ff7_externals.field_limit_fps));
107: 
108: 	if(movie_end)
109: 	{
110: 		if(trace_all || trace_movies) ffnx_trace("movie end\n");
111: 		if(ff7_externals.movie_object->loop)
112: 		{
113: 			ffmpeg_loop();
114: 			goto retry;
115: 		}
116: 
117: 		ff7_externals.movie_object->movie_end = 1;
118: 		is_movie_bgfield = false;
119: 
120: 		if(steam_edition || enable_steam_achievements)
121: 			if(g_FF7SteamAchievements->isEndingMovie())
122: 				g_FF7SteamAchievements->unlockGameProgressAchievement();
123: 
124: 		return true;
125: 	}
126: 
127: 	return true;
128: }
129: 
130: uint32_t ff7_start_movie()
131: {
132: 	if(trace_all || trace_movies) ffnx_trace("start_movie\n");
133: 
134: 	if(ff7_externals.movie_object->is_playing) return true;
135: 
136: 	ff7_externals.movie_object->is_playing = 1;
137: 
138: 	if (!is_movie_bgfield) nxAudioEngine.pauseAmbient();
139: 	nxAudioEngine.setMovieMasterVolume(ffmpeg_video_volume / 100.0f);
140: 	nxAudioEngine.playMovieAudio(movie_music_path, MovieAudioLayers::MUSIC);
141: 	nxAudioEngine.playMovieAudio(movie_voice_path, MovieAudioLayers::VOICE, 3.0f);
142: 
143: 	return ff7_update_movie_sample(0);
144: }
145: 
146: uint32_t ff7_stop_movie()
147: {
148: 	if(trace_all || trace_movies) ffnx_trace("stop_movie\n");
149: 
150: 	if(ff7_externals.movie_object->is_playing)
151: 	{
152: 		ff7_externals.movie_object->is_playing = 0;
153: 		ff7_externals.movie_object->movie_end = 0;
154: 
155: 		ffmpeg_stop_movie();
156: 
157: 		nxAudioEngine.stopMovieAudio(MovieAudioLayers::MUSIC);
158: 		nxAudioEngine.stopMovieAudio(MovieAudioLayers::VOICE);
159: 		if (!is_movie_bgfield) nxAudioEngine.resumeAmbient();
160: 	}
161: 
162: 	return true;
163: }
164: 
165: void ff7_release_movie_objects()
166: {
167: 	if(trace_all || trace_movies) ffnx_trace("release_movie_objects\n");
168: 
169: 	ff7_stop_movie();
170: 
171: 	ffmpeg_release_movie_objects();
172: 
173: 	ff7_externals.movie_object->global_movie_flag = 0;
174: }
175: 
176: void draw_current_frame()
177: {
178: 	if (trace_all || trace_movies) ffnx_trace("draw_current_frame\n");
179: 
180: 	ffmpeg_draw_current_frame();
181: 
182: 	// FF8 on Steam sometimes forgets to release the movie objects, so we do ensure it's done anyway
183: 	ffmpeg_release_movie_objects();
184: }
185: 
186: uint32_t ff7_get_movie_frame()
187: {
188: 	if(!ff7_externals.movie_object->is_playing) return 0;
189: 
190: 	return ffmpeg_get_movie_frame();
191: }
192: 
193: uint32_t ff8_movie_frames;
194: 
195: void ff8_prepare_movie(uint8_t disc, uint32_t movie)
196: {
197: 	char fmvName[MAX_PATH], camName[MAX_PATH], newFmvName[MAX_PATH], newCamName[MAX_PATH];
198: 	uint32_t camOffset = 0;
199: 
200: 	_snprintf(fmvName, sizeof(fmvName), "data/movies/disc%02i_%02ih.%s", disc, movie, ffmpeg_video_ext.c_str());
201: 
202: 	if (redirect_path_with_override(fmvName, newFmvName, sizeof(newFmvName)) != 0) {
203: 		_snprintf(newFmvName, sizeof(newFmvName), "%s/%s", ff8_externals.app_path, fmvName);
204: 	}
205: 
206: 	if(disc != 4)
207: 	{
208: 		_snprintf(camName, sizeof(camName), "data/movies/disc%02i_%02i.cam", disc, movie);
209: 
210: 		if (redirect_path_with_override(camName, newCamName, sizeof(newCamName)) != 0) {
211: 			_snprintf(newCamName, sizeof(newCamName), "%s/%s", ff8_externals.app_path, camName);
212: 		}
213: 
214: 		FILE *camFile = fopen(newCamName, "rb");
215: 
216: 		if(!camFile)
217: 		{
218: 			ffnx_error("could not load camera data from %s\n", newCamName);
219: 			return;
220: 		}
221: 
222: 		fseek(camFile, 0, SEEK_END);
223: 		long camFileSize = ftell(camFile);
224: 		rewind(camFile);
225: 		fread(&ff8_movie_cam_buffer, 1, camFileSize, camFile);
226: 		fclose(camFile);
227: 
228: 		ff8_externals.movie_object->movie_intro_pak = false;
229: 	}
230: 	else ff8_externals.movie_object->movie_intro_pak = true;
231: 
232: 	ff8_externals.movie_object->camdata_start = (struct ff8_camdata *)(&ff8_movie_cam_buffer[8]);
233: 	ff8_externals.movie_object->camdata_pointer = ff8_externals.movie_object->camdata_start;
234: 
235: 	ff8_externals.movie_object->movie_current_frame = 0;
236: 
237: 	if(trace_all || trace_movies) ffnx_trace("prepare_movie %s disc=%d movie=%d\n", newFmvName, disc, movie);
238: 
239: 	if (steam_edition || enable_steam_achievements) {
240: 		if (disc == 3 && movie == 4) // game ending movie
241: 		{
242: 			int squall_lvl = ff8_externals.get_char_level_4961D0(ff8_externals.savemap->chars[0].exp, 0);
243: 			g_FF8SteamAchievements->unlockEndOfGameAchievement(squall_lvl);
244: 		}
245: 	}
246: 
247: 	ff8_movie_frames = ffmpeg_prepare_movie(newFmvName);
248: }
249: 
250: void ff8_release_movie_objects()
251: {
252: 	if(trace_all || trace_movies) ffnx_trace("release_movie_objects\n");
253: 
254: 	ffmpeg_release_movie_objects();
255: }
256: 
257: int ff8_update_movie_sample()
258: {
259: 	if(trace_all || trace_movies) ffnx_trace("update_movie_sample\n");
260: 
261: 	ff8_externals.movie_object->movie_current_frame = ffmpeg_get_movie_frame();
262: 
263: 	if(ff8_externals.movie_object->camdata_pointer->flag & 0x8) *ff8_externals.byte_1CE4907 = 0;
264: 	if(ff8_externals.movie_object->camdata_pointer->flag & 0x10) *ff8_externals.byte_1CE4907 = 1;
265: 	if(ff8_externals.movie_object->camdata_pointer->flag & 0x20)
266: 	{
267: 		*ff8_externals.byte_1CE4901 = 1;
268: 		ff8_externals.movie_object->field_4C4B0 = 1;
269: 	}
270: 	else
271: 	{
272: 		*ff8_externals.byte_1CE4901 = 0;
273: 		ff8_externals.movie_object->field_4C4B0 = 0;
274: 	}
275: 
276: 	if(ff8_externals.movie_object->camdata_pointer->flag & 0x1)
277: 	{
278: 		*ff8_externals.byte_1CE4901 = 1;
279: 		ff8_externals.movie_object->field_4C4B0 = 1;
280: 	}
281: 
282: 	*ff8_externals.byte_1CE490D = ff8_externals.movie_object->camdata_pointer->flag & 0x40;
283: 
284: 	int ret = 0;
285: 
286: 	if (ff8_externals.movie_object->movie_current_frame <= ff8_externals.movie_object->movie_total_frames)
287: 	{
288: 		ffmpeg_update_movie_sample();
289: 		ret = (int)ff8_externals.movie_object->camdata_start;
290: 		ff8_externals.movie_object->camdata_pointer = &ff8_externals.movie_object->camdata_start[ff8_externals.movie_object->movie_current_frame];
291: 	}
292: 	else if(ff8_externals.movie_object->movie_intro_pak)
293: 		ret = ff8_stop_movie();
294: 	else
295: 		ret = ff8_externals.sub_5304B0();
296: 
297: 	return ret;
298: }
299: 
300: int ff8_start_movie()
301: {
302: 	if(trace_all || trace_movies) ffnx_trace("start_movie\n");
303: 
304: 	if(ff8_externals.movie_object->movie_intro_pak) ff8_externals.movie_object->movie_total_frames = ff8_movie_frames;
305: 	else
306: 	{
307: 		ff8_externals.movie_object->movie_total_frames = ((WORD *)ff8_movie_cam_buffer)[3];
308: 		ffnx_trace("%i frames\n", ff8_externals.movie_object->movie_total_frames);
309: 	}
310: 
311: 	ff8_externals.movie_object->field_4C4B0 = 0;
312: 
313: 	*ff8_externals.enable_framelimiter = false;
314: 
315: 	ff8_externals.movie_object->movie_is_playing = true;
316: 
317: 	return ff8_update_movie_sample();
318: }
319: 
320: int ff8_stop_movie()
321: {
322: 	if(trace_all || trace_movies) ffnx_trace("stop_movie\n");
323: 
324: 	ffmpeg_stop_movie();
325: 
326: 	ff8_externals.movie_object->movie_is_playing = false;
327: 
328: 	ff8_externals.movie_object->field_4C4AC = 0;
329: 	ff8_externals.movie_object->field_4C4B0 = 0;
330: 
331: 	*ff8_externals.enable_framelimiter = true;
332: 
333: 	int ret = (int)ff8_externals.movie_object->movie_file_handle;
334: 
335: 	if (ff8_externals.movie_object->movie_file_handle)
336: 	{
337: 		ret = CloseHandle(ff8_externals.movie_object->movie_file_handle);
338: 		ff8_externals.movie_object->movie_file_handle = 0;
339: 	}
340: 
341: 	return ret;
342: }
343: 
344: bool is_overlapping_movie_playing()
345: {
346: 	return ff7_externals.movie_object->is_playing && !is_movie_bgfield;
347: }
348: 
349: void movie_init()
350: {
351: 	if(!ff8)
352: 	{
353: 		nxAudioEngine.setMovieAudioMaxSlots(2);
354: 
355: 		replace_function(common_externals.prepare_movie, ff7_prepare_movie);
356: 		replace_function(common_externals.release_movie_objects, ff7_release_movie_objects);
357: 		replace_function(common_externals.start_movie, ff7_start_movie);
358: 		replace_function(common_externals.update_movie_sample, ff7_update_movie_sample);
359: 		replace_function(common_externals.stop_movie, ff7_stop_movie);
360: 		replace_function(common_externals.get_movie_frame, ff7_get_movie_frame);
361: 	}
362: 	else
363: 	{
364: 		replace_function(common_externals.prepare_movie, ff8_prepare_movie);
365: 		replace_function(common_externals.release_movie_objects, ff8_release_movie_objects);
366: 		replace_function(common_externals.start_movie, ff8_start_movie);
367: 		replace_function(common_externals.update_movie_sample, ff8_update_movie_sample);
368: 		replace_function(ff8_externals.draw_movie_frame, draw_current_frame);
369: 		replace_function(common_externals.stop_movie, ff8_stop_movie);
370: 	}
371: 
372: 	ffmpeg_movie_init();
373: }
</file>

<file path="src/movies.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: extern short movie_fps_ratio = 1;
26: extern bool is_movie_bgfield = false;
27: 
28: bool is_overlapping_movie_playing();
29: void movie_init();
30: void ff7_release_movie_objects();
31: void ff8_release_movie_objects();
32: int ff8_stop_movie();
</file>

<file path="src/music.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //                                                                          //
  10: //    This file is part of FFNx                                             //
  11: //                                                                          //
  12: //    FFNx is free software: you can redistribute it and/or modify          //
  13: //    it under the terms of the GNU General Public License as published by  //
  14: //    the Free Software Foundation, either version 3 of the License         //
  15: //                                                                          //
  16: //    FFNx is distributed in the hope that it will be useful,               //
  17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  19: //    GNU General Public License for more details.                          //
  20: /****************************************************************************/
  21: 
  22: #include <windows.h>
  23: #include <unordered_map>
  24: 
  25: #include "audio.h"
  26: #include "music.h"
  27: #include "patch.h"
  28: 
  29: #include "ff8/engine.h"
  30: 
  31: bool was_battle_gameover = false;
  32: bool next_music_channel = 0;
  33: bool next_music_is_skipped = false;
  34: bool next_music_is_skipped_with_saved_offset = false;
  35: std::unordered_map<uint32_t, bool> remember_musics;
  36: bool hold_volume_for_channel[2] = { false, false };
  37: bool next_music_is_not_multi = false;
  38: double next_music_fade_time = 0.0;
  39: bool next_music_is_battle = false;
  40: bool next_music_is_world = false;
  41: uint16_t next_battle_scene_id = 0;
  42: bool ff8_music_intro_volume_changed = false;
  43: char* eyes_on_me_track = "eyes_on_me";
  44: bool eyes_on_me_is_playing = false;
  45: uint8_t ff7_last_akao_call_type = 0;
  46: uint32_t ff7_last_music_id = 0;
  47: uint32_t ff7_last_region_id = -1;
  48: int16_t ff7_next_field_music_relative_id = -1;
  49: 
  50: void handle_mainmenu_playback()
  51: {
  52: 	struct game_mode *mode = getmode_cached();
  53: 	static bool is_main_menu = false;
  54: 
  55: 	switch (mode->driver_mode)
  56: 	{
  57: 	case MODE_MAIN_MENU:
  58: 		if (!is_main_menu)
  59: 		{
  60: 			is_main_menu = true;
  61: 
  62: 			nxAudioEngine.playMusic("main_menu", 0xFF, 0);
  63: 		}
  64: 		break;
  65: 	default:
  66: 		if (is_main_menu)
  67: 		{
  68: 			nxAudioEngine.stopMusic();
  69: 			is_main_menu = false;
  70: 		}
  71: 		break;
  72: 	}
  73: }
  74: 
  75: void music_flush()
  76: {
  77: 	nxAudioEngine.flush();
  78: }
  79: 
  80: bool is_gameover(uint32_t midi)
  81: {
  82: 	bool ret = false;
  83: 
  84: 	if (ff8)
  85: 	{
  86: 		switch (midi)
  87: 		{
  88: 		case 0: // Lose
  89: 			ret = true;
  90: 		}
  91: 	}
  92: 	else
  93: 	{
  94: 		switch (midi)
  95: 		{
  96: 		case 58: // OVER2
  97: 			ret = true;
  98: 		}
  99: 	}
 100: 
 101: 	return ret;
 102: }
 103: 
 104: uint32_t ff7_no_loop_ids[11] = {
 105: 	5, // FANFARE
 106: 	14, // TB
 107: 	22, // WALZ
 108: 	48, // CANNON
 109: 	57, // YADO
 110: 	89, // RO
 111: 	90, // JYRO
 112: 	92, // RIKU
 113: 	93, // SI
 114: 	94, // MOGU
 115: 	98, // ROLL
 116: };
 117: 
 118: bool no_loop(uint32_t midi)
 119: {
 120: 	if (ff8) {
 121: 		return false; // TODO
 122: 	}
 123: 
 124: 	for (int i = 0; i < 11; ++i) {
 125: 		if (ff7_no_loop_ids[i] == midi) {
 126: 			return true;
 127: 		}
 128: 	}
 129: 
 130: 	return false;
 131: }
 132: 
 133: uint32_t ff7_midi_init(uint32_t unknown)
 134: {
 135: 	// without this there will be no volume control for music in the config menu
 136: 	*ff7_externals.midi_volume_control = true;
 137: 
 138: 	// enable fade function
 139: 	*ff7_externals.midi_initialized = true;
 140: 
 141: 	return true;
 142: }
 143: 
 144: char ff8_midi[32];
 145: 
 146: char* ff8_format_midi_name(const char* midi_name)
 147: {
 148: 	// midi_name format: {num}{type}-{name}.sgt or {name}.sgt or _Missing.sgt
 149: 	const char* truncated_name = midi_name;
 150: 
 151: 	if (!ff8_external_music_force_original_filenames) {
 152: 		truncated_name = strchr(midi_name, '-');
 153: 
 154: 		if (nullptr != truncated_name) {
 155: 			truncated_name += 1; // Remove "-"
 156: 		}
 157: 		else {
 158: 			truncated_name = midi_name;
 159: 		}
 160: 	}
 161: 
 162: 	// Remove extension
 163: 	const char* max_midi_name = strchr(truncated_name, '.');
 164: 
 165: 	if (nullptr != max_midi_name) {
 166: 		size_t len = max_midi_name - truncated_name;
 167: 
 168: 		if (len < 32) {
 169: 			memcpy(ff8_midi, truncated_name, len);
 170: 			ff8_midi[len] = '\0';
 171: 
 172: 			return ff8_midi;
 173: 		}
 174: 	}
 175: 
 176: 	return nullptr;
 177: }
 178: 
 179: char* ff8_midi_name(uint32_t musicId)
 180: {
 181: 	if (musicId != UINT_MAX)
 182: 	{
 183: 		const char* midi_name = common_externals.get_midi_name(musicId);
 184: 		return ff8_format_midi_name(midi_name);
 185: 	}
 186: 
 187: 	return nullptr;
 188: }
 189: 
 190: char* current_midi_name(int channel)
 191: {
 192: 	const uint32_t musicId = nxAudioEngine.currentMusicId(channel);
 193: 	return ff8 ? ff8_midi_name(musicId) : common_externals.get_midi_name(musicId);
 194: }
 195: 
 196: void pause_music()
 197: {
 198: 	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));
 199: 
 200: 	nxAudioEngine.pauseMusic();
 201: }
 202: 
 203: void restart_music()
 204: {
 205: 	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));
 206: 
 207: 	nxAudioEngine.resumeMusic();
 208: }
 209: 
 210: uint32_t ff7_use_midi(uint32_t midi)
 211: {
 212: 	const char* name = common_externals.get_midi_name(midi);
 213: 
 214: 	if (nxAudioEngine.canPlayMusic(name)) {
 215: 		return 1;
 216: 	}
 217: 
 218: 	return strcmp(name, "HEART") != 0 && strcmp(name, "SATO") != 0 && strcmp(name, "SENSUI") != 0 && strcmp(name, "WIND") != 0;
 219: }
 220: 
 221: bool play_music(const char* music_name, uint32_t music_id, int channel, NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions(), char* fullpath = nullptr)
 222: {
 223: 	const struct game_mode* mode;
 224: 	bool playing = false;
 225: 	char new_music_name[50];
 226: 
 227: 	if (nxAudioEngine.isMusicDisabled(music_name)) {
 228: 		ff7_next_field_music_relative_id = -1;
 229: 
 230: 		return false;
 231: 	}
 232: 
 233: 	if (ff8)
 234: 	{
 235: 		const char* current_party_leader = ff8_names[*(byte*)(ff8_externals.field_vars_stack_1CFE9B8 + 0xCB) == 62 ? 8 : 0].c_str();
 236: 
 237: 		mode = getmode();
 238: 
 239: 		// Attempt to override battle music
 240: 		if (next_music_is_battle)
 241: 		{
 242: 			if (next_battle_scene_id > 0)
 243: 			{
 244: 				sprintf(new_music_name, "%s_%s_%u", music_name, current_party_leader, next_battle_scene_id);
 245: 
 246: 				// Attempt to load theme by party leader and battle id
 247: 				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 248: 
 249: 				if (!playing)
 250: 				{
 251: 					sprintf(new_music_name, "%s_%u", music_name, next_battle_scene_id);
 252: 
 253: 					// Attempt to load theme by battle id
 254: 					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 255: 				}
 256: 			}
 257: 
 258: 			next_music_is_battle = false;
 259: 		}
 260: 		// Attempt to override field music
 261: 		else if (mode->driver_mode == MODE_FIELD)
 262: 		{
 263: 			sprintf(new_music_name, "%s_field_%s_%s", music_name, current_party_leader, get_current_field_name());
 264: 
 265: 			// Attempt to load theme by party leader and map name
 266: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 267: 
 268: 			if (!playing)
 269: 			{
 270: 				sprintf(new_music_name, "%s_field_%s", music_name, get_current_field_name());
 271: 
 272: 				// Attempt to load theme by map name
 273: 				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 274: 			}
 275: 		}
 276: 
 277: 		if (!playing)
 278: 		{
 279: 			sprintf(new_music_name, "%s_%s", music_name, current_party_leader);
 280: 
 281: 			// Attempt to load current music name using the party leader in the name
 282: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 283: 		}
 284: 
 285: 		if (!playing) {
 286: 			if (fullpath == nullptr || nxAudioEngine.canPlayMusic(music_name))
 287: 			{
 288: 				playing = nxAudioEngine.playMusic(music_name, music_id, channel, options);
 289: 			}
 290: 			else if (fullpath != nullptr)
 291: 			{
 292: 				if (trace_all || trace_music) ffnx_info("%s: back to wav %s\n", __func__, fullpath);
 293: 
 294: 				options.useNameAsFullPath = true;
 295: 				strcpy(options.format, "wav");
 296: 				playing = nxAudioEngine.playMusic(fullpath, music_id, channel, options);
 297: 			}
 298: 		}
 299: 	}
 300: 	else
 301: 	{
 302: 		const uint32_t main_theme_midi_id = 13; // The Main Theme is always resumed
 303: 
 304: 		mode = getmode_cached();
 305: 
 306: 		if (external_music_resume) {
 307: 			if (nxAudioEngine.currentMusicId(0) == main_theme_midi_id || channel == 1) {
 308: 				// Backup current state of the music
 309: 				nxAudioEngine.pauseMusic(0, options.fadetime == 0.0 ? (next_music_is_battle && !external_music_sync ? 0.2 : 1.0) : options.fadetime, true);
 310: 			}
 311: 			else if (channel == 0) {
 312: 				// Channel 1 is never resumed
 313: 				nxAudioEngine.stopMusic(1, options.fadetime == 0.0 ? 1.0 : options.fadetime);
 314: 			}
 315: 		}
 316: 
 317: 		// Attempt to customize the battle theme flow
 318: 		if (next_music_is_battle)
 319: 		{
 320: 			uint16_t battle_id = next_battle_scene_id;
 321: 
 322: 			if (mode->driver_mode == MODE_FIELD)
 323: 			{
 324: 				battle_id = ff7_externals.modules_global_object->battle_id;
 325: 			}
 326: 
 327: 			if (battle_id > 0)
 328: 			{
 329: 				sprintf(new_music_name, "bat_%u_a%d", battle_id, ff7_externals.world_get_player_walkmap_region());
 330: 
 331: 				// Attempt to load theme by Battle ID + WM region
 332: 				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 333: 
 334: 				if (!playing)
 335: 				{
 336: 					sprintf(new_music_name, "bat_%u", battle_id);
 337: 
 338: 					// Attempt to load theme by Battle ID
 339: 					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 340: 				}
 341: 
 342: 				if (!playing && *common_externals._previous_mode == FF7_MODE_FIELD)
 343: 				{
 344: 					sprintf(new_music_name, "bat_%s", get_current_field_name());
 345: 
 346: 					// Attempt to load theme by Field name
 347: 					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 348: 				}
 349: 
 350: 				if (!playing)
 351: 				{
 352: 					sprintf(new_music_name, "bat_a%d", ff7_externals.world_get_player_walkmap_region());
 353: 
 354: 					// Attempt to load theme by Battle WM region
 355: 					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 356: 				}
 357: 			}
 358: 			else
 359: 			{
 360: 				if (trace_all || trace_music) ffnx_warning("%s: Unknown battle_id\n", __func__);
 361: 			}
 362: 		}
 363: 		else if (next_music_is_world)
 364: 		{
 365: 			ff7_last_region_id = ff7_externals.world_get_player_walkmap_region();
 366: 
 367: 			sprintf(new_music_name, "%s_a%d", music_name, ff7_last_region_id);
 368: 
 369: 			// Since world music comes with the same ID, we need to stop manually the channel to allow the new per region file to load again
 370: 			if (nxAudioEngine.canPlayMusic(new_music_name)) nxAudioEngine.stopMusic(channel);
 371: 
 372: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 373: 		}
 374: 		// Attempt to override field music
 375: 		else if (mode->driver_mode == MODE_FIELD)
 376: 		{
 377: 			if (ff7_next_field_music_relative_id >= 0)
 378: 			{
 379: 				sprintf(new_music_name, "field_%s_%d", get_current_field_name(), ff7_next_field_music_relative_id);
 380: 
 381: 				// Attempt to load theme by map name + relative field music id
 382: 				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 383: 			}
 384: 
 385: 			if (!playing)
 386: 			{
 387: 				sprintf(new_music_name, "field_%s", get_current_field_name());
 388: 
 389: 				// Attempt to load theme by map name
 390: 				playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 391: 				if (!playing)
 392: 				{
 393: 					sprintf(new_music_name, "field_%d", *ff7_externals.field_id);
 394: 
 395: 					// Attempt to load theme by Field ID
 396: 					playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 397: 				}
 398: 			}
 399: 		}
 400: 		else if (mode->driver_mode == MODE_CONDOR)
 401: 		{
 402: 			sprintf(new_music_name, "condor_%s", music_name);
 403: 
 404: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 405: 		}
 406: 		else if (mode->driver_mode == MODE_SNOWBOARD)
 407: 		{
 408: 			sprintf(new_music_name, "snowboard_%s", music_name);
 409: 
 410: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 411: 		}
 412: 		else if (mode->driver_mode == MODE_HIGHWAY)
 413: 		{
 414: 			sprintf(new_music_name, "highway_%s", music_name);
 415: 
 416: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 417: 		}
 418: 		else if (mode->driver_mode == MODE_CHOCOBO)
 419: 		{
 420: 			sprintf(new_music_name, "chocobo_%s", music_name);
 421: 
 422: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 423: 		}
 424: 		else if (mode->driver_mode == MODE_CREDITS)
 425: 		{
 426: 			sprintf(new_music_name, "credits_%s", music_name);
 427: 
 428: 			playing = nxAudioEngine.playMusic(new_music_name, music_id, channel, options);
 429: 		}
 430: 
 431: 		if (!playing)
 432: 		{
 433: 			// Nothing worked, switch back to default
 434: 			playing = nxAudioEngine.playMusic(music_name, music_id, channel, options);
 435: 		}
 436: 
 437: 		ff7_next_field_music_relative_id = -1;
 438: 	}
 439: 
 440: 	if (playing)
 441: 	{
 442: 		nxAudioEngine.setMusicLooping(!no_loop(music_id), channel);
 443: 	}
 444: 
 445: 	return playing;
 446: }
 447: 
 448: void ff7_play_midi(uint32_t music_id)
 449: {
 450: 	const int channel = external_music_resume ? next_music_channel : 0;
 451: 
 452: 	if (nxAudioEngine.currentMusicId(0) != music_id && nxAudioEngine.currentMusicId(1) != music_id)
 453: 	{
 454: 		if (is_gameover(music_id)) music_flush();
 455: 
 456: 		const char* midi_name = common_externals.get_midi_name(music_id);
 457: 		struct game_mode* mode = getmode_cached();
 458: 
 459: 		// Avoid restarting the same music when transitioning from the battle gameover to the gameover screen
 460: 		if (mode->driver_mode == MODE_GAMEOVER && was_battle_gameover)
 461: 		{
 462: 			was_battle_gameover = false;
 463: 			return;
 464: 		}
 465: 
 466: 		if (mode->driver_mode == MODE_BATTLE && is_gameover(music_id)) was_battle_gameover = true;
 467: 
 468: 		play_music(midi_name, music_id, channel);
 469: 
 470: 		if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(channel), midi_name);
 471: 	}
 472: }
 473: 
 474: void stop_music_for_channel(int channel)
 475: {
 476: 	if (!ff8)
 477: 	{
 478: 		struct game_mode* mode = getmode_cached();
 479: 
 480: 		// Do not stop the gameover music if coming from a battle
 481: 		if (mode->driver_mode == MODE_GAMEOVER && was_battle_gameover) return;
 482: 	}
 483: 
 484: 	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s, channel=%d\n", __func__, nxAudioEngine.currentMusicId(channel), current_midi_name(channel), channel);
 485: 
 486: 	nxAudioEngine.stopMusic(channel);
 487: 
 488: 	if (ff8)
 489: 	{
 490: 		ff8_externals.current_music_ids[channel] = 0;
 491: 	}
 492: }
 493: 
 494: void stop_music()
 495: {
 496: 	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));
 497: 
 498: 	stop_music_for_channel(0);
 499: 	stop_music_for_channel(1);
 500: }
 501: 
 502: void ff7_cross_fade_midi(uint32_t music_id, uint32_t steps)
 503: {
 504: 	const char* midi_name = common_externals.get_midi_name(music_id);
 505: 	const int channel = external_music_resume ? next_music_channel : 0;
 506: 
 507: 	/* FIXME: the game uses cross_fade_midi only in two places,
 508: 	 * with steps = 4 everytime. In the PS version, theses transitions
 509: 	 * last 1-2 seconds fade in / out, no more.
 510: 	 * Therefore steps value is clearly wrong here, so the formula
 511: 	 * to get the correct time is different than the one in set_midi_volume_trans.
 512: 	 */
 513: 	double time = (steps & 0xFF) / 4.0;
 514: 
 515: 	if (music_id != 0)
 516: 	{
 517: 		if (music_id == 1)
 518: 		{
 519: 			music_id = (nxAudioEngine.currentMusicId(channel) == 2) + 1;
 520: 		}
 521: 		else if (music_id == 2)
 522: 		{
 523: 			music_id = (nxAudioEngine.currentMusicId(channel) != 1) + 1;
 524: 		}
 525: 
 526: 		if (nxAudioEngine.currentMusicId(channel) != music_id)
 527: 		{
 528: 			NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
 529: 			options.fadetime = time;
 530: 			options.targetVolume = 1.0f;
 531: 			play_music(midi_name, music_id, channel, options);
 532: 		}
 533: 		else
 534: 		{
 535: 			nxAudioEngine.setMusicVolume(1.0f, channel, time);
 536: 		}
 537: 	}
 538: 	else
 539: 	{
 540: 		stop_music();
 541: 	}
 542: 
 543: 	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s, time=%fs\n", __func__, music_id, midi_name, time);
 544: }
 545: 
 546: uint32_t music_status()
 547: {
 548: 	if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, midi=%s\n", __func__, nxAudioEngine.currentMusicId(0), current_midi_name(0));
 549: 
 550: 	if (ff8) {
 551: 		// When the game asks for a music status, you know that it ends eventually
 552: 		nxAudioEngine.setMusicLooping(false, 0);
 553: 		nxAudioEngine.setMusicLooping(false, 1);
 554: 	}
 555: 
 556: 	return nxAudioEngine.isMusicPlaying(0) || nxAudioEngine.isMusicPlaying(1);
 557: }
 558: 
 559: void set_master_midi_volume(uint32_t volume)
 560: {
 561: 	if (trace_all || trace_music) ffnx_trace("%s: volume=%u\n", __func__, volume);
 562: 
 563: 	nxAudioEngine.setMusicMasterVolume(volume / 100.0f);
 564: }
 565: 
 566: void set_music_volume(uint32_t volume)
 567: {
 568: 	const int channel = 0;
 569: 
 570: 	if (volume > 127) volume = 127;
 571: 
 572: 	if (trace_all || trace_music) ffnx_trace("%s: volume=%u, channel=%u\n", __func__, volume, channel);
 573: 
 574: 	nxAudioEngine.setMusicVolume(volume / 127.0f, channel);
 575: }
 576: 
 577: void set_volume_trans(int channel, double volume, double time)
 578: {
 579: 	if (time != 0.0)
 580: 	{
 581: 		if (volume == 0.0)
 582: 		{
 583: 			nxAudioEngine.stopMusic(channel, time);
 584: 		}
 585: 		else
 586: 		{
 587: 			nxAudioEngine.setMusicVolume(volume, channel, time);
 588: 		}
 589: 	}
 590: 	else if (volume != 0.0)
 591: 	{
 592: 		nxAudioEngine.setMusicVolume(volume, channel);
 593: 	}
 594: 	else
 595: 	{
 596: 		stop_music_for_channel(channel);
 597: 	}
 598: }
 599: 
 600: void ff7_volume_trans(uint32_t volume, uint32_t steps)
 601: {
 602: 	const int channel = 0;
 603: 
 604: 	if (volume > 127) volume = 127;
 605: 
 606: 	double time = (steps & 0xFF) / 64.0;
 607: 
 608: 	if (trace_all || trace_music) ffnx_trace("%s: volume=%u, steps=%u (=> time=%fs), channel=%u\n", __func__, volume, steps, time, channel);
 609: 
 610: 	set_volume_trans(channel, volume / 127.0, time);
 611: }
 612: 
 613: void set_midi_tempo(int8_t tempo)
 614: {
 615: 	const int channel = 0;
 616: 
 617: 	if (trace_all || trace_music) ffnx_trace("%s: tempo=%d, channel=%u\n", __func__, tempo, channel);
 618: 
 619: 	if (tempo == -128) {
 620: 		tempo = -127; // Prevent speed to be 0 (can crash with SoLoud)
 621: 	}
 622: 
 623: 	float speed = float(tempo) / 128.0f + 1.0f;
 624: 
 625: 	// FIXME: will change the pitch
 626: 	nxAudioEngine.setMusicSpeed(speed, channel);
 627: }
 628: 
 629: uint32_t ff7_music_sound_operation_fix(uint32_t type, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4, uint32_t param5)
 630: {
 631: 	if (trace_all || trace_music) ffnx_trace("%s: AKAO call type=%X params=(%i %i %i %i)\n", __func__, type, param1, param2, param3, param4, param5);
 632: 
 633: 	type &= 0xFF; // The game does not always set this parameter as a 32-bit integer
 634: 
 635: 	if (type == 0xDA) { // Assimilated to stop music (Cid speech in Highwind)
 636: 		return ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(0xF0, 0, 0, 0, 0, 0);
 637: 	}
 638: 
 639: 	// Play music (channel #2) and Play music with fade (channel #2)
 640: 	if (use_external_music && (type == 0x14 || type == 0x19)) {
 641: 		const uint32_t music_id = param1;
 642: 		if (music_id > 0 && music_id <= 0x62) {
 643: 			if (trace_all || trace_music) ffnx_trace("%s: set music channel to 1\n", __func__);
 644: 			next_music_channel = 1;
 645: 		}
 646: 	}
 647: 
 648: 	uint32_t ret = ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(type, param1, param2, param3, param4, param5);
 649: 	next_music_channel = 0;
 650: 	return ret;
 651: }
 652: 
 653: uint32_t ff7_battle_music(uint32_t type, uint32_t music_id, uint32_t fadetime, uint32_t param3, uint32_t param4, uint32_t param5)
 654: {
 655: 	if (trace_all || trace_music) ffnx_trace("%s: music_id=%d\n", __func__, music_id);
 656: 
 657: 	next_music_is_battle = true;
 658: 
 659: 	uint32_t ret = ff7_music_sound_operation_fix(type, music_id, fadetime, param3, param4, param5);
 660: 
 661: 	next_music_is_battle = false;
 662: 
 663: 	return ret;
 664: }
 665: 
 666: uint32_t ff7_battle_music_fanfare()
 667: {
 668: 	if (trace_all || trace_music) ffnx_trace("%s: set music channel to 1\n", __func__);
 669: 
 670: 	next_music_channel = 1;
 671: 
 672: 	uint32_t ret = ff7_externals.play_battle_end_music();
 673: 
 674: 	next_music_channel = 0;
 675: 
 676: 	return ret;
 677: }
 678: 
 679: uint32_t ff7_worldmap_music_change(uint32_t type, uint32_t music_id, uint32_t fadetime, uint32_t param3, uint32_t param4, uint32_t param5)
 680: {
 681: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
 682: 
 683: 	if (music_id == 7) { // Battle
 684: 		ffnx_trace("%s: force music type to channel 1\n", __func__);
 685: 
 686: 		next_music_is_battle = true;
 687: 
 688: 		switch (type) {
 689: 		case 0x10:
 690: 			type = 0x14;
 691: 			break;
 692: 		case 0x18:
 693: 			type = 0x19;
 694: 			break;
 695: 		}
 696: 	}
 697: 	else
 698: 		next_music_is_world = true;
 699: 
 700: 	// Backup music operation type for custom battle music call
 701: 	ff7_last_akao_call_type = type;
 702: 	ff7_last_music_id = music_id;
 703: 
 704: 	return 0;
 705: }
 706: 
 707: void ff7_worldmap_on_loop()
 708: {
 709: 	(*ff7_externals.world_dword_DE68FC)();
 710: 
 711: 	// If we change region while moving in the worldmap, trigger a new music change
 712: 	if (ff7_last_region_id != ff7_externals.world_get_player_walkmap_region()) next_music_is_world = true;
 713: 
 714: 	if (next_music_is_battle || next_music_is_world)
 715: 	{
 716: 		ff7_music_sound_operation_fix(ff7_last_akao_call_type, ff7_last_music_id, 4, 0, 0, 0);
 717: 
 718: 		next_music_is_battle = false;
 719: 		next_music_is_world = false;
 720: 	}
 721: }
 722: 
 723: void ff7_worldmap_play_custom_battle_music(DWORD* unk1, DWORD* unk2, DWORD* battle_id)
 724: {
 725: 	ff7_externals.sub_767039(unk1, unk2, battle_id);
 726: 
 727: 	if (*unk1)
 728: 	{
 729: 		next_battle_scene_id = *battle_id;
 730: 		next_music_is_battle = true;
 731: 
 732: 		// Now we know the battle scene ID, so we can try to customize battle music in Worldmap too
 733: 		stop_music();
 734: 		// Play music
 735: 		ff7_music_sound_operation_fix(ff7_last_akao_call_type, ff7_last_music_id, 4, 0, 0, 0);
 736: 
 737: 		next_battle_scene_id = 0;
 738: 		next_music_is_battle = false;
 739: 	}
 740: }
 741: 
 742: uint32_t ff7_field_music_id_to_midi_id(int16_t field_music_id)
 743: {
 744: 	if (trace_all || trace_music) ffnx_trace("%s: field_music_id=%d\n", __func__, field_music_id);
 745: 
 746: 	ff7_next_field_music_relative_id = field_music_id;
 747: 
 748: 	return ff7_externals.field_music_id_to_midi_id(field_music_id);
 749: }
 750: 
 751: uint32_t ff8_remember_playing_time()
 752: {
 753: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
 754: 
 755: 	nxAudioEngine.pauseMusic(0, 0.0, true);
 756: 	// We never remember dualmusic, but battle and cardgame do not pause or stop channel 1 before playing the next music
 757: 	stop_music_for_channel(1);
 758: 
 759: 	return 0;
 760: }
 761: 
 762: uint32_t* ff8_load_music(uint32_t channel, uint32_t music_id, uint32_t data)
 763: {
 764: 	if (trace_all || trace_music) ffnx_trace("%s: channel=%u, music_id=%u, data=%u\n", __func__, channel, music_id, data);
 765: 
 766: 	// Do not apply volume changes for this channel between load_music and change_music/dual_music/replay_music instructions
 767: 	hold_volume_for_channel[channel] = true;
 768: 
 769: 	return ((uint32_t * (*)(uint32_t, uint32_t, uint32_t))ff8_externals.music_load)(channel, music_id, data);
 770: }
 771: 
 772: uint32_t ff8_play_midi(uint32_t music_id, int32_t volume, uint32_t unused1, uint32_t unused2)
 773: {
 774: 	const int channel = next_music_channel;
 775: 
 776: 	if (nxAudioEngine.currentMusicId(channel) != music_id)
 777: 	{
 778: 		if (is_gameover(music_id)) music_flush();
 779: 
 780: 		const char* music_name = ff8_midi_name(music_id);
 781: 
 782: 		if (nullptr == music_name) {
 783: 			ffnx_error("%s: Cannot get music name from music_id %d\n", __func__, music_id);
 784: 			return 0; // Error
 785: 		}
 786: 
 787: 		if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, name=%s, channel=%d, volume=%d\n", __func__, music_id, music_name, channel, volume);
 788: 
 789: 		SoLoud::time offset = 0;
 790: 		bool noIntro = false, backup_channel_1_after = false;
 791: 
 792: 		if (next_music_is_skipped_with_saved_offset && remember_musics[music_id]) {
 793: 			remember_musics[music_id] = false;
 794: 			if (trace_all || trace_music) ffnx_trace("%s: use remembered music time\n", __func__);
 795: 			// Move music to channel 1
 796: 			nxAudioEngine.swapChannels();
 797: 			nxAudioEngine.pauseMusic(1, 1.0);
 798: 			backup_channel_1_after = true;
 799: 		}
 800: 		else if (next_music_is_skipped) {
 801: 			noIntro = true;
 802: 		}
 803: 		else if (remember_musics[music_id]) {
 804: 			if (trace_all || trace_music) ffnx_trace("%s: discard remembered music\n", __func__);
 805: 			remember_musics[music_id] = false;
 806: 		}
 807: 
 808: 		NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
 809: 		options.fadetime = next_music_fade_time;
 810: 		options.noIntro = noIntro;
 811: 		if (volume >= 0 && volume <= 127) {
 812: 			options.targetVolume = volume / 127.0f;
 813: 		}
 814: 		play_music(music_name, music_id, channel, options);
 815: 
 816: 		if (backup_channel_1_after) {
 817: 			// Backup channel 1 music state
 818: 			nxAudioEngine.pauseMusic(1, 1.0, true);
 819: 		}
 820: 
 821: 		if (music_id == 93) { // The Extreme
 822: 			nxAudioEngine.pauseMusic(0);
 823: 		}
 824: 	}
 825: 	else if (trace_all || trace_music) {
 826: 		ffnx_trace("%s: is already playing music_id=%u, channel=%d, volume=%d\n", __func__, music_id, channel, volume);
 827: 	}
 828: 
 829: 	return 1; // Success
 830: }
 831: 
 832: uint32_t ff8_play_wav(uint32_t zero, char* filename, uint32_t volume)
 833: {
 834: 	int channel = next_music_channel;
 835: 	uint32_t music_id = ff8_externals.current_music_ids[channel];
 836: 	bool the_extreme_intro = false;
 837: 
 838: 	if (strstr(filename, "field2.fs") != nullptr) { // The Extreme Intro
 839: 		channel = 1;
 840: 		music_id = 111; // Arbitrary
 841: 		the_extreme_intro = true;
 842: 	}
 843: 
 844: 	if (the_extreme_intro || nxAudioEngine.currentMusicId(channel) != music_id)
 845: 	{
 846: 		if (is_gameover(music_id)) music_flush();
 847: 
 848: 		char* music_name = nullptr;
 849: 
 850: 		if (the_extreme_intro) {
 851: 			music_name = "lasbossintro";
 852: 		}
 853: 		else {
 854: 			music_name = ff8_format_midi_name(filename);
 855: 		}
 856: 
 857: 		if (nullptr == music_name) {
 858: 			ffnx_error("%s: Cannot get music name from filename %s\n", __func__, filename);
 859: 			return 0; // Error
 860: 		}
 861: 
 862: 		if (trace_all || trace_music) ffnx_trace("%s: music_id=%u, name=%s, channel=%d, volume=%u\n", __func__, music_id, music_name, channel, volume);
 863: 
 864: 		NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
 865: 		options.fadetime = next_music_fade_time;
 866: 		if (volume >= 0 && volume < 127) {
 867: 			options.targetVolume = volume / 127.0f;
 868: 		}
 869: 		play_music(music_name, music_id, channel, options, filename);
 870: 	}
 871: 	else if (trace_all || trace_music) {
 872: 		ffnx_trace("%s: is already playing music_id=%u, filename=%s, channel=%d, volume=%d\n", __func__, music_id, filename, channel, volume);
 873: 	}
 874: 
 875: 	return 1; // Success
 876: }
 877: 
 878: uint32_t ff8_opcode_dualmusic_play_music(char* midi_data, uint32_t volume)
 879: {
 880: 	uint32_t channel = 1;
 881: 
 882: 	if (trace_all || trace_music) ffnx_trace("%s: channel=%u, volume=%u\n", __func__, channel, volume);
 883: 
 884: 	next_music_channel = channel;
 885: 	channel = ff8_externals.sd_music_play(channel, midi_data, volume);
 886: 	next_music_channel = 0;
 887: 	return channel;
 888: }
 889: 
 890: uint32_t ff8_cross_fade_midi(char* midi_data, uint32_t steps, uint32_t volume)
 891: {
 892: 	uint32_t channel = 0;
 893: 	double time = steps / 50.0;
 894: 
 895: 	if (trace_all || trace_music) ffnx_trace("%s: steps=%u (time=%fs), volume=%u\n", __func__, steps, time, volume);
 896: 
 897: 	next_music_fade_time = time;
 898: 	channel = ff8_externals.sd_music_play(channel, midi_data, volume);
 899: 	next_music_fade_time = 0;
 900: 	return channel;
 901: }
 902: 
 903: uint32_t ff8_play_music_to_channel_0(char* midi_data)
 904: {
 905: 	uint32_t channel = 0;
 906: 
 907: 	hold_volume_for_channel[channel] = false;
 908: 
 909: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
 910: 	// Force known volume value
 911: 	return ff8_externals.sd_music_play(channel, midi_data, uint32_t(nxAudioEngine.getMusicVolume(channel) * 127));
 912: }
 913: 
 914: uint32_t ff8_play_midi_at(char* midi_data, uint32_t offset)
 915: {
 916: 	// We don't know what offset means in seconds
 917: 	if (trace_all || trace_music) ffnx_trace("%s: play midi at %d\n", __func__, offset);
 918: 	next_music_is_skipped = true;
 919: 	uint32_t channel = ff8_play_music_to_channel_0(midi_data);
 920: 	next_music_is_skipped = false;
 921: 	return channel;
 922: }
 923: 
 924: uint32_t ff8_opcode_musicskip_play_midi_at(char* midi_data, uint32_t offset)
 925: {
 926: 	uint32_t channel = 0;
 927: 
 928: 	hold_volume_for_channel[channel] = false;
 929: 
 930: 	if (trace_all || trace_music) ffnx_trace("%s: music skip, play midi at %d\n", __func__, offset);
 931: 	next_music_is_skipped_with_saved_offset = offset & 0xFF == 0xFF; // Special offset returned by ff8_opcode_getmusicoffset()
 932: 	channel = ff8_play_midi_at(midi_data, offset);
 933: 	next_music_is_skipped_with_saved_offset = false;
 934: 	return channel;
 935: }
 936: 
 937: uint32_t ff8_opcode_getmusicoffset()
 938: {
 939: 	const uint32_t channel = 0;
 940: 	const uint32_t musicId = nxAudioEngine.currentMusicId(channel);
 941: 
 942: 	if (trace_all || trace_music) ffnx_trace("%s: save music %d\n", __func__, musicId);
 943: 
 944: 	remember_musics[musicId] = true;
 945: 
 946: 	return 0xFFFFFFFF; // Return a special offset to recognize it in ff8_opcode_musicskip_play_midi_at()
 947: }
 948: 
 949: uint32_t ff8_field_pause_music(uint32_t a1)
 950: {
 951: 	if (trace_all || trace_music) ffnx_trace("%s: a1=%d\n", __func__, a1);
 952: 
 953: 	((uint32_t(*)(uint32_t))ff8_externals.pause_music_and_sfx)(0);
 954: 
 955: 	return ff8_externals.check_game_is_paused(a1);
 956: }
 957: 
 958: uint32_t ff8_field_restart_music(uint32_t a1)
 959: {
 960: 	uint32_t ret = ff8_externals.check_game_is_paused(a1);
 961: 
 962: 	if (ret == 0) { // Unpause
 963: 		if (trace_all || trace_music) ffnx_trace("%s: a1=%d\n", __func__, a1);
 964: 
 965: 		((uint32_t(*)(uint32_t))ff8_externals.restart_music_and_sfx)(0);
 966: 	}
 967: 
 968: 	return ret;
 969: }
 970: 
 971: uint32_t set_music_volume_for_channel(int32_t channel, uint32_t volume)
 972: {
 973: 	if (trace_all || trace_music) ffnx_trace("%s: channel=%d, volume=%d, hold=%d\n", __func__, channel, volume, hold_volume_for_channel[channel]);
 974: 
 975: 	if (hold_volume_for_channel[channel] || channel < 0 || channel > 1) {
 976: 		return 1;
 977: 	}
 978: 
 979: 	if (volume > 127) volume = 127;
 980: 
 981: 	nxAudioEngine.setMusicVolume(volume / 127.0f, channel);
 982: 
 983: 	return 1; // Success
 984: }
 985: 
 986: uint32_t ff8_volume_trans(int32_t channel, uint32_t steps, uint32_t volume)
 987: {
 988: 	double time = steps / 50.0;
 989: 
 990: 	if (trace_all || trace_music) ffnx_trace("%s: channel=%d, volume=%u, steps=%u (=> time=%fs), hold=%d\n", __func__, channel, volume, steps, time, hold_volume_for_channel[channel]);
 991: 
 992: 	if (hold_volume_for_channel[channel] || channel < 0 || channel > 1) {
 993: 		return 1;
 994: 	}
 995: 
 996: 	if (volume > 127) volume = 127;
 997: 
 998: 	nxAudioEngine.setMusicVolume(volume / 127.0f, channel, time);
 999: 
1000: 	return 1;
1001: }
1002: 
1003: uint32_t ff8_volume_fade(uint32_t channel, uint32_t steps, uint32_t volume1, uint32_t volume2)
1004: {
1005: 	if (trace_all || trace_music) ffnx_trace("%s: channel=%d, volume1=%u, volume2=%u, steps=%u\n", __func__, channel, volume1, volume2, steps);
1006: 
1007: 	set_music_volume_for_channel(channel, volume1);
1008: 	ff8_volume_trans(channel, steps, volume2);
1009: 
1010: 	return 1;
1011: }
1012: 
1013: uint32_t ff8_volume_sync(int a1)
1014: {
1015: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
1016: 
1017: 	if (nxAudioEngine.isMusicVolumeFadeFinished()) {
1018: 		return 2; // Continue
1019: 	}
1020: 
1021: 	return 1; // Wait
1022: }
1023: 
1024: uint32_t ff8_play_music_worldmap(char* midi_data)
1025: {
1026: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
1027: 
1028: 	nxAudioEngine.setMusicVolume(0.0f, 0, 0.5); // Fadeout: 500ms
1029: 	return ff8_cross_fade_midi(midi_data, 60, 127); // Fadein: ~1s
1030: }
1031: 
1032: uint32_t ff8_load_cdrom()
1033: {
1034: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
1035: 
1036: 	if (eyes_on_me_is_playing) {
1037: 		return 1;
1038: 	}
1039: 
1040: 	char fullpath[MAX_PATH];
1041: 
1042: 	snprintf(fullpath, MAX_PATH, "%s..\\%s.wav", ff8_externals.music_path, eyes_on_me_track);
1043: 
1044: 	NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
1045: 	options.targetVolume = 1.0f;
1046: 	eyes_on_me_is_playing = play_music(eyes_on_me_track, 111, 0, options, fullpath);
1047: 
1048: 	if (eyes_on_me_is_playing) {
1049: 		return 1;
1050: 	}
1051: 
1052: 	// Fallback
1053: 	return ff8_externals.load_cdrom();
1054: }
1055: 
1056: uint32_t ff8_play_cdrom(uint32_t trackStart, uint32_t trackEnd, uint32_t unknown)
1057: {
1058: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
1059: 
1060: 	if (eyes_on_me_is_playing) {
1061: 		return 1;
1062: 	}
1063: 
1064: 	return ff8_externals.play_cdrom(trackStart, trackEnd, unknown);
1065: }
1066: 
1067: uint32_t ff8_stop_cdrom()
1068: {
1069: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
1070: 
1071: 	if (eyes_on_me_is_playing) {
1072: 		nxAudioEngine.stopMusic(0);
1073: 		eyes_on_me_is_playing = false;
1074: 		return 1;
1075: 	}
1076: 
1077: 	return ff8_externals.stop_cdrom();
1078: }
1079: 
1080: std::vector<std::string> musics;
1081: 
1082: uint32_t ff8_opcode_choicemusic(uint32_t unused, uint32_t instruments)
1083: {
1084: 	if (trace_all || trace_music) ffnx_trace("%s: Clear musics\n", __func__);
1085: 
1086: 	musics.clear();
1087: 
1088: 	return ((uint32_t(*)(uint32_t, uint32_t))ff8_externals.choice_music)(unused, instruments);
1089: }
1090: 
1091: uint32_t ff8_load_midi_segment(void* directsound, const char* filename)
1092: {
1093: 	const char* midi_name = ff8_format_midi_name(filename);
1094: 
1095: 	hold_volume_for_channel[0] = false;
1096: 
1097: 	if (next_music_is_not_multi) {
1098: 		next_music_is_not_multi = false;
1099: 		NxAudioEngine::MusicOptions options = NxAudioEngine::MusicOptions();
1100: 		options.suppressOpeningSilence = true;
1101: 		play_music(midi_name, 43, 0, options);
1102: 		return 1; // Success
1103: 	}
1104: 
1105: 	if (trace_all || trace_music) ffnx_trace("%s: load music %s (%s)\n", __func__, midi_name, filename);
1106: 
1107: 	musics.push_back(midi_name);
1108: 
1109: 	return 1; // Success
1110: }
1111: 
1112: uint32_t ff8_play_midi_segments()
1113: {
1114: 	const int channel = 0;
1115: 
1116: 	if (trace_all || trace_music) ffnx_trace("%s\n", __func__);
1117: 
1118: 	nxAudioEngine.playSynchronizedMusics(musics, 43);
1119: 	nxAudioEngine.setMusicLooping(true, channel);
1120: 
1121: 	return 0;
1122: }
1123: 
1124: uint32_t ff8_load_and_play_one_midi_segment(uint32_t segment_id)
1125: {
1126: 	// In this call we know that we play only one segment
1127: 	next_music_is_not_multi = true;
1128: 	((uint32_t(*)(uint32_t))ff8_externals.load_midi_segment_from_id)(segment_id);
1129: 	next_music_is_not_multi = false;
1130: 
1131: 	return 0; // Fail (to prevent execution of the game's code)
1132: }
1133: 
1134: uint32_t ff8_set_music_volume_intro_credits(uint32_t channel, uint32_t volume)
1135: {
1136: 	if (ff8_music_intro_volume_changed) {
1137: 		if (nxAudioEngine.isMusicVolumeFadeFinished()) {
1138: 			*ff8_externals.credits_counter = 255; // Stop intro credits
1139: 			ff8_music_intro_volume_changed = false;
1140: 		}
1141: 
1142: 		return 1;
1143: 	}
1144: 
1145: 	if (trace_all || trace_music) ffnx_trace("%s %d %d\n", __func__, channel, volume);
1146: 
1147: 	if (nxAudioEngine.isMusicPlaying(channel)) {
1148: 		nxAudioEngine.stopMusic(channel, 2.0);
1149: 		ff8_music_intro_volume_changed = true;
1150: 	}
1151: 	else {
1152: 		*ff8_externals.credits_counter = 255; // Stop intro credits
1153: 	}
1154: 
1155: 	return 1;
1156: }
1157: 
1158: void music_init()
1159: {
1160: 	if (!ff8)
1161: 	{
1162: 		// Fix music stop issue in FF7
1163: 		patch_code_dword(ff7_externals.music_lock_clear_fix + 2, 0xCC195C);
1164: 		// Fix Cid speech music stop + music channel detection (field only)
1165: 		replace_call(ff7_externals.opcode_akao + 0xEA, ff7_music_sound_operation_fix);
1166: 		replace_call(ff7_externals.opcode_akao2 + 0xE8, ff7_music_sound_operation_fix);
1167: 		replace_call(ff7_externals.field_music_helper_sound_op_call, ff7_music_sound_operation_fix);
1168: 	}
1169: 	else
1170: 	{
1171: 		// Adding pause/resume music (and sfx) when pausing the game in field
1172: 		replace_call(ff8_externals.sub_4767B0 + (JP_VERSION ? 0x9BF : 0x9CC), ff8_field_pause_music);
1173: 		replace_call(ff8_externals.field_main_loop + 0x16C, ff8_field_restart_music);
1174: 	}
1175: 
1176: 	if (use_external_music)
1177: 	{
1178: 		if (ff8)
1179: 		{
1180: 			/* Play & Stop */
1181: 			replace_call(ff8_externals.opcode_musicload + 0x8C, ff8_load_music);
1182: 			replace_function(common_externals.play_midi, ff8_play_midi);
1183: 			replace_function(common_externals.play_wav, ff8_play_wav);
1184: 			// Removing stop_midi call from sd_music_play
1185: 			replace_call(uint32_t(ff8_externals.sd_music_play) + 0x1B1, noop_a1);
1186: 			replace_function(ff8_externals.sdmusicplay, ff8_play_music_to_channel_0);
1187: 			replace_function(common_externals.pause_midi, pause_music);
1188: 			replace_function(common_externals.pause_wav, noop_a1);
1189: 			replace_function(common_externals.restart_midi, restart_music);
1190: 			replace_function(common_externals.restart_wav, noop_a1);
1191: 			replace_function(ff8_externals.stop_music, stop_music_for_channel);
1192: 			// Called by game credits
1193: 			replace_function(common_externals.stop_midi, stop_music);
1194: 			replace_function(common_externals.midi_status, music_status);
1195: 			// Music channel detection
1196: 			replace_call(ff8_externals.opcode_dualmusic + 0x58, ff8_opcode_dualmusic_play_music);
1197: 			/* Volume */
1198: 			replace_function(common_externals.cross_fade_midi, ff8_cross_fade_midi);
1199: 			replace_function(common_externals.set_midi_volume_trans, ff8_volume_trans);
1200: 			replace_function(common_externals.set_midi_volume_fade, ff8_volume_fade);
1201: 			replace_function(common_externals.set_midi_volume, set_music_volume_for_channel);
1202: 			// Not implemented by the game
1203: 			replace_function(ff8_externals.opcode_musicvolsync, ff8_volume_sync);
1204: 			// Called by game credits
1205: 			replace_function(uint32_t(ff8_externals.dmusicperf_set_volume_sub_46C6F0), set_music_volume);
1206: 			// Fix intro credits volume fadeout time
1207: 			replace_call(ff8_externals.load_credits_image + 0x5DF, ff8_set_music_volume_intro_credits);
1208: 			replace_call(ff8_externals.load_credits_image + 0x5C2, noop_a1);
1209: 			// Worldmap: Replace stop and play music by a cross fade on leaving cities
1210: 			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x2, noop_a2); // set volume to 0
1211: 			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x8, noop_a1); // stop music
1212: 			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x28, ff8_play_music_worldmap); // play music
1213: 			replace_call(ff8_externals.worldmap_sub_53F310_loc_53F7EE + 0x3B, noop_a3); // volume fade (channel=0, steps=60, volume=127)
1214: 			/* Remember time and resume music */
1215: 			replace_function(ff8_externals.sd_music_play_at, ff8_play_midi_at);
1216: 			replace_function(common_externals.remember_midi_playing_time, ff8_remember_playing_time);
1217: 			replace_call(ff8_externals.opcode_musicskip + 0x46, ff8_opcode_musicskip_play_midi_at);
1218: 			// getmusicoffset opcode is not implemented, but could be used to skip music with musicskip opcode
1219: 			replace_call(ff8_externals.opcode_getmusicoffset, ff8_opcode_getmusicoffset);
1220: 			/* Eyes On Me */
1221: 			replace_call(ff8_externals.load_cdrom_call, ff8_load_cdrom);
1222: 			replace_call(ff8_externals.play_cdrom_call, ff8_play_cdrom);
1223: 			replace_call(ff8_externals.stop_cdrom_field_call, ff8_stop_cdrom);
1224: 			replace_call(ff8_externals.stop_cdrom_cleanup_call, ff8_stop_cdrom);
1225: 			/* MIDI segments (Fisherman's Horizon concert instruments) */
1226: 			// Initialization
1227: 			replace_call(ff8_externals.opcode_choicemusic + 0x5D, ff8_opcode_choicemusic);
1228: 			replace_function(ff8_externals.load_midi_segment, ff8_load_midi_segment);
1229: 			replace_function(ff8_externals.play_midi_segments, ff8_play_midi_segments);
1230: 			// The next played song will stop the previous one
1231: 			replace_function(ff8_externals.stop_midi_segments, noop);
1232: 			// Detect solo play_midi
1233: 			replace_call(ff8_externals.load_and_play_midi_segment + 0x41, ff8_load_and_play_one_midi_segment);
1234: 			/* Nullify MIDI subs */
1235: 			replace_function(ff8_externals.volume_music_update, noop_a1);
1236: 			replace_function(ff8_externals.dmusic_segment_connect_to_dls, noop_a2);
1237: 			replace_function(common_externals.midi_cleanup, noop);
1238: 			replace_function(common_externals.wav_cleanup, noop);
1239: 		}
1240: 		else
1241: 		{
1242: 			replace_function(common_externals.midi_init, ff7_midi_init);
1243: 			replace_function(common_externals.use_midi, ff7_use_midi);
1244: 			replace_function(common_externals.play_midi, ff7_play_midi);
1245: 			replace_function(common_externals.cross_fade_midi, ff7_cross_fade_midi);
1246: 			replace_function(common_externals.pause_midi, pause_music);
1247: 			replace_function(common_externals.restart_midi, restart_music);
1248: 			replace_function(common_externals.stop_midi, stop_music);
1249: 			replace_function(common_externals.midi_status, music_status);
1250: 			replace_function(common_externals.set_master_midi_volume, set_master_midi_volume);
1251: 			replace_function(common_externals.set_midi_volume, set_music_volume);
1252: 			replace_function(common_externals.set_midi_volume_trans, ff7_volume_trans);
1253: 			replace_function(common_externals.set_midi_tempo, set_midi_tempo);
1254: 			replace_function(common_externals.midi_cleanup, noop);
1255: 
1256: 			// Allow custom worldmap battle musics
1257: 			replace_call_function(ff7_externals.world_mode_loop_sub_74DB8C + 0x613, ff7_worldmap_play_custom_battle_music);
1258: 			// Force channel detection (1) for battle music
1259: 			replace_call(ff7_externals.play_battle_music_call, ff7_battle_music);
1260: 			replace_call(ff7_externals.play_battle_music_win_call, ff7_battle_music_fanfare);
1261: 			replace_call(ff7_externals.wm_play_music_call, ff7_worldmap_music_change);
1262: 			// Introduce a custom hook to run music AKAO code
1263: 			patch_code_byte(ff7_externals.world_loop_74BE49 + 0x121, 0x90);
1264: 			replace_call_function(ff7_externals.world_loop_74BE49 + 0x122, ff7_worldmap_on_loop);
1265: 
1266: 			replace_call(ff7_externals.field_music_id_to_midi_id_call1, ff7_field_music_id_to_midi_id);
1267: 			replace_call(ff7_externals.field_music_id_to_midi_id_call2, ff7_field_music_id_to_midi_id);
1268: 			replace_call(ff7_externals.field_music_id_to_midi_id_call3, ff7_field_music_id_to_midi_id);
1269: 
1270: 			if (ff7_external_opening_music) {
1271: 				// Disable opening music part 2 (ob)
1272: 				replace_call(ff7_externals.opening_movie_play_midi_call, noop_a1);
1273: 				// Reenable opening music part 1 (oa)
1274: 				patch_code_byte(ff7_externals.field_music_helper + 0xD1 + 2, 0x00);
1275: 			}
1276: 		}
1277: 	}
1278: }
</file>

<file path="src/music.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <stdint.h>
25: 
26: void handle_mainmenu_playback();
27: void ff7_play_midi(uint32_t music_id);
28: void music_init();
</file>

<file path="src/overlay.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2020 Marcin Gomulak                                     //
  9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 10: //    Copyright (C) 2023 Cosmos                                             //
 11: //                                                                          //
 12: //    This file is part of FFNx                                             //
 13: //                                                                          //
 14: //    FFNx is free software: you can redistribute it and/or modify          //
 15: //    it under the terms of the GNU General Public License as published by  //
 16: //    the Free Software Foundation, either version 3 of the License         //
 17: //                                                                          //
 18: //    FFNx is distributed in the hope that it will be useful,               //
 19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 21: //    GNU General Public License for more details.                          //
 22: /****************************************************************************/
 23: 
 24: #include "api.h"
 25: #include "field.h"
 26: #include "overlay.h"
 27: #include <bx/file.h>
 28: #include "cfg.h"
 29: #include "world.h"
 30: #include "lighting_debug.h"
 31: 
 32: #define IMGUI_VIEW_ID 255
 33: 
 34: inline bool Overlay::IsVkDown(int vk)
 35: {
 36:     return (::GetKeyState(vk) & 0x8000) != 0;
 37: }
 38: 
 39: // Updates the mouse position
 40: void Overlay::UpdateMousePos()
 41: {
 42:     ImGuiIO& io = ImGui::GetIO();
 43: 
 44:     // Set OS mouse position if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
 45:     if (io.WantSetMousePos)
 46:     {
 47:         POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
 48:         ::ClientToScreen(gameHwnd, &pos);
 49:         ::SetCursorPos(pos.x, pos.y);
 50:     }
 51: 
 52:     // Set mouse position
 53:     io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 54:     POINT pos;
 55:     if (HWND active_window = ::GetForegroundWindow())
 56:         if (active_window == gameHwnd || ::IsChild(active_window, gameHwnd))
 57:             if (::GetCursorPos(&pos) && ::ScreenToClient(gameHwnd, &pos))
 58:                 io.MousePos = ImVec2((float)pos.x, (float)pos.y);
 59: }
 60: 
 61: // Sets the cursor icon
 62: bool Overlay::UpdateMouseCursor()
 63: {
 64:     ImGuiIO& io = ImGui::GetIO();
 65:     if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
 66:         return false;
 67: 
 68:     ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
 69:     if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
 70:     {
 71:         // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
 72:         ::SetCursor(NULL);
 73:     }
 74:     else
 75:     {
 76:         // Show OS mouse cursor
 77:         LPTSTR win32_cursor = IDC_ARROW;
 78:         switch (imgui_cursor)
 79:         {
 80:         case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
 81:         case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
 82:         case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
 83:         case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
 84:         case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
 85:         case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
 86:         case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
 87:         case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
 88:         case ImGuiMouseCursor_NotAllowed:   win32_cursor = IDC_NO; break;
 89:         }
 90:         ::SetCursor(::LoadCursor(NULL, win32_cursor));
 91:     }
 92:     return true;
 93: }
 94: 
 95: void Overlay::Update()
 96: {
 97:     ImGuiIO& io = ImGui::GetIO();
 98:     IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");
 99: 
100:     // Block keys from reaching the game engine if the debug windows need input
101:     SetBlockKeysFromGame(io.WantCaptureKeyboard);
102: 
103:     // Setup display size (every frame to accommodate for window resizing)
104:     RECT rect;
105:     ::GetClientRect(gameHwnd, &rect);
106:     io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));
107: 
108:     // Setup time step
109:     INT64 current_time;
110:     ::QueryPerformanceCounter((LARGE_INTEGER*)&current_time);
111:     io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;
112:     g_Time = current_time;
113: 
114:     // Read keyboard modifiers inputs
115:     io.KeyCtrl = (::GetKeyState(VK_CONTROL) & 0x8000) != 0;
116:     io.KeyShift = (::GetKeyState(VK_SHIFT) & 0x8000) != 0;
117:     io.KeyAlt = (::GetKeyState(VK_MENU) & 0x8000) != 0;
118:     io.KeySuper = false;
119: 
120:     // Update OS mouse position
121:     UpdateMousePos();
122: 
123:     // Update OS mouse cursor with the cursor requested by imgui
124:     ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
125:     if (g_LastMouseCursor != mouse_cursor)
126:     {
127:         g_LastMouseCursor = mouse_cursor;
128:         UpdateMouseCursor();
129:     }
130: }
131: 
132: void Overlay::Render(ImDrawData* drawData)
133: {
134:     const ImGuiIO& io = ImGui::GetIO();
135:     const float width = io.DisplaySize.x;
136:     const float height = io.DisplaySize.y;
137: 
138:     bgfx::setViewName(IMGUI_VIEW_ID, "ImGui");
139:     bgfx::setViewMode(IMGUI_VIEW_ID, bgfx::ViewMode::Sequential);
140: 
141:     const bgfx::Caps* caps = bgfx::getCaps();
142:     {
143:         float ortho[16];
144:         bx::mtxOrtho(ortho, 0.0f, width, height, 0.0f, 0.0f, 1000.0f, 0.0f, caps->homogeneousDepth);
145:         bgfx::setViewTransform(IMGUI_VIEW_ID, NULL, ortho);
146:         bgfx::setViewRect(IMGUI_VIEW_ID, 0, 0, uint16_t(width), uint16_t(height));
147:     }
148: 
149:     for (int32_t ii = 0, num = drawData->CmdListsCount; ii < num; ++ii)
150:     {
151:         const ImDrawList* drawList = drawData->CmdLists[ii];
152:         uint32_t numVertices = (uint32_t)drawList->VtxBuffer.size();
153:         uint32_t numIndices = (uint32_t)drawList->IdxBuffer.size();
154: 
155:         bgfx::TransientVertexBuffer vb;
156:         if (bgfx::getAvailTransientVertexBuffer(drawList->VtxBuffer.Size, imguiVertexLayout)) {
157:             bgfx::allocTransientVertexBuffer(&vb, drawList->VtxBuffer.Size, imguiVertexLayout);
158:             memcpy(vb.data, drawList->VtxBuffer.Data, drawList->VtxBuffer.Size * sizeof(ImDrawVert));
159:         }
160: 
161:         bgfx::TransientIndexBuffer ib;
162:         if (bgfx::getAvailTransientIndexBuffer(drawList->IdxBuffer.Size)) {
163:             bgfx::allocTransientIndexBuffer(&ib, drawList->IdxBuffer.Size);
164:             memcpy(ib.data, drawList->IdxBuffer.Data, drawList->IdxBuffer.Size * sizeof(ImDrawIdx));
165:         }
166: 
167:         uint32_t offset = 0;
168:         for (ImDrawCmd cmd : drawList->CmdBuffer)
169:         {
170:             if (cmd.UserCallback)
171:             {
172:                 cmd.UserCallback(drawList, &cmd);
173:             }
174:             else if (0 != cmd.ElemCount)
175:             {
176:                 uint64_t state = 0
177:                     | BGFX_STATE_WRITE_RGB
178:                     | BGFX_STATE_WRITE_A
179:                     | BGFX_STATE_MSAA
180:                     ;
181: 
182:                 bgfx::TextureHandle th = m_texture;
183:                 bgfx::ProgramHandle program = m_program;
184: 
185:                 if (NULL != cmd.TextureId)
186:                 {
187:                     union { ImTextureID ptr; struct { bgfx::TextureHandle handle; uint8_t flags; uint8_t mip; } s; } texture = { cmd.TextureId };
188:                     state |= 0 != (texture.s.flags)
189:                         ? BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA)
190:                         : BGFX_STATE_NONE
191:                         ;
192:                     th = texture.s.handle;
193:                 }
194:                 else
195:                 {
196:                     state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA);
197:                 }
198: 
199:                 const uint16_t xx = uint16_t(bx::max(cmd.ClipRect.x, 0.0f));
200:                 const uint16_t yy = uint16_t(bx::max(cmd.ClipRect.y, 0.0f));
201:                 bgfx::setScissor(xx, yy
202:                     , uint16_t(bx::min(cmd.ClipRect.z, 65535.0f) - xx)
203:                     , uint16_t(bx::min(cmd.ClipRect.w, 65535.0f) - yy)
204:                 );
205: 
206:                 bgfx::setState(state);
207:                 bgfx::setTexture(0, s_tex, th);
208:                 bgfx::setVertexBuffer(0, &vb, 0, numVertices);
209:                 bgfx::setIndexBuffer(&ib, offset, cmd.ElemCount);
210:                 bgfx::submit(IMGUI_VIEW_ID, m_program);
211:             }
212: 
213:             offset += cmd.ElemCount;
214:         }
215:     }
216: }
217: 
218: bool Overlay::init(bgfx::ProgramHandle program, int width, int height)
219: {
220:     mem_edit.Open = false;
221: 
222:     if (!IMGUI_CHECKVERSION())
223:         return false;
224:     if (!::QueryPerformanceFrequency((LARGE_INTEGER*)&g_TicksPerSecond))
225:         return false;
226:     if (!::QueryPerformanceCounter((LARGE_INTEGER*)&g_Time))
227:         return false;
228: 
229:     ImGui::CreateContext();
230:     ImGui::StyleColorsDark();
231:     ImGui::SetNextWindowBgAlpha(0.3f);
232: 
233:     // Setup back-end capabilities flags
234:     ImGuiIO& io = ImGui::GetIO();
235:     io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
236:     io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
237:     io.BackendPlatformName = "imgui_impl_win32";
238:     ImGui::GetMainViewport()->PlatformHandleRaw = gameHwnd;
239: 
240:     // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.
241:     io.AddKeyEvent(ImGuiKey_Tab, IsVkDown(VK_TAB));
242:     io.AddKeyEvent(ImGuiKey_LeftArrow, IsVkDown(VK_LEFT));
243:     io.AddKeyEvent(ImGuiKey_RightArrow, IsVkDown(VK_RIGHT));
244:     io.AddKeyEvent(ImGuiKey_UpArrow, IsVkDown(VK_UP));
245:     io.AddKeyEvent(ImGuiKey_DownArrow, IsVkDown(VK_DOWN));
246:     io.AddKeyEvent(ImGuiKey_PageUp, IsVkDown(VK_PRIOR));
247:     io.AddKeyEvent(ImGuiKey_PageDown, IsVkDown(VK_NEXT));
248:     io.AddKeyEvent(ImGuiKey_Home, IsVkDown(VK_HOME));
249:     io.AddKeyEvent(ImGuiKey_End, IsVkDown(VK_END));
250:     io.AddKeyEvent(ImGuiKey_Insert, IsVkDown(VK_INSERT));
251:     io.AddKeyEvent(ImGuiKey_Delete, IsVkDown(VK_DELETE));
252:     io.AddKeyEvent(ImGuiKey_Backspace, IsVkDown(VK_BACK));
253:     io.AddKeyEvent(ImGuiKey_Space, IsVkDown(VK_SPACE));
254:     io.AddKeyEvent(ImGuiKey_Enter, IsVkDown(VK_RETURN));
255:     io.AddKeyEvent(ImGuiKey_Escape, IsVkDown(VK_ESCAPE));
256:     io.AddKeyEvent(ImGuiKey_KeypadEnter, IsVkDown(VK_RETURN));
257:     io.AddKeyEvent(ImGuiKey_A, IsVkDown('A'));
258:     io.AddKeyEvent(ImGuiKey_C, IsVkDown('C'));
259:     io.AddKeyEvent(ImGuiKey_V, IsVkDown('V'));
260:     io.AddKeyEvent(ImGuiKey_X, IsVkDown('X'));
261:     io.AddKeyEvent(ImGuiKey_Y, IsVkDown('Y'));
262:     io.AddKeyEvent(ImGuiKey_Z, IsVkDown('Z'));
263: 
264:     io.DisplaySize = ImVec2(width, height);
265:     io.DeltaTime = 1.0f / 60.0f;
266:     io.IniFilename = NULL;
267: 
268:     bgfx::RendererType::Enum type = bgfx::getRendererType();
269:     m_program = program;
270: 
271:     s_tex = bgfx::createUniform("s_tex", bgfx::UniformType::Sampler);
272: 
273:     // Load fonts
274:     // Build texture atlas
275:     unsigned char* pixels;
276:     int twidth, theight;
277:     io.Fonts->GetTexDataAsRGBA32(&pixels, &twidth, &theight);
278: 
279:     const bgfx::Memory* mem = bgfx::makeRef(pixels, twidth * theight * 4);
280:     m_texture = bgfx::createTexture2D(
281:         twidth
282:         , theight
283:         , false
284:         , 1
285:         , bgfx::TextureFormat::BGRA8
286:         , 0
287:         , mem
288:     );
289: 
290:     imguiVertexLayout
291:         .begin()
292:         .add(bgfx::Attrib::Position, 2, bgfx::AttribType::Float)
293:         .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float)
294:         .add(bgfx::Attrib::Color0, 4, bgfx::AttribType::Uint8, true)
295:         .end();
296: 
297:     nxRegisterMouseListener(this);
298:     nxRegisterKeyListener(this);
299: 
300:     return true;
301: }
302: 
303: void Overlay::drawMainWindow() {
304:     if (!ImGui::Begin("DevTools", &visible, ImGuiWindowFlags_::ImGuiWindowFlags_MenuBar))
305:     {
306:         ImGui::End();
307:         return;
308:     }
309: 
310:     if (ImGui::BeginMenuBar())
311:     {
312:         if (ImGui::BeginMenu("Tools"))
313:         {
314:             ImGui::MenuItem("Memory Debug", NULL, &mem_edit.Open);
315:             ImGui::MenuItem("Field Debug", NULL, &field_debug_open);
316:             if (!ff8) ImGui::MenuItem("Lighting Debug", NULL, &lighting_debug_open);
317:             if (ff8) ImGui::MenuItem("World Debug", NULL, &world_debug_open);
318:             ImGui::EndMenu();
319:         }
320:         ImGui::EndMenuBar();
321:     }
322:     ImGui::Text("Select a dev tool from the menu.");
323:     ImGui::End();
324: }
325: 
326: void Overlay::draw()
327: {
328:     Update();
329:     ImGui::NewFrame();
330: 
331:     // This is a placeholder UI
332:     if (visible)
333:     {
334:         drawMainWindow();
335:         if (mem_edit.Open)
336:         {
337:             if (!ff8) mem_edit.DrawWindow("Memory Editor", (void*)0x401000, 0xF52000 - 0x401000, 0x401000);
338:             else mem_edit.DrawWindow("Memory Editor", (void*)0x401000, 0x27A0000 - 0x401000, 0x401000);
339:         }
340:         if (field_debug_open) field_debug(&field_debug_open);
341:         if (!ff8 && lighting_debug_open) lighting_debug(&lighting_debug_open);
342:         if (ff8 && world_debug_open) world_debug(&world_debug_open);
343:     }
344: 
345:     ImGui::Render();
346:     Render(ImGui::GetDrawData());
347: }
348: 
349: void Overlay::destroy()
350: {
351:     bgfx::destroy(s_tex);
352:     bgfx::destroy(m_texture);
353: 
354:     ImGui::DestroyContext();
355: }
356: 
357: void Overlay::MouseDown(MouseEventArgs e)
358: {
359:     if (!ImGui::IsAnyMouseDown() && ::GetCapture() == NULL)
360:         ::SetCapture(gameHwnd);
361:     ImGui::GetIO().MouseDown[e.button - 1] = true;
362: }
363: 
364: void Overlay::MouseUp(MouseEventArgs e)
365: {
366:     ImGui::GetIO().MouseDown[e.button - 1] = false;
367:     if (!ImGui::IsAnyMouseDown() && ::GetCapture() == gameHwnd)
368:         ::ReleaseCapture();
369: }
370: 
371: void Overlay::MouseWheel(MouseEventArgs e)
372: {
373:     ImGui::GetIO().MouseWheel += e.delta;
374: }
375: 
376: void Overlay::MouseMove(MouseEventArgs e)
377: {
378:     UpdateMouseCursor();
379: }
380: 
381: void Overlay::KeyUp(KeyEventArgs e)
382: {
383:     if (e.keyValue == devtools_hotkey)
384:         visible = !visible;
385: }
386: 
387: void Overlay::KeyDown(KeyEventArgs e)
388: {
389:     // Silence is golden
390: }
391: 
392: void Overlay::KeyPress(KeyPressEventArgs e)
393: {
394:     if (e.keyChar > 0 && e.keyChar < 0x10000)
395:         ImGui::GetIO().AddInputCharacterUTF16((unsigned short)e.keyChar);
396: }
</file>

<file path="src/overlay.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2020 Marcin Gomulak                                     //
 9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
10: //    Copyright (C) 2023 Cosmos                                             //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: #include <bgfx/bgfx.h>
27: #include <imgui.h>
28: #include "imgui_club/imgui_memory_editor.h"
29: #include "input.h"
30: 
31: class Overlay : public MouseListener, public KeyListener {
32: private:
33: 	INT64 g_Time = 0;
34: 	INT64  g_TicksPerSecond = 0;
35: 	ImGuiMouseCursor g_LastMouseCursor = ImGuiMouseCursor_COUNT;
36: 	bgfx::VertexLayout imguiVertexLayout;
37: 	bgfx::UniformHandle s_tex;
38: 	bgfx::TextureHandle m_texture;
39: 	bgfx::ProgramHandle m_program;
40: 	bool visible = true;
41: 	bool field_debug_open = false;
42: 	bool lighting_debug_open = false;
43: 	bool world_debug_open = false;
44: 
45: 	MemoryEditor mem_edit;
46: 
47: 	void UpdateMousePos();
48: 	bool UpdateMouseCursor();
49: 	void Update();
50: 	void Render(ImDrawData* drawData);
51: 	inline bool IsVkDown(int vk);
52: public:
53: 	bool init(bgfx::ProgramHandle program, int width, int height);
54: 	void drawMainWindow();
55: 	void draw();
56: 	void destroy();
57: 	void MouseDown(MouseEventArgs e);
58: 	void MouseUp(MouseEventArgs e);
59: 	void MouseWheel(MouseEventArgs e);
60: 	void MouseMove(MouseEventArgs e);
61: 	void KeyUp(KeyEventArgs e);
62: 	void KeyDown(KeyEventArgs e);
63: 	void KeyPress(KeyPressEventArgs e);
64: };
</file>

<file path="src/patch.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: #include "patch.h"
 22: 
 23: #include <windows.h>
 24: #include <stdint.h>
 25: 
 26: #include "crashdump.h"
 27: 
 28: #ifdef PATCH_COLLECT_DUPLICATES
 29: #	include <unordered_set>
 30: std::unordered_set<uint32_t> offsets;
 31: std::unordered_set<uint32_t> addresses;
 32: uint32_t min_addr = 0;
 33: uint32_t max_addr = 0;
 34: #endif
 35: 
 36: uint32_t replace_counter = 0;
 37: uint32_t replaced_functions[512 * 3];
 38: 
 39: uint8_t check_is_call(const char *name, uint32_t base, uint32_t offset, uint16_t instruction)
 40: {
 41: 	if ((instruction & 0xFF) != 0xE8 && (instruction & 0xFF) != 0xE9 && instruction != 0x15FF)
 42: 	{
 43: 		// Warning to diagnose errors faster
 44: 		ffnx_warning("%s: Unrecognized call/jmp instruction at 0x%X + 0x%X (0x%X): 0x%X\n", name, base, offset, base + offset, instruction);
 45: 	}
 46: 
 47: 	return instruction == 0x15FF ? 2 : 1;
 48: }
 49: 
 50: #ifdef PATCH_COLLECT_DUPLICATES
 51: void check_boundaries(const char *name, uint32_t base, uint32_t offset, uint32_t address)
 52: {
 53: 	if (min_addr == 0)
 54: 	{
 55: 		// Get EXE boundaries
 56: 		FFNxStackWalker sw(true);
 57: 		if (sw.LoadModules()) {
 58: 			min_addr = sw.getBaseAddress();
 59: 			max_addr = min_addr + sw.getSize();
 60: 		}
 61: 	}
 62: 
 63: 	if (min_addr != 0 && (base + offset < min_addr || base + offset > max_addr))
 64: 	{
 65: 		ffnx_warning("%s: Out of bounds offset at 0x%X + 0x%X (0x%X) (min: 0x%X, max: 0x%X)\n", name, base, offset, base + offset, min_addr, max_addr);
 66: 	}
 67: 
 68: 	if (min_addr != 0 && (address < min_addr || address > max_addr))
 69: 	{
 70: 		ffnx_warning("%s: Out of bounds address at 0x%X + 0x%X (0x%X): 0x%X (min: 0x%X, max: 0x%X)\n", name, base, offset, base + offset, address, min_addr, max_addr);
 71: 	}
 72: }
 73: 
 74: void collect_addresses(const char *name, uint32_t base, uint32_t offset, uint32_t address)
 75: {
 76: 	check_boundaries(name, base, offset, address);
 77: 
 78: 	if (offsets.contains(base + offset))
 79: 	{
 80: 		ffnx_warning("%s: Offset used before 0x%X + 0x%X (0x%X)\n", name, base, offset, base + offset);
 81: 	}
 82: 
 83: 	if (addresses.contains(address))
 84: 	{
 85: 		ffnx_warning("%s: Address used before 0x%X + 0x%X (0x%X): 0x%X\n", name, base, offset, base + offset, address);
 86: 	}
 87: 
 88: 	offsets.insert(base + offset);
 89: 	addresses.insert(address);
 90: }
 91: #endif
 92: 
 93: uint32_t replace_function(uint32_t offset, void *func)
 94: {
 95: 	DWORD dummy;
 96: 
 97: 	VirtualProtect((void *)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);
 98: 
 99: 	replaced_functions[replace_counter++] = *(unsigned char *)offset;
100: 	replaced_functions[replace_counter++] = *(uint32_t *)(offset + 1);
101: 	replaced_functions[replace_counter++] = offset;
102: 
103: 	*(unsigned char *)offset = 0xE9;
104: 	*(uint32_t *)(offset + 1) = ((uint32_t)func - offset) - 5;
105: 
106: 	return replace_counter - 3;
107: }
108: 
109: void unreplace_function(uint32_t func)
110: {
111: 	uint32_t offset = replaced_functions[func + 2],
112: 		value = replaced_functions[func + 1],
113: 		instr = replaced_functions[func];
114: 	DWORD dummy;
115: 
116: 	VirtualProtect((void *)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);
117: 
118: 	// Remember previous state to rereplace later
119: 	replaced_functions[func + 1] = *(uint32_t *)(offset + 1);
120: 	replaced_functions[func] = *(unsigned char *)offset;
121: 
122: 	*(uint32_t *)(offset + 1) = value;
123: 	*(unsigned char *)offset = instr;
124: }
125: 
126: void rereplace_function(uint32_t func)
127: {
128: 	// In fact this is the same operation than unreplace_function
129: 	unreplace_function(func);
130: }
131: 
132: void unreplace_functions()
133: {
134: 	while(replace_counter > 0)
135: 	{
136: 		uint32_t offset = replaced_functions[--replace_counter];
137: 		DWORD dummy;
138: 
139: 		VirtualProtect((void *)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);
140: 		*(uint32_t *)(offset + 1) = replaced_functions[--replace_counter];
141: 		*(unsigned char *)offset = replaced_functions[--replace_counter];
142: 	}
143: }
144: 
145: void replace_call(uint32_t offset, void *func)
146: {
147: 	DWORD dummy;
148: 
149: 	uint8_t size = check_is_call(__func__, offset, 0, *((uint16_t *)(offset)));
150: 
151: 	VirtualProtect((void *)offset, size + 4, PAGE_EXECUTE_READWRITE, &dummy);
152: 
153: 	*(uint32_t *)(offset + size) = ((uint32_t)func - offset) - (size + 4);
154: }
155: 
156: uint32_t replace_call_function(uint32_t offset, void* func)
157: {
158: 	DWORD dummy;
159: 
160: 	VirtualProtect((void*)offset, 5, PAGE_EXECUTE_READWRITE, &dummy);
161: 
162: 	replaced_functions[replace_counter++] = *(unsigned char*)offset;
163: 	replaced_functions[replace_counter++] = *(uint32_t*)(offset + 1);
164: 	replaced_functions[replace_counter++] = offset;
165: 
166: 	*(unsigned char*)offset = 0xE8;
167: 	*(uint32_t*)(offset + 1) = ((uint32_t)func - offset) - 5;
168: 
169: 	return replace_counter - 3;
170: }
171: 
172: uint32_t get_relative_call(uint32_t base, uint32_t offset)
173: {
174: 	uint16_t instruction = *((uint16_t *)(base + offset));
175: 
176: 	uint8_t size = check_is_call(__func__, base, offset, instruction);
177: 
178: 	uint32_t ret = base + *((uint32_t *)(base + offset + size)) + offset + 4 + size;
179: 
180: #ifdef PATCH_COLLECT_DUPLICATES
181: 	collect_addresses(__func__, base, offset, ret);
182: #endif
183: 
184: 	return ret;
185: }
186: 
187: uint32_t get_absolute_value(uint32_t base, uint32_t offset)
188: {
189: #ifdef PATCH_COLLECT_DUPLICATES
190: 	collect_addresses(__func__, base, offset, *((uint32_t *)(base + offset)));
191: #endif
192: 
193: 	return *((uint32_t *)(base + offset));
194: }
195: 
196: void patch_code_byte(uint32_t offset, unsigned char r)
197: {
198: 	DWORD dummy;
199: 
200: 	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
201: 
202: 	*(unsigned char *)offset = r;
203: }
204: 
205: void patch_code_char(uint32_t offset, char r)
206: {
207: 	DWORD dummy;
208: 
209: 	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
210: 
211: 	*(char *)offset = r;
212: }
213: 
214: void patch_code_word(uint32_t offset, WORD r)
215: {
216: 	DWORD dummy;
217: 
218: 	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
219: 
220: 	*(WORD *)offset = r;
221: }
222: 
223: void patch_code_short(uint32_t offset, short r)
224: {
225: 	DWORD dummy;
226: 
227: 	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
228: 
229: 	*(short *)offset = r;
230: }
231: 
232: void patch_code_dword(uint32_t offset, DWORD r)
233: {
234: 	DWORD dummy;
235: 
236: 	VirtualProtect((void*)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
237: 
238: 	*(DWORD*)offset = r;
239: }
240: 
241: void patch_code_int(uint32_t offset, int r)
242: {
243: 	DWORD dummy;
244: 
245: 	VirtualProtect((void*)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
246: 
247: 	*(int*)offset = r;
248: }
249: 
250: void patch_code_uint(uint32_t offset, uint32_t r)
251: {
252: 	DWORD dummy;
253: 
254: 	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
255: 
256: 	*(uint32_t *)offset = r;
257: }
258: 
259: void patch_code_float(uint32_t offset, float r)
260: {
261: 	DWORD dummy;
262: 
263: 	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
264: 
265: 	*(float *)offset = r;
266: }
267: 
268: void patch_code_double(uint32_t offset, double r)
269: {
270: 	DWORD dummy;
271: 
272: 	VirtualProtect((void *)offset, sizeof(r), PAGE_EXECUTE_READWRITE, &dummy);
273: 
274: 	*(double *)offset = r;
275: }
276: 
277: void memcpy_code(uint32_t offset, void *data, uint32_t size)
278: {
279: 	DWORD dummy;
280: 
281: 	VirtualProtect((void *)offset, size, PAGE_EXECUTE_READWRITE, &dummy);
282: 
283: 	memcpy((void *)offset, data, size);
284: }
285: 
286: void memset_code(uint32_t offset, uint32_t val, uint32_t size)
287: {
288: 	DWORD dummy;
289: 
290: 	VirtualProtect((void *)offset, size, PAGE_EXECUTE_READWRITE, &dummy);
291: 
292: 	memset((void *)offset, val, size);
293: }
294: 
295: // From https://stackoverflow.com/a/21636483
296: void* member_func_to_ptr(char i, ...)
297: {
298:     va_list v;
299:     va_start(v,i);
300:     void* ret = va_arg(v, void*);
301:     va_end(v);
302:     return ret;
303: }
</file>

<file path="src/patch.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <stdint.h>
25: #include <windows.h>
26: 
27: uint32_t replace_function(uint32_t offset, void *func);
28: // Can also unreplace a call_function
29: void unreplace_function(uint32_t func);
30: // Replace again a function unreplaced before
31: void rereplace_function(uint32_t func);
32: void unreplace_functions();
33: 
34: void replace_call(uint32_t offset, void *func);
35: uint32_t replace_call_function(uint32_t offset, void* func);
36: 
37: uint32_t get_relative_call(uint32_t base, uint32_t offset);
38: uint32_t get_absolute_value(uint32_t base, uint32_t offset);
39: void patch_code_char(uint32_t offset, char r);
40: void patch_code_byte(uint32_t offset, unsigned char r);
41: void patch_code_word(uint32_t offset, WORD r);
42: void patch_code_short(uint32_t offset, short r);
43: void patch_code_dword(uint32_t offset, DWORD r);
44: void patch_code_int(uint32_t offset, int r);
45: void patch_code_uint(uint32_t offset, uint32_t r);
46: void patch_code_float(uint32_t offset, float r);
47: void patch_code_double(uint32_t offset, double r);
48: 
49: template<typename T>
50: void patch_multiply_code(uint32_t offset, int multiplier)
51: {
52: 	DWORD dummy;
53: 
54: 	VirtualProtect((void *)offset, sizeof(T), PAGE_EXECUTE_READWRITE, &dummy);
55: 
56: 	*(T *)offset = (*(T *)offset) * (T)multiplier;
57: 
58:     // TODO Add assertion
59: }
60: 
61: template<typename T>
62: void patch_divide_code(uint32_t offset, int multiplier)
63: {
64: 	DWORD dummy;
65: 
66: 	VirtualProtect((void *)offset, sizeof(T), PAGE_EXECUTE_READWRITE, &dummy);
67: 
68: 	*(T *)offset = (*(T *)offset) / (T)multiplier;
69: 
70:     // TODO Add assertion
71: }
72: 
73: void memcpy_code(uint32_t offset, void *data, uint32_t size);
74: void memset_code(uint32_t offset, uint32_t val, uint32_t size);
75: 
76: void* member_func_to_ptr(char i, ...);
</file>

<file path="src/redirect.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include <shlwapi.h>
 23: #include <filesystem>
 24: #include <io.h>
 25: #include "log.h"
 26: #include "utils.h"
 27: 
 28: #include "redirect.h"
 29: 
 30: int attempt_redirection(const char* in, char* out, size_t size, bool wantsSteamPath)
 31: {
 32: 	std::string newIn(in);
 33: 
 34: 	if (!ff8)
 35: 	{
 36: 		std::transform(newIn.begin(), newIn.end(), newIn.begin(), ::tolower);
 37: 	}
 38: 
 39: 	bool isSavegame = !ff8 && strstr(newIn.data(), ".ff7") != NULL;
 40: 	bool isCacheFile = !ff8 && strstr(newIn.data(), ".p") != NULL;
 41: 
 42: 	if (wantsSteamPath && !fileExists(in))
 43: 	{
 44: 		if (
 45: 			strcmp(newIn.data(), "scene.bin") == 0 ||
 46: 			strcmp(newIn.data(), "camdat0.bin") == 0 ||
 47: 			strcmp(newIn.data(), "camdat1.bin") == 0 ||
 48: 			strcmp(newIn.data(), "camdat2.bin") == 0 ||
 49: 			strcmp(newIn.data(), "co.bin") == 0
 50: 			)
 51: 		{
 52: 			get_data_lang_path(out);
 53: 			PathAppendA(out, R"(battle)");
 54: 			PathAppendA(out, newIn.data());
 55: 
 56: 			if (!fileExists(out))
 57: 				return 1;
 58: 		}
 59: 		else
 60: 		{
 61: 			const char* pos = strstr(newIn.data(), "data");
 62: 
 63: 			if (pos != NULL)
 64: 			{
 65: 				pos += 5;
 66: 			}
 67: 			else
 68: 			{
 69: 				// Search for the last '\' character and get a pointer to the next char
 70: 				pos = strrchr(in, 92);
 71: 
 72: 				if (pos != NULL) pos += 1;
 73: 			}
 74: 
 75: 			get_data_lang_path(out);
 76: 			if (pos != NULL) PathAppendA(out, pos);
 77: 
 78: 			if ((!fileExists(out) || pos == NULL))
 79: 			{
 80: 				// If steam edition, do one more try in the user data path
 81: 				if (steam_edition) get_userdata_path(out, size, isSavegame);
 82: 				else strcpy(out, "");
 83: 
 84: 				if (isCacheFile)
 85: 				{
 86: 					if (steam_edition)
 87: 					{
 88: 						PathAppendA(out, "cache");
 89: 						std::filesystem::create_directories(out);
 90: 					}
 91: 					PathAppendA(out, newIn.data());
 92: 				}
 93: 				else
 94: 				{
 95: 					if (isSavegame)
 96: 					{
 97: 						pos = strrchr(newIn.data(), 47) + 1;
 98: 						PathAppendA(out, pos);
 99: 					}
100: 					else
101: 					{
102: 						PathAppendA(out, pos);
103: 						if (!fileExists(out))
104: 							return 1;
105: 					}
106: 				}
107: 			}
108: 		}
109: 
110: 		if (trace_all || trace_files) ffnx_trace("Redirected: %s -> %s\n", newIn.data(), out);
111: 
112: 		return 0;
113: 	}
114: 	else
115: 	{
116: 		if (isSavegame && !save_path.empty())
117: 		{
118: 			char* pos = strrchr(newIn.data(), 47);
119: 
120: 			// This case may happen if we have already redirected the path
121: 			if (strstr(newIn.data(), "save/save") == NULL)
122: 			{
123: 				// Allow the game to continue by forward the redirected path again
124: 				strcpy(out, newIn.data());
125: 			}
126: 			// This one means we still have to redirect it
127: 			else if (pos != NULL)
128: 			{
129: 				strcpy(out, basedir);
130: 				PathAppendA(out, save_path.c_str());
131: 				PathAppendA(out, ++pos);
132: 
133: 				if (trace_all || trace_files) ffnx_trace("Redirected: %s -> %s\n", newIn.data(), out);
134: 			}
135: 
136: 			// Always return as found in order to allow non existing save files to be saved under the new redirected path
137: 			return 0;
138: 		}
139: 		else if (!isCacheFile)
140: 		{
141: 			const char* pos = ff8 ? newIn.data() : strstr(newIn.data(), "data");
142: 
143: 			if (pos != NULL)
144: 			{
145: 				pos += ff8 ? 0 : 5;
146: 			}
147: 			else
148: 			{
149: 				// Search for the last '\' character and get a pointer to the next char
150: 				pos = strrchr(newIn.data(), 92);
151: 
152: 				if (pos != NULL) pos += 1;
153: 			}
154: 
155: 			strcpy(out, basedir);
156: 			PathAppendA(out, override_path.c_str());
157: 			if (pos != NULL)
158: 				PathAppendA(out, pos);
159: 			else
160: 			{
161: 				PathAppendA(out, R"(battle)");
162: 				PathAppendA(out, newIn.data());
163: 			}
164: 
165: 			if (!fileExists(out))
166: 				return -1;
167: 
168: 			if (trace_all || trace_files) ffnx_trace("Redirected: %s -> %s\n", newIn.data(), out);
169: 
170: 			return 0;
171: 		}
172: 	}
173: 
174: 	return -1;
175: }
176: 
177: int redirect_path_with_override(const char* in, char* out, size_t out_size)
178: {
179: 	char _newFilename[MAX_PATH]{ 0 };
180: 
181: 	// Attempt another redirection based on Steam/eStore logic
182: 	int redirect_status = attempt_redirection(in, _newFilename, sizeof(_newFilename), steam_edition || estore_edition);
183: 
184: 	// File was found
185: 	if (redirect_status == 0)
186: 	{
187: 		// Attemp override redirection on top of Steam/eStore new path
188: 		redirect_status = attempt_redirection(_newFilename, out, out_size);
189: 
190: 		if (redirect_status == -1)
191: 		{
192: 			if (trace_all || trace_files) ffnx_trace("Redirection attempted, but file was not found: %s -> %s\n", in, _newFilename);
193: 
194: 			// If was not found, use original redirected path
195: 			strcpy(out, _newFilename);
196: 		}
197: 	}
198: 	// File was not found
199: 	else if (redirect_status == -1)
200: 	{
201: 		// Attemp override redirection on top of classic path
202: 		redirect_status = attempt_redirection(in, out, out_size);
203: 
204: 		if (redirect_status == -1)
205: 		{
206: 			if (trace_all || trace_files) ffnx_trace("Redirection attempted, but file was not found: %s -> %s\n", in, out);
207: 
208: 			// If was not found, use original filename
209: 			strcpy(out, in);
210: 		}
211: 	}
212: 
213: 	return redirect_status;
214: }
</file>

<file path="src/redirect.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: /**
25:  * Returns:
26:  *  -1 if the file was not found
27:  *   0 if the file is redirected
28:  *   1 if the file was not found but required
29:  */
30: int attempt_redirection(const char* in, char* out, size_t size, bool wantsSteamPath = false);
31: /**
32:  * Returns:
33:  *  -1 if the file was not found, in this case, `out` path is filled with `in` path content
34:  *  0  if the file is redirected
35:  *  1  if the file was not found but required
36:  */
37: int redirect_path_with_override(const char* in, char* out, size_t out_size);
</file>

<file path="src/renderer.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //    Copyright (C) 2023 Cosmos                                             //
  10: //                                                                          //
  11: //    This file is part of FFNx                                             //
  12: //                                                                          //
  13: //    FFNx is free software: you can redistribute it and/or modify          //
  14: //    it under the terms of the GNU General Public License as published by  //
  15: //    the Free Software Foundation, either version 3 of the License         //
  16: //                                                                          //
  17: //    FFNx is distributed in the hope that it will be useful,               //
  18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  20: //    GNU General Public License for more details.                          //
  21: /****************************************************************************/
  22: 
  23: // We need to set WINVER and _WIN32_WINNT to Win10 in order for DISPLAYCONFIG_SDR_WHITE_LEVEL to be defined.
  24: // Since the relevant functions have been defined since Win7, and we're only using a johnny-come-lately *parameter*,
  25: // the SDR-white-level-for-HDR autodetection code should fail gracefully with a bad parameter error on older versions of Windows.
  26: // In theory at least. (Not tested yet.)
  27: // It does fail gracefully on Wine.
  28: #define WINVER 0x0A00
  29: #define _WIN32_WINNT 0x0A00
  30: 
  31: #include <windows.h>
  32: #include <vector>
  33: 
  34: #include "lighting.h"
  35: #include "ff7/widescreen.h"
  36: #include "image/image.h"
  37: #include "gl.h"
  38: #include "log.h"
  39: #include "cfg.h"
  40: #include "utils.h"
  41: #include "renderer.h"
  42: 
  43: CMRC_DECLARE(FFNx);
  44: 
  45: Renderer newRenderer;
  46: RendererCallbacks bgfxCallbacks;
  47: 
  48: // BGFX CALLBACKS
  49: void RendererCallbacks::fatal(const char* _filePath, uint16_t _line, bgfx::Fatal::Enum _code, const char* _str)
  50: {
  51:     std::string error;
  52: 
  53:     switch (_code) {
  54:     case bgfx::Fatal::Enum::DebugCheck: error = "Debug Check";
  55:     case bgfx::Fatal::Enum::InvalidShader: error = "Invalid Shader";
  56:     case bgfx::Fatal::Enum::UnableToInitialize: error = "Unable To Initialize";
  57:     case bgfx::Fatal::Enum::UnableToCreateTexture: error = "Unable To Create Texture";
  58:     case bgfx::Fatal::Enum::DeviceLost: error = "Device Lost";
  59:     }
  60: 
  61:     ffnx_error("[%s] %s\n", error.c_str(), _str);
  62: }
  63: 
  64: void RendererCallbacks::traceVargs(const char* _filePath, uint16_t _line, const char* _format, va_list _argList)
  65: {
  66:     if (renderer_debug)
  67:     {
  68:         char buffer[16 * 1024];
  69: 
  70:         va_list argListCopy;
  71:         va_copy(argListCopy, _argList);
  72:         vsnprintf(buffer, sizeof(buffer), _format, argListCopy);
  73:         va_end(argListCopy);
  74: 
  75:         ffnx_trace("%s", buffer);
  76:     }
  77: }
  78: 
  79: uint32_t RendererCallbacks::cacheReadSize(uint64_t _id)
  80: {
  81:     // Return 0 if shader is not found.
  82:     return 0;
  83: }
  84: 
  85: bool RendererCallbacks::cacheRead(uint64_t _id, void* _data, uint32_t _size)
  86: {
  87:     // Shader is not found in cache, needs to be rebuilt.
  88:     return false;
  89: }
  90: 
  91: void RendererCallbacks::cacheWrite(uint64_t _id, const void* _data, uint32_t _size)
  92: {
  93: }
  94: 
  95: // PRIVATE
  96: 
  97: // Via https://stackoverflow.com/a/14375308
  98: uint32_t Renderer::createBGRA(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
  99: {
 100:     return ((b & 0xff) << 24) + ((g & 0xff) << 16) + ((r & 0xff) << 8) + (a & 0xff);
 101: }
 102: 
 103: void Renderer::setCommonUniforms()
 104: {
 105:     internalState.VSFlags = {
 106:         (float)internalState.bIsTLVertex,
 107:         (float)internalState.blendMode,
 108:         (float)internalState.bIsFBTexture,
 109:         (float)internalState.bIsTexture
 110:     };
 111:     if (uniform_log) ffnx_trace("%s: VSFlags XYZW(isTLVertex %f, blendMode %f, isFBTexture %f, isTexture %f)\n", __func__, internalState.VSFlags[0], internalState.VSFlags[1], internalState.VSFlags[2], internalState.VSFlags[3]);
 112: 
 113:     internalState.FSAlphaFlags = {
 114:         (float)internalState.alphaRef,
 115:         (float)internalState.alphaFunc,
 116:         (float)internalState.bDoAlphaTest,
 117:         NULL
 118:     };
 119:     if (uniform_log) ffnx_trace("%s: FSAlphaFlags XYZW(inAlphaRef %f, inAlphaFunc %f, bDoAlphaTest %f, NULL)\n", __func__, internalState.FSAlphaFlags[0], internalState.FSAlphaFlags[1], internalState.FSAlphaFlags[2]);
 120: 
 121:     internalState.FSMiscFlags = {
 122:         (float)internalState.bIsMovieFullRange,
 123:         (float)internalState.bIsMovieYUV,
 124:         (float)internalState.bModulateAlpha,
 125:         (float)internalState.bIsMovie
 126:     };
 127:     if (uniform_log) ffnx_trace("%s: FSMiscFlags XYZW(isMovieFullRange %f, isMovieYUV %f, modulateAlpha %f, isMovie %f)\n", __func__, internalState.FSMiscFlags[0], internalState.FSMiscFlags[1], internalState.FSMiscFlags[2], internalState.FSMiscFlags[3]);
 128: 
 129:     internalState.FSHDRFlags = {
 130:         (float)internalState.bIsHDR,
 131:         (float)hdr_max_nits,
 132:         (float)internalState.bIsOverrideGamut,
 133:         NULL
 134:     };
 135:     if (uniform_log) ffnx_trace("%s: FSMiscFlags XYZW(isHDR %f, monitorNits %f, NULL, NULL)\n", __func__, internalState.FSHDRFlags[0], internalState.FSHDRFlags[1]);
 136: 
 137:     internalState.FSTexFlags = {
 138:         (float)(internalState.texHandlers[RendererTextureSlot::TEX_NML].idx != bgfx::kInvalidHandle),
 139:         (float)(internalState.texHandlers[RendererTextureSlot::TEX_PBR].idx != bgfx::kInvalidHandle),
 140:         (float)(specularIblTexture.idx != bgfx::kInvalidHandle && diffuseIblTexture.idx != bgfx::kInvalidHandle && envBrdfTexture.idx != bgfx::kInvalidHandle),
 141:         NULL
 142:     };
 143:     if (uniform_log) ffnx_trace("%s: FSTexFlags XYZW(isNmlTextureLoaded %f, isPbrTextureLoaded %f, isIblTextureLoaded %f, NULL)\n", __func__, internalState.FSTexFlags[0], internalState.FSTexFlags[1], internalState.FSTexFlags[2]);
 144: 
 145:     internalState.WMFlags = {
 146:         (float)internalState.sphericalWorldRate,
 147:         (float)internalState.bIsFogEnabled,
 148:         NULL,
 149:         NULL
 150:     };
 151:     if (uniform_log) ffnx_trace("%s: VSFlags XYZW(isTLVertex %f, blendMode %f, isFBTexture %f, isTexture %f)\n", __func__, internalState.VSFlags[0], internalState.VSFlags[1], internalState.VSFlags[2], internalState.VSFlags[3]);
 152: 
 153:     internalState.FSMovieFlags = {
 154:         (float)internalState.bIsMovieColorMatrix,
 155:         (float)internalState.bIsMovieColorGamut,
 156:         (float)internalState.bIsMovieGammaType,
 157:         (float)internalState.bIsOverallColorGamut,
 158:     };
 159:     if (uniform_log) ffnx_trace("%s: FSMovieFlags XYZW(color matrix %f, color gamut %f, gamma type %f, overall color gamut %f)\n", __func__, internalState.FSMovieFlags[0], internalState.FSMovieFlags[1], internalState.FSMovieFlags[2], internalState.FSMovieFlags[3]);
 160: 
 161:     internalState.gameLightingFlags = {
 162:         (float)game_lighting,
 163:         NULL,
 164:         NULL,
 165:         NULL,
 166:     };
 167: 
 168:     setUniform(RendererUniform::VS_FLAGS,  internalState.VSFlags.data());
 169:     setUniform(RendererUniform::FS_ALPHA_FLAGS, internalState.FSAlphaFlags.data());
 170:     setUniform(RendererUniform::FS_MISC_FLAGS, internalState.FSMiscFlags.data());
 171:     setUniform(RendererUniform::FS_HDR_FLAGS, internalState.FSHDRFlags.data());
 172:     setUniform(RendererUniform::FS_TEX_FLAGS, internalState.FSTexFlags.data());
 173:     setUniform(RendererUniform::FS_MOVIE_FLAGS, internalState.FSMovieFlags.data());
 174:     setUniform(RendererUniform::WM_FLAGS, internalState.WMFlags.data());
 175:     setUniform(RendererUniform::TIME_COLOR, internalState.TimeColor.data());
 176:     setUniform(RendererUniform::TIME_DATA, internalState.TimeData.data());
 177: 
 178:     setUniform(RendererUniform::D3D_VIEWPORT, internalState.d3dViewMatrix);
 179:     setUniform(RendererUniform::D3D_PROJECTION, internalState.d3dProjectionMatrix);
 180:     setUniform(RendererUniform::WORLD_VIEW, internalState.worldViewMatrix);
 181:     setUniform(RendererUniform::NORMAL_MATRIX, internalState.normalMatrix);
 182:     setUniform(RendererUniform::VIEW_MATRIX, internalState.viewMatrix);
 183:     setUniform(RendererUniform::INV_VIEW_MATRIX, internalState.invViewMatrix);
 184: 
 185:     setUniform(RendererUniform::GAME_LIGHTING_FLAGS,  internalState.gameLightingFlags.data());
 186:     setUniform(RendererUniform::GAME_GLOBAL_LIGHT_COLOR, internalState.gameGlobalLightColor);
 187:     setUniform(RendererUniform::GAME_LIGHT_COLOR1, internalState.gameLightColor1);
 188:     setUniform(RendererUniform::GAME_LIGHT_COLOR2, internalState.gameLightColor2);
 189:     setUniform(RendererUniform::GAME_LIGHT_COLOR3, internalState.gameLightColor3);
 190:     setUniform(RendererUniform::GAME_LIGHT_DIR1, internalState.gameLightDir1);
 191:     setUniform(RendererUniform::GAME_LIGHT_DIR2, internalState.gameLightDir2);
 192:     setUniform(RendererUniform::GAME_LIGHT_DIR3, internalState.gameLightDir3);
 193:     setUniform(RendererUniform::GAME_SCRIPTED_LIGHT_COLOR, internalState.gameScriptedLightColor);
 194: }
 195: 
 196: void Renderer::setLightingUniforms()
 197: {
 198:     auto lightingState = lighting.getLightingState();
 199: 
 200:     setUniform(RendererUniform::LIGHTING_SETTINGS, lightingState.lightingSettings);
 201:     setUniform(RendererUniform::LIGHT_DIR_DATA, lightingState.lightDirData);
 202:     setUniform(RendererUniform::LIGHT_DATA, lightingState.lightData);
 203:     setUniform(RendererUniform::AMBIENT_LIGHT_DATA, lightingState.ambientLightData);
 204:     setUniform(RendererUniform::SHADOW_DATA, lightingState.shadowData);
 205:     setUniform(RendererUniform::FIELD_SHADOW_DATA, lightingState.fieldShadowData);
 206:     setUniform(RendererUniform::MATERIAL_DATA, lightingState.materialData);
 207:     setUniform(RendererUniform::MATERIAL_SCALE_DATA, lightingState.materialScaleData);
 208:     setUniform(RendererUniform::LIGHTING_DEBUG_DATA, lightingState.lightingDebugData);
 209:     setUniform(RendererUniform::IBL_DATA, lightingState.iblData);
 210: 
 211:     setUniform(RendererUniform::LIGHT_VIEW_PROJ_MATRIX, lightingState.lightViewProjMatrix);
 212:     setUniform(RendererUniform::LIGHT_VIEW_PROJ_TEX_MATRIX, lightingState.lightViewProjTexMatrix);
 213:     setUniform(RendererUniform::LIGHT_INV_VIEW_PROJ_TEX_MATRIX, lightingState.lightInvViewProjTexMatrix);
 214: }
 215: 
 216: bgfx::RendererType::Enum Renderer::getUserChosenRenderer() {
 217:     bgfx::RendererType::Enum ret;
 218: 
 219:     switch (renderer_backend)
 220:     {
 221:     case RENDERER_BACKEND_AUTO:
 222:         ret = bgfx::RendererType::Count;
 223:         break;
 224:     case RENDERER_BACKEND_OPENGL:
 225:         ret = bgfx::RendererType::OpenGL;
 226:         break;
 227:     case RENDERER_BACKEND_DIRECT3D11:
 228:         ret = bgfx::RendererType::Direct3D11;
 229:         break;
 230:     case RENDERER_BACKEND_DIRECT3D12:
 231:         ret = bgfx::RendererType::Direct3D12;
 232:         break;
 233:     case RENDERER_BACKEND_VULKAN:
 234:         ret = bgfx::RendererType::Vulkan;
 235:         break;
 236:     default:
 237:         ret = bgfx::RendererType::Noop;
 238:         break;
 239:     }
 240: 
 241:     return ret;
 242: }
 243: 
 244: void Renderer::updateRendererShaderPaths()
 245: {
 246:     std::string shaderSuffix;
 247: 
 248:     switch (getCaps()->rendererType)
 249:     {
 250:     case bgfx::RendererType::OpenGL:
 251:         currentRenderer = "OpenGL";
 252:         shaderSuffix = ".gl";
 253:         break;
 254:     case bgfx::RendererType::Direct3D11:
 255:         currentRenderer = "Direct3D11";
 256:         shaderSuffix = ".d3d11";
 257:         break;
 258:     case bgfx::RendererType::Direct3D12:
 259:         currentRenderer = "Direct3D12";
 260:         shaderSuffix = ".d3d12";
 261:         break;
 262:     case bgfx::RendererType::Vulkan:
 263:         currentRenderer = "Vulkan";
 264:         shaderSuffix = ".vk";
 265:         break;
 266:     }
 267: 
 268:     vertexPathFlat += ".flat" + shaderSuffix + ".vert";
 269:     fragmentPathFlat += ".flat" + shaderSuffix + ".frag";
 270:     vertexPathSmooth += ".smooth" + shaderSuffix + ".vert";
 271:     fragmentPathSmooth += ".smooth" + shaderSuffix + ".frag";
 272:     vertexPostPath += ".smooth" + shaderSuffix + ".vert";
 273:     fragmentPostPath += ".smooth" + shaderSuffix + ".frag";
 274:     vertexOverlayPath += ".smooth" + shaderSuffix + ".vert";
 275:     fragmentOverlayPath += ".smooth" + shaderSuffix + ".frag";
 276:     vertexLightingPathFlat += ".flat" + shaderSuffix + ".vert";
 277:     fragmentLightingPathFlat += ".flat" + shaderSuffix + ".frag";
 278:     vertexLightingPathSmooth += ".smooth" + shaderSuffix + ".vert";
 279:     fragmentLightingPathSmooth += ".smooth" + shaderSuffix + ".frag";
 280:     vertexShadowMapPath += ".smooth" + shaderSuffix + ".vert";
 281:     fragmentShadowMapPath += ".smooth" + shaderSuffix + ".frag";
 282:     vertexFieldShadowPath += ".smooth" + shaderSuffix + ".vert";
 283:     fragmentFieldShadowPath += ".smooth" + shaderSuffix + ".frag";
 284:     vertexBlitPath += ".flat" + shaderSuffix + ".vert";
 285:     fragmentBlitPath += ".flat" + shaderSuffix + ".frag";
 286: }
 287: 
 288: // Via https://dev.to/pperon/hello-bgfx-4dka
 289: bgfx::ShaderHandle Renderer::getShader(const char* filePath)
 290: {
 291:     bgfx::ShaderHandle handle = BGFX_INVALID_HANDLE;
 292: 
 293:     FILE* file = fopen(filePath, "rb");
 294: 
 295:     if (file == NULL)
 296:     {
 297:         char tmp[1024]{ 0 };
 298: 
 299:         sprintf(tmp, "Oops! Something very bad happened.\n\nCould not find shader file:\n%s\n\nMake sure all the provided files are installed correctly.", filePath);
 300: 
 301:         MessageBoxA(gameHwnd, tmp, "Error", MB_ICONERROR | MB_OK);
 302: 
 303:         exit(1);
 304:     }
 305: 
 306:     fseek(file, 0, SEEK_END);
 307:     long fileSize = ftell(file);
 308:     fseek(file, 0, SEEK_SET);
 309: 
 310:     const bgfx::Memory* mem = bgfx::alloc(fileSize);
 311:     fread(mem->data, 1, fileSize, file);
 312:     fclose(file);
 313: 
 314:     handle = bgfx::createShader(mem);
 315: 
 316:     if (bgfx::isValid(handle))
 317:     {
 318:         bgfx::setName(handle, filePath);
 319:     }
 320: 
 321:     return handle;
 322: }
 323: 
 324: bgfx::UniformHandle Renderer::createUniform(std::string uniformName, bgfx::UniformType::Enum uniformType)
 325: {
 326:     bgfx::UniformHandle handle;
 327:     handle = bgfx::createUniform(uniformName.c_str(), uniformType);
 328:     return handle;
 329: }
 330: 
 331: bgfx::UniformHandle Renderer::setUniform(RendererUniform uniform, const void* uniformValue)
 332: {
 333:     bgfx::UniformHandle handle = bgfxUniformHandles[uniform];
 334: 
 335:     if (bgfx::isValid(handle))
 336:     {
 337:         bgfx::setUniform(handle, uniformValue);
 338:     }
 339: 
 340:     return handle;
 341: }
 342: 
 343: void Renderer::destroyUniforms()
 344: {
 345:     for (const auto& handle : bgfxUniformHandles)
 346:     {
 347:         if (bgfx::isValid(handle))
 348:             bgfx::destroy(handle);
 349:     }
 350: }
 351: 
 352: void Renderer::destroyAll()
 353: {
 354:     destroyUniforms();
 355: 
 356:     for (auto& handle : internalState.texHandlers)
 357:     {
 358:         if (bgfx::isValid(handle))
 359:             bgfx::destroy(handle);
 360:     }
 361: 
 362:     bgfx::destroy(vertexBufferHandle);
 363: 
 364:     bgfx::destroy(indexBufferHandle);
 365: 
 366:     bgfx::destroy(backendFrameBuffer);
 367: 
 368:     bgfx::destroy(shadowMapFrameBuffer);
 369: 
 370:     for (auto& handle : backendProgramHandles)
 371:     {
 372:         if (bgfx::isValid(handle))
 373:             bgfx::destroy(handle);
 374:     }
 375: 
 376:     if (enable_devtools)
 377:         overlay.destroy();
 378: };
 379: 
 380: void Renderer::resetState()
 381: {
 382:     setBackgroundColor();
 383: 
 384:     doAlphaTest();
 385:     doDepthTest();
 386:     doDepthWrite();
 387:     doScissorTest();
 388:     setCullMode();
 389:     setBlendMode();
 390:     setAlphaRef();
 391:     setInterpolationQualifier();
 392:     isTLVertex();
 393:     isYUV();
 394:     isFullRange();
 395:     isFBTexture();
 396:     isTexture();
 397:     doModulateAlpha();
 398:     doTextureFiltering();
 399:     isExternalTexture();
 400:     setColorMatrix();
 401:     setColorGamut();
 402:     setOverallColorGamut(enable_ntscj_gamut_mode ? COLORGAMUT_NTSCJ : COLORGAMUT_SRGB);
 403:     setGamutOverride();
 404:     setGammaType();
 405:     setGameLightData();
 406: 
 407:     doMirrorTextureWrap();
 408:     setSphericalWorldRate();
 409:     setFogEnabled();
 410: 
 411:     resetViewMatrixFlag();
 412: };
 413: 
 414: void Renderer::renderFrame()
 415: {
 416:     /*  y0    y2
 417:      x0 +-----+ x2
 418:         |    /|
 419:         |   / |
 420:         |  /  |
 421:         | /   |
 422:         |/    |
 423:      x1 +-----+ x3
 424:         y1    y3
 425:     */
 426: 
 427:     // 0
 428:     float x0 = framebufferVertexOffsetX;
 429:     if (aspect_ratio == AR_STRETCH) x0 = 0.0f;
 430:     float y0 = 0.0f;
 431:     float u0 = 0.0f;
 432:     float v0 = getCaps()->originBottomLeft ? 1.0f : 0.0f;
 433:     // 1
 434:     float x1 = x0;
 435:     float y1 = game_height;
 436:     float u1 = u0;
 437:     float v1 = getCaps()->originBottomLeft ? 0.0f : 1.0f;
 438:     // 2
 439:     float x2 = x0 + framebufferVertexWidth;
 440:     if (aspect_ratio == AR_STRETCH) x2 = x0 + game_width;
 441:     float y2 = y0;
 442:     float u2 = 1.0f;
 443:     float v2 = v0;
 444:     // 3
 445:     float x3 = x2;
 446:     float y3 = y1;
 447:     float u3 = u2;
 448:     float v3 = v1;
 449: 
 450:     struct nvertex vertices[] = {
 451:         {x0, y0, 1.0f, 1.0f, 0xff000000, 0, u0, v0},
 452:         {x1, y1, 1.0f, 1.0f, 0xff000000, 0, u1, v1},
 453:         {x2, y2, 1.0f, 1.0f, 0xff000000, 0, u2, v2},
 454:         {x3, y3, 1.0f, 1.0f, 0xff000000, 0, u3, v3},
 455:     };
 456:     WORD indices[] = {
 457:         0, 1, 2,
 458:         1, 3, 2
 459:     };
 460: 
 461:     backendProgram = RendererProgram::POSTPROCESSING;
 462:     backendViewId++;
 463:     {
 464:         bool needsToDraw = internalState.bHasDrawBeenDone;
 465: 
 466:         if (internalState.bHasDrawBeenDone)
 467:             useTexture(
 468:                 bgfx::getTexture(backendFrameBuffer).idx
 469:             );
 470:         else
 471:             useTexture(0);
 472: 
 473:         setClearFlags(true, true);
 474: 
 475:         bindVertexBuffer(vertices, 0, 4);
 476:         bindIndexBuffer(indices, 6);
 477: 
 478:         setBlendMode(RendererBlendMode::BLEND_DISABLED);
 479:         setPrimitiveType();
 480: 
 481:         if (needsToDraw) draw();
 482: 
 483:         setBlendMode();
 484:     }
 485: };
 486: 
 487: void Renderer::printMatrix(char* name, float* mat)
 488: {
 489:     ffnx_trace("%s: 0 [%f, %f, %f, %f]\n", name, mat[0], mat[1], mat[2], mat[3]);
 490:     ffnx_trace("%s: 1 [%f, %f, %f, %f]\n", name, mat[4], mat[5], mat[6], mat[7]);
 491:     ffnx_trace("%s: 2 [%f, %f, %f, %f]\n", name, mat[8], mat[9], mat[10], mat[11]);
 492:     ffnx_trace("%s: 3 [%f, %f, %f, %f]\n", name, mat[12], mat[13], mat[14], mat[15]);
 493: };
 494: 
 495: bool Renderer::doesItFitInMemory(size_t size)
 496: {
 497:     if (size <= 0) ffnx_glitch("Unexpected texture size while checking if it fits in memory.\n");
 498: 
 499:     // We need to check this value as much as in real time as possible, to avoid possible crashes
 500:     GlobalMemoryStatusEx(&last_ram_state);
 501: 
 502:     return size < last_ram_state.ullAvailVirtual;
 503: }
 504: 
 505: void Renderer::recalcInternals()
 506: {
 507:     scalingFactor = internal_resolution_scale;
 508: 
 509:     viewWidth = window_size_x;
 510:     viewHeight = window_size_y;
 511: 
 512:     // aspect correction
 513:     switch(aspect_ratio){
 514:         case AR_ORIGINAL:
 515:             if (viewWidth * 3 != viewHeight * 4)
 516:             {
 517:                 if (viewHeight * 4 > viewWidth * 3)
 518:                 {
 519:                     viewOffsetY = viewHeight - (viewWidth * 3) / 4;
 520:                     viewHeight = (viewWidth * 3) / 4;
 521: 
 522:                     y_offset = viewOffsetY;
 523:                 }
 524:                 else if (viewWidth * 3 > viewHeight * 4)
 525:                 {
 526:                     viewOffsetX = (viewWidth - (viewHeight * 4) / 3) / 2;
 527:                     viewWidth = (viewHeight * 4) / 3;
 528: 
 529:                     x_offset = viewOffsetX;
 530:                 }
 531:             }
 532:             break;
 533:         case AR_WIDESCREEN_16X9:
 534:             if (viewWidth * 9 != viewHeight * 16)
 535:             {
 536:                 if (viewHeight * 16 > viewWidth * 9)
 537:                 {
 538:                     viewOffsetY = viewHeight - (viewWidth * 9) / 16;
 539:                     viewHeight = (viewWidth * 9) / 16;
 540: 
 541:                     y_offset = viewOffsetY;
 542:                 }
 543:                 else if (viewWidth * 9 > viewHeight * 16)
 544:                 {
 545:                     viewOffsetX = (viewWidth - (viewHeight * 16) / 9) / 2;
 546:                     viewWidth = (viewHeight * 16) / 9;
 547: 
 548:                     x_offset = viewOffsetX;
 549:                 }
 550:             }
 551:             break;
 552:         case AR_WIDESCREEN_16X10:
 553:             if (viewWidth * 10 != viewHeight * 16)
 554:             {
 555:                 if (viewHeight * 16 > viewWidth * 10)
 556:                 {
 557:                     viewOffsetY = viewHeight - (viewWidth * 10) / 16;
 558:                     viewHeight = (viewWidth * 10) / 16;
 559: 
 560:                     y_offset = viewOffsetY;
 561:                 }
 562:                 else if (viewWidth * 10 > viewHeight * 16)
 563:                 {
 564:                     viewOffsetX = (viewWidth - (viewHeight * 16) / 10) / 2;
 565:                     viewWidth = (viewHeight * 16) / 10;
 566: 
 567:                     x_offset = viewOffsetX;
 568:                 }
 569:             }
 570:             break;
 571:     }
 572: 
 573:     // If internal_resolution_scale from settings is less than one, calculate the closest fit for the output resolution, otherwise use the value directly
 574:     if (internal_resolution_scale < 1)
 575:     {
 576:         long scaleW = ::round(viewWidth / (float)game_width);
 577:         long scaleH = ::round(viewHeight / (float)game_height);
 578: 
 579:         if (scaleH > scaleW) scaleW = scaleH;
 580:         if (scaleW > internal_resolution_scale) scalingFactor = scaleW;
 581:         if (scalingFactor < 1) scalingFactor = 1;
 582:     }
 583: 
 584:     // Use the set or calculated scaling factor to determine the width and height of the framebuffer according to the original resolution
 585:     if(widescreen_enabled)
 586:     {
 587:         framebufferWidth = wide_game_width * scalingFactor;
 588:         framebufferHeight = wide_game_height * scalingFactor;
 589: 
 590:         framebufferVertexWidth = (viewWidth * wide_game_width) / window_size_x;
 591:         framebufferVertexOffsetX = (wide_game_width - framebufferVertexWidth) / 2;
 592:     }
 593:     else
 594:     {
 595:         framebufferWidth = game_width * scalingFactor;
 596:         framebufferHeight = game_height * scalingFactor;
 597: 
 598:         framebufferVertexWidth = (viewWidth * game_width) / window_size_x;
 599:         framebufferVertexOffsetX = (game_width - framebufferVertexWidth) / 2;
 600:     }
 601: 
 602:     // Let the user know about chosen resolutions
 603:     if (widescreen_enabled)
 604:         ffnx_info("Original resolution %ix%i, Scaling factor %ix, Internal resolution %ix%i, Output resolution %ix%i\n", wide_game_width, wide_game_height, scalingFactor, framebufferWidth, framebufferHeight, window_size_x, window_size_y);
 605:     else
 606:         ffnx_info("Original resolution %ix%i, Scaling factor %ix, Internal resolution %ix%i, Output resolution %ix%i\n", game_width, game_height, scalingFactor, framebufferWidth, framebufferHeight, window_size_x, window_size_y);
 607: }
 608: 
 609: void Renderer::calcBackendProjMatrix()
 610: {
 611:     // Used by the game
 612:     bx::mtxOrtho(
 613:         internalState.backendProjMatrix,
 614:         widescreen_enabled ? wide_viewport_x : 0.0f,
 615:         widescreen_enabled ? wide_viewport_width + wide_viewport_x : game_width,
 616:         widescreen_enabled ? wide_game_height : game_height,
 617:         0.0f,
 618:         getCaps()->homogeneousDepth ? -1.0f : 0.0f,
 619:         1.0f,
 620:         0.0,
 621:         getCaps()->homogeneousDepth
 622:     );
 623: 
 624:     // Used by postprocessing ( rendering the game framebuffer on screen)
 625:     bx::mtxOrtho(
 626:         internalState.postprocessingProjMatrix,
 627:         0.0f,
 628:         widescreen_enabled ? wide_game_width : game_width,
 629:         widescreen_enabled ? wide_game_height : game_height,
 630:         0.0f,
 631:         getCaps()->homogeneousDepth ? -1.0f : 0.0f,
 632:         1.0f,
 633:         0.0,
 634:         getCaps()->homogeneousDepth
 635:     );
 636: }
 637: 
 638: void Renderer::prepareFramebuffer()
 639: {
 640:     // If already existing, destroy
 641:     if (bgfx::isValid(backendFrameBuffer))
 642:         bgfx::destroy(backendFrameBuffer);
 643: 
 644:     uint64_t fbFlags = BGFX_TEXTURE_RT;
 645: 
 646:     if (enable_antialiasing > 0)
 647:     {
 648:         if (enable_antialiasing <= 2)
 649:             fbFlags = BGFX_TEXTURE_RT_MSAA_X2;
 650:         else if (enable_antialiasing <= 4)
 651:             fbFlags = BGFX_TEXTURE_RT_MSAA_X4;
 652:         else if (enable_antialiasing <= 8)
 653:             fbFlags = BGFX_TEXTURE_RT_MSAA_X8;
 654:         else if (enable_antialiasing <= 16)
 655:             fbFlags = BGFX_TEXTURE_RT_MSAA_X16;
 656:     }
 657: 
 658:     backendFrameBufferRT[0] = bgfx::createTexture2D(
 659:         framebufferWidth,
 660:         framebufferHeight,
 661:         false,
 662:         1,
 663:         internalState.bIsHDR ? bgfx::TextureFormat::RGB10A2 : bgfx::TextureFormat::RGBA16,
 664:         fbFlags | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP
 665:     );
 666: 
 667:     backendFrameBufferRT[1] = bgfx::createTexture2D(
 668:         framebufferWidth,
 669:         framebufferHeight,
 670:         false,
 671:         1,
 672:         bgfx::TextureFormat::D32F,
 673:         fbFlags | BGFX_TEXTURE_RT_WRITE_ONLY
 674:     );
 675: 
 676:     backendFrameBuffer = bgfx::createFrameBuffer(
 677:         backendFrameBufferRT.size(),
 678:         backendFrameBufferRT.data(),
 679:         true
 680:     );
 681: }
 682: 
 683: void Renderer::bindTextures()
 684: {
 685:     if (!internalState.bTexturesBound)
 686:     {
 687:         for (uint32_t idx = RendererTextureSlot::TEX_Y; idx < RendererTextureSlot::COUNT; idx++)
 688:         {
 689:             bgfx::TextureHandle handle = internalState.texHandlers[idx];
 690: 
 691:             if (bgfx::isValid(handle))
 692:             {
 693:                 uint32_t flags = 0;
 694: 
 695:                 switch(idx)
 696:                 {
 697:                     case RendererTextureSlot::TEX_Y:
 698:                     case RendererTextureSlot::TEX_U:
 699:                     case RendererTextureSlot::TEX_V:
 700:                         if (!internalState.bIsMovie && idx > RendererTextureSlot::TEX_Y) handle = BGFX_INVALID_HANDLE;
 701: 
 702:                         if (backendProgram == RendererProgram::POSTPROCESSING)
 703:                         {
 704:                             flags = BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP | BGFX_SAMPLER_MIN_ANISOTROPIC | BGFX_SAMPLER_MAG_ANISOTROPIC;
 705:                         }
 706:                         else
 707:                         {
 708:                             if (internalState.bDoMirrorTextureWrap) flags |= BGFX_SAMPLER_U_MIRROR | BGFX_SAMPLER_V_MIRROR | BGFX_SAMPLER_W_CLAMP;
 709: 
 710:                             if (internalState.bIsMovie) flags |= BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP;
 711: 
 712:                             if (!internalState.bDoTextureFiltering || !internalState.bIsExternalTexture) flags |= BGFX_SAMPLER_MIN_POINT | BGFX_SAMPLER_MAG_POINT | BGFX_SAMPLER_MIP_POINT;
 713:                         }
 714:                         break;
 715:                     case RendererTextureSlot::TEX_S:
 716:                     case RendererTextureSlot::TEX_D:
 717:                         // Specially handled, move on
 718:                         continue;
 719:                     case RendererTextureSlot::TEX_G_LUT:
 720:                         flags |= BGFX_SAMPLER_POINT | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP;
 721:                         break;
 722:                     default:
 723:                         break;
 724:                 }
 725: 
 726:                 if (flags == 0) flags = UINT32_MAX;
 727: 
 728:                 bgfx::setTexture(idx, bgfxTexUniformHandles[idx], handle, flags);
 729:             }
 730:         }
 731: 
 732:         internalState.bTexturesBound = true;
 733:     }
 734: }
 735: 
 736: void Renderer::AssignGamutLUT()
 737: {
 738: 	// Since HDR uses the super-wide rec2020 gamut, it doesn't need a gamut (compression) mapping algorithm,
 739: 	// so it would be better to use the old matrix-based conversions instead of the LUTs that embody a GMA.
 740: 	// That's what we do in post-processing.
 741: 	// However, in two cases we have two serial conversions happening:
 742: 	// (1) Movies where the movie's gamut isn't the same as the selected gamut mode
 743: 	// (2) The implemented but as-yet unused internalState.bIsOverrideGamut
 744: 	// What I'd *like* to do is to do matrix-based conversions for the first round,
 745: 	// then *tolerate* the out-of-bounds values until post processing,
 746: 	// then the final conversion to rec2020 will bring those values back in bounds.
 747: 	// Unfortunately, I don't think the lighting code could tolerate out-of-bounds values.
 748: 	// (Also, the srgb gamma function would need to be changed to avoid calling pow() on a negative input.)
 749: 	// So, for now I'm using the LUTs for the first step for both SDR and HDR,
 750: 	// and I'm putting this comment here in case we ever figure out how to tolerate out-of-bounds values
 751: 	//if (internalState.bIsHDR) return;
 752: 
 753: 
 754: 	// NTSCJ mode post-processing
 755: 	if ((backendProgram == RendererProgram::POSTPROCESSING) && (internalState.bIsOverallColorGamut == COLORGAMUT_NTSCJ)){
 756: 		LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB); // load LUT if not already loaded
 757: 		useTexture(GLUTHandleNTSCJtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
 758: 	}
 759: 	// Movies and override flag
 760: 	// Note: Override flag currently does nothing because it's never set to true anywhere
 761: 	// The intent is to eventually have a way to say "I want to display a NTSCJ asset in sRGB mode" or "I want to display a sRGB asset in NTSCJ mode."
 762: 	else {
 763: 		if (internalState.bIsOverallColorGamut == COLORGAMUT_SRGB){
 764: 			if ((internalState.bIsMovieColorGamut == COLORGAMUT_NTSCJ) || internalState.bIsOverrideGamut){
 765: 				LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB); // load LUT if not already loaded
 766: 				useTexture(GLUTHandleNTSCJtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
 767: 			}
 768: 			else if (internalState.bIsMovieColorGamut == COLORGAMUT_SMPTEC){
 769: 				LoadGamutLUT(INDEX_LUT_SMPTEC_TO_SRGB); // load LUT if not already loaded
 770: 				useTexture(GLUTHandleSMPTECtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
 771: 			}
 772: 			else if (internalState.bIsMovieColorGamut == COLORGAMUT_EBU){
 773: 				LoadGamutLUT(INDEX_LUT_EBU_TO_SRGB); // load LUT if not already loaded
 774: 				useTexture(GLUTHandleEBUtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
 775: 			}
 776: 		}
 777: 		else if (internalState.bIsOverallColorGamut == COLORGAMUT_NTSCJ){
 778: 			// SDR should use the "inverse" conversions created with gamutthingy's "expand" flag, to compensate for the compression later,
 779: 			// but HDR should not because the conversion to rec2020 doesn't involve compression
 780: 			// This isn't exactly kosher for the SMPTEC and EBU cases, but they're close enough to sRGB
 781: 			// that doing the expansion probably gives closer to accurate results than not doing it.
 782: 			if (internalState.bIsHDR){
 783: 				if ((internalState.bIsMovieColorGamut == COLORGAMUT_SRGB) || internalState.bIsOverrideGamut){
 784: 					LoadGamutLUT(INDEX_LUT_SRGB_TO_NTSCJ); // load LUT if not already loaded
 785: 					useTexture(GLUTHandleSRGBtoNTSCJ.idx, RendererTextureSlot::TEX_G_LUT);
 786: 				}
 787: 				else if (internalState.bIsMovieColorGamut == COLORGAMUT_SMPTEC){
 788: 					LoadGamutLUT(INDEX_LUT_SMPTEC_TO_NTSCJ); // load LUT if not already loaded
 789: 					useTexture(GLUTHandleSMPTECtoNTSCJ.idx, RendererTextureSlot::TEX_G_LUT);
 790: 				}
 791: 				else if (internalState.bIsMovieColorGamut == COLORGAMUT_EBU){
 792: 					LoadGamutLUT(INDEX_LUT_EBU_TO_NTSCJ); // load LUT if not already loaded
 793: 					useTexture(GLUTHandleEBUtoNTSCJ.idx, RendererTextureSlot::TEX_G_LUT);
 794: 				}
 795: 			}
 796: 			else{
 797: 				if ((internalState.bIsMovieColorGamut == COLORGAMUT_SRGB) || internalState.bIsOverrideGamut){
 798: 					LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_SRGB); // load LUT if not already loaded
 799: 					useTexture(GLUTHandleInverseNTSCJtoSRGB.idx, RendererTextureSlot::TEX_G_LUT);
 800: 				}
 801: 				else if (internalState.bIsMovieColorGamut == COLORGAMUT_SMPTEC){
 802: 					LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_SMPTEC); // load LUT if not already loaded
 803: 					useTexture(GLUTHandleInverseNTSCJtoSMPTEC.idx, RendererTextureSlot::TEX_G_LUT);
 804: 				}
 805: 				else if (internalState.bIsMovieColorGamut == COLORGAMUT_EBU){
 806: 					LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_EBU); // load LUT if not already loaded
 807: 					useTexture(GLUTHandleInverseNTSCJtoEBU.idx, RendererTextureSlot::TEX_G_LUT);
 808: 				}
 809: 			}
 810: 		}
 811: 
 812: 	}
 813: 	return;
 814: }
 815: 
 816: // PUBLIC
 817: 
 818: void Renderer::init()
 819: {
 820:     recalcInternals();
 821: 
 822:     // Init renderer
 823:     bgfxInit.platformData.nwh = gameHwnd;
 824:     bgfxInit.type = getUserChosenRenderer();
 825:     bgfxInit.resolution.width = window_size_x;
 826:     bgfxInit.resolution.height = window_size_y;
 827: 
 828:     if (enable_anisotropic)
 829:         bgfxInit.resolution.reset |= BGFX_RESET_MAXANISOTROPY;
 830: 
 831:     if (enable_vsync)
 832:         bgfxInit.resolution.reset |= BGFX_RESET_VSYNC;
 833: 
 834:     bgfxInit.debug = renderer_debug;
 835:     bgfxInit.callback = &bgfxCallbacks;
 836: 
 837:     if (!bgfx::init(bgfxInit)) exit(1);
 838: 
 839:     // If HDR support is present, make use of it
 840:     if (getCaps()->supported & BGFX_CAPS_HDR10)
 841:     {
 842:         internalState.bIsHDR = true;
 843:         ffnx_info("HDR monitor detected. HDR enabled.\n");
 844: 
 845:         bgfxInit.resolution.reset |= BGFX_RESET_HDR10;
 846:         bgfxInit.resolution.format = bgfx::TextureFormat::RGB10A2;
 847: 
 848:         if (hdr_max_nits <= 0) {
 849:             ffnx_info("Attempting to autodetect SDR white level for HDR...\n");
 850:             // The goal here is to autodetect "the brightness level that SDR 'white' is rendered at within an HDR monitor."
 851:             // See: https://www.pyromuffin.com/2018/07/how-to-do-nothing-in-hdr.html
 852:             // See also: https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-displayconfig_sdr_white_level
 853:             // Autodetection may fail on some monitor models.
 854:             // Autodetection WILL fail on Windows older than Win10 Fall Creators Update (Version 1709) and WILL fail on WINE (at least as of WINE 7.22)
 855: 
 856:             // First, enumerate the DISPLAYCONFIG_PATH_INFO for all monitors.
 857:             // Code borrowed from Microsoft's example: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-querydisplayconfig#examples
 858:             std::vector<DISPLAYCONFIG_PATH_INFO> paths;
 859:             std::vector<DISPLAYCONFIG_MODE_INFO> modes;
 860:             UINT32 flags = QDC_ONLY_ACTIVE_PATHS; // | QDC_VIRTUAL_MODE_AWARE; // MS's example is wrong. Causes bad param error on WINE. See: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdisplayconfigbuffersizes
 861:             LONG monresult = ERROR_SUCCESS;
 862:             bool gotbuffersizes = false;
 863:             bool usedefaultnits = true;
 864:             do {
 865:                 // Determine how many path and mode structures to allocate
 866:                 UINT32 pathCount, modeCount;
 867:                 monresult = GetDisplayConfigBufferSizes(flags, &pathCount, &modeCount);
 868: 
 869:                 if (monresult != ERROR_SUCCESS){
 870:                     if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Cannot enumerate monitors. GetDisplayConfigBufferSizes() failed with error code %i.\n", monresult);
 871:                     break;
 872:                 }
 873:                 gotbuffersizes = true;
 874: 
 875:                 // Allocate the path and mode arrays
 876:                 paths.resize(pathCount);
 877:                 modes.resize(modeCount);
 878: 
 879:                 // Get all active paths and their modes
 880:                 monresult = QueryDisplayConfig(flags, &pathCount, paths.data(), &modeCount, modes.data(), nullptr);
 881: 
 882:                 // The function may have returned fewer paths/modes than estimated
 883:                 paths.resize(pathCount);
 884:                 modes.resize(modeCount);
 885: 
 886:                 // It's possible that between the call to GetDisplayConfigBufferSizes and QueryDisplayConfig
 887:                 // that the display state changed, so loop on the case of ERROR_INSUFFICIENT_BUFFER.
 888:             } while (monresult == ERROR_INSUFFICIENT_BUFFER);
 889: 
 890:             if (monresult != ERROR_SUCCESS){
 891:                 if (gotbuffersizes){
 892:                     if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Cannot enumerate monitors. QueryDisplayConfig() failed with error code %i.\n", monresult);
 893:                 }
 894:             }
 895:             else {
 896:                 // loop over monitors and take the SDR white level of the first HDR monitor we find.
 897:                 int pathidx = -1;
 898:                 for (auto& path : paths) {
 899:                     pathidx++;
 900: 
 901:                     // Check if this monitor is HDR capable and HDR enabled
 902:                     // Borrowed from these two examples:
 903:                     // https://forum.doom9.org/showthread.php?s=33dc0ad84a0997fce56710b3959e0415&p=1897630#post1897630
 904:                     // https://stackoverflow.com/a/66160049
 905:                     DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO getColorInfo = {};
 906:                     getColorInfo.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;
 907:                     getColorInfo.header.id = path.targetInfo.id;
 908:                     getColorInfo.header.adapterId = path.targetInfo.adapterId;
 909:                     getColorInfo.header.size = sizeof(getColorInfo);
 910:                     monresult = DisplayConfigGetDeviceInfo(&getColorInfo.header);
 911:                     if (monresult != ERROR_SUCCESS){
 912:                         if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR skipping monitor #%i because DisplayConfigGetDeviceInfo() DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO check failed with error code %i.\n", pathidx, monresult);
 913:                         continue;
 914:                     }
 915:                     if (!getColorInfo.advancedColorSupported || !getColorInfo.advancedColorEnabled){
 916:                         if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR determined that monitor #%i is not an HDR monitor or HDR is not enabled. Checking next monitor (if any)...\n", pathidx);
 917:                         continue;
 918:                     }
 919: 
 920:                     // If we found an HDR monitor, then query its SDR white level
 921:                     // Code borrowed from Google Chrome: https://chromium.googlesource.com/chromium/src/+/c71f15ab1ace78c7efeeeda9f8552b4af9db2877/ui/display/win/screen_win.cc#112
 922:                     DISPLAYCONFIG_SDR_WHITE_LEVEL white_level = {};
 923:                     white_level.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL;
 924:                     white_level.header.id = path.targetInfo.id;
 925:                     white_level.header.adapterId = path.targetInfo.adapterId;
 926:                     white_level.header.size = sizeof(white_level);
 927:                     monresult = DisplayConfigGetDeviceInfo(&white_level.header);
 928:                     if (monresult != ERROR_SUCCESS){
 929:                         if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Monitor #%i appears to be an HDR monitor, but DisplayConfigGetDeviceInfo() DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL check failed with error code %i.\n", pathidx, monresult);
 930:                         break;
 931:                     }
 932:                     if (white_level.SDRWhiteLevel == 0){
 933:                         if (trace_all || trace_renderer) ffnx_trace("Renderer::init(): Autodetection of SDR white level for HDR failed. Monitor #%i appears to be an HDR monitor, but SDR white level is reported as 0.\n", pathidx);
 934:                         break;
 935:                     }
 936:                     // SDRWhiteLevel is stored in units of 2/25 nits (but with steps of 80 nits), because Microsoft.
 937:                     // See: https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-displayconfig_sdr_white_level
 938:                     hdr_max_nits = white_level.SDRWhiteLevel * 80.0 / 1000.0;
 939:                     ffnx_info("SDR white level for HDR successfully autodetected as %i nits.\n", (int)hdr_max_nits);
 940:                     usedefaultnits = false;
 941:                     break;
 942: 
 943:                 } // end for (auto& path : paths)
 944: 
 945:             } // end else (monresult == ERROR_SUCCESS)
 946:             if (usedefaultnits){
 947:                 ffnx_info("Autodetection of SDR white level for HDR failed. Assuming default value of 200 nits.\n");
 948:                 // Google thinks 200 nits is a good default. Who are we to argue?
 949:                 hdr_max_nits = 200.0;
 950:             }
 951:         } // end if  (hdr_max_nits <= 0)
 952: 
 953:         bgfx::reset(window_size_x, window_size_y, bgfxInit.resolution.reset, bgfxInit.resolution.format);
 954:     } //end if HDR
 955: 
 956:     internalState.texHandlers.resize(RendererTextureSlot::COUNT, BGFX_INVALID_HANDLE);
 957: 
 958:     updateRendererShaderPaths();
 959: 
 960:     calcBackendProjMatrix();
 961: 
 962:     prepareFramebuffer();
 963: 
 964:     prepareShadowMap();
 965: 
 966:     // Create Program
 967:     backendProgramHandles[RendererProgram::POSTPROCESSING] = bgfx::createProgram(
 968:         getShader(vertexPostPath.c_str()),
 969:         getShader(fragmentPostPath.c_str()),
 970:         true
 971:     );
 972: 
 973:     backendProgramHandles[RendererProgram::FLAT] = bgfx::createProgram(
 974:         getShader(vertexPathFlat.c_str()),
 975:         getShader(fragmentPathFlat.c_str()),
 976:         true
 977:     );
 978: 
 979:     backendProgramHandles[RendererProgram::SMOOTH] = bgfx::createProgram(
 980:         getShader(vertexPathSmooth.c_str()),
 981:         getShader(fragmentPathSmooth.c_str()),
 982:         true
 983:     );
 984: 
 985:     backendProgramHandles[RendererProgram::LIGHTING_FLAT] = bgfx::createProgram(
 986:         getShader(vertexLightingPathFlat.c_str()),
 987:         getShader(fragmentLightingPathFlat.c_str()),
 988:         true
 989:     );
 990: 
 991:     backendProgramHandles[RendererProgram::LIGHTING_SMOOTH] = bgfx::createProgram(
 992:         getShader(vertexLightingPathSmooth.c_str()),
 993:         getShader(fragmentLightingPathSmooth.c_str()),
 994:         true
 995:     );
 996: 
 997:     backendProgramHandles[RendererProgram::FIELD_SHADOW] = bgfx::createProgram(
 998:         getShader(vertexFieldShadowPath.c_str()),
 999:         getShader(fragmentFieldShadowPath.c_str()),
1000:         true
1001:     );
1002: 
1003:     backendProgramHandles[RendererProgram::SHADOW_MAP] = bgfx::createProgram(
1004:         getShader(vertexShadowMapPath.c_str()),
1005:         getShader(fragmentShadowMapPath.c_str()),
1006:         true
1007:     );
1008: 
1009:     backendProgramHandles[RendererProgram::BLIT] = bgfx::createProgram(
1010:         getShader(vertexBlitPath.c_str()),
1011:         getShader(fragmentBlitPath.c_str()),
1012:         true
1013:     );
1014: 
1015:     vertexLayout
1016:         .begin()
1017:         .add(bgfx::Attrib::Position, 4, bgfx::AttribType::Float)
1018:         .add(bgfx::Attrib::Color0, 4, bgfx::AttribType::Uint8, true)
1019:         .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float)
1020:         .add(bgfx::Attrib::Normal, 3, bgfx::AttribType::Float)
1021:         .end();
1022: 
1023:     bgfx::setDebug(BGFX_DEBUG_TEXT);
1024: 
1025:     bgfx::frame();
1026: 
1027:     if (enable_devtools)
1028:     {
1029:         backendProgramHandles[RendererProgram::OVERLAY] = bgfx::createProgram(
1030:             getShader(vertexOverlayPath.c_str()),
1031:             getShader(fragmentOverlayPath.c_str()),
1032:             true
1033:         );
1034:         overlay.init(backendProgramHandles[RendererProgram::OVERLAY], window_size_x, window_size_y);
1035:     }
1036: 
1037:     bgfxUniformHandles[RendererUniform::VS_FLAGS] = createUniform("VSFlags", bgfx::UniformType::Vec4);
1038:     bgfxUniformHandles[RendererUniform::FS_ALPHA_FLAGS] = createUniform("FSAlphaFlags", bgfx::UniformType::Vec4);
1039:     bgfxUniformHandles[RendererUniform::FS_MISC_FLAGS] = createUniform("FSMiscFlags", bgfx::UniformType::Vec4);
1040:     bgfxUniformHandles[RendererUniform::FS_HDR_FLAGS] = createUniform("FSHDRFlags", bgfx::UniformType::Vec4);
1041:     bgfxUniformHandles[RendererUniform::FS_TEX_FLAGS] = createUniform("FSTexFlags", bgfx::UniformType::Vec4);
1042:     bgfxUniformHandles[RendererUniform::FS_MOVIE_FLAGS] = createUniform("FSMovieFlags", bgfx::UniformType::Vec4);
1043:     bgfxUniformHandles[RendererUniform::WM_FLAGS] = createUniform("WMFlags", bgfx::UniformType::Vec4);
1044:     bgfxUniformHandles[RendererUniform::TIME_COLOR] = createUniform("TimeColor", bgfx::UniformType::Vec4);
1045:     bgfxUniformHandles[RendererUniform::TIME_DATA] = createUniform("TimeData", bgfx::UniformType::Vec4);
1046: 
1047:     bgfxUniformHandles[RendererUniform::D3D_VIEWPORT] = createUniform("d3dViewport", bgfx::UniformType::Mat4);
1048:     bgfxUniformHandles[RendererUniform::D3D_PROJECTION] = createUniform("d3dProjection", bgfx::UniformType::Mat4);
1049:     bgfxUniformHandles[RendererUniform::WORLD_VIEW] = createUniform("worldView", bgfx::UniformType::Mat4);
1050:     bgfxUniformHandles[RendererUniform::NORMAL_MATRIX] = createUniform("normalMatrix", bgfx::UniformType::Mat4);
1051:     bgfxUniformHandles[RendererUniform::VIEW_MATRIX] = createUniform("viewMatrix", bgfx::UniformType::Mat4);
1052:     bgfxUniformHandles[RendererUniform::INV_VIEW_MATRIX] = createUniform("invViewMatrix", bgfx::UniformType::Mat4);
1053: 
1054:     bgfxUniformHandles[RendererUniform::LIGHTING_SETTINGS] = createUniform("lightingSettings", bgfx::UniformType::Vec4);
1055:     bgfxUniformHandles[RendererUniform::LIGHT_DIR_DATA] = createUniform("lightDirData", bgfx::UniformType::Vec4);
1056:     bgfxUniformHandles[RendererUniform::LIGHT_DATA] = createUniform("lightData", bgfx::UniformType::Vec4);
1057:     bgfxUniformHandles[RendererUniform::AMBIENT_LIGHT_DATA] = createUniform("ambientLightData", bgfx::UniformType::Vec4);
1058:     bgfxUniformHandles[RendererUniform::SHADOW_DATA] = createUniform("shadowData", bgfx::UniformType::Vec4);
1059:     bgfxUniformHandles[RendererUniform::FIELD_SHADOW_DATA] = createUniform("fieldShadowData", bgfx::UniformType::Vec4);
1060:     bgfxUniformHandles[RendererUniform::MATERIAL_DATA] = createUniform("materialData", bgfx::UniformType::Vec4);
1061:     bgfxUniformHandles[RendererUniform::MATERIAL_SCALE_DATA] = createUniform("materialScaleData", bgfx::UniformType::Vec4);
1062:     bgfxUniformHandles[RendererUniform::LIGHTING_DEBUG_DATA] = createUniform("lightingDebugData", bgfx::UniformType::Vec4);
1063:     bgfxUniformHandles[RendererUniform::IBL_DATA] = createUniform("iblData", bgfx::UniformType::Vec4);
1064: 
1065:     bgfxUniformHandles[RendererUniform::LIGHT_VIEW_PROJ_MATRIX] = createUniform("lightViewProjMatrix", bgfx::UniformType::Mat4);
1066:     bgfxUniformHandles[RendererUniform::LIGHT_VIEW_PROJ_TEX_MATRIX] = createUniform("lightViewProjTexMatrix", bgfx::UniformType::Mat4);
1067:     bgfxUniformHandles[RendererUniform::LIGHT_INV_VIEW_PROJ_TEX_MATRIX] = createUniform("lightInvViewProjTexMatrix", bgfx::UniformType::Mat4);
1068:     bgfxUniformHandles[RendererUniform::VIEW_OFFSET_MATRIX] = createUniform("viewOffsetMatrix", bgfx::UniformType::Mat4);
1069:     bgfxUniformHandles[RendererUniform::INV_VIEW_OFFSET_MATRIX] = createUniform("invViewOffsetMatrix", bgfx::UniformType::Mat4);
1070: 
1071:     bgfxUniformHandles[RendererUniform::GAME_LIGHTING_FLAGS] = createUniform("gameLightingFlags", bgfx::UniformType::Vec4);
1072:     bgfxUniformHandles[RendererUniform::GAME_GLOBAL_LIGHT_COLOR] = createUniform("gameGlobalLightColor", bgfx::UniformType::Vec4);
1073:     bgfxUniformHandles[RendererUniform::GAME_LIGHT_COLOR1] = createUniform("gameLightColor1", bgfx::UniformType::Vec4);
1074:     bgfxUniformHandles[RendererUniform::GAME_LIGHT_COLOR2] = createUniform("gameLightColor2", bgfx::UniformType::Vec4);
1075:     bgfxUniformHandles[RendererUniform::GAME_LIGHT_COLOR3] = createUniform("gameLightColor3", bgfx::UniformType::Vec4);
1076:     bgfxUniformHandles[RendererUniform::GAME_LIGHT_DIR1] = createUniform("gameLightDir1", bgfx::UniformType::Vec4);
1077:     bgfxUniformHandles[RendererUniform::GAME_LIGHT_DIR2] = createUniform("gameLightDir2", bgfx::UniformType::Vec4);
1078:     bgfxUniformHandles[RendererUniform::GAME_LIGHT_DIR3] = createUniform("gameLightDir3", bgfx::UniformType::Vec4);
1079:     bgfxUniformHandles[RendererUniform::GAME_SCRIPTED_LIGHT_COLOR] = createUniform("gameScriptedLightColor", bgfx::UniformType::Vec4);
1080: 
1081:     for(int i = 0; i < RendererTextureSlot::COUNT; ++i)
1082:     {
1083:         bgfxTexUniformHandles[i] = createUniform("tex_" + std::to_string(i), bgfx::UniformType::Sampler);
1084:     }
1085: 
1086:     // Set defaults
1087:     show();
1088: };
1089: 
1090: void Renderer::reset()
1091: {
1092:     recalcInternals();
1093: 
1094:     calcBackendProjMatrix();
1095: 
1096:     prepareFramebuffer();
1097: 
1098:     if(!ff8 && enable_lighting) prepareShadowMap();
1099: 
1100:     bgfx::reset(window_size_x, window_size_y, bgfxInit.resolution.reset, bgfxInit.resolution.format);
1101: }
1102: 
1103: #define FFNX_LOGO_PATH ".logo/logo_nobg.png"
1104: 
1105: void Renderer::prepareFFNxLogo()
1106: {
1107:     if (bgfx::isValid(FFNxLogoHandle))
1108:         bgfx::destroy(FFNxLogoHandle);
1109: 
1110:     auto fs = cmrc::FFNx::get_filesystem();
1111:     auto logo = fs.open(FFNX_LOGO_PATH);
1112: 
1113:     uint32_t width, height, mipCount = 0;
1114:     FFNxLogoHandle = createTextureHandle(&logo, FFNX_LOGO_PATH, &width, &height, &mipCount, true);
1115:     if (!FFNxLogoHandle.idx) FFNxLogoHandle = BGFX_INVALID_HANDLE;
1116: }
1117: 
1118: void Renderer::prepareShadowMap()
1119: {
1120:     if (bgfx::isValid(shadowMapFrameBuffer))
1121:         bgfx::destroy(shadowMapFrameBuffer);
1122: 
1123:     auto shadowMapResolution = lighting.getShadowMapResolution();
1124:     shadowMapTexture = bgfx::createTexture2D(
1125:         shadowMapResolution,
1126:         shadowMapResolution,
1127:         false,
1128:         1,
1129:         bgfx::TextureFormat::D32F,
1130:         BGFX_TEXTURE_RT | BGFX_SAMPLER_COMPARE_LEQUAL | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP
1131:     );
1132: 
1133:     shadowMapFrameBuffer = bgfx::createFrameBuffer(
1134:         1,
1135:         &shadowMapTexture,
1136:         true
1137:     );
1138: }
1139: 
1140: void Renderer::prepareSpecularIbl(char* fullpath)
1141: {
1142:     if (bgfx::isValid(specularIblTexture))
1143:         bgfx::destroy(specularIblTexture);
1144: 
1145:     uint32_t width, height, mipCount = 0;
1146:     specularIblTexture = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1147:     if (!specularIblTexture.idx) specularIblTexture = BGFX_INVALID_HANDLE;
1148:     lighting.setIblMipCount(mipCount);
1149: }
1150: 
1151: void Renderer::prepareDiffuseIbl(char* fullpath)
1152: {
1153:     if (bgfx::isValid(diffuseIblTexture))
1154:         bgfx::destroy(diffuseIblTexture);
1155: 
1156:     uint32_t width, height, mipCount = 0;
1157:     diffuseIblTexture = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1158:     if (!diffuseIblTexture.idx) diffuseIblTexture = BGFX_INVALID_HANDLE;
1159: }
1160: 
1161: void Renderer::prepareEnvBrdf()
1162: {
1163:     static char fullpath[MAX_PATH];
1164: 
1165:     if (bgfx::isValid(envBrdfTexture))
1166:         bgfx::destroy(envBrdfTexture);
1167: 
1168:     sprintf(fullpath, "%s/%s/ibl/envBrdf.dds", basedir, external_lighting_path.c_str());
1169: 
1170:     uint32_t width, height, mipCount = 0;
1171:     envBrdfTexture = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1172:     if (!envBrdfTexture.idx) envBrdfTexture = BGFX_INVALID_HANDLE;
1173: }
1174: 
1175: void Renderer::prepareGamutLUTs()
1176: {
1177: 
1178: 	// flush everything (they should have all initialized to BGFX_INVALID_HANDLE, but let's be careful)
1179: 	if (bgfx::isValid(GLUTHandleNTSCJtoSRGB))
1180: 		bgfx::destroy(GLUTHandleNTSCJtoSRGB);
1181: 	if (bgfx::isValid(GLUTHandleSMPTECtoSRGB))
1182: 		bgfx::destroy(GLUTHandleSMPTECtoSRGB);
1183: 	if (bgfx::isValid(GLUTHandleEBUtoSRGB))
1184: 		bgfx::destroy(GLUTHandleEBUtoSRGB);
1185: 	if (bgfx::isValid(GLUTHandleInverseNTSCJtoSRGB))
1186: 		bgfx::destroy(GLUTHandleInverseNTSCJtoSRGB);
1187: 	if (bgfx::isValid(GLUTHandleInverseNTSCJtoSMPTEC))
1188: 		bgfx::destroy(GLUTHandleInverseNTSCJtoSMPTEC);
1189: 	if (bgfx::isValid(GLUTHandleInverseNTSCJtoEBU))
1190: 		bgfx::destroy(GLUTHandleInverseNTSCJtoEBU);
1191: 	if (bgfx::isValid(GLUTHandleSRGBtoNTSCJ))
1192: 		bgfx::destroy(GLUTHandleSRGBtoNTSCJ);
1193: 	if (bgfx::isValid(GLUTHandleSMPTECtoNTSCJ))
1194: 		bgfx::destroy(GLUTHandleSMPTECtoNTSCJ);
1195: 	if (bgfx::isValid(GLUTHandleEBUtoNTSCJ))
1196: 		bgfx::destroy(GLUTHandleEBUtoNTSCJ);
1197: 
1198: 	// load only the LUTs we are likely to need
1199: 	// consult the global setting so we don't get tripped up by renderer state changing to accomodate the FFNx logo
1200: 	if (enable_ntscj_gamut_mode){
1201: 		if (internalState.bIsHDR){
1202: 			// Final NTSC-J to rec2020 conversion will be handled by matrix math in the shader (no gamut compression mapping needed)
1203: 			// We will probably have some sRGB videos that must go sRGB -> NTSC-J -> rec2020.
1204: 			// Use the compress-only (non "inverse") LUT because the final step for HDR won't invert expansions
1205: 			LoadGamutLUT(INDEX_LUT_SRGB_TO_NTSCJ);
1206: 		}
1207: 		// SDR
1208: 		else {
1209: 			// Final NTSC-J to sRGB conversion needs gamut compression mapping LUT
1210: 			LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB);
1211: 			// We will probably have some sRGB videos that must go sRGB -> NTSC-J -> sRGB.
1212: 			// Use expanding "inverse" LUT to counteract the compression in the final conversion.
1213: 			LoadGamutLUT(INDEX_LUT_INVERSE_NTSCJ_TO_SRGB);
1214: 		}
1215: 	}
1216: 	// Most FF7 movies will need NTSC-J to sRGB conversion for sRGB mode
1217: 	// (FF8 Steam edition movies were already converted)
1218: 	else if(!ff8){
1219: 		LoadGamutLUT(INDEX_LUT_NTSCJ_TO_SRGB);
1220: 	}
1221: 
1222: 	// Any other LUTs we end up needing will be lazy loaded by AssignGamutLUT()
1223: 
1224: 	return;
1225: }
1226: 
1227: void Renderer::LoadGamutLUT(GamutLUTIndexType whichLUT)
1228: {
1229: 
1230: 	static char fullpath[MAX_PATH];
1231: 	uint32_t width = 0;
1232: 	uint32_t height = 0;
1233: 	uint32_t mipCount = 0;
1234: 
1235: 	// Note: It's important that the final parameter to createTextureHandle() -- isSrgb -- is false.
1236: 	// Otherwise the sRGB gamma function will be applied to convert sRGB to linear RGB.
1237: 	// But we don't want that because these LUTs are already in linear RGB.
1238: 
1239: 	switch (whichLUT){
1240: 		case INDEX_LUT_NTSCJ_TO_SRGB:
1241: 			if (!bgfx::isValid(GLUTHandleNTSCJtoSRGB)){
1242: 				sprintf(fullpath, "%s/shaders/glut_ntscj_to_srgb.png", basedir);
1243: 				GLUTHandleNTSCJtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1244: 				if (!GLUTHandleNTSCJtoSRGB.idx) GLUTHandleNTSCJtoSRGB = BGFX_INVALID_HANDLE;
1245: 			}
1246: 			break;
1247: 		case INDEX_LUT_SMPTEC_TO_SRGB:
1248: 			if (!bgfx::isValid(GLUTHandleSMPTECtoSRGB)){
1249: 				sprintf(fullpath, "%s/shaders/glut_smptec_to_srgb.png", basedir);
1250: 				GLUTHandleSMPTECtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1251: 				if (!GLUTHandleSMPTECtoSRGB.idx) GLUTHandleSMPTECtoSRGB = BGFX_INVALID_HANDLE;
1252: 			}
1253: 			break;
1254: 		case INDEX_LUT_EBU_TO_SRGB:
1255: 			if (!bgfx::isValid(GLUTHandleEBUtoSRGB)){
1256: 				sprintf(fullpath, "%s/shaders/glut_ebu_to_srgb.png", basedir);
1257: 				GLUTHandleEBUtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1258: 				if (!GLUTHandleEBUtoSRGB.idx) GLUTHandleEBUtoSRGB = BGFX_INVALID_HANDLE;
1259: 			}
1260: 			break;
1261: 		case INDEX_LUT_INVERSE_NTSCJ_TO_SRGB:
1262: 			if (!bgfx::isValid(GLUTHandleInverseNTSCJtoSRGB)){
1263: 				sprintf(fullpath, "%s/shaders/glut_inverse_ntscj_to_srgb.png", basedir);
1264: 				GLUTHandleInverseNTSCJtoSRGB = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1265: 				if (!GLUTHandleInverseNTSCJtoSRGB.idx) GLUTHandleInverseNTSCJtoSRGB = BGFX_INVALID_HANDLE;
1266: 			}
1267: 			break;
1268: 		case INDEX_LUT_INVERSE_NTSCJ_TO_SMPTEC:
1269: 			if (!bgfx::isValid(GLUTHandleInverseNTSCJtoSMPTEC)){
1270: 				sprintf(fullpath, "%s/shaders/glut_inverse_ntscj_to_smptec.png", basedir);
1271: 				GLUTHandleInverseNTSCJtoSMPTEC = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1272: 				if (!GLUTHandleInverseNTSCJtoSMPTEC.idx) GLUTHandleInverseNTSCJtoSMPTEC = BGFX_INVALID_HANDLE;
1273: 			}
1274: 			break;
1275: 		case INDEX_LUT_INVERSE_NTSCJ_TO_EBU:
1276: 			if (!bgfx::isValid(GLUTHandleInverseNTSCJtoEBU)){
1277: 				sprintf(fullpath, "%s/shaders/glut_inverse_ntscj_to_ebu.png", basedir);
1278: 				GLUTHandleInverseNTSCJtoEBU = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1279: 				if (!GLUTHandleInverseNTSCJtoEBU.idx) GLUTHandleInverseNTSCJtoEBU = BGFX_INVALID_HANDLE;
1280: 			}
1281: 			break;
1282: 		case INDEX_LUT_SRGB_TO_NTSCJ:
1283: 			if (!bgfx::isValid(GLUTHandleSRGBtoNTSCJ)){
1284: 				sprintf(fullpath, "%s/shaders/glut_srgb_to_ntscj.png", basedir);
1285: 				GLUTHandleSRGBtoNTSCJ = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1286: 				if (!GLUTHandleSRGBtoNTSCJ.idx) GLUTHandleSRGBtoNTSCJ = BGFX_INVALID_HANDLE;
1287: 			}
1288: 			break;
1289: 		case INDEX_LUT_SMPTEC_TO_NTSCJ:
1290: 			if (!bgfx::isValid(GLUTHandleSMPTECtoNTSCJ)){
1291: 				sprintf(fullpath, "%s/shaders/glut_smptec_to_ntscj.png", basedir);
1292: 				GLUTHandleSMPTECtoNTSCJ = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1293: 				if (!GLUTHandleSMPTECtoNTSCJ.idx) GLUTHandleSMPTECtoNTSCJ = BGFX_INVALID_HANDLE;
1294: 			}
1295: 			break;
1296: 		case INDEX_LUT_EBU_TO_NTSCJ:
1297: 			if (!bgfx::isValid(GLUTHandleEBUtoNTSCJ)){
1298: 				sprintf(fullpath, "%s/shaders/glut_ebu_to_ntscj.png", basedir);
1299: 				GLUTHandleEBUtoNTSCJ = createTextureHandle(fullpath, &width, &height, &mipCount, false);
1300: 				if (!GLUTHandleEBUtoNTSCJ.idx) GLUTHandleEBUtoNTSCJ = BGFX_INVALID_HANDLE;
1301: 			}
1302: 			break;
1303: 		default:
1304: 			ffnx_error("LoadGamutLUT: called with invalid index: %i\n", whichLUT);
1305: 			break;
1306: 	}
1307: 	return;
1308: }
1309: 
1310: void Renderer::shutdown()
1311: {
1312:     destroyAll();
1313: 
1314:     bgfx::shutdown();
1315: }
1316: 
1317: void Renderer::clearShadowMap()
1318: {
1319:     bgfx::setViewClear(0, BGFX_CLEAR_DEPTH, internalState.clearColorValue, 1.0f, 0);
1320:     bgfx::touch(0);
1321: }
1322: 
1323: void Renderer::drawToShadowMap(bool uniformsAlreadyAttached, bool texturesAlreadyAttached)
1324: {
1325:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s with backendProgram %d\n", __func__, backendProgram);
1326: 
1327:     // Lighting state
1328:     auto lightingState = lighting.getLightingState();
1329: 
1330:     // Set view to render in the framebuffer
1331:     bgfx::setViewFrameBuffer(0, shadowMapFrameBuffer);
1332: 
1333:     // Set current view rect
1334:     int shadowMapResolution = lighting.getShadowMapResolution();
1335:     bgfx::setViewRect(0, 0, 0, shadowMapResolution, shadowMapResolution);
1336: 
1337:     // Set current view transform
1338:     bgfx::setViewTransform(0, lightingState.lightViewMatrix, lightingState.lightProjMatrix);
1339: 
1340:     // Set uniforms
1341:     if(!uniformsAlreadyAttached)
1342:     {
1343:         setLightingUniforms();
1344:         setCommonUniforms();
1345:     }
1346: 
1347:     // Bind textures in pipeline
1348:     if (!texturesAlreadyAttached)
1349:     {
1350:         bindTextures();
1351:     }
1352: 
1353:     // Set state
1354:     internalState.state = BGFX_STATE_DEPTH_TEST_LEQUAL | BGFX_STATE_WRITE_Z;
1355: 
1356:     // Face culling
1357:     if (lighting.isShadowFaceCullingEnabled())
1358:     {
1359:         switch (internalState.cullMode)
1360:         {
1361:         case RendererCullMode::FRONT: internalState.state |= BGFX_STATE_CULL_CW;
1362:         case RendererCullMode::BACK: internalState.state |= BGFX_STATE_CULL_CCW;
1363:         }
1364:     }
1365:     bgfx::setState(internalState.state);
1366: 
1367:     bgfx::submit(0, backendProgramHandles[RendererProgram::SHADOW_MAP], 0, BGFX_DISCARD_NONE);
1368: };
1369: 
1370: void Renderer::drawWithLighting(bool uniformsAlreadyAttached, bool texturesAlreadyAttached, bool keepBindings)
1371: {
1372:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s with backendProgram %d\n", __func__, backendProgram);
1373: 
1374:     // Set lighting program
1375:     backendProgram = backendProgram == SMOOTH ? LIGHTING_SMOOTH : LIGHTING_FLAT;
1376: 
1377:     // Re-Bind shadow map with comparison sampler
1378:     bgfx::setTexture(RendererTextureSlot::TEX_S, bgfxTexUniformHandles[RendererTextureSlot::TEX_S], bgfx::getTexture(shadowMapFrameBuffer));
1379: 
1380:     // Bind specular IBL cubemap
1381:     if (bgfx::isValid(specularIblTexture))
1382:     {
1383:         bgfx::setTexture(RendererTextureSlot::TEX_IBL_SPEC, bgfxTexUniformHandles[RendererTextureSlot::TEX_IBL_SPEC], specularIblTexture);
1384:     }
1385: 
1386:     // Bind diffuse IBL cubemap
1387:     if (bgfx::isValid(diffuseIblTexture))
1388:     {
1389:         bgfx::setTexture(RendererTextureSlot::TEX_IBL_DIFF, bgfxTexUniformHandles[RendererTextureSlot::TEX_IBL_DIFF], diffuseIblTexture);
1390:     }
1391: 
1392:     // Bind environment BRDF texture
1393:     if (bgfx::isValid(envBrdfTexture))
1394:     {
1395:         bgfx::setTexture(RendererTextureSlot::TEX_BRDF, bgfxTexUniformHandles[RendererTextureSlot::TEX_BRDF], envBrdfTexture, BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP);
1396:     }
1397: 
1398:     // Draw with lighting
1399:     draw(uniformsAlreadyAttached, texturesAlreadyAttached, keepBindings);
1400: }
1401: 
1402: void Renderer::drawFieldShadow()
1403: {
1404:     backendProgram = RendererProgram::FIELD_SHADOW;
1405: 
1406:     // Re-Bind shadow map with comparison sampler
1407:     bgfx::setTexture(RendererTextureSlot::TEX_S, bgfxTexUniformHandles[RendererTextureSlot::TEX_S], bgfx::getTexture(shadowMapFrameBuffer));
1408: 
1409:     // Re-Bind shadow map for direct depth sampling
1410:     bgfx::setTexture(RendererTextureSlot::TEX_D, bgfxTexUniformHandles[RendererTextureSlot::TEX_D], bgfx::getTexture(shadowMapFrameBuffer), BGFX_TEXTURE_RT | BGFX_SAMPLER_POINT | BGFX_SAMPLER_U_CLAMP | BGFX_SAMPLER_V_CLAMP | BGFX_SAMPLER_W_CLAMP);
1411: 
1412:     draw();
1413: }
1414: 
1415: void Renderer::draw(bool uniformsAlreadyAttached, bool texturesAlreadyAttached, bool keepBindings)
1416: {
1417:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s with backendProgram %d\n", __func__, backendProgram);
1418: 
1419:     // Set current view rect
1420:     if (backendProgram == RendererProgram::POSTPROCESSING)
1421:     {
1422:         bgfx::setViewRect(backendViewId, 0, 0, window_size_x, window_size_y);
1423: 
1424:         // Set current view transform
1425:         bgfx::setViewTransform(backendViewId, NULL, internalState.postprocessingProjMatrix);
1426:     }
1427:     else
1428:     {
1429:         // Set view to render in the framebuffer
1430:         bgfx::setViewFrameBuffer(backendViewId, backendFrameBuffer);
1431: 
1432:         bgfx::setViewRect(backendViewId, 0, 0, framebufferWidth, framebufferHeight);
1433: 
1434:         if (internalState.bDoScissorTest) bgfx::setScissor(scissorOffsetX, scissorOffsetY, scissorWidth, scissorHeight);
1435: 
1436:         // Set current view transform
1437:         bgfx::setViewTransform(backendViewId, NULL, internalState.backendProjMatrix);
1438:     }
1439: 
1440:     // Skip uniform attachment as it has been done already
1441:     if (!uniformsAlreadyAttached)
1442:     {
1443:         setCommonUniforms();
1444:         setLightingUniforms();
1445:     }
1446: 
1447:     // set up a gamut LUT if we need one
1448:     AssignGamutLUT();
1449: 
1450:     // Bind textures in pipeline
1451:     if (!texturesAlreadyAttached)
1452:     {
1453:         bindTextures();
1454:     }
1455: 
1456:     // Set state
1457:     {
1458:         internalState.state = BGFX_STATE_LINEAA | BGFX_STATE_MSAA | BGFX_STATE_WRITE_RGB | BGFX_STATE_WRITE_A;
1459: 
1460:         switch (internalState.cullMode)
1461:         {
1462:         case RendererCullMode::FRONT: internalState.state |= BGFX_STATE_CULL_CW;
1463:         case RendererCullMode::BACK: internalState.state |= BGFX_STATE_CULL_CCW;
1464:         }
1465: 
1466:         switch (internalState.blendMode)
1467:         {
1468:         case RendererBlendMode::BLEND_AVG:
1469:             internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
1470:             internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA);
1471:             break;
1472:         case RendererBlendMode::BLEND_ADD:
1473:             internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
1474:             internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ONE);
1475:             break;
1476:         case RendererBlendMode::BLEND_SUB:
1477:             internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_REVSUB);
1478:             internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ONE);
1479:             break;
1480:         case RendererBlendMode::BLEND_25P:
1481:             internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
1482:             internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_ONE);
1483:             break;
1484:         case RendererBlendMode::BLEND_NONE:
1485:             internalState.state |= BGFX_STATE_BLEND_EQUATION(BGFX_STATE_BLEND_EQUATION_ADD);
1486:             if (internalState.bIsExternalTexture && !ff8) internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_SRC_ALPHA, BGFX_STATE_BLEND_INV_SRC_ALPHA);
1487:             else internalState.state |= BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ZERO);
1488:             break;
1489:         }
1490: 
1491:         switch (internalState.primitiveType)
1492:         {
1493:         case RendererPrimitiveType::PT_LINES:
1494:             internalState.state |= BGFX_STATE_PT_LINES;
1495:             break;
1496:         case RendererPrimitiveType::PT_POINTS:
1497:             internalState.state |= BGFX_STATE_PT_POINTS;
1498:             break;
1499:         }
1500: 
1501:         if (internalState.bDoDepthTest) internalState.state |= BGFX_STATE_DEPTH_TEST_LEQUAL;
1502: 
1503:         if (internalState.bDoDepthWrite) internalState.state |= BGFX_STATE_WRITE_Z;
1504:     }
1505:     bgfx::setState(internalState.state);
1506: 
1507:     auto flags = keepBindings ? BGFX_DISCARD_STATE : BGFX_DISCARD_ALL;
1508:     bgfx::submit(backendViewId, backendProgramHandles[backendProgram], 0, flags);
1509: 
1510:     internalState.bHasDrawBeenDone = true;
1511:     internalState.bTexturesBound = false;
1512: };
1513: 
1514: void Renderer::discardAllBindings()
1515: {
1516:     bgfx::discard(BGFX_DISCARD_ALL);
1517: }
1518: 
1519: void Renderer::drawOverlay()
1520: {
1521:     if (enable_devtools)
1522:         overlay.draw();
1523: }
1524: 
1525: void Renderer::drawFFNxLogo(float fade)
1526: {
1527:     setClearFlags(true, false);
1528: 
1529: 	/*  y0    y2
1530: 	 x0 +-----+ x2
1531: 		|    /|
1532: 		|   / |
1533: 		|  /  |
1534: 		| /   |
1535: 		|/    |
1536: 	 x1 +-----+ x3
1537: 		y1    y3
1538: 	*/
1539: 
1540: 	// 0
1541: 	float x0 = 0.0f;
1542: 	float y0 = 0.0f;
1543: 	float u0 = 0.0f;
1544: 	float v0 = 0.0f;
1545: 	// 1
1546: 	float x1 = x0;
1547: 	float y1 = game_height;
1548: 	float u1 = u0;
1549: 	float v1 = 1.0f;
1550: 	// 2
1551: 	float x2 = game_width;
1552: 	float y2 = y0;
1553: 	float u2 = 1.0f;
1554: 	float v2 = v0;
1555: 	// 3
1556: 	float x3 = x2;
1557: 	float y3 = y1;
1558: 	float u3 = u2;
1559: 	float v3 = v1;
1560: 
1561: 	struct nvertex vertices[] = {
1562: 		{x0, y0, 1.0f, 1.0f, 0xffffffff, 0, u0, v0},
1563: 		{x1, y1, 1.0f, 1.0f, 0xffffffff, 0, u1, v1},
1564: 		{x2, y2, 1.0f, 1.0f, 0xffffffff, 0, u2, v2},
1565: 		{x3, y3, 1.0f, 1.0f, 0xffffffff, 0, u3, v3},
1566: 	};
1567: 
1568:     for(int i = 0; i < 4; ++i)
1569:     {
1570:         vertices[i].color.a = 255 * fade;
1571:     }
1572: 
1573: 	WORD indices[] = {
1574: 		0, 1, 2,
1575: 		1, 3, 2
1576: 	};
1577: 
1578:     bindVertexBuffer(vertices, 0, 4);
1579: 	bindIndexBuffer(indices, 6);
1580: 
1581:     resetState();
1582:     setOverallColorGamut(COLORGAMUT_SRGB); // always draw the logo in sRGB mode. The old setting is restored in drawFFNxLogo() in common.cpp
1583: 	setPrimitiveType();
1584: 	isTLVertex(true);
1585: 	setCullMode(RendererCullMode::DISABLED);
1586: 	setBlendMode(RendererBlendMode::BLEND_AVG);
1587:     doTextureFiltering(true);
1588:     isExternalTexture(true);
1589: 	isTexture(true);
1590: 	doDepthTest(false);
1591: 	doDepthWrite(false);
1592:     doModulateAlpha(true);
1593:     useTexture(FFNxLogoHandle.idx);
1594: 
1595: 	draw();
1596: }
1597: 
1598: void Renderer::show()
1599: {
1600:     // Reset internal state
1601:     resetState();
1602: 
1603:     renderFrame();
1604: 
1605:     bgfx::update(
1606:         vertexBufferHandle,
1607:         0,
1608:         bgfx::copy(
1609:             vertexBufferData.data(),
1610:             vectorSizeOf(vertexBufferData)
1611:         )
1612:     );
1613: 
1614:     bgfx::update(
1615:         indexBufferHandle,
1616:         0,
1617:         bgfx::copy(
1618:             indexBufferData.data(),
1619:             vectorSizeOf(indexBufferData)
1620:         )
1621:     );
1622: 
1623:     bgfx::frame(doCaptureFrame);
1624: 
1625:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s\n", __func__);
1626: 
1627:     bgfx::dbgTextClear();
1628: 
1629:     if(!ff8 && getmode_cached()->driver_mode == MODE_BATTLE) {
1630:         for(int i = 0; i <= backendViewId; i++)
1631:             bgfx::resetView(i);
1632:     }
1633: 
1634:     backendViewId = 1;
1635: 
1636:     vertexBufferData.clear();
1637:     vertexBufferData.shrink_to_fit();
1638: 
1639:     indexBufferData.clear();
1640:     indexBufferData.shrink_to_fit();
1641: 
1642:     bgfx::setViewMode(backendViewId, bgfx::ViewMode::Sequential);
1643: }
1644: 
1645: void Renderer::printText(uint16_t x, uint16_t y, uint32_t color, const char* text)
1646: {
1647:     bgfx::dbgTextPrintf(
1648:         x,
1649:         y,
1650:         color,
1651:         text
1652:     );
1653: }
1654: 
1655: void Renderer::toggleCaptureFrame()
1656: {
1657:     doCaptureFrame = !doCaptureFrame;
1658: }
1659: 
1660: const bgfx::Caps* Renderer::getCaps()
1661: {
1662:     return bgfx::getCaps();
1663: };
1664: 
1665: const bgfx::Stats* Renderer::getStats()
1666: {
1667:     return bgfx::getStats();
1668: }
1669: 
1670: const bgfx::VertexLayout& Renderer::GetVertexLayout()
1671: {
1672:     return vertexLayout;
1673: }
1674: 
1675: void Renderer::bindVertexBuffer(struct nvertex* inVertex, vector3<float>* normals, uint32_t inCount)
1676: {
1677:     if (!bgfx::isValid(vertexBufferHandle)) vertexBufferHandle = bgfx::createDynamicVertexBuffer(inCount, vertexLayout, BGFX_BUFFER_ALLOW_RESIZE);
1678: 
1679:     uint32_t currentOffset = vertexBufferData.size();
1680: 
1681:     for (uint32_t idx = 0; idx < inCount; idx++)
1682:     {
1683:         vertexBufferData.push_back(Vertex());
1684: 
1685:         vertexBufferData[currentOffset + idx].x = inVertex[idx]._.x;
1686:         vertexBufferData[currentOffset + idx].y = inVertex[idx]._.y;
1687:         vertexBufferData[currentOffset + idx].z = inVertex[idx]._.z;
1688:         vertexBufferData[currentOffset + idx].w = ( ::isinf(inVertex[idx].color.w) ? 1.0f : inVertex[idx].color.w );
1689:         vertexBufferData[currentOffset + idx].bgra = inVertex[idx].color.color;
1690:         vertexBufferData[currentOffset + idx].u = inVertex[idx].u;
1691:         vertexBufferData[currentOffset + idx].v = inVertex[idx].v;
1692: 
1693:         if (normals)
1694:         {
1695:             vertexBufferData[currentOffset + idx].nx = normals[idx].x;
1696:             vertexBufferData[currentOffset + idx].ny = normals[idx].y;
1697:             vertexBufferData[currentOffset + idx].nz = normals[idx].z;
1698:         }
1699: 
1700:         if (vertex_log && idx == 0) ffnx_trace("%s: %u [XYZW(%f, %f, %f, %f), BGRA(%08x), UV(%f, %f)]\n", __func__, idx, vertexBufferData[currentOffset + idx].x, vertexBufferData[currentOffset + idx].y, vertexBufferData[currentOffset + idx].z, vertexBufferData[currentOffset + idx].w, vertexBufferData[currentOffset + idx].bgra, vertexBufferData[currentOffset + idx].u, vertexBufferData[currentOffset + idx].v);
1701:         if (vertex_log && idx == 1) ffnx_trace("%s: See the rest on RenderDoc.\n", __func__);
1702:     }
1703: 
1704:     bgfx::setVertexBuffer(0, vertexBufferHandle, currentOffset, inCount);
1705: };
1706: 
1707: void Renderer::bindIndexBuffer(WORD* inIndex, uint32_t inCount)
1708: {
1709:     if (!bgfx::isValid(indexBufferHandle)) indexBufferHandle = bgfx::createDynamicIndexBuffer(inCount, BGFX_BUFFER_ALLOW_RESIZE);
1710: 
1711:     uint32_t currentOffset = indexBufferData.size();
1712: 
1713:     for (uint32_t idx = 0; idx < inCount; idx++)
1714:     {
1715:         indexBufferData.push_back(inIndex[idx]);
1716:     }
1717: 
1718:     bgfx::setIndexBuffer(indexBufferHandle, currentOffset, inCount);
1719: };
1720: 
1721: void Renderer::setScissor(uint16_t x, uint16_t y, uint16_t width, uint16_t height)
1722: {
1723:     scissorOffsetX = getInternalCoordX(x);
1724:     scissorOffsetY = getInternalCoordY(y);
1725:     scissorWidth = getInternalCoordX(width);
1726:     scissorHeight = getInternalCoordY(height);
1727: 
1728:     // This removes the black bars on the top and bottom of the screen
1729:     if (enable_uncrop)
1730:     {
1731:         bool is_movie_playing = *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag;
1732:         if(!(is_movie_playing && widescreen.getMovieMode() == WM_DISABLED))
1733:         {
1734:             if(y == 16 && height == 448)
1735:             {
1736:                 scissorOffsetY = getInternalCoordY(0.0);
1737:                 scissorHeight = getInternalCoordY(480);
1738:             }
1739:         }
1740:     }
1741: 
1742:     if(!widescreen_enabled) return;
1743: 
1744:     struct game_mode* mode = getmode_cached();
1745:     switch(mode->driver_mode)
1746:     {
1747:         case MODE_CREDITS:
1748:             {
1749:                 // Keep the default scissor for credits mode
1750:                 scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
1751:             }
1752:             break;
1753:         case MODE_FIELD:
1754:             {
1755:                 // Keep the default scissor for widescreen disabled movies and fields
1756:                 bool isKeepDefaultScissor = false;
1757:                 if (!ff8)
1758:                 {
1759:                      bool is_movie_playing = *ff7_externals.word_CC1638 && !ff7_externals.modules_global_object->BGMOVIE_flag;
1760:                      isKeepDefaultScissor = (is_movie_playing && widescreen.getMovieMode() == WM_DISABLED) || widescreen.getMode() == WM_DISABLED;
1761:                 }
1762: 
1763:                 if (isKeepDefaultScissor)
1764:                 {
1765:                     scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
1766:                     return;
1767:                 }
1768: 
1769:                 // This changes the scissor width and makes it bigger to fit widescreen
1770:                 if(x == 0 && width == game_width)
1771:                     scissorWidth = getInternalCoordX(wide_viewport_width);
1772:                 else
1773:                     scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
1774:             }
1775:             break;
1776:         case MODE_SWIRL:
1777:             {
1778:                 // This changes the scissor width and makes it bigger to fit widescreen
1779:                 if(x == 0 && width == game_width)
1780:                     scissorWidth = getInternalCoordX(wide_viewport_width);
1781:                 else
1782:                     scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
1783:             }
1784:             break;
1785:         case MODE_BATTLE:
1786:             {
1787:                 if(x == 0 && width == game_width)
1788:                     scissorWidth = getInternalCoordX(wide_viewport_width);
1789:                 else if(internalState.bIsTLVertex)
1790:                     scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
1791: 
1792:                 if (ff8)
1793:                 {
1794:                     // This removes the black bars on the top and bottom of the screen
1795:                     if(y == 24 && height == 432)
1796:                     {
1797:                         scissorOffsetY = getInternalCoordY(0.0);
1798:                         scissorHeight = getInternalCoordY(480);
1799:                     }
1800:                 }
1801:             }
1802:             break;
1803:         default:
1804:             {
1805:                 // This changes the scissor width and makes it bigger to fit widescreen
1806:                 if(x == 0 && width == game_width)
1807:                     scissorWidth = getInternalCoordX(wide_viewport_width);
1808:                 else
1809:                     scissorOffsetX = getInternalCoordX(x + abs(wide_viewport_x));
1810: 
1811:                 if (ff8)
1812:                 {
1813:                     // This removes the black bars on the top and bottom of the screen
1814:                     if(y == 16 && height == 448)
1815:                     {
1816:                         scissorOffsetY = getInternalCoordY(0.0);
1817:                         scissorHeight = getInternalCoordY(480);
1818:                     }
1819:                 }
1820:             }
1821:             break;
1822:     }
1823: }
1824: 
1825: void Renderer::setClearFlags(bool doClearColor, bool doClearDepth)
1826: {
1827:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s clearColor=%d,clearDepth=%d\n", __func__, doClearColor, doClearDepth);
1828: 
1829:     uint16_t clearFlags = BGFX_CLEAR_NONE;
1830: 
1831:     if (doClearColor)
1832:         clearFlags |= BGFX_CLEAR_COLOR;
1833: 
1834:     if (doClearDepth)
1835:         clearFlags |= BGFX_CLEAR_DEPTH;
1836: 
1837:     bgfx::setViewClear(backendViewId, clearFlags, internalState.clearColorValue, 1.0f);
1838:     bgfx::touch(backendViewId);
1839: 
1840:     internalState.bHasDrawBeenDone = false;
1841: }
1842: 
1843: void Renderer::setBackgroundColor(float r, float g, float b, float a)
1844: {
1845:     internalState.clearColorValue = createBGRA(r * 255, g * 255, b * 255, a * 255);
1846: }
1847: 
1848: uint32_t Renderer::createTexture(uint8_t* data, size_t width, size_t height, int stride, RendererTextureType type, bool isSrgb, bool copyData)
1849: {
1850:     bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;
1851: 
1852:     bgfx::TextureFormat::Enum texFormat = bgfx::TextureFormat::R8;
1853:     bimg::TextureFormat::Enum imgFormat = bimg::TextureFormat::R8;
1854: 
1855:     if (type == RendererTextureType::BGRA)
1856:     {
1857:         texFormat = bgfx::TextureFormat::BGRA8;
1858:         imgFormat = bimg::TextureFormat::BGRA8;
1859:     }
1860: 
1861:     bimg::TextureInfo texInfo;
1862:     bimg::imageGetSize(&texInfo, width, height, 0, false, false, 1, imgFormat);
1863: 
1864:     // If the texture we are going to create does not fit in memory, return an empty one.
1865:     // Will prevent the game from crashing, while allowing the player to not loose its progress.
1866:     if (doesItFitInMemory(texInfo.storageSize) && (data != NULL))
1867:     {
1868:         const bgfx::Memory* mem;
1869: 
1870:         if (copyData)
1871:         {
1872:             mem = bgfx::alloc(texInfo.storageSize);
1873:             // Protect from crashes
1874:             if (mem != NULL) {
1875:                 bx::memCopy(mem->data, data, texInfo.storageSize);
1876:             }
1877:         }
1878:         else
1879:         {
1880:             mem = bgfx::makeRef(data, texInfo.storageSize, RendererReleaseData, (void *)data);
1881:         }
1882: 
1883:         uint64_t flags = BGFX_SAMPLER_NONE;
1884: 
1885:         if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
1886:         else flags |= BGFX_TEXTURE_NONE;
1887: 
1888:         ret = bgfx::createTexture2D(
1889:             width,
1890:             height,
1891:             false,
1892:             1,
1893:             texFormat,
1894:             flags,
1895:             stride > 0 ? NULL : mem
1896:         );
1897: 
1898:         if (stride > 0)
1899:             bgfx::updateTexture2D(
1900:                 ret,
1901:                 0,
1902:                 0,
1903:                 0,
1904:                 0,
1905:                 width,
1906:                 height,
1907:                 mem,
1908:                 stride
1909:             );
1910: 
1911:         if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from data with stride %u\n", __func__, ret.idx, width, height, stride);
1912:     }
1913: 
1914:     return ret.idx;
1915: };
1916: 
1917: uint32_t Renderer::createTexture(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb)
1918: {
1919:     bgfx::TextureHandle handle = createTextureHandle(filename, width, height, mipCount, isSrgb);
1920:     return handle.idx;
1921: }
1922: 
1923: bimg::ImageContainer* Renderer::createImageContainer(const char* filename, bimg::TextureFormat::Enum targetFormat)
1924: {
1925:     return loadImageContainer(&defaultAllocator, filename, targetFormat);
1926: }
1927: 
1928: bimg::ImageContainer* Renderer::createImageContainer(cmrc::file* file, bimg::TextureFormat::Enum targetFormat)
1929: {
1930:     bimg::ImageContainer* img = nullptr;
1931: 
1932:     if (file->size() > 0)
1933:     {
1934:         img = bimg::imageParse(&defaultAllocator, file->begin(), file->size(), targetFormat);
1935:     }
1936: 
1937:     return img;
1938: }
1939: 
1940: bgfx::TextureHandle Renderer::createTextureHandle(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb)
1941: {
1942:     bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;
1943:     bimg::ImageContainer* img = createImageContainer(filename);
1944: 
1945:     if (img != nullptr)
1946:     {
1947:         if (gl_check_texture_dimensions(img->m_width, img->m_height, filename) && doesItFitInMemory(img->m_size))
1948:         {
1949:             uint64_t flags = BGFX_SAMPLER_NONE;
1950: 
1951:             if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
1952:             else flags |= BGFX_TEXTURE_NONE;
1953: 
1954:             const bgfx::Memory* mem = bgfx::makeRef(img->m_data, img->m_size, RendererReleaseImageContainer, img);
1955:             if (img->m_cubeMap)
1956:             {
1957:                 ret = bgfx::createTextureCube(
1958:                     img->m_width,
1959:                     1 < img->m_numMips,
1960:                     img->m_numLayers,
1961:                     bgfx::TextureFormat::Enum(img->m_format),
1962:                     flags,
1963:                     mem
1964:                 );
1965:             }
1966:             else
1967:             {
1968: 
1969:                 ret = bgfx::createTexture2D(
1970:                     img->m_width,
1971:                     img->m_height,
1972:                     1 < img->m_numMips,
1973:                     img->m_numLayers,
1974:                     bgfx::TextureFormat::Enum(img->m_format),
1975:                     flags,
1976:                     mem
1977:                 );
1978:             }
1979: 
1980:             *width = img->m_width;
1981:             *height = img->m_height;
1982:             *mipCount = img->m_numMips;
1983: 
1984:             if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from filename %s\n", __func__, ret.idx, width, height, filename);
1985:         }
1986:     }
1987: 
1988:     return ret;
1989: }
1990: 
1991: bgfx::TextureHandle Renderer::createTextureHandle(cmrc::file* file, char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb)
1992: {
1993:     bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;
1994:     bimg::ImageContainer* img = createImageContainer(file);
1995: 
1996:     if (img != nullptr)
1997:     {
1998:         if (gl_check_texture_dimensions(img->m_width, img->m_height, filename) && doesItFitInMemory(img->m_size))
1999:         {
2000:             uint64_t flags = BGFX_SAMPLER_NONE;
2001: 
2002:             if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
2003:             else flags |= BGFX_TEXTURE_NONE;
2004: 
2005:             const bgfx::Memory* mem = bgfx::makeRef(img->m_data, img->m_size, RendererReleaseImageContainer, img);
2006:             if (img->m_cubeMap)
2007:             {
2008:                 ret = bgfx::createTextureCube(
2009:                     img->m_width,
2010:                     1 < img->m_numMips,
2011:                     img->m_numLayers,
2012:                     bgfx::TextureFormat::Enum(img->m_format),
2013:                     flags,
2014:                     mem
2015:                 );
2016:             }
2017:             else
2018:             {
2019: 
2020:                 ret = bgfx::createTexture2D(
2021:                     img->m_width,
2022:                     img->m_height,
2023:                     1 < img->m_numMips,
2024:                     img->m_numLayers,
2025:                     bgfx::TextureFormat::Enum(img->m_format),
2026:                     flags,
2027:                     mem
2028:                 );
2029:             }
2030: 
2031:             *width = img->m_width;
2032:             *height = img->m_height;
2033:             *mipCount = img->m_numMips;
2034: 
2035:             if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from filename %s\n", __func__, ret.idx, width, height, filename);
2036:         }
2037:     }
2038: 
2039:     return ret;
2040: }
2041: 
2042: uint32_t Renderer::createTextureLibPng(char* filename, uint32_t* width, uint32_t* height, bool isSrgb)
2043: {
2044:     bgfx::TextureHandle ret = FFNX_RENDERER_INVALID_HANDLE;
2045:     bimg::ImageMip mip;
2046: 
2047:     if (!loadPng(filename, mip)) {
2048:         return ret.idx;
2049:     }
2050: 
2051:     const bgfx::Memory* mem = bgfx::makeRef(mip.m_data, mip.m_size, RendererReleaseData, (void *)mip.m_data);
2052: 
2053:     uint64_t flags = BGFX_SAMPLER_NONE;
2054: 
2055:     if (isSrgb) flags |= BGFX_TEXTURE_SRGB;
2056:     else flags |= BGFX_TEXTURE_NONE;
2057: 
2058:     ret = bgfx::createTexture2D(
2059:         mip.m_width,
2060:         mip.m_height,
2061:         false,
2062:         1,
2063:         bgfx::TextureFormat::Enum(mip.m_format),
2064:         flags,
2065:         mem
2066:     );
2067: 
2068:     *width = mip.m_width;
2069:     *height = mip.m_height;
2070: 
2071:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => %ux%u from filename %s\n", __func__, ret.idx, *width, *height, filename);
2072: 
2073:     return ret.idx;
2074: }
2075: 
2076: bool Renderer::saveTexture(const char* filename, uint32_t width, uint32_t height, const void* data)
2077: {
2078:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %ux%u with filename %s\n", __func__, width, height, filename);
2079: 
2080:     if (bx::open(&defaultWriter, filename, false))
2081:     {
2082:         bimg::imageWritePng(
2083:             &defaultWriter,
2084:             width,
2085:             height,
2086:             width * 4,
2087:             data,
2088:             bimg::TextureFormat::BGRA8,
2089:             false
2090:         );
2091: 
2092:         bx::close(&defaultWriter);
2093: 
2094:         return true;
2095:     }
2096: 
2097:     return false;
2098: }
2099: 
2100: void Renderer::deleteTexture(uint16_t rt)
2101: {
2102:     if (rt > 0)
2103:     {
2104:         bgfx::TextureHandle handle = { rt };
2105: 
2106:         if (bgfx::isValid(handle)) {
2107:             bgfx::destroy(handle);
2108: 
2109:             if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u Texture was valid and is now destroyed!\n", __func__, rt);
2110:         }
2111:     }
2112: };
2113: 
2114: void Renderer::useTexture(uint16_t rt, uint32_t slot)
2115: {
2116:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: [%u] => %u\n", __func__, slot, rt);
2117: 
2118:     if (rt > 0)
2119:     {
2120:         internalState.texHandlers[slot] = { rt };
2121:         if (slot == RendererTextureSlot::TEX_Y) isTexture(true);
2122:     }
2123:     else
2124:     {
2125:         internalState.texHandlers[slot] = BGFX_INVALID_HANDLE;
2126:         if (slot == RendererTextureSlot::TEX_Y) isTexture(false);
2127:     }
2128: };
2129: 
2130: uint32_t Renderer::createBlitTexture(uint32_t x, uint32_t y, uint32_t width, uint32_t height)
2131: {
2132:     uint16_t newX = getInternalCoordX(x);
2133:     uint16_t newY = getInternalCoordY(y);
2134:     uint16_t newWidth = getInternalCoordX(width);
2135:     uint16_t newHeight = getInternalCoordY(height);
2136: 
2137:     bgfx::TextureHandle ret = bgfx::createTexture2D(newWidth, newHeight, false, 1, internalState.bIsHDR ? bgfx::TextureFormat::RGB10A2 : bgfx::TextureFormat::RGBA16, BGFX_TEXTURE_BLIT_DST);
2138: 
2139:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => XY(%u,%u) WH(%u,%u)\n", __func__, ret.idx, newX, newY, newWidth, newHeight);
2140: 
2141:     return ret.idx;
2142: }
2143: 
2144: void Renderer::blitTexture(uint16_t dest, uint32_t x, uint32_t y, uint32_t width, uint32_t height)
2145: {
2146:     uint16_t newX = getInternalCoordX(x);
2147:     uint16_t newY = getInternalCoordY(y);
2148:     uint16_t newWidth = getInternalCoordX(width);
2149:     uint16_t newHeight = getInternalCoordY(height);
2150: 
2151:     uint16_t dstY = 0;
2152: 
2153:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u => XY(%u,%u) WH(%u,%u)\n", __func__, dest, newX, newY, newWidth, newHeight);
2154: 
2155:     if (getCaps()->originBottomLeft)
2156:     {
2157:         int _newY = framebufferHeight - (newY + newHeight);
2158: 
2159:         // If the new Y is a positive value, we can use it as it is
2160:         if (_newY > 0)
2161:         {
2162:             newY = _newY;
2163:             dstY = 0;
2164:         }
2165:         // Otherwise, it means we have to copy the whole source texture
2166:         // but shift the result on the Y axis of the dest texture of the absolute negative difference
2167:         else
2168:         {
2169:             newY = 0;
2170:             dstY = ::abs(_newY);
2171:         }
2172:     }
2173: 
2174:     backendViewId++;
2175: 
2176:     bgfx::TextureHandle texHandle = { dest };
2177:     bgfx::blit(backendViewId, texHandle, 0, dstY, bgfx::getTexture(backendFrameBuffer, 0), newX, newY, newWidth, newHeight);
2178:     bgfx::touch(backendViewId);
2179:     setClearFlags(false, false);
2180: 
2181:     backendViewId++;
2182:     setClearFlags(false, false);
2183: }
2184: 
2185: void Renderer::zoomBackendFrameBuffer(int x, int y, int width, int height)
2186: {
2187:     if(!internalState.bHasDrawBeenDone) return;
2188: 
2189:     bgfx::TextureHandle textureHandle = bgfx::createTexture2D(width, height, false, 1, internalState.bIsHDR ? bgfx::TextureFormat::RGB10A2 : bgfx::TextureFormat::RGBA16, BGFX_TEXTURE_BLIT_DST);
2190: 
2191:     backendViewId++;
2192:     bgfx::setViewClear(backendViewId, BGFX_CLEAR_NONE, internalState.clearColorValue, 1.0f);
2193:     bgfx::touch(backendViewId);
2194:     bgfx::blit(backendViewId, textureHandle, 0, 0, bgfx::getTexture(backendFrameBuffer, 0), x, y, width, height);
2195:     backendViewId++;
2196:     bgfx::setViewClear(backendViewId, BGFX_CLEAR_NONE, internalState.clearColorValue, 1.0f);
2197:     bgfx::touch(backendViewId);
2198: 
2199:     /*  y0    y2
2200:      x0 +-----+ x2
2201:         |    /|
2202:         |   / |
2203:         |  /  |
2204:         | /   |
2205:         |/    |
2206:      x1 +-----+ x3
2207:         y1    y3
2208:     */
2209: 
2210:     // 0
2211:     float x0 = wide_viewport_x;
2212:     float y0 = wide_viewport_y;
2213:     float u0 = 0.0f;
2214:     float v0 = getCaps()->originBottomLeft ? 1.0f : 0.0f;
2215:     // 1
2216:     float x1 = x0;
2217:     float y1 = wide_viewport_height;
2218:     float u1 = u0;
2219:     float v1 = getCaps()->originBottomLeft ? 0.0f : 1.0f;
2220:     // 2
2221:     float x2 = x0 + wide_viewport_width;
2222:     float y2 = y0;
2223:     float u2 = 1.0f;
2224:     float v2 = v0;
2225:     // 3
2226:     float x3 = x2;
2227:     float y3 = y1;
2228:     float u3 = u2;
2229:     float v3 = v1;
2230: 
2231:     struct nvertex vertices[] = {
2232:         {x0, y0, 1.0f, 1.0f, 0xff000000, 0, u0, v0},
2233:         {x1, y1, 1.0f, 1.0f, 0xff000000, 0, u1, v1},
2234:         {x2, y2, 1.0f, 1.0f, 0xff000000, 0, u2, v2},
2235:         {x3, y3, 1.0f, 1.0f, 0xff000000, 0, u3, v3},
2236:     };
2237:     WORD indices[] = {
2238:         0, 1, 2,
2239:         1, 3, 2
2240:     };
2241: 
2242:     backendProgram = RendererProgram::BLIT;
2243: 
2244:     useTexture(textureHandle.idx);
2245: 
2246:     bindVertexBuffer(vertices, 0, 4);
2247:     bindIndexBuffer(indices, 6);
2248: 
2249:     doDepthTest(false);
2250:     setCullMode(RendererCullMode::DISABLED);
2251:     setBlendMode(RendererBlendMode::BLEND_DISABLED);
2252:     setPrimitiveType();
2253: 
2254:     draw();
2255: 
2256:     if (bgfx::isValid(textureHandle)) bgfx::destroy(textureHandle);
2257: }
2258: 
2259: void Renderer::clearDepthBuffer()
2260: {
2261:     backendViewId++;
2262:     bgfx::setViewMode(backendViewId, bgfx::ViewMode::Sequential);
2263:     bgfx::setViewRect(backendViewId, 0, 0, framebufferWidth, framebufferHeight);
2264:     bgfx::setViewFrameBuffer(backendViewId, backendFrameBuffer);
2265:     bgfx::setViewClear(backendViewId, BGFX_CLEAR_DEPTH);
2266:     bgfx::touch(backendViewId);
2267: 
2268:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: Clearing depth\n", __func__, backendViewId);
2269: }
2270: 
2271: void Renderer::isMovie(bool flag)
2272: {
2273:     internalState.bIsMovie = flag;
2274: };
2275: 
2276: void Renderer::isTLVertex(bool flag)
2277: {
2278:     internalState.bIsTLVertex = flag;
2279: };
2280: 
2281: void Renderer::setBlendMode(RendererBlendMode mode)
2282: {
2283:     internalState.blendMode = mode;
2284: };
2285: 
2286: void Renderer::isTexture(bool flag)
2287: {
2288:     internalState.bIsTexture = flag;
2289: };
2290: 
2291: void Renderer::isFBTexture(bool flag)
2292: {
2293:     internalState.bIsFBTexture = flag;
2294: };
2295: 
2296: void Renderer::isFullRange(bool flag)
2297: {
2298:     internalState.bIsMovieFullRange = flag;
2299: };
2300: 
2301: void Renderer::isYUV(bool flag)
2302: {
2303:     internalState.bIsMovieYUV = flag;
2304: };
2305: 
2306: void Renderer::doModulateAlpha(bool flag)
2307: {
2308:     internalState.bModulateAlpha = flag;
2309: };
2310: 
2311: void Renderer::doTextureFiltering(bool flag)
2312: {
2313:     internalState.bDoTextureFiltering = flag;
2314: };
2315: 
2316: void Renderer::doMirrorTextureWrap(bool flag)
2317: {
2318:     internalState.bDoMirrorTextureWrap = flag;
2319: }
2320: 
2321: void Renderer::isExternalTexture(bool flag)
2322: {
2323:     internalState.bIsExternalTexture = flag;
2324: }
2325: 
2326: bool Renderer::isHDR()
2327: {
2328:     return internalState.bIsHDR;
2329: }
2330: 
2331: void Renderer::setColorMatrix(ColorMatrixType cmtype){
2332:     internalState.bIsMovieColorMatrix = cmtype;
2333: }
2334: 
2335: void Renderer::setColorGamut(ColorGamutType cgtype){
2336:     internalState.bIsMovieColorGamut = cgtype;
2337: }
2338: 
2339: void Renderer::setOverallColorGamut(ColorGamutType cgtype){
2340:     internalState.bIsOverallColorGamut = cgtype;
2341: }
2342: 
2343: void Renderer::setGamutOverride(bool flag)
2344: {
2345:     internalState.bIsOverrideGamut = flag;
2346: }
2347: 
2348: void Renderer::setGammaType(InverseGammaFunctionType gtype)
2349: {
2350:     internalState.bIsMovieGammaType = gtype;
2351: };
2352: 
2353: void Renderer::setAlphaRef(RendererAlphaFunc func, float ref)
2354: {
2355:     internalState.alphaFunc = func;
2356:     internalState.alphaRef = ref;
2357: };
2358: 
2359: void Renderer::doAlphaTest(bool flag)
2360: {
2361:     internalState.bDoAlphaTest = flag;
2362: };
2363: 
2364: void Renderer::setInterpolationQualifier(RendererInterpolationQualifier qualifier)
2365: {
2366:     switch (qualifier)
2367:     {
2368:     case RendererInterpolationQualifier::FLAT:
2369:         backendProgram = RendererProgram::FLAT;
2370:         if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: FLAT\n", __func__);
2371:         break;
2372:     case RendererInterpolationQualifier::SMOOTH:
2373:         backendProgram = RendererProgram::SMOOTH;
2374:         if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: SMOOTH\n", __func__);
2375:         break;
2376:     }
2377: }
2378: 
2379: void Renderer::setPrimitiveType(RendererPrimitiveType type)
2380: {
2381:     if (trace_all || trace_renderer) ffnx_trace("Renderer::%s: %u\n", __func__, type);
2382: 
2383:     internalState.primitiveType = type;
2384: };
2385: 
2386: void Renderer::setCullMode(RendererCullMode mode)
2387: {
2388:     internalState.cullMode = mode;
2389: }
2390: 
2391: void Renderer::doDepthTest(bool flag)
2392: {
2393:     internalState.bDoDepthTest = flag;
2394: }
2395: 
2396: void Renderer::doDepthWrite(bool flag)
2397: {
2398:     internalState.bDoDepthWrite = flag;
2399: }
2400: 
2401: void Renderer::doScissorTest(bool flag)
2402: {
2403:     internalState.bDoScissorTest = flag;
2404: }
2405: 
2406: void Renderer::setWireframeMode(bool flag)
2407: {
2408:     if (flag) bgfx::setDebug(BGFX_DEBUG_WIREFRAME);
2409: }
2410: 
2411: void Renderer::setViewMatrix(struct matrix* matrix)
2412: {
2413:     ::memcpy(internalState.viewMatrix, &matrix->m[0][0], sizeof(matrix->m));
2414: 
2415:     bx::mtxInverse(internalState.invViewMatrix, internalState.viewMatrix);
2416: 
2417:     internalState.isViewMatrixSet = true;
2418: 
2419:     if (uniform_log) printMatrix(__func__, internalState.viewMatrix);
2420: }
2421: 
2422: float* Renderer::getViewMatrix()
2423: {
2424:     return internalState.viewMatrix;
2425: }
2426: 
2427: float* Renderer::getInvViewMatrix()
2428: {
2429:     return internalState.invViewMatrix;
2430: }
2431: 
2432: bool Renderer::isViewMatrixSet()
2433: {
2434:     return internalState.isViewMatrixSet;
2435: }
2436: 
2437: void Renderer::resetViewMatrixFlag()
2438: {
2439:     internalState.isViewMatrixSet = false;
2440: }
2441: 
2442: void Renderer::setWorldViewMatrix(struct matrix *matrix, bool calculateNormalMatrix)
2443: {
2444:     ::memcpy(internalState.worldViewMatrix, &matrix->m[0][0], sizeof(matrix->m));
2445: 
2446:     if (uniform_log) printMatrix(__func__, internalState.worldViewMatrix);
2447: 
2448:     if(calculateNormalMatrix)
2449:     {
2450:         struct matrix transpose;
2451:         transpose_matrix(matrix, &transpose);
2452:         struct matrix invTranspose;
2453:         inverse_matrix(&transpose, &invTranspose);
2454:         invTranspose._41 = 0.0;
2455:         invTranspose._42 = 0.0;
2456:         invTranspose._43 = 0.0;
2457:         invTranspose._44 = 1.0;
2458: 
2459:         ::memcpy(internalState.normalMatrix, &invTranspose.m[0][0], sizeof(invTranspose.m));
2460: 
2461:         if (uniform_log) printMatrix(__func__, internalState.normalMatrix);
2462:     }
2463: }
2464: 
2465: float* Renderer::getWorldViewMatrix()
2466: {
2467:     return internalState.worldViewMatrix;
2468: }
2469: 
2470: float* Renderer::getNormalMatrix()
2471: {
2472:     return internalState.normalMatrix;
2473: }
2474: 
2475: void Renderer::setD3DViweport(struct matrix* matrix)
2476: {
2477:     ::memcpy(internalState.d3dViewMatrix, &matrix->m[0][0], sizeof(matrix->m));
2478: 
2479:     if (uniform_log) printMatrix(__func__, internalState.d3dViewMatrix);
2480: };
2481: 
2482: void Renderer::setD3DProjection(struct matrix* matrix)
2483: {
2484:     ::memcpy(internalState.d3dProjectionMatrix, &matrix->m[0][0], sizeof(matrix->m));
2485: 
2486:     // Modify the projection matrix to prevent stretching
2487:     if(widescreen_enabled)
2488:     {
2489:         float widescreenScale = round(float(game_width) / wide_viewport_width * 100) / 100.f;
2490:         internalState.d3dProjectionMatrix[0] *= widescreenScale;
2491:         internalState.d3dProjectionMatrix[8] *= widescreenScale;
2492:     }
2493: 
2494:     // Modify the projection matrix to extend view distance
2495:     if (enable_worldmap_external_mesh)
2496:     {
2497:         struct game_mode* mode = getmode_cached();
2498:         if(mode->driver_mode == MODE_WORLDMAP)
2499:         {
2500:             const float f_offset = 0.0035f;
2501:             const float n_offset = 0.0f;
2502: 
2503:             float a = internalState.d3dProjectionMatrix[10];
2504:             float b = internalState.d3dProjectionMatrix[11];
2505: 
2506:             float f = b / (a + 1.0f) + f_offset;
2507:             float n = b / (a - 1.0f) + n_offset;
2508: 
2509:             internalState.d3dProjectionMatrix[10] = -(f + n) / (f -n);
2510:             internalState.d3dProjectionMatrix[11] = -(2*f*n) / (f - n);
2511:         }
2512:     }
2513: 
2514:     if (uniform_log) printMatrix(__func__, internalState.d3dProjectionMatrix);
2515: };
2516: 
2517: uint16_t Renderer::getInternalCoordX(uint16_t inX)
2518: {
2519:     if(widescreen_enabled)
2520:         return (inX * framebufferWidth) / (wide_viewport_width);
2521:     else
2522:         return (inX * framebufferWidth) / (game_width);
2523: }
2524: 
2525: uint16_t Renderer::getInternalCoordY(uint16_t inY)
2526: {
2527:     return (inY * framebufferHeight) / game_height;
2528: }
2529: 
2530: uint16_t Renderer::getScalingFactor()
2531: {
2532:     return scalingFactor;
2533: }
2534: 
2535: void Renderer::setTimeColor(bx::Vec3 color)
2536: {
2537:     internalState.TimeColor[0] = color.x;
2538:     internalState.TimeColor[1] = color.y;
2539:     internalState.TimeColor[2] = color.z;
2540: }
2541: 
2542: void Renderer::setTimeEnabled(bool flag)
2543: {
2544:     internalState.TimeData[0] = static_cast<float>(flag);
2545: }
2546: 
2547: void Renderer::setTimeFilterEnabled(bool flag)
2548: {
2549:     internalState.TimeData[1] = static_cast<float>(flag);
2550: }
2551: 
2552: bool Renderer::isTimeFilterEnabled()
2553: {
2554:     return static_cast<bool>(internalState.TimeData[1]);
2555: }
2556: 
2557: void Renderer::setSphericalWorldRate(float value)
2558: {
2559:     internalState.sphericalWorldRate = value;
2560: }
2561: 
2562: void Renderer::setFogEnabled(bool flag)
2563: {
2564:     internalState.bIsFogEnabled = flag;
2565: }
2566: 
2567: bool Renderer::isFogEnabled()
2568: {
2569:     return internalState.bIsFogEnabled;
2570: }
2571: 
2572: void Renderer::setGameLightData(light_data* lightdata)
2573: {
2574:     struct game_mode* mode = getmode_cached();
2575: 
2576:     bool useGameLighting = lightdata != nullptr;
2577:     if (enable_worldmap_external_mesh && mode->driver_mode == MODE_WORLDMAP)
2578:     {
2579:         useGameLighting = false;
2580:     }
2581: 
2582:     if (useGameLighting)
2583:     {
2584:         internalState.gameGlobalLightColor[0] = lightdata->global_light_color.r;
2585:         internalState.gameGlobalLightColor[1] = lightdata->global_light_color.g;
2586:         internalState.gameGlobalLightColor[2] = lightdata->global_light_color.b;
2587:         internalState.gameGlobalLightColor[3] = enable_lighting ? 2.5f : 1.0f;
2588: 
2589:         internalState.gameLightColor1[0] = lightdata->light_color_1.r;
2590:         internalState.gameLightColor1[1] = lightdata->light_color_1.g;
2591:         internalState.gameLightColor1[2] = lightdata->light_color_1.b;
2592:         internalState.gameLightColor1[3] = 1.0;
2593: 
2594:         internalState.gameLightColor2[0] = lightdata->light_color_2.r;
2595:         internalState.gameLightColor2[1] = lightdata->light_color_2.g;
2596:         internalState.gameLightColor2[2] = lightdata->light_color_2.b;
2597:         internalState.gameLightColor2[3] = 1.0;
2598: 
2599:         internalState.gameLightColor3[0] = lightdata->light_color_3.r;
2600:         internalState.gameLightColor3[1] = lightdata->light_color_3.g;
2601:         internalState.gameLightColor3[2] = lightdata->light_color_3.b;
2602:         internalState.gameLightColor3[3] = 1.0;
2603: 
2604:         if (mode->driver_mode == MODE_WORLDMAP)
2605:         {
2606:             internalState.gameLightDir1[0] = lightdata->light_dir_1.x;
2607:             internalState.gameLightDir1[1] = lightdata->light_dir_1.z;
2608:             internalState.gameLightDir1[2] = lightdata->light_dir_1.y;
2609: 
2610:             internalState.gameLightDir2[0] = lightdata->light_dir_2.x;
2611:             internalState.gameLightDir2[1] = lightdata->light_dir_2.z;
2612:             internalState.gameLightDir2[2] = lightdata->light_dir_2.y;
2613: 
2614:             internalState.gameLightDir3[0] = lightdata->light_dir_3.x;
2615:             internalState.gameLightDir3[1] = lightdata->light_dir_3.z;
2616:             internalState.gameLightDir3[2] = lightdata->light_dir_3.y;
2617:         }
2618:         else
2619:         {
2620:             internalState.gameLightDir1[0] = -lightdata->light_dir_1.x;
2621:             internalState.gameLightDir1[1] = -lightdata->light_dir_1.y;
2622:             internalState.gameLightDir1[2] = -lightdata->light_dir_1.z;
2623: 
2624:             internalState.gameLightDir2[0] = -lightdata->light_dir_2.x;
2625:             internalState.gameLightDir2[1] = -lightdata->light_dir_2.y;
2626:             internalState.gameLightDir2[2] = -lightdata->light_dir_2.z;
2627: 
2628:             internalState.gameLightDir3[0] = -lightdata->light_dir_3.x;
2629:             internalState.gameLightDir3[1] = -lightdata->light_dir_3.y;
2630:             internalState.gameLightDir3[2] = -lightdata->light_dir_3.z;
2631:         }
2632: 
2633:         internalState.gameScriptedLightColor[0] = lightdata->scripted_light_color.r;
2634:         internalState.gameScriptedLightColor[1] = lightdata->scripted_light_color.g;
2635:         internalState.gameScriptedLightColor[2] = lightdata->scripted_light_color.b;
2636:     }
2637:     else
2638:     {
2639:         internalState.gameGlobalLightColor[0] = 1.0;
2640:         internalState.gameGlobalLightColor[1] = 1.0;
2641:         internalState.gameGlobalLightColor[2] = 1.0;
2642:         internalState.gameGlobalLightColor[3] = 1;
2643: 
2644:         internalState.gameLightColor1[0] = 0;
2645:         internalState.gameLightColor1[1] = 0;
2646:         internalState.gameLightColor1[2] = 0;
2647:         internalState.gameLightColor1[3] = 0;
2648: 
2649:         internalState.gameLightColor2[0] = 0;
2650:         internalState.gameLightColor2[1] = 0;
2651:         internalState.gameLightColor2[2] = 0;
2652:         internalState.gameLightColor2[3] = 0;
2653: 
2654:         internalState.gameLightColor3[0] = 0;
2655:         internalState.gameLightColor3[1] = 0;
2656:         internalState.gameLightColor3[2] = 0;
2657:         internalState.gameLightColor3[3] = 0;
2658: 
2659:         internalState.gameLightDir1[0] = 0;
2660:         internalState.gameLightDir1[1] = 0;
2661:         internalState.gameLightDir1[2] = 0;
2662: 
2663:         internalState.gameLightDir2[0] = 0;
2664:         internalState.gameLightDir2[1] = 0;
2665:         internalState.gameLightDir2[2] = 0;
2666: 
2667:         internalState.gameLightDir3[0] = 0;
2668:         internalState.gameLightDir3[1] = 0;
2669:         internalState.gameLightDir3[2] = 0;
2670: 
2671:         internalState.gameScriptedLightColor[0] = 1.0;
2672:         internalState.gameScriptedLightColor[1] = 1.0;
2673:         internalState.gameScriptedLightColor[2] = 1.0;
2674:     }
2675: }
</file>

<file path="src/renderer.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #pragma once
 24: 
 25: #include "common.h"
 26: #include "overlay.h"
 27: 
 28: #include <cmrc/cmrc.hpp>
 29: #include <vector>
 30: #include <array>
 31: #include <string>
 32: #include <math.h>
 33: #include <bx/math.h>
 34: #include <bx/bx.h>
 35: #include <bx/allocator.h>
 36: #include <bx/file.h>
 37: #include <bimg/bimg.h>
 38: #include <bimg/decode.h>
 39: #include <bimg/encode.h>
 40: #include <bgfx/platform.h>
 41: #include <bgfx/bgfx.h>
 42: 
 43: #define FFNX_RENDERER_INVALID_HANDLE { 0 }
 44: 
 45: enum RendererInterpolationQualifier {
 46:     FLAT = 0,
 47:     SMOOTH
 48: };
 49: 
 50: enum RendererBlendMode {
 51:     BLEND_AVG = 0,
 52:     BLEND_ADD,
 53:     BLEND_SUB,
 54:     BLEND_25P,
 55:     BLEND_NONE,
 56:     BLEND_DISABLED = 999
 57: };
 58: 
 59: enum RendererCullMode {
 60:     DISABLED = 0,
 61:     FRONT,
 62:     BACK
 63: };
 64: 
 65: enum RendererAlphaFunc {
 66:     NEVER = 0,
 67:     LESS,
 68:     EQUAL,
 69:     LEQUAL,
 70:     GREATER,
 71:     NOTEQUAL,
 72:     GEQUAL,
 73:     ALWAYS
 74: };
 75: 
 76: enum RendererPrimitiveType
 77: {
 78:     PT_POINTS = 0,
 79:     PT_LINES,
 80:     PT_LINE_LOOP,
 81:     PT_LINE_STRIP,
 82:     PT_TRIANGLES,
 83:     PT_TRIANGLE_STRIP,
 84:     PT_TRIANGLE_FAN,
 85:     PT_QUADS,
 86:     PT_QUAD_STRIP
 87: };
 88: 
 89: enum RendererTextureType
 90: {
 91:     BGRA = 0,
 92:     YUV
 93: };
 94: 
 95: enum RendererUniform
 96: {
 97:     VS_FLAGS = 0,
 98:     FS_ALPHA_FLAGS,
 99:     FS_MISC_FLAGS,
100:     FS_HDR_FLAGS,
101:     FS_TEX_FLAGS,
102:     FS_MOVIE_FLAGS,
103:     WM_FLAGS,
104:     TIME_COLOR,
105:     TIME_DATA,
106:     D3D_VIEWPORT,
107:     D3D_PROJECTION,
108:     WORLD_VIEW,
109:     NORMAL_MATRIX,
110:     VIEW_MATRIX,
111:     INV_VIEW_MATRIX,
112:     GAME_LIGHTING_FLAGS,
113:     GAME_GLOBAL_LIGHT_COLOR,
114:     GAME_LIGHT_COLOR1,
115:     GAME_LIGHT_COLOR2,
116:     GAME_LIGHT_COLOR3,
117:     GAME_LIGHT_DIR1,
118:     GAME_LIGHT_DIR2,
119:     GAME_LIGHT_DIR3,
120:     GAME_SCRIPTED_LIGHT_COLOR,
121: 
122:     LIGHTING_SETTINGS,
123:     LIGHT_DIR_DATA,
124:     LIGHT_DATA,
125:     AMBIENT_LIGHT_DATA,
126:     SHADOW_DATA,
127:     FIELD_SHADOW_DATA,
128:     MATERIAL_DATA,
129:     MATERIAL_SCALE_DATA,
130:     LIGHTING_DEBUG_DATA,
131:     IBL_DATA,
132:     LIGHT_VIEW_PROJ_MATRIX,
133:     LIGHT_VIEW_PROJ_TEX_MATRIX,
134:     LIGHT_INV_VIEW_PROJ_TEX_MATRIX,
135:     VIEW_OFFSET_MATRIX,
136:     INV_VIEW_OFFSET_MATRIX,
137: 
138:     COUNT,
139: };
140: 
141: enum ColorMatrixType{
142:     COLORMATRIX_BT601 = 0,
143:     COLORMATRIX_BT709 = 1,
144:     COLORMATRIX_BGR24 = 2
145: };
146: 
147: enum ColorGamutType{
148:     COLORGAMUT_SRGB = 0,
149:     COLORGAMUT_NTSCJ = 1,
150:     COLORGAMUT_SMPTEC = 2,
151:     COLORGAMUT_EBU = 3
152: };
153: 
154: enum InverseGammaFunctionType{
155:     GAMMAFUNCTION_SRGB = 0,
156:     GAMMAFUNCTION_TWO_PT_TWO = 1,
157:     GAMMAFUNCTION_SMPTE170M = 2,
158:     GAMMAFUNCTION_TOELESS_SRGB = 3,
159:     GAMMAFUNCTION_TWO_PT_EIGHT = 4
160: };
161: 
162: namespace RendererTextureSlot {
163:     enum RendererTextureSlot
164:     {
165:         TEX_Y = 0,
166:         TEX_U,
167:         TEX_V,
168:         TEX_S,
169:         TEX_D,
170:         TEX_NML,
171:         TEX_PBR,
172:         TEX_IBL_SPEC,
173:         TEX_IBL_DIFF,
174:         TEX_BRDF,
175:         TEX_G_LUT,
176:         COUNT
177:     };
178: };
179: 
180: enum GamutLUTIndexType{
181: 	INDEX_LUT_NTSCJ_TO_SRGB,
182: 	INDEX_LUT_SMPTEC_TO_SRGB,
183: 	INDEX_LUT_EBU_TO_SRGB,
184: 	INDEX_LUT_INVERSE_NTSCJ_TO_SRGB,
185: 	INDEX_LUT_INVERSE_NTSCJ_TO_SMPTEC,
186: 	INDEX_LUT_INVERSE_NTSCJ_TO_EBU,
187: 	INDEX_LUT_SRGB_TO_NTSCJ,
188: 	INDEX_LUT_SMPTEC_TO_NTSCJ,
189: 	INDEX_LUT_EBU_TO_NTSCJ
190: };
191: 
192: static void RendererReleaseImageContainer(void* _ptr, void* _userData)
193: {
194:     BX_UNUSED(_ptr);
195:     bimg::ImageContainer* imageContainer = (bimg::ImageContainer*)_userData;
196:     bimg::imageFree(imageContainer);
197: }
198: 
199: static void RendererReleaseData(void* _ptr, void* _userData)
200: {
201:     BX_UNUSED(_ptr);
202:     driver_free(_userData);
203: }
204: 
205: struct RendererCallbacks : public bgfx::CallbackI {
206:     std::string cachePath = R"(shaders\cache)";
207: 
208:     virtual ~RendererCallbacks() {};
209:     virtual void fatal(const char* _filePath, uint16_t _line, bgfx::Fatal::Enum _code, const char* _str) override;
210:     virtual void traceVargs(const char* _filePath, uint16_t _line, const char* _format, va_list _argList) override;
211:     virtual void profilerBegin(const char* _name, uint32_t _abgr, const char* _filePath, uint16_t _line) override {};
212:     virtual void profilerBeginLiteral(const char* _name, uint32_t _abgr, const char* _filePath, uint16_t _line) override {};
213:     virtual void profilerEnd() override {};
214:     virtual uint32_t cacheReadSize(uint64_t _id) override;
215:     virtual bool cacheRead(uint64_t _id, void* _data, uint32_t _size) override;
216:     virtual void cacheWrite(uint64_t _id, const void* _data, uint32_t _size) override;
217:     virtual void screenShot(const char* _filePath, uint32_t _width, uint32_t _height, uint32_t _pitch, const void* _data, uint32_t _size, bool _yflip) override {};
218:     virtual void captureBegin(uint32_t _width, uint32_t _height, uint32_t _pitch, bgfx::TextureFormat::Enum _format, bool _yflip) override {};
219:     virtual void captureEnd() override {};
220:     virtual void captureFrame(const void* _data, uint32_t _size) override {};
221: };
222: 
223: // Vertex data structure
224: struct Vertex
225: {
226:     float x;
227:     float y;
228:     float z;
229:     float w;
230:     uint32_t bgra;
231:     float u;
232:     float v;
233:     float nx;
234:     float ny;
235:     float nz;
236: };
237: 
238: class Renderer {
239: private:
240:     friend class Lighting;
241: 
242:     // Current renderer view
243:     enum RendererProgram {
244:         FLAT = 0,
245:         SMOOTH,
246:         SHADOW_MAP,
247:         LIGHTING_FLAT,
248:         LIGHTING_SMOOTH,
249:         FIELD_SHADOW,
250:         POSTPROCESSING,
251:         OVERLAY,
252:         BLIT,
253:         COUNT
254:     };
255: 
256:     struct RendererState
257:     {
258:         std::vector<bgfx::TextureHandle> texHandlers;
259:         bool bTexturesBound = false;
260: 
261:         bool bHasDrawBeenDone = false;
262: 
263:         bool bDoAlphaTest = false;
264:         float alphaRef = 0.0f;
265:         RendererAlphaFunc alphaFunc;
266: 
267:         bool bDoDepthTest = false;
268:         bool bDoDepthWrite = false;
269:         bool bDoScissorTest = false;
270: 
271:         bool bIsTLVertex = false;
272:         bool bIsFBTexture = false;
273:         bool bIsTexture = false;
274:         bool bDoTextureFiltering = false;
275:         bool bDoMirrorTextureWrap = false;
276:         bool bModulateAlpha = false;
277:         bool bIsMovie = false;
278:         bool bIsMovieFullRange = false;
279:         bool bIsMovieYUV = false;
280:         bool bIsExternalTexture = false;
281:         bool bIsHDR = false;
282:         bool bIsFogEnabled = false;
283:         ColorMatrixType bIsMovieColorMatrix = COLORMATRIX_BT601;
284:         ColorGamutType bIsMovieColorGamut = COLORGAMUT_SRGB;
285:         ColorGamutType bIsOverallColorGamut = COLORGAMUT_SRGB;
286:         bool bIsOverrideGamut = false;
287:         InverseGammaFunctionType bIsMovieGammaType = GAMMAFUNCTION_SRGB;
288: 
289:         float backendProjMatrix[16];
290:         float postprocessingProjMatrix[16];
291: 
292:         std::vector<float> VSFlags;
293:         std::vector<float> FSAlphaFlags;
294:         std::vector<float> FSMiscFlags;
295:         std::vector<float> FSHDRFlags;
296:         std::vector<float> FSTexFlags;
297:         std::vector<float> WMFlags;
298:         std::vector<float> FSMovieFlags;
299: 
300:         std::array<float, 4> TimeColor;
301:         std::array<float, 4> TimeData;
302: 
303:         std::array<float, 4> gameLightingFlags;
304:         float gameGlobalLightColor[4] = { 0.0, 0.0, 0.0, 0.0 };
305:         float gameLightDir1[4] = { 0.0, 0.0, 0.0, 0.0 };
306:         float gameLightColor1[4] = { 0.0, 0.0, 0.0, 0.0 };
307:         float gameLightDir2[4] = { 0.0, 0.0, 0.0, 0.0 };
308:         float gameLightColor2[4] = { 0.0, 0.0, 0.0, 0.0 };
309:         float gameLightDir3[4] = { 0.0, 0.0, 0.0, 0.0 };
310:         float gameLightColor3[4] = { 0.0, 0.0, 0.0, 0.0 };
311:         float gameScriptedLightColor[4] = { 0.0, 0.0, 0.0, 0.0 };
312: 
313:         float d3dViewMatrix[16];
314:         float d3dProjectionMatrix[16];
315:         float viewMatrix[16];
316:         float invViewMatrix[16];
317:         float worldViewMatrix[16];
318:         float normalMatrix[16];
319: 
320:         float sphericalWorldRate = 0.0f;
321: 
322:         uint32_t clearColorValue;
323: 
324:         RendererCullMode cullMode = RendererCullMode::DISABLED;
325:         RendererBlendMode blendMode = RendererBlendMode::BLEND_NONE;
326:         RendererPrimitiveType primitiveType = RendererPrimitiveType::PT_TRIANGLES;
327: 
328:         uint64_t state = BGFX_STATE_MSAA;
329: 
330:         bool isViewMatrixSet = false;
331:     };
332: 
333:     std::string vertexPathFlat = "shaders/FFNx";
334:     std::string fragmentPathFlat = "shaders/FFNx";
335:     std::string vertexPathSmooth = "shaders/FFNx";
336:     std::string fragmentPathSmooth = "shaders/FFNx";
337:     std::string vertexPostPath = "shaders/FFNx.post";
338:     std::string fragmentPostPath = "shaders/FFNx.post";
339:     std::string vertexOverlayPath = "shaders/FFNx.overlay";
340:     std::string fragmentOverlayPath = "shaders/FFNx.overlay";
341:     std::string vertexLightingPathFlat = "shaders/FFNx.lighting";
342:     std::string fragmentLightingPathFlat = "shaders/FFNx.lighting";
343:     std::string vertexLightingPathSmooth = "shaders/FFNx.lighting";
344:     std::string fragmentLightingPathSmooth = "shaders/FFNx.lighting";
345:     std::string vertexShadowMapPath = "shaders/FFNx.shadowmap";
346:     std::string fragmentShadowMapPath = "shaders/FFNx.shadowmap";
347:     std::string vertexFieldShadowPath = "shaders/FFNx.field.shadow";
348:     std::string fragmentFieldShadowPath = "shaders/FFNx.field.shadow";
349:     std::string vertexBlitPath = "shaders/FFNx.blit";
350:     std::string fragmentBlitPath = "shaders/FFNx.blit";
351: 
352:     bgfx::ViewId backendViewId = 1;
353:     RendererProgram backendProgram = RendererProgram::SMOOTH;
354: 
355:     std::vector<bgfx::ProgramHandle> backendProgramHandles = std::vector<bgfx::ProgramHandle>(RendererProgram::COUNT, BGFX_INVALID_HANDLE);
356: 
357:     std::vector<bgfx::TextureHandle> backendFrameBufferRT = { BGFX_INVALID_HANDLE, BGFX_INVALID_HANDLE };
358:     bgfx::FrameBufferHandle backendFrameBuffer = BGFX_INVALID_HANDLE;
359: 
360:     bgfx::TextureHandle shadowMapTexture = BGFX_INVALID_HANDLE;
361:     bgfx::FrameBufferHandle shadowMapFrameBuffer = BGFX_INVALID_HANDLE;
362: 
363:     bgfx::TextureHandle specularIblTexture = BGFX_INVALID_HANDLE;
364:     bgfx::TextureHandle diffuseIblTexture = BGFX_INVALID_HANDLE;
365:     bgfx::TextureHandle envBrdfTexture = BGFX_INVALID_HANDLE;
366: 
367:     std::vector<Vertex> vertexBufferData;
368:     bgfx::DynamicVertexBufferHandle vertexBufferHandle = BGFX_INVALID_HANDLE;
369: 
370:     std::vector<WORD> indexBufferData;
371:     bgfx::DynamicIndexBufferHandle indexBufferHandle = BGFX_INVALID_HANDLE;
372: 
373:     bgfx::TextureHandle FFNxLogoHandle = BGFX_INVALID_HANDLE;
374: 
375:     bgfx::TextureHandle GLUTHandleNTSCJtoSRGB = BGFX_INVALID_HANDLE;
376:     bgfx::TextureHandle GLUTHandleSMPTECtoSRGB = BGFX_INVALID_HANDLE;
377:     bgfx::TextureHandle GLUTHandleEBUtoSRGB = BGFX_INVALID_HANDLE;
378:     bgfx::TextureHandle GLUTHandleInverseNTSCJtoSRGB = BGFX_INVALID_HANDLE;
379:     bgfx::TextureHandle GLUTHandleInverseNTSCJtoSMPTEC = BGFX_INVALID_HANDLE;
380:     bgfx::TextureHandle GLUTHandleInverseNTSCJtoEBU = BGFX_INVALID_HANDLE;
381:     bgfx::TextureHandle GLUTHandleSRGBtoNTSCJ = BGFX_INVALID_HANDLE;
382:     bgfx::TextureHandle GLUTHandleSMPTECtoNTSCJ = BGFX_INVALID_HANDLE;
383:     bgfx::TextureHandle GLUTHandleEBUtoNTSCJ = BGFX_INVALID_HANDLE;
384: 
385:     bgfx::VertexLayout vertexLayout;
386: 
387:     std::array<bgfx::UniformHandle, RendererUniform::COUNT> bgfxUniformHandles;
388:     std::array<bgfx::UniformHandle, RendererTextureSlot::COUNT> bgfxTexUniformHandles;
389: 
390:     RendererState internalState;
391: 
392:     uint16_t viewOffsetX = 0;
393:     uint16_t viewOffsetY = 0;
394:     uint16_t viewWidth = 0;
395:     uint16_t viewHeight = 0;
396: 
397:     uint16_t framebufferWidth = 0;
398:     uint16_t framebufferHeight = 0;
399: 
400:     uint16_t scissorOffsetX = 0;
401:     uint16_t scissorOffsetY = 0;
402:     uint16_t scissorWidth = 0;
403:     uint16_t scissorHeight = 0;
404: 
405:     uint16_t framebufferVertexOffsetX = 0;
406:     uint16_t framebufferVertexWidth = 0;
407: 
408:     uint16_t scalingFactor = 0;
409: 
410:     uint32_t createBGRA(uint8_t r, uint8_t g, uint8_t b, uint8_t a);
411:     bgfx::RendererType::Enum getUserChosenRenderer();
412:     void updateRendererShaderPaths();
413:     bgfx::ShaderHandle getShader(const char* filePath);
414: 
415:     bgfx::UniformHandle createUniform(std::string uniformName, bgfx::UniformType::Enum uniformType);
416: 
417:     void destroyUniforms();
418:     void destroyAll();
419: 
420:     void resetState();
421: 
422:     void renderFrame();
423: 
424:     void printMatrix(char* name, float* mat);
425: 
426:     void recalcInternals();
427:     void calcBackendProjMatrix();
428:     void prepareFramebuffer();
429: 
430:     void AssignGamutLUT();
431: 
432:     bx::DefaultAllocator defaultAllocator;
433:     bx::FileWriter defaultWriter;
434:     Overlay overlay;
435: 
436:     bool doCaptureFrame = false;
437: 
438:     bgfx::Init bgfxInit;
439: 
440: public:
441:     std::string currentRenderer;
442: 
443:     // ---
444: 
445:     void init();
446:     void reset();
447:     void prepareFFNxLogo();
448:     void prepareShadowMap();
449:     void prepareSpecularIbl(char* fullpath = nullptr);
450:     void prepareDiffuseIbl(char* fullpath = nullptr);
451:     void prepareEnvBrdf();
452:     void prepareGamutLUTs();
453: 	void LoadGamutLUT(GamutLUTIndexType whichLUT);
454:     void shutdown();
455: 
456:     void clearShadowMap();
457:     void drawToShadowMap(bool uniformsAlreadyAttached = false, bool texturesAlreadyAttached = false);
458:     void drawWithLighting(bool uniformsAlreadyAttached = false, bool texturesAlreadyAttached = false, bool keepBindings = false);
459:     void drawFieldShadow();
460:     void draw(bool uniformsAlreadyAttached = false, bool texturesAlreadyAttached = false, bool keepBindings = false);
461:     void discardAllBindings();
462:     void drawOverlay();
463:     void drawFFNxLogo(float fade);
464:     void show();
465: 
466:     void printText(uint16_t x, uint16_t y, uint32_t attr, const char* text);
467:     void toggleCaptureFrame();
468: 
469:     // ---
470: 
471:     const bgfx::Caps* getCaps();
472:     const bgfx::Stats* getStats();
473:     const bgfx::VertexLayout& GetVertexLayout();
474: 
475:     void bindVertexBuffer(struct nvertex* inVertex, vector3<float>* normals, uint32_t inCount);
476:     void bindIndexBuffer(WORD* inIndex, uint32_t inCount);
477: 
478:     bgfx::UniformHandle setUniform(RendererUniform uniform, const void* uniformValue);
479:     void setCommonUniforms();
480:     void setLightingUniforms();
481:     void bindTextures();
482: 
483:     void setScissor(uint16_t x, uint16_t y, uint16_t width, uint16_t height);
484:     void setClearFlags(bool doClearColor = false, bool doClearDepth = false);
485:     void setBackgroundColor(float r = 0.0f, float g = 0.0f, float b = 0.0f, float a = 0.0f);
486: 
487:     uint32_t createTexture(uint8_t* data, size_t width, size_t height, int stride = 0, RendererTextureType type = RendererTextureType::BGRA, bool isSrgb = true, bool copyData = true);
488:     uint32_t createTexture(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb = true);
489:     bimg::ImageContainer* createImageContainer(const char* filename, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Enum::Count);
490:     bimg::ImageContainer* createImageContainer(cmrc::file* file, bimg::TextureFormat::Enum targetFormat = bimg::TextureFormat::Enum::Count);
491:     bgfx::TextureHandle createTextureHandle(char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb = true);
492:     bgfx::TextureHandle createTextureHandle(cmrc::file* file, char* filename, uint32_t* width, uint32_t* height, uint32_t* mipCount, bool isSrgb = true);
493:     uint32_t createTextureLibPng(char* filename, uint32_t* width, uint32_t* height, bool isSrgb = true);
494:     bool saveTexture(const char* filename, uint32_t width, uint32_t height, const void* data);
495:     void deleteTexture(uint16_t texId);
496:     void useTexture(uint16_t texId, uint32_t slot = 0);
497:     uint32_t createBlitTexture(uint32_t x, uint32_t y, uint32_t width, uint32_t height);
498:     void blitTexture(uint16_t dest, uint32_t x, uint32_t y, uint32_t width, uint32_t height);
499:     void zoomBackendFrameBuffer(int x, int y, int width, int height);
500:     void clearDepthBuffer();
501: 
502:     void isMovie(bool flag = false);
503:     void isTLVertex(bool flag = false);
504:     void setBlendMode(RendererBlendMode mode = RendererBlendMode::BLEND_NONE);
505:     void isTexture(bool flag = false);
506:     void isFBTexture(bool flag = false);
507:     void isFullRange(bool flag = false);
508:     void isYUV(bool flag = false);
509:     void doModulateAlpha(bool flag = false);
510:     void doTextureFiltering(bool flag = false);
511:     void doMirrorTextureWrap(bool flag = false);
512:     void isExternalTexture(bool flag = false);
513:     bool isHDR();
514:     void setColorMatrix(ColorMatrixType cmtype = COLORMATRIX_BT601);
515:     void setColorGamut(ColorGamutType cgtype = COLORGAMUT_SRGB);
516:     void setOverallColorGamut(ColorGamutType cgtype = COLORGAMUT_SRGB);
517:     void setGammaType(InverseGammaFunctionType gtype = GAMMAFUNCTION_SRGB);
518:     void setGamutOverride(bool flag = false);
519: 
520:     // Alpha mode emulation
521:     void setAlphaRef(RendererAlphaFunc func = RendererAlphaFunc::ALWAYS, float ref = 0.0f);
522:     void doAlphaTest(bool flag = false);
523: 
524:     // Internal states
525:     void setInterpolationQualifier(RendererInterpolationQualifier qualifier = RendererInterpolationQualifier::SMOOTH);
526:     void setPrimitiveType(RendererPrimitiveType type = RendererPrimitiveType::PT_TRIANGLES);
527:     void setCullMode(RendererCullMode mode = RendererCullMode::DISABLED);
528:     void doDepthTest(bool flag = false);
529:     void doDepthWrite(bool flag = false);
530: 
531:     // Scissor test
532:     void doScissorTest(bool flag = false);
533: 
534:     // Wireframe mode
535:     void setWireframeMode(bool flag = false);
536: 
537:     // Viewport
538:     void setViewMatrix(struct matrix* matrix);
539:     float* getViewMatrix();
540:     float* getInvViewMatrix();
541:     bool isViewMatrixSet();
542:     void resetViewMatrixFlag();
543:     void setWorldViewMatrix(struct matrix* matrix, bool calculateNormalMatrix = true);
544:     float* getWorldViewMatrix();
545:     float* getNormalMatrix();
546:     void setD3DViweport(struct matrix* matrix);
547:     void setD3DProjection(struct matrix* matrix);
548: 
549:     // Internal coord calculation
550:     uint16_t getInternalCoordX(uint16_t inX);
551:     uint16_t getInternalCoordY(uint16_t inY);
552: 
553:     // Internal scaling factor
554:     uint16_t getScalingFactor();
555: 
556:     // Day-night time cycle
557:     void setTimeColor(bx::Vec3 color);
558:     void setTimeEnabled(bool flag = false);
559:     void setTimeFilterEnabled(bool flag = false);
560:     bool isTimeFilterEnabled();
561: 
562:     // Worldmap
563:     void setSphericalWorldRate(float value = 0.0f);
564:     void setFogEnabled(bool flag = false);
565:     bool isFogEnabled();
566: 
567:     // Game lighting
568:     void setGameLightData(light_data* lightdata = nullptr);
569: 
570:     static bool doesItFitInMemory(size_t size);
571: };
572: 
573: extern Renderer newRenderer;
</file>

<file path="src/saveload.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Cosmos                                             //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <stdio.h>
 24: #include <direct.h>
 25: #include "renderer.h"
 26: 
 27: #include "log.h"
 28: #include "gl.h"
 29: #include "utils.h"
 30: 
 31: #include <xxhash.h>
 32: 
 33: // TEMPORARY! WILL BE REMOVED AFTER MIGRATION.
 34: #include <iostream>
 35: #include <fstream>
 36: #include <filesystem>
 37: // -------------------------------------------
 38: 
 39: std::map<uint16_t, std::string> additional_textures = {
 40: 	{RendererTextureSlot::TEX_NML, "nml"},
 41: 	{RendererTextureSlot::TEX_PBR, "pbr"}
 42: };
 43: 
 44: void make_path(const char *name)
 45: {
 46: 	const char *next = name;
 47: 
 48: 	while((next = strchr(next, '/')))
 49: 	{
 50: 		char tmp[128];
 51: 
 52: 		while(next[0] == '/') next++;
 53: 
 54: 		strncpy(tmp, name, next - name);
 55: 		tmp[next - name] = 0;
 56: 
 57: 		_mkdir(tmp);
 58: 	}
 59: }
 60: 
 61: void normalize_path(char *name)
 62: {
 63: 	if (ff8)
 64: 	{
 65: 		int idx = 0;
 66: 		while (name[idx] != 0)
 67: 		{
 68: 			if (name[idx] == '\\') name[idx] = '/';
 69: 			idx++;
 70: 		}
 71: 	}
 72: }
 73: 
 74: void save_texture(const void *data, uint32_t dataSize, uint32_t width, uint32_t height, uint32_t palette_index, const char *name, bool is_animated)
 75: {
 76: 	char filename[sizeof(basedir) + 1024];
 77: 	uint64_t hash;
 78: 
 79: 	if (!save_textures && !save_textures_legacy) {
 80: 		ffnx_warning("Save texture skipped because the option \"save_textures\" is disabled (name=%s).\n", name);
 81: 
 82: 		return;
 83: 	}
 84: 
 85: 	if (is_animated)
 86: 	{
 87: 		char xxhash_filename[sizeof(basedir) + 1024];
 88: 		hash = XXH3_64bits(data, dataSize);
 89: 		_snprintf(xxhash_filename, sizeof(xxhash_filename), "%s/%s/%s_%02i_%llx.png", basedir, mod_path.c_str(), name, palette_index, hash);
 90: 	}
 91: 	else if (palette_index == uint32_t(-1))
 92: 	{
 93: 		_snprintf(filename, sizeof(filename), "%s/%s/%s.png", basedir, mod_path.c_str(), name);
 94: 	}
 95: 	else if (palette_index & 0x40000000)
 96: 	{
 97: 		_snprintf(filename, sizeof(filename), "%s/%s/%s_%u_%u.png", basedir, mod_path.c_str(), name, (palette_index & 0x7FFF), ((palette_index & 0x3FFFFFFF) >> 15) & 0x7FFF);
 98: 	}
 99: 	else
100: 	{
101: 		_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i.png", basedir, mod_path.c_str(), name, palette_index);
102: 	}
103: 
104: 	normalize_path(filename);
105: 
106: 	make_path(filename);
107: 
108: 	if (!fileExists(filename))
109: 	{
110: 		if (!newRenderer.saveTexture(filename, width, height, data)) ffnx_error("Save texture failed for the file [ %s ].\n", filename);
111: 	}
112: 	else
113: 		ffnx_warning("Save texture skipped because the file [ %s ] already exists.\n", filename);
114: }
115: 
116: uint32_t load_texture_helper(char* name, uint32_t* width, uint32_t* height, bool useLibPng, bool isSrgb)
117: {
118: 	uint32_t ret = 0;
119: 
120: 	normalize_path(name);
121: 
122: 	if (useLibPng)
123: 		ret = newRenderer.createTextureLibPng(name, width, height, isSrgb);
124: 	else
125: 	{
126: 		uint32_t mipCount = 0;
127: 		ret = newRenderer.createTexture(name, width, height, &mipCount, isSrgb);
128: 	}
129: 
130: 	if (ret)
131: 	{
132: 		if (trace_all || trace_loaders) ffnx_trace("Using texture: %s\n", name);
133: 	}
134: 
135: 	return ret;
136: }
137: 
138: uint32_t load_normal_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set, std::string tex_path)
139: {
140: 	uint32_t ret = 0;
141: 	char filename[sizeof(basedir) + 1024]{ 0 };
142: 
143: 	for (int idx = 0; idx < mod_ext.size(); idx++)
144: 	{
145: 		if (palette_index == uint32_t(-1))
146: 		{
147: 			_snprintf(filename, sizeof(filename), "%s/%s/%s.%s", basedir, tex_path.c_str(), name, mod_ext[idx].c_str());
148: 		}
149: 		else if (palette_index & 0x40000000)
150: 		{
151: 			_snprintf(filename, sizeof(filename), "%s/%s/%s_%u_%u.%s", basedir, tex_path.c_str(), name, (palette_index & 0x7FFF), ((palette_index & 0x3FFFFFFF) >> 15) & 0x7FFF, mod_ext[idx].c_str());
152: 		}
153: 		else
154: 		{
155: 			_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i.%s", basedir, tex_path.c_str(), name, palette_index, mod_ext[idx].c_str());
156: 		}
157: 
158: 		ret = load_texture_helper(filename, width, height, mod_ext[idx] == "png", true);
159: 
160: 		if(ret)
161: 		{
162: 			if (trace_all) ffnx_trace("Created external texture: %u from %s\n", ret, filename);
163: 			break;
164: 		}
165: 	}
166: 
167: 	if(!ret)
168: 	{
169: 		if(palette_index != uint32_t(-1) && (palette_index & 0x3FFFFFFF) != 0)
170: 		{
171: 			if(trace_all || show_missing_textures) ffnx_info("No external texture found [%s], falling back to palette 0\n", filename);
172: 			if(gl_set->default_texture_id)
173: 			{
174: 				return gl_set->default_texture_id;
175: 			}
176: 			else
177: 			{
178: 				gl_set->default_texture_id = load_normal_texture(data, dataSize, name, (palette_index & 0xC0000000) == 0xC0000000 ? -1 : (palette_index & 0x40000000), width, height, gl_set, tex_path);
179: 
180: 				return gl_set->default_texture_id;
181: 			}
182: 		}
183: 		else
184: 		{
185: 			if(trace_all || show_missing_textures) ffnx_info("No external texture found [%s], switching back to the internal one.\n", filename);
186: 			return 0;
187: 		}
188: 	}
189: 	else
190: 	{
191: 		// Load additional textures
192: 		for (const auto& it : additional_textures)
193: 		{
194: 			for (int idx = 0; idx < mod_ext.size(); idx++)
195: 			{
196: 				if (palette_index == uint32_t(-1))
197: 				{
198: 					_snprintf(filename, sizeof(filename), "%s/%s/%s_%s.%s", basedir, tex_path.c_str(), name, it.second.c_str(), mod_ext[idx].c_str());
199: 				}
200: 				else if (palette_index & 0x40000000)
201: 				{
202: 					_snprintf(filename, sizeof(filename), "%s/%s/%s_%u_%u_%s.%s", basedir, tex_path.c_str(), name, (palette_index & 0x7FFF), ((palette_index & 0x3FFFFFFF) >> 15) & 0x7FFF, it.second.c_str(), mod_ext[idx].c_str());
203: 				}
204: 				else
205: 				{
206: 					_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i_%s.%s", basedir, tex_path.c_str(), name, palette_index, it.second.c_str(), mod_ext[idx].c_str());
207: 				}
208: 
209: 				if (fileExists(filename))
210: 				{
211: 					if (gl_set->additional_textures.count(it.first)) newRenderer.deleteTexture(gl_set->additional_textures[it.first]);
212: 					gl_set->additional_textures[it.first] = load_texture_helper(filename, width, height, mod_ext[idx] == "png", false);
213: 					break;
214: 				}
215: 				else if (trace_all || show_missing_textures)
216: 				{
217: 					ffnx_trace("Could not find [ %s ].\n", filename);
218: 				}
219: 			}
220: 		}
221: 	}
222: 
223: 	return ret;
224: }
225: 
226: uint32_t load_animated_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set, std::string tex_path)
227: {
228: 	uint32_t ret = 0;
229: 	char filename[sizeof(basedir) + 1024]{ 0 };
230: 	uint64_t hash = XXH3_64bits(data, dataSize);
231: 	char texture_key[1024] { 0 };
232: 	_snprintf(texture_key, sizeof(texture_key), "%s_%02i_%llx", name, palette_index, hash);
233: 
234: 	// If texture has been cached, return immediately its handler
235: 	if (gl_set->animated_textures.contains(texture_key))
236: 	{
237: 		return gl_set->animated_textures[texture_key];
238: 	}
239: 
240: 	// Check for animated texture with hash
241: 	for (int idx = 0; idx < mod_ext.size(); idx++)
242: 	{
243: 		_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i_%llx.%s", basedir, tex_path.c_str(), name, palette_index, hash, mod_ext[idx].c_str());
244: 
245: 		ret = load_texture_helper(filename, width, height, mod_ext[idx] == "png", true);
246: 
247: 		if(ret)
248: 		{
249: 			if(trace_all) ffnx_trace("Created animated external texture: %u from %s\n", ret, filename);
250: 			gl_set->animated_textures[texture_key] = ret;
251: 			return ret;
252: 		}
253: 
254: 		if (trace_all || show_missing_textures) ffnx_trace("Could not find animated texture [ %s ].\n", filename);
255: 	}
256: 
257: 	// If animated texture not found, check for base texture
258: 	for (int idx = 0; idx < mod_ext.size(); idx++)
259: 	{
260: 		_snprintf(filename, sizeof(filename), "%s/%s/%s_%02i.%s", basedir, tex_path.c_str(), name, palette_index, mod_ext[idx].c_str());
261: 
262: 		ret = load_texture_helper(filename, width, height, mod_ext[idx] == "png", true);
263: 
264: 		if(ret)
265: 		{
266: 			if(trace_all) ffnx_trace("Created external texture: %u from %s\n", ret, filename);
267: 			gl_set->animated_textures[texture_key] = ret;
268: 			return ret;
269: 		}
270: 
271: 		if (trace_all || show_missing_textures) ffnx_trace("Could not find base texture [ %s ].\n", filename);
272: 	}
273: 
274: 	// Finally, if everything fails, return the one with palette index 0 or no texture
275: 	if(palette_index != 0)
276: 	{
277: 		if(trace_all || show_missing_textures) ffnx_info("No external texture found, falling back to palette 0\n");
278: 		if(gl_set->default_texture_id)
279: 		{
280: 			ret = gl_set->default_texture_id;
281: 		}
282: 		else
283: 		{
284: 			ret = load_animated_texture(data, dataSize, name, 0, width, height, gl_set, tex_path);
285: 			gl_set->default_texture_id = ret;
286: 		}
287: 		if(ret) gl_set->animated_textures[texture_key] = ret;
288: 		return ret;
289: 	}
290: 	else
291: 	{
292: 		if(tex_path == mod_path) // Are we on the last lookup layer?
293: 		{
294: 			if(trace_all || show_missing_textures) ffnx_info("No external texture found, switching back to the internal one.\n");
295: 			gl_set->animated_textures[texture_key] = 0; // short circuit and prevent further lookups
296: 		}
297: 		else if(trace_all || show_missing_textures) ffnx_info("No external texture found.\n");
298: 
299: 		return 0;
300: 	}
301: 
302: }
303: 
304: uint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)
305: {
306: 	uint32_t ret = 0;
307: 
308: 	if(gl_set->is_animated)
309: 	{
310: 		if (!override_mod_path.empty())
311: 			ret = load_animated_texture(data, dataSize, name, palette_index, width, height, gl_set, override_mod_path);
312: 
313: 		if (ret == 0)
314: 			ret = load_animated_texture(data, dataSize, name, palette_index, width, height, gl_set, mod_path);
315: 	}
316: 	else
317: 	{
318: 		if (!override_mod_path.empty())
319: 			ret = load_normal_texture(data, dataSize, name, palette_index, width, height, gl_set, override_mod_path);
320: 
321: 		if (ret == 0)
322: 			ret = load_normal_texture(data, dataSize, name, palette_index, width, height, gl_set, mod_path);
323: 	}
324: 
325: 	return ret;
326: }
</file>

<file path="src/saveload.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <stdint.h>
25: 
26: void make_path(const char *name);
27: void normalize_path(char *name);
28: void save_texture(const void *data, uint32_t dataSize, uint32_t width, uint32_t height, uint32_t palette_index, const char *name, bool is_animated);
29: uint32_t load_texture(const void *data, uint32_t dataSize, const char *name, uint32_t palette_index, uint32_t *width, uint32_t *height, struct gl_texture_set* gl_set);
</file>

<file path="src/sfx.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #include "audio.h"
 23: #include "patch.h"
 24: #include "ff7.h"
 25: 
 26: #include "sfx.h"
 27: 
 28: uint32_t sfx_volumes[5];
 29: ff7_field_sfx_state sfx_buffers[4];
 30: uint32_t real_volume;
 31: ff7_field_sfx_state* sfx_state = nullptr;
 32: ff7_channel_6_state sfx_channel_6_state;
 33: 
 34: constexpr auto FF8_MAX_CHANNEL_NUMBER = 0x1F;
 35: 
 36: //=============================================================================
 37: 
 38: void ff7_sfx_release(IDirectSoundBuffer *buffer)
 39: {
 40: 	if (buffer) buffer->Release();
 41: }
 42: 
 43: bool ff7_should_sfx_loop(int id)
 44: {
 45: 	return ff7_externals.sfx_fmt_header[id-1].loop;
 46: }
 47: 
 48: void ff7_sfx_stop_channel(int channel, double time = 0)
 49: {
 50: 	nxAudioEngine.stopSFX(channel, time);
 51: 
 52: 	sfx_state[channel-1].pan1 = 64;
 53: 	sfx_state[channel-1].sound_id = 0;
 54: 	sfx_state[channel-1].is_looped = false;
 55: }
 56: 
 57: void ff8_sfx_stop_channel(int channel, double time = 0)
 58: {
 59: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);
 60: 
 61: 	if (channel <= FF8_MAX_CHANNEL_NUMBER)
 62: 	{
 63: 		nxAudioEngine.stopSFX(channel, time);
 64: 	}
 65: }
 66: 
 67: int ff7_sfx_load(int id, DWORD dsound_flag)
 68: {
 69: 	//if (trace_all || trace_sfx) ffnx_trace("%s: id=%d\n", __func__, id);
 70: 
 71: 	return true;
 72: }
 73: 
 74: unsigned int ff8_sfx_load(unsigned int channel, unsigned int id, int is_eax)
 75: {
 76: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d id=%d is_eax=%d\n", __func__, channel, id, is_eax);
 77: 
 78: 	return true;
 79: }
 80: 
 81: void ff7_sfx_unload(int id, void* unk)
 82: {
 83: 	if (trace_all || trace_sfx) ffnx_trace("%s: id=%d\n", __func__, id);
 84: 
 85: 	nxAudioEngine.unloadSFX(id);
 86: }
 87: 
 88: void ff8_sfx_unload(int channel)
 89: {
 90: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);
 91: 
 92: 	nxAudioEngine.unloadSFX(nxAudioEngine.getSFXIdFromChannel(channel));
 93: }
 94: 
 95: void ff8_sfx_set_master_volume(uint32_t volume)
 96: {
 97: 	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%d\n", __func__, volume);
 98: 
 99: 	if (volume <= 100) {
100: 		*common_externals.master_sfx_volume = volume;
101: 		nxAudioEngine.setSFXMasterVolume(volume / 100.0);
102: 	}
103: }
104: 
105: void ff7_sfx_set_volume_on_channel(byte volume, int channel)
106: {
107: 	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%d,channel=%d\n", __func__, volume, channel);
108: 
109: 	sfx_state[channel].volume1 = volume;
110: 
111: 	nxAudioEngine.setSFXVolume(channel, volume / 127.0f);
112: }
113: 
114: void ff8_sfx_set_volume(uint32_t channel, uint32_t volume, int32_t time)
115: {
116: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d, volume=%d, time=%d\n", __func__, channel, volume, time);
117: 
118: 	if (volume == 0)
119: 		ff8_sfx_stop_channel(channel, time / 60.0f);
120: 	else if (channel <= FF8_MAX_CHANNEL_NUMBER && volume <= 127)
121: 		nxAudioEngine.setSFXVolume(channel, volume / 127.0f, time / 60.0f);
122: }
123: 
124: void ff7_sfx_set_volume_trans_on_channel(byte volume, int channel, int time)
125: {
126: 	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%d,channel=%d,time=%d\n", __func__, volume, channel, time);
127: 
128: 	if (volume == 0)
129: 		ff7_sfx_stop_channel(channel, time / 60.0f);
130: 	else
131: 		nxAudioEngine.setSFXVolume(channel, volume / 127.0f, time / 60.0f);
132: }
133: 
134: void ff7_sfx_set_panning_on_channel(byte panning, int channel)
135: {
136: 	if (trace_all || trace_sfx) ffnx_trace("%s: panning=%d,channel=%d\n", __func__, panning, channel);
137: 
138: 	sfx_state[channel].pan1 = panning;
139: 
140: 	if (panning <= 127)
141: 		nxAudioEngine.setSFXPanning(channel, panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f);
142: }
143: 
144: void ff8_sfx_set_panning(uint32_t channel, uint32_t panning, int32_t time)
145: {
146: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d, panning=%d, time=%d\n", __func__, channel, panning, time);
147: 
148: 	if (channel <= FF8_MAX_CHANNEL_NUMBER && panning <= 127)
149: 	{
150: 		// TODO: inverted panning option ((Reg.SoundOptions >> 20) & 1)
151: 		nxAudioEngine.setSFXPanning(channel, panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f);
152: 		// TODO: 3D sfx
153: 	}
154: }
155: 
156: void ff7_sfx_set_panning_trans_on_channel(byte panning, int channel, int time)
157: {
158: 	if (trace_all || trace_sfx) ffnx_trace("%s: panning=%d,channel=%d,time=%d\n", __func__, panning, channel, time);
159: 
160: 	if (panning <= 127)
161: 		nxAudioEngine.setSFXPanning(channel, panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f, time / 60.0f);
162: }
163: 
164: void ff7_sfx_set_frequency_on_channel(byte speed, int channel)
165: {
166: 	if (trace_all || trace_sfx) ffnx_trace("%s: speed=%d,channel=%d\n", __func__, speed, channel);
167: 
168: 	sfx_state[channel].frequency = speed;
169: 
170: 	if (speed == -128) {
171: 		speed = -127; // Prevent speed to be 0 (can crash with SoLoud)
172: 	}
173: 
174: 	nxAudioEngine.setSFXSpeed(channel, float(speed) / 128.0f + 1.0f);
175: }
176: 
177: void ff7_sfx_set_frequency_trans_on_channel(byte speed, int channel, int time)
178: {
179: 	if (trace_all || trace_sfx) ffnx_trace("%s: speed=%d,channel=%d,time=%d\n", __func__, speed, channel, time);
180: 
181: 	if (speed == -128) {
182: 		speed = -127; // Prevent speed to be 0 (can crash with SoLoud)
183: 	}
184: 
185: 	nxAudioEngine.setSFXSpeed(channel, float(speed) / 128.0f + 1.0f, time / 60.0f);
186: }
187: 
188: bool ff7_sfx_play_layered(float panning, int id, int channel)
189: {
190: 	const struct game_mode* mode = getmode_cached();
191: 	bool playing = false;
192: 	char track_name[64];
193: 	byte actor_id = 0xFF;
194: 
195: 	switch(mode->driver_mode)
196: 	{
197: 	case MODE_FIELD:
198: 		sprintf(track_name, "%s_%d_%d", get_current_field_name(), *common_externals.current_triangle_id, id);
199: 		break;
200: 	case MODE_MENU:
201: 	case MODE_MAIN_MENU:
202: 		sprintf(track_name, "menu_%d", id);
203: 		break;
204: 	case MODE_WORLDMAP:
205: 		sprintf(track_name, "world_%d", id);
206: 		break;
207: 	case MODE_BATTLE:
208: 		actor_id = ff7_externals.anim_event_queue[0].attackerID;
209: 		if(actor_id >= 0 && actor_id <= 2)
210: 			sprintf(track_name, "battle_char_%02X_%d", ff7_externals.battle_context->actor_vars[actor_id].index, id);
211: 		else if(actor_id >= 4 && actor_id <= 9)
212: 			sprintf(track_name, "battle_enemy_%04X_%d", ff7_externals.battle_context->actor_vars[actor_id].formationID, id);
213: 		else
214: 			sprintf(track_name, "%d", id);
215: 		break;
216: 	default:
217: 		sprintf(track_name, "%d", id);
218: 	}
219: 
220: 	// If any overridden layer could not be played, fallback to default
221: 	if (!(playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id))))
222: 	{
223: 		if (mode->driver_mode == MODE_FIELD)
224: 		{
225: 			sprintf(track_name, "%s_%d", get_current_field_name(), id);
226: 			if (!(playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id))))
227: 			{
228: 				sprintf(track_name, "%d", id);
229: 				playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id));
230: 			}
231: 		}
232: 		else
233: 		{
234: 			sprintf(track_name, "%d", id);
235: 			playing = nxAudioEngine.playSFX(track_name, id, channel, panning, ff7_should_sfx_loop(id));
236: 		}
237: 	}
238: 
239: 	return playing;
240: }
241: 
242: bool ff8_sfx_play_layered(int channel, int id, int volume, float panning)
243: {
244: 	const struct game_mode* mode = getmode_cached();
245: 	bool playing = false;
246: 	char track_name[64];
247: 	float panningf = panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f;
248: 	float volumef = volume / 127.0f;
249: 	bool loop = false;
250: 
251: 	// Get loop info from audio.fmt
252: 	if (id <= *ff8_externals.sfx_sound_count) {
253: 		loop = (*ff8_externals.sfx_audio_fmt)[id].loop;
254: 	}
255: 
256: 	// TODO: inverted panning option ((Reg.SoundOptions >> 20) & 1)
257: 
258: 	switch(mode->driver_mode)
259: 	{
260: 	case MODE_FIELD:
261: 		sprintf(track_name, "%s_%d_%d", get_current_field_name(), *common_externals.current_triangle_id, id);
262: 		playing = nxAudioEngine.playSFX(track_name, id, channel, panningf, loop, volumef);
263: 		if (!playing) sprintf(track_name, "%s_%d", get_current_field_name(), id);
264: 		break;
265: 	case MODE_MENU:
266: 	case MODE_MAIN_MENU:
267: 		sprintf(track_name, "menu_%d", id);
268: 		break;
269: 	case MODE_WORLDMAP:
270: 		sprintf(track_name, "world_%d", id);
271: 		break;
272: 	case MODE_BATTLE:
273: 		sprintf(track_name, "battle_%d", id);
274: 		break;
275: 	default:
276: 		sprintf(track_name, "%d", id);
277: 	}
278: 
279: 	// If any overridden layer could not be played, fallback to default
280: 	if (!(playing = nxAudioEngine.playSFX(track_name, id, channel, panningf, loop, volumef)))
281: 	{
282: 		sprintf(track_name, "%d", id);
283: 		playing = nxAudioEngine.playSFX(track_name, id, channel, panningf, loop, volumef);
284: 	}
285: 
286: 	return playing;
287: }
288: 
289: void ff7_sfx_play_on_channel(byte panning, int id, int channel)
290: {
291: 	if (trace_all || trace_sfx) ffnx_trace("%s: id=%d,channel=%d,panning=%d\n", __func__, id, channel, panning);
292: 
293: 	ff7_field_sfx_state *currentState = &sfx_state[channel-1];
294: 
295: 	if (id)
296: 	{
297: 		for (int chdx = 1; chdx <= 5; chdx++)
298: 		{
299: 			if(sfx_state[chdx-1].sound_id == id && sfx_state[chdx-1].is_looped && chdx != channel)
300: 			{
301: 				ff7_sfx_stop_channel(chdx);
302: 				return;
303: 			}
304: 		}
305: 
306: 		if (channel <= 5 && ((currentState->sound_id == id && !currentState->is_looped) || (currentState->sound_id != id))) ff7_sfx_stop_channel(channel);
307: 
308: 		if (currentState->sound_id != id) currentState->is_looped = false;
309: 
310: 		if (!currentState->is_looped)
311: 		{
312: 			ff7_sfx_play_layered(panning == 64 ? 0.0f : panning * 2 / 127.0f - 1.0f, id, channel);
313: 		}
314: 
315: 		currentState->pan1 = panning;
316: 		currentState->sound_id = id;
317: 		currentState->is_looped = ff7_should_sfx_loop(id);
318: 	}
319: 	else if ( channel < 6) // normally all sounds that are non-channel aware must never be stopped by the engine
320: 	{
321: 		ff7_sfx_stop_channel(channel);
322: 	}
323: }
324: 
325: int ff8_sfx_play_channel(unsigned int channel, unsigned int id, unsigned int volume, unsigned int panning, int pitch)
326: {
327: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d, id=%d, volume=%d, panning=%d, pitch=%d\n", __func__, channel, id, volume, panning, pitch);
328: 
329: 	if (channel > FF8_MAX_CHANNEL_NUMBER || volume > 127 || panning > 127)
330: 	{
331: 		return 0;
332: 	}
333: 
334: 	// pitch is always 100
335: 	return ff8_sfx_play_layered(channel, id, volume, panning);
336: }
337: 
338: void ff7_sfx_play_on_channel_5(int id)
339: {
340: 	ff7_sfx_play_on_channel(64, id, 5);
341: }
342: 
343: void ff7_sfx_load_and_play_with_speed(int id, byte panning, byte volume, byte speed)
344: {
345: 	const int _channel = 6;
346: 
347: 	if (trace_all || trace_sfx) ffnx_trace("%s: id=%d,volume=%d,panning=%d,speed=%d\n", __func__, id, volume, panning, speed);
348: 
349: 	if (id)
350: 	{
351: 		ff7_sfx_set_volume_on_channel(volume, _channel);
352: 		ff7_sfx_set_frequency_on_channel(speed, _channel);
353: 		ff7_sfx_play_on_channel(panning, id, _channel);
354: 	}
355: }
356: 
357: bool ff8_sfx_is_playing(int channel)
358: {
359: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);
360: 
361: 	return channel <= FF8_MAX_CHANNEL_NUMBER ? nxAudioEngine.isSFXPlaying(channel) : false;
362: }
363: 
364: void ff7_sfx_pause()
365: {
366: 	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);
367: 
368: 	for (short channel = 1; channel <= 6; channel++) nxAudioEngine.pauseSFX(channel);
369: }
370: 
371: void ff8_sfx_pause_channel(int channel)
372: {
373: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);
374: 
375: 	if (channel <= FF8_MAX_CHANNEL_NUMBER)
376: 	{
377: 		nxAudioEngine.pauseSFX(channel);
378: 	}
379: }
380: 
381: void ff7_sfx_resume()
382: {
383: 	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);
384: 
385: 	for (short channel = 1; channel <= 6; channel++) nxAudioEngine.resumeSFX(channel);
386: }
387: 
388: void ff8_sfx_resume_channel(int channel)
389: {
390: 	if (trace_all || trace_sfx) ffnx_trace("%s: channel=%d\n", __func__, channel);
391: 
392: 	if (channel <= FF8_MAX_CHANNEL_NUMBER)
393: 	{
394: 		nxAudioEngine.resumeSFX(channel);
395: 	}
396: }
397: 
398: void ff7_sfx_stop()
399: {
400: 	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);
401: 
402: 	for (short channel = 1; channel <= 6; channel++)
403: 		ff7_sfx_stop_channel(channel);
404: 
405: 	*ff7_externals.sfx_play_effects_id_channel_6 = 0;
406: }
407: 
408: // Channel 6 only
409: 
410: void ff7_sfx_set_frequency_on_channel_6(void* dsoundptr, DWORD frequency)
411: {
412: 	if (trace_all || trace_sfx) ffnx_trace("%s: frequency=%lu\n", __func__, frequency);
413: 
414: 	// TODO: IMPLEMENT PITCH?
415: }
416: 
417: void ff7_sfx_set_panning_on_channel_6(void* dsoundptr, LONG panning)
418: {
419: 	sfx_channel_6_state.panning = (panning / 10000.0f);
420: 
421: 	if (trace_all || trace_sfx) ffnx_trace("%s: panning=%ld,calculated=%f\n", __func__, panning, sfx_channel_6_state.panning);
422: }
423: 
424: void ff7_sfx_set_volume_on_channel_6(void* dsoundptr, LONG volume)
425: {
426: 	sfx_channel_6_state.volume = (volume / 10000.0f) + 1.0f;
427: 
428: 	if (trace_all || trace_sfx) ffnx_trace("%s: volume=%ld,calculated=%f\n", __func__, volume, sfx_channel_6_state.volume);
429: }
430: 
431: void ff7_sfx_play_on_channel_6(void* dsoundptr, int unk)
432: {
433: 	if (trace_all || trace_sfx) ffnx_trace("%s: id=%lu,panning=%f\n", __func__, *ff7_externals.sfx_play_effects_id_channel_6, sfx_channel_6_state.panning);
434: 
435: 	nxAudioEngine.setSFXVolume(6, sfx_channel_6_state.volume);
436: 	ff7_sfx_play_layered(sfx_channel_6_state.panning, *ff7_externals.sfx_play_effects_id_channel_6, 6);
437: }
438: 
439: void ff7_sfx_stop_channel_6()
440: {
441: 	if (trace_all || trace_sfx) ffnx_trace("%s\n", __func__);
442: 
443: 	nxAudioEngine.stopSFX(6);
444: 
445: 	if (*ff7_externals.sfx_stop_channel_timer_handle) timeKillEvent(*ff7_externals.sfx_stop_channel_timer_handle);
446: 
447: 	*ff7_externals.sfx_stop_channel_timer_handle = 0;
448: }
449: 
450: //=============================================================================
451: 
452: bool sfx_buffer_is_looped(IDirectSoundBuffer* buffer)
453: {
454: 	if (buffer == nullptr) {
455: 		return false;
456: 	}
457: 
458: 	DWORD status;
459: 	buffer->GetStatus(&status);
460: 
461: 	if (status & (DSBSTATUS_LOOPING | DSBSTATUS_PLAYING)) {
462: 		return true;
463: 	}
464: 
465: 	return false;
466: }
467: 
468: uint32_t sfx_operation_battle_swirl_stop_sound(uint32_t type, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4, uint32_t param5)
469: {
470: 	if (trace_all || trace_sfx) ffnx_info("%s: Battle swirl stop sound\n", __func__);
471: 
472: 	for (int i = 0; i < 4; ++i) {
473: 		sfx_buffers[i] = ff7_field_sfx_state();
474: 		sfx_buffers[i].buffer1 = nullptr;
475: 		sfx_buffers[i].buffer2 = nullptr;
476: 
477: 		if (use_external_sfx)
478: 		{
479: 			// Check which SFX effects are still playing on channels before saving their state. If not, avoid playing them back.
480: 			if (!nxAudioEngine.isSFXPlaying(i+1)) sfx_state[i].sound_id = 0;
481: 		}
482: 
483: 		// Save sfx state for looped sounds in channel 1 -> 4 (not channel 5)
484: 		if (sfx_buffer_is_looped(sfx_state[i].buffer1) || sfx_buffer_is_looped(sfx_state[i].buffer2) || use_external_sfx) {
485: 			memcpy(&sfx_buffers[i], &sfx_state[i], sizeof(ff7_field_sfx_state));
486: 		}
487: 	}
488: 
489: 	return ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(type, param1, param2, param3, param4, param5);
490: }
491: 
492: uint32_t sfx_operation_resume_music(uint32_t type, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4, uint32_t param5)
493: {
494: 	if (trace_all || trace_sfx) ffnx_info("%s: Field resume music after battle\n", __func__);
495: 
496: 	for (int i = 0; i < 4; ++i) {
497: 		if (use_external_sfx)
498: 		{
499: 			ff7_sfx_play_on_channel(sfx_buffers[i].pan1, sfx_buffers[i].sound_id, i + 1);
500: 		}
501: 		else
502: 		{
503: 			if (sfx_buffers[i].buffer1 != nullptr || sfx_buffers[i].buffer2 != nullptr) {
504: 				uint32_t pan;
505: 				if (sfx_buffers[i].buffer1 != nullptr) {
506: 					pan = sfx_buffers[i].pan1;
507: 				}
508: 				else {
509: 					pan = sfx_buffers[i].pan2;
510: 				}
511: 
512: 				((uint32_t(*)(uint32_t, uint32_t, uint32_t))common_externals.play_sfx_on_channel)(pan, sfx_buffers[i].sound_id, i + 1);
513: 
514: 				sfx_buffers[i] = ff7_field_sfx_state();
515: 				sfx_buffers[i].buffer1 = nullptr;
516: 				sfx_buffers[i].buffer2 = nullptr;
517: 			}
518: 		}
519: 	}
520: 
521: 	return ((uint32_t(*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))ff7_externals.sound_operation)(type, param1, param2, param3, param4, param5);
522: }
523: 
524: void sfx_remember_volumes()
525: {
526: 	if (trace_all || trace_sfx) ffnx_info("%s: Remember SFX volumes (master: %i)\n", __func__, *common_externals.master_sfx_volume);
527: 
528: 	for (int i = 0; i < 5; ++i) {
529: 
530: 		sfx_volumes[i] = use_external_sfx ? sfx_state[i].volume1 : (sfx_state[i].buffer1 != nullptr ? sfx_state[i].volume1 : sfx_state[i].volume2);
531: 
532: 		if (sfx_volumes[i] > 127) {
533: 			sfx_volumes[i] = 127;
534: 		}
535: 
536: 		if (trace_all || trace_sfx) ffnx_info("%s: SFX volume channel #%i: %i\n", __func__, i, sfx_volumes[i]);
537: 	}
538: }
539: 
540: void sfx_menu_force_channel_5_volume(uint32_t volume, uint32_t channel)
541: {
542: 	if (trace_all || trace_sfx) ffnx_info("%s: %d\n", __func__, volume);
543: 	// Original call (set channel 5 volume to maximum)
544: 	if (use_external_sfx)
545: 		ff7_sfx_set_volume_on_channel(volume, channel);
546: 	else
547: 		common_externals.set_sfx_volume_on_channel(volume, channel);
548: 	// Added by FFNx
549: 	sfx_remember_volumes();
550: }
551: 
552: void sfx_update_volume(int modifier)
553: {
554: 	if (trace_all || trace_sfx) ffnx_info("%s: Update SFX volumes %d\n", __func__, modifier);
555: 
556: 	// Set master sfx volume
557: 	BYTE** sfx_tmp_volume = (BYTE**)(ff7_externals.config_menu_sub + ff7_externals.call_menu_sound_slider_loop_sfx_down + 0xA);
558: 
559: 	*common_externals.master_sfx_volume = **sfx_tmp_volume + modifier;
560: 
561: 	if (use_external_sfx) nxAudioEngine.setSFXMasterVolume(*common_externals.master_sfx_volume / 100.0f);
562: 
563: 	// Update sfx volume in real-time for all channel
564: 	for (int channel = 1; channel <= 5; ++channel) {
565: 		if (use_external_sfx)
566: 			ff7_sfx_set_volume_on_channel(sfx_volumes[channel - 1], channel);
567: 		else
568: 			common_externals.set_sfx_volume_on_channel(sfx_volumes[channel - 1], channel);
569: 
570: 		if (trace_all || trace_sfx) ffnx_info("%s: Set SFX volume for channel #%i: %i\n", __func__, channel, sfx_volumes[channel - 1]);
571: 	}
572: }
573: 
574: void sfx_menu_play_sound_down(uint32_t id)
575: {
576: 	// Added by FFNx
577: 	sfx_update_volume(-1);
578: 
579: 	// Original call (cursor sound)
580: 	if (use_external_sfx)
581: 		ff7_sfx_play_on_channel_5(id);
582: 	else
583: 		common_externals.play_sfx(id);
584: }
585: 
586: void sfx_menu_play_sound_up(uint32_t id)
587: {
588: 	// Added by FFNx
589: 	sfx_update_volume(1);
590: 
591: 	// Original call (cursor sound)
592: 	if (use_external_sfx)
593: 		ff7_sfx_play_on_channel_5(id);
594: 	else
595: 		common_externals.play_sfx(id);
596: }
597: 
598: void sfx_clear_sound_locks()
599: {
600: 	uint32_t** flags = (uint32_t**)(ff7_externals.battle_clear_sound_flags + 5);
601: 	// The last uint32_t wasn't reset by the original sub
602: 	memset((void*)*flags, 0, 5 * sizeof(uint32_t));
603: }
604: 
605: void sfx_fix_volume_values(char* log)
606: {
607: 	if (trace_all || trace_sfx) ffnx_info("%s", log); // FF7 default log
608: 
609: 	for (int i = 0; i < 5; ++i) {
610: 		if (sfx_state[i].u1 == 0xFFFFFFFF) {
611: 			if (trace_all || trace_sfx) ffnx_info("%s: SFX fix volume channel #%i: %i\n", __func__, i + 1, real_volume);
612: 
613: 			sfx_state[i].volume1 = real_volume;
614: 			sfx_state[i].volume2 = real_volume;
615: 			sfx_state[i].u1 = 0; // Back to the correct value
616: 		}
617: 	}
618: }
619: 
620: int sfx_play_battle_specific(IDirectSoundBuffer* buffer, uint32_t flags)
621: {
622: 	if (buffer == nullptr) {
623: 		return 0;
624: 	}
625: 
626: 	// Added by FFNx: set buffer volume according to master_sfx_volume
627: 	unsigned char volume = 127 * (*common_externals.master_sfx_volume) / 100;
628: 
629: 	buffer->SetVolume(common_externals.dsound_volume_table[volume]);
630: 
631: 	// Original behavior
632: 	HRESULT res = buffer->Play(0, 0, flags);
633: 
634: 	if (DSERR_BUFFERLOST == res) {
635: 		res = buffer->Restore();
636: 
637: 		return -1;
638: 	}
639: 
640: 	return res == DS_OK;
641: }
642: 
643: uint32_t sfx_fix_omnislash_sound_loading(int sound_id, int dsound_buffer)
644: {
645: 	// Added by FFNx: Load sound 0x188
646: 	((uint32_t(*)(int, int))common_externals.sfx_load)(0x188, dsound_buffer);
647: 
648: 	// Original call (load sound 0x285)
649: 	return ((uint32_t(*)(int, int))common_externals.sfx_load)(sound_id, dsound_buffer);
650: }
651: 
652: void sfx_fix_cait_sith_roulette(int sound_id)
653: {
654: 	((uint32_t(*)(uint32_t, uint32_t, uint32_t))common_externals.play_sfx_on_channel)(64, sound_id, 4);
655: }
656: 
657: //=============================================================================
658: 
659: void sfx_process_footstep(bool is_player_moving)
660: {
661: 	static time_t last_playback_time, current_playback_time;
662: 
663: 	if (is_player_moving)
664: 	{
665: 		float pace = 0.5f;
666: 
667: 		// If running change the pace
668: 		if (*ff7_externals.input_run_button_status != 0 || gamepad_analogue_intent == INTENT_RUN) pace = 0.30f;
669: 
670: 		qpc_get_time(&current_playback_time);
671: 		if (qpc_diff_time(&current_playback_time, &last_playback_time, nullptr) >= ((ff7_game_obj*)common_externals.get_game_object())->countspersecond * pace)
672: 		{
673: 			if (use_external_sfx) ff7_sfx_play_layered(0.0f, 159, 7);
674: 			else common_externals.play_sfx(159);
675: 			qpc_get_time(&last_playback_time);
676: 		}
677: 	}
678: }
679: 
680: void sfx_process_wm_footstep(int player_model_id, int player_walkmap_type)
681: {
682: 	static time_t last_playback_time, current_playback_time;
683: 	float pace = 0.3f;
684: 	constexpr int footstep_id = 159;
685: 	bool playing;
686: 
687: 	if(player_model_id == 4 || player_model_id == 19)
688: 		pace = 0.5f;
689: 
690: 	qpc_get_time(&current_playback_time);
691: 	if (qpc_diff_time(&current_playback_time, &last_playback_time, nullptr) >= ((ff7_game_obj*)common_externals.get_game_object())->countspersecond * pace)
692: 	{
693: 		char track_name[64];
694: 		if (use_external_sfx)
695: 		{
696: 			sprintf(track_name, "wm_footsteps_%d_%d_%d", player_model_id, player_walkmap_type, footstep_id);
697: 			playing = nxAudioEngine.playSFX(track_name, footstep_id, 7, 0.0f);
698: 
699: 			if(!playing)
700: 			{
701: 				sprintf(track_name, "wm_footsteps_%d_%d", player_walkmap_type, footstep_id);
702: 				playing = nxAudioEngine.playSFX(track_name, footstep_id, 7, 0.0f);
703: 			}
704: 		}
705: 		else
706: 		{
707: 			common_externals.play_sfx(footstep_id);
708: 		}
709: 		qpc_get_time(&last_playback_time);
710: 	}
711: }
712: 
713: void sfx_process_wm_highwind(bool is_old_highwind, bool is_highwind_moving)
714: {
715: 	static bool playing = false;
716: 
717: 	constexpr int default_sfx_id = 493; // Tiny Bronco SFX
718: 	constexpr int default_channel = 1;
719: 
720: 	if (is_highwind_moving && !playing)
721: 	{
722: 		if (use_external_sfx)
723: 		{
724: 			char track_name[64];
725: 			sprintf(track_name, "sfx_highwind_%d", (is_old_highwind) ? 0 : 1);
726: 			playing = nxAudioEngine.playSFX(track_name, default_sfx_id, default_channel, 0.0f, true);
727: 		}
728: 		else
729: 		{
730: 			common_externals.play_sfx_effects(64, default_sfx_id, 0, 0, 0);
731: 			playing = true;
732: 		}
733: 	}
734: 	else if (!is_highwind_moving && playing)
735: 	{
736: 		for(int channel = 1; channel <= 5; channel++)
737: 			common_externals.set_sfx_frequency_on_channel(0, channel);
738: 		((void(*)())common_externals.sfx_stop)();
739: 		playing = false;
740: 	}
741: }
742: 
743: //=============================================================================
744: 
745: void sfx_init()
746: {
747: 	// Add Global Focus flag to DirectSound Secondary Buffers
748: 	patch_code_byte(common_externals.directsound_buffer_flags_1 + 0x4, 0x80); // DSBCAPS_GLOBALFOCUS & 0x0000FF00
749: 
750: 	// SFX Patches
751: 	if (!ff8) {
752: 		// On volume change in main menu initialization
753: 		replace_call(ff7_externals.menu_start + 0x17, sfx_menu_force_channel_5_volume);
754: 		// On SFX volume change in config menu
755: 		replace_call(ff7_externals.config_menu_sub + ff7_externals.call_menu_sound_slider_loop_sfx_down, sfx_menu_play_sound_down);
756: 		replace_call(ff7_externals.config_menu_sub + ff7_externals.call_menu_sound_slider_loop_sfx_up, sfx_menu_play_sound_up);
757: 		// Fix escape sound not played more than once
758: 		replace_function(ff7_externals.battle_clear_sound_flags, sfx_clear_sound_locks);
759: 		// On stop sound in battle swirl
760: 		replace_call(ff7_externals.swirl_sound_effect + 0x26, sfx_operation_battle_swirl_stop_sound);
761: 		// On resume music after a battle
762: 		replace_call(ff7_externals.field_initialize_variables + 0xEB, sfx_operation_resume_music);
763: 
764: 		// Leviathan fix
765: 		patch_code_byte(ff7_externals.battle_summon_leviathan_loop + 0x3FA + 1, 0x2A);
766: 		// Omnislash fix
767: 		replace_call(ff7_externals.battle_limit_omnislash_loop + 0x5A, sfx_fix_omnislash_sound_loading);
768: 		// Cait Sith Roulette fix
769: 		replace_call_function(ff7_externals.battle_menu_state_fn_table[26] + 0xC7, sfx_fix_cait_sith_roulette);
770: 		// Comet2 fix
771: 		patch_code_byte(ff7_externals.comet2_unload_sub_5A4359 + 0xF1, 0x5A);
772: 
773: 		if (use_external_sfx)
774: 		{
775: 			replace_function(common_externals.sfx_load, ff7_sfx_load);
776: 			replace_function(common_externals.sfx_unload, ff7_sfx_unload);
777: 			replace_function(common_externals.play_sfx_on_channel, ff7_sfx_play_on_channel);
778: 			replace_function((uint32_t)common_externals.play_sfx, ff7_sfx_play_on_channel_5);
779: 			replace_function((uint32_t)common_externals.set_sfx_volume_on_channel, ff7_sfx_set_volume_on_channel);
780: 			replace_function((uint32_t)common_externals.set_sfx_volume_trans_on_channel, ff7_sfx_set_volume_trans_on_channel);
781: 			replace_function((uint32_t)common_externals.set_sfx_panning_on_channel, ff7_sfx_set_panning_on_channel);
782: 			replace_function((uint32_t)common_externals.set_sfx_panning_trans_on_channel, ff7_sfx_set_panning_trans_on_channel);
783: 			replace_function((uint32_t)common_externals.set_sfx_frequency_on_channel, ff7_sfx_set_frequency_on_channel);
784: 			replace_function((uint32_t)common_externals.set_sfx_frequency_trans_on_channel, ff7_sfx_set_frequency_trans_on_channel);
785: 			replace_function(ff7_externals.sfx_load_and_play_with_speed, ff7_sfx_load_and_play_with_speed);
786: 			replace_function(ff7_externals.sfx_play_summon, ff7_sfx_play_on_channel_5);
787: 			replace_function(common_externals.sfx_pause, ff7_sfx_pause);
788: 			replace_function(common_externals.sfx_resume, ff7_sfx_resume);
789: 			replace_function(common_externals.sfx_stop, ff7_sfx_stop);
790: 			replace_function(common_externals.sfx_release, ff7_sfx_release);
791: 			// Replace partially some calls in ff7_sfx_play_effects
792: 			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x183, ff7_sfx_set_frequency_on_channel_6);
793: 			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x1A9, ff7_sfx_set_panning_on_channel_6);
794: 			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x1D9, ff7_sfx_set_volume_on_channel_6);
795: 			replace_call_function((uint32_t)common_externals.play_sfx_effects + 0x1E9, ff7_sfx_play_on_channel_6);
796: 			// Required to stop channel 6 effects when required by the engine
797: 			replace_function(ff7_externals.sfx_stop_channel_6, ff7_sfx_stop_channel_6);
798: 
799: 			sfx_state = new ff7_field_sfx_state[5]{0};
800: 			for (short i = 0; i < 5; i++) sfx_state[i].volume1 = 127;
801: 
802: 			nxAudioEngine.setSFXTotalChannels(7); // Allocate 7 channels in total
803: 			nxAudioEngine.setSFXReusableChannels(5); // The engine by default although re-uses up to 5 channels
804: 			nxAudioEngine.addSFXLazyUnloadChannel(6); // Channel 6 will be lazy unloaded by the game engine
805: 		}
806: 		else
807: 		{
808: 			/*
809: 			* Set sound volume on channel changes
810: 			* When this sub is called, it set two fields of sfx_state,
811: 			* but with the wrong value (computed with sfx_master_volume)
812: 			*/
813: 
814: 			// Replace a useless "volume & 0xFF" to "real_volume <- volume; nop"
815: 			patch_code_byte(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x48, 0xA3); // mov
816: 			patch_code_uint(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x48 + 1, uint32_t(&real_volume));
817: 			patch_code_byte(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x48 + 5, 0x90); // nop
818: 			// Use a field of sfx_state to flag the current channel
819: 			patch_code_uint(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x70, 0xFFFFFFFF);
820: 			// Replace log call to fix sfx_state volume values
821: 			replace_call(uint32_t(common_externals.set_sfx_volume_on_channel) + 0x183, sfx_fix_volume_values);
822: 
823: 			// Fix volume on specific SFX
824: 			replace_call(ff7_externals.sfx_play_summon + 0xA2, sfx_play_battle_specific);
825: 			replace_call(ff7_externals.sfx_play_summon + 0xF2, sfx_play_battle_specific);
826: 
827: 			// Store pointer to the SFX states
828: 			sfx_state = ff7_externals.sound_states;
829: 		}
830: 	} else if (use_external_sfx) {
831: 		replace_function(common_externals.sfx_load, ff8_sfx_load);
832: 		replace_function(common_externals.sfx_unload, ff8_sfx_unload);
833: 		replace_function(common_externals.play_sfx_on_channel, ff8_sfx_play_channel);
834: 		replace_function(common_externals.sfx_stop, ff8_sfx_stop_channel);
835: 		replace_function(common_externals.sfx_pause, ff8_sfx_pause_channel);
836: 		replace_function(common_externals.sfx_resume, ff8_sfx_resume_channel);
837: 		replace_function(uint32_t(ff8_externals.sfx_set_master_volume), ff8_sfx_set_master_volume);
838: 		replace_function(ff8_externals.sfx_is_playing, ff8_sfx_is_playing);
839: 		replace_function(ff8_externals.sfx_set_volume, ff8_sfx_set_volume);
840: 		replace_function(ff8_externals.sfx_set_panning, ff8_sfx_set_panning);
841: 
842: 		nxAudioEngine.setSFXTotalChannels(FF8_MAX_CHANNEL_NUMBER + 1); // Allocate 32 channels in total
843: 		nxAudioEngine.setSFXReusableChannels(FF8_MAX_CHANNEL_NUMBER + 1); // The engine by default although re-uses up to 32 channels
844: 	}
845: }
</file>

<file path="src/sfx.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: #include <stdint.h>
25: 
26: void sfx_process_footstep(bool is_player_moving);
27: void sfx_process_wm_footstep(int player_model_id, int player_walkmap_type);
28: void sfx_process_wm_highwind(bool is_old_highwind, bool is_highwind_motor_on);
29: void sfx_init();
</file>

<file path="src/utils.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  8: //    Copyright (C) 2023 myst6re                                            //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: #include "utils.h"
 22: 
 23: #include "globals.h"
 24: #include "log.h"
 25: 
 26: #include <sys/stat.h>
 27: #include <filesystem>
 28: #include <Softpub.h>
 29: #include <wintrust.h>
 30: 
 31: #include <cryptopp/md5.h>
 32: #include <cryptopp/sha.h>
 33: #include <cryptopp/files.h>
 34: #include <cryptopp/hex.h>
 35: 
 36: bool fileExists(const char *filename)
 37: {
 38:     struct stat dummy;
 39: 
 40:     // Use stat to keep compatibility with 7th Heaven
 41:     return stat(filename, &dummy) == 0;
 42: }
 43: 
 44: bool dirExists(const char *dirname)
 45: {
 46:     struct stat dummy;
 47: 
 48:     // Use stat to keep compatibility with 7th Heaven
 49:     return stat(dirname, &dummy) == 0;
 50: }
 51: 
 52: std::string getCopyrightInfoFromExe(const std::string& filePath)
 53: {
 54:     // Get the size of the version information
 55:     DWORD handle = 0;
 56:     DWORD versionInfoSize = GetFileVersionInfoSize(filePath.c_str(), &handle);
 57:     if (versionInfoSize == 0) return "Failed to get version info size.";
 58: 
 59:     // Allocate memory to hold version information
 60:     std::vector<char> versionData(versionInfoSize);
 61:     if (!GetFileVersionInfo(filePath.c_str(), handle, versionInfoSize, versionData.data())) return "Failed to get version information.";
 62: 
 63:     // Query the translation table to locate the language and code page
 64:     struct LANGANDCODEPAGE {
 65:         WORD language;
 66:         WORD codePage;
 67:     } *translation = nullptr;
 68: 
 69:     UINT translationSize = 0;
 70:     if (!VerQueryValue(versionData.data(), "\\VarFileInfo\\Translation", (LPVOID*)&translation, &translationSize)) return "Failed to query translation information.";
 71: 
 72:     if (translationSize == 0) return "No translation information available.";
 73: 
 74:     // Use the first language and code page in the translation table
 75:     char subBlock[50];
 76:     snprintf(subBlock, sizeof(subBlock), "\\StringFileInfo\\%04x%04x\\LegalCopyright", translation[0].language, translation[0].codePage);
 77: 
 78:     // Query the copyright information
 79:     char* copyrightInfo = nullptr;
 80:     UINT infoSize = 0;
 81:     if (!VerQueryValue(versionData.data(), subBlock, (LPVOID*)&copyrightInfo, &infoSize) || infoSize == 0) return "Copyright information not found.";
 82: 
 83:     // Return the copyright information as a std::string
 84:     return std::string(copyrightInfo, infoSize);
 85: }
 86: 
 87: std::wstring GetErrorMessage(unsigned long errorCode)
 88: {
 89:     LPWSTR messageBuffer = nullptr;
 90: 
 91:     FormatMessageW(
 92:         FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
 93:         NULL,
 94:         errorCode,
 95:         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
 96:         (LPWSTR)&messageBuffer,
 97:         0,
 98:         NULL
 99:     );
100: 
101:     std::wstring message = messageBuffer ? messageBuffer : L"Unknown error";
102:     LocalFree(messageBuffer);
103:     return message;
104: }
105: 
106: bool isFileSigned(const wchar_t* dllPath)
107: {
108:     WINTRUST_FILE_INFO fileInfo = {};
109:     WINTRUST_DATA trustData = {};
110:     WINTRUST_SIGNATURE_SETTINGS signatureSettings = {};
111: 
112:     // Open the file with proper sharing flags
113:     fileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
114:     fileInfo.pcwszFilePath = NULL;
115:     fileInfo.hFile = CreateFileW(dllPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);;
116:     fileInfo.pgKnownSubject = NULL;
117: 
118:     GUID actionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
119: 
120:     trustData.cbStruct = sizeof(WINTRUST_DATA);
121:     trustData.dwUIChoice = WTD_UI_NONE;
122:     trustData.fdwRevocationChecks = WTD_REVOKE_NONE;
123:     trustData.dwUnionChoice = WTD_CHOICE_FILE;
124:     trustData.pFile = &fileInfo;
125:     trustData.dwStateAction = WTD_STATEACTION_VERIFY;
126:     trustData.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;
127: 
128:     LONG status = WinVerifyTrust(NULL, &actionID, &trustData);
129: 
130:     if (status != ERROR_SUCCESS) ffnx_error("Unable to verify '%ls': %ls", dllPath, GetErrorMessage(status));
131: 
132:     trustData.dwStateAction = WTD_STATEACTION_CLOSE;
133:     WinVerifyTrust(NULL, &actionID, &trustData);
134: 
135:     CloseHandle(fileInfo.hFile);
136: 
137:     return status == ERROR_SUCCESS;
138: }
139: 
140: std::string sha1_file(const std::string& filename)
141: {
142:     CryptoPP::SHA1 hash;
143:     std::string digest;
144: 
145:     CryptoPP::FileSource(filename.c_str(), true,
146:         new CryptoPP::HashFilter(hash,
147:             new CryptoPP::HexEncoder(
148:                 new CryptoPP::StringSink(digest), false)));
149: 
150:     return digest;
151: }
152: 
153: std::string md5_hash(const unsigned char* data, size_t length)
154: {
155:     using namespace CryptoPP;
156: 
157:     std::string digest;
158: 
159:     MD5 hash;
160:     StringSource(data, length, true,
161:         new HashFilter(hash,
162:             new HexEncoder(
163:                 new StringSink(digest), false)));
164: 
165:     return digest;
166: }
</file>

<file path="src/utils.h">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //                                                                          //
 10: //    This file is part of FFNx                                             //
 11: //                                                                          //
 12: //    FFNx is free software: you can redistribute it and/or modify          //
 13: //    it under the terms of the GNU General Public License as published by  //
 14: //    the Free Software Foundation, either version 3 of the License         //
 15: //                                                                          //
 16: //    FFNx is distributed in the hope that it will be useful,               //
 17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 19: //    GNU General Public License for more details.                          //
 20: /****************************************************************************/
 21: 
 22: #pragma once
 23: 
 24: #include <regex>
 25: #include <string>
 26: #include <vector>
 27: #include <chrono>
 28: #include <random>
 29: 
 30: // Get the size of a vector in bytes
 31: template<typename T>
 32: size_t vectorSizeOf(const typename std::vector<T>& vec)
 33: {
 34:     return sizeof(T) * vec.size();
 35: }
 36: 
 37: // trim from start (in place)
 38: inline void ltrim(std::string& s) {
 39:     s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
 40:         return !std::isspace(ch);
 41:         }));
 42: }
 43: 
 44: // trim from end (in place)
 45: inline void rtrim(std::string& s) {
 46:     s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
 47:         return !std::isspace(ch);
 48:         }).base(), s.end());
 49: }
 50: 
 51: // trim from both ends (in place)
 52: inline void trim(std::string& s) {
 53:     ltrim(s);
 54:     rtrim(s);
 55: }
 56: 
 57: inline bool contains(std::string const& value, std::string const& token)
 58: {
 59:     return value.find(token) != std::string::npos;
 60: }
 61: 
 62: inline std::vector<std::string> split(const std::string& string, const std::string& regex)
 63: {
 64:     std::vector<std::string> result;
 65:     std::string safeString(string);
 66: 
 67:     trim(safeString);
 68: 
 69:     const std::regex rgx(regex);
 70:     std::sregex_token_iterator iter(safeString.begin(), safeString.end(), rgx, -1);
 71: 
 72:     for (std::sregex_token_iterator end; iter != end; ++iter)
 73:     {
 74:         result.push_back(iter->str());
 75:     }
 76: 
 77:     return result;
 78: }
 79: 
 80: inline bool starts_with(std::string const& value, std::string const& starting)
 81: {
 82:     if (starting.size() > value.size()) return false;
 83:     return value.rfind(starting, 0) == 0;
 84: }
 85: 
 86: inline bool ends_with(std::string const& value, std::string const& ending)
 87: {
 88:     if (ending.size() > value.size()) return false;
 89:     return std::equal(ending.rbegin(), ending.rend(), value.rbegin());
 90: }
 91: 
 92: inline bool replaceOnce(std::string& str, const std::string& from, const std::string& to)
 93: {
 94:     size_t start_pos = str.find(from);
 95: 
 96:     if (start_pos == std::string::npos)
 97:         return false;
 98: 
 99:     str.replace(start_pos, from.length(), to);
100: 
101:     return true;
102: }
103: 
104: inline void replaceAll(std::string& str, const char from, const char to)
105: {
106:     std::replace(str.begin(), str.end(), from, to);
107: }
108: 
109: // Based on https://stackoverflow.com/a/13446015
110: inline int getRandomInt(int min, int max)
111: {
112:     std::random_device rd;
113:     std::mt19937::result_type seed = rd() ^ (
114:         (std::mt19937::result_type)
115:         std::chrono::duration_cast<std::chrono::seconds>(
116:             std::chrono::system_clock::now().time_since_epoch()
117:         ).count() +
118:         (std::mt19937::result_type)
119:         std::chrono::duration_cast<std::chrono::microseconds>(
120:             std::chrono::high_resolution_clock::now().time_since_epoch()
121:         ).count()
122:     );
123: 
124:     std::mt19937 gen(seed);
125:     std::uniform_int_distribution<unsigned> distrib(min, max);
126: 
127:     return distrib(gen);
128: }
129: 
130: inline std::chrono::time_point<std::chrono::high_resolution_clock> highResolutionNow()
131: {
132:     return std::chrono::high_resolution_clock::now();
133: }
134: 
135: inline long double elapsedMicroseconds(std::chrono::time_point<std::chrono::high_resolution_clock> startTime)
136: {
137:     return std::chrono::duration<long double, std::micro>(highResolutionNow() - startTime).count();
138: }
139: 
140: bool fileExists(const char *filename);
141: bool dirExists(const char *dirname);
142: std::string getCopyrightInfoFromExe(const std::string& filePath);
143: std::wstring GetErrorMessage(unsigned long errorCode);
144: bool isFileSigned(const wchar_t* dllPath);
145: std::string sha1_file(const std::string& filename);
146: std::string md5_hash(const unsigned char* data, size_t length);
</file>

<file path="src/vibration.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 Chris Rizzitello                                   //
  6: //    Copyright (C) 2020 John Pritchard                                     //
  7: //    Copyright (C) 2023 myst6re                                            //
  8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
  9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include "vibration.h"
 24: 
 25: #include <vector>
 26: 
 27: #include "gamepad.h"
 28: #include "joystick.h"
 29: #include "globals.h"
 30: #include "log.h"
 31: 
 32: NxVibrationEngine nxVibrationEngine;
 33: 
 34: NxVibrationEngine::NxVibrationEngine() :
 35: 	_leftMotorStopTimeFrame(0),
 36: 	_left(0), _right(0),
 37: 	_currentLeft(0), _currentRight(0)
 38: {
 39: }
 40: 
 41: NxVibrationEngine::~NxVibrationEngine()
 42: {
 43: 	for (auto data: _vibrateData) {
 44: 		delete[] data.second;
 45: 	}
 46: }
 47: 
 48: void NxVibrationEngine::setLeftMotorValue(uint8_t force)
 49: {
 50: 	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s force=%d\n", __func__, force);
 51: 
 52: 	if (force > 0)
 53: 	{
 54: 		_leftMotorStopTimeFrame = xinput_connected ? frame_counter + LEFT_MOTOR_DURATION_FRAMES : 0;
 55: 		_left = force;
 56: 	}
 57: }
 58: 
 59: void NxVibrationEngine::setRightMotorValue(uint8_t force)
 60: {
 61: 	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s force=%d\n", __func__, force);
 62: 
 63: 	_right = force;
 64: }
 65: 
 66: void NxVibrationEngine::stopAll()
 67: {
 68: 	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s\n", __func__);
 69: 
 70: 	_leftMotorStopTimeFrame = 0;
 71: 	_left = 0;
 72: 	_right = 0;
 73: 
 74: 	rumbleUpdate();
 75: }
 76: 
 77: bool NxVibrationEngine::hasChanged() const
 78: {
 79: 	return _currentLeft != _left || _currentRight != _right;
 80: }
 81: 
 82: void NxVibrationEngine::updateLeftMotorValue()
 83: {
 84: 	if (xinput_connected && _leftMotorStopTimeFrame > 0 && frame_counter > _leftMotorStopTimeFrame)
 85: 	{
 86: 		if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s stop\n", __func__);
 87: 		_leftMotorStopTimeFrame = 0;
 88: 		_left = 0;
 89: 	}
 90: 	else if (!xinput_connected)
 91: 	{
 92: 		_leftMotorStopTimeFrame = 0;
 93: 	}
 94: }
 95: 
 96: bool NxVibrationEngine::rumbleUpdate()
 97: {
 98: 	updateLeftMotorValue();
 99: 
100: 	if (! hasChanged())
101: 	{
102: 		return false;
103: 	}
104: 
105: 	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s left=%d right=%d\n", __func__, _left, _right);
106: 
107: 	const DWORD maxVibration = xinput_connected ? UINT16_MAX : joystick.GetMaxVibration();
108: 	DWORD left = _left * maxVibration / LEFT_MOTOR_MAX_VALUE;
109: 	DWORD right = _right * maxVibration / RIGHT_MOTOR_MAX_VALUE;
110: 
111: 	if (left > maxVibration) {
112: 		left = maxVibration;
113: 	}
114: 	if (right > maxVibration) {
115: 		right = maxVibration;
116: 	}
117: 
118: 	if (xinput_connected)
119: 	{
120: 		gamepad.Vibrate(left, right);
121: 	}
122: 	else
123: 	{
124: 		joystick.Vibrate(left, right);
125: 	}
126: 
127: 	_currentLeft = _left;
128: 	_currentRight = _right;
129: 
130: 	return true;
131: }
132: 
133: bool NxVibrationEngine::canRumble() const
134: {
135: 	if (xinput_connected)
136: 	{
137: 		return gamepad.GetPort() > 0;
138: 	}
139: 
140: 	return joystick.CheckConnection() && joystick.HasForceFeedback();
141: }
142: 
143: uint8_t *NxVibrationEngine::createVibrateDataFromConfig(const toml::parse_result &config)
144: {
145: 	char sectionName[6] = "";
146: 	uint32_t header[64] = {};
147: 	std::vector<uint16_t> executionData;
148: 
149: 	for (int set = 0; set < 64; ++set)
150: 	{
151: 		snprintf(sectionName, sizeof(sectionName), "set%d", set);
152: 		const toml::array *leftMotor = config[sectionName]["left_motor"].as_array();
153: 		const toml::array *rightMotor = config[sectionName]["right_motor"].as_array();
154: 		if (leftMotor && rightMotor
155: 			&& (leftMotor->empty() || leftMotor->is_homogeneous(toml::node_type::array))
156: 			&& (rightMotor->empty() || rightMotor->is_homogeneous(toml::node_type::array))
157: 		) {
158: 			header[set] = sizeof(header) + executionData.size() * sizeof(uint16_t);
159: 
160: 			uint16_t leftSize = leftMotor->empty() ? 0 : (leftMotor->size() + 1) * 2,
161: 				rightSize = rightMotor->empty() ? 0 : (rightMotor->size() + 1) * 2;
162: 			executionData.push_back(leftSize);
163: 			executionData.push_back(rightSize);
164: 
165: 			for (const toml::node& elem: *leftMotor)
166: 			{
167: 				const toml::array *values = elem.as_array();
168: 
169: 				if (values && values->is_homogeneous(toml::node_type::integer) && values->size() == 2)
170: 				{
171: 					executionData.push_back(
172: 						(((*values)[1].value_or(0) & 0xFF) << 8) | ((*values)[0].value_or(0) & 0xFF)
173: 					);
174: 				}
175: 				else
176: 				{
177: 					ffnx_warning("NxVibrationEngine::%s: Invalid values in section %s/left_motor\n", __func__, sectionName);
178: 				}
179: 			}
180: 
181: 			if (leftSize > 0) {
182: 				// End of sequence
183: 				executionData.push_back(0xFF00);
184: 			}
185: 
186: 			for (const toml::node& elem: *rightMotor)
187: 			{
188: 				const toml::array *values = elem.as_array();
189: 
190: 				if (values && values->is_homogeneous(toml::node_type::integer) && values->size() == 2)
191: 				{
192: 					executionData.push_back(
193: 						(((*values)[1].value_or(0) & 0xFF) << 8) | ((*values)[0].value_or(0) & 0xFF)
194: 					);
195: 				}
196: 				else
197: 				{
198: 					ffnx_warning("NxVibrationEngine::%s: Invalid values in section %s/right_motor\n", __func__, sectionName);
199: 				}
200: 			}
201: 
202: 			if (rightSize > 0) {
203: 				// End of sequence
204: 				executionData.push_back(0xFF00);
205: 			}
206: 		}
207: 		else if (config[sectionName])
208: 		{
209: 			ffnx_warning("NxVibrationEngine::%s: Missing or invalid left_motor or right_motor in section %s\n", __func__, sectionName);
210: 		}
211: 	}
212: 
213: 	if (executionData.empty())
214: 	{
215: 		return nullptr;
216: 	}
217: 
218: 	uint8_t *data = new uint8_t[sizeof(header) + executionData.size() * sizeof(uint16_t)];
219: 
220: 	memcpy(data, header, sizeof(header));
221: 	memcpy(data + sizeof(header), executionData.data(), executionData.size() * sizeof(uint16_t));
222: 
223: 	return data;
224: }
225: 
226: const uint8_t *NxVibrationEngine::vibrateDataOverride(const char *name)
227: {
228: 	char fullpath[MAX_PATH];
229: 	snprintf(fullpath, sizeof(fullpath), "%s/%s/%s.toml", basedir, external_vibrate_path.c_str(), name);
230: 
231: 	if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s: looking for %s\n", __func__, fullpath);
232: 
233: 	std::string nameStr(name);
234: 
235: 	if (_vibrateData.contains(nameStr))
236: 	{
237: 		return _vibrateData[nameStr];
238: 	}
239: 
240: 	try
241: 	{
242: 		toml::parse_result result = toml::parse_file(fullpath);
243: 		uint8_t *data = createVibrateDataFromConfig(result);
244: 		if (data != nullptr)
245: 		{
246: 			if (trace_all || trace_gamepad) ffnx_trace("NxVibrationEngine::%s: data created\n", __func__, fullpath);
247: 			_vibrateData[nameStr] = data;
248: 		}
249: 
250: 		return data;
251: 	}
252: 	catch (const toml::parse_error &err)
253: 	{
254: 		return nullptr;
255: 	}
256: 
257: 	return nullptr;
258: }
</file>

<file path="src/vibration.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 Chris Rizzitello                                   //
 6: //    Copyright (C) 2020 John Pritchard                                     //
 7: //    Copyright (C) 2023 myst6re                                            //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include <stdint.h>
26: #include <unordered_map>
27: #include <string>
28: #include <toml++/toml.h>
29: 
30: constexpr int LEFT_MOTOR_DURATION_FRAMES = 5;
31: constexpr int LEFT_MOTOR_MAX_VALUE = 240;
32: constexpr int RIGHT_MOTOR_MAX_VALUE = 128;
33: 
34: class NxVibrationEngine {
35: public:
36: 	NxVibrationEngine();
37: 	~NxVibrationEngine();
38: 	void setLeftMotorValue(uint8_t force);
39: 	void setRightMotorValue(uint8_t force);
40: 	void stopAll();
41: 	bool rumbleUpdate();
42: 	bool canRumble() const;
43: 	const uint8_t *vibrateDataOverride(const char *name);
44: private:
45: 	bool hasChanged() const;
46: 	void updateLeftMotorValue();
47: 	uint8_t *createVibrateDataFromConfig(const toml::parse_result &config);
48: 
49: 	uint32_t _leftMotorStopTimeFrame;
50: 	uint8_t _left, _right;
51: 	uint8_t _currentLeft, _currentRight;
52: 	std::unordered_map<std::string, uint8_t *> _vibrateData;
53: };
54: 
55: extern NxVibrationEngine nxVibrationEngine;
</file>

<file path="src/voice.cpp">
   1: /****************************************************************************/
   2: //    Copyright (C) 2009 Aali132                                            //
   3: //    Copyright (C) 2018 quantumpencil                                      //
   4: //    Copyright (C) 2018 Maxime Bacoux                                      //
   5: //    Copyright (C) 2020 myst6re                                            //
   6: //    Copyright (C) 2020 Chris Rizzitello                                   //
   7: //    Copyright (C) 2020 John Pritchard                                     //
   8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
   9: //                                                                          //
  10: //    This file is part of FFNx                                             //
  11: //                                                                          //
  12: //    FFNx is free software: you can redistribute it and/or modify          //
  13: //    it under the terms of the GNU General Public License as published by  //
  14: //    the Free Software Foundation, either version 3 of the License         //
  15: //                                                                          //
  16: //    FFNx is distributed in the hope that it will be useful,               //
  17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
  18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
  19: //    GNU General Public License for more details.                          //
  20: /****************************************************************************/
  21: 
  22: #include "voice.h"
  23: 
  24: #include "achievement.h"
  25: #include "audio.h"
  26: #include "field.h"
  27: #include "globals.h"
  28: #include "patch.h"
  29: #include "utils.h"
  30: 
  31: #include "ff8/engine.h"
  32: 
  33: #include <queue>
  34: 
  35: enum class display_type
  36: {
  37: 	NONE = 0,
  38: 	DIALOGUE,
  39: 	CHAR_CMD
  40: };
  41: 
  42: enum class message_kind
  43: {
  44: 	NONE = 0,
  45: 	ASK,
  46: 	MESSAGE,
  47: 	DRAWPOINT
  48: };
  49: 
  50: struct battle_text_aux_data{
  51: 	bool has_started {false};
  52: 	bool follow_voice {false};
  53: 	display_type text_type {display_type::NONE};
  54: 	int page_count {0};
  55: 	uint16_t enemy_id;
  56: 	cmd_id command_id;
  57: 	byte char_id;
  58: };
  59: 
  60: struct opcode_message_status
  61: {
  62: 	opcode_message_status() :
  63: 		// Common
  64: 		message_page_count(0),
  65: 		message_last_opcode(0),
  66: 		is_voice_acting(false),
  67: 		message_last_transition(0),
  68: 		message_last_option(UCHAR_MAX),
  69: 		message_dialog_id(0),
  70: 		message_last_dialog_id(0),
  71: 		char_id(0),
  72: 		message_kind(message_kind::NONE),
  73: 		field_name("")
  74: 	{}
  75: 	byte message_page_count = 0;
  76: 	WORD message_last_opcode = 0;
  77: 	bool is_voice_acting = false;
  78: 	WORD message_last_transition = 0;
  79: 	byte message_last_option = UCHAR_MAX;
  80: 	int message_dialog_id = 0;
  81: 	int message_last_dialog_id = 0;
  82: 	byte char_id = 0;
  83: 	message_kind message_kind = message_kind::NONE;
  84: 	std::string field_name = "";
  85: };
  86: 
  87: // FF7
  88: int (*opcode_old_message)();
  89: int (*opcode_old_ask)(int);
  90: int (*opcode_old_wmode)();
  91: int (*opcode_wm_old_message)(uint8_t,uint8_t);
  92: int (*opcode_wm_old_ask)(uint8_t,uint8_t,uint8_t,uint8_t,WORD*);
  93: int (*opcode_old_tutor)();
  94: void (*ff7_set_master_music_volume)(uint32_t);
  95: 
  96: // FF8
  97: int (*ff8_opcode_old_mes)(int);
  98: int (*ff8_opcode_old_ames)(int);
  99: int (*ff8_opcode_old_amesw)(int);
 100: int (*ff8_opcode_old_ramesw)(int);
 101: int (*ff8_opcode_old_ask)(int);
 102: int (*ff8_opcode_old_aask)(int);
 103: int (*ff8_opcode_old_drawpoint)(int);
 104: 
 105: int ff8_current_window_dialog_id = -1;
 106: std::map<int, int> ff8_field_window_stack_count;
 107: std::map<int, char*> ff8_battle_actor_name;
 108: 
 109: // COMMON
 110: byte opcode_ask_current_option = UCHAR_MAX;
 111: 
 112: std::map<int,bool> simulate_OK_disabled;
 113: 
 114: DWORD previous_master_music_volume = 0x64; // Assume maximum by default
 115: float voice_volume = -1.0f;
 116: 
 117: std::array<battle_text_aux_data, 64> other_battle_display_text_queue;
 118: std::queue<short> display_string_actor_queue;
 119: std::map<int, opcode_message_status> current_opcode_message_status;
 120: 
 121: //=============================================================================
 122: 
 123: void set_voice_volume()
 124: {
 125: 	voice_volume = 2.0f + (100 - external_voice_music_fade_volume) / 100.0f;
 126: }
 127: 
 128: void begin_voice(byte window_id = 0)
 129: {
 130: 	current_opcode_message_status[window_id] = opcode_message_status();
 131: 
 132: 	set_voice_volume();
 133: 
 134: 	if (enable_voice_music_fade)
 135: 	{
 136: 		if (use_external_music)
 137: 		{
 138: 			float new_master_volume = external_voice_music_fade_volume / 100.0f;
 139: 
 140: 			if (new_master_volume < nxAudioEngine.getMusicMasterVolume())
 141: 				nxAudioEngine.setMusicMasterVolume(new_master_volume, 1);
 142: 		}
 143: 		else
 144: 		{
 145: 			if (external_voice_music_fade_volume < *common_externals.master_midi_volume)
 146: 			{
 147: 				previous_master_music_volume = *common_externals.master_midi_volume;
 148: 
 149: 				if (ff8)
 150: 					ff8_externals.dmusicperf_set_volume_sub_46C6F0(floor(127 * (external_voice_music_fade_volume / 100.0f)), 0);
 151: 				else
 152: 					ff7_set_master_music_volume(external_voice_music_fade_volume);
 153: 			}
 154: 		}
 155: 	}
 156: }
 157: 
 158: bool play_voice(char* field_name, byte window_id, byte dialog_id, byte page_count)
 159: {
 160: 	char name[MAX_PATH];
 161: 
 162: 	char page = 'a' + page_count;
 163: 	if (page > 'z') page = 'z';
 164: 
 165: 	sprintf(name, "%s/w%u_%u%c", field_name, window_id, dialog_id, page);
 166: 
 167: 	if (!nxAudioEngine.canPlayVoice(name))
 168: 		sprintf(name, "%s/%u%c", field_name, dialog_id, page);
 169: 
 170: 	if (!nxAudioEngine.canPlayVoice(name) && page_count == 0)
 171: 	{
 172: 		sprintf(name, "%s/w%u_%u", field_name, window_id, dialog_id);
 173: 
 174: 		if (!nxAudioEngine.canPlayVoice(name))
 175: 			sprintf(name, "%s/%u", field_name, dialog_id);
 176: 	}
 177: 
 178: 	return nxAudioEngine.playVoice(name, window_id, voice_volume, *common_externals.field_game_moment);
 179: }
 180: 
 181: bool play_battle_dialogue_voice(short enemy_id, std::string tokenized_dialogue)
 182: {
 183: 	char name[MAX_PATH];
 184: 
 185: 	sprintf(name, "_battle/enemy_%04X/%s", enemy_id, tokenized_dialogue.c_str());
 186: 
 187: 	return nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
 188: }
 189: 
 190: bool play_battle_cmd_voice(byte char_id, cmd_id command_id, std::string tokenized_dialogue, int page_count)
 191: {
 192: 	char name[MAX_PATH];
 193: 	bool playing;
 194: 
 195: 	char page = 'a' + page_count;
 196: 	if (page > 'z') page = 'z';
 197: 	sprintf(name, "_battle/char_%02X/cmd_%02X_", char_id, command_id);
 198: 
 199: 	switch(command_id)
 200: 	{
 201: 	case cmd_id::CMD_MANIPULATE:
 202: 		// 2 cases: manipulated, couldnt
 203: 	case cmd_id::CMD_STEAL:
 204: 	case cmd_id::CMD_MUG:
 205: 		// 3 cases: nothing, couldnt, stole
 206: 		sprintf(name + strlen(name), "%s", split(tokenized_dialogue, "_")[0].c_str());
 207: 		break;
 208: 	default:
 209: 		sprintf(name + strlen(name), "%c", page);
 210: 		break;
 211: 	}
 212: 
 213: 	playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
 214: 
 215: 	if(!playing && page_count == 0)
 216: 	{
 217: 		sprintf(name, "_battle/char_%02X/cmd_%02X", char_id, command_id);
 218: 		playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
 219: 	}
 220: 
 221: 	return playing;
 222: }
 223: 
 224: bool play_battle_char_action_voice(byte char_id, byte command_id, short action_id)
 225: {
 226: 	char name[MAX_PATH];
 227: 	bool playing;
 228: 
 229: 	sprintf(name, "_battle/char_%02X/cmd_%02X_%04X", char_id, command_id, action_id);
 230: 	playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
 231: 
 232: 	if(!playing)
 233: 	{
 234: 		sprintf(name, "_battle/char_%02X/cmd_%02X", char_id, command_id);
 235: 		playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
 236: 	}
 237: 
 238: 	return playing;
 239: }
 240: 
 241: bool play_battle_enemy_action_voice(uint16_t enemy_id, byte command_id, short action_id)
 242: {
 243: 	char name[MAX_PATH];
 244: 	bool playing;
 245: 
 246: 	sprintf(name, "_battle/enemy_%04X/cmd_%02X_%04X", enemy_id, command_id, action_id);
 247: 	playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
 248: 
 249: 	if(!playing)
 250: 	{
 251: 		sprintf(name, "_battle/enemy_%04X/cmd_%02X", enemy_id, command_id);
 252: 		playing = nxAudioEngine.playVoice(name, 0, voice_volume, *common_externals.field_game_moment);
 253: 	}
 254: 
 255: 	return playing;
 256: }
 257: 
 258: void play_option(char* field_name, byte window_id, byte dialog_id, byte option_count)
 259: {
 260: 	char name[MAX_PATH];
 261: 
 262: 	sprintf(name, "%s/%u_%u", field_name, dialog_id, option_count);
 263: 
 264: 	nxAudioEngine.playVoice(name, window_id, voice_volume, *common_externals.field_game_moment);
 265: }
 266: 
 267: void end_voice(byte window_id = 0, uint32_t time = 0)
 268: {
 269: 	nxAudioEngine.stopVoice(window_id, time);
 270: 
 271: 	if (enable_voice_music_fade)
 272: 	{
 273: 		if (use_external_music)
 274: 			nxAudioEngine.restoreMusicMasterVolume(time > 0 ? time : 1);
 275: 		else if (ff8)
 276: 			ff8_externals.dmusicperf_set_volume_sub_46C6F0(previous_master_music_volume, 0);
 277: 		else
 278: 			ff7_set_master_music_volume(previous_master_music_volume);
 279: 	}
 280: }
 281: 
 282: //=============================================================================
 283: 
 284: bool is_dialog_opening(WORD code)
 285: {
 286: 	return (code == 0);
 287: }
 288: 
 289: bool is_dialog_starting(WORD old_code, WORD new_code)
 290: {
 291: 	return (
 292: 		old_code == 0 && old_code != new_code
 293: 	);
 294: }
 295: 
 296: bool is_dialog_paging(WORD old_code, WORD new_code)
 297: {
 298: 	if (ff8)
 299: 		return (
 300: 			(old_code == 10 && new_code == 1)
 301: 		);
 302: 	else
 303: 		return (
 304: 			(old_code == 14 && new_code == 2) ||
 305: 			(old_code == 4 && new_code == 8)
 306: 		);
 307: }
 308: 
 309: bool is_dialog_closing(WORD old_code, WORD new_code)
 310: {
 311: 	if (ff8)
 312: 		return (
 313: 			new_code < old_code
 314: 		);
 315: 	else
 316: 		return (
 317: 			old_code != new_code && new_code == 7
 318: 		);
 319: }
 320: 
 321: bool is_dialog_closed(WORD old_code, WORD new_code)
 322: {
 323: 	if (ff8)
 324: 		return (
 325: 			new_code < old_code && new_code == 0
 326: 		);
 327: 	else
 328: 		return (
 329: 			old_code == 7 && new_code == 0
 330: 		);
 331: }
 332: 
 333: byte get_dialog_opcode(byte window_id)
 334: {
 335: 	return ff7_externals.opcode_message_loop_code[24 * window_id];
 336: }
 337: 
 338: //=============================================================================
 339: 
 340: // -- FIELD --
 341: 
 342: byte get_field_dialog_char_id(byte window_id) {
 343: 	if (ff7_externals.field_entity_id_list[window_id] != *ff7_externals.current_entity_id) return 0;
 344: 
 345: 	if (ff7_externals.field_entity_id_list[window_id] == 0x0) return 0;
 346: 
 347: 	byte id = *(byte*)ff7_externals.current_dialog_string_pointer[window_id];
 348: 
 349: 	switch(id) {
 350: 		case 0xEA: // CLOUD
 351: 		case 0xEB: // BARRET
 352: 		case 0xEC: // TIFA
 353: 		case 0xED: // AERITH
 354: 		case 0xEE: // RED XIII
 355: 		case 0xEF: // YUFFIE
 356: 		case 0xF0: // CAIT SITH
 357: 		case 0xF1: // VINCENT
 358: 		case 0xF2: // CID
 359: 			return id;
 360: 		default:
 361: 			return 0;
 362: 	}
 363: }
 364: 
 365: void ff7_handle_wmode_reset()
 366: {
 367: 	struct game_mode *mode = getmode_cached();
 368: 	static WORD last_field_id = 0;
 369: 	uint32_t last_driver_mode = 0;
 370: 
 371: 	if (last_field_id != *ff7_externals.field_id)
 372: 	{
 373: 		last_field_id = *ff7_externals.field_id;
 374: 
 375: 		simulate_OK_disabled.clear();
 376: 	}
 377: 	else if (last_driver_mode != mode->driver_mode)
 378: 	{
 379: 		last_driver_mode = mode->driver_mode;
 380: 
 381: 		simulate_OK_disabled.clear();
 382: 	}
 383: }
 384: 
 385: int opcode_wmode()
 386: {
 387: 	byte window_id = get_field_parameter<byte>(0);
 388: 	byte window_permanent = get_field_parameter<byte>(2);
 389: 
 390: 	simulate_OK_disabled[window_id] = window_permanent;
 391: 
 392: 	return opcode_old_wmode();
 393: }
 394: 
 395: int opcode_voice_message()
 396: {
 397: 	byte window_id = get_field_parameter<byte>(0);
 398: 	byte dialog_id = get_field_parameter<byte>(1);
 399: 	byte message_current_opcode = get_dialog_opcode(window_id);
 400: 	char* field_name = get_current_field_name();
 401: 
 402: 	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
 403: 	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 404: 	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 405: 	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 406: 	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 407: 
 408: 	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;
 409: 
 410: 	if (_is_dialog_opening)
 411: 	{
 412: 		begin_voice(window_id);
 413: 	}
 414: 	else if (_is_dialog_starting || _is_dialog_paging)
 415: 	{
 416: 		if (_is_dialog_starting) current_opcode_message_status[window_id].char_id = get_field_dialog_char_id(window_id);
 417: 		if (trace_all || trace_opcodes) ffnx_trace("opcode[MESSAGE]: field=%s,window_id=%u,dialog_id=%u,paging_id=%u,char=%X\n", field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count, current_opcode_message_status[window_id].char_id);
 418: 		current_opcode_message_status[window_id].is_voice_acting = play_voice(field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
 419: 	}
 420: 	else if (_is_dialog_closing)
 421: 	{
 422: 		end_voice(window_id);
 423: 		simulate_OK_disabled[window_id] = false;
 424: 		current_opcode_message_status[window_id].is_voice_acting = false;
 425: 	}
 426: 
 427: 	// Auto close the message if it was voice acted and the audio file has finished playing
 428: 	if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
 429: 	{
 430: 		current_opcode_message_status[window_id].is_voice_acting = false;
 431: 		if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
 432: 	}
 433: 
 434: 	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
 435: 
 436: 	return opcode_old_message();
 437: }
 438: 
 439: int opcode_voice_tutor()
 440: {
 441: 	static const int window_id = 0;
 442: 
 443: 	current_opcode_message_status[window_id].message_dialog_id = get_field_parameter<byte>(0);
 444: 
 445: 	return opcode_old_tutor();
 446: }
 447: 
 448: int opcode_voice_parse_options(uint8_t window_id, uint8_t dialog_id, uint8_t first_question_id, uint8_t last_question_id, WORD *current_question_id)
 449: {
 450: 	opcode_ask_current_option = *current_question_id;
 451: 
 452: 	return ff7_externals.field_opcode_ask_update_loop_6310A1(window_id, dialog_id, first_question_id, last_question_id, current_question_id);
 453: }
 454: 
 455: int opcode_voice_ask(int unk)
 456: {
 457: 	byte window_id = get_field_parameter<byte>(1);
 458: 	byte dialog_id = get_field_parameter<byte>(2);
 459: 	byte message_current_opcode = get_dialog_opcode(window_id);
 460: 	char* field_name = get_current_field_name();
 461: 
 462: 	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
 463: 	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 464: 	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 465: 	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 466: 	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 467: 	bool _is_dialog_option_changed = (current_opcode_message_status[window_id].message_last_option != opcode_ask_current_option);
 468: 
 469: 	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;
 470: 
 471: 	if (_is_dialog_opening)
 472: 	{
 473: 		opcode_ask_current_option = UCHAR_MAX;
 474: 		begin_voice(window_id);
 475: 	}
 476: 	else if (_is_dialog_starting || _is_dialog_paging)
 477: 	{
 478: 		if (_is_dialog_starting) current_opcode_message_status[window_id].char_id = get_field_dialog_char_id(window_id);
 479: 		if (trace_all || trace_opcodes) ffnx_trace("opcode[ASK]: field=%s,window_id=%u,dialog_id=%u,paging_id=%u,char=%X\n", field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count, current_opcode_message_status[window_id].char_id);
 480: 		current_opcode_message_status[window_id].is_voice_acting = play_voice(field_name, window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
 481: 	}
 482: 	else if (_is_dialog_option_changed)
 483: 	{
 484: 		if (trace_all || trace_opcodes) ffnx_trace("opcode[ASK]: field=%s,window_id=%u,dialog_id=%u,option_id=%u,char=%X\n", field_name, window_id, dialog_id, opcode_ask_current_option,current_opcode_message_status[window_id].char_id);
 485: 		play_option(field_name, window_id, dialog_id, opcode_ask_current_option);
 486: 	}
 487: 	else if (_is_dialog_closing)
 488: 	{
 489: 		end_voice(window_id);
 490: 	}
 491: 
 492: 	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
 493: 	current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;
 494: 
 495: 	return opcode_old_ask(unk);
 496: }
 497: 
 498: // -- WORLDMAP --
 499: 
 500: int opcode_wm_message(uint8_t window_id, uint8_t dialog_id) {
 501: 	byte message_current_opcode = get_dialog_opcode(window_id);
 502: 
 503: 	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
 504: 	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 505: 	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 506: 	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 507: 	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 508: 
 509: 	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;
 510: 
 511: 	if (_is_dialog_opening)
 512: 	{
 513: 		begin_voice(window_id);
 514: 		current_opcode_message_status[window_id].message_dialog_id = dialog_id;
 515: 	}
 516: 	else if (_is_dialog_starting || _is_dialog_paging)
 517: 	{
 518: 		if (trace_all || trace_opcodes) ffnx_trace("wm_opcode[MESSAGE]: window_id=%u,dialog_id=%u,paging_id=%u\n", window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
 519: 		current_opcode_message_status[window_id].is_voice_acting = play_voice("_world", window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
 520: 	}
 521: 	else if (_is_dialog_closing)
 522: 	{
 523: 		end_voice(window_id);
 524: 		simulate_OK_disabled[window_id] = false;
 525: 		current_opcode_message_status[window_id].is_voice_acting = false;
 526: 	}
 527: 
 528: 	// Auto close the message if it was voice acted and the audio file has finished playing
 529: 	if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
 530: 	{
 531: 		current_opcode_message_status[window_id].is_voice_acting = false;
 532: 		if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) (*ff7_externals.field_global_object_ptr)->field_80 |= 0x20;
 533: 	}
 534: 
 535: 	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
 536: 
 537: 	return opcode_wm_old_message(window_id, dialog_id);
 538: }
 539: 
 540: int opcode_wm_ask(uint8_t window_id, uint8_t dialog_id, uint8_t first_question_id, uint8_t last_question_id, WORD *current_question_id) {
 541: 	byte message_current_opcode = get_dialog_opcode(window_id);
 542: 
 543: 	bool _is_dialog_opening = is_dialog_opening(message_current_opcode);
 544: 	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 545: 	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 546: 	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 547: 	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
 548: 	bool _is_dialog_option_changed = (current_opcode_message_status[window_id].message_last_option != *current_question_id);
 549: 
 550: 	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;
 551: 
 552: 	if (_is_dialog_opening)
 553: 	{
 554: 		begin_voice(window_id);
 555: 	}
 556: 	else if (_is_dialog_starting || _is_dialog_paging)
 557: 	{
 558: 		if (trace_all || trace_opcodes) ffnx_trace("wm_opcode[ASK]: window_id=%u,dialog_id=%u,paging_id=%u\n", window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
 559: 		current_opcode_message_status[window_id].message_dialog_id = dialog_id;
 560: 		current_opcode_message_status[window_id].is_voice_acting = play_voice("_world", window_id, dialog_id, current_opcode_message_status[window_id].message_page_count);
 561: 	}
 562: 	else if (_is_dialog_option_changed)
 563: 	{
 564: 		if (trace_all || trace_opcodes) ffnx_trace("wm_opcode[ASK]: window_id=%u,dialog_id=%u,option_id=%u\n", window_id, current_opcode_message_status[window_id].message_dialog_id, *current_question_id);
 565: 		play_option("_world", window_id, current_opcode_message_status[window_id].message_dialog_id, *current_question_id);
 566: 	}
 567: 	else if (_is_dialog_closing)
 568: 	{
 569: 		end_voice(window_id);
 570: 	}
 571: 
 572: 	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
 573: 	current_opcode_message_status[window_id].message_last_option = *current_question_id;
 574: 
 575: 	return opcode_wm_old_ask(window_id, dialog_id, first_question_id, last_question_id, current_question_id);
 576: }
 577: 
 578: // -- BATTLE --
 579: 
 580: std::string decode_ff7_text(const char *encoded_text)
 581: {
 582: 	std::string decoded_text{};
 583: 	int index = 0;
 584: 	char current_char;
 585: 	while (current_char = encoded_text[index++], current_char != char(0xFF))
 586: 	{
 587: 		switch (current_char)
 588: 		{
 589: 		case 0xEB:
 590: 			decoded_text.append("{item_name}");
 591: 			index += 3;
 592: 			break;
 593: 		case 0xEC:
 594: 			decoded_text.append("{number}");
 595: 			index += 3;
 596: 			break;
 597: 		case 0xED:
 598: 			decoded_text.append("{target_name}");
 599: 			index += 3;
 600: 			break;
 601: 		case 0xEE:
 602: 			decoded_text.append("{attack_name}");
 603: 			index += 3;
 604: 			break;
 605: 		case 0xEF:
 606: 			decoded_text.append("{special_number}");
 607: 			index += 3;
 608: 			break;
 609: 		case 0xF0:
 610: 			decoded_text.append("{target_letter}");
 611: 			index += 3;
 612: 			break;
 613: 		case 0xF8:
 614: 			index += 2;
 615: 			break;
 616: 		default:
 617: 			decoded_text.push_back(current_char + 0x20);
 618: 			break;
 619: 		}
 620: 	}
 621: 	return decoded_text;
 622: }
 623: 
 624: std::string tokenize_text(std::string decoded_text)
 625: {
 626: 	transform(decoded_text.begin(), decoded_text.end(), decoded_text.begin(), tolower);
 627: 
 628: 	std::string filename{};
 629: 	for(auto current_char : decoded_text)
 630: 	{
 631: 		if(current_char >= 'a' && current_char <= 'z')
 632: 			filename += current_char;
 633: 		else if(current_char >= '0' && current_char <= '9')
 634: 			filename += current_char;
 635: 		else if(current_char == ' ')
 636: 			filename += '_';
 637: 		else if(current_char == '{' || current_char == '}')
 638: 			filename += current_char;
 639: 	}
 640: 	return filename;
 641: }
 642: 
 643: void ff7_enqueue_script_display_string(short actor_id, byte command_index, uint16_t rel_attack_index)
 644: {
 645: 	display_string_actor_queue.push(actor_id);
 646: 
 647: 	if (trace_all || trace_battle_text) ffnx_trace("Push display string for actorId: %d\n", actor_id);
 648: 
 649: 	((void (*)(short, byte, uint16_t))ff7_externals.enqueue_script_action)(actor_id, command_index, rel_attack_index);
 650: }
 651: 
 652: void ff7_add_text_to_display_queue(WORD buffer_idx, byte wait_frames, byte n_frames, WORD param_4)
 653: {
 654: 	auto text_data = std::find_if(ff7_externals.battle_display_text_queue.begin(), ff7_externals.battle_display_text_queue.end(),
 655: 									[](const battle_text_data &data)
 656: 									{ return data.buffer_idx == -1; });
 657: 
 658: 	if (text_data != ff7_externals.battle_display_text_queue.end())
 659: 	{
 660: 		text_data->buffer_idx = buffer_idx;
 661: 		text_data->field_2 = param_4;
 662: 		text_data->wait_frames = wait_frames * battle_frame_multiplier - 1;
 663: 		int n_frames_int = (n_frames == 0) ? ((int (*)())ff7_externals.get_n_frames_display_action_string)() : n_frames * battle_frame_multiplier;
 664: 		text_data->n_frames = std::min(n_frames_int, UCHAR_MAX); // safely cast int to unsigned char
 665: 
 666: 		if (trace_all || trace_battle_text)
 667: 			ffnx_trace("Add text string to be displayed: (text_id: %d, field_2: %d, wait_frames: %d, n_frames: %d)\n", text_data->buffer_idx, text_data->field_2, text_data->wait_frames, text_data->n_frames);
 668: 
 669: 		int index = std::distance(ff7_externals.battle_display_text_queue.begin(), text_data);
 670: 		byte attacker_id = ff7_externals.anim_event_queue[*ff7_externals.anim_event_index].attackerID;
 671: 		if (attacker_id == 10 && n_frames == 0 && buffer_idx >= 256)
 672: 		{
 673: 			other_battle_display_text_queue[index].has_started = false;
 674: 			other_battle_display_text_queue[index].follow_voice = true;
 675: 			other_battle_display_text_queue[index].text_type = display_type::DIALOGUE;
 676: 			if (!display_string_actor_queue.empty())
 677: 			{
 678: 				short actor_id = display_string_actor_queue.front();
 679: 				display_string_actor_queue.pop();
 680: 				other_battle_display_text_queue[index].enemy_id = ff7_externals.battle_context->actor_vars[actor_id].formationID;
 681: 			}
 682: 		}
 683: 		else
 684: 		{
 685: 			if (attacker_id == 10)
 686: 				attacker_id = ff7_externals.anim_event_queue[0].attackerID;
 687: 
 688: 			other_battle_display_text_queue[index].has_started = false;
 689: 			other_battle_display_text_queue[index].follow_voice = false;
 690: 			other_battle_display_text_queue[index].page_count = index;
 691: 			other_battle_display_text_queue[index].command_id = static_cast<cmd_id>(ff7_externals.battle_context->lastCommandIdx);
 692: 
 693: 			if (attacker_id >= 0 && attacker_id <= 2)
 694: 			{
 695: 				other_battle_display_text_queue[index].text_type = display_type::CHAR_CMD;
 696: 				other_battle_display_text_queue[index].char_id = ff7_externals.battle_context->actor_vars[attacker_id].index;
 697: 			}
 698: 			else
 699: 			{
 700: 				other_battle_display_text_queue[index].text_type = display_type::NONE;
 701: 			}
 702: 		}
 703: 	}
 704: }
 705: 
 706: void ff7_update_display_text_queue()
 707: {
 708: 	*ff7_externals.field_battle_word_BF2E08 = *ff7_externals.field_battle_word_BF2E08 | 2;
 709: 	auto &text_data_first = ff7_externals.battle_display_text_queue.front();
 710: 	auto &other_text_data_first = other_battle_display_text_queue.front();
 711: 
 712: 	if (text_data_first.buffer_idx != -1)
 713: 	{
 714: 		if (text_data_first.wait_frames == 0)
 715: 		{
 716: 			// Begin voice
 717: 			if(!other_text_data_first.has_started)
 718: 			{
 719: 				const char *encoded_text = ff7_externals.get_kernel_text(8, text_data_first.buffer_idx, 8);
 720: 				std::string decoded_text = decode_ff7_text(encoded_text);
 721: 				std::string tokenized_dialogue;
 722: 
 723: 				begin_voice();
 724: 				switch (other_text_data_first.text_type)
 725: 				{
 726: 				case display_type::DIALOGUE:
 727: 					tokenized_dialogue = tokenize_text(decoded_text);
 728: 					other_text_data_first.has_started = play_battle_dialogue_voice(other_text_data_first.enemy_id, tokenized_dialogue);
 729: 
 730: 					if (trace_all || trace_battle_text)
 731: 						ffnx_trace("Begin voice of EnemyID: %04X for text: %s (filename: %s)\n", other_text_data_first.enemy_id, decoded_text.c_str(), tokenized_dialogue.c_str());
 732: 
 733: 					break;
 734: 				case display_type::CHAR_CMD:
 735: 					tokenized_dialogue = tokenize_text(decoded_text);
 736: 					other_text_data_first.has_started = play_battle_cmd_voice(other_text_data_first.char_id, other_text_data_first.command_id,
 737: 																				tokenized_dialogue, other_text_data_first.page_count);
 738: 
 739: 					if (trace_all || trace_battle_text)
 740: 						ffnx_trace("Begin voice for (character ID: %d; command ID: %X) [filename: %s]\n",
 741: 									 other_text_data_first.char_id, other_text_data_first.command_id, tokenized_dialogue.c_str());
 742: 
 743: 					break;
 744: 				default:
 745: 					break;
 746: 				}
 747: 
 748: 				other_text_data_first.text_type = (!other_text_data_first.has_started) ? display_type::NONE : other_text_data_first.text_type;
 749: 				if(!other_text_data_first.has_started)
 750: 					end_voice();
 751: 			}
 752: 
 753: 			if (text_data_first.field_2 != 0)
 754: 			{
 755: 				((void (*)(uint16_t))ff7_externals.battle_sfx_play_effect_430D14)(0x2D7);
 756: 				text_data_first.field_2 = 0;
 757: 			}
 758: 
 759: 			if (text_data_first.n_frames == 0)
 760: 			{
 761: 				text_data_first.buffer_idx = -1;
 762: 
 763: 				// End voice
 764: 				if (other_text_data_first.has_started)
 765: 				{
 766: 					other_text_data_first.has_started = false;
 767: 					end_voice();
 768: 				}
 769: 
 770: 				for (int i = 0; i < ff7_externals.battle_display_text_queue.size(); i++)
 771: 				{
 772: 					if (text_data_first.buffer_idx == -1)
 773: 					{
 774: 						for (int j = 0; j < ff7_externals.battle_display_text_queue.size() - 1; j++)
 775: 						{
 776: 							ff7_externals.battle_display_text_queue[j] = ff7_externals.battle_display_text_queue[j + 1];
 777: 							other_battle_display_text_queue[j] = other_battle_display_text_queue[j + 1];
 778: 						}
 779: 						*ff7_externals.field_battle_word_BF2032 = 0xFFFF;
 780: 					}
 781: 				}
 782: 
 783: 				return;
 784: 			}
 785: 
 786: 			int show_text = (ff7_externals.battle_sub_66C3BF)();
 787: 			if (show_text)
 788: 				((void (*)(short))ff7_externals.set_battle_text_active)(text_data_first.buffer_idx);
 789: 
 790: 			if (*ff7_externals.g_is_battle_paused || !*ff7_externals.g_is_battle_running_9AD1AC)
 791: 				return;
 792: 
 793: 			// Ending voice
 794: 			if (other_text_data_first.has_started && other_text_data_first.follow_voice)
 795: 			{
 796: 				if (!nxAudioEngine.isVoicePlaying())
 797: 				{
 798: 					text_data_first.n_frames = 0;
 799: 				}
 800: 			}
 801: 			else
 802: 			{
 803: 				text_data_first.n_frames--;
 804: 			}
 805: 			return;
 806: 		}
 807: 		if (!*ff7_externals.g_is_battle_paused && *ff7_externals.g_is_battle_running_9AD1AC)
 808: 			text_data_first.wait_frames--;
 809: 	}
 810: 
 811: 	((void (*)(short))ff7_externals.set_battle_text_active)(-1);
 812: 	*ff7_externals.field_battle_word_BF2E08 = *ff7_externals.field_battle_word_BF2E08 & 0xFFFD;
 813: }
 814: 
 815: void ff7_display_battle_action_text()
 816: {
 817: 	auto &effect_data = ff7_externals.effect100_array_data[*ff7_externals.effect100_array_idx];
 818: 	constexpr short VOICE_STARTED = -2;
 819: 	constexpr short VOICE_NOT_STARTED = -1;
 820: 
 821: 	if(effect_data.field_6 <= 0)
 822: 	{
 823: 		// Play voice
 824: 		if(effect_data.field_6 == 0)
 825: 		{
 826: 			byte actor_id = *ff7_externals.g_active_actor_id;
 827: 			bool hasStarted = false;
 828: 			if(actor_id >= 0 && actor_id <= 2)
 829: 			{
 830: 				byte char_id = ff7_externals.battle_context->actor_vars[actor_id].index;
 831: 				byte command_id = ff7_externals.g_battle_model_state[actor_id].commandID;
 832: 				uint16_t action_id = ff7_externals.g_small_battle_model_state[actor_id].actionIdx;
 833: 
 834: 				set_voice_volume();
 835: 				hasStarted = play_battle_char_action_voice(char_id, command_id, action_id);
 836: 			}
 837: 			else if(actor_id >= 4 && actor_id < 10)
 838: 			{
 839: 				uint16_t enemy_id = ff7_externals.battle_context->actor_vars[actor_id].formationID;
 840: 				byte command_id = ff7_externals.g_battle_model_state[actor_id].commandID;
 841: 				uint16_t action_id = ff7_externals.g_small_battle_model_state[actor_id].actionIdx;
 842: 
 843: 				set_voice_volume();
 844: 				hasStarted = play_battle_enemy_action_voice(enemy_id, command_id, action_id);
 845: 			}
 846: 
 847: 			if(hasStarted)
 848: 				effect_data.field_6 = VOICE_STARTED;
 849: 			else
 850: 				effect_data.field_6 = VOICE_NOT_STARTED;
 851: 		}
 852: 
 853: 		if(effect_data.n_frames == 0)
 854: 		{
 855: 			effect_data.field_0 = 0xFFFF;
 856: 		}
 857: 		else
 858: 		{
 859: 			int show_text = (ff7_externals.battle_sub_66C3BF)();
 860: 			if(show_text)
 861: 			{
 862: 				byte command_id = ff7_externals.g_battle_model_state[*ff7_externals.g_active_actor_id].commandID;
 863: 				uint16_t action_id = ff7_externals.g_small_battle_model_state[*ff7_externals.g_active_actor_id].actionIdx;
 864: 				((void(*)(short, short))ff7_externals.display_battle_action_text_sub_6D71FA)(command_id, action_id);
 865: 				if(*ff7_externals.g_is_battle_running_9AD1AC != 0)
 866: 					effect_data.n_frames--;
 867: 			}
 868: 		}
 869: 	}
 870: 	else
 871: 	{
 872: 		if(*ff7_externals.g_is_battle_running_9AD1AC != 0)
 873: 			effect_data.field_6--;
 874: 	}
 875: }
 876: 
 877: // -- MENU --
 878: 
 879: int ff7_menu_tutorial_render()
 880: {
 881: 	static const int window_id = 0;
 882: 	int dialog_id = current_opcode_message_status[window_id].message_dialog_id;
 883: 
 884: 	byte message_current_opcode = *ff7_externals.menu_tutorial_window_state;
 885: 
 886: 	bool _is_dialog_opening = (current_opcode_message_status[window_id].message_last_opcode == 0 && message_current_opcode == 1);
 887: 	bool _is_dialog_starting = (current_opcode_message_status[window_id].message_last_opcode == 1 && message_current_opcode == 2);
 888: 	bool _is_dialog_closing = (current_opcode_message_status[window_id].message_last_opcode == 3 && message_current_opcode == 0);
 889: 
 890: 	if (_is_dialog_opening)
 891: 	{
 892: 		begin_voice(window_id);
 893: 		current_opcode_message_status[window_id].message_dialog_id = dialog_id;
 894: 	}
 895: 	else if (_is_dialog_starting)
 896: 	{
 897: 		std::string decoded_text = decode_ff7_text((char*)*ff7_externals.menu_tutorial_window_text_ptr);
 898: 		std::string tokenized_dialogue = tokenize_text(decoded_text);
 899: 
 900: 		if (trace_all || trace_opcodes) ffnx_trace("[TUTOR]: id=%d,text=%s\n", dialog_id, decoded_text.c_str());
 901: 
 902: 		char voice_file[MAX_PATH];
 903: 		sprintf(voice_file, "_tutor/%04u/%s", dialog_id, tokenized_dialogue.c_str());
 904: 		current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
 905: 	}
 906: 	else if (_is_dialog_closing)
 907: 	{
 908: 		end_voice(window_id);
 909: 		simulate_OK_disabled[window_id] = false;
 910: 		current_opcode_message_status[window_id].is_voice_acting = false;
 911: 	}
 912: 
 913: 	// Auto close the message if it was voice acted and the audio file has finished playing
 914: 	if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
 915: 	{
 916: 		current_opcode_message_status[window_id].is_voice_acting = false;
 917: 		if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) (*ff7_externals.field_global_object_ptr)->field_80 |= 0x20;
 918: 	}
 919: 
 920: 	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
 921: 
 922: 	return ff7_externals.menu_tutorial_sub_6C49FD();
 923: }
 924: 
 925: //=============================================================================
 926: 
 927: char* ff8_battle_get_monster_name(int idx)
 928: {
 929: 	char* ret = *((char**)*(ff8_externals.battle_char_struct_dword_1D27B10 + 0x34 * idx));
 930: 
 931: 	ff8_battle_actor_name[idx] = ret;
 932: 
 933: 	return ret;
 934: }
 935: 
 936: char* ff8_battle_get_actor_name(int idx)
 937: {
 938: 	char* ret;
 939: 	BYTE actor_id = *(ff8_externals.byte_1CFF1C3 + 0x1D0 * idx);
 940: 
 941: 	if ( !actor_id )
 942: 		ret = ff8_externals.unk_1CFDC70;
 943: 	else if ( actor_id == 4 )
 944: 		ret = ff8_externals.unk_1CFDC7C;
 945: 	else if ( *(ff8_externals.word_1CF75EC + 0x12 * *(ff8_externals.byte_1CFF1C3 + 0x1D0 * idx)) == -1 )
 946: 		ret = ff8_externals.unk_1CFF84C;
 947: 	else
 948: 		ret = ff8_externals.unk_1CF3E48 + *(ff8_externals.word_1CF75EC + 0x12 * *(ff8_externals.byte_1CFF1C3 + 0x1D0 * idx)) + *ff8_externals.dword_1CF3EE0;
 949: 
 950: 	ff8_battle_actor_name[idx] = ret;
 951: 
 952: 	return ret;
 953: }
 954: 
 955: char *ff8_field_get_dialog_string(char *msg, int dialog_id)
 956: {
 957: 	ff8_current_window_dialog_id = dialog_id;
 958: 
 959: 	return msg + *(uint32_t *)(msg + 4 * dialog_id);
 960: }
 961: 
 962: int ff8_world_dialog_assign_text(int idx, int dialog_id, char *text)
 963: {
 964: 	int window_id = *(ff8_externals.worldmap_windows_idx_map + 0x10 * idx);
 965: 
 966: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
 967: 	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
 968: 
 969: 	return ff8_externals.world_dialog_assign_text_sub_543790(idx, dialog_id, text);
 970: }
 971: 
 972: int ff8_world_dialog_question_assign_text(int idx, int dialog_id, char *text, int first_question, int last_question, int current_choice, uint8_t default_option)
 973: {
 974: 	int window_id = *(ff8_externals.worldmap_windows_idx_map + 0x10 * idx);
 975: 
 976: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
 977: 	current_opcode_message_status[window_id].message_kind = message_kind::ASK;
 978: 	current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;
 979: 
 980: 	return ff8_externals.world_dialog_question_assign_text_sub_5438D0(idx, dialog_id, text, first_question, last_question, current_choice, default_option);
 981: }
 982: 
 983: int ff8_opcode_voice_drawpoint(int unk)
 984: {
 985: 	byte idx = *(byte *)(unk + 388);
 986: 
 987: 	int magic_id = *(DWORD *)(unk + 4 * idx--);
 988: 	static int window_id = 6;
 989: 	static int default_option = 2;
 990: 	ff8_win_obj *win = ff8_externals.windows + window_id;
 991: 
 992: 	int ret = ff8_opcode_old_drawpoint(unk);
 993: 
 994: 	current_opcode_message_status[window_id].message_page_count = magic_id;
 995: 	current_opcode_message_status[window_id].message_dialog_id = ff8_current_window_dialog_id;
 996: 	current_opcode_message_status[window_id].message_kind = message_kind::DRAWPOINT;
 997: 	current_opcode_message_status[window_id].field_name = "_drawpoint";
 998: 
 999: 	if (ff8_current_window_dialog_id == 4)
1000: 	{
1001: 		if (opcode_ask_current_option == UCHAR_MAX)
1002: 			current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;
1003: 		else
1004: 			opcode_ask_current_option = win->current_choice_question;
1005: 	}
1006: 
1007: 	return ret;
1008: }
1009: 
1010: int ff8_opcode_voice_mes(int unk)
1011: {
1012: 	byte idx = *(byte *)(unk + 388);
1013: 
1014: 	int dialog_id = *(DWORD *)(unk + 4 * idx--);
1015: 	int window_id = *(DWORD *)(unk + 4 * idx);
1016: 	ff8_win_obj *win = ff8_externals.windows + window_id;
1017: 	int message_current_opcode = win->state;
1018: 	char* field_name = get_current_field_name();
1019: 
1020: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1021: 	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
1022: 	current_opcode_message_status[window_id].field_name = get_current_field_name();
1023: 
1024: 	return ff8_opcode_old_mes(unk);
1025: }
1026: 
1027: int ff8_opcode_voice_ames(int unk)
1028: {
1029: 	byte idx = *(byte *)(unk + 388);
1030: 
1031: 	idx--; // Y Position of window
1032: 	idx--; // X position of window
1033: 	int dialog_id = *(DWORD *)(unk + 4 * idx--);
1034: 	int window_id = *(DWORD *)(unk + 4 * idx);
1035: 	ff8_win_obj *win = ff8_externals.windows + window_id;
1036: 	int message_current_opcode = win->state;
1037: 	char* field_name = get_current_field_name();
1038: 
1039: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1040: 	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
1041: 	current_opcode_message_status[window_id].field_name = get_current_field_name();
1042: 
1043: 	return ff8_opcode_old_ames(unk);
1044: }
1045: 
1046: int ff8_opcode_voice_amesw(int unk)
1047: {
1048: 	byte idx = *(byte *)(unk + 388);
1049: 
1050: 	idx--; // Y Position of window
1051: 	idx--; // X position of window
1052: 	int dialog_id = *(DWORD *)(unk + 4 * idx--);
1053: 	int window_id = *(DWORD *)(unk + 4 * idx);
1054: 	ff8_win_obj *win = ff8_externals.windows + window_id;
1055: 	int message_current_opcode = win->state;
1056: 	char* field_name = get_current_field_name();
1057: 
1058: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1059: 	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
1060: 	current_opcode_message_status[window_id].field_name = get_current_field_name();
1061: 
1062: 	return ff8_opcode_old_amesw(unk);
1063: }
1064: 
1065: int ff8_opcode_voice_ramesw(int unk)
1066: {
1067: 	byte idx = *(byte *)(unk + 388);
1068: 
1069: 	idx--; // Y Position of window
1070: 	idx--; // X position of window
1071: 	int dialog_id = *(DWORD *)(unk + 4 * idx--);
1072: 	int window_id = *(DWORD *)(unk + 4 * idx);
1073: 	ff8_win_obj *win = ff8_externals.windows + window_id;
1074: 	int message_current_opcode = win->state;
1075: 	char* field_name = get_current_field_name();
1076: 
1077: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1078: 	current_opcode_message_status[window_id].message_kind = message_kind::MESSAGE;
1079: 	current_opcode_message_status[window_id].field_name = get_current_field_name();
1080: 
1081: 	return ff8_opcode_old_ramesw(unk);
1082: }
1083: 
1084: int ff8_opcode_voice_ask(int unk)
1085: {
1086: 	byte idx = *(byte *)(unk + 388);
1087: 
1088: 	idx--; // Line of cancel option
1089: 	int default_option = *(DWORD *)(unk + 4 * idx--); // Line of default option
1090: 	idx--; // Line of last option
1091: 	idx--; // Line of first option
1092: 	int dialog_id = *(DWORD *)(unk + 4 * idx--);
1093: 	int window_id = *(DWORD *)(unk + 4 * idx);
1094: 	ff8_win_obj *win = ff8_externals.windows + window_id;
1095: 	int message_current_opcode = win->state;
1096: 	char* field_name = get_current_field_name();
1097: 
1098: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1099: 	current_opcode_message_status[window_id].message_kind = message_kind::ASK;
1100: 	current_opcode_message_status[window_id].field_name = get_current_field_name();
1101: 
1102: 	if (opcode_ask_current_option == UCHAR_MAX)
1103: 		current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;
1104: 	else
1105: 		opcode_ask_current_option = win->current_choice_question;
1106: 
1107: 	return ff8_opcode_old_ask(unk);
1108: }
1109: 
1110: int ff8_opcode_voice_aask(int unk)
1111: {
1112: 	byte idx = *(byte *)(unk + 388);
1113: 
1114: 	idx--; // Y Position of window
1115: 	idx--; // X position of window
1116: 	idx--; // Line of cancel option
1117: 	int default_option = *(DWORD *)(unk + 4 * idx--); // Line of default option
1118: 	idx--; // Line of last option
1119: 	idx--; // Line of first option
1120: 	int dialog_id = *(DWORD *)(unk + 4 * idx--);
1121: 	int window_id = *(DWORD *)(unk + 4 * idx);
1122: 	ff8_win_obj *win = ff8_externals.windows + window_id;
1123: 	int message_current_opcode = win->state;
1124: 	char* field_name = get_current_field_name();
1125: 
1126: 	current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1127: 	current_opcode_message_status[window_id].message_kind = message_kind::ASK;
1128: 	current_opcode_message_status[window_id].field_name = get_current_field_name();
1129: 
1130: 	if (opcode_ask_current_option == UCHAR_MAX)
1131: 		current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option = default_option;
1132: 	else
1133: 		opcode_ask_current_option = win->current_choice_question;
1134: 
1135: 	int ret = ff8_opcode_old_aask(unk);
1136: 
1137: 	if (steam_edition || enable_steam_achievements) {
1138: 		if (ret == 3) // aask exit
1139: 		{
1140: 			// --- Only for unlocking chocobo achievement (only way to implement it) ---
1141: 			int chosen_option = *(DWORD*)(unk + 240);
1142: 			WORD field_id = *common_externals.current_field_id;
1143: 			bool is_field_chocobo_forest = field_id >= 287 && field_id <= 293 && field_id != 290;
1144: 			if (is_field_chocobo_forest && dialog_id == 56 && chosen_option == 0) // capture chocobo
1145: 			{
1146: 				g_FF8SteamAchievements->unlockChocoboAchievement();
1147: 			}
1148: 		}
1149: 	}
1150: 	return ret;
1151: }
1152: 
1153: int ff8_show_dialog(int window_id, int state, int a3)
1154: {
1155: 	struct game_mode *mode = getmode_cached();
1156: 
1157: 	int dialog_id = current_opcode_message_status[window_id].message_dialog_id;
1158: 	ff8_win_obj *win = ff8_externals.windows + window_id;
1159: 	uint32_t message_current_opcode = win->state;
1160: 	message_kind message_kind = current_opcode_message_status[window_id].message_kind;
1161: 	std::string field_name = current_opcode_message_status[window_id].field_name;
1162: 	byte message_page_count = current_opcode_message_status[window_id].message_page_count;
1163: 	if (mode->driver_mode == MODE_WORLDMAP && message_kind == message_kind::ASK) opcode_ask_current_option = win->current_choice_question;
1164: 
1165: 	bool _is_dialog_opening = is_dialog_opening(win->open_close_transition);
1166: 	bool _is_dialog_starting = is_dialog_starting(current_opcode_message_status[window_id].message_last_transition, win->open_close_transition);
1167: 	bool _is_dialog_paging = is_dialog_paging(current_opcode_message_status[window_id].message_last_opcode, message_current_opcode);
1168: 	bool _is_dialog_option_changed = (current_opcode_message_status[window_id].message_last_option != opcode_ask_current_option);
1169: 	bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_transition, win->open_close_transition);
1170: 	bool _is_dialog_closed = is_dialog_closed(current_opcode_message_status[window_id].message_last_transition, win->open_close_transition);
1171: 	bool _is_dialog_ask = (message_kind == message_kind::ASK) || (message_kind == message_kind::DRAWPOINT);
1172: 
1173: 	if (_is_dialog_paging) current_opcode_message_status[window_id].message_page_count++;
1174: 
1175: 	// Skip voice over on Tutorials
1176: 	if (mode->driver_mode == MODE_FIELD)
1177: 	{
1178: 		if (_is_dialog_opening)
1179: 		{
1180: 			opcode_ask_current_option = UCHAR_MAX;
1181: 			begin_voice(window_id);
1182: 			current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1183: 			current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;
1184: 			current_opcode_message_status[window_id].message_kind = message_kind;
1185: 			current_opcode_message_status[window_id].field_name = field_name;
1186: 			if (message_kind == message_kind::DRAWPOINT) current_opcode_message_status[window_id].message_page_count = message_page_count;
1187: 			if (message_kind == message_kind::MESSAGE)
1188: 			{
1189: 				if (ff8_field_window_stack_count.find(*common_externals.current_field_id) == ff8_field_window_stack_count.end())
1190: 					ff8_field_window_stack_count[*common_externals.current_field_id] = 0;
1191: 
1192: 				ff8_field_window_stack_count[*common_externals.current_field_id]++;
1193: 
1194: 				if (ff8_field_window_stack_count[*common_externals.current_field_id] > 1) simulate_OK_disabled[window_id] = true;
1195: 			}
1196: 		}
1197: 		else if (_is_dialog_starting || _is_dialog_paging)
1198: 		{
1199: 			if (_is_dialog_starting) current_opcode_message_status[window_id].char_id = 0; // TODO
1200: 			if (trace_all || trace_opcodes) ffnx_trace("[MESSAGE]: field=%s,window_id=%u,dialog_id=%u,paging_id=%u,char=%X\n", field_name.c_str(), window_id, dialog_id, current_opcode_message_status[window_id].message_page_count, current_opcode_message_status[window_id].char_id);
1201: 			current_opcode_message_status[window_id].is_voice_acting = play_voice((char*)field_name.c_str(), window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
1202: 		}
1203: 		else if (_is_dialog_option_changed && _is_dialog_ask)
1204: 		{
1205: 			if (trace_all || trace_opcodes) ffnx_trace("[ASK]: field=%s,window_id=%u,dialog_id=%u,option_id=%u,char=%X\n", field_name.c_str(), window_id, dialog_id, opcode_ask_current_option,current_opcode_message_status[window_id].char_id);
1206: 			play_option((char*)field_name.c_str(), window_id, dialog_id, opcode_ask_current_option);
1207: 		}
1208: 		else if (_is_dialog_closing)
1209: 		{
1210: 			end_voice(window_id);
1211: 			simulate_OK_disabled[window_id] = false;
1212: 			current_opcode_message_status[window_id].is_voice_acting = false;
1213: 			opcode_ask_current_option = UCHAR_MAX;
1214: 			ff8_current_window_dialog_id = -1;
1215: 			if (message_kind == message_kind::MESSAGE)
1216: 			{
1217: 				if (ff8_field_window_stack_count[*common_externals.current_field_id] > 0)
1218: 					ff8_field_window_stack_count[*common_externals.current_field_id]--;
1219: 			}
1220: 		}
1221: 
1222: 		// Auto close the message if it was voice acted and the audio file has finished playing
1223: 		if (message_kind == message_kind::MESSAGE)
1224: 		{
1225: 			if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
1226: 			{
1227: 				current_opcode_message_status[window_id].is_voice_acting = false;
1228: 				if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
1229: 			}
1230: 		}
1231: 	}
1232: 	else if (mode->driver_mode == MODE_BATTLE)
1233: 	{
1234: 		bool _has_dialog_text_changed = win->field_30 != current_opcode_message_status[window_id].message_dialog_id;
1235: 		bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_transition, message_current_opcode);
1236: 
1237: 		if (_is_dialog_opening)
1238: 		{
1239: 			begin_voice(window_id);
1240: 		}
1241: 		else if (_is_dialog_starting || _has_dialog_text_changed)
1242: 		{
1243: 			std::string decoded_text = ff8_decode_text(win->text_data1);
1244: 			std::string tokenized_dialogue = tokenize_text(decoded_text);
1245: 			std::string actor_name = ff8_decode_text(ff8_battle_actor_name[LOBYTE(*ff8_externals.battle_current_actor_talking)]);
1246: 			std::string tokenized_actor = tokenize_text(actor_name);
1247: 
1248: 			if (trace_all || trace_opcodes || trace_battle_text) ffnx_trace("[BATTLE]: scene_id=%u,actor=%s,text=%s\n", *ff8_externals.battle_encounter_id, actor_name.c_str(), decoded_text.c_str());
1249: 
1250: 			char voice_file[MAX_PATH];
1251: 			sprintf(voice_file, "_battle/%s/%s", tokenized_actor.c_str(), tokenized_dialogue.c_str());
1252: 			current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
1253: 		}
1254: 		else if (_is_dialog_closing)
1255: 		{
1256: 			end_voice(window_id);
1257: 			current_opcode_message_status[window_id].is_voice_acting = false;
1258: 		}
1259: 
1260: 		current_opcode_message_status[window_id].message_dialog_id = win->field_30;
1261: 	}
1262: 	else if (mode->driver_mode == MODE_WORLDMAP)
1263: 	{
1264: 		bool _has_dialog_text_changed = dialog_id != current_opcode_message_status[window_id].message_last_dialog_id;
1265: 
1266: 		if (_is_dialog_opening)
1267: 		{
1268: 			begin_voice(window_id);
1269: 			current_opcode_message_status[window_id].message_dialog_id = dialog_id;
1270: 			current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;
1271: 			current_opcode_message_status[window_id].message_kind = message_kind;
1272: 		}
1273: 		else if (_is_dialog_starting || _has_dialog_text_changed)
1274: 		{
1275: 			if (dialog_id < 0)
1276: 			{
1277: 				std::string decoded_text = ff8_decode_text(win->text_data1);
1278: 				std::string tokenized_dialogue = tokenize_text(decoded_text);
1279: 				if (trace_all || trace_opcodes) ffnx_trace("[WORLD]: window_id=%u,text=%s\n", window_id, decoded_text.c_str());
1280: 
1281: 				char voice_file[MAX_PATH];
1282: 				sprintf(voice_file, "_world/text/%s", tokenized_dialogue.c_str());
1283: 				current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
1284: 			}
1285: 			else
1286: 			{
1287: 				if (trace_all || trace_opcodes) ffnx_trace("[WORLD]: window_id=%u,dialog_id=%d\n", window_id, current_opcode_message_status[window_id].message_dialog_id);
1288: 				current_opcode_message_status[window_id].is_voice_acting = play_voice("_world", window_id, current_opcode_message_status[window_id].message_dialog_id, current_opcode_message_status[window_id].message_page_count);
1289: 			}
1290: 		}
1291: 		else if (_is_dialog_option_changed && _is_dialog_ask)
1292: 		{
1293: 			if (trace_all || trace_opcodes) ffnx_trace("[WORLD]: window_id=%u,dialog_id=%u,option_id=%u,char=%X\n", window_id, dialog_id, opcode_ask_current_option,current_opcode_message_status[window_id].char_id);
1294: 			play_option("_world", window_id, dialog_id, opcode_ask_current_option);
1295: 		}
1296: 		else if (_is_dialog_closing)
1297: 		{
1298: 			end_voice(window_id);
1299: 			current_opcode_message_status[window_id].is_voice_acting = false;
1300: 		}
1301: 
1302: 		// Auto close the message if it was voice acted and the audio file has finished playing
1303: 		if (message_kind == message_kind::MESSAGE)
1304: 		{
1305: 			if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
1306: 			{
1307: 				current_opcode_message_status[window_id].is_voice_acting = false;
1308: 				if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
1309: 			}
1310: 		}
1311: 	}
1312: 	else if (mode->mode == FF8_MODE_TUTO)
1313: 	{
1314: 		bool _has_dialog_text_changed = win->field_30 != current_opcode_message_status[window_id].message_dialog_id;
1315: 		bool _is_dialog_closing = is_dialog_closing(current_opcode_message_status[window_id].message_last_transition, message_current_opcode);
1316: 
1317: 		if (_is_dialog_opening)
1318: 		{
1319: 			begin_voice(window_id);
1320: 		}
1321: 		else if (_is_dialog_starting || _has_dialog_text_changed)
1322: 		{
1323: 			std::string decoded_text = ff8_decode_text(win->text_data1);
1324: 			std::string tokenized_dialogue = tokenize_text(decoded_text);
1325: 
1326: 			if (trace_all || trace_opcodes || trace_battle_text) ffnx_trace("[TUTO]: id=%u,text=%s\n", *ff8_externals.current_tutorial_id, decoded_text.c_str());
1327: 
1328: 			char voice_file[MAX_PATH];
1329: 			sprintf(voice_file, "_tuto/%04u/%s", *ff8_externals.current_tutorial_id, tokenized_dialogue.c_str());
1330: 			current_opcode_message_status[window_id].is_voice_acting = nxAudioEngine.playVoice(voice_file, 0, voice_volume, *common_externals.field_game_moment);
1331: 		}
1332: 		else if (_is_dialog_closing)
1333: 		{
1334: 			end_voice(window_id);
1335: 			simulate_OK_disabled[window_id] = false;
1336: 			current_opcode_message_status[window_id].is_voice_acting = false;
1337: 		}
1338: 
1339: 		current_opcode_message_status[window_id].message_dialog_id = win->field_30;
1340: 
1341: 		if (current_opcode_message_status[window_id].is_voice_acting && !nxAudioEngine.isVoicePlaying(window_id))
1342: 		{
1343: 			current_opcode_message_status[window_id].is_voice_acting = false;
1344: 			if (!simulate_OK_disabled[window_id] && enable_voice_auto_text) simulate_OK_button = true;
1345: 		}
1346: 	}
1347: 
1348: 	current_opcode_message_status[window_id].message_last_opcode = message_current_opcode;
1349: 	current_opcode_message_status[window_id].message_last_transition = win->open_close_transition;
1350: 	current_opcode_message_status[window_id].message_last_option = opcode_ask_current_option;
1351: 	current_opcode_message_status[window_id].message_last_dialog_id = dialog_id;
1352: 
1353: 	return ff8_externals.show_dialog(window_id, state, a3);
1354: }
1355: 
1356: //=============================================================================
1357: 
1358: void voice_init()
1359: {
1360: 	// Prepare up to 10 voice slots
1361: 	nxAudioEngine.setVoiceMaxSlots(10);
1362: 
1363: 	if (!ff8)
1364: 	{
1365: 		ff7_set_master_music_volume = (void (*)(uint32_t))common_externals.set_master_midi_volume;
1366: 
1367: 		opcode_old_message = (int (*)())ff7_externals.opcode_message;
1368: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x40], (DWORD)&opcode_voice_message);
1369: 
1370: 		opcode_old_ask = (int (*)(int))ff7_externals.opcode_ask;
1371: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x48], (DWORD)&opcode_voice_ask);
1372: 		replace_call_function((uint32_t)ff7_externals.opcode_ask + 0x8E, opcode_voice_parse_options);
1373: 
1374: 		opcode_old_wmode = (int (*)())ff7_externals.opcode_wmode;
1375: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x52], (DWORD)&opcode_wmode);
1376: 
1377: 		opcode_wm_old_message = (int (*)(uint8_t,uint8_t))ff7_externals.world_opcode_message;
1378: 		replace_call_function(ff7_externals.world_opcode_message_sub_75EE86 + 0x2B, opcode_wm_message);
1379: 		replace_call_function(ff7_externals.world_sub_75EF46 + 0x8C, opcode_wm_message);
1380: 
1381: 		opcode_wm_old_ask = (int (*)(uint8_t,uint8_t,uint8_t,uint8_t,WORD*))ff7_externals.world_opcode_ask;
1382: 		replace_call_function(ff7_externals.world_opcode_ask_sub_75EEBB + 0x3C, opcode_wm_ask);
1383: 		replace_call_function(ff7_externals.world_sub_75EF46 + 0xAF, opcode_wm_ask);
1384: 
1385: 		opcode_old_tutor = (int (*)())ff7_externals.opcode_tutor;
1386: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x21], (DWORD)&opcode_voice_tutor);
1387: 
1388: 		replace_function(ff7_externals.add_text_to_display_queue, ff7_add_text_to_display_queue);
1389: 		replace_function(ff7_externals.update_display_text_queue, ff7_update_display_text_queue);
1390: 		replace_function(ff7_externals.display_battle_action_text_42782A, ff7_display_battle_action_text);
1391: 		replace_call_function(ff7_externals.run_enemy_ai_script + 0xB7F, ff7_enqueue_script_display_string);
1392: 		replace_call_function(ff7_externals.menu_sub_6CB56A + 0x2B7, ff7_menu_tutorial_render);
1393: 	}
1394: 	else
1395: 	{
1396: 		// == Field ==
1397: 		// All possible message and ask windows
1398: 		ff8_opcode_old_mes = (int (*)(int))ff8_externals.opcode_mes;
1399: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x47], (DWORD)&ff8_opcode_voice_mes);
1400: 
1401: 		ff8_opcode_old_ames = (int (*)(int))ff8_externals.opcode_ames;
1402: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x65], (DWORD)&ff8_opcode_voice_ames);
1403: 
1404: 		ff8_opcode_old_amesw = (int (*)(int))ff8_externals.opcode_amesw;
1405: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x64], (DWORD)&ff8_opcode_voice_amesw);
1406: 
1407: 		ff8_opcode_old_ramesw = (int (*)(int))ff8_externals.opcode_ramesw;
1408: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x116], (DWORD)&ff8_opcode_voice_ramesw);
1409: 
1410: 		ff8_opcode_old_ask = (int (*)(int))ff8_externals.opcode_ask;
1411: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x4A], (DWORD)&ff8_opcode_voice_ask);
1412: 
1413: 		ff8_opcode_old_aask = (int (*)(int))ff8_externals.opcode_aask;
1414: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x6F], (DWORD)&ff8_opcode_voice_aask);
1415: 
1416: 		ff8_opcode_old_drawpoint = (int (*)(int))ff8_externals.opcode_drawpoint;
1417: 		patch_code_dword((uint32_t)&common_externals.execute_opcode_table[0x137], (DWORD)&ff8_opcode_voice_drawpoint);
1418: 
1419: 		replace_function(ff8_externals.field_get_dialog_string, ff8_field_get_dialog_string);
1420: 		replace_call(ff8_externals.sub_4A0C00 + 0x5F, ff8_show_dialog);
1421: 
1422: 		// == Battle ==
1423: 		replace_function(ff8_externals.battle_get_monster_name_sub_495100, ff8_battle_get_monster_name);
1424: 		replace_function(ff8_externals.battle_get_actor_name_sub_47EAF0, ff8_battle_get_actor_name);
1425: 
1426: 		// == World Map ==
1427: 		replace_call_function(ff8_externals.sub_543CB0 + (FF8_US_VERSION ? 0x638 : (FF8_SP_VERSION || FF8_IT_VERSION) ? 0x61C : 0x605), ff8_world_dialog_assign_text);
1428: 		replace_call_function(ff8_externals.sub_5484B0 + (FF8_US_VERSION ? 0x524 : 0x4FD), ff8_world_dialog_assign_text);
1429: 		replace_call_function(ff8_externals.sub_54A230 + (FF8_US_VERSION ? 0xF : 0xD), ff8_world_dialog_assign_text);
1430: 		replace_call_function(ff8_externals.sub_54D7E0 + (FF8_US_VERSION ? 0x72 : 0x6F), ff8_world_dialog_assign_text);
1431: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x206 : 0x20C), ff8_world_dialog_assign_text);
1432: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x396 : 0x3A9), ff8_world_dialog_assign_text);
1433: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x3D2 : 0x3E5), ff8_world_dialog_assign_text);
1434: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x67D : (FF8_SP_VERSION ? 0x6CA : 0x68F)), ff8_world_dialog_assign_text);
1435: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x6A6 : (FF8_SP_VERSION ? 0x6F7 : 0x6BC)), ff8_world_dialog_assign_text);
1436: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0xEED : (FF8_SP_VERSION ? 0xFAD : 0xF72)), ff8_world_dialog_assign_text);
1437: 		replace_call_function(ff8_externals.sub_54FDA0 + (FF8_US_VERSION ? 0xAE : 0xAC), ff8_world_dialog_assign_text);
1438: 		replace_call_function(ff8_externals.sub_54FDA0 + (FF8_US_VERSION ? 0x178 : 0x175), ff8_world_dialog_assign_text);
1439: 		replace_call_function(ff8_externals.sub_543CB0 + (FF8_US_VERSION ? 0x5EE : (FF8_SP_VERSION || FF8_IT_VERSION) ? 0x5D2 : 0x5BB), ff8_world_dialog_question_assign_text);
1440: 		replace_call_function(ff8_externals.sub_5484B0 + (FF8_US_VERSION ? 0xBD : 0x131), ff8_world_dialog_question_assign_text);
1441: 		replace_call_function(ff8_externals.sub_5484B0 + (FF8_US_VERSION ? 0x24F : 0x244), ff8_world_dialog_question_assign_text);
1442: 		replace_call_function(ff8_externals.sub_54D7E0 + (FF8_US_VERSION ? 0x119 : 0x116), ff8_world_dialog_question_assign_text);
1443: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0x621 : (FF8_SP_VERSION ? 0x66A : 0x62F)), ff8_world_dialog_question_assign_text);
1444: 		replace_call_function(ff8_externals.sub_54E9B0 + (FF8_US_VERSION ? 0xBE4 : (FF8_SP_VERSION ? 0xC99 : 0xC5E)), ff8_world_dialog_question_assign_text);
1445: 	}
1446: }
</file>

<file path="src/voice.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //                                                                          //
10: //    This file is part of FFNx                                             //
11: //                                                                          //
12: //    FFNx is free software: you can redistribute it and/or modify          //
13: //    it under the terms of the GNU General Public License as published by  //
14: //    the Free Software Foundation, either version 3 of the License         //
15: //                                                                          //
16: //    FFNx is distributed in the hope that it will be useful,               //
17: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
18: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
19: //    GNU General Public License for more details.                          //
20: /****************************************************************************/
21: 
22: #pragma once
23: 
24: void voice_init();
25: void ff7_handle_wmode_reset();
</file>

<file path="src/widescreen.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Tang-Tang Zhou                                     //
10: //    Copyright (C) 2023 Cosmos                                             //
11: //                                                                          //
12: //    This file is part of FFNx                                             //
13: //                                                                          //
14: //    FFNx is free software: you can redistribute it and/or modify          //
15: //    it under the terms of the GNU General Public License as published by  //
16: //    the Free Software Foundation, either version 3 of the License         //
17: //                                                                          //
18: //    FFNx is distributed in the hope that it will be useful,               //
19: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
20: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
21: //    GNU General Public License for more details.                          //
22: /****************************************************************************/
23: 
24: #pragma once
25: 
26: int wide_viewport_x = -107;
27: int wide_viewport_y = 0;
28: int wide_viewport_width = 854;
29: int wide_viewport_height = 480;
30: 
31: int wide_game_x = 0;
32: int wide_game_y = 0;
33: int wide_game_width = 854;
34: int wide_game_height = 480;
</file>

<file path="src/wine.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 9: //    Copyright (C) 2023 Cosmos                                             //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: #include <windows.h>
26: 
27: typedef const char* (*WineVersionFunction)();
28: inline const char* GetWineVersion() {
29:     HMODULE hModule = LoadLibraryA("ntdll.dll");
30:     if (!hModule) {
31:         return "Wine is not detected.";
32:     }
33: 
34:     WineVersionFunction wine_get_version = (WineVersionFunction)GetProcAddress(hModule, "wine_get_version");
35:     if (!wine_get_version) {
36:         FreeLibrary(hModule);
37:         return "Wine is not detected.";
38:     }
39: 
40:     const char* version = wine_get_version();
41:     FreeLibrary(hModule);
42:     return version;
43: }
</file>

<file path="src/world.cpp">
  1: /****************************************************************************/
  2: //    Copyright (C) 2009 Aali132                                            //
  3: //    Copyright (C) 2018 quantumpencil                                      //
  4: //    Copyright (C) 2018 Maxime Bacoux                                      //
  5: //    Copyright (C) 2020 myst6re                                            //
  6: //    Copyright (C) 2020 Chris Rizzitello                                   //
  7: //    Copyright (C) 2020 John Pritchard                                     //
  8: //    Copyright (C) 2020 Marcin Gomulak                                     //
  9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
 10: //                                                                          //
 11: //    This file is part of FFNx                                             //
 12: //                                                                          //
 13: //    FFNx is free software: you can redistribute it and/or modify          //
 14: //    it under the terms of the GNU General Public License as published by  //
 15: //    the Free Software Foundation, either version 3 of the License         //
 16: //                                                                          //
 17: //    FFNx is distributed in the hope that it will be useful,               //
 18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
 19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
 20: //    GNU General Public License for more details.                          //
 21: /****************************************************************************/
 22: 
 23: #include <imgui.h>
 24: #include <stdint.h>
 25: 
 26: #include "globals.h"
 27: #include "common.h"
 28: #include "patch.h"
 29: 
 30: #include "world.h"
 31: 
 32: 
 33: //https://stackoverflow.com/a/19885112/4509036
 34: #define BYTE_TO_BINARY(byte)  \
 35:   (byte & 0x80 ? '1' : '0'), \
 36:   (byte & 0x40 ? '1' : '0'), \
 37:   (byte & 0x20 ? '1' : '0'), \
 38:   (byte & 0x10 ? '1' : '0'), \
 39:   (byte & 0x08 ? '1' : '0'), \
 40:   (byte & 0x04 ? '1' : '0'), \
 41:   (byte & 0x02 ? '1' : '0'), \
 42:   (byte & 0x01 ? '1' : '0')
 43: 
 44: 
 45: WORD* cameraZoom;
 46: DWORD* playerPosX; //203EE80
 47: DWORD* playerPosZ; //+1
 48: DWORD* playerPosY; //+1; it's dword, but later in game it's &0xFFFF
 49: BYTE* collisionTriangleGroundType; //0x2035D2E
 50: BYTE* collisionTriangleTextureFlag; //+1
 51: 
 52: DWORD* currentCollideTriangle; //ESI+0x1C / 53CEE9
 53: DWORD* bCollisionEnabled;
 54: 
 55: void world_init()
 56: {
 57: 	if (ff8)
 58: 	{
 59: 		cameraZoom = (WORD*)get_absolute_value(ff8_externals.sub_4023D0, 0x10);
 60: 		playerPosX = (DWORD*)get_absolute_value(ff8_externals.sub_53BB90, 0x4C);
 61: 		playerPosZ = playerPosX+1;
 62: 		playerPosY = playerPosX+2;
 63: 		BYTE *wm_struct;
 64: 		if(FF8_US_VERSION)
 65: 		{
 66: 			wm_struct = (BYTE*)get_absolute_value(ff8_externals.sub_53C750, 0x633);
 67: 			bCollisionEnabled = (DWORD*)get_absolute_value(ff8_externals.sub_53E6B0, 0x4);
 68: 		}
 69: 		else
 70: 		{
 71: 			wm_struct = (BYTE*)get_absolute_value(ff8_externals.sub_53C750, 0x649);
 72: 			bCollisionEnabled = (DWORD*)get_absolute_value(ff8_externals.sub_53E6B0, 0x1);
 73: 		}
 74: 		collisionTriangleGroundType = wm_struct + 0x26;
 75: 		collisionTriangleTextureFlag = collisionTriangleGroundType + 1;
 76: 
 77: 		currentCollideTriangle = (DWORD*)(wm_struct + 0x1C);
 78: 	}
 79: }
 80: 
 81: void world_debug(bool* isOpen)
 82: {
 83: 	if (!ImGui::Begin("World Debug", isOpen, ImGuiWindowFlags_::ImGuiWindowFlags_AlwaysAutoResize))
 84: 	{
 85: 		ImGui::End();
 86: 		return;
 87: 	}
 88: 
 89: 	if (getmode_cached()->driver_mode != MODE_WORLDMAP)
 90: 	{
 91: 		ImGui::Text("Not currently on a worldmap.");
 92: 		ImGui::End();
 93: 		return;
 94: 	}
 95: 
 96: 	ImGui::SliderInt("Camera zoom ", (int*)cameraZoom, 0, 9000);
 97: 	ImGui::Text("	Player position:"); //didn't use InputInt3 because it's XZ-Y not XYZ
 98: 	ImGui::InputInt("X", (int*)playerPosX, 10);
 99: 	ImGui::SameLine();
100: 	ImGui::InputInt("Y", (int*)playerPosY, 10);
101: 	ImGui::SameLine();
102: 	ImGui::InputInt("Z", (int*)playerPosZ, 10);
103: 	ImGui::Checkbox("Enable collision", (bool*)bCollisionEnabled);
104: 	ImGui::Text("	Current collide triangle:");
105: 	ImGui::Text("Ground type: %d, texture flag: 0b%c%c%c%c%c%c%c%c", //this is cool stuff
106: 		*collisionTriangleGroundType,
107: 		BYTE_TO_BINARY(*collisionTriangleTextureFlag)
108: 		);
109: 	ImGui::Text("triangle pointer: %08X:", *currentCollideTriangle);
110: 
111: 	if (*currentCollideTriangle != 0) //this is to prevent nullptr crashes
112: 	{
113: 		ImU8 u8step = 1;
114: 		ImU8 u8stepTen = 10;
115: 		int tPage, clut, texFlags, vertFlags;
116: 		bool texFlagsBool[8];
117: 		bool vertFlagsBool[8];
118: 		tPage = (*((BYTE*)*currentCollideTriangle + 12) >> 4) & 0x0F;
119: 		clut = *((BYTE*)*currentCollideTriangle + 12) &0x0F;
120: 		texFlags = *((BYTE*)*currentCollideTriangle + 14);
121: 		vertFlags = *((BYTE*)*currentCollideTriangle + 15);
122: 
123: 		for (int i = 0; i < 8; i++)
124: 		{
125: 			texFlagsBool[i] = ((texFlags >> 7 - i) & 0b1) == 1;
126: 			vertFlagsBool[i] = ((vertFlags >> 7 - i) & 0b1) == 1;
127: 		}
128: 
129: 		ImGui::InputScalar("F1", ImGuiDataType_U8 ,(BYTE*)*currentCollideTriangle, &u8step, &u8stepTen, "%d");
130: 		ImGui::SameLine();
131: 		ImGui::InputScalar("F2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 1, &u8step, &u8stepTen, "%d");
132: 		ImGui::SameLine();
133: 		ImGui::InputScalar("F3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 2, &u8step, &u8stepTen, "%d");
134: 
135: 		ImGui::InputScalar("N1", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 3, &u8step, &u8stepTen, "%d");
136: 		ImGui::SameLine();
137: 		ImGui::InputScalar("N2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 4, &u8step, &u8stepTen, "%d");
138: 		ImGui::SameLine();
139: 		ImGui::InputScalar("N3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 5, &u8step, &u8stepTen, "%d");
140: 
141: 		ImGui::InputScalar("U1", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 6, &u8step, &u8stepTen, "%d");
142: 		ImGui::SameLine();
143: 		ImGui::InputScalar("V1", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 7, &u8step, &u8stepTen, "%d");
144: 		ImGui::InputScalar("U2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 8, &u8step, &u8stepTen, "%d");
145: 		ImGui::SameLine();
146: 		ImGui::InputScalar("V2", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 9, &u8step, &u8stepTen, "%d");
147: 		ImGui::InputScalar("U3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 10, &u8step, &u8stepTen, "%d");
148: 		ImGui::SameLine();
149: 		ImGui::InputScalar("V3", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 11, &u8step, &u8stepTen, "%d");
150: 
151: 		ImGui::InputInt("TPage", &tPage);
152: 		ImGui::InputInt("Clut", &clut);
153: 		ImGui::InputScalar("Ground type", ImGuiDataType_U8, (BYTE*)*currentCollideTriangle + 13, &u8step, &u8stepTen, "%d");
154: 
155: 		ImGui::Text("TEXFLAGS:");
156: 		ImGui::Checkbox("TEXFLAGS_MISC", &texFlagsBool[0]);
157: 		ImGui::Checkbox("TEXFLAGS_WATER", &texFlagsBool[1]);
158: 		ImGui::Checkbox("TEXFLAGS_ROAD", &texFlagsBool[2]);
159: 		ImGui::Checkbox("TEXFLAGS_TRANSPARENT", &texFlagsBool[3]);
160: 		ImGui::Checkbox("TEXFLAGS_ENTERABLE", &texFlagsBool[4]);
161: 		ImGui::Checkbox("TEXFLAGS_UNK", &texFlagsBool[5]);
162: 		ImGui::Checkbox("TEXFLAGS_SHADOW1", &texFlagsBool[6]);
163: 		ImGui::Checkbox("TEXFLAGS_SHADOW2", &texFlagsBool[7]);
164: 		texFlags = 0;
165: 		texFlags |= texFlagsBool[0] ? 0x80 : 00;
166: 		texFlags |= texFlagsBool[1] ? 0x40 : 00;
167: 		texFlags |= texFlagsBool[2] ? 0x20 : 00;
168: 		texFlags |= texFlagsBool[3] ? 0x10 : 00;
169: 		texFlags |= texFlagsBool[4] ? 0x08 : 00;
170: 		texFlags |= texFlagsBool[5] ? 0x04 : 00;
171: 		texFlags |= texFlagsBool[6] ? 0x02 : 00;
172: 		texFlags |= texFlagsBool[7] ? 0x01 : 00;
173: 
174: 		ImGui::Text("VERTFLAGS:");
175: 		ImGui::Checkbox("VERTFLAGS_WALKABLE", &vertFlagsBool[0]);
176: 		ImGui::Checkbox("VERTFLAGS_UNK", &vertFlagsBool[1]);
177: 		ImGui::Checkbox("VERTFLAGS_UNK2", &vertFlagsBool[2]);
178: 		ImGui::Checkbox("VERTFLAGS_WALKABLECHOCOBO?", &vertFlagsBool[3]);
179: 		ImGui::Checkbox("VERTFLAGS_UNK3", &vertFlagsBool[4]);
180: 		ImGui::Checkbox("VERTFLAGS_UNK4", &vertFlagsBool[5]);
181: 		ImGui::Checkbox("VERTFLAGS_UNK5", &vertFlagsBool[6]);
182: 		ImGui::Checkbox("VERTFLAGS_UNK6", &vertFlagsBool[7]);
183: 		vertFlags = 0;
184: 		vertFlags |= vertFlagsBool[0] ? 0x80 : 00;
185: 		vertFlags |= vertFlagsBool[1] ? 0x40 : 00;
186: 		vertFlags |= vertFlagsBool[2] ? 0x20 : 00;
187: 		vertFlags |= vertFlagsBool[3] ? 0x10 : 00;
188: 		vertFlags |= vertFlagsBool[4] ? 0x08 : 00;
189: 		vertFlags |= vertFlagsBool[5] ? 0x04 : 00;
190: 		vertFlags |= vertFlagsBool[6] ? 0x02 : 00;
191: 		vertFlags |= vertFlagsBool[7] ? 0x01 : 00;
192: 
193: 		*((BYTE*)*currentCollideTriangle + 12) = (BYTE)(tPage<<4 | clut);
194: 		*((BYTE*)*currentCollideTriangle + 14) = (BYTE)texFlags;
195: 		*((BYTE*)*currentCollideTriangle + 15) = (BYTE)vertFlags;
196: 	}
197: 
198: 
199: 	ImGui::End();
200: }
</file>

<file path="src/world.h">
 1: /****************************************************************************/
 2: //    Copyright (C) 2009 Aali132                                            //
 3: //    Copyright (C) 2018 quantumpencil                                      //
 4: //    Copyright (C) 2018 Maxime Bacoux                                      //
 5: //    Copyright (C) 2020 myst6re                                            //
 6: //    Copyright (C) 2020 Chris Rizzitello                                   //
 7: //    Copyright (C) 2020 John Pritchard                                     //
 8: //    Copyright (C) 2020 Marcin Gomulak                                     //
 9: //    Copyright (C) 2025 Julian Xhokaxhiu                                   //
10: //                                                                          //
11: //    This file is part of FFNx                                             //
12: //                                                                          //
13: //    FFNx is free software: you can redistribute it and/or modify          //
14: //    it under the terms of the GNU General Public License as published by  //
15: //    the Free Software Foundation, either version 3 of the License         //
16: //                                                                          //
17: //    FFNx is distributed in the hope that it will be useful,               //
18: //    but WITHOUT ANY WARRANTY; without even the implied warranty of        //
19: //    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
20: //    GNU General Public License for more details.                          //
21: /****************************************************************************/
22: 
23: #pragma once
24: 
25: void world_init();
26: void world_debug(bool* isOpen);
</file>

<file path=".editorconfig">
 1: # EditorConfig is awesome: https://EditorConfig.org
 2: 
 3: root = true
 4: 
 5: [*]
 6: end_of_line = lf
 7: indent_size = 2
 8: indent_style = space
 9: insert_final_newline = true
10: trim_trailing_whitespace = true
</file>

<file path=".gitignore">
  1: ## Get latest from https://github.com/github/gitignore/blob/main/C%2B%2B.gitignore
  2: 
  3: # Prerequisites
  4: *.d
  5: 
  6: # Compiled Object files
  7: *.slo
  8: *.lo
  9: *.o
 10: *.obj
 11: 
 12: # Precompiled Headers
 13: *.gch
 14: *.pch
 15: 
 16: # Compiled Dynamic libraries
 17: *.so
 18: *.dylib
 19: *.dll
 20: 
 21: # Fortran module files
 22: *.mod
 23: *.smod
 24: 
 25: # Compiled Static libraries
 26: *.lai
 27: *.la
 28: *.a
 29: *.lib
 30: 
 31: # Executables
 32: *.exe
 33: *.out
 34: *.app
 35: 
 36: ## Ignore Visual Studio temporary files, build results, and
 37: ## files generated by popular Visual Studio add-ons.
 38: ##
 39: ## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore
 40: 
 41: # User-specific files
 42: *.rsuser
 43: *.suo
 44: *.user
 45: *.userosscache
 46: *.sln.docstates
 47: 
 48: # User-specific files (MonoDevelop/Xamarin Studio)
 49: *.userprefs
 50: 
 51: # Mono auto generated files
 52: mono_crash.*
 53: 
 54: # Build results
 55: [Dd]ebug/
 56: [Dd]ebugPublic/
 57: [Rr]elease/
 58: [Rr]eleases/
 59: x64/
 60: x86/
 61: [Ww][Ii][Nn]32/
 62: [Aa][Rr][Mm]/
 63: [Aa][Rr][Mm]64/
 64: bld/
 65: [Bb]in/
 66: [Oo]bj/
 67: [Ll]og/
 68: [Ll]ogs/
 69: 
 70: # Visual Studio 2015/2017 cache/options directory
 71: .vs/
 72: # Uncomment if you have tasks that create the project's static files in wwwroot
 73: #wwwroot/
 74: 
 75: # Visual Studio 2017 auto generated files
 76: Generated\ Files/
 77: 
 78: # MSTest test Results
 79: [Tt]est[Rr]esult*/
 80: [Bb]uild[Ll]og.*
 81: 
 82: # NUnit
 83: *.VisualState.xml
 84: TestResult.xml
 85: nunit-*.xml
 86: 
 87: # Build Results of an ATL Project
 88: [Dd]ebugPS/
 89: [Rr]eleasePS/
 90: dlldata.c
 91: 
 92: # Benchmark Results
 93: BenchmarkDotNet.Artifacts/
 94: 
 95: # .NET Core
 96: project.lock.json
 97: project.fragment.lock.json
 98: artifacts/
 99: 
100: # ASP.NET Scaffolding
101: ScaffoldingReadMe.txt
102: 
103: # StyleCop
104: StyleCopReport.xml
105: 
106: # Files built by Visual Studio
107: *_i.c
108: *_p.c
109: *_h.h
110: *.ilk
111: *.meta
112: *.obj
113: *.iobj
114: *.pch
115: *.pdb
116: *.ipdb
117: *.pgc
118: *.pgd
119: *.rsp
120: # but not Directory.Build.rsp, as it configures directory-level build defaults
121: !Directory.Build.rsp
122: *.sbr
123: *.tlb
124: *.tli
125: *.tlh
126: *.tmp
127: *.tmp_proj
128: *_wpftmp.csproj
129: *.log
130: *.tlog
131: *.vspscc
132: *.vssscc
133: .builds
134: *.pidb
135: *.svclog
136: *.scc
137: 
138: # Chutzpah Test files
139: _Chutzpah*
140: 
141: # Visual C++ cache files
142: ipch/
143: *.aps
144: *.ncb
145: *.opendb
146: *.opensdf
147: *.sdf
148: *.cachefile
149: *.VC.db
150: *.VC.VC.opendb
151: 
152: # Visual Studio profiler
153: *.psess
154: *.vsp
155: *.vspx
156: *.sap
157: 
158: # Visual Studio Trace Files
159: *.e2e
160: 
161: # TFS 2012 Local Workspace
162: $tf/
163: 
164: # Guidance Automation Toolkit
165: *.gpState
166: 
167: # ReSharper is a .NET coding add-in
168: _ReSharper*/
169: *.[Rr]e[Ss]harper
170: *.DotSettings.user
171: 
172: # TeamCity is a build add-in
173: _TeamCity*
174: 
175: # DotCover is a Code Coverage Tool
176: *.dotCover
177: 
178: # AxoCover is a Code Coverage Tool
179: .axoCover/*
180: !.axoCover/settings.json
181: 
182: # Coverlet is a free, cross platform Code Coverage Tool
183: coverage*.json
184: coverage*.xml
185: coverage*.info
186: 
187: # Visual Studio code coverage results
188: *.coverage
189: *.coveragexml
190: 
191: # NCrunch
192: _NCrunch_*
193: .NCrunch_*
194: .*crunch*.local.xml
195: nCrunchTemp_*
196: 
197: # MightyMoose
198: *.mm.*
199: AutoTest.Net/
200: 
201: # Web workbench (sass)
202: .sass-cache/
203: 
204: # Installshield output folder
205: [Ee]xpress/
206: 
207: # DocProject is a documentation generator add-in
208: DocProject/buildhelp/
209: DocProject/Help/*.HxT
210: DocProject/Help/*.HxC
211: DocProject/Help/*.hhc
212: DocProject/Help/*.hhk
213: DocProject/Help/*.hhp
214: DocProject/Help/Html2
215: DocProject/Help/html
216: 
217: # Click-Once directory
218: publish/
219: 
220: # Publish Web Output
221: *.[Pp]ublish.xml
222: *.azurePubxml
223: # Note: Comment the next line if you want to checkin your web deploy settings,
224: # but database connection strings (with potential passwords) will be unencrypted
225: *.pubxml
226: *.publishproj
227: 
228: # Microsoft Azure Web App publish settings. Comment the next line if you want to
229: # checkin your Azure Web App publish settings, but sensitive information contained
230: # in these scripts will be unencrypted
231: PublishScripts/
232: 
233: # NuGet Packages
234: *.nupkg
235: # NuGet Symbol Packages
236: *.snupkg
237: # The packages folder can be ignored because of Package Restore
238: **/[Pp]ackages/*
239: # except build/, which is used as an MSBuild target.
240: !**/[Pp]ackages/build/
241: # Uncomment if necessary however generally it will be regenerated when needed
242: #!**/[Pp]ackages/repositories.config
243: # NuGet v3's project.json files produces more ignorable files
244: *.nuget.props
245: *.nuget.targets
246: 
247: # Microsoft Azure Build Output
248: csx/
249: *.build.csdef
250: 
251: # Microsoft Azure Emulator
252: ecf/
253: rcf/
254: 
255: # Windows Store app package directories and files
256: AppPackages/
257: BundleArtifacts/
258: Package.StoreAssociation.xml
259: _pkginfo.txt
260: *.appx
261: *.appxbundle
262: *.appxupload
263: 
264: # Visual Studio cache files
265: # files ending in .cache can be ignored
266: *.[Cc]ache
267: # but keep track of directories ending in .cache
268: !?*.[Cc]ache/
269: 
270: # Others
271: ClientBin/
272: ~$*
273: *~
274: *.dbmdl
275: *.dbproj.schemaview
276: *.jfm
277: *.pfx
278: *.publishsettings
279: orleans.codegen.cs
280: 
281: # Including strong name files can present a security risk
282: # (https://github.com/github/gitignore/pull/2483#issue-259490424)
283: #*.snk
284: 
285: # Since there are multiple workflows, uncomment next line to ignore bower_components
286: # (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
287: #bower_components/
288: 
289: # RIA/Silverlight projects
290: Generated_Code/
291: 
292: # Backup & report files from converting an old project file
293: # to a newer Visual Studio version. Backup files are not needed,
294: # because we have git ;-)
295: _UpgradeReport_Files/
296: Backup*/
297: UpgradeLog*.XML
298: UpgradeLog*.htm
299: ServiceFabricBackup/
300: *.rptproj.bak
301: 
302: # SQL Server files
303: *.mdf
304: *.ldf
305: *.ndf
306: 
307: # Business Intelligence projects
308: *.rdl.data
309: *.bim.layout
310: *.bim_*.settings
311: *.rptproj.rsuser
312: *- [Bb]ackup.rdl
313: *- [Bb]ackup ([0-9]).rdl
314: *- [Bb]ackup ([0-9][0-9]).rdl
315: 
316: # Microsoft Fakes
317: FakesAssemblies/
318: 
319: # GhostDoc plugin setting file
320: *.GhostDoc.xml
321: 
322: # Node.js Tools for Visual Studio
323: .ntvs_analysis.dat
324: node_modules/
325: 
326: # Visual Studio 6 build log
327: *.plg
328: 
329: # Visual Studio 6 workspace options file
330: *.opt
331: 
332: # Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
333: *.vbw
334: 
335: # Visual Studio 6 auto-generated project file (contains which files were open etc.)
336: *.vbp
337: 
338: # Visual Studio 6 workspace and project file (working project files containing files to include in project)
339: *.dsw
340: *.dsp
341: 
342: # Visual Studio 6 technical files
343: *.ncb
344: *.aps
345: 
346: # Visual Studio LightSwitch build output
347: **/*.HTMLClient/GeneratedArtifacts
348: **/*.DesktopClient/GeneratedArtifacts
349: **/*.DesktopClient/ModelManifest.xml
350: **/*.Server/GeneratedArtifacts
351: **/*.Server/ModelManifest.xml
352: _Pvt_Extensions
353: 
354: # Paket dependency manager
355: .paket/paket.exe
356: paket-files/
357: 
358: # FAKE - F# Make
359: .fake/
360: 
361: # CodeRush personal settings
362: .cr/personal
363: 
364: # Python Tools for Visual Studio (PTVS)
365: __pycache__/
366: *.pyc
367: 
368: # Cake - Uncomment if you are using it
369: # tools/**
370: # !tools/packages.config
371: 
372: # Tabs Studio
373: *.tss
374: 
375: # Telerik's JustMock configuration file
376: *.jmconfig
377: 
378: # BizTalk build output
379: *.btp.cs
380: *.btm.cs
381: *.odx.cs
382: *.xsd.cs
383: 
384: # OpenCover UI analysis results
385: OpenCover/
386: 
387: # Azure Stream Analytics local run output
388: ASALocalRun/
389: 
390: # MSBuild Binary and Structured Log
391: *.binlog
392: 
393: # NVidia Nsight GPU debugger configuration file
394: *.nvuser
395: 
396: # MFractors (Xamarin productivity tool) working folder
397: .mfractor/
398: 
399: # Local History for Visual Studio
400: .localhistory/
401: 
402: # Visual Studio History (VSHistory) files
403: .vshistory/
404: 
405: # BeatPulse healthcheck temp database
406: healthchecksdb
407: 
408: # Backup folder for Package Reference Convert tool in Visual Studio 2017
409: MigrationBackup/
410: 
411: # Ionide (cross platform F# VS Code tools) working folder
412: .ionide/
413: 
414: # Fody - auto-generated XML schema
415: FodyWeavers.xsd
416: 
417: # VS Code files for those working on multiple tools
418: .vscode/*
419: !.vscode/settings.json
420: !.vscode/tasks.json
421: !.vscode/launch.json
422: !.vscode/extensions.json
423: *.code-workspace
424: 
425: # Local History for Visual Studio Code
426: .history/
427: 
428: # Windows Installer files from build outputs
429: *.cab
430: *.msi
431: *.msix
432: *.msm
433: *.msp
434: 
435: # JetBrains Rider
436: *.sln.iml
437: 
438: ## Get latest from https://github.com/github/gitignore/blob/main/CMake.gitignore
439: 
440: CMakeLists.txt.user
441: CMakeCache.txt
442: CMakeFiles
443: CMakeScripts
444: Testing
445: Makefile
446: cmake_install.cmake
447: install_manifest.txt
448: compile_commands.json
449: CTestTestfile.cmake
450: _deps
451: CMakeUserPresets.json
452: 
453: ## Get latest from https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
454: 
455: # Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider
456: # Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839
457: 
458: # User-specific stuff
459: .idea/**/workspace.xml
460: .idea/**/tasks.xml
461: .idea/**/usage.statistics.xml
462: .idea/**/dictionaries
463: .idea/**/shelf
464: 
465: # AWS User-specific
466: .idea/**/aws.xml
467: 
468: # Generated files
469: .idea/**/contentModel.xml
470: 
471: # Sensitive or high-churn files
472: .idea/**/dataSources/
473: .idea/**/dataSources.ids
474: .idea/**/dataSources.local.xml
475: .idea/**/sqlDataSources.xml
476: .idea/**/dynamic.xml
477: .idea/**/uiDesigner.xml
478: .idea/**/dbnavigator.xml
479: 
480: # Gradle
481: .idea/**/gradle.xml
482: .idea/**/libraries
483: 
484: # Gradle and Maven with auto-import
485: # When using Gradle or Maven with auto-import, you should exclude module files,
486: # since they will be recreated, and may cause churn.  Uncomment if using
487: # auto-import.
488: # .idea/artifacts
489: # .idea/compiler.xml
490: # .idea/jarRepositories.xml
491: # .idea/modules.xml
492: # .idea/*.iml
493: # .idea/modules
494: # *.iml
495: # *.ipr
496: 
497: # CMake
498: cmake-build-*/
499: 
500: # Mongo Explorer plugin
501: .idea/**/mongoSettings.xml
502: 
503: # File-based project format
504: *.iws
505: 
506: # IntelliJ
507: out/
508: 
509: # mpeltonen/sbt-idea plugin
510: .idea_modules/
511: 
512: # JIRA plugin
513: atlassian-ide-plugin.xml
514: 
515: # Cursive Clojure plugin
516: .idea/replstate.xml
517: 
518: # SonarLint plugin
519: .idea/sonarlint/
520: .idea/sonarlint.xml # see https://community.sonarsource.com/t/is-the-file-idea-idea-idea-sonarlint-xml-intended-to-be-under-source-control/121119
521: 
522: # Crashlytics plugin (for Android Studio and IntelliJ)
523: com_crashlytics_export_strings.xml
524: crashlytics.properties
525: crashlytics-build.properties
526: fabric.properties
527: 
528: # Editor-based Rest Client
529: .idea/httpRequests
530: 
531: # Android studio 3.1+ serialized cache file
532: .idea/caches/build_file_checksums.ser
533: 
534: ## Custom section
535: 
536: # Build directory
537: .build
538: 
539: # vcpkg
540: vcpkg_installed/
</file>

<file path=".gitmodules">
1: [submodule "vcpkg"]
2: 	path = vcpkg
3: 	url = https://github.com/microsoft/vcpkg.git
</file>

<file path=".vsconfig">
 1: {
 2:   "version": "1.0",
 3:   "components": [
 4:     "Microsoft.VisualStudio.Component.CoreEditor",
 5:     "Microsoft.VisualStudio.Workload.CoreEditor",
 6:     "Microsoft.Net.Component.4.8.SDK",
 7:     "Microsoft.Net.Component.4.7.2.TargetingPack",
 8:     "Microsoft.Net.ComponentGroup.DevelopmentPrerequisites",
 9:     "Microsoft.VisualStudio.ComponentGroup.WebToolsExtensions",
10:     "Microsoft.VisualStudio.Component.Roslyn.Compiler",
11:     "Microsoft.Component.MSBuild",
12:     "Microsoft.VisualStudio.Component.Roslyn.LanguageServices",
13:     "Microsoft.VisualStudio.Component.TextTemplating",
14:     "Microsoft.VisualStudio.Component.NuGet",
15:     "Microsoft.VisualStudio.Component.SQL.CLR",
16:     "Microsoft.Component.ClickOnce",
17:     "Microsoft.VisualStudio.Component.ManagedDesktop.Core",
18:     "Microsoft.NetCore.Component.Runtime.6.0",
19:     "Microsoft.NetCore.Component.SDK",
20:     "Microsoft.VisualStudio.Component.FSharp",
21:     "Microsoft.ComponentGroup.ClickOnce.Publish",
22:     "Microsoft.NetCore.Component.DevelopmentTools",
23:     "Microsoft.Net.Component.4.8.TargetingPack",
24:     "Microsoft.Net.ComponentGroup.4.8.DeveloperTools",
25:     "Microsoft.VisualStudio.Component.DiagnosticTools",
26:     "Microsoft.VisualStudio.Component.EntityFramework",
27:     "Microsoft.VisualStudio.Component.Debugger.JustInTime",
28:     "Microsoft.VisualStudio.Component.IntelliCode",
29:     "Microsoft.Net.Component.4.6.2.TargetingPack",
30:     "Microsoft.Net.Component.4.7.TargetingPack",
31:     "Microsoft.Net.Component.4.7.1.TargetingPack",
32:     "Microsoft.VisualStudio.Component.VC.CoreIde",
33:     "Microsoft.VisualStudio.Component.Windows10SDK",
34:     "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
35:     "Microsoft.VisualStudio.Component.Graphics.Tools",
36:     "Microsoft.VisualStudio.Component.VC.DiagnosticTools",
37:     "Microsoft.VisualStudio.Component.Windows10SDK.19041",
38:     "Microsoft.VisualStudio.Component.ManagedDesktop.Prerequisites",
39:     "Microsoft.ComponentGroup.Blend",
40:     "Microsoft.VisualStudio.ComponentGroup.MSIX.Packaging",
41:     "Microsoft.VisualStudio.Workload.ManagedDesktop",
42:     "Microsoft.VisualStudio.Component.VC.Redist.14.Latest",
43:     "Microsoft.VisualStudio.ComponentGroup.NativeDesktop.Core",
44:     "Microsoft.VisualStudio.ComponentGroup.WebToolsExtensions.CMake",
45:     "Microsoft.VisualStudio.Component.VC.CMake.Project",
46:     "Microsoft.VisualStudio.Component.VC.ATL",
47:     "Microsoft.VisualStudio.Component.VC.TestAdapterForBoostTest",
48:     "Microsoft.VisualStudio.Component.VC.TestAdapterForGoogleTest",
49:     "Microsoft.VisualStudio.Component.VC.ASAN",
50:     "Microsoft.VisualStudio.Component.Windows10SDK.20348",
51:     "Microsoft.VisualStudio.Workload.NativeDesktop",
52:     "Microsoft.Net.ComponentGroup.TargetingPacks.Common",
53:     "Microsoft.Net.Component.4.6.TargetingPack",
54:     "Microsoft.Net.Component.4.6.1.TargetingPack"
55:   ]
56: }
</file>

<file path="Changelog.md">
   1: # Next
   2: 
   3: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.23.0...master
   4: 
   5: ## FF8
   6: 
   7: - Core: Fix crashes happening in Non-US versions ( https://github.com/julianxhokaxhiu/FFNx/pull/848 )
   8: - External textures: Fix glitches in field module ( https://github.com/julianxhokaxhiu/FFNx/pull/848 https://github.com/julianxhokaxhiu/FFNx/pull/851 )
   9: - External textures: Fix Tonberry format when dumping PNGs using `save_textures_legacy` flag ( https://github.com/julianxhokaxhiu/FFNx/pull/848 )
  10: - Graphics: Use more precise texture UVs ( https://github.com/julianxhokaxhiu/FFNx/pull/852 )
  11: 
  12: # 1.23.0
  13: 
  14: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.22.0...1.23.0
  15: 
  16: ## Common
  17: 
  18: - Core: Improve error message on crash and make the link clickable
  19: - Core: Revise LUT shader code to avoid 1.0 coordinates that some graphics drivers may sample incorrectly ( https://github.com/julianxhokaxhiu/FFNx/pull/813 )
  20: - Renderer: Fix game crashing while using Vulkan returning error VK_ERROR_OUT_OF_POOL_MEMORY
  21: 
  22: ## FF7
  23: 
  24: - 60FPS: Fix escape magic animation speed (https://github.com/julianxhokaxhiu/FFNx/issues/794)
  25: - 60FPS: Fix manipulate, poison and regen effect animation in battle (https://github.com/julianxhokaxhiu/FFNx/issues/817)
  26: - Core: Fix core game bug issue happening on the wind wall fields `woa_*` ( https://github.com/julianxhokaxhiu/FFNx/issues/797 )
  27: - Core: Fix FADE opcode fading color when type=2 is used ( https://github.com/julianxhokaxhiu/FFNx/issues/805 )
  28: - Core: Fix Credits playing too fast ( https://github.com/julianxhokaxhiu/FFNx/issues/828 )
  29: - Direct: Fix scene.bin chunk load logic which was using the wrong chunk ID when loading from disk
  30: - GameHacks: Allow to skip ending movie using the movie skip shortcut
  31: - Input: Fix Auto-Run behavior for NPCs when using the analogue controller ( https://github.com/julianxhokaxhiu/FFNx/issues/831 )
  32: 
  33: ## FF8
  34: 
  35: - Core: Fix crash when entering field in JP version ( https://github.com/julianxhokaxhiu/FFNx/pull/827 )
  36: - Core: Fix crashes happening in Non-US versions ( https://github.com/julianxhokaxhiu/FFNx/pull/821 )
  37: - Direct file: field subarchives (mapdata.fs for example) can now be loaded outside field.fs ( https://github.com/julianxhokaxhiu/FFNx/pull/822 )
  38: - External textures: Fix Rinoa battle model that do not get replaced ( https://github.com/julianxhokaxhiu/FFNx/pull/790 )
  39: - External textures: Swizzle as one image: Fix stride, was `imgWidth / imgScale` instead of `imgWidth`. (https://github.com/julianxhokaxhiu/FFNx/pull/842)
  40: - Input: Allow to capture input from Gamepad when game window is not focused ( https://github.com/julianxhokaxhiu/FFNx/pull/804 )
  41: - Movie: Fix CAM file loading when bigger than 312KB
  42: - Widescreen: Initial support for the entire game
  43: - Widescreen: Fix menu rendering bringing it back to its original aspect ratio
  44: - Widescreen: Enable some full 3D areas to be seen entirely instead of vertically cropped
  45: 
  46: ## FF8 Steam
  47: 
  48: - Achievements: Add support for all Steam achievements
  49: 
  50: # 1.22.0
  51: 
  52: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.21.3...1.22.0
  53: 
  54: ## Commmon
  55: 
  56: - Core: Users can now choose on which screen to run the game, using the new `display_index` option.
  57: - Music: Add the ability to play a custom `main_menu` music file on the new game screen.
  58: 
  59: ## FF7
  60: 
  61: - Core: Fix memory leak when using the field chunk functionality ( https://github.com/julianxhokaxhiu/FFNx/issues/768 )
  62: - Cheats: Use equipped Attack behavior when using auto-attack shortcut ( https://github.com/julianxhokaxhiu/FFNx/pull/773 )
  63: - Music: Allow to use a custom music track per world map area ( music files will have an `_aXX` format appended to the file name, where XX is the area ID )
  64: - Rendering: Add uncrop option to remove black bars from top/bottom of the screen ( https://github.com/julianxhokaxhiu/FFNx/pull/767 )
  65: 
  66: ## FF8
  67: 
  68: - Input: Fix regression supporting native Steam input config when using the native launcher.
  69: - Modding: Allow modding card texts hardcoded in exe ( https://github.com/julianxhokaxhiu/FFNx/pull/774 )
  70: - Modding: Allow modding draw texts hardcoded in exe ( https://github.com/julianxhokaxhiu/FFNx/pull/774 )
  71: - Rendering: Fix red cross not showing in GF boost ability when ff8_use_gamepad_icons is enabled ( https://github.com/julianxhokaxhiu/FFNx/pull/784 )
  72: - SFX: Fix incorrect volume assignment when playing sfx effects using the external layer
  73: 
  74: # 1.21.3
  75: 
  76: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.21.2...1.21.3
  77: 
  78: ## FF7 Steam
  79: 
  80: - Achievements: Fix unlocking achievements when using Steam
  81: 
  82: ## FF8 Steam
  83: 
  84: - Choco: Create a custom driver that allows to launch the mini game without the need of a custom protocol
  85: 
  86: # 1.21.2
  87: 
  88: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.21.1...1.21.2
  89: 
  90: ## FF7
  91: 
  92: - Core: Fix field chunk size calculation for the chunk number 9 ( https://github.com/julianxhokaxhiu/FFNx/pull/763 )
  93: 
  94: # 1.21.1
  95: 
  96: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.21.0...1.21.1
  97: 
  98: ## FF7
  99: 
 100: - Core: Fix loading field lgp files that might have incorrect headers ( https://github.com/julianxhokaxhiu/FFNx/issues/758 )
 101: 
 102: ## FF8
 103: 
 104: - External textures: Fix texture not reloaded between fields ( https://github.com/julianxhokaxhiu/FFNx/pull/761 )
 105: 
 106: ## FF8 Steam
 107: 
 108: - Input: Fix button schema mapping
 109: 
 110: # 1.21.0
 111: 
 112: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.20.3...1.21.0
 113: 
 114: ## Common
 115: 
 116: - Core: Fix bgfx crash when memory cannot be allocated ( https://github.com/julianxhokaxhiu/FFNx/pull/755 )
 117: - Voice: Add support for `config.toml` configuration override based on Game Moment ID
 118: 
 119: ## FF8
 120: 
 121: - Core: Fix crash for non-us versions introduced in 1.20.3 ( https://github.com/julianxhokaxhiu/FFNx/pull/741 )
 122: - Core: Fix crash when `more_debug` option is enabled ( https://github.com/julianxhokaxhiu/FFNx/pull/749 )
 123: - Ambient: Fix missing Battle ID for battles triggered using field opcodes
 124: - Ambient: Fix Battle ID detection for random encounters in Field
 125: - Modding: Fix blending in external textures ( https://github.com/julianxhokaxhiu/FFNx/pull/749 )
 126: - Modding: Allow modding card names hardcoded in exe ( https://github.com/julianxhokaxhiu/FFNx/pull/739 )
 127: - Modding: Add compatibility to LZ4 compression in FS archives ( https://github.com/julianxhokaxhiu/FFNx/pull/741 https://github.com/julianxhokaxhiu/FFNx/pull/743/files )
 128: - Rendering: Add support for substractive blending ( https://github.com/julianxhokaxhiu/FFNx/pull/750 )
 129: - Voice: Add support for Worldmap question dialogs
 130: - Voice: Add support for Auto text in World messages
 131: 
 132: # 1.20.3
 133: 
 134: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.20.2...1.20.3
 135: 
 136: ## FF7
 137: 
 138: - Music: Fix battle ID detection ( https://github.com/julianxhokaxhiu/FFNx/issues/738 )
 139: 
 140: ## FF8
 141: 
 142: - Core: Fix Card Game mode and allow it to run at 60 FPS
 143: 
 144: # 1.20.2
 145: 
 146: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.20.1...1.20.2
 147: 
 148: ## FF7 Steam
 149: 
 150: - Core: Fix crash when entering Config menu in Spanish ( https://github.com/julianxhokaxhiu/FFNx/discussions/735 )
 151: 
 152: # 1.20.1
 153: 
 154: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.20.0...1.20.1
 155: 
 156: ## FF7
 157: 
 158: - Core: Add missing Cloud models in the model to eye mapping list
 159: 
 160: ## FF8
 161: 
 162: - Core: Fix crash on JP version ( https://github.com/julianxhokaxhiu/FFNx/pull/733 )
 163: - Movie: Fix `override_path` support ( TrueOdin + https://github.com/julianxhokaxhiu/FFNx/pull/734 )
 164: 
 165: ## FF8 2000
 166: 
 167: - Movie: Fix path lookup when using ffmpeg ( https://github.com/julianxhokaxhiu/FFNx/issues/730 )
 168: 
 169: # 1.20.0
 170: 
 171: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.19.1...1.20.0
 172: 
 173: ## Common
 174: 
 175: - Audio: Fix bug that won't allow to configure vanilla SFX IDs using the `sfx/config.toml` file
 176: - Audio: Fix bug where overriding only fade flags in `ambient/config.toml` would not allow the ambient audio file to be loaded
 177: - Audio: Warn user in logs if the `config.toml` file was not parsed correctly, instead of failing silently
 178: - Audio: Allow customising Ambient tracks volume via `config.toml`
 179: - Audio: Ensure Ambient does not stop currently playing track if new one requested does not exist
 180: - External textures: Reuse already loaded textures on fallback to palette 0 ( https://github.com/julianxhokaxhiu/FFNx/pull/692 https://github.com/julianxhokaxhiu/FFNx/pull/707 )
 181: - Modding: Allow replacing EXE text/data hardcoded in code ( https://github.com/julianxhokaxhiu/FFNx/pull/699 )
 182: - Rendering: Add bilinear filtering option `enable_bilinear` ( https://github.com/julianxhokaxhiu/FFNx/pull/692 )
 183: 
 184: ## FF7
 185: 
 186: - Core: Fix mouth replacement for main characters, by replacing only model where the KAWAI opcode has been called.
 187: - Core: NPCs can now have custom eyes and mouths, each their own, during the whole lifecycle of a field scene.
 188: - Core: Fix blinking to use the correct closed eyes texture for NPCs
 189: - Rendering: Fix wrong rendering for fonts in Field mode while scrolling.
 190: - Rendering: Fix wrong rendering for timer boxes when using normal window mode.
 191: - Widescreen: Added option to clip camera position during scripted events ( https://github.com/julianxhokaxhiu/FFNx/pull/706 )
 192: - Widescreen: Added feature to extend movies in true widescreen mode ( https://github.com/julianxhokaxhiu/FFNx/pull/700 )
 193: - 60FPS: Fix bug that displayed battle text too quickly when set at full SLOW speed
 194: 
 195: ## FF8
 196: 
 197: - 60FPS: Add support for 60FPS in the entire game ( separate mods are still required for a stable gameplay )
 198: - Audio: Add ambient layer support for Fields and Battles
 199: - Audio: Add new override logics for Music by using Battle ID, Party Leader and Field name.
 200: - Audio: Add support for current triangle ID for SFX
 201: - External textures: Add support for modding VRAM pages directly, like Tonberry Mods does, see [documentation](https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/ff8/mods/external_textures.md) ( https://github.com/julianxhokaxhiu/FFNx/pull/687 https://github.com/julianxhokaxhiu/FFNx/pull/692 https://github.com/julianxhokaxhiu/FFNx/pull/696 https://github.com/julianxhokaxhiu/FFNx/pull/712 https://github.com/julianxhokaxhiu/FFNx/pull/716 )
 202: - External textures: Fix filename lookup which can match more textures than it should in a VRAM page ( https://github.com/julianxhokaxhiu/FFNx/pull/687 )
 203: - External textures: Split `battle/A8DEF.TIM` into three files to avoid redundant textures ( https://github.com/julianxhokaxhiu/FFNx/pull/687 )
 204: - External music: Fix music get stopped in Fisherman's Horizon concert ( https://github.com/julianxhokaxhiu/FFNx/pull/694 )
 205: - Files: Enable support for `override_path` option ( https://github.com/julianxhokaxhiu/FFNx/pull/705 https://github.com/julianxhokaxhiu/FFNx/pull/707 )
 206: - Rendering: Avoid texture reupload in case of palette swap ( https://github.com/julianxhokaxhiu/FFNx/pull/687 )
 207: - Rendering: Fix texture unload when multiple palettes are written ( https://github.com/julianxhokaxhiu/FFNx/pull/687 )
 208: - Rendering: Prevent the game from sending textures with half-alpha colors ( https://github.com/julianxhokaxhiu/FFNx/pull/687 )
 209: - SFX: Add missing support for audio effects to be stopped in time
 210: - Speedhack: Fix support in field which were not getting the real speed up despite FFNx prompting it on screen.
 211: 
 212: # FF8 2000
 213: 
 214: - Audio: Creative EAX Unified is now optional to launch the game ( https://github.com/julianxhokaxhiu/FFNx/pull/718 )
 215: 
 216: # FF8 Steam
 217: 
 218: - Files: Fix `app_path` option support ( https://github.com/julianxhokaxhiu/FFNx/pull/714 )
 219: 
 220: # 1.19.1
 221: 
 222: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.19.0...1.19.1
 223: 
 224: ## Common
 225: 
 226: - Core: Expose current Wine and Proton version as well in the log, if detected.
 227: - Core: Fix crash that happened on startup on certain machine configurations while fetching PC specs.
 228: 
 229: ## FF8
 230: 
 231: > **Important:** If you have installed [FFNx-v1.19.0.0](https://github.com/julianxhokaxhiu/FFNx/releases/tag/1.19.0), please remove the directories `mods/Textures/battle` and `mods/Textures/magic` and reinstall your battle mods if you had any. A lots of PNG textures has been wrongly dumped into those directories ( https://github.com/julianxhokaxhiu/FFNx/pull/685 )
 232: 
 233: - Rendering: Do not dump any textures if save_textures flag is false ( https://github.com/julianxhokaxhiu/FFNx/pull/685 )
 234: - Rendering: Fix game over crash with external texture ( https://github.com/julianxhokaxhiu/FFNx/pull/686 )
 235: 
 236: # 1.19.0
 237: 
 238: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.18.1...1.19.0
 239: 
 240: ## Common
 241: 
 242: - Core: Add a new capability that will expose the current PC config (CPU, GPU including Driver version, RAM and OS) used to run FFNx. This will help a lot during troubleshooting.
 243: - Music: Add new [relative_speed](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.music.toml#L29-L31) option in the config layer ( https://github.com/julianxhokaxhiu/FFNx/pull/672 )
 244: 
 245: ## FF7
 246: 
 247: - Modding: Do not replace eyes if no external texture has been found.
 248: - Rendering: Fix wrong rendering for battle limit boxes when using transparency. Usually notices while using ESUI or FFNx default hext files.
 249: - Rendering: Fix wrong rendering for overlapping message boxes. Usually noticed while using custom mods like SYW UI or Kactuar.
 250: - Rendering: Fix world FX effects in DE, FR and SP editions.
 251: 
 252: ## FF7 Steam
 253: 
 254: - Input: Prevent input configuration corruption after starting a new game and entering the Config menu ( https://github.com/julianxhokaxhiu/FFNx/pull/683 )
 255: 
 256: ## FF8
 257: 
 258: - Core: Fix crash when some text windows are opening in worldmap on Spanish and Italian versions ( https://github.com/julianxhokaxhiu/FFNx/pull/682/files )
 259: - Graphics: Fix texture animations by copy only partially animated ( https://github.com/julianxhokaxhiu/FFNx/pull/670 )
 260: - Graphics: Allow more external texture replacement for battle effects ( https://github.com/julianxhokaxhiu/FFNx/pull/674 https://github.com/julianxhokaxhiu/FFNx/pull/676 )
 261: - SFX: Fix some external SFX effects that were not stopping when they were looped in certain scenes
 262: - Vibration: Added vibration option in the config menu and the battle pause menu ( https://github.com/julianxhokaxhiu/FFNx/pull/658 )
 263: - Vibration: do not rely on hashes anymore to identify vibration data ( https://github.com/julianxhokaxhiu/FFNx/pull/675 )
 264: 
 265: ## FF8 2000
 266: 
 267: - Misc: Update the FF8.reg file to disable the compatibility fix from Windows that disallow ALT+tab ( https://github.com/julianxhokaxhiu/FFNx/pull/670 )
 268: 
 269: ## FF8 Steam
 270: 
 271: - Misc: Fix metadata save file preservation when a save file is created on Slot 2
 272: 
 273: # 1.18.1
 274: 
 275: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.18.0...1.18.1
 276: 
 277: ## Common
 278: 
 279: - Metadata: Fixes randomly disappearing save files, by rewriting completely the engine and patching `metadata.xml` only for the save file where the player saves
 280: 
 281: ## FF7
 282: 
 283: - Input: Fixed auto-run not working sometimes on diagonals ( https://github.com/julianxhokaxhiu/FFNx/pull/666 )
 284: - Input: Fixed not being able to place the flags during snowstorm ( https://github.com/julianxhokaxhiu/FFNx/pull/667 )
 285: - Renderer: Fixed menu not working when using external worldmap mesh ( https://github.com/julianxhokaxhiu/FFNx/pull/657 )
 286: - Widescreen: Fixed scripted camera clipping when widescreen enabled ( https://github.com/julianxhokaxhiu/FFNx/pull/664 )
 287: 
 288: ## FF8 Steam
 289: 
 290: - Misc: Fix crash for the Japanese version ( https://github.com/julianxhokaxhiu/FFNx/pull/663 )
 291: 
 292: # 1.18.0
 293: 
 294: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.17.1...1.18.0
 295: 
 296: ## FF7
 297: 
 298: - Lighting: Fix Temple of the Ancients rolling stones color when `game_lighting` is set to `1` or `2` ( regression since 1.17.0 )
 299: - Renderer: Fixed fog being incorrectly applied to Emerald Weapon battle ( https://github.com/julianxhokaxhiu/FFNx/pull/648 )
 300: - Renderer: Preserve world camera state when changing game modes ( https://github.com/julianxhokaxhiu/FFNx/pull/651 )
 301: 
 302: ## FF8
 303: 
 304: - Graphics: Add external textures replacement for magic.fs textures ( https://github.com/julianxhokaxhiu/FFNx/pull/646 )
 305: - Graphics: Fix white textures in battle ( https://github.com/julianxhokaxhiu/FFNx/pull/646 )
 306: - Graphics: Opimize PNG and DDS loading time ( https://github.com/julianxhokaxhiu/FFNx/pull/650 )
 307: - Graphics: Minimize RAM usage of external textures and prevent crashes with big textures ( https://github.com/julianxhokaxhiu/FFNx/pull/650 )
 308: - Graphics: Fix Tonberry compatibility layer for field background -again- ( https://github.com/julianxhokaxhiu/FFNx/pull/650 )
 309: - Input: New option to show PlayStation gamepad icons when a gamepad is used ( https://github.com/julianxhokaxhiu/FFNx/pull/641 https://github.com/julianxhokaxhiu/FFNx/pull/650 )
 310: - Input: Fix mapping of gamepad buttons when modified in the game ( https://github.com/julianxhokaxhiu/FFNx/pull/641 )
 311: - Input: Fix inverted analog up/down direction for non-XInput controllers ( https://github.com/julianxhokaxhiu/FFNx/pull/647 )
 312: 
 313: ## FF8 Steam
 314: 
 315: - Misc: Rewrite metadata file when a save file is created to prevent save file loss ( https://github.com/julianxhokaxhiu/FFNx/pull/655 )
 316: 
 317: # 1.17.1
 318: 
 319: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.17.0...1.17.1
 320: 
 321: ## Common
 322: 
 323: - Core: Hide cursor when the game is started in fullscreen mode ( https://github.com/julianxhokaxhiu/FFNx/pull/638 )
 324: 
 325: ## FF7
 326: 
 327: - Renderer: Fixed fog rendering not working in underwater worldmap ( https://github.com/julianxhokaxhiu/FFNx/pull/639 )
 328: 
 329: ## FF8
 330: 
 331: - Graphics: Fix Tonberry compatibility layer for field backgrouns ( https://github.com/julianxhokaxhiu/FFNx/pull/638 )
 332: 
 333: # 1.17.0
 334: 
 335: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.16.0...1.17.0
 336: 
 337: ## Common
 338: 
 339: - Logo: Fix intro logo showing up when `enable_lighting = true`
 340: - Movie: Fix audio stream playing at the same time as the external audio
 341: - Movie: Add support for the AV1 codec
 342: 
 343: ## FF7
 344: 
 345: - 60FPS: Refactor 60FPS battle menu fix and fix ESUI compatibility ( https://github.com/julianxhokaxhiu/FFNx/pull/597 )
 346: - 60FPS: Fix Submarine minigame ( https://github.com/julianxhokaxhiu/FFNx/issues/621 )
 347: - Ambient: Allow ambient effects to playback in fields that use movies as background
 348: - Core: Add additional main models eye-to-model mapping
 349: - Core: Add ability to replace eye textures with custom one ( https://github.com/julianxhokaxhiu/FFNx/issues/589 )
 350: - Core: Add ability to replace mouth textures with custom one
 351: - DevTools: Add Game Moment in Field Debug
 352: - Input: Added right analog stick camera scrolling controls in field mode
 353: - Lighting: Fix [`config.toml`](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.lighting.toml) load/save logic
 354: - Lighting: Fix Bahamut Zero and Supernova not displaying correctly when lighting enabled
 355: - Lighting: Fix field shadows not displaying during FMV movies
 356: - Lighting: Implemented GPU-based original game lighting that better matches PSX version
 357: - Lighting: Fixed minor shadow visual glitches occurring in some fields
 358: - Music: Fix overlapping external music tracks when `external_music_resume = false`
 359: - Renderer: Fix black color in some field maps (`spipe2` for example) ( https://github.com/julianxhokaxhiu/FFNx/pull/587 )
 360: - Renderer: Added functionality to replace worldmap rendering with an external 3d mesh
 361: - Sound: Fix loading music volume value from ff7sound.cfg
 362: - Voice: Enable tutorial voice acting
 363: - Widescreen: Added experimental support for 16:10 aspect ratio
 364: - Widescreen: Fix Pollensalta attack (only when also using 30/60FPS mode since it is a temporary fix) and Bahamut Zero summon background
 365: - Widescreen: Fix Pandora Box white background position
 366: - Voice: Fix auto-text sometimes not working on certain fields after long gameplay sessions
 367: 
 368: ## FF7 Steam
 369: 
 370: - Common: Fix a softlock when trying to change in-game Controller setting to "Normal" (by disabling this option)
 371: - Input: Fix character naming screen not working correctly when Steam Input is enabled
 372: 
 373: ## FF8
 374: 
 375: - Hext: `fix_uv_coords` hext files are not needed anymore ( https://github.com/julianxhokaxhiu/FFNx/pull/619 )
 376: - Graphics: Fix blue color on some attacks in battle ( https://github.com/julianxhokaxhiu/FFNx/pull/619 )
 377: - Graphics: Fix crash when using external texture replacement ( https://github.com/julianxhokaxhiu/FFNx/pull/588 )
 378: - Graphics: Fix texture glitches using external texture replacement ( https://github.com/julianxhokaxhiu/FFNx/pull/591 )
 379: - Graphics: Fix external texture blending ( https://github.com/julianxhokaxhiu/FFNx/pull/598 https://github.com/julianxhokaxhiu/FFNx/pull/601 )
 380: - Graphics: Add chara.one worldmap texture replacement ( https://github.com/julianxhokaxhiu/FFNx/pull/615 )
 381: - Graphics: Add support for external texture animation ( https://github.com/julianxhokaxhiu/FFNx/pull/616 https://github.com/julianxhokaxhiu/FFNx/pull/628 )
 382: - Graphics: Add support for multiple palettes in external texture ( https://github.com/julianxhokaxhiu/FFNx/pull/617 https://github.com/julianxhokaxhiu/FFNx/pull/628 )
 383: - Graphics: Minimize texture uploads when the palette is not set yet ( https://github.com/julianxhokaxhiu/FFNx/pull/617 https://github.com/julianxhokaxhiu/FFNx/pull/628 )
 384: - Graphics: Increase max texture size to 16384 for external textures ( https://github.com/julianxhokaxhiu/FFNx/pull/601 )
 385: - Input: Enable support for 360¬∞ analog movement ( https://github.com/julianxhokaxhiu/FFNx/pull/632 )
 386: - Input: Enable support dual-stick vehicle control ( https://github.com/julianxhokaxhiu/FFNx/pull/632 )
 387: - Menu: Fix main menu texts when selecting "new game" option (European versions only) ( https://github.com/julianxhokaxhiu/FFNx/pull/636 )
 388: - Music: Add `ff8_external_music_force_original_filenames` option to use original music names (eg 018s-julia.ogg) instead of just the main identifier in external music ( https://github.com/julianxhokaxhiu/FFNx/pull/594 )
 389: - Music: Fix intro credits unsync ( https://github.com/julianxhokaxhiu/FFNx/pull/634 )
 390: - SFX: Fix Quezacotl sounds ( https://github.com/julianxhokaxhiu/FFNx/pull/633 )
 391: - Voice: Enable battle dialogs voice acting
 392: - Voice: Enable worldmap voice acting
 393: - Voice: Enable tutorial voice acting
 394: 
 395: # 1.16.0
 396: 
 397: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.15.0...1.16.0
 398: 
 399: ## Common
 400: 
 401: - Common: Allow to skip the FFNx logo on button press
 402: - Common: Improve texture upload time by reducing allocations for color conversion
 403: - Common: Add a new NTSC color correction option ( https://github.com/julianxhokaxhiu/FFNx/issues/536 )
 404: - Common: Introduce a new volume management that can be managed via the `FFNx.toml` file ([Music](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L195-L203), [SFX](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L161-L169), [Voice](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L257-L265), [Ambient](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L297-L305), [Movie](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L321-L329))
 405: - GameHacks: Add toggle for Voice auto-text feature ( see https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/shortcuts.md#voice-auto-text )
 406: - Voice: Fix track master volume inheritance when overriding via config
 407: 
 408: ## FF7
 409: 
 410: - 60FPS: Fix softlock on one of the last map (las0_5) ( https://github.com/julianxhokaxhiu/FFNx/discussions/569 )
 411: - Core: Fix `ERROR: COULD NOT CHANGE TO DIRECTORY` error when starting the Condor minigame
 412: - Graphics: Fix missing snow footsteps ( https://github.com/julianxhokaxhiu/FFNx/issues/550 )
 413: - Input: Allow Cloud to walk/run based on the left analogue stick position ( https://github.com/julianxhokaxhiu/FFNx/issues/523 + https://github.com/julianxhokaxhiu/FFNx/issues/557 )
 414: - Lighting: Fix model normal data inheritance
 415: - Modding: Allow snowboard model swapping ( https://github.com/julianxhokaxhiu/FFNx/issues/440 )
 416: 
 417: ## FF8
 418: 
 419: - Common: Fix startup hang on launch
 420: - Common: Fix jp version crash
 421: - Common: Fix ger version crash on entering worldmap
 422: - Config: enable worldmap fixes by default
 423: - Graphics: Add Field texture replacement ( https://github.com/julianxhokaxhiu/FFNx/pull/542 https://github.com/julianxhokaxhiu/FFNx/pull/545 )
 424: - Graphics: Add Battle texture replacement ( https://github.com/julianxhokaxhiu/FFNx/pull/564 )
 425: - Graphics: Add Worldmap texture replacement for roads and some vehicles ( https://github.com/julianxhokaxhiu/FFNx/pull/584 )
 426: - Graphics: Fix wrong texture replacements in battle
 427: - Graphics: Fix bad texture UVs in worldmap ( https://github.com/julianxhokaxhiu/FFNx/pull/564 )
 428: - Graphics: Disable texture filtering for external textures, as sprites can overlap or look bad in FF8
 429: - Voice: Rework the layer to correctly support field voice acting, multiple dialogs, option dialogs, voice auto-text, music fade-out-in on voice playback, etc.
 430: 
 431: # 1.15.0
 432: 
 433: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.14.0...1.15.0
 434: 
 435: ## Common
 436: 
 437: - Common: Introduce the FFNx logo on game start
 438: - Modding: Add an extra override layer for external textures ( https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L365 )
 439: 
 440: ## FF7
 441: 
 442: - 60FPS: Fix fading speed in FIELD mode screen transitions ( https://github.com/julianxhokaxhiu/FFNx/pull/503 )
 443: - 60FPS: Fix fading out speed in BATTLE mode exit screen transition
 444: - 60FPS: Fix Climhazzard random crash on enemies with status effects ( https://github.com/julianxhokaxhiu/FFNx/pull/516 )
 445: - Core: Fix Barret's eyebrow not loading ( https://github.com/julianxhokaxhiu/FFNx/issues/107 )
 446: - Modding: Added day-night time cycle system that can be controled from field scripts ( https://github.com/julianxhokaxhiu/FFNx/pull/511 )
 447: - Modding: Add support for chunked kernel.bin/kernel2.bin sections
 448: - Modding: Add support for chunked scene.bin sections
 449: - Renderer: Fixed graphical glitch happening in battle when 3d models rendered in front of UI ( https://github.com/julianxhokaxhiu/FFNx/issues/131 )
 450: - Renderer: Fix FIELD mode text box flickering rendering ( https://github.com/julianxhokaxhiu/FFNx/pull/525 )
 451: - Voice: Add play voice for enemy actions during BATTLE mode ( https://github.com/julianxhokaxhiu/FFNx/pull/502 )
 452: - Voice: Fix worldmap message opcode wrong dialog id
 453: - Voice: Fix wrong ASK opcode initialization
 454: - Voice: Fix auto-text behavior for Worldmap
 455: - Widescreen: Allow the buster sword image on new game screen to support 16:9 ratio ( https://github.com/julianxhokaxhiu/FFNx/pull/506 )
 456: 
 457: ## FF8
 458: 
 459: - SFX: Add external SFX audio effects for modders ( https://github.com/julianxhokaxhiu/FFNx/pull/510 )
 460: 
 461: # 1.14.0
 462: 
 463: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.13.0...1.14.0
 464: 
 465: ## Common
 466: 
 467: - Audio: Fix a minor glitch happening on long tracks that were looped ( https://github.com/julianxhokaxhiu/FFNx/issues/452 )
 468: - Audio: Fix a minor glitch happening on OGG tracks that were looped until the end of the track ( https://github.com/julianxhokaxhiu/FFNx/issues/497 )
 469: - Borderless: Fix debug info display when using this mode
 470: - Borderless: Fix game aspect ratio when using borderless or switching to it on the fly
 471: - Vulkan: Disable HDR support, brings more stability on top of AMD cards
 472: 
 473: ## FF7
 474: 
 475: - 60FPS: Fix FIELD and WORLD mode text box animation speed (opening, closing, next paging)
 476: - Animated textues: Optimizations that lead to major speed improvements on old/weak CPUs ( https://github.com/julianxhokaxhiu/FFNx/pull/494 )
 477: - Fields: Move vertical centering [to be a flag](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L554-L559) instead of a Hext file ( https://github.com/julianxhokaxhiu/FFNx/pull/486 )
 478: - Lighting: Fixed minor graphical glitches happening in fields ( https://github.com/julianxhokaxhiu/FFNx/pull/475 )
 479: - Lighting: Fixed visual glitches happening while using Antialiasing ( https://github.com/julianxhokaxhiu/FFNx/pull/476 )
 480: - Lighting: Fixed various missing graphical elements through the overall game ( Titan missing floor, etc. ) ( https://github.com/julianxhokaxhiu/FFNx/pull/478 )
 481: - Lighting: Minor code optimizations that lead to major speed improvements while using this mode
 482: - Modding: Added support for chunked field files
 483: - Modding: Added support for `direct/*.lgp` direct paths
 484: - SFX: Fix a loop bug happening when using MIDI + External SFX combination ( https://github.com/julianxhokaxhiu/FFNx/issues/495 )
 485: - Widescreen: Added config logic and zoom implementation
 486: - Widescreen: Added logic to offset camera scrolling and minor other fixes
 487: - Widescreen: Added logic for vertical offset in movies and other minor fixes
 488: - Widescreen: 16:9 native support!
 489: 
 490: ## FF8
 491: 
 492: - Fixed a crash that happened while exiting the game ( https://github.com/julianxhokaxhiu/FFNx/pull/479 )
 493: 
 494: # 1.13.0
 495: 
 496: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.12.0...1.13.0
 497: 
 498: ## Common
 499: 
 500: - Add native Borderless support ( see https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/shortcuts.md#borderless and https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L30 )
 501: - Fix a rare crash that might happen when closing the game while using 7th Heaven
 502: - Voice: Allow users to enable/disable the auto-text feature ( see https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L221 )
 503: - Steam: Improve metadata save logic ( see https://github.com/julianxhokaxhiu/FFNx/issues/459 )
 504: - Shortcuts: Reworked the entire gamepad trigger logic ( see https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/shortcuts.md )
 505: 
 506: ## FF7
 507: 
 508: - 60FPS: Implement smooth FIELD background scrolling (3D models, tiles, cursor, and arrows)
 509: - 60FPS: Fix model position glitch for some summons
 510: - 60FPS: Fix FIELD 3D model blinking time and wait time
 511: - FF7 Achievement: Fix bug about Cait Sith last limit break and Emerald Weapon achievements not achievable
 512: - Voice: Add Worldmap voice acting support
 513: - Fixed a crash happening while loading a save game on Steam Spanish language
 514: - Fixed minor issues happening while using the new lighting engine on OpenGL ( see https://github.com/julianxhokaxhiu/FFNx/issues/448 )
 515: - Fixed Summon SFX effects volume to respect the master sfx volume ( see https://github.com/julianxhokaxhiu/FFNx/issues/453 )
 516: - Fixed Worldmap missing FX effects ( see https://github.com/julianxhokaxhiu/FFNx/issues/465 )
 517: 
 518: # 1.12.0
 519: 
 520: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.11.0...1.12.0
 521: 
 522: ## Common
 523: 
 524: - Fixed OpenGL rendering for Nvidia/Intel GPUs. AMD continues to have issues unfortunately.
 525: - Fixed a rare buffer-overflow while rendering movies that could lead to crashes on certain game scenes
 526: - SFX: Add a new [`skip`](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.SFX.toml#L24-L27) option in the config layer
 527: 
 528: ## FF7
 529: 
 530: - Added a new game hack, see https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/shortcuts.md#toggle-music-on-battle-pause--ff7-only-
 531: - Ambient global volume is now linked to the SFX global volume
 532: - Movie volume is no more linked to the in-game global music volume
 533: - Misc 60 FPS bugfixes
 534: - XInput: Fix deadzone bug for analog triggers
 535: - Lighting: Fix field 3D models shadow glitch
 536: - SFX: Allow to always centre SFX effects by using the new flag `external_sfx_always_centered`
 537: - Audio: Allow players to customize global Voice, Ambient and Movie volume
 538: 
 539: ## FF8
 540: 
 541: - Misc gamepad vibration fixes on worldmap
 542: - Xinput: fix controller button mapping for steam edition
 543: - Misc Horizon concert fixes
 544: - Graphics: Add Triple Triad mini-game texture replacement ( https://github.com/julianxhokaxhiu/FFNx/pull/444 )
 545: - Graphics: Allow new high quality built-in Worldmap textures to load instead of the low quality ones [by enabling the relative flag in FFNx.toml](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L561) ( https://github.com/julianxhokaxhiu/FFNx/pull/444 )
 546: 
 547: ---
 548: 
 549: # 1.11.0
 550: 
 551: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.10.1...1.11.0
 552: 
 553: ## Common
 554: 
 555: - Added the ability to disable a track by name in External Music ( https://github.com/julianxhokaxhiu/FFNx/pull/318 )
 556: - Improved the internal graphics autoscaling logic to enhance visual output as well as performance ( https://github.com/julianxhokaxhiu/FFNx/pull/364 )
 557: - Added support for HDR mode ( see https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L96 )
 558:   - **PLEASE NOTE:** HDR mode will be auto-enabled only when all these conditions apply:
 559:     - Using DirectX 11/DirectX 12 as backend renderer
 560:     - Windows has the HDR mode enabled
 561:     - Your GPU and monitor supports HDR
 562: - Added support for 5.1/7.1 audio setup
 563: 
 564: ## FF7
 565: 
 566: - 60 FPS mode! ( see https://github.com/julianxhokaxhiu/FFNx/issues/347 for left-over bugs )
 567: - New Auto-Attack GameHack ( https://github.com/julianxhokaxhiu/FFNx/pull/314 )
 568: - New External Music feature: sync to start a track in sync with the previous one ( https://github.com/julianxhokaxhiu/FFNx/pull/318 )
 569: - Various External Music improvements, including the ability to customize a boss battle music by battle scene ID, and to customize minigame music ( https://github.com/julianxhokaxhiu/FFNx/pull/318 + https://github.com/julianxhokaxhiu/FFNx/pull/334 )
 570: - New special feature to play the music from the introduction via External Music, and not via the movie ( https://github.com/julianxhokaxhiu/FFNx/pull/337 )
 571: - New audio layer to replace audio from movies ( https://github.com/julianxhokaxhiu/FFNx/pull/343 )
 572: - New voice acting in Battle:
 573:   - For generic text ( https://github.com/julianxhokaxhiu/FFNx/pull/322 )
 574:   - For skills, magic and items ( https://github.com/julianxhokaxhiu/FFNx/pull/331 )
 575: - New Battle camera control using the right analogue stick ( https://github.com/julianxhokaxhiu/FFNx/pull/340 )
 576: - Various graphical fixes and optimizations on the Lighting engine
 577: - Footsteps sound effect support in Worldmap ( https://github.com/julianxhokaxhiu/FFNx/pull/386 )
 578: - Highwind sound effect support in Worldmap ( https://github.com/julianxhokaxhiu/FFNx/pull/402 )
 579: - Fixed Ambient audio effect pause/resume logic in Battle
 580: - Footsteps run sound effect now works correctly indipendent of the button layout configuration from the user
 581: - Added support for voice acting when multiple dialogs are shown on screen
 582: - Various fixes on the voice acting layer:
 583:   - Prevent Auto-OK when the game engine does not allow user interaction on a specific dialog window
 584:   - The Auto-OK feature now works indipendent of the button layout configuration from the user
 585: - HUGE boost in performance when using animated textures even on weak CPUs
 586: - Removed the Save Anywhere feature as it was causing more issues than benefits
 587: - Movies will now continue to play while dragging the game window
 588: - Fix achievement unlock on End of Part 1
 589: 
 590: ## FF8
 591: 
 592: - Added vibration feature ( https://github.com/julianxhokaxhiu/FFNx/pull/415 )
 593: - New voice audio layer to dub the game ( https://github.com/julianxhokaxhiu/FFNx/pull/412 )
 594: - Added new supported modules (intro credits and cdcheck) to replace textures with DDS or PNG files ( https://github.com/julianxhokaxhiu/FFNx/pull/375 )
 595: - New Direct Mode feature for FF8 ( https://github.com/julianxhokaxhiu/FFNx/pull/405 )
 596: - Added support for japanese 1.02 (nvidia and non-nvidia) version of the game ( https://github.com/julianxhokaxhiu/FFNx/pull/417 )
 597: - Fixed crash in the Chocobo World menu for the Steam version ( https://github.com/julianxhokaxhiu/FFNx/pull/414 )
 598: - Fixed chocobo world Cloud save signature ( https://github.com/julianxhokaxhiu/FFNx/pull/330 )
 599: - Various fixes for the External Music feature ( https://github.com/julianxhokaxhiu/FFNx/pull/330 )
 600: - Fixed crash using debug tools on non-US version of the game ( https://github.com/julianxhokaxhiu/FFNx/pull/323 )
 601: - Allow some Registry settings to be overridden via FFNx.toml ( https://github.com/julianxhokaxhiu/FFNx/pull/427 )
 602: - Enable support for more debug output from the game engine ( https://github.com/julianxhokaxhiu/FFNx/pull/428 )
 603: 
 604: ---
 605: 
 606: # 1.10.1
 607: 
 608: - Milestone: https://github.com/julianxhokaxhiu/FFNx/milestone/5?closed=1
 609: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.10.0...1.10.1
 610: 
 611: ## Common
 612: 
 613: - Fixes Steam edition startup issue: game was crashing directly on startup.
 614: 
 615: ## FF7
 616: 
 617: - Achievements are now more robust, as well as enabled by default on Steam releases. You might still need to enable the [relative flag](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L244) on 1998 release.
 618: 
 619: ---
 620: 
 621: # 1.10.0
 622: 
 623: - Milestone: https://github.com/julianxhokaxhiu/FFNx/milestone/3?closed=1
 624: - Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.9.0...1.10.0
 625: 
 626: ## Common
 627: 
 628: - Add support for PBR/NML textures ( https://github.com/julianxhokaxhiu/FFNx/commit/a878d9f7ed4c3a5e833f68ea7758d8417334b3ad )
 629: 
 630: ## FF7
 631: 
 632: ### New features
 633: 
 634: - Implemented real-time lighting and shadow option ( https://github.com/julianxhokaxhiu/FFNx/pull/227 )
 635: - Added ambient effects support for Battles ( https://github.com/julianxhokaxhiu/FFNx/issues/239 )
 636: - Added ambient fade in/out support for each track customizable through the `config.toml` ( https://github.com/julianxhokaxhiu/FFNx/issues/237 )
 637: - Foot step sound layer. You will be able to hear footsteps when moving Cloud in fields ( https://github.com/julianxhokaxhiu/FFNx/issues/253 )
 638: - New analogue controls when moving Cloud in fields. Much smoother movements when using the Analogue controls ( https://github.com/julianxhokaxhiu/FFNx/pull/274 )
 639: - Added support for Steam achievements ( https://github.com/julianxhokaxhiu/FFNx/pull/283 )
 640: - Enable cached animated textures. HUGE improvement in speed when using external textures using this feature ( https://github.com/julianxhokaxhiu/FFNx/commit/4c116f221b4bd0273b2dc55d28454130374ef847 )
 641: 
 642: ### Fixes
 643: 
 644: - When removing the vertical centered fields hext, movies were still playing centered. Now this is no more true and they'll work exactly like in vanilla ( https://github.com/julianxhokaxhiu/FFNx/issues/234 )
 645: - Field battle music can be again targeted via ID ( https://github.com/julianxhokaxhiu/FFNx/issues/236 )
 646: - Field centering will now affect message boxes in-game vertically offsetting them ( https://github.com/julianxhokaxhiu/FFNx/issues/235 )
 647: - Tiny Bronco sound stops after first play ( https://github.com/julianxhokaxhiu/FFNx/issues/238 )
 648: - Some fields were slown down by the FPS limiter when using movies in background ( https://github.com/julianxhokaxhiu/FFNx/issues/260 )
 649: - Ambient sounds will pause/resume when pausing the game in battles ( https://github.com/julianxhokaxhiu/FFNx/issues/270 )
 650: - Some SFX effects were looped forever, for example some used by the Ruby Weapon ( https://github.com/julianxhokaxhiu/FFNx/issues/275 )
 651: - SFX Volume set in-game was not affecting the external SFX layer, now it is ( https://github.com/julianxhokaxhiu/FFNx/issues/277 )
 652: - Sometimes the game was crashing when too many audio files were opened at the same time ( https://github.com/julianxhokaxhiu/FFNx/discussions/281 )
 653: - Fix a crash that could happen when the external Music layer is not able to open a file ( https://github.com/julianxhokaxhiu/FFNx/pull/273 )
 654: - Fix a potential memory corruption issue that might happen when converting field model size values in memory. As a side effect the model would display huge when it happens ( https://github.com/julianxhokaxhiu/FFNx/issues/295 )
 655: 
 656: ---
 657: 
 658: # 1.9.0
 659: 
 660: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.8.1...1.9.0
 661: 
 662: ## Common
 663: 
 664: - Allow multiple fallback extensions logic for external_sfx/music/voice
 665: - Allow native D-Pad support for DInput pads. No external tools required.
 666: - Use DirectX APIs for Direct Input gamepads, instead of Windows Multimedia APIs. Now supporting even more gamepads than before!
 667: - Add support for SFX sequential mode: playback every effect sequentially from being to end, and repeat
 668: - Sound, Music and Voice layers now use VGMStream: this greatly improves codec support but also performance while playing
 669: - Allow aspect ratio to be toggled on the fly via shortcuts
 670: - Enhance FFMpeg codec support, adding OPUS, SPEEX, THEORA, VORBIS, WAVPACK and X265 to the current existing list
 671: - Improve GameHacks inputs on Gamepad, try to add a little delay between one input and the other.
 672: 
 673: ## FF7
 674: - Auto-advance message boxes when using voice acting mods.
 675: - Prevent movie skip in certain fields to avoid game crashes.
 676: - Allow custom Battle music replacement in Fields and Worldmap. Lookup order: Battle ID ( eg. `bat_391` ) -> Field Name ( eg. `bat_colne_b3`) -> Default battle music file
 677: - Allow custom Field music replacement. Lookup order: Field ID ( eg. `field_371` ) -> Default field music file
 678: - Various external music fixes to improve fading and volume transitions.
 679: - External SFX files that were supposed to loop, now do loop correctly ( elevator scene for eg. )
 680: - Voice acting volume is now always loud and clear compared to music volume even when on 100%
 681: - Add support for 30 FPS movies or higher framerates
 682: - Speedhack will be auto-disabled when a movie starts to prevent some bugs appearing at the end of it
 683: - Add support for 60FPS in the entire game ( separate mods are still required for a stable gameplay )
 684: - Add new Ambient layer effects in fields
 685: 
 686: ## FF7 Steam
 687: - Everything mentioned in [FF7](#FF7)
 688: - Saves will now be signed immediately once you save the game, instead of when you close it. This will improve reliability in case the game crashes.
 689: 
 690: ## FF8
 691: - Introduce music cross fade when external music is being used.
 692: - Add support for movie skip gamehack
 693: - Add support for battle toggle gamehack
 694: - Add support to skip the credits screen using the movie skip shortcut
 695: - Various external music fixes to improve fading and volume transitions.
 696: - Fix CD-ROM drive detection when the CD has been inserted after the game has already been started.
 697: - Various graphical fixes for some weird glitches appearing in certain scenes
 698: - Fix crash immediately after launching the Italian or Spanish version of the game
 699: 
 700: ## FF8 Steam
 701: - Everything mentioned in [FF8](#FF8)
 702: - `ff8input.cfg` will now be loaded from `Documents\Square Enix\FINAL FANTASY VIII Steam` inheriting the original Steam driver path
 703: 
 704: ---
 705: 
 706: # 1.8.1
 707: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.8.0...1.8.1
 708: 
 709: ### Improved stability
 710: 
 711: This release focuses on adding minor enhancements, as well as improving the stability of the driver.
 712: 
 713: Some of these changes are:
 714: - Removed `texture_filtering` option! You don't need to tinker with it anymore. The driver will automatically detect when enabling it, or not.
 715: - Fixed loading shuffle IDs that are not part of the core engine by default ( any ID > 750 ). You can now use **up to 10000** IDs!
 716: - Fixed music fading on voice acting. Sometimes the volume of the music was raised higher than the currently set one in-game. Now your desire in-game volume will be considered, before fading.
 717: - Updated third_party libraries to their latest version.
 718: - Fixed texture dump ( `save_textures` ) on Final Fantasy 8.
 719: 
 720: ---
 721: 
 722: If you appreciate what is being done, and what has been done so far, feel free to donate through the [Sponsoring](https://github.com/sponsors/julianxhokaxhiu) program here on Github.
 723: 
 724: ---
 725: 
 726: **PLEASE NOTE:**
 727: 1. This release brings a **whole new** configuration file type that is **NOT** compatible with previous releases. Please make sure you install all the provided files before starting with the new FFNx.
 728: 2. It is HIGHLY SUGGESTED to always use the default config file. Using old config files will probably end up with unexpected behaviors.
 729: 
 730: ---
 731: 
 732: # 1.8.0
 733: 
 734: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.7.2...1.8.0
 735: 
 736: ### New Logo
 737: 
 738: Every project deserves a kick-ass logo, and we finally managed to have one created for FFNx. This was done thanks to a silent contributor to the project who worked tirelessly night and day, draft after draft, to bring to you this: the true spirit of FFNx in one image. Enjoy!
 739: 
 740: <div align="center">
 741:   <img src="https://github.com/julianxhokaxhiu/FFNx/raw/master/.logo/logo_nobg.png" alt="">
 742:   <br><strong><small>Kudos to <a href="https://www.instagram.com/aryaaiedail/">Cinzia Cancedda (aryaaiedail)</a></small></strong>
 743: </div>
 744: 
 745: ### Rock-Stable Rendering Engine
 746: 
 747: In this release, the rendering engine has been completely polished, cleaned up, and improved to ensure every GPU clock is squeezed to the max to give you the best performance ever, even under pressure. Because of this, **Vulkan** and **DirectX 12** are stable and fully functional, able to push as many FPS as your GPU can generate.
 748: 
 749: Additionally, you can now toggle full-screen on the fly (Alt+Enter), or resize/maximize the window on demand. The initial configuration is just there to ensure the game starts as you expect it to.
 750: 
 751: Enjoy a new butter-smooth experience under AMD, NVIDIA, and even Intel GPUs.
 752: 
 753: ### New Audio Engine
 754: 
 755: This release brings with it also a completely new Audio Engine powered by [SoLoud](https://sol.gfxile.net/soloud/). This allows FFNx to reach levels never before seen on FF7 and FF8.
 756: 
 757: #### Sound Effects Replacement
 758: 
 759: It is now possible to replace in-game sound effects, and configure new behaviors on top of them. For example, you can shuffle a given sound effect each time the engine calls for it. Your Omnislash limit break has never felt so real.
 760: 
 761: To learn more about this feature, please see [Audio Configuration](./How-To_Audio%20Configuration)
 762: 
 763: #### Music Enhancement
 764: 
 765: The music layer has also been completely reworked to bring you the best audio experience yet. Not only are commonly used containers like ogg and mp3 supported, but FFNx now supports surround playback (up to 7.1), along with native PSX (and PS2) sound files! This is made possible through [OpenPSF](https://github.com/myst6re/openpsf) by [myst6re](http://forums.qhimm.com/index.php?action=profile;u=4778) who is also a direct contributor to FFNx. We all need to thank him, as he is working tirelessly in improving the audio engine in general.
 766: 
 767: Not only that, myst6re‚Äôs work allows you to finally hear the full OST from start to end, as he has implemented proper resuming on the world map and field modules of both FF7 and FF8. Music resumes where you left off, even between screen changes!
 768: 
 769: Not being happy with just these great features, myst6re also managed to implement a full music replacement for FF8, improving the quality over the entire game, including the **Horizon Concert**. For now, his own custom pack [FFNx FF8Music](http://forums.qhimm.com/index.php?topic=19968.0) is the first to make use of this layer, and more will come in the future.
 770: 
 771: Finally, this layer is fully configurable, allowing users to do things like shuffling music for a given field and much more. To learn more about this feature, please see [Audio Configuration](./How-To_Audio%20Configuration)
 772: 
 773: #### Voice acting
 774: 
 775: We're not done yet! The new audio engine allows us also to bring one of the most anticipated features of all classical FF fans, dubbing every single line in game! Yes, you **heard** that right!
 776: 
 777: One of the first mods to make use of this will be [Echo-S](https://forum.tsunamods.com/viewtopic.php?f=65&t=9). But please, remember to not ask for an ETA :)
 778: 
 779: Finally you can configure some of the voice acting behavior layer in your [`FFNx.toml` config file](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L155)
 780: 
 781: ### XInput Gamepad support
 782: 
 783: You can now play on FF7 and FF8 using all of your gamepad buttons, including the dpad. It's time to enjoy the PSX experience on PC, finally!
 784: 
 785: ### New configuration file
 786: 
 787: This release comes with a new configuration file syntax which closely resembles the old, but enables us to accomplish many more cool things in code. The configuration syntax is named TOML.
 788: 
 789: Feel free to check out [Learn TOML in Y minutes](https://learnxinyminutes.com/docs/toml/) for a quick tutorial.
 790: 
 791: ### Fancy Transparency Yes or No? Why not both
 792: 
 793: Working closely with [Satsuki](http://forums.qhimm.com/index.php?action=profile;u=24647) and [Chrysalis](http://forums.qhimm.com/index.php?action=profile;u=674) brought up new testing scenarios I was not aware of.
 794: 
 795: Thanks to their tireless efforts in checking every single bit of code written in Nx, on top of their astonishing mods, we found that it was possible to actually drop the `fancy_transparency` option and let the driver code decide whether to use it.
 796: 
 797: Consequently, the driver now has full knowledge of how to blend the current texture by detecting whether it's custom or default, and based on that, correctly blend it on screen to create the best visual output. Goodbye visual glitches!
 798: 
 799: ### Improved memory management
 800: 
 801: Compared to previous releases, v1.8.0 is MUCH faster in loading textures in memory while running the game, and at the same time, less demanding on that memory.
 802: 
 803: ---
 804: 
 805: <div align="center">
 806:   <a href="docs/mods/assets/texture-speed-comparison.png"><img src="docs/mods/assets/texture-speed-comparison.png" alt=""></a>
 807:   <br><strong><small>Kudos to <a href="http://forums.qhimm.com/index.php?action=profile;u=1016">Rumbah</a></small></strong>
 808: </div>
 809: 
 810: ---
 811: 
 812: It is now possible to use the **full 32-bit, 4GB memory space** for your mods ( remember to patch your game exe with [4GB Patch](https://ntcore.com/?page_id=371) in order to make use of this ).
 813: 
 814: ### Gameplay enhancements
 815: 
 816: This release also brings a TON of gameplay enhancements which, even though they‚Äôre not really part of FFNx‚Äôs core mission, add a lot of fun. For instance, you can speedhack the engine to grind faster, skip movies completely, toggle random encounters, and even soft reset if you did something wrong and prefer to restart your progress where you left off. Just like the good old times on your Playstation 1 :)
 817: 
 818: To learn more about this feature, please see [Shortcuts](./Shortcuts)
 819: 
 820: ### DevTools
 821: 
 822: Wait, what? Did I read that correctly?...Yes, you did!
 823: 
 824: This release brings a completely new set of development tools you can use with FF7 and FF8 to accomplish tasks which previously had to be done through third-party tools like Cheat Engine, such as jumping between FF7 fields with a couple of clicks, or exploring FF8‚Äôs world geometry.
 825: 
 826: This is just the beginning! The layer has been designed to be opened further via external APIs and additional modules that you can code and FFNx will then load. Stay tuned for more information in future releases.
 827: 
 828: To learn more about this feature, please see [DevTools](./How-To_DevTools)
 829: 
 830: ### FF7: Animated Textures (EXPERIMENTAL!)
 831: 
 832: There's also a new, proof-of-concept implementation available to allow modders to replace in-game animated texture layers, like the light effect or water cascade behind Aerith‚Äôs house. Be aware that because of how they are implemented, it is not possible to predict their state, and in order to allow them to be replaced we have to hash their pixel content on every draw call.
 833: 
 834: This brings old hardware to its knees, so the functionality is OFF by default, but you can easily enable it in the [`FFNx.toml` config file](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.toml#L247).
 835: 
 836: ### FF8: Background mode
 837: 
 838: By default, FF8 pauses the game if the window loses focus. No more! Starting this release, FF8 will continue running while window focus is on something else.
 839: 
 840: ### Tons of game bugs fixed!
 841: 
 842: If you ever played the game on PC, even the official Steam release has some weird graphical bugs here and there which might annoy you. This release tries to squash many of them, making for a pixel perfect game (mostly) everywhere.
 843: 
 844: In order to enjoy this, make sure to follow the [Installation Instructions](https://github.com/julianxhokaxhiu/FFNx#how-to-install) for the edition you're willing to play. It is **very important** to follow each step.
 845: 
 846: Additionally, a lot of sound, music, and miscellaneous other bugs were fixed in both FF7 and FF8.
 847: 
 848: ## Special thanks to
 849: 
 850: This release would have never been possible if this list of contributors would not have participated:
 851: https://github.com/julianxhokaxhiu/FFNx/graphs/contributors
 852: 
 853: In addition to that list, special thanks must also be given to:
 854: 
 855: - [Bers](http://forums.qhimm.com/index.php?action=profile;u=27643) (https://github.com/berserkingyadis)
 856: - [Chrysalis](http://forums.qhimm.com/index.php?action=profile;u=674)
 857: - [L@Zar0](http://forums.qhimm.com/index.php?action=profile;u=40773)
 858: - [OatBran](http://forums.qhimm.com/index.php?action=profile;u=27603)
 859: - [Rumbah](http://forums.qhimm.com/index.php?action=profile;u=1016)
 860: - [Satsuki](http://forums.qhimm.com/index.php?action=profile;u=24647)
 861: 
 862: Their testing efforts is what allowed FFNx to mark another stable release. Thank you from the bottom of my heart!
 863: 
 864: Additionally, some more special thanks goes to:
 865: 
 866: - [Aali](http://forums.qhimm.com/index.php?action=profile;u=2862)
 867: - [quantumpencil](http://forums.qhimm.com/index.php?action=profile;u=23810)
 868: 
 869: Their help behind the scenes was extremely helpful to accomplish some of this release goals. Thank you again as well from the bottom of my heart!
 870: 
 871: One more special thanks goes also to:
 872: 
 873: - [LordUrQuan](http://forums.qhimm.com/index.php?action=profile;u=28301)
 874: 
 875: For reviewing this changelog release and squashing (almost) all the bugs out of it. Thank you as well from the bottom of my heart!
 876: 
 877: ---
 878: 
 879: If you appreciate what is being done, and what has been done so far, feel free to donate through the [Sponsoring](https://github.com/sponsors/julianxhokaxhiu) program here on Github.
 880: 
 881: ---
 882: 
 883: **PLEASE NOTE:**
 884: 
 885: 1. This release brings a **whole new** configuration file type that is **NOT** compatible with previous releases. Please make sure you install all the provided files before starting with the new FFNx.
 886: 2. It is HIGHLY SUGGESTED to always use the default config file. Using old config files will probably end up with unexpected behaviors.
 887: 
 888: ---
 889: 
 890: # 1.7.2
 891: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.7.1...1.7.2
 892: 
 893: ## FF7
 894: - **FIX:** Snowboard game now runs at 60 FPS.
 895: 
 896: ## FF7 Steam
 897: - **FIX:** Game will load fine again ( regression since 1.7.0 )
 898: 
 899: If you appreciate what is being done, and what has been done so far, feel free to donate through the [Sponsoring](https://github.com/sponsors/julianxhokaxhiu) program here on Github.
 900: 
 901: ---
 902: 
 903: **PLEASE NOTE:**
 904: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
 905: 2. It is HIGHLY SUGGESTED to always use the given default config file. Using the old config will most probably end up in unexpected behaviors.
 906: 
 907: ---
 908: 
 909: # 1.7.1
 910: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.7.0...1.7.1
 911: 
 912: ## Common
 913: - **FIX:** FFNx is now fully compatible starting from Windows 7 and newer releases
 914: - **FIX:** Override layer is now case-insensitive.
 915: - **FIX:** External music is now disabled by default, with an auto-enable functionality if known music paths are detected. If not, the driver will continue to use the default engine music layer. This fixes missing MIDI sound by default.
 916: 
 917: ## FF7
 918: - **MINOR:** `FFNx.reg` will now fix your sound device to inherit the default chosen one on Windows.
 919: - **MINOR:** FFNx will now log if your controller is detected as XInput or DInput.
 920: 
 921: If you appreciate what is being done, and what has been done so far, feel free to donate through the [Sponsoring](https://github.com/sponsors/julianxhokaxhiu) program here on Github.
 922: 
 923: ---
 924: 
 925: **PLEASE NOTE:**
 926: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
 927: 2. It is HIGHLY SUGGESTED to always use the given default config file. Using the old config will most probably end up in unexpected behaviors.
 928: 
 929: ---
 930: 
 931: # 1.7.0
 932: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.6.1...1.7.0
 933: 
 934: This release would have never been possible without the great help of [myst6re](https://github.com/myst6re) and [sithlord48](https://github.com/sithlord48) which has now become contributors to this project. Thank you from the deep of my heart!
 935: 
 936: Please note also **the license has now been fixed to** use **GPLv3** as per [Aali own will](https://github.com/Aali132/ff7_opengl/blob/master/LICENSE).
 937: 
 938: This means that the MIT license **WAS WRONG AND WAS NEVER** compatible with GPLv3. Please make sure you understand this before claiming this code under MIT License until this point. This was a mistake that has been fixed starting this release, but this whole code has always been GPLv3 anyway.
 939: 
 940: ## Common
 941: - **NEW:** Re-worked Music Engine with full support for Winamp plugins, allowing you to play even the most esoteric extensions and having way better experience in playback while playing. Additionally the music will not be stopped when the game window will lose focus. Kudos to [myst6re](https://github.com/myst6re) for this great enhancement!
 942: - **NEW:** Antialiasing support up to 16x!
 943: - **NEW:** Hext by [DLPB](https://forums.qhimm.com/index.php?action=profile;u=6439) patching support now built-in! No external DLLs/EXEs required. Just put your hext files in `hext/`
 944: - **NEW:** Override logic support! You can now override any file in `data/` by just copying it to `override/` folder instead ( path can be changed in the config file )
 945: - **NEW:** The driver can now work if you forget to copy the config file. If not found, it will use its own default flags.
 946: - **NEW:** Savegames will now be preserved when playing with your Steam copy. No more lost save files between multiple game sessions!
 947: - **NEW:** Add support for 4GB LAA processes! Use up to 3.5GB of RAM space in your game for the ultimate modding experience.
 948: - **NEW:** Improved RAM detection for the game, with much better stats shown.
 949: - **FIX:** Improved a bit the rendering quality for external textures that do have mipmaps ( DDS only ).
 950: - **FIX:** The driver will now work correctly even in non-standard DPI settings!
 951: - **FIX:** The game will no more crash when closing, while a music is being reproduced.
 952: - **FIX:** The driver is more resilient to crashes, thanks for a reworked texture memory management. This will allow you to play even heavy mods with little to no crashes. No more 1GB hard cap in RAM for textures!
 953: - **MINOR:** You can now customize the `direct/` path in your config.
 954: - **MINOR:** Show the driver version by default.
 955: 
 956: ## FF7
 957: - **NEW:** Fields are now vertically centered!
 958: - **NEW:** Battles are now full screen!
 959: - **NEW:** Menu hand cursor is now vertically aligned in the middle in menu!
 960: - **NEW:** XInput support OOB for Xbox 360 and compatible gamepads!
 961: - **NEW:** Movies will continue to reproduce even when the window will lose focus. No more black videos in the middle of a scene :)
 962: - **NEW:** Movies will now reproduce respecting the overall in-game music volume.
 963: - **NEW:** The driver now supports the [Satsuki Speedhack](https://forums.qhimm.com/index.php?topic=18851.0) mod!
 964: - **NEW:** The driver now by default, is able to autodetect the best music settings based on your game folder structure. This can still be overridden through the config.
 965: - **NEW:** The driver will now use correct FPS settings around the whole game: this improves minigames speed, battle swirls when vsync is off, etc.
 966: - **NEW:** Thanks to the new music engine, it is now possible to replace wav files too! Kudos to [myst6re](https://github.com/myst6re) for this great enhancement!
 967: - **NEW:** Thanks to the new music engine, music now will pause and resume correctly after a battle! Kudos to [myst6re](https://github.com/myst6re) for this great enhancement!
 968: - **FIX:** Savegame crashes will now be saved in the Steam user directory, when using your Steam copy. Will still be saved in the `save/` directory on the 1998/eStore edition.
 969: - **FIX:** Sound and music volume configuration being done in your Steam copy, are now correctly saved ( and loaded ) in your Steam user directory.
 970:  - **FIX:** Fixed a game bug which stopped the music sometimes, known as MULCK bug (for example: Reno first encounter). Kudos to [myst6re](https://github.com/myst6re) for this great patch!
 971: 
 972: ## FF8
 973: - **NEW:** Thanks to the new music layer, it is now possible to override in-game Midi music files! Kudos to [myst6re](https://github.com/myst6re) for this great enhancement!
 974: - **NEW:** Field Music is now correctly resumed after Triple Triad mini game. Kudos to [myst6re](https://github.com/myst6re) for this great enhancement!
 975: 
 976: If you appreciate what is being done, and what has been done so far, feel free to donate through the [Sponsoring](https://github.com/sponsors/julianxhokaxhiu) program here on Github.
 977: 
 978: ---
 979: 
 980: **PLEASE NOTE:**
 981: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
 982: 2. It is MANDATORY to use the given default config file, as this release has A LOT of NEW flags. Using the old config will most probably end up in unexpected behaviors.
 983: 
 984: ---
 985: 
 986: # 1.6.1
 987: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.6.0...1.6.1
 988: 
 989: ## Common
 990: - **FIX:** Movie mods were not playing correctly on 7h. Now they are.
 991: 
 992: ## FF7 / eStore / Steam
 993: - **FIX:** Fields were having an offset of 8px when vertical centering is disabled. This has now been fixed.
 994: 
 995: And remember, if you like this project please consider [Sponsoring](https://github.com/sponsors/julianxhokaxhiu) me. This will greatly help in moving the project even further.
 996: 
 997: ---
 998: 
 999: **PLEASE NOTE:**
1000: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1001: 2. It is HIGHLY suggested to use the given default config file, as this released moved A LOT of flags around and gave them new options.
1002: 
1003: ---
1004: 
1005: # 1.6.0
1006: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.5.5...1.6.0
1007: 
1008: ## Common
1009: - **NEW:** FFMpeg can now load any video file, depending on the extension you provide. See [the relative flag](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.cfg#L78) for more information!
1010: - **NEW:** MUCH BETTER Stack traces in your logs, giving you exact offset of all the functions being called, even inside the FF7/FF8 process.
1011: - **MINOR:** Updated third party dependencies to their latest respective commits. May bring little to none performance improvements.
1012: - **MINOR:** Updated config file with more instructions on how to enable/disabled flags.
1013: - **MINOR:** Re-organized some flags in the config file. IT IS HIGHLY SUGGESTED to use the given default and update your settings again, at your wish.
1014: 
1015: ## FF7 / eStore / Steam
1016: - **NEW:** [eStore](https://github.com/julianxhokaxhiu/FFNx#2013-estore-release) support!
1017: - **NEW:** Add [AnyCD](http://forums.qhimm.com/index.php?topic=11564.0) support for FR/DE/SP languages.
1018: - **NEW:** [Ficedula FF7Music](http://ff8.fr/pub/FF7Music.zip) support! You can now use it to playback your in-game music, like PSF files. Because of this, [the relative existing flag](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.cfg#L145) was updated to support this new engine.
1019: - **NEW:** VGMStream can now load new music files, not only OGG. For a list of supported extensions see [the relative entry](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.cfg#L162) in the config file!
1020: - **NEW:** Initial eStore Japanese support! Please check [the relative note](https://github.com/julianxhokaxhiu/FFNx#final-fantasy-vii) for more information.
1021: - **NEW:** Fullscreen Battle scenes! For more information feel free to check [the relative entry](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.cfg#L178) in the config file. Kudos to [satsuki](http://forums.qhimm.com/index.php?action=profile;u=24647) and [Chrysalis](http://forums.qhimm.com/index.php?action=profile;u=674) for the help.
1022: - **NEW:** Minor vertical alignment for the hand cursor in the Menu screen! For more information feel free to check [the relative entry](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.cfg#L181) in the config file.
1023: - **MINOR:** You can now disable the Field vertical centering if you want, through [the relative flag](https://github.com/julianxhokaxhiu/FFNx/blob/master/misc/FFNx.cfg#L175).
1024: - **FIX:** Steam SP was crashing on launch. This has now been fixed.
1025: - **FIX:** Field vertical centering in FR was having graphical glitches. This now has been fixed.
1026: - **FIX:** Fix potential crash happening while closing the game, meanwhile the audio was being reproduced using VGMStream.
1027: 
1028: And remember, if you like this project please consider [Sponsoring](https://github.com/sponsors/julianxhokaxhiu) me. This will greatly help in moving the project even further.
1029: 
1030: ---
1031: 
1032: **PLEASE NOTE:**
1033: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1034: 2. It is HIGHLY suggested to use the given default config file, as this released moved A LOT of flags around and gave them new options.
1035: 
1036: ---
1037: 
1038: # 1.5.5
1039: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.5.4...1.5.5
1040: 
1041: ## FF7 + FF7 Steam
1042: - **NEW:** Movies and Field scenes are now vertically centered.
1043: 
1044: ---
1045: 
1046: **PLEASE NOTE:**
1047: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1048: 
1049: ---
1050: 
1051: # 1.5.4
1052: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.5.3...1.5.4
1053: 
1054: ## FF7 Steam
1055: - **FIX:** The driver would crash upon a fresh install. This has now been fixed.
1056: 
1057: ---
1058: 
1059: **PLEASE NOTE:**
1060: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1061: 
1062: ---
1063: 
1064: # 1.5.3
1065: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.5.2...1.5.3
1066: 
1067: ## FF7
1068: - **MINOR:** Removed framerate options as they were not having any real impact on the game.
1069: 
1070: ## FF8 Steam
1071: - **FIX:** Movies do now render with the correct aspect ratio.
1072: 
1073: ---
1074: 
1075: **PLEASE NOTE:**
1076: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1077: 
1078: ---
1079: 
1080: # 1.5.2
1081: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.5.1...1.5.2
1082: 
1083: ## Common
1084: - **FIX:** Movies do now render with the correct aspect ratio.
1085: 
1086: ## FF7
1087: - **FIX:** Screen does now fade to black after the battle swirl correctly.
1088: 
1089: ---
1090: 
1091: **PLEASE NOTE:**
1092: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1093: 
1094: ---
1095: 
1096: # 1.5.1
1097: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.5.0...1.5.1
1098: 
1099: ## Common
1100: - **MINOR:** Improve Video decoding stability.
1101: 
1102: ## FF7
1103: - **FIX:** Sometimes original 1998 movies would crash upon loading. This release aims to fix that and allow you to play original movies coming along your original installation discs.
1104: 
1105: ---
1106: 
1107: **PLEASE NOTE:**
1108: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1109: 
1110: ---
1111: 
1112: # 1.5.0
1113: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.4.5...1.5.0
1114: 
1115: ## Common
1116: - **NEW:** [DDS Texture support](https://beyondskyrim.org/tutorials/the-dds-texture-format) (up to BC7 format). Faster loading times, lower memory usage, same quality as PNG.
1117: - **NEW:** Improved overall visual rendering output: now MUCH clearer and sharper than before.
1118: - **NEW:** Added support for internal rendering multiplier! Scale your internal game resolution up to your pleasure, as long as your GPU can handle it :)
1119: - **FIX:** Depth testing in D3D11/D3D12/Vulkan now working the same as with OpenGL rendering.
1120: - **FIX:** `save_textures` flag now works as expected.
1121: - **MINOR:** Improve Video decoding stability.
1122: - **MINOR:** Improve texture copy operation from GPU memory.
1123: - **MINOR:** Improve performance while getting game status mode.
1124: - **FLAG:** Added flag to turn on/off the Anisotropic filtering.
1125: - **FLAG:** Added flag to show/hide the Backend renderer in the window title or in fullscreen mode.
1126: - **FLAG:** Added flag to tweak the internal renderer multiplier.
1127: - **FLAG:** Added flag to show current FFNx version being used.
1128: 
1129: ## FF7
1130: - **FIX:** A lot of missing effects in Summons ( for eg. Kujata earthquake, or Odin cut effects )
1131: - **FIX:** Escape materia wobbling effect.
1132: - **FIX:** Snowboard minimage background is now white as expected.
1133: - **FIX:** Fort Condor minigame was not clearing correctly the screen, while now it does.
1134: - **FIX:** Battle swirls now fade correctly like on PSX.
1135: 
1136: ## FF8
1137: - **NEW:** [Unofficial bad UV texture patch by Maki](http://forums.qhimm.com/index.php?topic=16327.0) for **ALL LANGUAGES**
1138: - **FIX:** FR GeForce version now works fine with FFNx.
1139: - **FIX:** SP Non-GeForce version now works fine with FFNx.
1140: - **FIX:** US Eidos GeForce/Non-GeForce versions now works fine with FFNx.
1141: 
1142: ---
1143: 
1144: **PLEASE NOTE:**
1145: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1146: 
1147: ---
1148: 
1149: # 1.4.5
1150: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.4.4...1.4.5
1151: 
1152: ## Common
1153: - **FIX:** Debugging flags like `uniform_log` and `trace_movies` now work as expected.
1154: 
1155: ## FF8
1156: - **FIX:** Minor glitches happening during the final battle.
1157: 
1158: ---
1159: 
1160: **PLEASE NOTE:**
1161: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1162: 
1163: ---
1164: 
1165: # 1.4.4
1166: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.4.3...1.4.4
1167: 
1168: ## FF8
1169: - **FIX:** Crash when flying in the worldmap at certain points, as well as in the final battle with Ultimecia.
1170: 
1171: ---
1172: 
1173: **PLEASE NOTE:**
1174: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1175: 
1176: ---
1177: 
1178: # 1.4.3
1179: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.4.2...1.4.3
1180: 
1181: ## Common
1182: - **NEW:** This release now provides three different ZIPs based on which game version you are interested. Feel free to check [installation instructions](https://github.com/julianxhokaxhiu/FFNx#how-to-install) to know which one to download.
1183: - **NEW:** `FFNx.cfg` file has now documented all the available flags. **[With great power comes great responsibility](https://en.wikipedia.org/wiki/With_great_power_comes_great_responsibility)**
1184: - **FIX:** Framebuffer copy operation. Now the driver will correctly copy the last seen frame, fixing the "jumping" behavior between what was used in battle swirls and what was seen before the effect started.
1185: 
1186: ## FF7
1187: - **FIX:** Fix H.264 movie playback with NAL Bitstream filters. This finally fixes 7h compatibility with Satsuki Movie mod.
1188: 
1189: ## FF8
1190: - **NEW:** Added a new `.reg` file for FF8 2000 release. This one will set the best Graphics settings which are used as well on Steam release.
1191: - **NEW:** FF8 Battleswirls animations are now consistent with official releases. No more hacks on how they are drawn.
1192: - **FIX:** Alpha blending operation is now correctly handled as it should be. This also fixes black borders in FF8 horizon battlefields textures.
1193: - **FIX:** In FF8 sometimes some scenes were having some weird polygons drawn on screen. This case has now been fixed.
1194: - **FIX:** FF8 Boss battleswirls now do show and work properly.
1195: - **FIX:** Fix a potential crash that was happening during Squall vs Edea scene by the end of Disk 1.
1196: - **FIX:** Sometimes movies were having some gray bars on top and on bottom, on 2000 release. This now has been fixed and black bars are always shown.
1197: - **FIX:** FIx wrong alpha channels used in some places ( Dialog boxes background, elevator glasses and initial Squall dormitory scene ). Now it will inherit the right one. You will notice darker elevator glasses for example.
1198: 
1199: ## FF8 Steam
1200: - **NEW:** Use high resolution fonts by default.
1201: 
1202: ---
1203: 
1204: **PLEASE NOTE:**
1205: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1206: 
1207: ---
1208: 
1209: # 1.4.2
1210: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.4.1...1.4.2
1211: 
1212: - **FIX:** Wrong disk detection for movies on FF8 Steam edition, defaulting always on disk 1. Now it will use the right disk.
1213: 
1214: ---
1215: 
1216: **PLEASE NOTE:**
1217: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1218: 
1219: ---
1220: 
1221: # 1.4.1
1222: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.4.0...1.4.1
1223: 
1224: ## FF7
1225: - **FIX:** Battle crashing on FF7 Steam edition. Now it works as expected.
1226: 
1227: ## FF8
1228: - **FIX:** Disk 2/3/4 requirement on FF8 Steam edition. Now you can load any game past Disk 1.
1229: 
1230: ---
1231: 
1232: **PLEASE NOTE:**
1233: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1234: 
1235: ---
1236: 
1237: # 1.4.0
1238: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.3.1...1.4.0
1239: 
1240: - **NEW:** Support for Steam user data directories for both FF7 and FF8! You can continue to play where you left off, using the official driver.
1241: - **ENHANCEMENT:** Smooth rendering on higher resolution. Enjoy beautiful upscaled gameplays.
1242: - **ENHANCEMENT:** Re-organized configuration file. Now it is MUCH clearer which options belong to each game.
1243: - **ENHANCEMENT:** Battle swirl in FF7 now behaves like in the official driver.
1244: - **FIX:** Fix mixed 3D rendering and movie playback in some scenes, where 3D models were completely black.
1245: - **FIX:** Fixed upscaled rendering where some green lines were appearing.
1246: - **FIX:** Fixed debug font rendering, printing weird characters instead of alphanumerical characters, once the game was started in fullscreen mode.
1247: - **MISC:** Removed DirectX 9 renderer. Basically broken and unreliable.
1248: - **MISC:** Disable fancy_transparency by default. The option is now Opt-In by default.
1249: 
1250: ---
1251: 
1252: **PLEASE NOTE:**
1253: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1254: 
1255: ---
1256: 
1257: # 1.3.1
1258: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.3.0...1.3.1
1259: 
1260: - Fix an issue where `external_music_path` configuration was overridden for FF7 1998 edition. Now it will maintain the value set in the configuration
1261: 
1262: ---
1263: 
1264: **PLEASE NOTE:**
1265: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1266: 2. **Steam edition only:** Savegame files will still be read from the Game Installation directory and **NOT** from your Steam user profile directory.
1267: 
1268: ---
1269: 
1270: # 1.3.0
1271: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.2.1...1.3.0
1272: 
1273: - Bypass CD requirement on FF8 Steam edition
1274: - Add support for Movies on FF8 Steam edition
1275: - Improve compatibility with FF7/FF8 Steam edition(s). No more required to move `data/lang-*` files around.
1276: 
1277: ---
1278: 
1279: **PLEASE NOTE:**
1280: 1. If you did use this driver in the past and you had to move files around, the game **will still work** but if you prefer to have a clean installation feel free to do so.
1281: 2. **Steam edition only:** Savegame files will still be read from the Game Installation directory and **NOT** from your Steam user profile directory.
1282: 
1283: ---
1284: 
1285: # 1.2.1
1286: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.2.0...1.2.1
1287: 
1288: - Fixed FF8 In-Game menu rendering and also modal transitions during dialogs
1289: 
1290: ---
1291: 
1292: # 1.2.0
1293: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.1.0...1.2.0
1294: 
1295: - Added full support for FF8 2000 and Steam 2013 release ( see [installation instructions](https://github.com/julianxhokaxhiu/FFNx#final-fantasy-viii) )
1296: - Added **multilanguage support** for both [Final Fantasy VII](https://github.com/julianxhokaxhiu/FFNx#final-fantasy-vii) and [Final Fantasy VIII](https://github.com/julianxhokaxhiu/FFNx#final-fantasy-viii)
1297: - Driver log is now named `FFNx.log` and no more `app.log`
1298: 
1299: ---
1300: 
1301: # 1.1.0
1302: Full commit list since last stable release: https://github.com/julianxhokaxhiu/FFNx/compare/1.0.0...1.1.0
1303: 
1304: - Add native Steam support for FF7 ( see [installation instructions](https://github.com/julianxhokaxhiu/FFNx#steam-official-release) )
1305: 
1306: ---
1307: 
1308: # 1.0.0
1309: - Initial release
</file>

<file path="cmake-format.yaml">
1: # cmake-format yaml configuration file
2: 
3: format:
4:   dangle_align: prefix
5:   fractional_tab_policy: use-space
6:   line_width: 150
7: 
8: markup:
9:   enable_markup: false
</file>

<file path="CMakeLists.txt">
  1: #*****************************************************************************#
  2: #    Copyright (C) 2009 Aali132                                               #
  3: #    Copyright (C) 2018 quantumpencil                                         #
  4: #    Copyright (C) 2018 Maxime Bacoux                                         #
  5: #    Copyright (C) 2020 myst6re                                               #
  6: #    Copyright (C) 2020 Chris Rizzitello                                      #
  7: #    Copyright (C) 2020 John Pritchard                                        #
  8: #    Copyright (C) 2025 Julian Xhokaxhiu                                      #
  9: #                                                                             #
 10: #    This file is part of FFNx                                                #
 11: #                                                                             #
 12: #    FFNx is free software: you can redistribute it and/or modify             #
 13: #    it under the terms of the GNU General Public License as published by     #
 14: #    the Free Software Foundation, either version 3 of the License            #
 15: #                                                                             #
 16: #    FFNx is distributed in the hope that it will be useful,                  #
 17: #    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
 18: #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
 19: #    GNU General Public License for more details.                             #
 20: #*****************************************************************************#
 21: 
 22: cmake_minimum_required(VERSION 3.25)
 23: cmake_policy(SET CMP0091 NEW)
 24: 
 25: if(NOT DEFINED CMAKE_BUILD_TYPE)
 26:   message(FATAL_ERROR "CMAKE_BUILD_TYPE must be set to continue building with cmake. \nExample: Add -DCMAKE_BUILD_TYPE=Release to your cmake command line.")
 27: endif()
 28: if (NOT DEFINED _DLL_VERSION OR NOT _DLL_VERSION)
 29:   message(FATAL_ERROR "_DLL_VERSION must be set to continue building with cmake. \nExample: Add -D_DLL_VERSION=devel to your cmake command line.")
 30: endif ()
 31: 
 32: set(VCPKG_DISABLE_COMPILER_TRACKING 1)
 33: set(VCPKG_INSTALL_OPTIONS "--clean-after-build" "--allow-unsupported")
 34: 
 35: set(CMAKE_SHARED_LINKER_FLAGS
 36:   "${CMAKE_SHARED_LINKER_FLAGS} /NODEFAULTLIB:MSVCRT /NODEFAULTLIB:MSVCRTD /DEBUG:FULL /FORCE:MULTIPLE /IGNORE:4006,4075,4099,4217"
 37: )
 38: 
 39: if(CMAKE_BUILD_TYPE MATCHES Debug)
 40:   set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
 41:   set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /NODEFAULTLIB:LIBCMT")
 42: else()
 43:   set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded")
 44:   set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /NODEFAULTLIB:LIBCMTD")
 45: endif()
 46: 
 47: set(BGFX_SHADERC_OPENGL_FLAGS --profile 120)
 48: set(BGFX_SHADERC_DIRECT3D_FLAGS --platform windows -p s_5_0)
 49: set(BGFX_SHADERC_VULKAN_FLAGS --platform windows --profile spirv)
 50: 
 51: if(CMAKE_BUILD_TYPE MATCHES Release OR CMAKE_BUILD_TYPE MATCHES MinSizeRel)
 52:   list(APPEND BGFX_SHADERC_DIRECT3D_FLAGS -O3)
 53: else()
 54:   list(APPEND BGFX_SHADERC_DIRECT3D_FLAGS --debug -O0)
 55:   list(APPEND BGFX_SHADERC_VULKAN_FLAGS --debug -O0)
 56: endif()
 57: 
 58: option(FORCEHEAP "Force all allocation to our heap" OFF)
 59: if(FORCEHEAP)
 60:   add_definitions(-DNO_EXT_HEAP)
 61: endif()
 62: 
 63: option(TRACEHEAP "Trace and keep count of every allocation made by this program" OFF)
 64: if(TRACEHEAP)
 65:   add_definitions(-DHEAP_DEBUG)
 66: endif()
 67: 
 68: option(PROFILING "Enable Profiling" OFF)
 69: if(PROFILING)
 70:   add_definitions(-DPROFILE)
 71: endif()
 72: 
 73: project(FFNx)
 74: 
 75: find_package(ZLIB REQUIRED)
 76: find_package(BX REQUIRED)
 77: find_package(BIMG REQUIRED)
 78: find_package(BGFX REQUIRED)
 79: find_package(FFMPEG REQUIRED)
 80: find_package(MPG123 REQUIRED)
 81: find_package(Vorbis CONFIG REQUIRED)
 82: find_package(VGMSTREAM REQUIRED)
 83: find_package(STACKWALKER REQUIRED)
 84: find_package(pugixml CONFIG REQUIRED)
 85: find_package(PNG REQUIRED)
 86: find_package(directxtex CONFIG REQUIRED)
 87: find_package(mimalloc CONFIG REQUIRED)
 88: find_package(imgui CONFIG REQUIRED)
 89: find_package(SOLOUD REQUIRED)
 90: find_package(OPENPSF REQUIRED)
 91: find_package(STEAMWORKSSDK CONFIG REQUIRED)
 92: find_package(xxHash CONFIG REQUIRED)
 93: find_package(LZ4 REQUIRED)
 94: find_package(CMakeRC CONFIG REQUIRED)
 95: find_package(lfreist-hwinfo CONFIG REQUIRED)
 96: find_package(cryptopp CONFIG REQUIRED)
 97: find_package(tomlplusplus CONFIG REQUIRED)
 98: 
 99: set(RELEASE_NAME "FFNx")
100: 
101: if(_DLL_VERSION STREQUAL "devel" OR _DLL_VERSION MATCHES "-")
102:   set(_DLL_RCVERSION "0,0,0,0")
103:   set(_DLL_RCSTRVERSION "0.0.0.0")
104:   set(PATCH_COLLECT_DUPLICATES 1)
105: else()
106:   string(REPLACE "." "," _DLL_RCVERSION ${_DLL_VERSION})
107:   set(_DLL_RCSTRVERSION ${_DLL_VERSION})
108: endif()
109: 
110: # Choco driver
111: set(CHOCO_RELEASE_NAME "FFNx-Choco")
112: file(GLOB_RECURSE choco_source_files "${CMAKE_SOURCE_DIR}/choco/*.cpp")
113: add_library(${CHOCO_RELEASE_NAME} SHARED ${choco_source_files} ${CMAKE_CURRENT_BINARY_DIR}/version.rc)
114: target_include_directories(
115:   ${CHOCO_RELEASE_NAME}
116:   PRIVATE "${CMAKE_SOURCE_DIR}/choco"
117: )
118: target_link_libraries(
119:   ${CHOCO_RELEASE_NAME}
120:   shlwapi
121: )
122: target_compile_options(
123:   ${CHOCO_RELEASE_NAME}
124:   PRIVATE /DVERSION="${_DLL_VERSION}"
125:   PRIVATE /D_CRT_SECURE_NO_WARNINGS
126:   PRIVATE /DNOMINMAX
127:   PRIVATE /Zc:strictStrings-
128:   PRIVATE /Zc:__cplusplus
129:   PRIVATE /Zc:preprocessor
130:   PRIVATE /Qpar
131:   PRIVATE /MP
132: )
133: target_compile_features(${CHOCO_RELEASE_NAME}
134:   PRIVATE cxx_std_20
135: )
136: target_link_options(${CHOCO_RELEASE_NAME} PRIVATE /PDBALTPATH:${CHOCO_RELEASE_NAME}.pdb PRIVATE /DEF:${CMAKE_SOURCE_DIR}/misc/${CHOCO_RELEASE_NAME}.def)
137: 
138: # Include all the source code files
139: file(GLOB_RECURSE source_files "${CMAKE_SOURCE_DIR}/src/*.cpp")
140: 
141: configure_file(misc/version.rc.in ${CMAKE_CURRENT_BINARY_DIR}/version.rc @ONLY)
142: 
143: cmrc_add_resource_library(
144:   ${RELEASE_NAME}-resources
145:   ALIAS ${RELEASE_NAME}::rc
146:   NAMESPACE ${RELEASE_NAME}
147:   ${CMAKE_CURRENT_SOURCE_DIR}/.logo/logo_nobg.png
148: )
149: 
150: add_library(${RELEASE_NAME} SHARED ${source_files} ${CMAKE_CURRENT_BINARY_DIR}/version.rc)
151: add_dependencies(${RELEASE_NAME} ${CHOCO_RELEASE_NAME})
152: target_include_directories(
153:   ${RELEASE_NAME}
154:   PRIVATE "${CMAKE_SOURCE_DIR}/src"
155:   PRIVATE ${FFMPEG_INCLUDE_DIRS}
156:   PRIVATE ${BX_INCLUDE_DIRS}
157:   PRIVATE ${BIMG_INCLUDE_DIRS}
158:   PRIVATE ${BGFX_INCLUDE_DIRS}
159:   PRIVATE ${OPENPSF_INCLUDE_DIRS}
160:   PRIVATE ${SOLOUD_INCLUDE_DIRS}
161:   PRIVATE ${STACKWALKER_INCLUDE_DIRS}
162:   PRIVATE ${VGMSTREAM_INCLUDE_DIRS}
163: )
164: target_link_directories(
165:   ${RELEASE_NAME}
166:   PRIVATE ${FFMPEG_LIBRARY_DIRS}
167: )
168: target_link_libraries(
169:   ${RELEASE_NAME}
170:   ${RELEASE_NAME}::rc
171:   comctl32
172:   wintrust
173:   dbghelp
174:   shlwapi
175:   psapi
176:   dwmapi
177:   winmm
178:   dinput8
179:   dxguid
180:   XINPUT9_1_0
181:   strmiids
182:   ZLIB::ZLIB
183:   PNG::PNG
184:   Microsoft::DirectXTex
185:   mimalloc-static
186:   imgui::imgui
187:   pugixml::pugixml
188:   tomlplusplus::tomlplusplus
189:   STEAMWORKSSDK::STEAMWORKSSDK
190:   xxHash::xxhash
191:   lz4::lz4
192:   Vorbis::vorbisfile
193:   Vorbis::vorbis
194:   MPG123::libmpg123
195:   lfreist-hwinfo::hwinfo
196:   unofficial::stackwalker::StackWalker
197:   cryptopp::cryptopp
198:   ${BX_LIBRARIES}
199:   ${BIMG_LIBRARIES}
200:   ${BGFX_LIBRARIES}
201:   ${FFMPEG_LIBRARIES}
202:   ${OPENPSF_LIBRARIES}
203:   ${SOLOUD_LIBRARIES}
204:   ${VGMSTREAM_LIBRARIES}
205: )
206: target_compile_options(
207:   ${RELEASE_NAME}
208:   PRIVATE /DBX_CONFIG_DEBUG=1
209:   PRIVATE /DDIRECTINPUT_VERSION=0x0800
210:   PRIVATE /DVERSION="${_DLL_VERSION}"
211:   PRIVATE /D_CRT_SECURE_NO_WARNINGS
212:   PRIVATE /DNOMINMAX
213:   PRIVATE /Zc:strictStrings-
214:   PRIVATE /Zc:__cplusplus
215:   PRIVATE /Zc:preprocessor
216:   PRIVATE /Qpar
217:   PRIVATE /MP
218: )
219: if(PATCH_COLLECT_DUPLICATES)
220:   target_compile_definitions(${RELEASE_NAME}
221:     PRIVATE PATCH_COLLECT_DUPLICATES
222:   )
223: endif()
224: target_compile_features(${RELEASE_NAME}
225:   PRIVATE cxx_std_20
226: )
227: target_link_options(
228:   ${RELEASE_NAME}
229:   PRIVATE /PDBALTPATH:${RELEASE_NAME}.pdb
230:   PRIVATE /DEF:${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.def
231:   PRIVATE /MANIFESTDEPENDENCY:"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'"
232: )
233: 
234: # SHADER COMPILATION
235: set(FFNX_SHADERS "FFNx" "FFNx.lighting" "FFNx.shadowmap" "FFNx.field.shadow" "FFNx.overlay" "FFNx.post" "FFNx.blit")
236: foreach(FFNX_SHADER IN LISTS FFNX_SHADERS)
237:   foreach(BGFX_VARYING flat smooth)
238:     add_custom_command(
239:       TARGET ${RELEASE_NAME}
240:       POST_BUILD
241:       COMMAND echo Building ${FFNX_SHADER}.${BGFX_VARYING} vert/frag shaders...
242:       # ensure bin directory exists
243:       COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/bin/shaders
244:       # OpenGL
245:       COMMAND
246:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
247:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.gl.frag --type f --varyingdef
248:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_OPENGL_FLAGS}
249:       COMMAND
250:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
251:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.gl.vert --type v --varyingdef
252:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_OPENGL_FLAGS}
253:       # Vulkan
254:       COMMAND
255:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
256:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.vk.frag --type f --varyingdef
257:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_VULKAN_FLAGS}
258:       COMMAND
259:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
260:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.vk.vert --type v --varyingdef
261:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_VULKAN_FLAGS}
262:       # Direct3D 11
263:       COMMAND
264:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
265:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d11.frag --type f --varyingdef
266:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS}
267:       COMMAND
268:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
269:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d11.vert --type v --varyingdef
270:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS}
271:       # Direct3D 12
272:       COMMAND
273:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.frag -o
274:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d12.frag --type f --varyingdef
275:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS}
276:       COMMAND
277:         ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/bgfx/shadercRelease -i ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/include -f ${CMAKE_SOURCE_DIR}/misc/${FFNX_SHADER}.vert -o
278:         ${CMAKE_BINARY_DIR}/bin/shaders/${FFNX_SHADER}.${BGFX_VARYING}.d3d12.vert --type v --varyingdef
279:         ${CMAKE_SOURCE_DIR}/misc/${RELEASE_NAME}.varying.${BGFX_VARYING}.def.sc ${BGFX_SHADERC_DIRECT3D_FLAGS})
280:   endforeach()
281: endforeach()
282: 
283: # List .gitkeep files to remove them on INSTALL
284: FILE(GLOB_RECURSE HEXT_GIT_KEEP_FILES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}/misc/ ${CMAKE_CURRENT_SOURCE_DIR}/misc/hext/ff8/**/.gitkeep)
285: LIST(TRANSFORM HEXT_GIT_KEEP_FILES PREPEND ${CMAKE_BINARY_DIR}/bin/)
286: 
287: # INSTALL
288: add_custom_command(
289:   TARGET ${RELEASE_NAME}
290:   POST_BUILD
291:   COMMAND echo Preparing ${RELEASE_NAME} ${_DLL_VERSION} release...
292:   # ensure bin directory exists
293:   COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/bin
294:   # License
295:   COMMAND ${CMAKE_COMMAND} -E copy
296:           ${CMAKE_CURRENT_SOURCE_DIR}/COPYING.TXT
297:           ${CMAKE_BINARY_DIR}/bin
298:   # .dll
299:   COMMAND ${CMAKE_COMMAND} -E copy
300:           ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/${RELEASE_NAME}.dll
301:           ${CMAKE_BINARY_DIR}/bin
302:   # choco .dll
303:   COMMAND ${CMAKE_COMMAND} -E copy
304:           ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/${CHOCO_RELEASE_NAME}.dll
305:           ${CMAKE_BINARY_DIR}/bin
306:   # rename choco .dll to AF4DN.P
307:   COMMAND ${CMAKE_COMMAND} -E rename
308:           ${CMAKE_BINARY_DIR}/bin/${CHOCO_RELEASE_NAME}.dll
309:           ${CMAKE_BINARY_DIR}/bin/AF4DN.P
310:   # steam_api.dll
311:   COMMAND ${CMAKE_COMMAND} -E copy
312:           ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/steamworkssdk/steam_api.dll
313:           ${CMAKE_BINARY_DIR}/bin
314:   # .pdb
315:   COMMAND ${CMAKE_COMMAND} -E copy
316:           ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/${RELEASE_NAME}.pdb
317:           ${CMAKE_BINARY_DIR}/bin
318:   # .toml
319:   COMMAND ${CMAKE_COMMAND} -E copy
320:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.toml
321:           ${CMAKE_BINARY_DIR}/bin
322:   # FF7.reg
323:   COMMAND ${CMAKE_COMMAND} -E copy
324:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/FF7.reg
325:           ${CMAKE_BINARY_DIR}/bin
326:   # FF8.reg
327:   COMMAND ${CMAKE_COMMAND} -E copy
328:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/FF8.reg
329:           ${CMAKE_BINARY_DIR}/bin
330:   # hext
331:   COMMAND ${CMAKE_COMMAND} -E copy_directory
332:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/hext
333:           ${CMAKE_BINARY_DIR}/bin/hext
334:   COMMAND ${CMAKE_COMMAND} -E rm ${HEXT_GIT_KEEP_FILES}
335: 
336:   # ambient .toml
337:   COMMAND ${CMAKE_COMMAND} -E copy
338:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.ambient.toml
339:           ${CMAKE_BINARY_DIR}/bin/ambient/config.toml
340:   # lighting .toml
341:   COMMAND ${CMAKE_COMMAND} -E copy
342:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.lighting.toml
343:           ${CMAKE_BINARY_DIR}/bin/lighting/config.toml
344:   # SFX .toml
345:   COMMAND ${CMAKE_COMMAND} -E copy
346:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.SFX.toml
347:           ${CMAKE_BINARY_DIR}/bin/sfx/config.toml
348:   # Music .toml
349:   COMMAND ${CMAKE_COMMAND} -E copy
350:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.music.toml
351:           ${CMAKE_BINARY_DIR}/bin/music/vgmstream/config.toml
352:   # Voice .toml
353:   COMMAND ${CMAKE_COMMAND} -E copy
354:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.voice.toml
355:           ${CMAKE_BINARY_DIR}/bin/voice/config.toml
356:   # Vibrate field .toml
357:   COMMAND ${CMAKE_COMMAND} -E copy
358:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.vibrate.ff8.field.toml
359:           ${CMAKE_BINARY_DIR}/bin/vibrate/ff8/field.toml
360:   # Vibrate world .toml
361:   COMMAND ${CMAKE_COMMAND} -E copy
362:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.vibrate.ff8.world.toml
363:           ${CMAKE_BINARY_DIR}/bin/vibrate/ff8/world.toml
364:   # Vibrate battle .toml
365:   COMMAND ${CMAKE_COMMAND} -E copy
366:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.vibrate.ff8.battle.toml
367:           ${CMAKE_BINARY_DIR}/bin/vibrate/ff8/battle.toml
368:   # time cycle .toml
369:   COMMAND ${CMAKE_COMMAND} -E copy
370:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/${RELEASE_NAME}.time.toml
371:           ${CMAKE_BINARY_DIR}/bin/time/config.toml
372:   # Gamut LUTS
373:   COMMAND ${CMAKE_COMMAND} -E copy
374:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_ntscj_to_srgb.png
375:           ${CMAKE_BINARY_DIR}/bin/shaders
376:   COMMAND ${CMAKE_COMMAND} -E copy
377:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_smptec_to_srgb.png
378:           ${CMAKE_BINARY_DIR}/bin/shaders
379:   COMMAND ${CMAKE_COMMAND} -E copy
380:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_ebu_to_srgb.png
381:           ${CMAKE_BINARY_DIR}/bin/shaders
382:   COMMAND ${CMAKE_COMMAND} -E copy
383:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_inverse_ntscj_to_srgb.png
384:           ${CMAKE_BINARY_DIR}/bin/shaders
385:   COMMAND ${CMAKE_COMMAND} -E copy
386:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_inverse_ntscj_to_smptec.png
387:           ${CMAKE_BINARY_DIR}/bin/shaders
388:   COMMAND ${CMAKE_COMMAND} -E copy
389:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_inverse_ntscj_to_ebu.png
390:           ${CMAKE_BINARY_DIR}/bin/shaders
391:   COMMAND ${CMAKE_COMMAND} -E copy
392:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_srgb_to_ntscj.png
393:           ${CMAKE_BINARY_DIR}/bin/shaders
394:   COMMAND ${CMAKE_COMMAND} -E copy
395:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_smptec_to_ntscj.png
396:           ${CMAKE_BINARY_DIR}/bin/shaders
397:   COMMAND ${CMAKE_COMMAND} -E copy
398:           ${CMAKE_CURRENT_SOURCE_DIR}/misc/glut_ebu_to_ntscj.png
399:           ${CMAKE_BINARY_DIR}/bin/shaders
400: 
401: )
402: 
403: # CPU INFO
404: add_custom_command(
405:   TARGET ${CHOCO_RELEASE_NAME}
406:   PRE_BUILD
407:   # Get CPU info
408:   COMMAND
409:     ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/cpuinfo/cpu-info
410:   # Get CPU ISA supported instructions
411:   COMMAND
412:     ${CMAKE_BINARY_DIR}/vcpkg_installed/x86-windows-static/tools/cpuinfo/isa-info
413: )
414: 
415: # Copy FFNx release to FF7 1998 game path if installed
416: cmake_host_system_information(RESULT FF7_1998_GAME_PATH QUERY WINDOWS_REGISTRY "HKLM/SOFTWARE/Square Soft, Inc./Final Fantasy VII" VALUE "AppPath" ERROR_VARIABLE FF7_KEY_QUERY_RES)
417: if("${FF7_KEY_QUERY_RES}" STREQUAL "")
418:   cmake_path(CONVERT "${FF7_1998_GAME_PATH}" TO_CMAKE_PATH_LIST FF7_1998_GAME_PATH)
419:   # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
420:   if(NOT EXISTS "${FF7_1998_GAME_PATH}/FFNx.toml")
421:     # Copy file if it doesn't exist
422:     file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF7_1998_GAME_PATH}/")
423:   endif()
424:   add_custom_command(
425:     TARGET ${RELEASE_NAME}
426:     POST_BUILD
427:     COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF7_1998_GAME_PATH}...
428:     # Preserve the current FFNx.toml
429:     COMMAND ${CMAKE_COMMAND} -E rename
430:             ${FF7_1998_GAME_PATH}/FFNx.toml
431:             ${FF7_1998_GAME_PATH}/FFNx.toml.bak
432:     # Copy all dist files
433:     COMMAND ${CMAKE_COMMAND} -E copy_directory
434:             ${CMAKE_BINARY_DIR}/bin
435:             ${FF7_1998_GAME_PATH}
436:     # Delete the new copied FFNx.toml
437:     COMMAND ${CMAKE_COMMAND} -E remove
438:             ${FF7_1998_GAME_PATH}/FFNx.toml
439:     # Bring back the existing FFNx.toml
440:     COMMAND ${CMAKE_COMMAND} -E rename
441:             ${FF7_1998_GAME_PATH}/FFNx.toml.bak
442:             ${FF7_1998_GAME_PATH}/FFNx.toml
443:   )
444: endif()
445: 
446: # Copy FFNx release to FF8 2000 game path if installed
447: cmake_host_system_information(RESULT FF8_2000_GAME_PATH QUERY WINDOWS_REGISTRY "HKLM/SOFTWARE/Square Soft, Inc/FINAL FANTASY VIII/1.00" VALUE "AppPath" ERROR_VARIABLE FF8_KEY_QUERY_RES)
448: if("${FF8_KEY_QUERY_RES}" STREQUAL "")
449:   cmake_path(CONVERT "${FF8_2000_GAME_PATH}" TO_CMAKE_PATH_LIST FF8_2000_GAME_PATH)
450:   # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
451:   if(NOT EXISTS "${FF8_2000_GAME_PATH}/FFNx.toml")
452:     # Copy file if it doesn't exist
453:     file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF8_2000_GAME_PATH}/")
454:   endif()
455:   add_custom_command(
456:     TARGET ${RELEASE_NAME}
457:     POST_BUILD
458:     COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF8_2000_GAME_PATH}...
459:     # Preserve the current FFNx.toml
460:     COMMAND ${CMAKE_COMMAND} -E rename
461:             ${FF8_2000_GAME_PATH}/FFNx.toml
462:             ${FF8_2000_GAME_PATH}/FFNx.toml.bak
463:     # Copy all dist files
464:     COMMAND ${CMAKE_COMMAND} -E copy_directory
465:             ${CMAKE_BINARY_DIR}/bin
466:             ${FF8_2000_GAME_PATH}
467:     # Delete previous eax.dll
468:     COMMAND ${CMAKE_COMMAND} -E remove
469:             ${FF8_2000_GAME_PATH}/eax.dll
470:     # Rename FFNx.dll to eax.dll
471:     COMMAND ${CMAKE_COMMAND} -E rename
472:             ${FF8_2000_GAME_PATH}/FFNx.dll
473:             ${FF8_2000_GAME_PATH}/eax.dll
474:     # Delete the new copied FFNx.toml
475:     COMMAND ${CMAKE_COMMAND} -E remove
476:             ${FF8_2000_GAME_PATH}/FFNx.toml
477:     # Bring back the existing FFNx.toml
478:     COMMAND ${CMAKE_COMMAND} -E rename
479:             ${FF8_2000_GAME_PATH}/FFNx.toml.bak
480:             ${FF8_2000_GAME_PATH}/FFNx.toml
481:   )
482: endif()
483: 
484: # Copy FFNx release to FF7 Steam game path if installed
485: execute_process(
486:   COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/utils/FindSteamGamePath 39140
487:   OUTPUT_VARIABLE FF7_STEAM_GAME_PATH
488:   ERROR_VARIABLE FF7_STEAM_ERROR
489:   OUTPUT_STRIP_TRAILING_WHITESPACE
490: )
491: if(NOT "${FF7_STEAM_GAME_PATH}" STREQUAL "")
492:   cmake_path(CONVERT "${FF7_STEAM_GAME_PATH}" TO_CMAKE_PATH_LIST FF7_STEAM_GAME_PATH)
493:   # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
494:   if(NOT EXISTS "${FF7_STEAM_GAME_PATH}/FFNx.toml")
495:     # Copy file if it doesn't exist
496:     file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF7_STEAM_GAME_PATH}/")
497:   endif()
498:   add_custom_command(
499:     TARGET ${RELEASE_NAME}
500:     POST_BUILD
501:     COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF7_STEAM_GAME_PATH}...
502:     # Preserve the current FFNx.toml
503:     COMMAND ${CMAKE_COMMAND} -E rename
504:             ${FF7_STEAM_GAME_PATH}/FFNx.toml
505:             ${FF7_STEAM_GAME_PATH}/FFNx.toml.bak
506:     # Copy all dist files
507:     COMMAND ${CMAKE_COMMAND} -E copy_directory
508:             ${CMAKE_BINARY_DIR}/bin
509:             ${FF7_STEAM_GAME_PATH}
510:     # Delete previous AF3DN.P
511:     COMMAND ${CMAKE_COMMAND} -E remove
512:             ${FF7_STEAM_GAME_PATH}/AF3DN.P
513:     # Rename FFNx.dll to AF3DN.P
514:     COMMAND ${CMAKE_COMMAND} -E rename
515:             ${FF7_STEAM_GAME_PATH}/FFNx.dll
516:             ${FF7_STEAM_GAME_PATH}/AF3DN.P
517:     # Delete the new copied FFNx.toml
518:     COMMAND ${CMAKE_COMMAND} -E remove
519:             ${FF7_STEAM_GAME_PATH}/FFNx.toml
520:     # Bring back the existing FFNx.toml
521:     COMMAND ${CMAKE_COMMAND} -E rename
522:             ${FF7_STEAM_GAME_PATH}/FFNx.toml.bak
523:             ${FF7_STEAM_GAME_PATH}/FFNx.toml
524:   )
525: endif()
526: 
527: # Copy FFNx release to FF7 Steam game path if installed
528: execute_process(
529:   COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/utils/FindSteamGamePath 39150
530:   OUTPUT_VARIABLE FF8_STEAM_GAME_PATH
531:   ERROR_VARIABLE FF8_STEAM_ERROR
532:   OUTPUT_STRIP_TRAILING_WHITESPACE
533: )
534: if(NOT "${FF8_STEAM_GAME_PATH}" STREQUAL "")
535:   cmake_path(CONVERT "${FF8_STEAM_GAME_PATH}" TO_CMAKE_PATH_LIST FF8_STEAM_GAME_PATH)
536:   # Ensure FFNx.toml exists so the copy on build does not error on fresh installs
537:   if(NOT EXISTS "${FF8_STEAM_GAME_PATH}/FFNx.toml")
538:     # Copy file if it doesn't exist
539:     file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/misc/FFNx.toml" DESTINATION "${FF8_STEAM_GAME_PATH}/")
540:   endif()
541:   add_custom_command(
542:     TARGET ${RELEASE_NAME}
543:     POST_BUILD
544:     COMMAND echo Copying ${RELEASE_NAME} ${_DLL_VERSION} release to ${FF8_STEAM_GAME_PATH}...
545:     # Preserve the current FFNx.toml
546:     COMMAND ${CMAKE_COMMAND} -E rename
547:             ${FF8_STEAM_GAME_PATH}/FFNx.toml
548:             ${FF8_STEAM_GAME_PATH}/FFNx.toml.bak
549:     # Copy all dist files
550:     COMMAND ${CMAKE_COMMAND} -E copy_directory
551:             ${CMAKE_BINARY_DIR}/bin
552:             ${FF8_STEAM_GAME_PATH}
553:     # Delete previous AF3DN.P
554:     COMMAND ${CMAKE_COMMAND} -E remove
555:             ${FF8_STEAM_GAME_PATH}/AF3DN.P
556:     # Rename FFNx.dll to AF3DN.P
557:     COMMAND ${CMAKE_COMMAND} -E rename
558:             ${FF8_STEAM_GAME_PATH}/FFNx.dll
559:             ${FF8_STEAM_GAME_PATH}/AF3DN.P
560:     # Delete the new copied FFNx.toml
561:     COMMAND ${CMAKE_COMMAND} -E remove
562:             ${FF8_STEAM_GAME_PATH}/FFNx.toml
563:     # Bring back the existing FFNx.toml
564:     COMMAND ${CMAKE_COMMAND} -E rename
565:             ${FF8_STEAM_GAME_PATH}/FFNx.toml.bak
566:             ${FF8_STEAM_GAME_PATH}/FFNx.toml
567:   )
568: endif()
</file>

<file path="CMakePresets.json">
 1: {
 2:   "version": 6,
 3:   "cmakeMinimumRequired": {
 4:     "major": 3,
 5:     "minor": 25,
 6:     "patch": 0
 7:   },
 8:   "configurePresets": [
 9:     {
10:       "name": "base",
11:       "hidden": true,
12:       "generator": "Visual Studio 17 2022",
13:       "architecture": {
14:         "value": "win32",
15:         "strategy": "set"
16:       },
17:       "toolset": {
18:         "value": "host=x86",
19:         "strategy": "set"
20:       },
21:       "environment": {
22:         "NUGET_CLI_LANGUAGE": "en-us",
23:         "VCPKG_ROOT": "${sourceDir}/vcpkg",
24:         "VCPKG_BINARY_SOURCES": "clear;nuget,github,readwrite;default,readwrite"
25:       },
26:       "binaryDir": "${sourceDir}/.build",
27:       "toolchainFile": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
28:       "cacheVariables": {
29:         "_DLL_VERSION": "devel",
30:         "CMAKE_C_COMPILER": "cl",
31:         "VCPKG_TARGET_TRIPLET": "x86-windows-static"
32:       }
33:     },
34:     {
35:       "name": "Release",
36:       "inherits": "base",
37:       "cacheVariables": {
38:         "CMAKE_BUILD_TYPE": "Release"
39:       }
40:     },
41:     {
42:       "name": "RelWithDebInfo",
43:       "inherits": "base",
44:       "cacheVariables": {
45:         "CMAKE_BUILD_TYPE": "RelWithDebInfo"
46:       }
47:     },
48:     {
49:       "name": "Debug",
50:       "inherits": "base",
51:       "cacheVariables": {
52:         "CMAKE_BUILD_TYPE": "Debug"
53:       }
54:     },
55:     {
56:       "name": "MinSizeRel",
57:       "inherits": "base",
58:       "cacheVariables": {
59:         "CMAKE_BUILD_TYPE": "MinSizeRel"
60:       }
61:     }
62:   ],
63:   "buildPresets": [
64:     {
65:       "name": "Release",
66:       "displayName": "Default",
67:       "configurePreset": "Release",
68:       "configuration": "Release"
69:     },
70:     {
71:       "name": "RelWithDebInfo",
72:       "displayName": "Default",
73:       "configurePreset": "RelWithDebInfo",
74:       "configuration": "RelWithDebInfo"
75:     },
76:     {
77:       "name": "Debug",
78:       "displayName": "Default",
79:       "configurePreset": "Debug",
80:       "configuration": "Debug"
81:     },
82:     {
83:       "name": "MinSizeRel",
84:       "displayName": "Default",
85:       "configurePreset": "MinSizeRel",
86:       "configuration": "MinSizeRel"
87:     }
88:   ],
89:   "vendor": {
90:     "microsoft.com/VisualStudioSettings/CMake/1.0": {
91:       "hostOS": "Windows",
92:       "intelliSenseMode": "windows-msvc-x64"
93:     }
94:   }
95: }
</file>

<file path="COPYING.TXT">
  1: GNU GENERAL PUBLIC LICENSE
  2:                        Version 3, 29 June 2007
  3: 
  4:  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
  5:  Everyone is permitted to copy and distribute verbatim copies
  6:  of this license document, but changing it is not allowed.
  7: 
  8:                             Preamble
  9: 
 10:   The GNU General Public License is a free, copyleft license for
 11: software and other kinds of works.
 12: 
 13:   The licenses for most software and other practical works are designed
 14: to take away your freedom to share and change the works.  By contrast,
 15: the GNU General Public License is intended to guarantee your freedom to
 16: share and change all versions of a program--to make sure it remains free
 17: software for all its users.  We, the Free Software Foundation, use the
 18: GNU General Public License for most of our software; it applies also to
 19: any other work released this way by its authors.  You can apply it to
 20: your programs, too.
 21: 
 22:   When we speak of free software, we are referring to freedom, not
 23: price.  Our General Public Licenses are designed to make sure that you
 24: have the freedom to distribute copies of free software (and charge for
 25: them if you wish), that you receive source code or can get it if you
 26: want it, that you can change the software or use pieces of it in new
 27: free programs, and that you know you can do these things.
 28: 
 29:   To protect your rights, we need to prevent others from denying you
 30: these rights or asking you to surrender the rights.  Therefore, you have
 31: certain responsibilities if you distribute copies of the software, or if
 32: you modify it: responsibilities to respect the freedom of others.
 33: 
 34:   For example, if you distribute copies of such a program, whether
 35: gratis or for a fee, you must pass on to the recipients the same
 36: freedoms that you received.  You must make sure that they, too, receive
 37: or can get the source code.  And you must show them these terms so they
 38: know their rights.
 39: 
 40:   Developers that use the GNU GPL protect your rights with two steps:
 41: (1) assert copyright on the software, and (2) offer you this License
 42: giving you legal permission to copy, distribute and/or modify it.
 43: 
 44:   For the developers' and authors' protection, the GPL clearly explains
 45: that there is no warranty for this free software.  For both users' and
 46: authors' sake, the GPL requires that modified versions be marked as
 47: changed, so that their problems will not be attributed erroneously to
 48: authors of previous versions.
 49: 
 50:   Some devices are designed to deny users access to install or run
 51: modified versions of the software inside them, although the manufacturer
 52: can do so.  This is fundamentally incompatible with the aim of
 53: protecting users' freedom to change the software.  The systematic
 54: pattern of such abuse occurs in the area of products for individuals to
 55: use, which is precisely where it is most unacceptable.  Therefore, we
 56: have designed this version of the GPL to prohibit the practice for those
 57: products.  If such problems arise substantially in other domains, we
 58: stand ready to extend this provision to those domains in future versions
 59: of the GPL, as needed to protect the freedom of users.
 60: 
 61:   Finally, every program is threatened constantly by software patents.
 62: States should not allow patents to restrict development and use of
 63: software on general-purpose computers, but in those that do, we wish to
 64: avoid the special danger that patents applied to a free program could
 65: make it effectively proprietary.  To prevent this, the GPL assures that
 66: patents cannot be used to render the program non-free.
 67: 
 68:   The precise terms and conditions for copying, distribution and
 69: modification follow.
 70: 
 71:                        TERMS AND CONDITIONS
 72: 
 73:   0. Definitions.
 74: 
 75:   "This License" refers to version 3 of the GNU General Public License.
 76: 
 77:   "Copyright" also means copyright-like laws that apply to other kinds of
 78: works, such as semiconductor masks.
 79: 
 80:   "The Program" refers to any copyrightable work licensed under this
 81: License.  Each licensee is addressed as "you".  "Licensees" and
 82: "recipients" may be individuals or organizations.
 83: 
 84:   To "modify" a work means to copy from or adapt all or part of the work
 85: in a fashion requiring copyright permission, other than the making of an
 86: exact copy.  The resulting work is called a "modified version" of the
 87: earlier work or a work "based on" the earlier work.
 88: 
 89:   A "covered work" means either the unmodified Program or a work based
 90: on the Program.
 91: 
 92:   To "propagate" a work means to do anything with it that, without
 93: permission, would make you directly or secondarily liable for
 94: infringement under applicable copyright law, except executing it on a
 95: computer or modifying a private copy.  Propagation includes copying,
 96: distribution (with or without modification), making available to the
 97: public, and in some countries other activities as well.
 98: 
 99:   To "convey" a work means any kind of propagation that enables other
100: parties to make or receive copies.  Mere interaction with a user through
101: a computer network, with no transfer of a copy, is not conveying.
102: 
103:   An interactive user interface displays "Appropriate Legal Notices"
104: to the extent that it includes a convenient and prominently visible
105: feature that (1) displays an appropriate copyright notice, and (2)
106: tells the user that there is no warranty for the work (except to the
107: extent that warranties are provided), that licensees may convey the
108: work under this License, and how to view a copy of this License.  If
109: the interface presents a list of user commands or options, such as a
110: menu, a prominent item in the list meets this criterion.
111: 
112:   1. Source Code.
113: 
114:   The "source code" for a work means the preferred form of the work
115: for making modifications to it.  "Object code" means any non-source
116: form of a work.
117: 
118:   A "Standard Interface" means an interface that either is an official
119: standard defined by a recognized standards body, or, in the case of
120: interfaces specified for a particular programming language, one that
121: is widely used among developers working in that language.
122: 
123:   The "System Libraries" of an executable work include anything, other
124: than the work as a whole, that (a) is included in the normal form of
125: packaging a Major Component, but which is not part of that Major
126: Component, and (b) serves only to enable use of the work with that
127: Major Component, or to implement a Standard Interface for which an
128: implementation is available to the public in source code form.  A
129: "Major Component", in this context, means a major essential component
130: (kernel, window system, and so on) of the specific operating system
131: (if any) on which the executable work runs, or a compiler used to
132: produce the work, or an object code interpreter used to run it.
133: 
134:   The "Corresponding Source" for a work in object code form means all
135: the source code needed to generate, install, and (for an executable
136: work) run the object code and to modify the work, including scripts to
137: control those activities.  However, it does not include the work's
138: System Libraries, or general-purpose tools or generally available free
139: programs which are used unmodified in performing those activities but
140: which are not part of the work.  For example, Corresponding Source
141: includes interface definition files associated with source files for
142: the work, and the source code for shared libraries and dynamically
143: linked subprograms that the work is specifically designed to require,
144: such as by intimate data communication or control flow between those
145: subprograms and other parts of the work.
146: 
147:   The Corresponding Source need not include anything that users
148: can regenerate automatically from other parts of the Corresponding
149: Source.
150: 
151:   The Corresponding Source for a work in source code form is that
152: same work.
153: 
154:   2. Basic Permissions.
155: 
156:   All rights granted under this License are granted for the term of
157: copyright on the Program, and are irrevocable provided the stated
158: conditions are met.  This License explicitly affirms your unlimited
159: permission to run the unmodified Program.  The output from running a
160: covered work is covered by this License only if the output, given its
161: content, constitutes a covered work.  This License acknowledges your
162: rights of fair use or other equivalent, as provided by copyright law.
163: 
164:   You may make, run and propagate covered works that you do not
165: convey, without conditions so long as your license otherwise remains
166: in force.  You may convey covered works to others for the sole purpose
167: of having them make modifications exclusively for you, or provide you
168: with facilities for running those works, provided that you comply with
169: the terms of this License in conveying all material for which you do
170: not control copyright.  Those thus making or running the covered works
171: for you must do so exclusively on your behalf, under your direction
172: and control, on terms that prohibit them from making any copies of
173: your copyrighted material outside their relationship with you.
174: 
175:   Conveying under any other circumstances is permitted solely under
176: the conditions stated below.  Sublicensing is not allowed; section 10
177: makes it unnecessary.
178: 
179:   3. Protecting Users' Legal Rights From Anti-Circumvention Law.
180: 
181:   No covered work shall be deemed part of an effective technological
182: measure under any applicable law fulfilling obligations under article
183: 11 of the WIPO copyright treaty adopted on 20 December 1996, or
184: similar laws prohibiting or restricting circumvention of such
185: measures.
186: 
187:   When you convey a covered work, you waive any legal power to forbid
188: circumvention of technological measures to the extent such circumvention
189: is effected by exercising rights under this License with respect to
190: the covered work, and you disclaim any intention to limit operation or
191: modification of the work as a means of enforcing, against the work's
192: users, your or third parties' legal rights to forbid circumvention of
193: technological measures.
194: 
195:   4. Conveying Verbatim Copies.
196: 
197:   You may convey verbatim copies of the Program's source code as you
198: receive it, in any medium, provided that you conspicuously and
199: appropriately publish on each copy an appropriate copyright notice;
200: keep intact all notices stating that this License and any
201: non-permissive terms added in accord with section 7 apply to the code;
202: keep intact all notices of the absence of any warranty; and give all
203: recipients a copy of this License along with the Program.
204: 
205:   You may charge any price or no price for each copy that you convey,
206: and you may offer support or warranty protection for a fee.
207: 
208:   5. Conveying Modified Source Versions.
209: 
210:   You may convey a work based on the Program, or the modifications to
211: produce it from the Program, in the form of source code under the
212: terms of section 4, provided that you also meet all of these conditions:
213: 
214:     a) The work must carry prominent notices stating that you modified
215:     it, and giving a relevant date.
216: 
217:     b) The work must carry prominent notices stating that it is
218:     released under this License and any conditions added under section
219:     7.  This requirement modifies the requirement in section 4 to
220:     "keep intact all notices".
221: 
222:     c) You must license the entire work, as a whole, under this
223:     License to anyone who comes into possession of a copy.  This
224:     License will therefore apply, along with any applicable section 7
225:     additional terms, to the whole of the work, and all its parts,
226:     regardless of how they are packaged.  This License gives no
227:     permission to license the work in any other way, but it does not
228:     invalidate such permission if you have separately received it.
229: 
230:     d) If the work has interactive user interfaces, each must display
231:     Appropriate Legal Notices; however, if the Program has interactive
232:     interfaces that do not display Appropriate Legal Notices, your
233:     work need not make them do so.
234: 
235:   A compilation of a covered work with other separate and independent
236: works, which are not by their nature extensions of the covered work,
237: and which are not combined with it such as to form a larger program,
238: in or on a volume of a storage or distribution medium, is called an
239: "aggregate" if the compilation and its resulting copyright are not
240: used to limit the access or legal rights of the compilation's users
241: beyond what the individual works permit.  Inclusion of a covered work
242: in an aggregate does not cause this License to apply to the other
243: parts of the aggregate.
244: 
245:   6. Conveying Non-Source Forms.
246: 
247:   You may convey a covered work in object code form under the terms
248: of sections 4 and 5, provided that you also convey the
249: machine-readable Corresponding Source under the terms of this License,
250: in one of these ways:
251: 
252:     a) Convey the object code in, or embodied in, a physical product
253:     (including a physical distribution medium), accompanied by the
254:     Corresponding Source fixed on a durable physical medium
255:     customarily used for software interchange.
256: 
257:     b) Convey the object code in, or embodied in, a physical product
258:     (including a physical distribution medium), accompanied by a
259:     written offer, valid for at least three years and valid for as
260:     long as you offer spare parts or customer support for that product
261:     model, to give anyone who possesses the object code either (1) a
262:     copy of the Corresponding Source for all the software in the
263:     product that is covered by this License, on a durable physical
264:     medium customarily used for software interchange, for a price no
265:     more than your reasonable cost of physically performing this
266:     conveying of source, or (2) access to copy the
267:     Corresponding Source from a network server at no charge.
268: 
269:     c) Convey individual copies of the object code with a copy of the
270:     written offer to provide the Corresponding Source.  This
271:     alternative is allowed only occasionally and noncommercially, and
272:     only if you received the object code with such an offer, in accord
273:     with subsection 6b.
274: 
275:     d) Convey the object code by offering access from a designated
276:     place (gratis or for a charge), and offer equivalent access to the
277:     Corresponding Source in the same way through the same place at no
278:     further charge.  You need not require recipients to copy the
279:     Corresponding Source along with the object code.  If the place to
280:     copy the object code is a network server, the Corresponding Source
281:     may be on a different server (operated by you or a third party)
282:     that supports equivalent copying facilities, provided you maintain
283:     clear directions next to the object code saying where to find the
284:     Corresponding Source.  Regardless of what server hosts the
285:     Corresponding Source, you remain obligated to ensure that it is
286:     available for as long as needed to satisfy these requirements.
287: 
288:     e) Convey the object code using peer-to-peer transmission, provided
289:     you inform other peers where the object code and Corresponding
290:     Source of the work are being offered to the general public at no
291:     charge under subsection 6d.
292: 
293:   A separable portion of the object code, whose source code is excluded
294: from the Corresponding Source as a System Library, need not be
295: included in conveying the object code work.
296: 
297:   A "User Product" is either (1) a "consumer product", which means any
298: tangible personal property which is normally used for personal, family,
299: or household purposes, or (2) anything designed or sold for incorporation
300: into a dwelling.  In determining whether a product is a consumer product,
301: doubtful cases shall be resolved in favor of coverage.  For a particular
302: product received by a particular user, "normally used" refers to a
303: typical or common use of that class of product, regardless of the status
304: of the particular user or of the way in which the particular user
305: actually uses, or expects or is expected to use, the product.  A product
306: is a consumer product regardless of whether the product has substantial
307: commercial, industrial or non-consumer uses, unless such uses represent
308: the only significant mode of use of the product.
309: 
310:   "Installation Information" for a User Product means any methods,
311: procedures, authorization keys, or other information required to install
312: and execute modified versions of a covered work in that User Product from
313: a modified version of its Corresponding Source.  The information must
314: suffice to ensure that the continued functioning of the modified object
315: code is in no case prevented or interfered with solely because
316: modification has been made.
317: 
318:   If you convey an object code work under this section in, or with, or
319: specifically for use in, a User Product, and the conveying occurs as
320: part of a transaction in which the right of possession and use of the
321: User Product is transferred to the recipient in perpetuity or for a
322: fixed term (regardless of how the transaction is characterized), the
323: Corresponding Source conveyed under this section must be accompanied
324: by the Installation Information.  But this requirement does not apply
325: if neither you nor any third party retains the ability to install
326: modified object code on the User Product (for example, the work has
327: been installed in ROM).
328: 
329:   The requirement to provide Installation Information does not include a
330: requirement to continue to provide support service, warranty, or updates
331: for a work that has been modified or installed by the recipient, or for
332: the User Product in which it has been modified or installed.  Access to a
333: network may be denied when the modification itself materially and
334: adversely affects the operation of the network or violates the rules and
335: protocols for communication across the network.
336: 
337:   Corresponding Source conveyed, and Installation Information provided,
338: in accord with this section must be in a format that is publicly
339: documented (and with an implementation available to the public in
340: source code form), and must require no special password or key for
341: unpacking, reading or copying.
342: 
343:   7. Additional Terms.
344: 
345:   "Additional permissions" are terms that supplement the terms of this
346: License by making exceptions from one or more of its conditions.
347: Additional permissions that are applicable to the entire Program shall
348: be treated as though they were included in this License, to the extent
349: that they are valid under applicable law.  If additional permissions
350: apply only to part of the Program, that part may be used separately
351: under those permissions, but the entire Program remains governed by
352: this License without regard to the additional permissions.
353: 
354:   When you convey a copy of a covered work, you may at your option
355: remove any additional permissions from that copy, or from any part of
356: it.  (Additional permissions may be written to require their own
357: removal in certain cases when you modify the work.)  You may place
358: additional permissions on material, added by you to a covered work,
359: for which you have or can give appropriate copyright permission.
360: 
361:   Notwithstanding any other provision of this License, for material you
362: add to a covered work, you may (if authorized by the copyright holders of
363: that material) supplement the terms of this License with terms:
364: 
365:     a) Disclaiming warranty or limiting liability differently from the
366:     terms of sections 15 and 16 of this License; or
367: 
368:     b) Requiring preservation of specified reasonable legal notices or
369:     author attributions in that material or in the Appropriate Legal
370:     Notices displayed by works containing it; or
371: 
372:     c) Prohibiting misrepresentation of the origin of that material, or
373:     requiring that modified versions of such material be marked in
374:     reasonable ways as different from the original version; or
375: 
376:     d) Limiting the use for publicity purposes of names of licensors or
377:     authors of the material; or
378: 
379:     e) Declining to grant rights under trademark law for use of some
380:     trade names, trademarks, or service marks; or
381: 
382:     f) Requiring indemnification of licensors and authors of that
383:     material by anyone who conveys the material (or modified versions of
384:     it) with contractual assumptions of liability to the recipient, for
385:     any liability that these contractual assumptions directly impose on
386:     those licensors and authors.
387: 
388:   All other non-permissive additional terms are considered "further
389: restrictions" within the meaning of section 10.  If the Program as you
390: received it, or any part of it, contains a notice stating that it is
391: governed by this License along with a term that is a further
392: restriction, you may remove that term.  If a license document contains
393: a further restriction but permits relicensing or conveying under this
394: License, you may add to a covered work material governed by the terms
395: of that license document, provided that the further restriction does
396: not survive such relicensing or conveying.
397: 
398:   If you add terms to a covered work in accord with this section, you
399: must place, in the relevant source files, a statement of the
400: additional terms that apply to those files, or a notice indicating
401: where to find the applicable terms.
402: 
403:   Additional terms, permissive or non-permissive, may be stated in the
404: form of a separately written license, or stated as exceptions;
405: the above requirements apply either way.
406: 
407:   8. Termination.
408: 
409:   You may not propagate or modify a covered work except as expressly
410: provided under this License.  Any attempt otherwise to propagate or
411: modify it is void, and will automatically terminate your rights under
412: this License (including any patent licenses granted under the third
413: paragraph of section 11).
414: 
415:   However, if you cease all violation of this License, then your
416: license from a particular copyright holder is reinstated (a)
417: provisionally, unless and until the copyright holder explicitly and
418: finally terminates your license, and (b) permanently, if the copyright
419: holder fails to notify you of the violation by some reasonable means
420: prior to 60 days after the cessation.
421: 
422:   Moreover, your license from a particular copyright holder is
423: reinstated permanently if the copyright holder notifies you of the
424: violation by some reasonable means, this is the first time you have
425: received notice of violation of this License (for any work) from that
426: copyright holder, and you cure the violation prior to 30 days after
427: your receipt of the notice.
428: 
429:   Termination of your rights under this section does not terminate the
430: licenses of parties who have received copies or rights from you under
431: this License.  If your rights have been terminated and not permanently
432: reinstated, you do not qualify to receive new licenses for the same
433: material under section 10.
434: 
435:   9. Acceptance Not Required for Having Copies.
436: 
437:   You are not required to accept this License in order to receive or
438: run a copy of the Program.  Ancillary propagation of a covered work
439: occurring solely as a consequence of using peer-to-peer transmission
440: to receive a copy likewise does not require acceptance.  However,
441: nothing other than this License grants you permission to propagate or
442: modify any covered work.  These actions infringe copyright if you do
443: not accept this License.  Therefore, by modifying or propagating a
444: covered work, you indicate your acceptance of this License to do so.
445: 
446:   10. Automatic Licensing of Downstream Recipients.
447: 
448:   Each time you convey a covered work, the recipient automatically
449: receives a license from the original licensors, to run, modify and
450: propagate that work, subject to this License.  You are not responsible
451: for enforcing compliance by third parties with this License.
452: 
453:   An "entity transaction" is a transaction transferring control of an
454: organization, or substantially all assets of one, or subdividing an
455: organization, or merging organizations.  If propagation of a covered
456: work results from an entity transaction, each party to that
457: transaction who receives a copy of the work also receives whatever
458: licenses to the work the party's predecessor in interest had or could
459: give under the previous paragraph, plus a right to possession of the
460: Corresponding Source of the work from the predecessor in interest, if
461: the predecessor has it or can get it with reasonable efforts.
462: 
463:   You may not impose any further restrictions on the exercise of the
464: rights granted or affirmed under this License.  For example, you may
465: not impose a license fee, royalty, or other charge for exercise of
466: rights granted under this License, and you may not initiate litigation
467: (including a cross-claim or counterclaim in a lawsuit) alleging that
468: any patent claim is infringed by making, using, selling, offering for
469: sale, or importing the Program or any portion of it.
470: 
471:   11. Patents.
472: 
473:   A "contributor" is a copyright holder who authorizes use under this
474: License of the Program or a work on which the Program is based.  The
475: work thus licensed is called the contributor's "contributor version".
476: 
477:   A contributor's "essential patent claims" are all patent claims
478: owned or controlled by the contributor, whether already acquired or
479: hereafter acquired, that would be infringed by some manner, permitted
480: by this License, of making, using, or selling its contributor version,
481: but do not include claims that would be infringed only as a
482: consequence of further modification of the contributor version.  For
483: purposes of this definition, "control" includes the right to grant
484: patent sublicenses in a manner consistent with the requirements of
485: this License.
486: 
487:   Each contributor grants you a non-exclusive, worldwide, royalty-free
488: patent license under the contributor's essential patent claims, to
489: make, use, sell, offer for sale, import and otherwise run, modify and
490: propagate the contents of its contributor version.
491: 
492:   In the following three paragraphs, a "patent license" is any express
493: agreement or commitment, however denominated, not to enforce a patent
494: (such as an express permission to practice a patent or covenant not to
495: sue for patent infringement).  To "grant" such a patent license to a
496: party means to make such an agreement or commitment not to enforce a
497: patent against the party.
498: 
499:   If you convey a covered work, knowingly relying on a patent license,
500: and the Corresponding Source of the work is not available for anyone
501: to copy, free of charge and under the terms of this License, through a
502: publicly available network server or other readily accessible means,
503: then you must either (1) cause the Corresponding Source to be so
504: available, or (2) arrange to deprive yourself of the benefit of the
505: patent license for this particular work, or (3) arrange, in a manner
506: consistent with the requirements of this License, to extend the patent
507: license to downstream recipients.  "Knowingly relying" means you have
508: actual knowledge that, but for the patent license, your conveying the
509: covered work in a country, or your recipient's use of the covered work
510: in a country, would infringe one or more identifiable patents in that
511: country that you have reason to believe are valid.
512: 
513:   If, pursuant to or in connection with a single transaction or
514: arrangement, you convey, or propagate by procuring conveyance of, a
515: covered work, and grant a patent license to some of the parties
516: receiving the covered work authorizing them to use, propagate, modify
517: or convey a specific copy of the covered work, then the patent license
518: you grant is automatically extended to all recipients of the covered
519: work and works based on it.
520: 
521:   A patent license is "discriminatory" if it does not include within
522: the scope of its coverage, prohibits the exercise of, or is
523: conditioned on the non-exercise of one or more of the rights that are
524: specifically granted under this License.  You may not convey a covered
525: work if you are a party to an arrangement with a third party that is
526: in the business of distributing software, under which you make payment
527: to the third party based on the extent of your activity of conveying
528: the work, and under which the third party grants, to any of the
529: parties who would receive the covered work from you, a discriminatory
530: patent license (a) in connection with copies of the covered work
531: conveyed by you (or copies made from those copies), or (b) primarily
532: for and in connection with specific products or compilations that
533: contain the covered work, unless you entered into that arrangement,
534: or that patent license was granted, prior to 28 March 2007.
535: 
536:   Nothing in this License shall be construed as excluding or limiting
537: any implied license or other defenses to infringement that may
538: otherwise be available to you under applicable patent law.
539: 
540:   12. No Surrender of Others' Freedom.
541: 
542:   If conditions are imposed on you (whether by court order, agreement or
543: otherwise) that contradict the conditions of this License, they do not
544: excuse you from the conditions of this License.  If you cannot convey a
545: covered work so as to satisfy simultaneously your obligations under this
546: License and any other pertinent obligations, then as a consequence you may
547: not convey it at all.  For example, if you agree to terms that obligate you
548: to collect a royalty for further conveying from those to whom you convey
549: the Program, the only way you could satisfy both those terms and this
550: License would be to refrain entirely from conveying the Program.
551: 
552:   13. Use with the GNU Affero General Public License.
553: 
554:   Notwithstanding any other provision of this License, you have
555: permission to link or combine any covered work with a work licensed
556: under version 3 of the GNU Affero General Public License into a single
557: combined work, and to convey the resulting work.  The terms of this
558: License will continue to apply to the part which is the covered work,
559: but the special requirements of the GNU Affero General Public License,
560: section 13, concerning interaction through a network will apply to the
561: combination as such.
562: 
563:   14. Revised Versions of this License.
564: 
565:   The Free Software Foundation may publish revised and/or new versions of
566: the GNU General Public License from time to time.  Such new versions will
567: be similar in spirit to the present version, but may differ in detail to
568: address new problems or concerns.
569: 
570:   Each version is given a distinguishing version number.  If the
571: Program specifies that a certain numbered version of the GNU General
572: Public License "or any later version" applies to it, you have the
573: option of following the terms and conditions either of that numbered
574: version or of any later version published by the Free Software
575: Foundation.  If the Program does not specify a version number of the
576: GNU General Public License, you may choose any version ever published
577: by the Free Software Foundation.
578: 
579:   If the Program specifies that a proxy can decide which future
580: versions of the GNU General Public License can be used, that proxy's
581: public statement of acceptance of a version permanently authorizes you
582: to choose that version for the Program.
583: 
584:   Later license versions may give you additional or different
585: permissions.  However, no additional obligations are imposed on any
586: author or copyright holder as a result of your choosing to follow a
587: later version.
588: 
589:   15. Disclaimer of Warranty.
590: 
591:   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
592: APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
593: HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
594: OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
595: THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
596: PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
597: IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
598: ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
599: 
600:   16. Limitation of Liability.
601: 
602:   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
603: WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
604: THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
605: GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
606: USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
607: DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
608: PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
609: EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
610: SUCH DAMAGES.
611: 
612:   17. Interpretation of Sections 15 and 16.
613: 
614:   If the disclaimer of warranty and limitation of liability provided
615: above cannot be given local legal effect according to their terms,
616: reviewing courts shall apply local law that most closely approximates
617: an absolute waiver of all civil liability in connection with the
618: Program, unless a warranty or assumption of liability accompanies a
619: copy of the Program in return for a fee.
620: 
621:                      END OF TERMS AND CONDITIONS
622: 
623:             How to Apply These Terms to Your New Programs
624: 
625:   If you develop a new program, and you want it to be of the greatest
626: possible use to the public, the best way to achieve this is to make it
627: free software which everyone can redistribute and change under these terms.
628: 
629:   To do so, attach the following notices to the program.  It is safest
630: to attach them to the start of each source file to most effectively
631: state the exclusion of warranty; and each file should have at least
632: the "copyright" line and a pointer to where the full notice is found.
633: 
634:     <one line to give the program's name and a brief idea of what it does.>
635:     Copyright (C) <year>  <name of author>
636: 
637:     This program is free software: you can redistribute it and/or modify
638:     it under the terms of the GNU General Public License as published by
639:     the Free Software Foundation, either version 3 of the License, or
640:     (at your option) any later version.
641: 
642:     This program is distributed in the hope that it will be useful,
643:     but WITHOUT ANY WARRANTY; without even the implied warranty of
644:     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
645:     GNU General Public License for more details.
646: 
647:     You should have received a copy of the GNU General Public License
648:     along with this program.  If not, see <https://www.gnu.org/licenses/>.
649: 
650: Also add information on how to contact you by electronic and paper mail.
651: 
652:   If the program does terminal interaction, make it output a short
653: notice like this when it starts in an interactive mode:
654: 
655:     <program>  Copyright (C) <year>  <name of author>
656:     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
657:     This is free software, and you are welcome to redistribute it
658:     under certain conditions; type `show c' for details.
659: 
660: The hypothetical commands `show w' and `show c' should show the appropriate
661: parts of the General Public License.  Of course, your program's commands
662: might be different; for a GUI interface, you would use an "about box".
663: 
664:   You should also get your employer (if you work as a programmer) or school,
665: if any, to sign a "copyright disclaimer" for the program, if necessary.
666: For more information on this, and how to apply and follow the GNU GPL, see
667: <https://www.gnu.org/licenses/>.
668: 
669:   The GNU General Public License does not permit incorporating your program
670: into proprietary programs.  If your program is a subroutine library, you
671: may consider it more useful to permit linking proprietary applications with
672: the library.  If this is what you want to do, use the GNU Lesser General
673: Public License instead of this License.  But first, please read
674: <https://www.gnu.org/licenses/why-not-lgpl.html>.
</file>

<file path="README.md">
  1: ![License](https://img.shields.io/github/license/julianxhokaxhiu/FFNx) ![Overall Downloads](https://img.shields.io/github/downloads/julianxhokaxhiu/FFNx/total?label=Overall%20Downloads) ![Latest Stable Downloads](https://img.shields.io/github/downloads/julianxhokaxhiu/FFNx/latest/total?label=Latest%20Stable%20Downloads&sort=semver) ![Latest Canary Downloads](https://img.shields.io/github/downloads/julianxhokaxhiu/FFNx/canary/total?label=Latest%20Canary%20Downloads) ![GitHub Actions Workflow Status](https://github.com/julianxhokaxhiu/FFNx/actions/workflows/main-1.23.0.yml/badge.svg?branch=master)
  2: 
  3: <div align="center">
  4:   <img src="https://github.com/julianxhokaxhiu/FFNx/blob/master/.logo/logo_nobg.png" alt="">
  5:   <br><strong><small>Kudos to <a href="https://www.instagram.com/aryaaiedail/">Cinzia Cancedda (aryaaiedail)</a></small></strong>
  6: </div>
  7: 
  8: # FFNx
  9: 
 10: Next generation modding platform for Final Fantasy VII and Final Fantasy VIII (with native Steam 2013 release support)
 11: 
 12: ## Introduction
 13: 
 14: FFNx is a continuing evolution of the [FF7_OpenGL](https://github.com/Aali132/ff7_opengl) driver, [made by Aali](http://forums.qhimm.com/index.php?topic=14922.0).
 15: 
 16: FFNx today in a nutshell:
 17: 
 18: - Uses an easy, drag-n-drop installation experience, see [How to Install](docs/how_to_install.md)
 19: - Comes built-in with 7th Heaven v2.3 and higher
 20: - Supports the newest video and audio codecs (WEBM, H.265, Ogg, etc.)
 21: - Drastically enhances the gameplay experience compared to the vanilla experience
 22: - Provides four stable rendering backends:
 23:   - DirectX 11 (default)
 24:   - DirectX 12
 25:   - Vulkan
 26:   - OpenGL
 27: 
 28: ## The Team
 29: 
 30: FFNx is developed by a core team, currently composed of:
 31: 
 32: - [Julian Xhokaxhiu](https://github.com/julianxhokaxhiu) (TrueOdin, üá™üá∏ Spain)
 33: - [Tang-Tang Zhou](https://github.com/tangtang95) (vertex2995, üáÆüáπ Italy)
 34: - [J√©r√¥me Arzel](https://github.com/myst6re) (myst6re, üá´üá∑ France)
 35: - [CosmosXIII](https://github.com/CosmosXIII) (Cosmos, üáØüáµ Japan)
 36: 
 37: We are always open for contributions via PRs, and in case you want to join the core team, feel free to approach us on Discord and we will evaluate on a case-by-case basis.
 38: 
 39: ## Features
 40: 
 41: ### As a user
 42: 
 43: #### FF7/FF8
 44: 
 45: - [/LARGEADDRESSAWARE](https://docs.microsoft.com/en-us/cpp/build/reference/largeaddressaware-handle-large-addresses?view=vs-2019) support. Up to 3.5GB of RAM available for mods (this requires the [4GB Patch](https://ntcore.com/?page_id=371) in your ff7.exe).
 46: - High DPI support
 47: - HDR support
 48: - Up to 16x anisotropic support
 49: - Up to 16x antialiasing support
 50: - 5.1/7.1 audio output support
 51: - Steam support; no game converter required
 52: - Steam savegame preservation (you no longer lose saves created while FFNx is active)
 53: - XInput controller support (Xbox 360 and compatible) with D-Pad working out-of-the-box
 54: - Native speedhack support
 55: - External music loading to replace original MIDIs
 56: - The game continues to run within an inactive window
 57: 
 58: #### FF7
 59: - 60 FPS
 60: - eStore support! No game converter required
 61: - Vertical centering for fields and movies
 62: - Fullscreen battle scenes
 63: - Menu cursor vertically aligned on the center of words
 64: - Movies continue to play while running in an inactive window
 65: - Movie volume respects global sound volume
 66: - Steam sound and music volume configuration preservation (configure at your pleasure and on the next run it will be inherited)
 67: - Configurable background transparency in battle dialogs (by default set to 75%)
 68: - SFX volume change applies in real-time, instead of requiring a game reload
 69: - Support for animated textures (like Aerith's waterfall, light fading, etc.)
 70: - Support for soft-reset while you're playing, just like the PSX
 71: - Support for battle toggle (enable/disable at your own pleasure)
 72: - **Voice acting**! [Echo-S](https://www.tsunamods.com/echo-s-7/) was the first mod to take advantage of this!
 73: - Support for external SFX audio effects
 74: - Support for external ambient audio effects
 75: - Support for external movie audio files (allows multiple videos to share the same audio)
 76: - Support for external movie voice acting (dedicated audio layer only for voice acting on top of movies)
 77: - Steam achievements can be unlocked while playing within FFNx
 78: - Real-time light engine - You can now feel the game visually like never before
 79: - Real-time camera control in battles
 80: - Analogue controls using the full axis of your left analog stick
 81: 
 82: #### FF8
 83: - Vibration support
 84: - Analog controls improved support
 85: - **Voice acting**! [Echo-S](https://www.tsunamods.com/echo-s-8/) was the first mod to take advantage of this!
 86: - Various graphical patches for worldmap included
 87: - Enable the VRAM debug window while playing in order to see how the engine uploads textures
 88: - Support for external SFX audio effects
 89: - Support for external movie audio files (allows multiple videos to share the same audio)
 90: - Support for external movie voice acting (dedicated audio layer only for voice acting on top of movies)
 91: - Support for external music audio with music resume after battle and improved volume transitions
 92: 
 93: ### As a modder
 94: 
 95: - Game rendering inspection through [RenderDoc](https://renderdoc.org/)
 96: - [DDS Texture support](https://wiki.beyondskyrim.org/wiki/Arcane_University:DDS_Data_Format) up to BC7 format, with PNG support as fallback
 97: - Support for configurable external textures path using [mod_path](misc/FFNx.toml#L100)
 98: - Support for an override layer of the data directory using [override_path](misc/FFNx.toml#L116)
 99: - Support for MINIPSF audio files using the emulated PSX/PS2 AKAO Engine
100: - Support for [Hext](https://forums.qhimm.com/index.php?topic=13574.0) patching files inside of the [hext_patching_path](misc/FFNx.toml#L113)
101: - Debug in-game engine data through [imgui](https://github.com/ocornut/imgui) integration
102: 
103: ## Documentation
104: 
105: For a more in-depth documentation feel free to visit the [docs/](docs/) folder.
106: 
107: ## Screenshots
108: 
109: |                       Vanilla/Steam                                                                  |
110: | :--------------------------------------------------------------------------------------------------: |
111: | ![Final Fantasy VII running on Vulkan](.screens/ff7.png)                                             |
112: | ![Final Fantasy VIII running on Vulkan](.screens/ff8.png)                                            |
113: | [![Final Fantasy VIII Worldmap graphical patches](.screens/ff8-worldmap-official-release-vs-ffnx.png)](https://imgsli.com/MTg5NjQ2) |
114: 
115: ## Tech Stack
116: 
117: If you're curious to know, FFNx makes use of:
118: 
119: - C++ code base
120: - Latest MSVC available on [Visual Studio 2022 Community Edition](https://visualstudio.microsoft.com/vs/features/cplusplus/)
121: - [vcpkg](https://vcpkg.io/) (dependency manager)
122: - [CMake](https://cmake.org/) (make files)
123: - [BGFX](https://github.com/bkaradzic/bgfx) (backend renderer)
124: - [BIMG](https://github.com/bkaradzic/bimg) (custom textures)
125: - [FFMpeg](https://www.ffmpeg.org/) with H/W accelleration support
126: - [VGMStream](https://github.com/losnoco/vgmstream) using FFMpeg as backend (with loop support!)
127: - [tomlplusplus](https://github.com/marzer/tomlplusplus) (configuration management)
128: - [StackWalker](https://github.com/JochenKalmbach/StackWalker) (log file stack traces)
129: - [pugixml](https://github.com/zeux/pugixml) (Steam XML manifest)
130: - [md5](http://www.zedwood.com/article/cpp-md5-function) (Steam XML manifest)
131: - [libpng](http://www.libpng.org/pub/png/libpng.html) (better and faster PNG texture support)
132: - [imgui](https://github.com/ocornut/imgui) (DevTools in-game interface)
133: - [imgui_club](https://github.com/ocornut/imgui_club) (imgui Memory Editor Widget)
134: - [xxhash](https://github.com/Cyan4973/xxHash) (fast hash extraction from paletted game texture data, aka animated textures)
135: - [SoLoud](https://github.com/jarikomppa/soloud) (audio engine used to playback audio, music or voice files)
136: - [openpsf](https://github.com/myst6re/openpsf) (MINIPSF emulation engine to playback PSX/PS2 music files)
137: - [Steamworks SDK](https://github.com/julianxhokaxhiu/SteamworksSDKCI) (support achievements for the Steam editions of games)
138: - [mimalloc](https://github.com/microsoft/mimalloc) (a compact general purpose allocator with excellent performance)
139: 
140: ## How to build
141: 
142: Available build profiles:
143: 
144: - x86-Release (default, the same used to release artifacts in this Github page)
145: - x86-RelWithDebInfo (used while developing to better debug some issues)
146: - x86-MinSizeRel
147: - x86-Debug (prefer it if you want to use a debugger attached to the game)
148: 
149: Once the project is built you can find the output in this path: `.build/bin`
150: 
151: ### Preparation
152: 
153: > **Please note:**
154: >
155: > FFNx uses vcpkg as a package manager to resolve dependencies. Failing to follow these steps will result in build errors.
156: 
157: 0. Clone this repository using the `--recursive` flag, eg. `git clone --recursive https://github.com/julianxhokaxhiu/FFNx.git`
158: 
159: ### NuGet
160: 
161: > **Please note:**
162: >
163: > This step will speed up your compilation times by avoiding the vcpkg dependencies rebuild.
164: 
165: 0. Make sure you have [NuGet CLI installed](https://learn.microsoft.com/en-us/nuget/install-nuget-client-tools?tabs=windows#install-nugetexe).
166: 1. [Create a Personal Access token ( classic )](https://github.com/settings/tokens/new) with the `write:packages` permission.
167: 2. Open a `cmd` window and run the following commands ( replace `YOUR_GITHUB_USERNAME` and `YOUR_GITHUB_PAT` accordingly ):
168: ```pwsh
169: $ nuget sources add -Name github -Source "https://nuget.pkg.github.com/YOUR_GITHUB_USERNAME/index.json" -Username YOUR_GITHUB_USERNAME -Password YOUR_GITHUB_PAT -StorePasswordInClearText
170: $ nuget setApiKey YOUR_GITHUB_PAT -Source "https://nuget.pkg.github.com/YOUR_GITHUB_USERNAME/index.json"
171: ```
172: 
173: ### Visual Studio
174: 
175: > **Please note:**
176: >
177: > By default Visual Studio will pick the **x86-Release** build configuration, but you can choose any other profile available.
178: > FFNx uses vcpkg as a package manager to resolve dependencies. Failing to follow these steps will result in build errors.
179: 
180: 0. Download the the latest [Visual Studio Community](https://visualstudio.microsoft.com/vs/community/) installer
181: 1. Run the installer and import this [.vsconfig](.vsconfig) file in the installer to pick the components required to build this project
182: 2. Make sure you select the English Language pack in the language list before clicking Install
183: 3. Go inside the [`vcpkg`](./vcpkg) folder and double click `bootstrap-vcpkg.bat`
184: 4. Open a `cmd` window in [`vcpkg`](./vcpkg) and run the following command: `vcpkg integrate install`
185: 5. Once installed, open this repository **as a folder** in Visual Studio
186: 6. Choose as preset in the status bar the one you desire
187: 7. Click the `Build` button
188: 
189: ### Visual Studio Code
190: 
191: 0. **REQUIRED!** Follow up the steps to install Visual Studio, which will also install the MSVC toolchain
192: 1. Download and install the latest [Visual Studio Code](https://code.visualstudio.com/) release
193: 2. Install the following extensions:
194:    - https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools
195:    - https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools
196: 3. Open this repository as a folder in Visual Studio Code
197: 4. Choose as preset in the status bar the one you desire
198: 5. Click the button on the status bar `Build`
199: 
200: ### Neovim with clangd (optional)
201: 
202: 0. **REQUIRED!** Follow up the steps to install Visual Studio, which will also install the MSVC toolchain
203: 1. **REQUIRED!** Have [Neovim](https://neovim.io/) installed with [clangd](https://clangd.llvm.org/) as LSP
204: 2. Install the extension `Clang Power Tools` in [Visual Studio Community](https://visualstudio.microsoft.com/vs/community/)
205: 3. Open the solution `FFNx.sln` under the `.build` directory with **Visual Studio Community** (**sln** file is generated by the build process)
206: 4. Right-click on **FFNx** solution (under the **Solution Explorer**) then click on **Clang Power Tools** -> **Export Compilation Database**
207: 5. Copy the `compile_commands.json` generated file into the root of the repository
208: 6. Open **Neovim** and enjoy!
209: 
210: To build from the terminal (example with *RelWithDebInfo*):
211: - For dependency use: `cmake --preset RelWithDebInfo`
212: - For building the project: `cmake --build --preset RelWithDebInfo`
213: 
214: **NOTE**: Make sure to use the `cmake` executable that comes from Visual Studio
215: (e.g. `C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe`)
216: 
217: ## Auto-Formatting
218: 
219: ### CMake Files
220: 
221: 0. **REQUIRED!** Install [Python](https://www.python.org/)
222: 1. Install [cmake-format](https://github.com/cheshirekow/cmake_format#installation) and make sure the binary is available in your PATH environment variable
223: 2. **OPTIONAL!** Integrate it [in your own IDE](https://github.com/cheshirekow/cmake_format#integrations) (eg. for Visual Studio Code use [the relative extension](https://marketplace.visualstudio.com/items?itemName=cheshirekow.cmake-format))
224: 
225: ## Support
226: 
227: FFNx offers multiple support channels, pick the one you prefer
228: 
229: ### Forums
230: 
231: - Qhimm Forum: http://forums.qhimm.com/index.php?topic=19970.0
232: - Tsunamods Forum: https://forum.tsunamods.com/viewtopic.php?p=41#p41
233: 
234: ### Discord
235: 
236: - Qhimm FFNx-FF7 (Final Fantasy VII only): https://discord.gg/N6M6pKS
237: - Qhimm FFNx-FF8 (Final Fantasy VIII only): https://discord.gg/u6M7DnY
238: - Tsunamods FFNx: https://discord.gg/Urq67Uz (remember to hit the Red Chocobo reaction!)
239: 
240: ### Github
241: 
242: - Issues: https://github.com/julianxhokaxhiu/FFNx/issues
243: 
244: ## Credits
245: 
246: This project could have not been a reality if those people would have not worked on FF7 and FF8 with their deep passion and knowledge.
247: FFNx makes use also of their work, and I will never be enough grateful to those people. The order is purely Alphabetical.
248: 
249: These people are:
250: 
251: - [Aali](http://forums.qhimm.com/index.php?action=profile;u=2862):
252:   - for the original Driver code FFNx is based on.
253: - [Chrysalis](http://forums.qhimm.com/index.php?action=profile;u=674):
254:   - for the battle fullscreen hext patch
255:   - for the menu cursor vertical centering in menu
256: - [CosmosXIII](https://github.com/CosmosXIII)
257:   - for the real-time light engine
258:   - for the real-time camera control in battles
259:   - for the analogue controls in FF7
260: - [DLPB](https://forums.qhimm.com/index.php?action=profile;u=6439):
261:   - for original Hext concept and specification that FFNx implemented as well
262:   - for the field vertical centering hext patch, which FFNx provides a default patch for
263:   - for the Soft-Reset original concept
264:   - for the no battle original concept
265: - [dziugo](http://forums.qhimm.com/index.php?action=profile;u=1660):
266:   - for the original FMV skip concept
267: - [ficedula](http://forums.qhimm.com/index.php?action=profile;u=68):
268:   - for 7h 1.x which FFNx provides support for
269: - [Iros](https://forums.qhimm.com/index.php?action=profile;u=21785):
270:   - for 7h 1.x which FFNx provides support for
271: - [JWP](http://forums.qhimm.com/index.php?action=profile;u=3772):
272:   - for imgui integration within FFNx
273: - [Kranmer](http://forums.qhimm.com/index.php?action=profile;u=4909)
274:   - for PHS save everywhere Hext patch
275:   - for the no battle original concept
276: - [Maki](http://forums.qhimm.com/index.php?action=profile;u=23937):
277:   - for FF8 UV Hext Patch in the world map, which FFNx provides a default patch for
278:   - for the help in getting the first iterations of FFNx running on FF8 2000/2013 release
279: - [myst6re](http://forums.qhimm.com/index.php?action=profile;u=4778):
280:   - for the great tools like Makou Reactor, Deling and many others he did which helped a lot in improving FF8 while working on the code
281:   - for the great help in the code implementing the MINIPSF emulation layer being present inside FFNx
282:   - for the heavy testing and lifting of a lot of bugs being catched in FFNx, for FF8
283:   - for the Steam savegame logic in the manifest.xml for FF8
284:   - for the real-time SFX volume change for FF7
285: - [quantumpencil](http://forums.qhimm.com/index.php?action=profile;u=23810) and [Nax](https://github.com/nax):
286:   - for the original CMake files FFNx has based its work upon
287:   - for all the help in getting some logics wired up in the game engine and a lot of hex addresses I would never been able to figure out myself
288: - [Satsuki](http://forums.qhimm.com/index.php?action=profile;u=24647):
289:   - for the heavy testing and lifting of a lot of bugs being catched in FFNx, for FF7
290:   - for the field vertical centering hext patch, which FFNx provides a default patch for
291:   - for a lot of hex addresses I would have never been able to figure out myself otherwise
292:   - for the original Speedhack concept and help in getting it natively into FFNx
293: - [Sebanisu](http://forums.qhimm.com/index.php?action=profile;u=22866):
294:   - for the help in getting the first iterations of FFNx running on FF8 2000/2013 release
295:   - for the heavy testing and lifting of a lot of bugs being catched in FFNx, for FF8
296: - [sithlord48](http://forums.qhimm.com/index.php?action=profile;u=6501):
297:   - for the Steam savegame logic in the manifest.xml for FF7
298: - [TurBoss](https://github.com/TurBoss):
299:   - for 7h 1.x source code release and FFNx enablement
300: - [unab0mb](https://forums.qhimm.com/index.php?action=profile;u=31071):
301:   - for the official integration of FFNx within 7thHeaven 2.3+
302: - [tangtang95](https://github.com/tangtang95)
303:   - for the 60FPS support in FF7
304:   - for the Steam achievements in FF7
305: - [Lord UrQuan](https://github.com/eve-atum)
306:   - for finding new and inventive ways to crash our test builds
307:   - for general documentation clean-up
308: - [LaZar00](https://github.com/LaZar00)
309:   - for the Snowboard TMD structures
310: - [ChthonVII](https://github.com/ChthonVII)
311:   - for the R&D needed to match modern display gamuts to the original PSX release
312: 
313: I'm sure I forgot many others. In case you feel you're missing here, feel free to open a PR! I'll be happy to include you because you deserve this.
314: 
315: ## License
316: 
317: FFNx is released under GPLv3 license. You can get a copy of the license here: [COPYING.TXT](COPYING.TXT)
318: 
319: If you paid for FFNx, remember to ask for a refund from the person who sold you a copy. Also make sure you get a copy of the source code (if it was provided as binary only).
320: 
321: If the person who gave you this copy refuses to give you the source code, report it here: https://www.gnu.org/licenses/gpl-violation.html
322: 
323: All rights belong to their respective owners.
</file>

<file path="vcpkg-configuration.json">
 1: {
 2:   "registries": [
 3:     {
 4:       "kind": "filesystem",
 5:       "path": ".vcpkg",
 6:       "packages": [
 7:         "bx",
 8:         "bimg",
 9:         "bgfx",
10:         "hwinfo",
11:         "openpsf",
12:         "soloud",
13:         "vgmstream",
14:         "steamworkssdk"
15:       ]
16:     }
17:   ]
18: }
</file>

<file path="vcpkg.json">
  1: {
  2:   "name": "ffnx",
  3:   "version": "1.23.0",
  4:   "builtin-baseline": "4334d8b4c8916018600212ab4dd4bbdc343065d1",
  5:   "dependencies": [
  6:     "bgfx",
  7:     {
  8:       "name": "ffmpeg",
  9:       "default-features": false,
 10:       "features": [
 11:         "avcodec",
 12:         "avdevice",
 13:         "avfilter",
 14:         "avformat",
 15:         "avresample",
 16:         "postproc",
 17:         "swresample",
 18:         "swscale",
 19:         "amf",
 20:         "nvcodec",
 21:         "opencl",
 22:         "qsv",
 23:         "gpl",
 24:         "version3",
 25:         "dav1d",
 26:         "opus",
 27:         "speex",
 28:         "theora",
 29:         "vorbis",
 30:         "vpx",
 31:         "x264",
 32:         "x265"
 33:       ],
 34:       "platform": "windows"
 35:     },
 36:     "imgui",
 37:     "libpng",
 38:     {
 39:       "name": "directxtex",
 40:       "default-features": false,
 41:       "features": []
 42:     },
 43:     {
 44:       "name": "mimalloc",
 45:       "default-features": false,
 46:       "features": [
 47:         "override",
 48:         "secure"
 49:       ]
 50:     },
 51:     "openpsf",
 52:     "pugixml",
 53:     "soloud",
 54:     "stackwalker",
 55:     "tomlplusplus",
 56:     "vgmstream",
 57:     "steamworkssdk",
 58:     "xxhash",
 59:     "lz4",
 60:     {
 61:       "name": "cpuinfo",
 62:       "default-features": false,
 63:       "features": [
 64:         "tools"
 65:       ]
 66:     },
 67:     "cmakerc",
 68:     "cgltf",
 69:     "hwinfo",
 70:     "cryptopp"
 71:   ],
 72:   "overrides": [
 73:     {
 74:       "name": "bgfx",
 75:       "version": "1.0.0",
 76:       "port-version": 0
 77:     },
 78:     {
 79:       "name": "ffmpeg",
 80:       "version": "7.1.1",
 81:       "port-version": 5
 82:     },
 83:     {
 84:       "name": "imgui",
 85:       "version": "1.91.9",
 86:       "port-version": 0
 87:     },
 88:     {
 89:       "name": "libpng",
 90:       "version": "1.6.50",
 91:       "port-version": 0
 92:     },
 93:     {
 94:       "name": "directxtex",
 95:       "version": "2025-07-10",
 96:       "port-version": 0
 97:     },
 98:     {
 99:       "name": "mimalloc",
100:       "version": "2.2.3",
101:       "port-version": 1
102:     },
103:     {
104:       "name": "openpsf",
105:       "version": "1.3.0",
106:       "port-version": 0
107:     },
108:     {
109:       "name": "pugixml",
110:       "version": "1.15",
111:       "port-version": 0
112:     },
113:     {
114:       "name": "soloud",
115:       "version": "1.0.0",
116:       "port-version": 0
117:     },
118:     {
119:       "name": "stackwalker",
120:       "version": "2023-06-24",
121:       "port-version": 0
122:     },
123:     {
124:       "name": "tomlplusplus",
125:       "version": "3.4.0",
126:       "port-version": 1
127:     },
128:     {
129:       "name": "vgmstream",
130:       "version": "1.0.0",
131:       "port-version": 0
132:     },
133:     {
134:       "name": "steamworkssdk",
135:       "version": "1.23.0",
136:       "port-version": 0
137:     },
138:     {
139:       "name": "xxhash",
140:       "version": "0.8.3",
141:       "port-version": 0
142:     },
143:     {
144:       "name": "lz4",
145:       "version": "1.10.0",
146:       "port-version": 0
147:     },
148:     {
149:       "name": "cpuinfo",
150:       "version": "2022-07-19",
151:       "port-version": 3
152:     },
153:     {
154:       "name": "cmakerc",
155:       "version": "2023-07-24",
156:       "port-version": 0
157:     },
158:     {
159:       "name": "cgltf",
160:       "version": "1.14",
161:       "port-version": 0
162:     },
163:     {
164:       "name": "hwinfo",
165:       "version": "1.0.0",
166:       "port-version": 0
167:     },
168:     {
169:       "name": "cryptopp",
170:       "version": "8.9.0",
171:       "port-version": 1
172:     }
173:   ]
174: }
</file>

</files>
