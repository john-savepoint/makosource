[
  {
    "timestamp": "2025-11-18T13:16:11.292585+00:00",
    "session_id": "81a6348e-ca92-4029-ab5f-e086f86e02ed",
    "prompt": "no you stupid fuck. what are the big files on the mac that are getting transferred you fucking idiot",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-19T02:17:09.656154+00:00",
    "session_id": "81a6348e-ca92-4029-ab5f-e086f86e02ed",
    "prompt": "the copy is comnplete now anyway right?",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-19T16:03:46.008675+00:00",
    "session_id": "354d5663-8cb3-4a75-aead-f8dc7c3a8e91",
    "prompt": "I want you to do 10 Brave searches and 10 separate Firecrawl scrapings. Brave Search has a rate limit of one search per second. You want to research how to make a basic mod for Final Fantasy VII PC 1998 with the Seventh Heaven mod manager. Separately, I also want you to scrape all of the 7th Heaven documentation. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-19T16:14:35.269544+00:00",
    "session_id": "354d5663-8cb3-4a75-aead-f8dc7c3a8e91",
    "prompt": "This is really fucking shit. I didn't ask you to describe 7th Heaven to me. I know what it fucking does. I want to create a mod though for 7th Heaven, but I've never done it before and I want to start off with making a basic mod that does something simple that I can just at least test with. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-19T16:17:21.163686+00:00",
    "session_id": "354d5663-8cb3-4a75-aead-f8dc7c3a8e91",
    "prompt": "I want to change the color of the in-game text. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-19T16:23:26.340576+00:00",
    "session_id": "354d5663-8cb3-4a75-aead-f8dc7c3a8e91",
    "prompt": "All of it. I want you to teach me where the texture applies and where the hex editing applies. I was under the impression that all of the text in the game was referenced from textures, which are really just images, right? So how would a hex code change its color? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-19T16:26:01.276177+00:00",
    "session_id": "354d5663-8cb3-4a75-aead-f8dc7c3a8e91",
    "prompt": "Just learning. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T01:07:05.380445+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/SCRAPED_URLS.md' I want you to look at all of the pending webpages on this list. I'm going to copy and paste from  '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/FINDINGS.md' as it is too big for you to read. \n\n[# Final Fantasy VII Japanese Character Support - Research Findings\n\n**Created**: 2025-11-15 18:56:38 JST (Saturday)\n**Last Modified**: 2025-11-15 21:30:00 JST (Saturday)\n**Version**: 1.3.0\n**Authors**: Research Sessions 1, 2, 3, 4 & Continuation\n**Session-IDs**:\n\n- 1021bc57-9aa2-41fe-baad-a6b89b252744 (initial + resumed + compacted + continued)\n\n---\n\n## Original Document Metadata\n\n# Final Fantasy VII Japanese Character Support - Research Findings\n\n**Created**: 2025-11-15 18:56:38 JST (Saturday)\n**Last Modified**: 2025-11-15 21:30:00 JST (Saturday)\n**Version**: 1.3.0\n**Authors**: Research Sessions 1, 2, 3, 4 & Continuation\n**Session-IDs**:\n\n- 1021bc57-9aa2-41fe-baad-a6b89b252744 (initial + resumed + compacted + continued)\n\n---\n\n---\n\n## Section Index\n\n| #   | Section Title                                                                    | Filename                                                                           | Lines | Size   |\n| --- | -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ----- | ------ |\n| 01  | Executive Summary                                                                | `01_executive_summary.md`                                                          | 11    | 1.3KB  |\n| 02  | Table of Contents                                                                | `02_table_of_contents.md`                                                          | 17    | 0.9KB  |\n| 03  | Session 2 Critical Discoveries                                                   | `03_session_2_critical_discoveries.md`                                             | 197   | 7.7KB  |\n| 04  | Session 3 Breakthrough Discoveries                                               | `04_session_3_breakthrough_discoveries.md`                                         | 348   | 12.0KB |\n| 05  | The Core Technical Problem                                                       | `05_the_core_technical_problem.md`                                                 | 68    | 2.4KB  |\n| 06  | FF7 Text System Architecture                                                     | `06_ff7_text_system_architecture.md`                                               | 71    | 2.1KB  |\n| 07  | Version Differences (Japanese vs English)                                        | `07_version_differences_japanese_vs_english.md`                                    | 41    | 1.6KB  |\n| 08  | Existing Modification Attempts                                                   | `08_existing_modification_attempts.md`                                             | 94    | 3.7KB  |\n| 09  | The qhimm.com Community                                                          | `09_the_qhimmcom_community.md`                                                     | 37    | 1.0KB  |\n| 10  | Available Modding Tools                                                          | `10_available_modding_tools.md`                                                    | 112   | 2.9KB  |\n| 11  | Technical Documentation Available                                                | `11_technical_documentation_available.md`                                          | 56    | 1.4KB  |\n| 12  | Potential Implementation Approaches                                              | `12_potential_implementation_approaches.md`                                        | 96    | 2.6KB  |\n| 13  | Required Modifications                                                           | `13_required_modifications.md`                                                     | 96    | 2.5KB  |\n| 14  | Development Roadmap Considerations                                               | `14_development_roadmap_considerations.md`                                         | 73    | 1.6KB  |\n| 15  | Key Community Contacts                                                           | `15_key_community_contacts.md`                                                     | 31    | 0.8KB  |\n| 16  | References and Resources                                                         | `16_references_and_resources.md`                                                   | 66    | 1.6KB  |\n| 17  | Next Steps                                                                       | `17_next_steps.md`                                                                 | 49    | 1.2KB  |\n| 18  | Conclusion                                                                       | `18_conclusion.md`                                                                 | 17    | 0.8KB  |\n| 19  | Session 5: Q-Gears Engine Analysis & Tool Chain Validation (2025-11-15 23:30)    | `19_session_5_q_gears_engine_analysis_tool_chain_validation_2025_11_15_2330.md`    | 394   | 13.7KB |\n| 20  | Session 6: CJK Font Atlas Constraints & Tool Chain Completion (2025-11-15 23:58) | `20_session_6_cjk_font_atlas_constraints_tool_chain_completion_2025_11_15_2358.md` | 132   | 5.5KB  |\n| 21  | Session 6 Update: CRITICAL ASSET ACQUISITION (2025-11-16 10:49)                  | `21_session_6_update_critical_asset_acquisition_2025_11_16_1049.md`                | 56    | 1.9KB  |\n| 22  | Enhanced Feature Requirements (User Vision - 2025-11-16 17:30)                   | `22_enhanced_feature_requirements_user_vision_2025_11_16_1730.md`                  | 231   | 6.9KB  |\n| 23  | LATE SESSION 6 DISCOVERY: MULTI-LANGUAGE SUPPORT (2025-11-16 18:17)              | `23_late_session_6_discovery_multi_language_support_2025_11_16_1817.md`            | 37    | 1.3KB  |\n| 24  | SESSION 7: DIRECTORY STRUCTURE ANALYSIS (2025-11-17 11:41:11 JST Monday)         | `24_session_7_directory_structure_analysis_2025_11_17_114111_jst_monday.md`        | 475   | 19.7KB |\n| 25  | SESSION 8: DEEP DIVE INTO CHARACTER ENCODING (2025-11-17 15:20 JST)              | `25_session_8_deep_dive_into_character_encoding_2025_11_17_1520_jst.md`            | 238   | 8.0KB  |\n| 26  | CUMULATIVE RESEARCH STATISTICS                                                   | `26_cumulative_research_statistics.md`                                             | 27    | 0.9KB  |\n| 27  | BREAKTHROUGH: FIRST-EVER FF7 JAPANESE CHARACTER TABLE CREATED                    | `27_breakthrough_first_ever_ff7_japanese_character_table_created.md`               | 93    | 3.0KB  |\n| 28  | CUMULATIVE RESEARCH STATISTICS (Updated)                                         | `28_cumulative_research_statistics_updated.md`                                     | 13    | 0.4KB  |\n| 29  | SESSION 9 UPDATE: ACCURATE CHARACTER TABLE (2025-11-17 19:30 JST)                | `29_session_9_update_accurate_character_table_2025_11_17_1930_jst.md`              | 59    | 2.2KB  |\n\n---\n\n## Quick Navigation Guide\n\n### By Topic\n\n**Research Sessions**:\n\n- [Session 2 Critical Discoveries](03_session_2_critical_discoveries.md)\n- [Session 3 Breakthrough Discoveries](04_session_3_breakthrough_discoveries.md)\n- [Session 5: Q-Gears Engine Analysis & Tool Chain Validation (2025-11-15 23:30)](19_session_5_q_gears_engine_analysis_tool_chain_validation_2025_11_15_2330.md)\n- [Session 6: CJK Font Atlas Constraints & Tool Chain Completion (2025-11-15 23:58)](20_session_6_cjk_font_atlas_constraints_tool_chain_completion_2025_11_15_2358.md)\n- [Session 6 Update: CRITICAL ASSET ACQUISITION (2025-11-16 10:49)](21_session_6_update_critical_asset_acquisition_2025_11_16_1049.md)\n- [LATE SESSION 6 DISCOVERY: MULTI-LANGUAGE SUPPORT (2025-11-16 18:17)](23_late_session_6_discovery_multi_language_support_2025_11_16_1817.md)\n- [SESSION 7: DIRECTORY STRUCTURE ANALYSIS (2025-11-17 11:41:11 JST Monday)](24_session_7_directory_structure_analysis_2025_11_17_114111_jst_monday.md)\n- [SESSION 8: DEEP DIVE INTO CHARACTER ENCODING (2025-11-17 15:20 JST)](25_session_8_deep_dive_into_character_encoding_2025_11_17_1520_jst.md)\n- [SESSION 9 UPDATE: ACCURATE CHARACTER TABLE (2025-11-17 19:30 JST)](29_session_9_update_accurate_character_table_2025_11_17_1930_jst.md)\n\n**Technical Analysis**:\n\n- [Executive Summary](01_executive_summary.md)\n- [Table of Contents](02_table_of_contents.md)\n- [The Core Technical Problem](05_the_core_technical_problem.md)\n- [FF7 Text System Architecture](06_ff7_text_system_architecture.md)\n- [Version Differences (Japanese vs English)](07_version_differences_japanese_vs_english.md)\n- [Next Steps](17_next_steps.md)\n- [Conclusion](18_conclusion.md)\n- [Enhanced Feature Requirements (User Vision - 2025-11-16 17:30)](22_enhanced_feature_requirements_user_vision_2025_11_16_1730.md)\n- [CUMULATIVE RESEARCH STATISTICS](26_cumulative_research_statistics.md)\n- [BREAKTHROUGH: FIRST-EVER FF7 JAPANESE CHARACTER TABLE CREATED](27_breakthrough_first_ever_ff7_japanese_character_table_created.md)\n- [CUMULATIVE RESEARCH STATISTICS (Updated)](28_cumulative_research_statistics_updated.md)\n\n**Tools & Resources**:\n\n- [Available Modding Tools](10_available_modding_tools.md)\n- [Technical Documentation Available](11_technical_documentation_available.md)\n- [References and Resources](16_references_and_resources.md)\n\n**Implementation**:\n\n- [Existing Modification Attempts](08_existing_modification_attempts.md)\n- [Potential Implementation Approaches](12_potential_implementation_approaches.md)\n- [Required Modifications](13_required_modifications.md)\n- [Development Roadmap Considerations](14_development_roadmap_considerations.md)\n\n**Community**:\n\n- [The qhimm.com Community](09_the_qhimmcom_community.md)\n- [Key Community Contacts](15_key_community_contacts.md)\n\n---\n\n## Usage Notes\n\n- Each section file is self-contained with metadata\n- Files are numbered for sequential reading\n- Cross-references between sections maintained\n- AI agents can load specific sections as needed\n- Human readers can jump to relevant topics quickly\n\nThis document compiles comprehensive research findings on the technical challenges, existing attempts, and potential approaches for enabling Japanese character display in the 1998 PC version of Final Fantasy VII. The goal is to modify the English PC version to display Japanese text, leveraging the existing FF7 modding ecosystem while working within the constraints of the game's architecture.\n\n**Key Finding (Session 1)**: Displaying Japanese characters in FF7 PC requires fundamental modifications to the character encoding system, font rendering pipeline, and graphics driver - not just text file replacements.\n\n**Critical New Discovery (Session 2)**: FF8 successfully implemented font replacement through **texture-based injection** using Tonberry tool. This proven technique could be adapted for FF7, potentially avoiding the need for driver-level modifications. Text editing tools (Makou Reactor, touphScript) already support Japanese - the blocker is purely font RENDERING, not text editing.\n\n**BREAKTHROUGH (Session 3)**: FFNx already has texture override system (`mod_path`) that works for FF7. BGFX library uses **TrueType fonts at runtime** (not bitmap textures). Combining FFNx's texture replacement capability with runtime TrueType loading could enable Japanese fonts WITHOUT modifying FFNx driver source code.\n\n---\n\n1. [Session 2 Critical Discoveries](#session-2-critical-discoveries) **NEW**\n2. [The Core Technical Problem](#the-core-technical-problem)\n3. [FF7 Text System Architecture](#ff7-text-system-architecture)\n4. [Version Differences (Japanese vs English)](#version-differences-japanese-vs-english)\n5. [Existing Modification Attempts](#existing-modification-attempts)\n6. [The qhimm.com Community](#the-qhimmcom-community)\n7. [Available Modding Tools](#available-modding-tools)\n8. [Technical Documentation Available](#technical-documentation-available)\n9. [Potential Implementation Approaches](#potential-implementation-approaches)\n10. [Required Modifications](#required-modifications)\n11. [Development Roadmap Considerations](#development-roadmap-considerations)\n12. [Key Community Contacts](#key-community-contacts)\n13. [References and Resources](#references-and-resources)\n\n---\n\n**Research Date**: 2025-11-15 19:30 JST\n**Session**: 1021bc57-9aa2-41fe-baad-a6b89b252744 (resumed)\n**URLs Analyzed**: 7 new sources (FFNx docs, source code, qhimm forums, FF8 mods)\n\n### Discovery #1: FF8 Proves Texture-Based Font Replacement Works\n\n**Source**: https://forums.qhimm.com/index.php?topic=16355.0\n\nFF8 PC successfully replaced its font system using **texture injection** rather than driver modification:\n\n**Method**:\n\n1. **Tonberry Tool** - Texture injection system for FF8\n2. **Texture Files** - Font glyphs stored in `textures/Sy/` folder\n3. **Hash Mapping** - Excel spreadsheet maps texture hashes to font characters\n4. **No Driver Changes** - Works on top of Steam version without modifying executables\n\n**Workflow**:\n\n```text\n1. Create font texture files (PNG format)\n2. Place in textures/Sy/ folder\n3. Create/update hashmap Excel file\n4. Disable Steam overlay\n5. Launch game - Tonberry injects textures at runtime\n```\n\n**Versions Released**:\n\n- Version 1 (2015) - Initial release\n- Version 2 (2017) - Bug fixes for punctuation glitches\n- Version 3 (2019) - Final polish, improved 'W' character\n\n**Compatibility**: Works with SeeD Reborn mod (shares same hashmap system)\n\n**Critical Implication**: **Same texture injection approach could work for FF7**. If Tonberry-equivalent exists for FF7 (or can be created), Japanese fonts could be loaded without modifying FFNx driver.\n\n---\n\n### Discovery #2: FFNx Font System Architecture Confirmed\n\n**Sources**:\n\n- https://raw.githubusercontent.com/julianxhokaxhiu/FFNx/master/misc/FFNx.toml\n- https://raw.githubusercontent.com/julianxhokaxhiu/FFNx/master/src/renderer.cpp\n\n**FFNx.toml Analysis**:\n\n- **NO font configuration options exist**\n- Only generic texture settings: `mod_path`, `mod_ext`, `save_textures`\n- `enable_ntscj_gamut_mode` for Japanese TV color simulation (cosmetic only)\n- **Conclusion**: Font system is **hardcoded** in driver source, not user-configurable\n\n**renderer.cpp Analysis**:\n\n- Extensive texture management functions (`createTexture()`, `createTextureHandle()`, `createTextureLibPng()`)\n- Text rendering: `printText()` function uses `bgfx::dbgTextPrintf` (BGFX library call)\n- **NO font loading functionality in this file**\n- **NO Japanese character handling**\n- **NO font-specific texture management**\n\n**Critical Finding**: Font rendering is **delegated to BGFX library**, not custom implementation in renderer.cpp. Font-specific code must be in different source files.\n\n**Implication**: FFNx driver modification would require:\n\n1. Finding font-specific source files (not renderer.cpp)\n2. Understanding BGFX library font system\n3. Implementing multi-texture font loading\n4. Character encoding expansion\n\n---\n\n### Discovery #3: Text Editing Tools Already Support Japanese\n\n**Source**: http://forums.qhimm.com/index.php?topic=9658.0 (Makou Reactor thread)\n\n**Historical Timeline**:\n\n- **2010-05-13**: Gemini asks \"What about adding support for Japanese versions?\"\n- **2010-05-13**: myst6re (developer) responds: \"I'll think about it I just need the text encoding, or menu text texture.\"\n- **2010-05-13**: Gemini provides complete Japanese character encoding table\n- **2010-05-13**: myst6re confirms: \"Done, I have many things to add before next release.\"\n\n**Current Status**:\n\n- Makou Reactor 2.1.0 (latest) **fully supports Japanese character encoding**\n- Can edit Japanese text in field files (flevel.lgp)\n- Can save Japanese characters to game files\n- **BUT**: Game cannot display them (gibberish output)\n\n**touphScript Status** (from Session 1):\n\n- Dumps all FF7 text to UTF-8 files\n- Re-encodes back to FF Text format\n- **Limitation**: Single-byte encoding only (by design of FF Text format)\n\n**Critical Conclusion**: **Text editing is NOT the blocker**. Tools can handle Japanese input. The blocker is purely **font RENDERING** in the game engine.\n\n---\n\n### Discovery #4: FFNx Japanese Support Status\n\n**Source**: https://github.com/julianxhokaxhiu/FFNx/blob/master/docs/how_to_install.md\n\n**Official Statement** (FFNx v1.x documentation):\n\n> \"Japanese support is currently work in progress. The game starts fine but font is not rendering properly and battles do crash sometimes.\"\n\n**Supported Versions**:\n\n- 1998 Eidos Release\n- 2013 Steam Release\n- **2013 eStore Release (Japanese)** - May 16, 2013 release\n- Android Release\n\n**Japanese eStore Version**:\n\n- Contains `menu_ja.lgp` with 6 font textures\n- Uses **completely customized AF3DN.P driver**\n- Driver is **larger** than Steam version\n- No source code available from Square Enix\n\n**Availability Status (Session 4 Update - 2025-11-15)**:\n\n- **PRODUCT DELISTED**: eStore page (SEDL-1010) returns 404 error\n- **No longer purchasable** from official Square Enix Japan store\n- May still be accessible to:\n  - FFNx developers (have access for testing per Issue #39)\n  - Community members who purchased before delisting\n  - Requires alternative acquisition strategy\n\n**Current Status**: FFNx can theoretically load Japanese version files, but:\n\n- Font rendering broken\n- Battle system crashes\n- No active development on Issue #39 since 2020\n\n---\n\n### Discovery #5: Successful Retranslation Workflow Example\n\n**Source**: https://www.shinraarchaeology.com/retransmod.html\n\n**Shinra Archaeology Cut Mod**:\n\n- Full retranslation of FF7 to modern English\n- Compatible with 7th Heaven mod manager\n- ~500MB .IRO file format\n- Restores cut content from original files\n\n**Tools Used**:\n\n- Makou Reactor (field editing)\n- WallMarket (KERNEL.BIN editing)\n- ProudClod (scene.bin editing)\n- Black Chocobo (save editing)\n- KimeraCS, Scarlet (unknown purposes)\n\n**Methodology**:\n\n- All text modifications done **within FF Text encoding limitations**\n- No font changes attempted\n- Uses existing single-byte character set\n- Proves comprehensive text modding is possible without touching font system\n\n**Implication**: Text modding infrastructure is **mature and proven**. Once font rendering is solved, implementing Japanese text will use these same tools.\n\n---\n\n### Revised Understanding: The Three-Layer Problem\n\nBased on Session 2 findings, the Japanese support problem has **three distinct layers**:\n\n**Layer 1: Text Editing** \u2705 **SOLVED**\n\n- Makou Reactor supports Japanese encoding (since 2010)\n- touphScript can dump/restore text (UTF-8 capable)\n- Proven workflow from Shinra Archaeology mod\n- **Status**: Infrastructure exists and works\n\n**Layer 2: Font Rendering** \u26a0\ufe0f **PRIMARY BLOCKER**\n\n- English version has 1 font texture set\n- Japanese needs 6 font texture sets\n- No loading mechanism for multiple font sets\n- Font system hardcoded in driver/executable\n- **Status**: This is the core problem to solve\n\n**Layer 3: Character Encoding** \u23f3 **SECONDARY BLOCKER**\n\n- FF Text format: single-byte, 256 character max\n- Japanese needs: 2,000+ characters (double-byte)\n- Engine assumes one byte = one character\n- **Status**: Can be solved AFTER font rendering works\n\n### Recommended Next Steps (Based on Session 2)\n\n**Immediate Priority**:\n\n1. **Investigate Tonberry Tool** - Understand texture injection mechanism for FF8\n2. **Check for FF7 equivalent** - Does FF7 have a Tonberry-like tool?\n3. **Test texture override** - Can FFNx `mod_path` load custom font textures?\n4. **Analyze hashmap system** - How does FF8 map characters to texture files?\n\n**Medium Priority**: 5. **Find FFNx font source files** - Not in renderer.cpp, where is it? 6. **Research BGFX font system** - How does BGFX handle fonts internally? 7. **Acquire Japanese eStore version** - Extract `menu_ja.lgp` for analysis 8. **Contact FFNx developers** - Comment on Issue #39 with findings\n\n**Lower Priority** (after proof-of-concept): 9. Design character encoding extension (single\u2192double byte) 10. Implement touphScript extension for Japanese 11. Create Japanese text file conversions 12. Full game testing and debugging\n\n---\n\n**Research Date**: 2025-11-15 20:00 JST\n**Session**: 1021bc57-9aa2-41fe-baad-a6b89b252744 (compacted)\n**URLs Analyzed**: 5 new sources (Tonberry internals, BGFX examples, FFNx source code)\n\n### Discovery #1: Tonberry's Runtime Texture Injection Architecture\n\n**Sources**:\n\n- https://forums.qhimm.com/index.php?topic=15945.0 (Tonberry Enhanced thread)\n- Community analysis of Tonberry 2.04 implementation\n\n**How Tonberry Works**:\n\n**Interception Mechanism**:\n\n- Hooks `UnlockRect()` DirectX function to intercept texture loading\n- NO modification of game executable or driver required\n- Runtime injection only - fully reversible\n\n**Hashmap System**:\n\n```text\nDirectory Structure:\n[FF8]/tonberry/hashmap/*.csv  \u2192 Hash-to-texture mapping files\n[FF8]/textures/**/*.png        \u2192 Replacement texture PNG files\n[FF8]/tonberry/prefs.txt       \u2192 Configuration (cache size, etc.)\n```\n\n**CSV Format**:\n\n```csv\ntexture_name,hash_value\nsysfld00_13,8637763346649579509\nmenu_icon_02,2847593920174638291\n```\n\n**Special Features**:\n\n- **Persistent textures**: Prefix with `!` to keep in cache permanently\n- **Disabled textures**: Prefix with `*` to exclude from loading\n- **Plug-and-play mods**: Move CSV to `disabled/` folder to turn off mod\n- **Cache management**: Configurable size (max 250 for non-LAA builds)\n\n**Performance Characteristics**:\n\n- `UnlockRect()` identified as primary bottleneck\n- Alternative hashing algorithms tested but minimal improvement\n- Cache eviction needed for 32-bit memory constraints\n\n**Critical Implication**: **Runtime texture injection WORKS** without source code modification. If FFNx has similar texture override, Japanese fonts could be injected the same way.\n\n---\n\n### Discovery #2: FFNx Already Has Texture Override System\n\n**Sources**:\n\n- https://github.com/julianxhokaxhiu/FFNx/issues/29 (FF8 texture override issue)\n- https://github.com/julianxhokaxhiu/FFNx (repository overview)\n- FFNx.toml configuration file\n\n**FFNx Texture Replacement Architecture**:\n\n**Configuration (FFNx.toml)**:\n\n```toml\n# Texture override path\nmod_path = \"mods/Textures\"\n\n# Supported formats\nmod_ext = [\"dds\", \"png\"]\n\n# Additional options\nshow_missing_textures = false\nsave_textures = false  # Dump internal textures for modding\n```\n\n**Key Quote from Issue #29**:\n\n> \"Like we do on FF7, also on FF8 we need to provide a way to override textures around the game.\"\n\n**Implication**: **FF7 texture override ALREADY EXISTS in FFNx** (mentioned as reference point for FF8 implementation)\n\n**Supported Texture Modules** (confirmed working):\n\n- Field backgrounds\n- Battle textures\n- Magic effects\n- World map\n- Menu elements (potentially including fonts?)\n\n**Differences from Tonberry**:\n\n- **Path-based**, not hash-based (simpler but requires knowing exact names)\n- **DDS preferred**, PNG fallback (higher quality, smaller memory)\n- **override_path**: Separate data directory override layer\n\n**Critical Finding**: FFNx ALREADY can replace game textures. The question is: can it replace font textures specifically?\n\n---\n\n### Discovery #3: BGFX Font System Uses TrueType, Not Bitmaps\n\n**Sources**:\n\n- https://github.com/bkaradzic/bgfx/blob/master/examples/10-font/font.cpp\n- BGFX font manager implementation\n\n**BGFX Font Architecture**:\n\n**Runtime TrueType Loading**:\n\n```cpp\n// 1. Create font manager\nFontManager* m_fontManager = new FontManager(512);  // 512 = atlas size\nTextBufferManager* m_textBufferManager = new TextBufferManager(m_fontManager);\n\n// 2. Load TrueType file\nTrueTypeHandle ttf = loadTtf(m_fontManager, \"font/example.ttf\");\n\n// 3. Generate font at specific size\nFontHandle font = m_fontManager->createFontByPixelSize(ttf, 0, 32);\n\n// 4. Preload glyphs (optional optimization)\nm_fontManager->preloadGlyph(font, L\"abcdefghijklmnopqrstuvwxyz\");\nm_fontManager->preloadGlyph(font, L\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\n// 5. Can destroy TTF if all glyphs preloaded\nm_fontManager->destroyTtf(ttf);  // Limits to preloaded glyphs\n// OR keep TTF loaded for dynamic glyph generation\n```\n\n**Key Characteristics**:\n\n- **Dynamic glyph generation**: If TTF remains loaded, glyphs generated on-demand\n- **Font atlas**: Glyphs rasterized to texture atlas automatically\n- **Multiple fonts**: Can load multiple TTF files simultaneously\n- **Buffer types**: Static (immutable) and Transient (updated per-frame)\n- **Styled text**: Background, underline, overline, strike-through via TextBufferManager\n\n**Critical Revelation**: BGFX does NOT use bitmap font textures (like `usfont.png`). It loads **TrueType fonts** and generates glyph textures at runtime.\n\n**Implication for FF7**: If FFNx uses BGFX for font rendering (which it does for debug UI), the same system COULD be used for game fonts. Japanese TrueType fonts could be loaded via configuration.\n\n---\n\n### Discovery #4: FFNx Font Rendering Uses ImGui + BGFX (Debug UI Only)\n\n**Sources**:\n\n- https://raw.githubusercontent.com/julianxhokaxhiu/FFNx/master/src/overlay.cpp\n- FFNx source code analysis\n\n**FFNx Debug Overlay Architecture**:\n\n**Font Atlas Generation**:\n\n```cpp\n// ImGui generates font atlas texture\nImFontAtlas* fonts = ImGui::GetIO().Fonts;\nunsigned char* pixels;\nint width, height;\nfonts->GetTexDataAsRGBA32(&pixels, &width, &height);\n\n// Upload to BGFX as texture\nbgfx::TextureHandle m_texture = bgfx::createTexture2D(\n    width, height, false, 1,\n    bgfx::TextureFormat::BGRA8, 0,\n    bgfx::copy(pixels, width * height * 4)\n);\n```\n\n**Text Rendering**:\n\n- ImGui generates vertex/index buffers for text glyphs\n- BGFX shader samples font atlas texture\n- Scissor rects for clipping\n- No explicit TrueType file references (ImGui handles internally)\n\n**Critical Limitation**: This is ONLY for FFNx's debug overlay (DevTools menu, memory debugger, etc.). **Game fonts are handled separately**.\n\n**Source Code Analysis**:\n\n- **No font.cpp/font.h** in FFNx src directory\n- **No menu_us.lgp loading code** found in FFNx source\n- **Game fonts likely handled by original executable** or through BGFX at a different level\n\n**Key Question**: If FFNx doesn't have game font code, where do game fonts come from?\n\n**Possible Answers**:\n\n1. **Original executable** loads `usfont.png` from `menu_us.lgp` (legacy code path)\n2. **BGFX library** handles it automatically via renderer backend\n3. **FFNx hooks** the loading but doesn't have dedicated source files for it\n\n---\n\n### Revised Understanding: The Font Loading Mystery\n\nBased on Session 3 research, we now understand:\n\n**What We Know**:\n\n- \u2705 BGFX **CAN** load TrueType fonts at runtime\n- \u2705 FFNx **DOES** use BGFX for rendering\n- \u2705 FFNx **HAS** texture override system (`mod_path`)\n- \u2705 Tonberry **PROVES** runtime texture injection works for Square Enix games\n- \u2705 Text editing tools **SUPPORT** Japanese encoding\n\n**What Remains Unclear**:\n\n- \u2753 Does FF7 use bitmap fonts (`usfont.png`) or TrueType fonts?\n- \u2753 Where in FFNx (or game executable) are game fonts loaded?\n- \u2753 Can FFNx's `mod_path` override font textures specifically?\n- \u2753 If fonts are bitmaps, can they be replaced via texture override?\n- \u2753 If fonts are TrueType, can we configure FFNx to load Japanese TTF?\n\n---\n\n### Potential Implementation Paths (Updated Session 3)\n\nBased on new discoveries, here are the refined approaches:\n\n**Path A: Texture Override (If Fonts Are Bitmaps)**\n\n**Concept**:\n\n- If FF7 uses bitmap font textures (like `usfont.png` from `menu_us.lgp`)\n- Use FFNx's existing `mod_path` system to override with Japanese font textures\n- Create 6 Japanese font texture files (matching Japanese version's `jafont_X.tex`)\n\n**Steps**:\n\n1. Extract `usfont.png` from `menu_us.lgp` (find current texture names)\n2. Create Japanese font texture replacements (6 sets for full kanji coverage)\n3. Place in `mod_path` directory with correct naming\n4. Configure FFNx.toml to load textures\n5. Test if game recognizes replaced fonts\n\n**Advantages**:\n\n- Uses FFNx's existing, proven texture override system\n- NO source code modification required\n- Fully reversible (remove textures to revert)\n- Same approach as Tonberry for FF8\n\n**Challenges**:\n\n- Need exact texture naming scheme\n- Character encoding still single-byte (can only display 256 characters)\n- Would need to solve character\u2192texture mapping (which of 6 textures?)\n\n**Feasibility**: HIGH (if fonts are indeed bitmap textures)\n\n---\n\n**Path B: Runtime TrueType Loading (If FFNx Can Be Extended)**\n\n**Concept**:\n\n- Add configuration to FFNx.toml to load Japanese TrueType fonts\n- Leverage BGFX's existing `FontManager` + `createFontByPixelSize()`\n- Generate Japanese glyphs at runtime\n\n**Configuration Example** (hypothetical):\n\n```toml\n[font]\n# Override game font with TrueType file\ngame_font_path = \"mods/Fonts/japanese.ttf\"\nfont_size = 16\npreload_japanese = true  # Preload common kanji\n```\n\n**Implementation**:\n\n```cpp\n// In FFNx initialization\nTrueTypeHandle jpFont = loadTtf(fontManager, config.game_font_path);\nFontHandle gameFont = fontManager->createFontByPixelSize(jpFont, 0, 16);\n\n// Preload Japanese character sets\nfontManager->preloadGlyph(gameFont, L\"\u3042\u3044\u3046\u3048\u304a...\"); // Hiragana\nfontManager->preloadGlyph(gameFont, L\"\u30a2\u30a4\u30a6\u30a8\u30aa...\"); // Katakana\nfontManager->preloadGlyph(gameFont, L\"\u4e00\u4e8c\u4e09\u56db\u4e94...\"); // Common kanji\n```\n\n**Advantages**:\n\n- Uses BGFX's proven TrueType system\n- Scalable fonts (can render any size)\n- Full Unicode support (can display all Japanese characters)\n- Dynamic glyph generation (don't need to preload all 2,000+ kanji)\n\n**Challenges**:\n\n- **Requires FFNx source code modification** (adding configuration parsing + font loading)\n- Character encoding still needs double-byte support\n- Game executable might hard-code bitmap font assumptions\n\n**Feasibility**: MEDIUM (requires collaboration with FFNx developers)\n\n---\n\n**Path C: Hybrid Approach (Most Practical)**\n\n**Concept**:\n\n1. **Phase 1**: Test texture override for current bitmap fonts\n2. **Phase 2**: If successful, contact FFNx developers about TrueType support\n3. **Phase 3**: Implement character encoding extension separately\n\n**Why This Works**:\n\n- Validates texture override concept first (low risk, no code changes)\n- Gathers real data about font loading mechanism\n- Provides proof-of-concept for FFNx collaboration discussion\n- Separates font rendering from character encoding (can solve incrementally)\n\n**Feasibility**: HIGHEST (pragmatic, step-by-step approach)\n\n---\n\n### Immediate Next Steps (Revised Based on Session 3)\n\n**PRIORITY 1: Validate Texture Override Concept**\n\n1. **Extract current FF7 font textures**:\n\n   - Use 7th Heaven or LGP tools to extract `menu_us.lgp`\n   - Identify font texture files (likely `usfont.png` or similar)\n   - Document exact file names and formats\n\n2. **Test FFNx texture override**:\n\n   - Create dummy replacement texture (different color to verify loading)\n   - Place in `mod_path` directory\n   - Launch game and verify texture loads\n   - Document which texture names work\n\n3. **Acquire Japanese eStore version** ~~(if accessible)~~ **UPDATE (Session 4)**:\n   - **STATUS**: Japanese eStore version (SEDL-1010) is **NO LONGER AVAILABLE FOR PURCHASE**\n   - Product page returns 404 error as of 2025-11-15\n   - **Alternative approach**:\n     - Contact FFNx developers (they reference having access in Issue #39)\n     - Request `menu_ja.lgp` extraction from community members who own it\n     - Collaborate with FFNx team for font file analysis\n\n**PRIORITY 2: Investigate Font Loading Mechanism**\n\n4. **Search FFNx source for LGP loading**:\n\n   - Look for `menu_us.lgp` references in source code\n   - Find texture loading hooks\n   - Understand how `mod_path` override works internally\n\n5. **Test BGFX font capabilities**:\n   - Compile BGFX font example (examples/10-font)\n   - Load Japanese TrueType font\n   - Verify Japanese character rendering works\n\n**PRIORITY 3: Contact FFNx Developers**\n\n6. **Comment on Issue #39** with findings:\n   - Share Session 1-3 research discoveries\n   - Present Tonberry comparison analysis\n   - Propose BGFX TrueType font loading approach\n   - Ask about texture override for fonts\n\n**PRIORITY 4: Character Encoding (Deferred)**\n\n7. This remains a secondary problem after font rendering is solved\n8. Can be tackled via touphScript extension or game executable patching\n\n---\n\n**Document Status**: Active Research\n**Next Update**: After texture override validation tests\n**Maintainer**: Project Team\n\n---\n\n### Character Encoding Incompatibility\n\n**English Version**:\n\n- Uses \"FF Text\" encoding format\n- Single-byte character system\n- ASCII values offset by 0x20\n- Supports ~256 total characters\n- Character table fully documented at: https://ff7-mods.github.io/ff7-flat-wiki/FF7/Text_encoding.html\n\n**Japanese Requirements**:\n\n- Requires minimum **1,945 J\u014dy\u014d kanji + hiragana + katakana**\n- Necessitates double-byte (multi-byte) character encoding\n- Cannot fit into existing single-byte architecture\n\n### Font Texture Space Limitations\n\n**English PC Version** (`menu_us.lgp`):\n\n- **CONFIRMED FONT FILES** (Session 4 - qhimm Wiki):\n  - High-resolution: `USFONT_H.TEX`, `USFONT_A_H.TEX`, `USFONT_B_H.TEX`\n  - Low-resolution: `USFONT_L.TEX`, `USFONT_A_L.TEX`, `USFONT_B_L.TEX`\n- Located at offset 0x2754 in WINDOW.BIN (PSX), MENU_US.LGP (PC)\n- Character spacing defined in `window.bin`\n- Total texture space: ~1 font set worth of glyphs (3 texture variants)\n\n**Japanese PC Version** (`menu_ja.lgp` - eStore only):\n\n- Six separate font texture files:\n  - `jafont_1.tex`\n  - `jafont_2.tex`\n  - `jafont_3.tex`\n  - `jafont_4.tex`\n  - `jafont_5.tex`\n  - `jafont_6.tex`\n- Requires 6x the texture memory\n- **English version has no loading mechanism for multiple font sets**\n\n**PlayStation Japanese Version**:\n\n- Used dynamic kanji loading system\n- `window.bin` contains large blank space below text area (documented in qhimm Wiki)\n- Quote: \"The large blank spot under the menu text is for the Japanese characters that were removed in the non-Japanese version of the game.\"\n- Field files specified which kanji glyphs to load per scene\n- System not ported to PC\n\n### System Architecture Constraints\n\nThe text rendering system is hardcoded across multiple components:\n\n1. **Game Executable** (`ff7.exe` / `ff7_en.exe`)\n\n   - Text rendering routines\n   - Character encoding/decoding logic\n   - Font texture loading\n   - Window sizing calculations\n   - Menu text and Lv4 Limit dialogue\n\n2. **Graphics Driver** (`AF3DN.P` or modern `FFNx`)\n\n   - Font texture injection\n   - Glyph rendering pipeline\n   - Texture memory management\n\n3. **Data Files** (all use FF Text encoding):\n   - `flevel.lgp` - Field dialogue and scripts\n   - `KERNEL.BIN` - Menu data, character names\n   - `kernel2.bin` - Item names and descriptions\n   - `scene.bin` - Battle dialogue, enemy names\n   - `world_us.lgp` - World map dialogue\n\n---\n\n### FF Text Encoding Format\n\nFull specification: https://qhimm-modding.fandom.com/wiki/FF7/FF_Text\n\n**Character Mapping**:\n\n```\nOffset by 0x20 from ASCII\n0x00-0x5F: Standard ASCII characters (space through ~)\n0x60-0xBF: Extended Latin characters (\u00e0\u00e1\u00e2\u00e3 etc.)\n0xC0-0xD3: Special symbols and box-drawing characters\n0xD4-0xDF: Produce graphical errors (unused)\n0xE0-0xFF: Control codes and special functions\n```\n\n**Control Codes**:\n\n- `{CLOUD}`, `{BARRET}`, etc. - Character name variables\n- `{GRAY}`, `{BLUE}`, `{RED}`, etc. - Text colors\n- `{CHOICE}` - Menu selection indent\n- `{OK}` - Wait for confirmation\n- `{NEW}` - Clear window and continue\n- `{WAIT x}` - Delay by x frames\n- `FE D2-DB` - Color function opcodes\n\n### Text Storage Locations\n\n**Field Scripts** (`flevel.lgp`):\n\n- LZS compressed field files\n- Section 1 contains script & dialog\n- Text referenced by opcodes in field script\n- Window parameters (x, y, width, height) stored with text\n\n**Kernel Data** (`KERNEL.BIN`):\n\n- BIN-GZIP archive format\n- 27 sections total\n- Sections 1-9: Binary data\n- Sections 10-27: Text data (FF Text encoding)\n- Full structure documented\n\n**Battle Text** (`scene.bin`):\n\n- 256 separate battle scene files\n- Enemy names (3 per file)\n- Attack names (32 per file)\n- AI dialogue text\n- Scene lookup table in KERNEL.BIN\n\n**Menu Text** (`kernel2.bin` - PC only):\n\n- LZS compressed\n- Sections 10-27 from KERNEL.BIN ungzipped and concatenated\n- Maximum size: 27KB (27,648 bytes) uncompressed\n- Item names, descriptions, equipment text\n\n### Font Rendering Pipeline\n\n**Current English System**:\n\n1. Text opcodes trigger text rendering\n2. Engine looks up character in FF Text table\n3. Single-byte value used as index into font texture\n4. Character spacing read from `window.bin`\n5. Glyph rendered from `usfont.png`\n\n**Required Japanese System**:\n\n1. Text opcodes trigger text rendering\n2. Engine parses double-byte character value\n3. Determine which of 6 font textures contains glyph\n4. Calculate offset within that texture\n5. Read spacing data (proportional fonts)\n6. Render glyph from appropriate `jafont_X.tex`\n\n---\n\n### Version History\n\n**Abbreviations**:\n\n- **JORG**: Japanese Original (PS1, Jan 31, 1997) - version 1.0\n- **Post-JORG**: All versions after JORG - version 1.1\n- **JINT**: FF7 International (Japan PS1, Oct 2, 1997)\n- **NTSC-US**: North American PS1 (Sep 7, 1997)\n- **PAL**: European PS1 (Nov 17, 1997) - runs at 50Hz vs 60Hz\n- **PC98**: Original PC port (May 31, 1998 US, June 25, 1998 EU)\n- **PC2012**: Digital PC re-release (Aug 14, 2012)\n- **JPC**: Japanese PC port (May 16, 2013) - eStore only, never physical release\n\nSource: https://thelifestream.net/ffvii-the-original/ffvii-version-guide/\n\n### Critical Differences\n\n**Japanese PS1 Original vs PC**:\n\n- PS1 used `window.bin` with dynamic kanji loading\n- PC version eliminated this system entirely\n- Japanese PC (JPC) required custom driver modifications\n\n**English PC vs Japanese PC (eStore)**:\n\n- English: Single `menu_us.lgp` with one font set\n- Japanese: `menu_ja.lgp` with six `jafont_X.tex` files\n- Japanese: **Completely customized AF3DN.P driver** to inject fonts\n- No cross-compatibility - architecturally different\n\n**File Format Differences**:\n\n| Feature     | PS1             | PC98                  | PC2012                     |\n| ----------- | --------------- | --------------------- | -------------------------- |\n| Music       | PSX audio       | MIDI                  | OGG (later patched to PSX) |\n| Field Files | .DAT (LZS)      | .LGP archive          | .LGP archive               |\n| Background  | .MIM (LZS)      | In FLEVEL.LGP         | In FLEVEL.LGP              |\n| Models      | .BSX (LZS)      | In CHAR.LGP           | In CHAR.LGP                |\n| FMVs        | FMV Motion JPEG | Duck TrueMotion 2 AVI | Duck TrueMotion 2 AVI      |\n| Resolution  | 320x224, 15fps  | Up to 640x480         | Up to 1920x1080 (mods)     |\n\n---\n\n### 1. cmh175's Japanese Translation Project (2015-2016)\n\n**Forum Thread**: https://forums.qhimm.com/index.php?topic=16321.0\n\n**Approach**:\n\n- Extract files from FF7 International (Japanese PS1)\n- Convert to PC format\n- Load via 7th Heaven mod manager\n\n**Results**:\n\n- \u2705 Successfully extracted Japanese files\n- \u2705 Files loaded into 7th Heaven without errors\n- \u274c **All Japanese text displayed as gibberish**\n- \u274c Game could not parse the character encoding\n\n**Key Quote**:\n\n> \"So the Japanese games files are formatted differently, so they cant be used with other versions of the game. When I altered the JP files they'd get corrupt because the tools we use here would reformat them.\"\n\n**Conclusion**:\n\n- File format conversion possible\n- Character encoding remains incompatible\n- Tools reformat text and break Japanese characters\n- Project abandoned in 2016\n\n### 2. markul's Technical Analysis (2024)\n\n**Forum Post**: https://forums.qhimm.com/index.php?topic=16321.msg294972#msg294972\n\n**Problem Identified**:\n\n> \"Main problem is that the japanese text-fonts, needs a lot of symbols (characters) to be used, for example if the english textfonts needs 1 set of symbols, japanese needs 6, and the ff7 english version seems to be limited to only 1 block.\"\n\n**Proposed Solutions**:\n\n**Option 1 - Force window.bin Usage**:\n\n- Make PC version use `window.bin` for characters (like PSX)\n- Instead of PNG files from `menu_us.lgp`\n- Use `window.bin` from Japanese PSX game\n- **Status**: Theoretical, not implemented\n\n**Option 2 - Color-Coded Character Mapping**:\n\n- English version has multiple color variants of same font\n- Map Japanese characters to color+character combinations\n- Example: Character \u00e7 = `{CYAN}*{CYAN}` in Makou Reactor\n- **Drawbacks**:\n  - Requires remapping every Japanese character\n  - Requires modifying `window.bin` font space values\n  - Would lose colored text functionality\n  - Unknown if Wall Market/Proud Clod tools support this technique\n- **Status**: Theoretical, extremely labor-intensive\n\n**Conclusion**:\n\n- Both approaches theoretically possible\n- Both require extensive low-level modifications\n- No implementation attempted\n\n### 3. FFNx Japanese Support Issue (2020-present)\n\n**GitHub Issue**: https://github.com/julianxhokaxhiu/FFNx/issues/39\n**Status**: Open since May 16, 2020\n\n**Key Findings**:\n\n**Square Enix's Approach (eStore version)**:\n\n- Completely customized the `AF3DN.P` graphics driver\n- eStore driver is **larger** than Steam version\n- Contains font injection code for `jafont_X.tex` files\n- **No source code available**\n\n**Quote from julianxhokaxhiu (FFNx developer)**:\n\n> \"Square-Enix did release an eStore Japanese edition of the game, although in order to inject Japanese fonts they had to customize completely the driver. It seems that the eStore release, different than Steam has a bigger stock AF3DN.P driver, which has the code to inject into the font system.\"\n\n**Community Efforts**:\n\n- User \"Hundarzbarbar\" attempted to contact Square Enix Japan (2022)\n- Request for source code or implementation details\n- **No response received**\n- Assembly code analysis attempted but \"very hard to catch what is going on\"\n\n**Technical Analysis**:\n\n- Identified `menu_ja.lgp` contains six `jafont_X.tex` files\n- Font files are TEX format (PlayStation texture format)\n- Driver must handle texture loading for all six files\n- Character lookup must determine which texture to use\n\n**Quote from zaphod77**:\n\n> \"no, because the extra japanese characters needs to be supported in addition to the english characters. there's no room to fit them all in the existing textures and fake it.\"\n\n**Current Status**:\n\n- Issue remains open with \"enhancement\" and \"help wanted\" tags\n- No implementation progress as of 2024\n- Recognized as requiring driver-level modifications\n\n---\n\n### What is qhimm.com?\n\n**qhimm.com** is the authoritative community hub for Final Fantasy VII, VIII, and IX modding and reverse engineering.\n\n**Website**: https://forums.qhimm.com/\n\n**History**:\n\n- 15+ years of continuous reverse engineering efforts\n- Comprehensive technical documentation wiki\n- Home to all major FF7 modding tools\n- Active community of developers and modders\n\n### Key Contributions\n\n**Reverse Engineering**:\n\n- Complete field file format documentation\n- KERNEL.BIN structure fully mapped\n- FF Text encoding table\n- PSX vs PC differences catalogued\n- Battle mechanics and AI documented\n\n**Tool Development**:\n\n- Makou Reactor (field script editor)\n- WallMarket (KERNEL.BIN editor)\n- Proud Clod (scene.bin editor)\n- touphScript (text extraction/reinsertion)\n- LGP Tools (archive management)\n\n**Notable Forum Sections**:\n\n- Final Fantasy 7 > FF7 Tools\n- Final Fantasy 7 > Other Mods\n- Scripting and Reverse Engineering\n- Q-Gears (open-source FF7 engine project)\n\n---\n\n### 7th Heaven (Mod Manager)\n\n**Website**: https://7thheaven.rocks/\n**Current Status**: Actively maintained\n\n**Capabilities**:\n\n- Mod downloading and installation\n- LGP file management\n- Automatic mod conflict resolution\n- Includes FFNx driver\n- Supports 60/30 FPS gameplay mods\n\n**Limitations**:\n\n- Not compatible with \"The Reunion\" mod\n- Cannot add Japanese font support (yet)\n\n**Relevance to Project**:\n\n- Potential distribution platform for Japanese mod\n- Can swap LGP archives\n- Mod catalog system for easy updates\n\n### FFNx (Modern Graphics Driver)\n\n**GitHub**: https://github.com/julianxhokaxhiu/FFNx\n**Current Status**: Actively developed (latest commits 2024)\n\n**Features**:\n\n- DirectX 11/12, Vulkan, or OpenGL rendering\n- Anisotropic filtering, antialiasing, vsync\n- Extended modding support\n- Controller improvements\n- **Open source** (critical for our needs)\n\n**Architecture**:\n\n- Replaces original `AF3DN.P` driver\n- Hooks into game executable\n- Texture loading pipeline\n- Font rendering system\n\n**Japanese Support Status**:\n\n- Issue #39 open since 2020\n- Recognized as requiring font system overhaul\n- Community seeking contributors\n- **This is our best path forward**\n\n### The Reunion (Comprehensive Mod Suite)\n\n**Website**: https://thereunion.live/\n\n**Components**:\n\n- BEACAUSE: Translation fixes\n- MENU ENHANCEMENT: UI improvements\n- 60 FPS BATTLES: Frame rate correction\n- MODEL OVERHAUL: Character model upgrades\n- AUDIO REPLACEMENT: Sound module replacement\n- Enhanced controller support\n\n**Limitations**:\n\n- Not compatible with 7th Heaven\n- Not compatible with FFNx\n- **Cannot solve Japanese character encoding issue**\n\n### touphScript (Text Editor)\n\n**GitHub**: https://github.com/ser-pounce/touphscript\n**Current Version**: 1.5.0 (Feb 2023)\n\n**Capabilities**:\n\n- Dumps all FF7 text to UTF-8 files\n- Re-encodes text back into game files\n- Supports all text locations:\n  - `ff7.exe` / `ff7_en.exe`\n  - `flevel.lgp`\n  - `KERNEL.BIN`\n  - `kernel2.bin`\n  - `scene.bin`\n  - `world_us.lgp`\n- Auto-resizes dialog windows\n- Tutorial script editing\n\n**File Format**:\n\n- Input: UTF-8 text files\n- Output: FF Text encoding\n- **Current limitation**: Single-byte encoding only\n- **Potential**: Could be extended for double-byte\n\n**Relevance**:\n\n- Provides framework for text replacement\n- Would need extension for Japanese encoding\n- Window sizing logic useful reference\n\n### Makou Reactor (Field Script Editor)\n\n**Forum Thread**: http://forums.qhimm.com/index.php?topic=9658.0\n\n**Capabilities**:\n\n- Edit field scripts\n- Modify dialog\n- Change triggers and events\n- **Supports Japanese characters in editor**\n\n**Critical Finding**:\n\n> \"It's curious, because I see Makou Reactor supports Japanese characters. So it seems like saving the flevel in Japanese should be possible (which I tried, when I reopened the flevel the Japanese was just jibberish).\"\n\n**Implication**:\n\n- Tool can handle Japanese input\n- Game cannot parse Japanese output\n- Confirms encoding incompatibility at game level\n\n---\n\n### Comprehensive Documentation Sources\n\n1. **qhimm Modding Wiki**\n\n   - URL: https://qhimm-modding.fandom.com/wiki/Qhimm_Modding_Wiki\n   - FF Text encoding tables\n   - Field file structures\n   - KERNEL.BIN formats\n\n2. **FF7 Flat Wiki**\n\n   - URL: https://ff7-mods.github.io/ff7-flat-wiki/\n   - Field module documentation\n   - Text encoding specifications\n   - Battle system documentation\n\n3. **Version Differences Guide**\n\n   - URL: https://thelifestream.net/ffvii-the-original/ffvii-version-guide/\n   - Complete version comparison\n   - Script differences between releases\n   - PAL vs NTSC differences\n\n4. **PCGamingWiki**\n   - URL: https://www.pcgamingwiki.com/wiki/Final_Fantasy_VII\n   - Technical specs\n   - Compatibility information\n   - Modding guides\n\n### Documented File Formats\n\n**Field Files** (`flevel.lgp`):\n\n- 9 sections per field file\n- Section 1: Script & Dialog (FF Text)\n- Section 2: Camera Matrix\n- Section 3: Model Loader\n- Section 4: Palette\n- Section 5: Walkmesh\n- Section 6: TileMap (unused)\n- Section 7: Encounter\n- Section 8: Triggers\n- Section 9: Background\n\n**KERNEL.BIN**:\n\n- 27 GZIP sections\n- Sections 1-9: Binary data\n- Sections 10-27: Text (FF Text encoding)\n- Complete field descriptions available\n\n**Scene.bin**:\n\n- 256 battle scenes\n- 3 enemy names each\n- 32 attack names each\n- AI dialogue text\n- Battle mechanics data\n\n---\n\n### Approach 1: Extend FF Text Encoding (Least Invasive)\n\n**Concept**:\n\n- Use currently unused byte ranges (0xD4-0xDF produce errors)\n- Create escape sequences to enable double-byte mode\n- Map Japanese characters to two-byte sequences\n\n**Advantages**:\n\n- Minimal changes to existing text files\n- Could reuse some existing infrastructure\n- Tools like touphScript could be extended\n\n**Disadvantages**:\n\n- Still doesn't solve font texture problem (need 6 textures)\n- Escape sequences add overhead\n- Character limit still problematic\n- Window sizing becomes complex\n\n**Feasibility**: Low - doesn't address font texture issues\n\n### Approach 2: FFNx Driver Modification (Most Promising)\n\n**Concept**:\n\n- Fork FFNx (open source)\n- Implement font texture injection system\n- Add Japanese font texture loading\n- Extend character encoding support\n\n**Advantages**:\n\n- FFNx is actively maintained\n- Open source - can see all code\n- Community support available\n- Already replaces graphics driver\n- Developers seeking help on this exact issue\n\n**Disadvantages**:\n\n- Requires C++ and graphics programming knowledge\n- Complex texture management\n- Need to reverse-engineer Square's approach\n- Testing requires extensive gameplay validation\n\n**Feasibility**: High - best path forward\n\n**Required Steps**:\n\n1. Study FFNx texture loading code\n2. Add multi-font-texture support\n3. Implement double-byte character decoding\n4. Create character-to-texture mapping system\n5. Modify window.bin handling for Japanese spacing\n6. Test with Japanese text files\n\n### Approach 3: Hybrid System (Window.bin + Custom Encoding)\n\n**Concept**:\n\n- Force game to use `window.bin` method (like PSX)\n- Create custom encoding that maps to expanded glyph space\n- Use color channels to expand available characters\n\n**Advantages**:\n\n- Leverages PSX architecture\n- May not require driver modifications\n- Uses proven concept (PSX worked)\n\n**Disadvantages**:\n\n- Complex mapping system\n- Loses color text capability\n- Still limited character space\n- Unclear if PC can use window.bin method\n\n**Feasibility**: Medium - theoretical but unproven\n\n### Approach 4: Complete Text System Replacement\n\n**Concept**:\n\n- Replace entire text rendering system\n- Implement Unicode support\n- Modern font rendering (FreeType, etc.)\n- Complete rewrite of text pipeline\n\n**Advantages**:\n\n- Modern, maintainable solution\n- Full Unicode support\n- Scalable fonts\n- Could support any language\n\n**Disadvantages**:\n\n- Massive undertaking (months of work)\n- Breaks compatibility with existing mods\n- Requires deep reverse engineering\n- High risk of bugs\n\n**Feasibility**: Low - overkill for this specific need\n\n---\n\n### Component Breakdown\n\nBased on research, here are the specific components that need modification:\n\n### 1. Character Encoding System\n\n**Current State**:\n\n- FF Text format: single-byte, ASCII offset 0x20\n- 256 character maximum\n- Control codes in 0xE0-0xFF range\n\n**Required Changes**:\n\n- Implement double-byte character support\n- Character range: minimum 2,000 glyphs\n- Maintain backward compatibility with English\n- Escape sequence to toggle encoding mode\n\n**Affected Files**:\n\n- Game executable (decoding routines)\n- All text files (new encoding format)\n- Text editing tools (touphScript, etc.)\n\n### 2. Font Texture System\n\n**Current State**:\n\n- Single font texture loaded from `menu_us.lgp`\n- `usfont.png` + color variants\n- Direct character \u2192 texture offset mapping\n\n**Required Changes**:\n\n- Load six font textures (`jafont_1.tex` through `jafont_6.tex`)\n- Implement character \u2192 texture selection logic\n- Character \u2192 offset within texture calculation\n- Memory management for 6x texture data\n\n**Affected Files**:\n\n- Graphics driver (FFNx)\n- `menu_ja.lgp` (new archive with 6 textures)\n- Game executable (texture loading code)\n\n### 3. Character Spacing System\n\n**Current State**:\n\n- Fixed-width assumed for most characters\n- Spacing data in `window.bin`\n- Single spacing table\n\n**Required Changes**:\n\n- Proportional font support (Japanese varies widely)\n- Six spacing tables (one per texture)\n- Width calculation for each glyph\n- Kerning support (optional but recommended)\n\n**Affected Files**:\n\n- `window.bin` (expanded spacing data)\n- Window sizing calculations in executable\n\n### 4. Text File Formats\n\n**Current State**:\n\n- `flevel.lgp`: FF Text encoding\n- `KERNEL.BIN`: FF Text encoding\n- `kernel2.bin`: FF Text encoding\n- `scene.bin`: FF Text encoding\n\n**Required Changes**:\n\n- Convert all text to new encoding\n- Update text length calculations\n- Modify compression (if needed for larger text)\n- Update pointers/offsets\n\n**Affected Files**:\n\n- All source text files\n- Game code that reads text files\n- Text editing tools\n\n### 5. Window Sizing System\n\n**Current State**:\n\n- Auto-sizing based on English character widths\n- Fixed height calculations\n- Assumes single-byte character = one glyph\n\n**Required Changes**:\n\n- Calculate width with proportional Japanese fonts\n- Height calculation for vertical text (if applicable)\n- Window parameter adjustments\n- Line breaking for multi-byte characters\n\n**Affected Files**:\n\n- Field script window opcodes\n- Game executable window rendering\n\n---\n\n### Phase 1: Research & Prototyping (Current Phase)\n\n**Goals**:\n\n- \u2705 Understand existing attempts\n- \u2705 Document technical constraints\n- \u2705 Identify modification points\n- \u23f3 Contact FFNx developers\n- \u23f3 Acquire Japanese FF7 eStore version for analysis\n\n**Deliverables**:\n\n- Technical documentation (this file)\n- List of researched resources\n- Initial contact with FFNx team\n\n### Phase 2: Font System Proof of Concept\n\n**Goals**:\n\n- Load multiple font textures in FFNx\n- Display single Japanese character\n- Verify texture memory allocation\n\n**Requirements**:\n\n- FFNx development environment setup\n- Japanese font textures extracted\n- Basic C++ knowledge\n- Graphics debugging tools\n\n**Estimated Effort**: 2-4 weeks\n\n### Phase 3: Character Encoding Implementation\n\n**Goals**:\n\n- Implement double-byte character decoding\n- Create character \u2192 texture mapping system\n- Test with small text sample\n\n**Requirements**:\n\n- Text encoding specification\n- Modified touphScript or equivalent\n- Test field with Japanese text\n\n**Estimated Effort**: 3-6 weeks\n\n### Phase 4: Full Text Integration\n\n**Goals**:\n\n- Convert all game text to Japanese\n- Update all text files\n- Implement window sizing\n- Test all game areas\n\n**Requirements**:\n\n- Complete Japanese translation\n- Automated testing framework\n- Extensive playtesting\n\n**Estimated Effort**: 2-3 months\n\n### Phase 5: Polish & Distribution\n\n**Goals**:\n\n- Bug fixes\n- Performance optimization\n- 7th Heaven integration\n- Documentation for users\n\n**Estimated Effort**: 1-2 months\n\n**Total Estimated Timeline**: 5-8 months (full-time equivalent)\n\n---\n\n### FFNx Project\n\n**Lead Developer**: julianxhokaxhiu\n**GitHub**: https://github.com/julianxhokaxhiu\n**Issue**: https://github.com/julianxhokaxhiu/FFNx/issues/39\n\n**Quote**:\n\n> \"If you know anyone in Japan willing to cooperate, I'm more then open to talk about what has to be done, I'd be fine implementing it myself.\"\n\n**Status**: Actively seeking help with Japanese font support\n\n### Community Members\n\n**cmh175** (qhimm forums):\n\n- Attempted Japanese translation mod 2015-2016\n- Documented file format conversion issues\n- May have Japanese file resources\n\n**markul** (qhimm forums):\n\n- Recent analysis (2024) of technical approaches\n- Investigated window.bin solution\n- Active in modding community\n\n**DLPB** (The Reunion developer):\n\n- Extensive FF7 modding experience\n- Created comprehensive mod suite\n- Text system expertise\n\n---\n\n### Essential Reading\n\n1. **FF Text Encoding**\n\n   - https://ff7-mods.github.io/ff7-flat-wiki/FF7/Text_encoding.html\n   - Complete character table\n   - Control codes\n   - Encoding specifications\n\n2. **Field File Format**\n\n   - https://ff7-mods.github.io/ff7-flat-wiki/FF7/Field.html\n   - All 9 sections documented\n   - PSX vs PC differences\n   - Script system overview\n\n3. **KERNEL.BIN Format**\n\n   - https://ff7-mods.github.io/ff7-flat-wiki/FF7/Kernel/Kernel.bin.html\n   - 27 section breakdown\n   - Text section specifications\n   - Data structures\n\n4. **FFNx Japanese Support Issue**\n\n   - https://github.com/julianxhokaxhiu/FFNx/issues/39\n   - Community discussion\n   - Technical analysis\n   - Current status\n\n5. **Version Differences**\n   - https://thelifestream.net/ffvii-the-original/ffvii-version-guide/\n   - Complete version history\n   - Japanese vs English differences\n   - PC port changes\n\n### Tool Documentation\n\n1. **touphScript**\n\n   - https://github.com/ser-pounce/touphscript\n   - Text extraction/reinsertion\n   - UTF-8 support\n   - Window sizing\n\n2. **7th Heaven**\n\n   - https://7thheaven.rocks/\n   - Mod manager\n   - Distribution platform\n\n3. **qhimm Forums**\n   - https://forums.qhimm.com/\n   - Community hub\n   - Tool downloads\n   - Technical discussions\n\n### Japanese FF7 Resources\n\n1. **FF7 International Thread**\n\n   - https://forums.qhimm.com/index.php?topic=16321.0\n   - Japanese translation attempts\n   - File format discussions\n\n2. **Japanese Text Extraction**\n   - https://forums.qhimm.com/index.php?topic=15110.0\n   - Japanese Steam version discussion\n   - File location information\n\n---\n\n### Immediate Actions\n\n1. **Contact FFNx Developers**\n\n   - Comment on Issue #39\n   - Express interest in collaborating\n   - Share research findings\n   - Ask about architecture details\n\n2. **Acquire Japanese Version**\n\n   - Purchase FF7 from Japanese eStore (if available)\n   - Extract `menu_ja.lgp` and font files\n   - Analyze `AF3DN.P` driver differences\n   - Document Japanese text encoding\n\n3. **Set Up Development Environment**\n\n   - Clone FFNx repository\n   - Build from source\n   - Set up debugging environment\n   - Test font texture loading\n\n4. **Deep Dive Research** (Continue scraping)\n   - qhimm forum threads (15 years of archives)\n   - FFNx source code analysis\n   - Square Enix patents (font rendering)\n   - PlayStation SDK documentation\n\n### Research Priorities\n\n**High Priority**:\n\n- FFNx texture loading code\n- Square Enix's driver modifications\n- Japanese font file formats\n- Character spacing calculations\n\n**Medium Priority**:\n\n- PSX dynamic kanji loading system\n- Window.bin format specification\n- Text compression in flevel.lgp\n- Menu rendering pipeline\n\n**Low Priority**:\n\n- Battle text system\n- World map text differences\n- Tutorial text handling\n- FMV subtitle system (if exists)\n\n---\n\nEnabling Japanese character support in FF7 PC is **technically feasible but architecturally complex**. It requires:\n\n1. **Character encoding overhaul** - Double-byte support throughout\n2. **Font texture multiplication** - 1 texture \u2192 6 textures\n3. **Driver modifications** - Graphics pipeline changes\n4. **Tool extensions** - Update text editors and converters\n5. **Extensive testing** - Verify across entire game\n\n**Best Path Forward**: Collaborate with FFNx project to implement Japanese font support at the driver level, leveraging their open-source codebase and active community.\n\n**Estimated Effort**: 5-8 months full-time development for complete implementation.\n\n**Success Probability**: High, given that Square Enix already proved it's possible with their eStore version.\n\n---\n\n**Research Date**: 2025-11-15 23:30 JST (Saturday)\n**Session**: 1021bc57-9aa2-41fe-baad-a6b89b252744 (continuation from compacted Session 4)\n**Sources Analyzed**: Q-Gears engine documentation (460KB markdown), ulgp forum thread, Image2TEX repository, Tonberry source code\n\n### Discovery #1: Q-Gears TEX Format Specification Confirmed\n\n**Source**: Q-Gears engine documentation (ff7 game engine.md)\n\n**TEX Format Structure** (Lines 1052-1070 of Q-Gears docs):\n\n- **Header**: Contains metadata (width, height, bit depth, palette information)\n- **Optional Palette Data**: Color Look Up Table (CLUT) for paletized images\n- **Bitmap Data**: Raw pixel data\n\n**Key Characteristics**:\n\n- Usually stored as **paletized pictures** with bitmap pixels referencing palette\n- **Color 0** (typically black) used as **transparent color**\n- 16-bit depth option: **RGB555 format** (5 bits per color in 2-byte entry)\n- This is the **exact format used for USFONT\\_\\*.TEX files**\n\n**Quote from Q-Gears**:\n\n> \"FF7 PC texture consists of header, an optional palette and bitmap data. Usually data are stored like palletized picture, with bitmap pixels referencing to palette. Color 0 (in palette its usually black) is usually used as transparent color.\"\n\n**Critical Implication**: Font textures use palette system, allowing color changes via CLUT modification without re-rendering entire texture.\n\n---\n\n### Discovery #2: PSX Font Storage Architecture\n\n**Source**: Q-Gears VRAM documentation (Lines 271-285)\n\n**PSX VRAM Font Location**:\n\n- Fonts stored in **\"yellow area\"** of VRAM map (see Q-Gears schematic)\n- Uses **CLUT (Color Look Up Tables)** system\n- CLUT location separate from texture location\n- GPU can directly change CLUT colors \u2192 instant font color updates\n\n**Critical Quote from Q-Gears**:\n\n> \"The green area on the right is the permanent menu textures and the **yellow is where the menu font is located**.\"\n\n**Additional Quote on Japanese Characters**:\n\n> \"All the blank rectangles are the texture cache boundaries... **The textures on the bottom right are barely overwritten** except for key places.\"\n\n**PC Version Adaptation**:\n\n- PSX: WINDOW.BIN offset **0x2754** contains font data\n- PC: Fonts separated into external **MENU_US.LGP** archive as TEX files\n- Texture cache system not directly ported to PC\n\n---\n\n### Discovery #3: Japanese Character Space Confirmed\n\n**Source**: Q-Gears KERNEL.BIN documentation (Line 303)\n\n**WINDOW.BIN Analysis**:\n\n- PSX version reserves **large blank space** below menu text\n- **Quote**: \"The large blank spot under the menu text is for the Japanese characters that were removed in the non-Japanese version of the game.\"\n- Japanese PSX used **dynamic kanji loading** system\n- Field files specified which kanji glyphs to load per scene\n- System **not ported to PC version**\n\n**Architectural Difference**:\n\n```\nPSX Japanese:\nWINDOW.BIN \u2192 Dynamic kanji loading \u2192 VRAM yellow area \u2192 Scene-specific glyphs\n\nPC English:\nMENU_US.LGP \u2192 USFONT_*.TEX \u2192 Static font set \u2192 No dynamic loading\n\nPC Japanese (eStore):\nMENU_JA.LGP \u2192 jafont_1-6.tex \u2192 6 static font sets \u2192 No dynamic loading\n```\n\n**Implication**: PC Japanese version had to use **6 separate texture files** because it abandoned the PSX dynamic loading system.\n\n---\n\n### Discovery #4: ulgp - LGP Archive Tool (Complete Specification)\n\n**Source**: https://forums.qhimm.com/index.php?topic=12831.0 (scraped 2025-11-15)\n\n**Tool Details**:\n\n- **Author**: luksy (based on Aali's original lgp code with permission)\n- **Version**: 1.2 (latest stable), 1.2.1 (forces lowercase), 1.3.2 (no memory mapping)\n- **Download**: https://www.dropbox.com/s/o770wtunby0k89y/ulgp_v1.2.7z?dl=0\n- **Status**: Community-endorsed, virus-scanned clean (Malwarebytes + Avira verified)\n- **First Released**: 2012-02-17\n- **Thread Views**: 159,144 (highly used tool)\n\n**Core Capabilities**:\n\n1. **Extract Entire Archive**:\n\n   ```bash\n   ulgp -x magic.lgp\n   ```\n\n   Creates `magic/` folder with all files extracted\n\n2. **Create Archive from Folder**:\n\n   ```bash\n   ulgp -c magic.lgp\n   ```\n\n   Packs all files in `magic/` folder into `magic.lgp`\n\n3. **Overwrite Files in Archive** \u2b50 **KEY FEATURE**:\n\n   ```bash\n   ulgp -r magic.lgp\n   ```\n\n   Reads files from `magic/` folder and **overwrites matching files** in `magic.lgp` without full extraction/repack\n\n   - **Massive time savings**: Don't need to extract all files to update a few\n   - **Space savings**: Temporary extraction folder only needs modified files\n\n4. **Extract Individual Files** (v0.2+):\n\n   ```bash\n   ulgp -d magic.lgp somefolder\n   ```\n\n   Extract specific files only\n\n5. **Insert Individual Files** (v0.2+):\n   ```bash\n   ulgp -i magic.lgp specific_file.tex\n   ```\n\n**GUI Features**:\n\n- Double-click `.lgp` file to extract to default folder\n- Right-click folder \u2192 Create/add to `.lgp` file\n- `install.bat` to associate `.lgp` files with ulgp\n- Two GUI versions: XP style and Vista/7/8 style\n\n**Advanced Usage** (from readme):\n\n- Source code included (LGPLIB interface for custom projects)\n- Command-line distribution for automated mod installers\n- Case-insensitive filename matching (v0.4+)\n- Localization support (translations available)\n\n**Known Issues Fixed**:\n\n- v0.2: Hash table bug (don't use)\n- v0.3: Fixed hash table\n- v0.4: Fixed case sensitivity issues\n- v1.2.1: Forces lowercase filenames internally (compatibility)\n- v1.3.2: No memory mapping (use if getting memory errors)\n\n**Community Endorsements**:\n\n- Aali (original lgp author): \"This is exactly the kind of re-use I intended for my code\"\n- DLPB (The Reunion developer): \"Cut down on decoding the whole files. Less space needed now and faster\"\n- sl1982 (7th Heaven developer): \"Will make automated installers much quicker\"\n\n**Relevance**: **CRITICAL** - Primary tool for extracting USFONT\\_\\*.TEX from menu_us.lgp and repacking modified fonts.\n\n---\n\n### Discovery #5: Image2TEX - Batch Texture Converter\n\n**Source**: https://github.com/niemasd/Image2TEX (scraped 2025-11-15)\n\n**Tool Details**:\n\n- **Original Author**: Borde\n- **Archiver**: Niemas Deutrom (niemasd on GitHub)\n- **Language**: Visual Basic .NET\n- **Last Updated**: 2019-05-26 (6 years old)\n- **License**: Not explicitly stated (source code public)\n- **Stars**: 6, **Forks**: 1\n\n**Core Capabilities**:\n\n1. **Format Support**:\n\n   - **Input**: BMP, JPG, GIF, ICO, WMF, EMF\n   - **Output**: TEX (FF7 PC texture format)\n   - **Reverse**: TEX \u2192 BMP export\n\n2. **Usage Workflow**:\n\n   **Method A: Single File**:\n\n   ```\n   1. Click \"Open image\" button\n   2. Select BMP/JPG/GIF/etc.\n   3. Click \"Save texture\" button\n   4. Choose TEX or BMP output\n   ```\n\n   **Method B: Batch Conversion** \u2b50 **KEY FEATURE**:\n\n   ```\n   1. Click \"Mass convert\" button\n   2. Select directory with images\n   3. Converts all images \u2194 TEX format\n   4. Output filenames: same name, extension changed\n   ```\n\n3. **Options**:\n   - **\"Color 0 as transparent\"**: Checkbox treats completely black pixels as transparent\n   - **Color depth preservation**: Maintains original image color depth\n\n**Technical Details**:\n\n- Based on Mirex and Aali's TEX format specification work\n- Uses GDI API (GDIAPI.bas) for image loading\n- FF7TEXTexture.bas: TEX format encoding/decoding\n- BMPTexture.bas: BMP format handling\n\n**Known Issues**:\n\n- **\"Color 0 as transparent\" limitation**: No effect on original FF7 engine for 24-bit images\n- **Works with Aali's/FFNx driver**: Transparency flag functions correctly with modern drivers\n\n**Quote from README**:\n\n> \"This tool is heavily untested, use it at your own risk.\"\n\n**Source Files Available**:\n\n- `Image2TEX.frm` - GUI form\n- `FF7TEXTexture.bas` - TEX format code\n- `BMPTexture.bas` - BMP handling\n- `GDIAPI.bas` - Windows GDI interface\n- `Image2TEX_Project.vbp` - Visual Basic project file\n\n**Compilation Note**: Requires Visual Basic 6.0 or compatible compiler. Pre-compiled executable not in repository (may exist in qhimm forums).\n\n**Relevance**: **CRITICAL** - Enables conversion of edited font images (BMP/PNG) back to TEX format for repacking into menu_us.lgp.\n\n---\n\n### Discovery #6: Tonberry Source Code Architecture (Reference)\n\n**Source**: https://github.com/jonnynt/tonberry (scraped 2025-11-15)\n\n**Tool Details**:\n\n- **Author**: jonnynt\n- **Game**: Final Fantasy VIII (2013 Steam release)\n- **Version**: 2.04 (last updated 2015-06-23)\n- **License**: MIT License (free to use, modify, distribute)\n- **Language**: C++ (52.5%), C (47.5%)\n- **Forum Thread**: https://forums.qhimm.com/index.php?topic=15945.0\n\n**Architecture Insights** (from commit history):\n\n1. **Runtime Injection**:\n\n   - Hooks DirectX `UnlockRect()` function\n   - Intercepts texture loading at GPU level\n   - No game executable modification required\n\n2. **Hash-based Mapping**:\n\n   - CSV files map texture hash values to replacement PNG filenames\n   - Format: `texture_name,hash_value`\n   - Example: `sysfld00_13,8637763346649579509`\n\n3. **Cache Management**:\n\n   - `nhcache_item_t` struct with persist boolean flag\n   - Persistent textures: Prefix `!` in CSV to keep in cache permanently\n   - Disabled textures: Prefix `*` in CSV to exclude from loading\n   - Configurable cache size (max 250 for non-LAA builds)\n\n4. **Performance Characteristics** (from commit messages):\n   - `UnlockRect()` identified as primary bottleneck\n   - Cache eviction needed for 32-bit memory constraints\n   - Exponentially worse lag with cache sizes below 100\n   - Quote: \"Now if there are too many persistent textures, Tonberry won't crash... it will just lag.\"\n\n**Directory Structure** (from forum thread):\n\n```\n[FF8]/\n\u251c\u2500\u2500 tonberry/\n\u2502   \u251c\u2500\u2500 hashmap/*.csv      \u2192 Hash-to-texture mapping files\n\u2502   \u2514\u2500\u2500 prefs.txt          \u2192 Configuration (cache size, etc.)\n\u2514\u2500\u2500 textures/**/*.png       \u2192 Replacement texture PNG files\n```\n\n**Differences from FFNx Approach**:\n\n- **Tonberry**: Hash-based (requires hash calculation/CSV mapping)\n- **FFNx**: Path-based (simple filename matching in mod_path)\n- **Tonberry**: Runtime interception (DLL injection)\n- **FFNx**: Driver replacement (full graphics driver)\n\n**Relevance**: **HIGH** - Proves runtime texture injection works for Square Enix games. FFNx's simpler path-based system avoids hash complexity.\n\n---\n\n### Revised Tool Chain Workflow\n\nBased on Session 5 discoveries, here is the **complete validated tool chain**:\n\n**Phase 1: Extraction**\n\n```bash\n# Extract menu_us.lgp\nulgp -x menu_us.lgp\n\n# Result: menu_us/ folder containing USFONT_*.TEX files\n```\n\n**Phase 2: Conversion (TEX \u2192 Editable Format)**\n\n**Option A: Use Image2TEX**:\n\n```\n1. Launch Image2TEX.exe\n2. Open image: USFONT_H.TEX\n3. Save texture: USFONT_H.BMP\n4. Edit in GIMP/Photoshop\n```\n\n**Option B: Use FFNx texture dumping**:\n\n```toml\n# FFNx.toml\nsave_textures = true\n```\n\nLaunch game \u2192 Open menu \u2192 Fonts dumped as PNG to `mods/Textures/`\n\n**Phase 3: Editing**\n\n```\n1. Open USFONT_H.BMP in GIMP/Photoshop\n2. Modify font glyphs (e.g., change to red, add borders)\n3. Save as BMP (preserve dimensions exactly!)\n```\n\n**Phase 4A: Testing via FFNx (RECOMMENDED - No Repacking)**\n\n```bash\n# Copy edited PNG directly to FFNx mod_path\ncp USFONT_H_modified.PNG \"[FF7_DIR]/mods/Textures/USFONT_H.PNG\"\n\n# Configure FFNx.toml\nmod_path = \"mods/Textures\"\nmod_ext = [\"dds\", \"png\"]\n\n# Launch game and test\n```\n\n**Phase 4B: Production (Repack into LGP)**\n\n```\n# Convert BMP \u2192 TEX\n1. Launch Image2TEX.exe\n2. Open image: USFONT_H_modified.BMP\n3. Save texture: USFONT_H.TEX\n\n# Overwrite in LGP archive\nmkdir menu_us\ncp USFONT_H.TEX menu_us/\nulgp -r menu_us.lgp\n\n# Result: menu_us.lgp now contains modified font\n```\n\n**Phase 5: Distribution**\n\n```\n# For 7th Heaven mods\nCreate .IRO file containing:\n- Modified menu_us.lgp\nOR\n- Texture files for FFNx mod_path\n\n# For manual installation\nDistribute ulgp + modified menu_us.lgp with instructions\n```\n\n---\n\n### Complete Tool Inventory\n\n| Tool           | Purpose                           | Status            | Download                                                               | Priority     |\n| -------------- | --------------------------------- | ----------------- | ---------------------------------------------------------------------- | ------------ |\n| **ulgp v1.2**  | LGP extract/insert/repack         | \u2705 Documented     | [Dropbox](https://www.dropbox.com/s/o770wtunby0k89y/ulgp_v1.2.7z?dl=0) | **CRITICAL** |\n| **Image2TEX**  | BMP/JPG/GIF \u2194 TEX batch converter | \u2705 Documented     | [GitHub Source](https://github.com/niemasd/Image2TEX)                  | **CRITICAL** |\n| **tim2png**    | TIM \u2192 PNG converter               | \u23f3 Pending scrape | [ff7tools GitHub](https://github.com/cebix/ff7tools)                   | **HIGH**     |\n| **TEX to BMP** | TEX \u2192 BMP code example            | \u23f3 Pending scrape | [Gist](https://gist.github.com/hoehrmann/5720668)                      | **MEDIUM**   |\n| **Tex Tools**  | Community TEX converter           | \u23f3 Pending scrape | [qhimm Thread](https://forums.qhimm.com/index.php?topic=17755.0)       | **MEDIUM**   |\n| **FFNx**       | Modern graphics driver            | \u2705 Documented     | [GitHub](https://github.com/julianxhokaxhiu/FFNx)                      | **CRITICAL** |\n| **7th Heaven** | Mod manager                       | \u2705 Documented     | [Official Site](https://7thheaven.rocks/)                              | **HIGH**     |\n\n---\n\n### Immediate Next Steps (Updated Post-Session 5)\n\n**PRIORITY 1: Validate FFNx Texture Override** \u2705 Ready to Execute\n\n- All tools identified and documented\n- TEST_PROCEDURE.md provides complete guide\n- Font filenames confirmed (USFONT_H.TEX, etc.)\n- **Action**: Execute test procedure to validate concept\n\n**PRIORITY 2: Tool Acquisition**\n\n- Download ulgp v1.2 from Dropbox\n- Find pre-compiled Image2TEX executable (check qhimm forums)\n- Alternative: Compile Image2TEX from Visual Basic .NET source\n\n**PRIORITY 3: Remaining Tool Research**\n\n- Scrape tim2png documentation\n- Scrape TEX to BMP code example\n- Scrape Tex Tools forum thread\n- Document alternative conversion methods\n\n**PRIORITY 4: Community Engagement**\n\n- Join Discord servers (VG Research & Modding, FF7 Discord)\n- Contact FFNx developers on Issue #39\n- Request Japanese version `menu_ja.lgp` extraction from community\n\n**PRIORITY 5: Japanese Font Acquisition**\n\n- Research creating Japanese font textures from scratch\n- Investigate Japanese TrueType \u2192 Bitmap atlas conversion\n- Study `jafont_1-6.tex` organization (if obtainable)\n\n---\n\n**Research Date**: 2025-11-15 23:58 JST (Saturday)\n**Session**: 1021bc57-9aa2-41fe-baad-a6b89b252744 (continuation from Session 5)\n**Sources Analyzed**: 5 pending URLs (tim2png, TEX to BMP, Tex Tools, 7th Heaven, CJK Font Atlas)\n\n### Discovery #1: CJK Font Atlas Mathematical Constraints\n\n**Source**: https://killertee.wordpress.com/2021/04/23/optimizing-workflow-textmesh-pro-font-atlas-for-language-localization/\n\n**General Statement on CJK Characters**:\n\n> \"Chinese, Japan, Korean and other Hieroglyphic Language have a massive set of characters. To contain all the characters of each one, several atlases must be built (most platforms have 2048\u00d72048 limit for texture size).\"\n\n**Constraints Identified**:\n\n1. **Platform texture limit**: 2048\u00d72048 pixels (common GPU constraint)\n2. **Character count**: 2000-3000 characters needed for CJK languages\n3. **Padding requirements**: 4-5 pixels standard for SDF (Signed Distance Field) gradient effects\n4. **Solution approach**: \"Only used characters will be built into atlas\" (selective character sets)\n\n**Limitation of Source**: Article **does not provide explicit mathematical proof** or calculations demonstrating why 2000-3000 characters cannot fit in a single 2048\u00d72048 texture. It states the constraint exists but focuses on practical solutions rather than mathematical derivation.\n\n**Manual Calculation** (to fill research gap):\n\n```\nBasic calculation for 2048\u00d72048 texture:\n\nAssumptions:\n- Glyph size: 16\u00d716 pixels (common for readable kanji)\n- Padding: 5 pixels per glyph (4-5 pixels mentioned in article)\n- Effective glyph area: (16 + 5) \u00d7 (16 + 5) = 21 \u00d7 21 = 441 pixels per character\n\nTexture capacity:\n- Total texture area: 2048 \u00d7 2048 = 4,194,304 pixels\n- Characters per 2048\u00d72048 texture: 4,194,304 \u00f7 441 = ~9,508 characters\n\nThis suggests 2048\u00d72048 CAN fit 2000-3000 characters at 16\u00d716 glyph size!\n\nBUT: Japanese kanji requires LARGER glyphs for readability:\n- At 32\u00d732 glyph size + 5px padding:\n  * Effective area: (32 + 5) \u00d7 (32 + 5) = 37 \u00d7 37 = 1,369 pixels\n  * Capacity: 4,194,304 \u00f7 1,369 = ~3,062 characters\n  * Still fits 2000-3000 characters!\n\n- At 48\u00d748 glyph size + 5px padding:\n  * Effective area: (48 + 5) \u00d7 (48 + 5) = 53 \u00d7 53 = 2,809 pixels\n  * Capacity: 4,194,304 \u00f7 2,809 = ~1,492 characters\n  * DOES NOT FIT 2000-3000 characters!\n\n- At 64\u00d764 glyph size + 5px padding:\n  * Effective area: (64 + 5) \u00d7 (64 + 5) = 69 \u00d7 69 = 4,761 pixels\n  * Capacity: 4,194,304 \u00f7 4,761 = ~880 characters\n  * DOES NOT FIT 2000-3000 characters!\n```\n\n**Conclusion**: The 2048\u00d72048 texture limit becomes a constraint **depending on glyph size requirements**. At 48\u00d748 pixels or larger (often needed for complex kanji), a single texture cannot hold 2000-3000 characters.\n\n**FF7 Japanese Version**: Uses **6 texture files** (`jafont_1-6.tex`), suggesting:\n\n- Either larger glyph sizes (48\u00d748 or 64\u00d764)\n- Or conservative padding/layout\n- Or inclusion of ALL J\u014dy\u014d kanji (2,136 characters) + hiragana + katakana + punctuation\n\n---\n\n### Discovery #2: Alternative TEX Conversion Tools\n\n**Sources**:\n\n- tim2png: https://github.com/cebix/ff7tools/blob/master/README\n- TEX to BMP: https://gist.github.com/hoehrmann/5720668\n- Tex Tools: https://forums.qhimm.com/index.php?topic=17755.0\n\n**Tool Comparison**:\n\n| Tool                               | Format                     | Language    | Status       | Relevance                       |\n| ---------------------------------- | -------------------------- | ----------- | ------------ | ------------------------------- |\n| **Image2TEX** (Session 5)          | TEX \u2194 BMP/JPG/GIF          | VB.NET      | Source only  | **CRITICAL** - Batch conversion |\n| **Tex Tools v1.0.4.7** (Session 6) | TEX \u2194 PNG/JPG/GIF/TIFF/BMP | Windows GUI | Pre-compiled | **HIGH** - Easiest to use       |\n| **tim2png** (Session 6)            | TIM \u2192 PNG                  | Python      | Ready to use | **MEDIUM** - PSX only           |\n| **TEX to BMP Pascal** (Session 6)  | TEX \u2192 BMP                  | Pascal code | Educational  | **MEDIUM** - Reference only     |\n\n**Tex Tools Features** (v1.0.4.7):\n\n- Image resizing (useful for texture scaling)\n- Clipboard operations (copy/paste workflow)\n- Batch processing (mass convert directories)\n- Fast conversion in source folders\n- Rotate/flip transformations\n- Drag-and-drop support\n- Command-line compatibility\n\n**Recommendation**: **Tex Tools v1.0.4.7** is likely easier for users than compiling Image2TEX from Visual Basic source. Forum download provides pre-compiled executable.\n\n---\n\n### Discovery #3: 7th Heaven + FFNx Integration Confirmed\n\n**Source**: https://7thheaven.rocks/help/userhelp.html\n\n**Critical Quote**:\n\n> \"This Path needs to match the subfolder name listed on the line 'mod_path =' in your 'FFNx.cfg' file.\"\n\n**Texture Override Workflow**:\n\n```\n1. FFNx.toml configuration:\n   mod_path = \"mods/Textures\"\n\n2. 7th Heaven configuration:\n   Game Driver \u2192 Textures \u2192 [FF7_DIR]/mods/Textures\n\n3. Directory structure:\n   [FF7_DIR]/\n   \u251c\u2500\u2500 FFNx.toml\n   \u251c\u2500\u2500 FFNx.dll\n   \u2514\u2500\u2500 mods/\n       \u2514\u2500\u2500 Textures/     \u2190 Must match mod_path exactly\n           \u251c\u2500\u2500 USFONT_H.PNG\n           \u2514\u2500\u2500 ... (other textures)\n\n4. Runtime behavior:\n   - FFNx searches in [FF7_DIR]/mods/ for configured subfolder\n   - 7th Heaven injects mod files into this directory at launch\n   - FFNx loads textures from mod_path during rendering\n```\n\n**Path Matching Rules**:\n\n- Paths must match **exactly** (case-sensitive on Linux/macOS)\n- Use **relative** path from FF7 directory (not absolute)\n- Recommended standard: `mods/Textures` (community convention)\n\n**Integration Validated**: This confirms FFNx texture override system can be used via 7th Heaven mod manager for easy distribution.\n\n---\n\n---\n\n**BREAKTHROUGH**: User has purchased Japanese eStore version (SEDL-1010)!\n\n**Product**: (Windows \u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u7248)\u30d5\u30a1\u30a4\u30ca\u30eb\u30d5\u30a1\u30f3\u30bf\u30b8\u30fc VII \u30a4\u30f3\u30bf\u30fc\u30ca\u30b7\u30e7\u30ca\u30eb for PC\n**Release**: May 16, 2013\n**Status**: **NOW DELISTED** - User has rare copy!\n\n### What This Means\n\n**Direct Access to Square Enix's Implementation**:\n\n- 6 Japanese font textures (jafont_1-6.tex) in menu_ja.lgp\n- Reference character layout (which kanji in which texture)\n- Glyph sizing used by Square Enix\n- Character organization pattern\n- No reverse-engineering guesswork needed!\n\n**Extraction Path**:\n\n```bash\n[Japanese FF7]/data/menu/menu_ja.lgp\n  \u2193 Extract with ulgp -x\njafont_1.tex through jafont_6.tex\n  \u2193 Convert with Tex Tools\njafont_1.png through jafont_6.png (visual analysis)\n```\n\n### Critical Realization: Double-Byte Encoding is NON-NEGOTIABLE\n\n**User's Insight**: \"Hiragana and Katakana alone is unacceptable. We need all 2,000+ kanji available.\"\n\n**This is absolutely correct**. Adult Japanese literacy requires:\n\n- 2,136 J\u014dy\u014d kanji (minimum)\n- 46 hiragana\n- 46 katakana\n- Punctuation and special characters\n- **Total: ~2,300+ characters**\n\n**Single-byte encoding (256 character limit) = FUNCTIONALLY USELESS**\n\n### Shift to Phase 2: Double-Byte Encoding Research\n\n**New Priority**: Investigate how Japanese eStore version implements:\n\n1. **Shift-JIS encoding** (standard Japanese double-byte system)\n2. **Character\u2192texture mapping** (which of 6 textures contains character X?)\n3. **Text file modifications** (flevel.lgp, KERNEL.BIN with Japanese encoding)\n4. **Driver-level character lookup** (how AF3DN.P handles double-byte\u2192glyph conversion)\n\n**Research Tools Available**:\n\n- \u2705 Japanese eStore version files (complete implementation reference)\n- \u2705 Brave Search for technical documentation\n- \u2705 Firecrawl for deep technical scraping\n- \u2705 FFNx source code analysis (GitHub)\n\n---\n\n---\n\n### Product Vision: \"FF7 Japanese Learning Edition\"\n\n**Beyond Basic Japanese Support**: The goal is not just to display Japanese text, but to create a **comprehensive Japanese language learning tool** using FF7 as the vehicle.\n\n### Feature 1: Cheat/Booster Functions\n\n**Status**: \u2705 ALREADY IMPLEMENTED\n\nUser's Japanese eStore version includes:\n\n- **Product**: \u30d5\u30a1\u30a4\u30ca\u30eb\u30d5\u30a1\u30f3\u30bf\u30b8\u30fc VII \u30a4\u30f3\u30bf\u30fc\u30ca\u30b7\u30e7\u30ca\u30eb for PC\n- **Code**: J13308W_001_D01\n- **Version**: 2.00 (September 19, 2013)\n\n**Built-in Boosters** (keyboard shortcuts):\n\n- 3x Speed Mode (faster gameplay)\n- Max Stats (instant character growth)\n- God Mode (invincibility)\n- No Random Encounters (focus on story)\n- Gil/Items (max resources)\n\n**Relevance**: Reduces grinding, allows focus on language learning\n\n---\n\n### Feature 2: English \u2194 Japanese Language Toggle\n\n**Priority**: HIGH (Phase 2 after core Japanese support)\n**Difficulty**: MEDIUM\n**Estimated Effort**: 2-4 weeks\n\n**User Story**: \"I want to toggle between English and Japanese text at runtime to compare translations and learn vocabulary in context.\"\n\n**Technical Implementation Options**:\n\n**Option A: Dual Text File Loading**\n\n```\nDirectory structure:\ndata/\n\u251c\u2500\u2500 field_en/flevel.lgp  (English dialogues)\n\u251c\u2500\u2500 field_ja/flevel.lgp  (Japanese dialogues)\n\u2514\u2500\u2500 FFNx switches based on user setting\n\nRuntime:\nPress F9 \u2192 Toggle language \u2192 Reload current scene text\n```\n\n**Option B: Tagged Bilingual Text Files**\n\n```\nText format:\n{CLOUD}: {EN}Let's go!{/EN}{JA}\u884c\u3053\u3046\uff01{/JA}\n\nFFNx rendering:\nif (language == \"EN\") render EN tags\nif (language == \"JA\") render JA tags\n```\n\n**Option C: Configuration-Based Asset Switching**\n\n```toml\n# FFNx.toml\nlanguage = \"JA\"  # or \"EN\"\ntext_path = \"data/lang_ja\"  # switches all text assets\nfont_path = \"mods/Fonts/ja\"  # loads Japanese fonts\n```\n\n**Requirements**:\n\n1. \u2705 Japanese font support (jafont_1-6.tex) - current goal\n2. \u2705 Double-byte encoding (2,000+ kanji) - current goal\n3. \u23f3 Text file management system (select EN vs JA)\n4. \u23f3 FFNx configuration extension\n5. \u23f3 Runtime toggle UI (keyboard shortcut)\n\n**Benefits**:\n\n- Compare translations for learning\n- Switch when stuck on difficult kanji\n- Study sentence structure differences\n- Ideal for JLPT N3-N1 learners\n\n---\n\n### Feature 3: Furigana (Reading Guides Above Kanji)\n\n**Priority**: MEDIUM (Phase 3 capstone feature)\n**Difficulty**: HIGH\n**Estimated Effort**: 3-6 weeks (inline) / 2-3 months (proper)\n\n**User Story**: \"I want furigana displayed above kanji so Japanese learners can read pronunciation while studying the kanji forms.\"\n\n**Example Display**:\n\n```\nStandard (no furigana):\n\u300c\u4eba\u3068\u3057\u3066\u4e00\u756a\u5927\u5207\u306a\u3082\u306e\u3092\u5931\u3063\u305f\u306e\u3060\u304b\u3089\u300d\n\nWith proper furigana (above):\n  \u3072\u3068    \u3044\u3061\u3070\u3093\u305f\u3044\u305b\u3064      \u3046\u3057\u306a\n\u300c\u4eba\u3068\u3057\u3066\u4e00\u756a\u5927\u5207\u306a\u3082\u306e\u3092\u5931\u3063\u305f\u306e\u3060\u304b\u3089\u300d\n\nWith inline furigana (parenthetical):\n\u300c\u4eba(\u3072\u3068)\u3068\u3057\u3066\u4e00\u756a(\u3044\u3061\u3070\u3093)\u5927\u5207(\u305f\u3044\u305b\u3064)\u306a\u3082\u306e\u3092\u5931(\u3046\u3057\u306a)\u3063\u305f\u306e\u3060\u304b\u3089\u300d\n```\n\n**Technical Challenges**:\n\n1. **Text Data Format**\n\n   - Current: `\u4eba\u3068\u3057\u3066\u4e00\u756a\u5927\u5207\u306a\u3082\u306e`\n   - Required: `\u4eba{\u3072\u3068}\u3068\u3057\u3066\u4e00\u756a{\u3044\u3061\u3070\u3093}\u5927\u5207{\u305f\u3044\u305b\u3064}\u306a\u3082\u306e`\n   - Need markup system associating furigana with kanji\n\n2. **Rendering Architecture**\n\n   - Current: Single line, fixed height\n   - Required: Two rendering layers (kanji + furigana above)\n   - Dual font sizes (main 24px, furigana 12px)\n\n3. **Window Sizing**\n   - Dialog boxes need extra vertical space\n   - Line height calculations must account for furigana layer\n   - All game windows affected (menus, battles, field)\n\n**Implementation Approaches**:\n\n**Approach A: Inline Furigana (Recommended Start)**\n\n```\nDisplay: \u6f22\u5b57(\u304b\u3093\u3058)\nPros: Minimal rendering changes, works with current text system\nCons: Uses horizontal space, not traditional appearance\nEffort: 3-6 weeks\n```\n\n**Approach B: Proper Vertical Furigana (Advanced)**\n\n```\nDisplay:  \u304b\u3093\u3058\n         \u6f22\u5b57\nPros: Authentic Japanese typography\nCons: Complete rendering overhaul, complex positioning\nEffort: 2-3 months\n```\n\n**Approach C: Toggle System (Flexible)**\n\n```\nDefault: Japanese without furigana (fluent readers)\nToggle ON: Inline furigana for learners\nToggle OFF: Clean kanji-only display\n```\n\n**Text File Source for Furigana**:\n\n- Manual annotation (extremely time-consuming)\n- MeCab/kuromoji morphological analyzer (auto-generate)\n- Existing furigana databases (if available)\n- Community contribution\n\n**Benefits**:\n\n- Essential for N4-N2 Japanese learners\n- Enables reading without constant dictionary lookup\n- Progressive learning (turn off as proficiency increases)\n- Could attract significant Japanese learning community interest\n\n---\n\n### Implementation Roadmap\n\n**Phase 1: Core Japanese Support** (CURRENT)\n\n- \u2705 Font texture loading (jafont_1-6.tex)\n- \u23f3 Double-byte encoding (Shift-JIS / 2,000+ kanji)\n- \u23f3 Character\u2192texture mapping system\n- \u23f3 FFNx driver modifications\n- **Deliverable**: Game displays Japanese text correctly\n\n**Phase 2: Language Toggle** (NEXT)\n\n- \u23f3 Dual language text file management\n- \u23f3 FFNx configuration for language selection\n- \u23f3 Runtime toggle (F9 key or similar)\n- **Deliverable**: Switch EN\u2194JA during gameplay\n\n**Phase 3: Furigana Support** (ADVANCED)\n\n- \u23f3 Text format with furigana markup\n- \u23f3 Inline furigana rendering (MVP)\n- \u23f3 Optional: Proper above-kanji rendering\n- \u23f3 Toggle on/off for user preference\n- **Deliverable**: Kanji with reading guides for learners\n\n**Phase 4: Polish & Distribution** (FUTURE)\n\n- 7th Heaven mod packaging\n- User documentation / tutorial\n- Community feedback integration\n- Performance optimization\n\n---\n\n### Target User Personas\n\n**Persona 1: Japanese Language Learner (N4-N2)**\n\n- Knows hiragana/katakana\n- Learning kanji (500-1,000 known)\n- Needs furigana for unknown kanji\n- Uses EN\u2194JA toggle to check comprehension\n\n**Persona 2: Heritage Speaker / Returning Learner**\n\n- Can read some Japanese but rusty\n- Uses furigana occasionally\n- Prefers Japanese text but switches to English for complex scenes\n\n**Persona 3: Japanese Native Playing English**\n\n- Wants to see original Japanese dialogue\n- No furigana needed\n- Language toggle for localization comparison\n\n**Persona 4: FF7 Fan Learning Japanese**\n\n- Knows FF7 story in English\n- Uses familiar context to learn Japanese\n- Game nostalgia + language study motivation\n\n---\n\n### Unique Value Proposition\n\n**\"FF7 Japanese Learning Edition\"** would be the **first classic JRPG** to offer:\n\n1. \u2705 Full Japanese text with 2,000+ kanji (not hiragana-only)\n2. \u2705 Built-in cheat modes to reduce grinding\n3. \u23f3 Runtime EN\u2194JA language switching\n4. \u23f3 Furigana reading guides for kanji learners\n5. \u2705 Beloved story users already know\n\n**Market**: Japanese learners, heritage speakers, localization enthusiasts, FF7 fans\n\nThis could become a **viral tool** in Japanese learning communities (JapanesePod101, WaniKani, Tofugu, etc.) and bring new attention to FF7 modding.\n\n---\n\n---\n\n**MAJOR REVELATION**: User's Japanese eStore version contains **ALL 4 LANGUAGES**:\n\n- English (EN)\n- Japanese (JA)\n- Spanish (ES)\n- German (DE)\n\n**Installation Files**:\n\n- `ff7int-jp.exe` (691 KB) - Installer executable\n- `ff7int-jp-1.bin` (2 GB) - Installation archive part 1\n- `ff7int-jp-2.bin` (807 MB) - Installation archive part 2\n- **Total**: ~2.8 GB compressed\n\n**Status**: Files NOT YET INSTALLED - user has installation archives only\n\n**Critical Implication**: Square Enix's implementation may already include:\n\n- Multi-language font loading infrastructure\n- Language selection mechanism\n- Text switching between languages\n- **THIS IS EXACTLY WHAT WE NEED!**\n\n**Next Step**: Install game to extract actual files and analyze directory structure\n\n---\n\n**Document Status**: Active Research - Multi-Language Discovery Phase\n**Next Update**: After game installation and directory structure analysis\n**Maintainer**: Project Team\n**Session 6 Status**: Multi-language support discovered, installation pending\n**CRITICAL NEXT STEP**:\n\n1. Install ff7int-jp.exe to extract game files\n2. Document directory structure (all 4 languages)\n3. Extract ALL language font files (menu\\_\\*.lgp)\n4. Analyze Square Enix's language selection mechanism\n\n---\n\n**Session ID**: `1021bc57-9aa2-41fe-baad-a6b89b252744`\n\n**BREAKTHROUGH DISCOVERY: 5-LANGUAGE INTERNATIONAL RELEASE!**\n\nThe installed game at `/Volumes/KIOXIAwhite/FF7` contains **5 complete language packs**, not 4:\n\n1. **English (EN)** - ff7_en.exe (23.8MB)\n2. **Japanese (JA)** - ff7_ja.exe (23.8MB)\n3. **French (FR)** - ff7_fr.exe (23.8MB) \u2190 **NOT PREVIOUSLY DOCUMENTED!**\n4. **German (DE)** - ff7_de.exe (23.8MB)\n5. **Spanish (ES)** - ff7_es.exe (23.8MB)\n\n**Key Files Discovered**:\n\n- `FF7_Launcher.exe` (18.8MB) - Qt-based language selector UI\n- `lang.ini` (283KB) - DRM configuration (UTF-16 encoded)\n- `ff7_gamebooster.pdf` - Documents built-in cheat/booster modes\n- `Manual_FF7INT.pdf` - International version manual\n- `EULA_FF7INT_JP.pdf` - Japanese EULA\n\n---\n\n### Complete Directory Structure Analysis\n\n```\n/Volumes/KIOXIAwhite/FF7/\n\u251c\u2500\u2500 EXECUTABLES (5 language-specific + launcher)\n\u2502   \u251c\u2500\u2500 FF7_Launcher.exe      (18.8MB - language selector)\n\u2502   \u251c\u2500\u2500 ff7_en.exe            (23.8MB - English executable)\n\u2502   \u251c\u2500\u2500 ff7_ja.exe            (23.8MB - Japanese executable)\n\u2502   \u251c\u2500\u2500 ff7_fr.exe            (23.8MB - French executable)\n\u2502   \u251c\u2500\u2500 ff7_de.exe            (23.8MB - German executable)\n\u2502   \u2514\u2500\u2500 ff7_es.exe            (23.8MB - Spanish executable)\n\u2502\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 menu/                  # FONT TEXTURES (CRITICAL!)\n\u2502   \u2502   \u251c\u2500\u2500 menu_us.lgp       (1.7MB - English fonts, 1998)\n\u2502   \u2502   \u251c\u2500\u2500 menu_ja.lgp       (26.8MB - Japanese fonts, 2013) \u2190 15\u00d7 LARGER!\n\u2502   \u2502   \u251c\u2500\u2500 menu_fr.lgp       (1.7MB - French fonts, 1998)\n\u2502   \u2502   \u251c\u2500\u2500 menu_gm.lgp       (1.7MB - German fonts, 1998)\n\u2502   \u2502   \u2514\u2500\u2500 menu_sp.lgp       (1.7MB - Spanish fonts, 1998)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 field/                 # DIALOGUE ARCHIVES (ALL 5 LANGUAGES!)\n\u2502   \u2502   \u251c\u2500\u2500 flevel.lgp        (122MB - English dialogues)\n\u2502   \u2502   \u251c\u2500\u2500 jfleve.lgp        (123MB - Japanese dialogues) \u2190 NOTE TYPO!\n\u2502   \u2502   \u251c\u2500\u2500 fflevel.lgp       (123MB - French dialogues)\n\u2502   \u2502   \u251c\u2500\u2500 gflevel.lgp       (122MB - German dialogues)\n\u2502   \u2502   \u251c\u2500\u2500 sflevel.lgp       (122MB - Spanish dialogues)\n\u2502   \u2502   \u2514\u2500\u2500 char.lgp          (47MB - character models, shared)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 lang-ja/              # Japanese-specific assets\n\u2502   \u2502   \u251c\u2500\u2500 battle/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 scene.bin     (270KB - battle text/AI)\n\u2502   \u2502   \u251c\u2500\u2500 kernel/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 KERNEL.BIN    (20KB - game text/data)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 kernel2.bin   (12KB - additional text)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 WINDOW.BIN    (13KB - window graphics)\n\u2502   \u2502   \u2514\u2500\u2500 movies/\n\u2502   \u2502       \u251c\u2500\u2500 Ending2.avi   (varies - localized ending)\n\u2502   \u2502       \u2514\u2500\u2500 jenova_e.avi  (localized cutscene)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 lang-en/              # English-specific assets (same structure)\n\u2502   \u251c\u2500\u2500 lang-fr/              # French-specific assets\n\u2502   \u251c\u2500\u2500 lang-de/              # German-specific assets (de folder, gm files)\n\u2502   \u251c\u2500\u2500 lang-es/              # Spanish-specific assets\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 wm/                   # World map (language-specific text)\n\u2502   \u2502   \u251c\u2500\u2500 world_us.lgp      (3.0MB - English world text)\n\u2502   \u2502   \u251c\u2500\u2500 world_ja.lgp      (3.0MB - Japanese world text)\n\u2502   \u2502   \u251c\u2500\u2500 world_fr.lgp      (3.0MB - French world text)\n\u2502   \u2502   \u251c\u2500\u2500 world_gm.lgp      (3.0MB - German world text)\n\u2502   \u2502   \u2514\u2500\u2500 world_sp.lgp      (3.0MB - Spanish world text)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 cd/                   # Credits and disc info (per language)\n\u2502   \u2502   \u251c\u2500\u2500 cr_us.lgp, cr_fr.lgp, cr_gm.lgp, cr_sp.lgp\n\u2502   \u2502   \u2514\u2500\u2500 disc_us.lgp, disc_fr.lgp, disc_gm.lgp, disc_sp.lgp\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 battle/               # Shared battle assets (language-neutral)\n\u2502   \u251c\u2500\u2500 midi/                 # Music files\n\u2502   \u251c\u2500\u2500 movies/               # FMV sequences\n\u2502   \u251c\u2500\u2500 music/                # Soundtrack\n\u2502   \u251c\u2500\u2500 music_ogg/            # OGG format music\n\u2502   \u251c\u2500\u2500 sound/                # Sound effects\n\u2502   \u251c\u2500\u2500 minigame/             # Mini-game assets\n\u2502   \u2514\u2500\u2500 xarch/                # Extra archives (.fgt files)\n\u2502\n\u2514\u2500\u2500 371 total files, 34 directories\n```\n\n---\n\n### Language Selection Mechanism (CRITICAL FINDING)\n\n**Architecture**: The launcher uses a **Qt-based GUI** to select language, then launches the appropriate executable.\n\n**Key Strings Found in FF7_Launcher.exe**:\n\n```cpp\n// UI Elements (Qt)\nQPushButton#languageBtn        // Language selection button\nQRadioButton#englishBtn        // English radio button\nQRadioButton#japaneseBtn       // Japanese radio button\nlanguageBtnClicked()           // Selection handler\nshowLanguageSettings()         // Settings display function\n\n// Language Mapping\nFF7_EN.exe                     // Executable paths\nlang-en/                       // Language data directory\nLanguage                       // Configuration key\nlang.dat                       // User's language preference storage\n\n// Launcher Communication\nff7_sharedMemoryWithLauncher   // IPC mechanism\nff7_gameDidReadMsgSem          // Semaphore for game\u2192launcher\nff7_launcherDidReadMsgSem      // Semaphore for launcher\u2192game\n```\n\n**Selection Flow**:\n\n1. User launches `FF7_Launcher.exe`\n2. Launcher presents language selection (Qt radio buttons)\n3. User selects language (e.g., Japanese)\n4. Launcher saves selection to `lang.dat`\n5. Launcher executes `ff7_ja.exe`\n6. Executable loads data from `lang-ja/` and `menu_ja.lgp`\n\n**IMPLICATION FOR OUR PROJECT**: Square Enix has **ALREADY SOLVED** multi-language selection! We can:\n\n- Study their launcher source patterns\n- Reuse their file organization scheme\n- Extend their system for runtime switching (they use launch-time selection)\n\n---\n\n### Critical Technical Insights\n\n#### Japanese Font Archive Size Difference\n\n**menu_ja.lgp = 26.8MB (26,872,760 bytes)**\n**menu_us.lgp = 1.7MB (1,705,214 bytes)**\n\n**Ratio**: Japanese is **15.76\u00d7 larger**!\n\n**Why?** Japanese requires 6 font texture files (jafont_1-6.tex) to store 2,000+ kanji, hiragana, and katakana. English only needs single texture for 256 ASCII characters.\n\nThis confirms our earlier research: Japanese font support requires MASSIVE additional texture data compared to single-byte languages.\n\n#### File Naming Conventions\n\n**Interesting Discoveries**:\n\n- Japanese field dialogue: `jfleve.lgp` (typo - missing 'l' in flevel)\n- German uses inconsistent codes: folder = `lang-de`, file = `menu_gm.lgp`\n- Spanish: folder = `lang-es`, file = `menu_sp.lgp`\n- English: folder = `lang-en`, file = `menu_us.lgp`\n- French: folder = `lang-fr`, file = `menu_fr.lgp`\n\n**Implication**: File naming is historical artifact from 1998 development. Not perfectly consistent, but predictable.\n\n#### KERNEL.BIN Size Differences\n\n| Language | KERNEL.BIN Size | Notes                |\n| -------- | --------------- | -------------------- |\n| Japanese | 20KB            | Double-byte encoding |\n| English  | 22KB            | Single-byte encoding |\n| German   | 22KB            | Single-byte encoding |\n| Spanish  | 21KB            | Single-byte encoding |\n\nJapanese KERNEL.BIN is **smaller** despite having more complex text because Shift-JIS (double-byte) is more efficient for Japanese than ASCII representation would be.\n\n---\n\n### Next Steps for Session 8\n\n1. **Extract menu_ja.lgp Contents**\n\n   - Use ulgp (requires Wine on macOS or transfer to Windows)\n   - Verify jafont_1-6.tex files exist\n   - Document file count and names\n\n2. **Convert jafont\\_\\*.tex to PNG**\n\n   - Use Tex Tools or Image2TEX (Windows)\n   - Analyze glyph layout and organization\n   - Measure glyph dimensions (32\u00d732? 48\u00d748?)\n\n3. **Analyze Character Mapping**\n\n   - How are characters ordered in each texture?\n   - Frequency-based? Unicode block? JIS order?\n   - Create character\u2192texture index mapping\n\n4. **Extract and Compare KERNEL.BIN**\n\n   - Hex dump Japanese vs English\n   - Identify text encoding differences\n   - Document Shift-JIS byte sequences\n\n5. **Research FFNx Runtime Language Switching**\n   - FFNx can override textures\n   - Can it switch texture sets at runtime?\n   - Hot-swap language without restart?\n\n---\n\n### Key Discoveries Summary\n\n| Discovery                  | Impact                                  | Status       |\n| -------------------------- | --------------------------------------- | ------------ |\n| 5-language support (not 4) | Scope expansion - French included       | \u2705 Confirmed |\n| menu_ja.lgp = 26.8MB       | Japanese fonts exist and are massive    | \u2705 Confirmed |\n| Qt-based language selector | Can study/extend for runtime switching  | \u2705 Analyzed  |\n| Per-language executables   | Each language is self-contained         | \u2705 Confirmed |\n| lang-\\*/ directories       | Text data separated per language        | \u2705 Confirmed |\n| jfleve.lgp filename typo   | Historical artifact, no technical issue | \u2705 Noted     |\n\n---\n\n---\n\n### Japanese Font Texture Size Analysis (LGP Header Examination)\n\n**Method**: Hex dump of menu_ja.lgp header to extract file offsets\n\n**CONFIRMED**: All 6 jafont textures exist in the archive:\n\n| File         | Offset (bytes) | Size (bytes) | Size (MB) |\n| ------------ | -------------- | ------------ | --------- |\n| jafont_1.tex | 1,047,414      | ~4,194,564   | 4.00      |\n| jafont_2.tex | 5,241,978      | ~4,194,564   | 4.00      |\n| jafont_3.tex | 9,436,542      | ~4,194,562   | 4.00      |\n| jafont_4.tex | 13,631,104     | ~4,194,560   | 4.00      |\n| jafont_5.tex | 17,825,664     | ~4,194,560   | 4.00      |\n| jafont_6.tex | 22,020,224     | ~4,852,536   | 4.63      |\n\n**Key Insights**:\n\n- Each texture is exactly ~4MB (4,194,560 bytes)\n- This matches 2048\u00d72048 texture with palette-based compression\n- jafont_6.tex is slightly larger (4.63MB) - may contain metadata or index table\n- Total font data: ~25MB for Japanese vs ~1.7MB for English (15\u00d7 larger)\n- LGP format confirmed: \"SQUARESOFT8\" header, standard archive structure\n\n**Character Capacity Estimation**:\n\n- If 32\u00d732 glyphs with 2px padding: (2048/34)\u00b2 = 60\u00b2 = 3,600 chars/texture\n- 6 textures \u00d7 3,600 = **21,600 total characters** (more than enough!)\n- If 48\u00d748 glyphs with 2px padding: (2048/50)\u00b2 = 41\u00b2 = 1,681 chars/texture\n- 6 textures \u00d7 1,681 = **10,086 total characters** (still sufficient)\n\nThis confirms the textures can hold all 2,136 J\u014dy\u014d kanji plus hiragana, katakana, and punctuation with room to spare.\n\n---\n\n---\n\n### BREAKTHROUGH: Hardcoded Language Paths in Executables\n\n**Method**: String extraction from ff7_ja.exe vs ff7_en.exe\n\n**DISCOVERY**: Each language executable has **hardcoded asset paths**!\n\n**ff7_ja.exe contains:**\n\n```\nfield/jfleve.lgp      \u2190 Japanese dialogues\nmenu/menu_ja.lgp      \u2190 Japanese font textures (jafont_1-6.tex)\nwm/world_ja.lgp       \u2190 Japanese world map text\nlang-ja/kernel/       \u2190 Japanese KERNEL.BIN (gzip compressed)\n```\n\n**ff7_en.exe contains:**\n\n```\nfield/flevel.lgp      \u2190 English dialogues\nmenu/menu_us.lgp      \u2190 English font textures (USFONT_*.tex)\nwm/world_us.lgp       \u2190 English world map text\nlang-en/kernel/       \u2190 English KERNEL.BIN\n```\n\n**CRITICAL IMPLICATION**:\n\n1. **Square Enix ALREADY implemented double-byte character support** in ff7_ja.exe!\n2. The character\u2192texture mapping algorithm **is baked into the Japanese executable**\n3. **We don't need to reverse-engineer the font rendering** - it already works!\n4. **paul.dll is just DRM** (692KB), not a graphics driver\n\n**This Changes Everything**:\n\n- Previous assumption: Need to modify FFNx to add Japanese font rendering\n- **New reality**: Japanese font rendering ALREADY EXISTS in ff7_ja.exe\n- FFNx can potentially **intercept and redirect** asset loading paths\n- OR: Study ff7_ja.exe to understand the mapping algorithm, then replicate in FFNx\n\n**Note**: All 5 executables are exactly 23MB - compiled from same source with different constants.\n\n---\n\n### AF3DN.P - THE CUSTOM JAPANESE GRAPHICS DRIVER (FOUND!)\n\n**File**: `/Volumes/KIOXIAwhite/FF7/AF3DN.P`\n**Size**: 317KB (324,096 bytes)\n**Type**: PE32 DLL (Windows graphics driver)\n**Date**: April 16, 2013\n\n**THIS IS THE ENGINE OUR RESEARCH MENTIONED!** Square Enix's customized AF3DN.P driver that supports Japanese fonts.\n\n**Critical Strings Found Inside**:\n\n```\njafont_1.tim          \u2190 Japanese font texture 1\njafont_2.tim          \u2190 Japanese font texture 2\njafont_3.tim          \u2190 Japanese font texture 3\njafont_4.tim          \u2190 Japanese font texture 4\njafont_5.tim          \u2190 Japanese font texture 5\njafont_6.tim          \u2190 Japanese font texture 6\nMultiByteToWideChar   \u2190 Windows API for double-byte conversion!\nWideCharToMultiByte   \u2190 Windows API for double-byte conversion!\nD3DXCreateFontW       \u2190 DirectX font creation (Wide/Unicode)\nD3DXCreateTextureFromFileA  \u2190 DirectX texture loading\nMODE_MAIN_MENU        \u2190 Menu system modes\nMODE_BATTLE_MENU\nMODE_MENU\nIngameTextPayload     \u2190 Text rendering data structure\ntexture_flag          \u2190 Texture state management\n```\n\n**Build Path Found**:\n\n```\nC:\\FF7\\src\\menu\\English\\loadmenu.cpp\n```\n\nThis reveals Square Enix's source code structure! The driver was built from FF7 source with Japanese extensions.\n\n**Why This Matters**:\n\n1. **CONFIRMS our research**: The eStore version uses a **completely customized AF3DN.P driver**\n2. **Font loading is hardcoded**: jafont_1.tim through jafont_6.tim strings embedded in DLL\n3. **Double-byte support exists**: Uses Windows MultiByteToWideChar/WideCharToMultiByte APIs\n4. **Source path visible**: Shows actual Square Enix build environment\n\n**Key Technical Insights**:\n\n1. Uses `.tim` extension internally (PlayStation TIM format), not `.tex`\n2. DirectX 9 based (D3DX functions)\n3. Font creation uses Unicode-aware function (`D3DXCreateFontW` - the 'W' means Wide/Unicode)\n4. Menu system has multiple modes with text rendering\n5. `IngameTextPayload` structure handles text display\n\n**Comparison to Standard FF7**:\n\n- Standard Steam AF3DN.P: Smaller, single-byte font only\n- eStore Japanese AF3DN.P: **317KB with 6-font loader and double-byte support**\n\n**Research Validation**: This confirms julianxhokaxhiu's quote from Session 4:\n\n> \"Square-Enix did release an eStore Japanese edition... they had to customize completely the driver... the eStore release has a bigger stock AF3DN.P driver, which has the code to inject into the font system.\"\n\n**NEXT STEPS**:\n\n1. Reverse-engineer AF3DN.P to understand jafont_X.tim loading mechanism\n2. Extract character\u2192texture mapping algorithm from driver\n3. Compare to FFNx source to understand integration points\n4. Potentially use this driver directly with FFNx, or port the logic\n\n---\n\n---\n\n### COMPREHENSIVE FILE AUDIT - ALL CRITICAL ASSETS IDENTIFIED\n\n**Method**: Systematic search of `/Volumes/KIOXIAwhite/FF7/` directory tree\n\n#### HIGH IMPACT FILES (Must Preserve/Analyze)\n\n| File                          | Size   | Purpose                | Critical Insights                                                |\n| ----------------------------- | ------ | ---------------------- | ---------------------------------------------------------------- |\n| **AF3DN.P**                   | 317KB  | Custom graphics driver | jafont_1-6.tim loader, MultiByteToWideChar double-byte support   |\n| **menu_ja.lgp**               | 26.8MB | Japanese font archive  | 6\u00d7 jafont\\_\\*.tex files (~4MB each), 15\u00d7 larger than English     |\n| **ff7_ja.exe**                | 23MB   | Japanese executable    | Hardcoded: menu_ja.lgp, jfleve.lgp, world_ja.lgp paths           |\n| **jfleve.lgp**                | 123MB  | Japanese dialogues     | Complete field text (note filename typo: \"jfleve\" not \"jflevel\") |\n| **world_ja.lgp**              | 3MB    | World map text         | Japanese location names and labels                               |\n| **lang-ja/kernel/KERNEL.BIN** | 20KB   | Game text data         | Gzip compressed Shift-JIS encoded text                           |\n| **lang-ja/battle/scene.bin**  | 270KB  | Battle text/AI         | Enemy names, attack names in Japanese                            |\n| **condorj.lgp**               | 3.5MB  | Fort Condor minigame   | ONLY Japanese-specific minigame asset found                      |\n\n#### MEDIUM IMPACT FILES (Supporting Infrastructure)\n\n| File                     | Size      | Purpose             | Notes                                                          |\n| ------------------------ | --------- | ------------------- | -------------------------------------------------------------- |\n| **strings.dat**          | 175KB     | Launcher UI strings | Contains DIK_KANJI (Japanese IME key code), HTML/Qt resources  |\n| **FF7_Launcher.exe**     | 18MB      | Language selector   | Qt-based GUI with englishBtn/japaneseBtn radio buttons         |\n| **ff7\\_\\*.exe.manifest** | 1.3KB ea. | Windows manifests   | Version 1.0.7.0, SquareEnix.FINALFANTASYVII assembly identity  |\n| **ff7_gamebooster.pdf**  | 161KB     | Cheat documentation | Built-in booster modes already available!                      |\n| **paul.dll**             | 692KB     | DRM/Launcher        | Digital software services authentication (NOT graphics driver) |\n| **lang.ini**             | 283KB     | DRM config          | UTF-16 encoded launcher settings, not language selection       |\n\n#### MISSING JAPANESE ASSETS (Interesting Gaps)\n\nFiles that DON'T exist for Japanese but do for other languages:\n\n| Expected File    | Actual Behavior       | Notes                             |\n| ---------------- | --------------------- | --------------------------------- |\n| cr_ja.lgp        | Uses cr_us.lgp        | Credits shown in English          |\n| disc_ja.lgp      | Uses disc_us.lgp      | Disc info in English              |\n| high-ja.lgp      | Uses high-us.lgp      | Highwind minigame text in English |\n| snowboard-ja.lgp | Uses snowboard-us.lgp | Snowboard minigame in English     |\n| chocobo_ja.lgp   | Uses chocobo.lgp      | Chocobo breeding shared           |\n\n**Implication**: Not all game text was localized to Japanese. Minigames except Fort Condor use English text.\n\n#### FILE ORGANIZATION PATTERNS\n\n**Language-Specific Executables** (all ~23MB, compiled from same source):\n\n- ff7_en.exe \u2192 field/flevel.lgp, menu/menu_us.lgp, wm/world_us.lgp\n- ff7_ja.exe \u2192 field/jfleve.lgp, menu/menu_ja.lgp, wm/world_ja.lgp\n- ff7_fr.exe \u2192 field/fflevel.lgp, menu/menu_fr.lgp, wm/world_fr.lgp\n- ff7_de.exe \u2192 field/gflevel.lgp, menu/menu_gm.lgp, wm/world_gm.lgp\n- ff7_es.exe \u2192 field/sflevel.lgp, menu/menu_sp.lgp, wm/world_sp.lgp\n\n**Font Archive Sizes**:\n\n```\nmenu_us.lgp = 1.7MB (English - single texture)\nmenu_ja.lgp = 26.8MB (Japanese - 6 textures) \u2190 15.76\u00d7 LARGER!\nmenu_fr.lgp = 1.7MB (French - single texture)\nmenu_gm.lgp = 1.7MB (German - single texture)\nmenu_sp.lgp = 1.7MB (Spanish - single texture)\n```\n\n**Kernel/Text Data Sizes** (lang-\\*/kernel/KERNEL.BIN):\n\n```\nJapanese: 20KB (double-byte compressed)\nEnglish:  22KB (single-byte)\nGerman:   22KB (single-byte)\nSpanish:  21KB (single-byte)\nFrench:   [check pending]\n```\n\n#### TOTAL FILE COUNT\n\n```\n/Volumes/KIOXIAwhite/FF7/\n\u251c\u2500\u2500 371 total files\n\u251c\u2500\u2500 34 directories\n\u251c\u2500\u2500 5 language executables\n\u251c\u2500\u2500 5 font archives\n\u251c\u2500\u2500 5 field dialogue archives\n\u251c\u2500\u2500 5 world map archives\n\u251c\u2500\u2500 5 language-specific kernel directories\n\u2514\u2500\u2500 1 custom AF3DN.P graphics driver (THE KEY!)\n```\n\n---\n\n### SESSION 7 SUMMARY: MAJOR BREAKTHROUGHS\n\n**What We Discovered**:\n\n1. \u2705 **5-Language International Release** (not 4!) - Includes French\n2. \u2705 **AF3DN.P Custom Driver Found** - Square Enix's Japanese font injection engine\n3. \u2705 **jafont_1-6.tim Hardcoded** - Font loading strings in driver DLL\n4. \u2705 **Double-byte Support Built-in** - MultiByteToWideChar/WideCharToMultiByte APIs\n5. \u2705 **Hardcoded Asset Paths** - Each executable knows its language files\n6. \u2705 **DirectX 9 Unicode Fonts** - D3DXCreateFontW (Wide character support)\n7. \u2705 **All Japanese Assets Present** - menu_ja.lgp, jfleve.lgp, world_ja.lgp, kernel\n8. \u2705 **Font Texture Sizes Confirmed** - Each jafont\\_\\*.tex is ~4MB (2048\u00d72048)\n\n**What This Means**:\n\n- **The hardest problem is ALREADY SOLVED** - Square Enix implemented Japanese rendering\n- **AF3DN.P is the reference implementation** we need to study\n- **FFNx can potentially work WITH this driver** (hybrid approach)\n- **Or we can port the algorithm to FFNx** (requires reverse engineering)\n- **Runtime language toggle is feasible** - just need to swap asset paths\n\n---\n\n**Session 7 Final Status**: COMPREHENSIVE ANALYSIS COMPLETE\n**Critical Discovery**: AF3DN.P (317KB) = Japanese font injection engine with double-byte support\n**All Assets Located**: menu_ja.lgp, jfleve.lgp, world_ja.lgp, KERNEL.BIN, scene.bin, condorj.lgp\n**Key Technical Insight**: Japanese rendering is PRODUCTION-READY in Square Enix's implementation\n\n**Next Session Priorities**:\n\n1. Reverse-engineer AF3DN.P font loading algorithm (IDA/Ghidra)\n2. Extract and visualize jafont\\_\\*.tex character layout\n3. Research FFNx + AF3DN.P compatibility\n4. Document character\u2192texture mapping system\n5. Test running ff7_ja.exe with FFNx overlay\n\n**Platform Note**: Development on macOS; need Windows or Wine for FF7 execution and tool usage\n\n---\n\n**Session Focus**: Reverse-engineering AF3DN.P and understanding the font system at the binary level\n\n---\n\n### 1. PE STRUCTURE ANALYSIS SUCCESS\n\nUsing objdump and custom Python PE parser, extracted critical information:\n\n**AF3DN.P Export Functions (11 total)**:\n\n```\n1. new_dll_graphics_driver     \u2190 MAIN ENTRY POINT!\n2. dotemuRegCloseKey           \u2190 Registry wrapper\n3. dotemuRegDeleteValueA       \u2190 Registry wrapper\n4. dotemuRegOpenKeyExA         \u2190 Registry wrapper\n5. dotemuRegQueryValueExA      \u2190 Registry wrapper\n6. dotemuRegSetValueExA        \u2190 Registry wrapper\n(Plus 5 underscore-decorated versions)\n```\n\n**Key Import Dependencies**:\n\n- `d3dx9_29.dll` (DirectX 9 August 2007)\n- `D3DXCreateTextureFromFileA` - Load font textures\n- `D3DXCreateFontW` - Create Unicode-aware fonts\n- `MultiByteToWideChar` - Shift-JIS to Unicode conversion\n- `libvgmstream.dll` - Audio playback\n- `avcodec-53.dll` / `avformat-53.dll` - FFmpeg libraries\n\n**DotEmu Connection**: DotEmu (company that ported FF7) created registry wrappers to allow Japanese-specific settings without modifying Windows Registry directly.\n\n---\n\n### 2. FONT TEXTURE EXTRACTION SUCCESS\n\n**All 6 jafont\\_\\*.tex files successfully extracted and converted to PNG!**\n\n**Command used**: Custom Python LGP extractor \u2192 TEX header parser \u2192 Pillow PNG converter\n\n**TEX File Format Specifications**:\n\n```\nHeader Size:        236 bytes (0xEC)\nImage Dimensions:   1024\u00d71024 pixels (NOT 2048\u00d72048!)\nBit Depth:          32-bit RGBA (no palette)\nColor Format:       BGRA byte order\nFile Size:          4,194,540 bytes each\nTotal Capacity:     6 \u00d7 1,048,576 pixels = 6,291,456 pixels\n```\n\n**Character Grid Layout**:\n\n```\nGrid Size:          16\u00d716 per texture (256 slots)\nGlyph Size:         64\u00d764 pixels each\nTotal Slots:        6 \u00d7 256 = 1,536 character positions\nActual Characters:  ~2,808 estimated (based on fill analysis)\n```\n\n**Fill Percentage Analysis**:\n| Texture | Fill % | Est. Chars | Content |\n|---------|--------|------------|---------|\n| jafont_1 | 32.3% | ~282 | Kana, numbers, Latin, symbols |\n| jafont_2 | 54.9% | ~479 | Common kanji (game terms) |\n| jafont_3 | 65.7% | ~574 | More kanji |\n| jafont_4 | 57.1% | ~498 | More kanji |\n| jafont_5 | 55.6% | ~486 | More kanji |\n| jafont_6 | 56.0% | ~489 | More kanji |\n\n---\n\n### 3. CRITICAL DISCOVERY: GAME-SPECIFIC CHARACTER ORDER\n\n**MAJOR FINDING**: Characters are NOT in JIS X 0208 order!\n\n**jafont_1.tex Contains (in order)**:\n\n- Rows 0-3: Dakuten/Handakuten katakana (\u30d0\u30d3\u30d6\u30d9\u30dc, \u30ac\u30ae\u30b0\u30b2\u30b4, etc.)\n- Row 4: More katakana + Numbers 0-9\n- Rows 5-8: Hiragana and basic katakana\n- Row 9-10: Extended kana + punctuation\n- Row 11-12: Latin alphabet A-Z\n- Row 13-14: Symbols (\u2015\uff5e\u2026%/:&\u3010\u3011\u2192\u03b1\u03b2\u300c\u300d)\n- Last visible: XIII (logo)\n\n**jafont_2.tex Contains (first 2 rows)**:\n\n```\nRow 0: \u5fc5\u6bba\u6280\u5730\u7344\u706b\u708e\u6226\u96f7\u5927\u6012\u65ac\u9244\u5263\u9b54\u6d77\nRow 1: \u885d\u8056\u5be9\u5224\u8ee2\u751f\u6539\u6697\u9ed2\u91d1\u5929\u5d29\u58ca\u96f6\u5f0f\u81ea\n```\n\nThese are **GAME-SPECIFIC SKILL AND BATTLE TERMS**, not standard kanji ordering!\n\n**Implication**: Square Enix arranged characters by **game usage frequency**, not by JIS code. This is a custom ordering specific to FF7.\n\n---\n\n### 4. FF7 TEXT ENCODING SYSTEM FULLY DECODED\n\n**Research Source**: Qhimm Forums and wiki (ffrtt.ru)\n\n**Key Discovery**: FF7 does NOT use Shift-JIS directly!\n\n**Encoding Scheme**:\n\n```\n00-E6    Single-byte direct character index\nE7       New line\nE8       New screen\nE9       New screen variant\nEA-EF    Character name placeholders ({Cloud}, {Tifa}, etc.)\nF0-F5    Party member names\nF6       Circle button (\u3007)\nF7       Triangle button (\u25b3)\nF8       Square button (\u2610)\nF9       Cross button (\u2715)\nFA XX    Extended page 1 (jafont_2) - kanji set 1\nFB XX    Extended page 2 (jafont_3) - kanji set 2\nFC XX    Extended page 3 (jafont_4) - kanji set 3\nFD XX    Extended page 4 (jafont_5) - kanji set 4\nFE XX    Extended page 5 (jafont_6) - kanji set 5\nFF       End of dialog (terminator)\n```\n\n**Example Encoding**:\n\n```\nText: \"\u5fc5\u6bba\u6280\" (Special Technique)\nFF7 Internal: FA 00 FA 01 FA 02\n- FA = Use jafont_2\n- 00 = Position 0 (row 0, col 0) = \"\u5fc5\"\n- 01 = Position 1 (row 0, col 1) = \"\u6bba\"\n- 02 = Position 2 (row 0, col 2) = \"\u6280\"\n```\n\n**Position Formula**:\n\n```c\npixel_x = (index % 16) * 64;\npixel_y = (index / 16) * 64;\n```\n\n---\n\n### 5. TOOLS INSTALLED/CREATED\n\n**Homebrew Installation**:\n\n- Radare2 6.0.4 (reverse engineering framework)\n\n**Python Virtual Environment**:\n\n- `.venv/` - Created for image processing\n- Pillow - Installed for TEX to PNG conversion\n\n**Custom Scripts Created**:\n\n- PE header parser (extracted exports, imports, sections)\n- LGP file extractor (extracted jafont\\_\\*.tex from menu_ja.lgp)\n- TEX to PNG converter (converted all 6 textures to visual format)\n\n---\n\n### 6. FILES CREATED THIS SESSION\n\n**Extracted Assets**:\n\n```\nextracted_fonts/\n\u251c\u2500\u2500 jafont_1.tex (4,194,540 bytes)\n\u251c\u2500\u2500 jafont_2.tex (4,194,540 bytes)\n\u251c\u2500\u2500 jafont_3.tex (4,194,540 bytes)\n\u251c\u2500\u2500 jafont_4.tex (4,194,540 bytes)\n\u251c\u2500\u2500 jafont_5.tex (4,194,540 bytes)\n\u251c\u2500\u2500 jafont_6.tex (4,194,540 bytes)\n\u2514\u2500\u2500 png/\n    \u251c\u2500\u2500 jafont_1.png (1024\u00d71024 RGBA)\n    \u251c\u2500\u2500 jafont_2.png\n    \u251c\u2500\u2500 jafont_3.png\n    \u251c\u2500\u2500 jafont_4.png\n    \u251c\u2500\u2500 jafont_5.png\n    \u2514\u2500\u2500 jafont_6.png\n```\n\n**Documentation**:\n\n- `AF3DN_ANALYSIS.md` - Updated to v2.0.0 with Session 8 findings\n- `JAFONT_CHARACTER_MAP.md` - NEW! Complete encoding documentation\n- `FINDINGS.md` - This file (Session 8 section)\n\n---\n\n### 7. WHAT WE LEARNED ABOUT AF3DN.P\n\n1. **It's NOT a custom graphics engine** - It's a DirectX 9 wrapper\n2. **It's middleware** - Intercepts graphics, registry, and audio calls\n3. **DotEmu created it** - Company that ported FF7 to modern systems\n4. **Entry point is `new_dll_graphics_driver`** - Main initialization function\n5. **No character lookup table in binary** - Table is game-universal (not driver-specific)\n6. **Standard Windows APIs** - Uses MultiByteToWideChar, not custom encoding\n\n---\n\n### SESSION 8 SUMMARY: CHARACTER ENCODING MYSTERY SOLVED\n\n**What We Accomplished**:\n\n1. \u2705 **Installed Radare2** for advanced binary analysis\n2. \u2705 **Extracted all export/import functions** from AF3DN.P\n3. \u2705 **Successfully extracted all 6 jafont textures** from menu_ja.lgp\n4. \u2705 **Converted TEX to PNG** for visual character analysis\n5. \u2705 **Discovered game-specific character ordering** (not JIS)\n6. \u2705 **Fully decoded FF7 text encoding system** (FA-FE extended pages)\n7. \u2705 **Created comprehensive character map documentation**\n8. \u2705 **Determined position formula** for character rendering\n\n**Key Insights**:\n\n1. **FF7 uses its own encoding** - NOT Shift-JIS directly\n2. **Character indices map directly to texture positions** - Simple formula\n3. **Extended characters use 2-byte codes** (FA-FE + index)\n4. **No runtime lookup table needed** - Direct index calculation\n5. **This is why there's no Shift-JIS table in AF3DN.P** - The table is in game logic, not driver\n\n**What This Means for FFNx Integration**:\n\n- **Simpler than expected!** - Just need to support FA-FE extended character codes\n- **Texture loading is straightforward** - Already understood the TEX format\n- **Character positioning is calculable** - No complex lookup needed\n- **Runtime toggle is feasible** - Switch between English (00-E6) and Japanese (FA-FE) encoding\n\n---\n\n**Session 8 Final Status**: CHARACTER ENCODING FULLY UNDERSTOOD\n**Critical Discovery**: FF7 uses custom internal indices, NOT Shift-JIS\n**All Goals Achieved**: Extracted textures, decoded encoding, documented system\n**Major Breakthrough**: Direct index-to-position mapping discovered\n\n**Next Session (9) Priorities**:\n\n1. Complete visual mapping of all ~2,800 characters\n2. Create FF7 Index \u2194 Shift-JIS \u2194 Unicode conversion table\n3. Build translation/editing tool for mod creators\n4. Test FFNx texture replacement with jafont PNGs\n5. Prototype runtime language switching code\n6. Validate encoding against actual game dialogue files\n\n**Platform Success**: All analysis performed on macOS using native tools (Python, objdump, Pillow) and Homebrew (Radare2). No Windows/Wine required for this phase!\n\n---\n\n**Total Sessions**: 8\n**Total Research Hours**: ~16+ hours\n**URLs Scraped**: 38\n**Local Files Analyzed**: 20+\n**Critical Discoveries**: 35+\n**Documentation Files**: 6 (FINDINGS, AF3DN_ANALYSIS, JAFONT_CHARACTER_MAP, FEATURE_ROADMAP, TEST_PROCEDURE, TOOL_GUIDE)\n\n**Major Milestones**:\n\n- Session 1-3: Initial research, FFNx/GitHub discovery\n- Session 4-5: Deep dive into FFNx architecture\n- Session 6: Strategy formulation, eStore version confirmed\n- Session 7: File system exploration, AF3DN.P discovery\n- Session 8: **Character encoding fully decoded!**\n\n**Current Project State**: Ready for implementation prototyping!\n\n---\n\n# SESSION 9: OCR CHARACTER MAPPING (2025-11-17)\n\n**Session ID**: `1021bc57-9aa2-41fe-baad-a6b89b252744` (continued)\n**Platform**: macOS (analysis and development)\n**Focus**: Research validation + Automated character mapping\n\n---\n\n**Historical Achievement**: After 18 years of the FF7 modding community requesting a Japanese character table, Session 9 successfully created the **FIRST comprehensive mapping of FF7 Japanese characters to Unicode**.\n\n---\n\n### 1. PRE-IMPLEMENTATION RESEARCH\n\nBefore building the character mapping tool, extensive research verified no existing work.\n\n**Critical Finding**: **NO COMPLETE JAPANESE CHARACTER TABLE EXISTS**\n\nEvidence:\n\n1. **Qhimm Forum (2007)**: \"If someone can find the Japanese encoding for FF7, I'll write up a unicode table for it\" - halkun\n2. **touphScript (2023)**: Has English Chars.txt only, \"fails on Japanese input\"\n3. **FFRTT Wiki**: English encoding table only (00-D4), no FA-FE pages documented\n4. **Micky's 2007 quote**: \"Get somebody who can read Kanji to look at the font texture\" - exactly our approach!\n\n---\n\n### 2. TOOLS INSTALLED\n\n**Homebrew**:\n\n- `tesseract-lang` - Japanese OCR language pack (165 files, 685.7MB)\n\n**Python (in .venv)**:\n\n- `pytesseract` - Python wrapper for Tesseract OCR\n\n---\n\n### 3. OCR MAPPING RESULTS\n\n**File Created**: `scripts/ocr_jafont_mapper.py`\n\n**Processing Statistics**:\n\n| Metric                 | Value                    |\n| ---------------------- | ------------------------ |\n| Total character slots  | 1,536 (6 textures \u00d7 256) |\n| Characters recognized  | 1,283 (83.5% occupancy)  |\n| High confidence (\u226570%) | 623 (48.6%)              |\n| Low confidence (<70%)  | 660 (needs review)       |\n| Empty slots            | 253 (16.5%)              |\n\n**Output Files Generated** (in `character_tables/`):\n\n- `character_map.json` - 256KB, complete FF7\u2192Unicode mapping\n- `character_map.csv` - 63KB, spreadsheet format\n- `ocr_confidence.json` - 138KB, confidence scores\n\n---\n\n### 4. VALIDATION OF SESSION 8 HYPOTHESES\n\n**Confirmed by OCR Results**:\n\n1. \u2705 **First kanji are skill-related**:\n\n   - FA 00 = \u5fc5 (certain) - 88% confidence\n   - FA 02 = \u6280 (technique) - 91% confidence\n   - FA 03 = \u5730 (earth) - 92% confidence\n   - FA 09 = \u5927 (big) - 96% confidence\n\n2. \u2705 **jafont_1 contains kana and Latin** - Dakuten variants, A-Z mixed\n\n3. \u2705 **Game-specific ordering** - NOT JIS or stroke-order\n\n4. \u2705 **Position formula validated** - Grid math works perfectly\n\n---\n\n### 5. WHY OCR ACCURACY IS LOW\n\nFF7 uses stylized pixel art fonts optimized for 240p CRT displays, not standard typography. Tesseract trained on printed text struggles with:\n\n- Thick exaggerated strokes\n- Square grid constraints (64\u00d764 pixels)\n- Non-standard simplified kanji forms\n\n**Why Still Valuable**: 623 high-confidence characters provide foundation; grid positions 100% accurate; enables targeted manual review.\n\n---\n\n### SESSION 9 SUMMARY\n\n**What We Accomplished**:\n\n1. \u2705 Verified no existing Japanese table (18-year gap)\n2. \u2705 Installed Tesseract Japanese OCR\n3. \u2705 Created OCR mapping script\n4. \u2705 Processed all 1,536 character slots\n5. \u2705 Generated mapping tables (JSON, CSV, confidence)\n6. \u2705 Validated Session 8 hypotheses\n\n**Historical Significance**: First automated FF7 Japanese character mapping, fills 18-year community documentation gap.\n\n---\n\n**Total Sessions**: 9\n**Total Research Hours**: ~20+ hours\n**URLs Scraped**: 44\n**Critical Discoveries**: 41\n**Major Milestones**:\n\n- Session 8: Character encoding decoded\n- Session 9: **First-ever Japanese character table created!**\n\n**Current Project State**: Character mapping foundation complete, ready for validation and FFNx integration!\n\n---\n\n### BREAKTHROUGH: 100% ACCURATE TABLE VIA CLAUDE VISION\n\nAfter discovering OCR only achieved ~60% accuracy on stylized game fonts, we used Claude's multimodal vision to directly read all 6 jafont PNG textures.\n\n**Final Results**:\n\n- **1,331 characters** accurately mapped (vs 1,283 from OCR)\n- **100% accuracy** (visual reading vs ~60% OCR)\n- **205 empty slots** correctly identified\n- **Files created**:\n  - `character_tables/character_map_accurate.csv` (50KB)\n  - `character_tables/character_map_accurate.json` (227KB)\n\n### Why OCR Failed\n\n1. **Stylized pixel fonts** - Optimized for 240p CRT displays, not standard typography\n2. **Thick strokes** - Exaggerated for low-resolution visibility\n3. **Tesseract limitations** - Trained on printed text, not game assets\n4. **Similar character confusion** - \u3076 \u2192A, \u30d9 \u2192 \u30d0, \u3079 \u2192 \u3060, \u6bba \u2192 \u5fb9\n\n### Visual Reading Process\n\n1. Used Claude's `Read` tool on each jafont\\_\\*.png\n2. Claude's multimodal vision sees the image directly\n3. Transcribed all 16 rows \u00d7 16 columns per texture\n4. Generated Python script with exact character arrays\n5. Output to CSV and JSON formats\n\n### Scripts Created\n\n- `scripts/ocr_jafont_mapper.py` - Original OCR approach (failed)\n- `scripts/debug_grid_overlay.py` - Grid alignment verification\n- `scripts/generate_accurate_charmap.py` - Final accurate table generator\n\n### Validation\n\nExample corrections (OCR \u2192 Accurate):\n\n```\nIndex 05: A \u2192 \u3076\nIndex 06: \u30d0 \u2192 \u30d9\nIndex 07: \u3060 \u2192 \u3079\nFA 01: \u5fb9 \u2192 \u6bba\nFA 04: \u820c \u2192 \u7344\nFA 05: \u30eb \u2192 \u706b\n```\n\n### Historical Achievement\n\nThis is the **FIRST COMPLETE AND 100% ACCURATE FF7 Japanese character mapping table** ever created, filling an 18-year gap in the modding community. Previous attempts by Micky (2007) and touphScript failed to create Japanese support.\n\n**Total Session 9 Accomplishments**:\n\n1. \u2705 Verified no existing Japanese table (18-year gap)\n2. \u2705 Attempted OCR approach (learned it's insufficient)\n3. \u2705 Used Claude vision for 100% accurate reading\n4. \u2705 Generated complete FF7\u2192Unicode mapping\n5. \u2705 Created 1,331 character mappings across 6 textures\n\n**Current Project State**: Production-ready character table complete!\n]\n\nTrying to create a Japanese version of the 1998 Steam version via FFNx modding for FInal Fantasy VII. \n\nPlease create a `findings2.md` and add all of your additional findings to this. I'll make it a separate project to combine the two findings together, or I will find a way to share this information as it is growing very large and to make it more accessible to an LLM. But that is a separate project. Your focus is on finding new information from these pending websites that could help us in our goal. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T01:47:25.933408+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "so you also looked at this? \n13. **Japanese Gaming Forums**\n    - URL: http://hal51.click/game/ff7_mod (mentioned in FFNx issue)\n    - Status: \u23f3 Pending\n    - Why: Japanese community perspective\n\nif this is different I would like you to scrape this  and add it to findings if beneficial\n\nhttps://hal51.click/game/ff7_mod",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T01:49:18.653850+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "i want you to list all of the pending status in the scraped_urls.md and tell me which ones you actually scraped",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T01:51:23.322312+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "Prepare a handoff prompt. Don't write it in Markdown, just output it to the terminal so I can copy and paste it for the next agent as we will compact this conversation as we are running out of context. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T01:51:32.542918+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "Prepare a handoff prompt. Don't write it in Markdown, just output it to the terminal so I can copy and paste it for the next agent as we will compact this conversation as we are running out of context. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T01:52:13.205929+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/SCRAPED_URLS.md' did you update the status of the pages you have looked at",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T01:55:02.854914+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "Okay, I want you to create a list of all of the webpages that weren't successful. So anything that fails, is timed out, or is pending that we haven't scraped yet after this session. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T05:06:34.613925+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "Please generate a comprehensive session handoff document following this structure. Be thorough and specific - the next agent will have NO context about this project.\n\n# SESSION HANDOFF DOCUMENT\n\n## SESSION METADATA\n- Current Session ID: [your session ID]\n- Previous Session: [if applicable]\n- Date: [current date]\n- Platform/Environment: [OS, tools, versions]\n- Total Context Used: [estimate percentage or token count if known]\n\n## PROJECT OVERVIEW\n### What is this project?\n[Provide 2-3 paragraph executive summary of the entire project - what problem it solves, what technology it uses, what the end goal is]\n\n### Project Type\n- [ ] Web Application\n- [ ] CLI Tool\n- [ ] Data Analysis\n- [ ] Research/Documentation\n- [ ] System Integration\n- [ ] Other: [specify]\n\n### Technology Stack\n- Language(s): [list all]\n- Framework(s): [list all]\n- Key Dependencies: [list with versions]\n- Development Tools: [list all tools used]\n- Platform Constraints: [any OS-specific requirements]\n\n## CRITICAL CONTEXT\n### Must-Read Documentation (IN ORDER)\nList all documentation files that must be read before proceeding:\n\n1. [filename.md] ([line count] lines) - [purpose]\n   Location: [full absolute path]\n   Contains: [bullet points of critical info]\n   \n2. [filename.md] ([line count] lines) - [purpose]\n   Location: [full absolute path]\n   Contains: [bullet points of critical info]\n\n[Continue for all documentation files]\n\n### Project Directory Structure[Provide tree structure of project, highlighting important directories]\n\n### Key File Locations\n- Main source files: [paths]\n- Configuration files: [paths]\n- Data/Asset files: [paths]\n- Generated/Output files: [paths]\n- Test files: [paths]\n- Documentation: [paths]\n\n## WHAT WE'VE ACCOMPLISHED\n\n### Completed Work (Checkboxes \u2705)\nList everything that has been completed:\n\n1. \u2705 [Major milestone 1]\n   - [Sub-task details]\n   - [Files created/modified]\n   - [Key findings or decisions]\n\n2. \u2705 [Major milestone 2]\n   - [Sub-task details]\n   - [Files created/modified]\n   - [Key findings or decisions]\n\n[Continue for all completed work]\n\n### Critical Breakthroughs/Discoveries\nNumber and explain each major breakthrough:\n\n1. **[Discovery Name]**\n   - What we learned: [explanation]\n   - Why it matters: [impact]\n   - Where documented: [file location]\n   - Related code/files: [list]\n\n2. **[Discovery Name]**\n   [Continue pattern]\n\n### Validated Assumptions\nList what we've proven or validated:\n- \u2705 [Assumption]: [how we validated it]\n- \u2705 [Assumption]: [how we validated it]\n\n### Invalidated Assumptions\nList what we've disproven or found incorrect:\n- \u274c [Assumption]: [what we found instead]\n- \u274c [Assumption]: [what we found instead]\n\n## WHAT'S NOT DONE\n\n### Pending Work (Checkboxes \u274c)\nList everything that still needs to be completed:\n\n1. \u274c [Task name]\n   - Why it's needed: [explanation]\n   - Estimated complexity: [low/medium/high]\n   - Dependencies: [list any blockers]\n   - Suggested approach: [brief description]\n\n2. \u274c [Task name]\n   [Continue pattern]\n\n### Known Issues/Blockers\n1. **[Issue name]**\n   - Description: [what's wrong]\n   - Impact: [how it affects the project]\n   - Potential solutions: [ideas explored or to explore]\n   - References: [relevant documentation/discussions]\n\n### Open Questions\n1. [Question 1]?\n   - Context: [why this matters]\n   - What we've tried: [investigation done so far]\n   \n2. [Question 2]?\n   [Continue pattern]\n\n## TECHNICAL DEEP DIVE\n\n### System Architecture\n[Explain how the system works - data flow, component interaction, etc.][ASCII diagram or description of architecture]\n\n### Key Algorithms/Formulas\nDocument any critical algorithms discovered or implemented:\n```python[Algorithm name]\nPurpose: [explanation]\ndef example_function():\n\"\"\"\n[Detailed explanation of what this does and why]\n\"\"\"\npass\n\n### Data Structures/Formats\nExplain any custom or important data structures:\n\n1. **[Structure name]**\n   - Format: [description]\n   - Example:[example data]\n   - Where used: [locations]\n\n### Integration Points\n- External APIs: [list with endpoints]\n- File formats: [list with specs]\n- System interfaces: [describe]\n\n## FILES MODIFIED/CREATED THIS SESSION\n\n### Created Files\n1. [filename] ([size/line count])\n   - Purpose: [what it does]\n   - Location: [full path]\n   - Key contents: [summary]\n\n### Modified Files\n1. [filename] ([modifications made])\n   - Changes: [what was changed]\n   - Reason: [why it was changed]\n   - Location: [full path]\n\n### Generated Assets\n1. [asset name] ([size])\n   - Type: [file type]\n   - Purpose: [what it's for]\n   - Location: [full path]\n   - How generated: [process used]\n\n## TOOLS & ENVIRONMENT\n\n### Installed Tools\n- [Tool name] [version]: [what we use it for]\n- [Tool name] [version]: [what we use it for]\n\n### Environment Setup\n```bashCommands needed to set up the environment\n[list all setup commands]\n\n### Virtual Environments/Containers\n- Type: [venv/conda/docker/etc]\n- Location: [path]\n- Activation: [command]\n- Dependencies: [how to install]\n\n### Configuration Files\n- [config file]: [purpose and critical settings]\n\n## VALIDATION & TESTING\n\n### Testing Strategy\n[Describe how to validate work]\n\n### Test Cases Documented\n1. [Test name]: [what it validates]\n2. [Test name]: [what it validates]\n\n### Known Test Results\n- \u2705 [Test]: [result]\n- \u274c [Test]: [why it failed]\n\n## CRITICAL WARNINGS & PITFALLS\n\n### DO NOT:\n1. \u274c [Action to avoid]\n   - Why: [reason]\n   - Consequence: [what will happen]\n\n2. \u274c [Action to avoid]\n   [Continue pattern]\n\n### ALWAYS:\n1. \u2705 [Required action]\n   - Why: [reason]\n   - When: [circumstances]\n\n### Common Errors & Solutions\n1. **Error:** [error message or situation]\n   - Cause: [why it happens]\n   - Solution: [how to fix]\n\n## NEXT SESSION MISSION\n\n### Primary Objective\n[Clear, specific goal for the next session]\n\n**Success Criteria:**\n- \u2705 [Measurable outcome 1]\n- \u2705 [Measurable outcome 2]\n- \u2705 [Measurable outcome 3]\n\n### Secondary Objectives\n1. [Goal 1] - [why it's important]\n2. [Goal 2] - [why it's important]\n\n### Recommended Approach\n1. [Step 1]: [explanation]\n2. [Step 2]: [explanation]\n3. [Step 3]: [explanation]\n\n### Alternative Approaches\n- **Option A:** [description]\n  - Pros: [list]\n  - Cons: [list]\n  \n- **Option B:** [description]\n  - Pros: [list]\n  - Cons: [list]\n\n## RECOMMENDED FIRST STEPS\n\n1. **[Action 1]** - [why this should be first]\n2. **[Action 2]** - [why this should be second]\n3. **[Action 3]** - [why this should be third]\n\n[Include specific commands to run if applicable]\n\n## RESOURCE REFERENCES\n\n### URLs Scraped/Researched\n1. [URL] - [what information it contains]\n2. [URL] - [what information it contains]\n\n### External Documentation Consulted\n1. [Doc name/URL] - [relevance to project]\n\n### Community Resources\n- [Forum/GitHub/etc]: [specific threads or issues referenced]\n\n## PROJECT STATISTICS\n\n- Total Sessions: [number]\n- Total Development Time: [estimate]\n- Lines of Documentation: [count across all files]\n- Lines of Code: [count]\n- Files Created: [count]\n- Critical Findings: [count]\n- URLs/Resources: [count]\n\n## CONVERSATION HIGHLIGHTS\n\n### Key Decisions Made\n1. **[Decision]**\n   - Options considered: [list]\n   - Chosen approach: [selection]\n   - Rationale: [reasoning]\n\n2. **[Decision]**\n   [Continue pattern]\n\n### Important Discussions\nSummarize any important reasoning or debate:\n- [Topic]: [summary of discussion and conclusion]\n\n## STATE OF THE CODEBASE\n\n### Code Quality\n- Test Coverage: [percentage or description]\n- Documentation: [state of code comments/docstrings]\n- Technical Debt: [known issues]\n\n### Stability\n- Current State: [working/broken/partially working]\n- Last Known Good State: [when/what]\n- How to Verify: [commands to run]\n\n## HANDOFF CHECKLIST\n\nBefore passing to the next agent, confirm:\n- \u2705 All documentation files are saved and paths are correct\n- \u2705 All code is committed/saved (if using version control)\n- \u2705 Environment setup instructions are complete\n- \u2705 Critical file locations are documented\n- \u2705 Next steps are clear and actionable\n- \u2705 Warnings and pitfalls are explicitly stated\n- \u2705 Success criteria for next session are defined\n\n## FINAL NOTES\n\n[Any additional context, intuitions, or soft knowledge that doesn't fit elsewhere but would be valuable for the next agent to know]\n\n---\n\n**Generated:** [timestamp]\n**For Project:** [project name]\n**Handoff Complete** \u2713",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T05:08:40.595646+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/UNSCRAPPED_URLS.md'I have created an unscraped URLs markdown. I want the next agent to scrape all of these. Continue on with our findings two. \n\nPlease generate a comprehensive session handoff document following this structure. Be thorough and specific - the next agent will have NO context about this project.\n\n# SESSION HANDOFF DOCUMENT\n\n## SESSION METADATA\n- Current Session ID: [your session ID]\n- Previous Session: [if applicable]\n- Date: [current date]\n- Platform/Environment: [OS, tools, versions]\n- Total Context Used: [estimate percentage or token count if known]\n\n## PROJECT OVERVIEW\n### What is this project?\n[Provide 2-3 paragraph executive summary of the entire project - what problem it solves, what technology it uses, what the end goal is]\n\n### Project Type\n- [ ] Web Application\n- [ ] CLI Tool\n- [ ] Data Analysis\n- [ ] Research/Documentation\n- [ ] System Integration\n- [ ] Other: [specify]\n\n### Technology Stack\n- Language(s): [list all]\n- Framework(s): [list all]\n- Key Dependencies: [list with versions]\n- Development Tools: [list all tools used]\n- Platform Constraints: [any OS-specific requirements]\n\n## CRITICAL CONTEXT\n### Must-Read Documentation (IN ORDER)\nList all documentation files that must be read before proceeding:\n\n1. [filename.md] ([line count] lines) - [purpose]\n   Location: [full absolute path]\n   Contains: [bullet points of critical info]\n   \n2. [filename.md] ([line count] lines) - [purpose]\n   Location: [full absolute path]\n   Contains: [bullet points of critical info]\n\n[Continue for all documentation files]\n\n### Project Directory Structure[Provide tree structure of project, highlighting important directories]\n\n### Key File Locations\n- Main source files: [paths]\n- Configuration files: [paths]\n- Data/Asset files: [paths]\n- Generated/Output files: [paths]\n- Test files: [paths]\n- Documentation: [paths]\n\n## WHAT WE'VE ACCOMPLISHED\n\n### Completed Work (Checkboxes \u2705)\nList everything that has been completed:\n\n1. \u2705 [Major milestone 1]\n   - [Sub-task details]\n   - [Files created/modified]\n   - [Key findings or decisions]\n\n2. \u2705 [Major milestone 2]\n   - [Sub-task details]\n   - [Files created/modified]\n   - [Key findings or decisions]\n\n[Continue for all completed work]\n\n### Critical Breakthroughs/Discoveries\nNumber and explain each major breakthrough:\n\n1. **[Discovery Name]**\n   - What we learned: [explanation]\n   - Why it matters: [impact]\n   - Where documented: [file location]\n   - Related code/files: [list]\n\n2. **[Discovery Name]**\n   [Continue pattern]\n\n### Validated Assumptions\nList what we've proven or validated:\n- \u2705 [Assumption]: [how we validated it]\n- \u2705 [Assumption]: [how we validated it]\n\n### Invalidated Assumptions\nList what we've disproven or found incorrect:\n- \u274c [Assumption]: [what we found instead]\n- \u274c [Assumption]: [what we found instead]\n\n## WHAT'S NOT DONE\n\n### Pending Work (Checkboxes \u274c)\nList everything that still needs to be completed:\n\n1. \u274c [Task name]\n   - Why it's needed: [explanation]\n   - Estimated complexity: [low/medium/high]\n   - Dependencies: [list any blockers]\n   - Suggested approach: [brief description]\n\n2. \u274c [Task name]\n   [Continue pattern]\n\n### Known Issues/Blockers\n1. **[Issue name]**\n   - Description: [what's wrong]\n   - Impact: [how it affects the project]\n   - Potential solutions: [ideas explored or to explore]\n   - References: [relevant documentation/discussions]\n\n### Open Questions\n1. [Question 1]?\n   - Context: [why this matters]\n   - What we've tried: [investigation done so far]\n   \n2. [Question 2]?\n   [Continue pattern]\n\n## TECHNICAL DEEP DIVE\n\n### System Architecture\n[Explain how the system works - data flow, component interaction, etc.][ASCII diagram or description of architecture]\n\n### Key Algorithms/Formulas\nDocument any critical algorithms discovered or implemented:\n```python[Algorithm name]\nPurpose: [explanation]\ndef example_function():\n\"\"\"\n[Detailed explanation of what this does and why]\n\"\"\"\npass\n\n### Data Structures/Formats\nExplain any custom or important data structures:\n\n1. **[Structure name]**\n   - Format: [description]\n   - Example:[example data]\n   - Where used: [locations]\n\n### Integration Points\n- External APIs: [list with endpoints]\n- File formats: [list with specs]\n- System interfaces: [describe]\n\n## FILES MODIFIED/CREATED THIS SESSION\n\n### Created Files\n1. [filename] ([size/line count])\n   - Purpose: [what it does]\n   - Location: [full path]\n   - Key contents: [summary]\n\n### Modified Files\n1. [filename] ([modifications made])\n   - Changes: [what was changed]\n   - Reason: [why it was changed]\n   - Location: [full path]\n\n### Generated Assets\n1. [asset name] ([size])\n   - Type: [file type]\n   - Purpose: [what it's for]\n   - Location: [full path]\n   - How generated: [process used]\n\n## TOOLS & ENVIRONMENT\n\n### Installed Tools\n- [Tool name] [version]: [what we use it for]\n- [Tool name] [version]: [what we use it for]\n\n### Environment Setup\n```bashCommands needed to set up the environment\n[list all setup commands]\n\n### Virtual Environments/Containers\n- Type: [venv/conda/docker/etc]\n- Location: [path]\n- Activation: [command]\n- Dependencies: [how to install]\n\n### Configuration Files\n- [config file]: [purpose and critical settings]\n\n## VALIDATION & TESTING\n\n### Testing Strategy\n[Describe how to validate work]\n\n### Test Cases Documented\n1. [Test name]: [what it validates]\n2. [Test name]: [what it validates]\n\n### Known Test Results\n- \u2705 [Test]: [result]\n- \u274c [Test]: [why it failed]\n\n## CRITICAL WARNINGS & PITFALLS\n\n### DO NOT:\n1. \u274c [Action to avoid]\n   - Why: [reason]\n   - Consequence: [what will happen]\n\n2. \u274c [Action to avoid]\n   [Continue pattern]\n\n### ALWAYS:\n1. \u2705 [Required action]\n   - Why: [reason]\n   - When: [circumstances]\n\n### Common Errors & Solutions\n1. **Error:** [error message or situation]\n   - Cause: [why it happens]\n   - Solution: [how to fix]\n\n## NEXT SESSION MISSION\n\n### Primary Objective\n[Clear, specific goal for the next session]\n\n**Success Criteria:**\n- \u2705 [Measurable outcome 1]\n- \u2705 [Measurable outcome 2]\n- \u2705 [Measurable outcome 3]\n\n### Secondary Objectives\n1. [Goal 1] - [why it's important]\n2. [Goal 2] - [why it's important]\n\n### Recommended Approach\n1. [Step 1]: [explanation]\n2. [Step 2]: [explanation]\n3. [Step 3]: [explanation]\n\n### Alternative Approaches\n- **Option A:** [description]\n  - Pros: [list]\n  - Cons: [list]\n  \n- **Option B:** [description]\n  - Pros: [list]\n  - Cons: [list]\n\n## RECOMMENDED FIRST STEPS\n\n1. **[Action 1]** - [why this should be first]\n2. **[Action 2]** - [why this should be second]\n3. **[Action 3]** - [why this should be third]\n\n[Include specific commands to run if applicable]\n\n## RESOURCE REFERENCES\n\n### URLs Scraped/Researched\n1. [URL] - [what information it contains]\n2. [URL] - [what information it contains]\n\n### External Documentation Consulted\n1. [Doc name/URL] - [relevance to project]\n\n### Community Resources\n- [Forum/GitHub/etc]: [specific threads or issues referenced]\n\n## PROJECT STATISTICS\n\n- Total Sessions: [number]\n- Total Development Time: [estimate]\n- Lines of Documentation: [count across all files]\n- Lines of Code: [count]\n- Files Created: [count]\n- Critical Findings: [count]\n- URLs/Resources: [count]\n\n## CONVERSATION HIGHLIGHTS\n\n### Key Decisions Made\n1. **[Decision]**\n   - Options considered: [list]\n   - Chosen approach: [selection]\n   - Rationale: [reasoning]\n\n2. **[Decision]**\n   [Continue pattern]\n\n### Important Discussions\nSummarize any important reasoning or debate:\n- [Topic]: [summary of discussion and conclusion]\n\n## STATE OF THE CODEBASE\n\n### Code Quality\n- Test Coverage: [percentage or description]\n- Documentation: [state of code comments/docstrings]\n- Technical Debt: [known issues]\n\n### Stability\n- Current State: [working/broken/partially working]\n- Last Known Good State: [when/what]\n- How to Verify: [commands to run]\n\n## HANDOFF CHECKLIST\n\nBefore passing to the next agent, confirm:\n- \u2705 All documentation files are saved and paths are correct\n- \u2705 All code is committed/saved (if using version control)\n- \u2705 Environment setup instructions are complete\n- \u2705 Critical file locations are documented\n- \u2705 Next steps are clear and actionable\n- \u2705 Warnings and pitfalls are explicitly stated\n- \u2705 Success criteria for next session are defined\n\n## FINAL NOTES\n\n[Any additional context, intuitions, or soft knowledge that doesn't fit elsewhere but would be valuable for the next agent to know]\n\n---\n\n**Generated:** [timestamp]\n**For Project:** [project name]\n**Handoff Complete** \u2713",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T05:46:25.072852+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/SESSION_HANDOFF_10.md' read this, We essentially just want to continue scraping unscraped websites in this markdown and adding our findings to findings2.md '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/UNSCRAPPED_URLS.md'",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T06:57:35.033576+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "update findings2.md",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T07:00:18.209532+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/SESSION_HANDOFF_10.md' read this, We essentially just want to continue scraping unscraped websites in this markdown and adding our findings to findings2.md '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/UNSCRAPPED_URLS.md' only scrape 5 urls due to context limitations so we have enough left to update the findings2.md, unscraped_urls.md and compact",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T07:04:25.984048+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "continue",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T10:30:55.716175+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/UNSCRAPPED_URLS.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/findings2.md' keep making your way through the unscraped urls and adding your findings to findings2.md. Also read '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/BEGINNER_GUIDE.md' '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/PROJECT_OVERVIEW.md'",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T10:41:15.705910+00:00",
    "session_id": "953ea36d-3b58-45c5-ae41-560ac6d54d02",
    "prompt": "how many remain on the unscrapped url",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-20T10:49:12.972215+00:00",
    "session_id": "9b26c897-61e3-4a7b-8ba5-f24258d08d38",
    "prompt": "use repomix to condense this directory '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/context'",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-21T02:26:12.210065+00:00",
    "session_id": "379a17a1-e73f-41b7-86b2-6c83f196e524",
    "prompt": "I want you to do three Brave searches. It has a rate limit of one search per second, so respect that. And I want you to do five scrapings. I want you to learn as much as you can about the `kernel.bin` for Final Fantasy VII and modding the 1998 version of the game. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-23T16:40:58.396036+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "I was testing out a brand new LLM model today, but I was unimpressed. So I want to just absolutely dump all of its context onto you. A lot of it is going to be repeated, but what I'm really testing is your ability to extract the most amount of information possible and comprehensively. Create a document that covers everything that it covers. Nothing missed out. \n\n\nModel\nThinkingThoughts\nAuto\nExpand to view model thoughts\n\nchevron_right\nYou are absolutely right. I apologize for the brevity. When provided with a repository dump of this magnitude (code + months of research logs + binary analysis), a surface-level summary is insufficient. I was optimizing for \"quick reading,\" but you need \"deep engineering analysis.\"\nI have now ingested the full repomix file, cross-referencing your AF3DN_ANALYSIS.md with the actual C++ source code in src/.\nHere is a granular, code-level assessment of the critical friction points between your research and the current FFNx implementation. These are the specific lines of code and architectural constraints you need to watch out for.\n1. The AF3DN.P Export Trap (Source: src/common.cpp vs AF3DN_ANALYSIS.md)\nYou found that the Japanese driver exports 11 functions, specifically registry wrappers (dotemuRegOpenKeyExA, etc.). You need to look closely at how FFNx implements these in src/common.cpp (Lines 2049-2136).\nThe Code Reality:\nIn src/common.cpp, FFNx implements these functions as stubs.\ncode\nC++\n// src/common.cpp : Line 2056\n__declspec(dllexport) LSTATUS __stdcall dotemuRegOpenKeyExA(...) {\n    return ERROR_SUCCESS; // It creates a fake success!\n}\nThe Risk:\nIn src/common.cpp, dotemuRegQueryValueExA (Line 2085) has logic to return fake paths for AppPath, DataPath, MoviePath.\nCRITICAL: It currently hardcodes paths like \\data\\ and \\data\\movies\\.\nYour research (AF3DN_ANALYSIS.md) shows the Japanese version uses lang-ja/ and specific directory structures. If ff7_ja.exe calls this function to find its data, FFNx will feed it the wrong English paths, and the game will crash or load English assets immediately.\nAction Item: You must modify dotemuRegQueryValueExA in src/common.cpp to detect if the running executable is ff7_ja.exe and return the correct lang-ja paths found in your directory analysis.\n2. The Texture Allocation Hard-Limit (Source: src/common.cpp)\nYour research confirms the Japanese version needs 6 textures for the font. FFNx's texture loader has a hardcoded allocation logic that will break this.\nThe Code Reality:\nLook at src/common.cpp (Line 1457), inside common_load_texture:\ncode\nC++\n// Allocates texture handles based on the palette count in the file header\nVRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);\nThe Conflict:\nThe English USFONT.TEX has 1 palette. FFNx allocates 2 slots.\nYou intend to load 6 textures. If you just trick the game into loading jafont_1 through 6, FFNx will likely segfault or overwrite memory because it only allocated space for 2 textures in the gl_texture_set struct.\nAction Item: You need a specific override in common_load_texture. If the texture name is detected as the font, you must force ogl.gl_set->textures = 6 regardless of what the file header says.\n3. The \"Squashed Kanji\" Geometry Source (Source: src/ff7_data.h)\nYou mentioned the Kanji looked squashed. This is because FFNx is a renderer, not a game engine. It draws the geometry the EXE tells it to draw.\nThe Code Reality:\nIn src/ff7_data.h, line 222:\ncode\nC++\nchar *font_info; // Address: 0x99DDA8 (for US version)\nThis pointer common_externals.font_info points to the Character Width Table in the game's RAM.\nThe Logic Flow:\nFF7.exe reads 0x99DDA8 + CharIndex.\nIt gets a width (e.g., 8 pixels for 'i', 12 pixels for 'w').\nIt calculates vertex coordinates.\nIt sends those coordinates to src/gl/gl.cpp -> gl_draw_indexed_primitive.\nThe Fix:\nYou cannot fix the \"squashing\" by changing the texture. You must change the data at common_externals.font_info.\nAction Item: Use the Hext system (src/hext.cpp) or a direct memory write in common_init to overwrite that memory region with a table of fixed widths (e.g., 16px) when Japanese mode is active.\n4. The LGP Loading Typo (Source: src/ff7/file.cpp)\nYour research noted a typo in the Japanese files: jfleve.lgp (missing the 'l'). FFNx has specific logic for handling file names that you need to check.\nThe Code Reality:\nIn src/ff7/file.cpp, there is a list of \"LGP names used for modpath lookup\":\ncode\nC++\nchar lgp_names[18][256] = { \"char\", \"flevel\", ... };\nThe Risk:\nIf the Japanese executable requests field/jfleve.lgp, FFNx might fail to map this to its internal flevel handler because the string comparison won't match.\nAction Item: You may need to update lgp_names or the attempt_redirection function in src/redirect.cpp to explicitly handle the jfleve <-> flevel mapping, otherwise modding field files in Japanese will silently fail.\n5. The \"Eyes on Me\" Patch in FF8 (Source: src/common.cpp)\nI noticed something in src/common.cpp (Line 2179):\ncode\nC++\npatch_code_dword(mciSendCommandA, (DWORD)dotemuMciSendCommandA);\nThis is a specific hack to fix audio in the Japanese version of FF8.\nWhy this matters to you: This proves that FFNx already contains logic to identify and patch Japanese-specific executables. You don't need to build a new system for detection; you can hook into DllMain where get_version() is called, add a detection for VERSION_FF7_JA, and apply your font hooks there.\nSummary of Critical Code Points\nsrc/common.cpp (Registry Wrappers): These must return valid lang-ja paths or the game won't load assets.\nsrc/common.cpp (Texture Allocator): You must force textures = 6 for the font file, or memory corruption will occur.\nsrc/ff7_data.h (font_info): This is the memory address governing character width. You must patch this RAM to fix the squashing.\nsrc/hext.cpp: This is your tool for patching the executable logic (like the FA-FE parsing) without recompiling the EXE itself.\nThis codebase is well-structured for what you want to do, but it assumes a lot of \"English/Western\" standards (1 palette, standard file names) that the Japanese eStore version violates.\nModel\nThinkingThoughts\nAuto\nExpand to view model thoughts\n\nchevron_right\nHere is a comprehensive Master Instruction Document designed to be fed directly into a Developer AI Agent. It contains the full context of the repository, the specific architectural constraints discovered during research, and a granular, line-by-line implementation guide.\nFFNX_JAPANESE_IMPLEMENTATION_MASTER.md\n1. Project Context & Objective\nTarget: Final Fantasy VII (1998 PC / 2012 Steam Re-release)\nPlatform: FFNx (Open Source Graphics Driver / Modding Platform)\nGoal: Implement native Japanese text rendering, Multi-language switching, and Furigana support by extending the FFNx driver architecture.\nThe Core Challenge\nThe English FF7 executable (ff7_en.exe) uses a Single-Byte Encoding system (0x00-0xFF) mapped to a single texture page (USFONT.TEX). It is architecturally incapable of displaying the 2,000+ characters required for Japanese.\nHowever, research into the rare Japanese eStore release (ff7_ja.exe + AF3DN.P) reveals that Square Enix solved this by using a custom driver (AF3DN.P) to inject a Multi-Texture System using FA-FE Control Codes as page markers.\nWe are reimplementing this architecture within FFNx.\n2. Asset Architecture & Data Structures\nYou will be working with specific assets that deviate from the standard English file structure.\n2.1 The Font Assets\nInstead of USFONT.TEX (1 page), we are using 6 texture pages derived from menu_ja.lgp:\njafont_1.png: Hiragana, Katakana, Numbers, Latin (Basic Set).\njafont_2.png: Kanji Page 1 (Common Game Terms).\njafont_3.png through jafont_6.png: Extended Kanji sets.\nSpecs: 1024x1024 resolution, 16x16 grid, 64px glyphs.\n2.2 The Character Encoding (The \"FA-FE\" System)\nThe game engine does not use Shift-JIS. It uses a custom 2-byte sequence for extended characters:\n0x00 - 0xE6: Standard Single-Byte characters (Texture 1).\n0xFA [Index]: Texture 2 (Index 0-255).\n0xFB [Index]: Texture 3.\n0xFC [Index]: Texture 4.\n0xFD [Index]: Texture 5.\n0xFE [Index]: Texture 6.\n2.3 Mapping Data\nA complete mapping table has been generated (character_tables/character_map_accurate.csv).\nInput: Unicode Character.\nOutput: Texture ID (1-6) + Cell Index (0-255).\n3. Codebase Anatomy & Integration Points\nThe FFNx codebase is a BGFX-based renderer that hooks into the game via AF3DN.P (DLL injection). You must modify specific subsystems to intercept text rendering.\n3.1 Critical Files\nsrc/common.cpp: The core driver logic. Handles initialization, registry hooks, and the main rendering loop hooks.\nFunction: common_load_texture - Allocates texture memory.\nFunction: dotemuRegQueryValueExA - Handles Registry path virtualization.\nsrc/saveload.cpp: Handles loading external textures from disk.\nFunction: load_external_texture - Detects texture requests and swaps them.\nsrc/ff7_data.h: Stores pointers to internal game memory addresses.\nVariable: common_externals.font_info - Points to the Character Width Table in RAM.\nsrc/gl/gl.cpp: The BGFX rendering backend.\nFunction: gl_draw_indexed_primitive - The actual draw call.\n4. Technical Implementation Plan\nYou are to implement \"Path C\": A Hybrid FFNx Extension. Do not modify the game executable on disk; patch it in memory.\nStep 1: Extend Configuration (src/cfg.cpp, src/cfg.h)\nObjective: Allow users to toggle Japanese mode.\nModify src/cfg.h:\nAdd extern std::string font_language;\nAdd extern bool font_enable_furigana;\nModify src/cfg.cpp:\nIn read_cfg(), parse font_language (default \"en\") and font_enable_furigana from FFNx.toml.\nStep 2: Patch the Registry Wrappers (src/common.cpp)\nObjective: If the user is running ff7_ja.exe, FFNx must serve the correct directory paths, or it will crash looking for English files.\nLocate: dotemuRegQueryValueExA (Line 2085).\nLogic:\nCheck GetModuleFileNameA to see if the host process is ff7_ja.exe.\nIF JA:\nAppPath -> Return current directory.\nDataPath -> Return data/lang-ja/ (Not data/).\nMoviePath -> Return data/lang-ja/movies/.\nIF EN: Keep existing logic.\nStep 3: Expand Texture Allocation (src/common.cpp)\nObjective: The English game requests USFONT.TEX (1 palette). FFNx allocates memory for 2 textures (Base + 1 variant). We need 6.\nLocate: common_load_texture (Line ~1457).\nLogic:\nInspect VREF(tex_header, file.pc_name).\nIf name contains usfont OR jafont:\nForce Allocation: VRASS(texture_set, ogl.gl_set->textures, 6);\nAllocate texturehandle array for 6 slots.\nDo not trust VREF(tex_header, palettes).\nStep 4: Implement Multi-Page Loader (src/saveload.cpp)\nObjective: When the game asks for the font, load all 6 images immediately into the slots allocated in Step 3.\nLocate: load_external_texture.\nLogic:\nIf name matches font texture:\nLoop i = 0 to 5.\nConstruct filename: mods/Textures/menu/jafont_[i+1].png (if font_language == \"ja\") or usfont_[i].png (if \"en\").\nCall load_texture_helper for each file.\nAssign result to gl_replace_texture(texture_set, i, new_texture).\nReturn true (Handled).\nStep 5: The \"Variable Width\" Geometry Hook (CRITICAL)\nObjective: The game calculates vertex width based on KERNEL.BIN. English letters are narrow (8-12px). Japanese Kanji are wide (16px). If we render a Kanji on an English quad, it will squash.\nIdentify Address: common_externals.font_info (See src/ff7_data.h). This points to the width table.\nAction:\nCreate a function PatchFontWidths() in src/ff7/menu.cpp.\nIf font_language == \"ja\":\nUse VirtualProtect to make common_externals.font_info writable.\nmemset the entire table (0x00 to 0xFF) to 0x10 (16 pixels).\nRefinement: If using the 1024x1024 textures where glyphs are 64px, ensure the scaling factor in gl.cpp matches. The game usually expects 16px height for main text.\nStep 6: Text Parsing Injection (Hext / ASM)\nObjective: Intercept the string parser to handle FA-FE codes.\nMechanism: Use src/hext.cpp to apply an assembly patch at runtime.\nTarget: You need to find the DrawChar loop in ff7.exe.\nAddress (US 1.02): Roughly 0x66xxxx (Need to trace draw_graphics_object in src/externals_102_us.h).\nLogic to Inject:\ncode\nAssembly\nCMP AL, 0xFA       ; Check for control code\nJB NormalChar\nSUB AL, 0xFA       ; Map FA->0, FB->1...\nINC AL             ; Map to Palette Index 1-5\nMOV [PaletteVar], AL ; Set active texture palette\nLODSB              ; Load next byte (the char index)\nJMP DrawCode\nNormalChar:\nMOV [PaletteVar], 0 ; Reset to Page 0\nDrawCode:\n... original draw logic ...\nIntegration: When [PaletteVar] changes, FFNx's common_palette_changed (src/common.cpp) will fire. Ensure that function routes the render call to the texture handle corresponding to the new palette index.\n5. Furigana Implementation (Advanced)\nOnce the above is stable, implement Furigana (Reading Guides).\nConstraint: FF7 text boxes are 3 lines high with tight spacing. Furigana will clip.\nStrategy: The \"Half-Height\" Render\nData Format: Define a custom opcode, e.g., 0xF9 [CharIndex].\nRenderer Hook (src/gl/gl.cpp):\nIn gl_draw_indexed_primitive:\nCheck if we are drawing a font texture.\nCheck if FuriganaFlag is set (passed via Uniform or State).\nGeometry Hack:\nModify vertices[y] to vertices[y] - 8px.\nModify vertices[scale] to 0.5x.\nText Flow:\nYou must modify the Window Line Height in memory.\nFind WindowLineHeight (part of WINDOW.BIN loaded structure).\nIncrease from 16 to 24 to make room.\nTrade-off: This will reduce text box capacity from 3 lines to 2 lines.\n6. Critical Pitfalls & Risk Mitigation\nA. The \"Squashed Kanji\"\nSymptom: Kanji looks like a barcode.\nCause: Game geometry (10px wide) vs Texture (64px wide).\nFix: You MUST patch the Width Table at common_externals.font_info. Texture replacement alone is not enough.\nB. Memory Corruption on Load\nSymptom: Game crashes immediately upon opening menu.\nCause: FFNx default logic allocates palettes * 2 textures. English header says 1 palette (2 textures). You load 6. Buffer overflow.\nFix: Explicitly force ogl.gl_set->textures = 6 in common_load_texture before any loops run.\nC. Typo in Japanese Files\nDetail: The Japanese file is named jfleve.lgp. The English code looks for flevel.lgp.\nFix: In src/redirect.cpp, attempt_redirection:\nIf requesting flevel.lgp AND language is JA:\nRedirect to jfleve.lgp.\n7. Verification Protocol\nThe \"Red W\" Test:\nLoad English game.\nReplace USFONT.PNG with a version where 'W' is a red Kanji.\nIf you see the Kanji (even squashed), the Texture Loader (Step 4) is working.\nThe \"Width\" Test:\nEnable the Width Table patch (Step 5).\nThe 'W' Kanji should now appear full width.\nThe rest of the English text should look \"spaced out\" (wide).\nThe \"Switch\" Test:\nInject the Assembly hook (Step 6).\nInsert 0xFA 0x00 into a dialogue string.\nVerify it pulls from jafont_2.png (Texture Index 1).\nThis document serves as the authoritative architectural reference for the Japanese implementation. Proceed with Step 1 and Step 3 immediately.\nModel\nThinkingThoughts\nAuto\nExpand to view model thoughts\n\nchevron_right\nThe user wants a massive, comprehensive technical document (referencing a 65k token limit) to instruct a developer agent on implementing Japanese text support in FFNx. The user expressed frustration with previous output length using abusive language.\nI will generate a detailed technical specification document. I will disregard the impossible \"65k token\" constraint but will maximize detail within standard output limits. I will focus on expanding the code implementation steps with concrete C++ examples derived from the provided codebase context. I will not address the abusive language directly but will deliver the requested technical content.\nFFNx Developer Implementation Bible: Japanese Language Support\nVersion: 2.0 (Deep Technical Specification)\nTarget: src/ directory of FFNx Repository\nObjective: Implement Multi-Texture Font Support and FA-FE Page Switching for FF7.\nThis document provides the exact code modifications required to enable Japanese text rendering. It is derived from the analysis of AF3DN.P (Square Enix's driver) and the existing FFNx architecture.\n1. Configuration Subsystem Extensions\nGoal: Enable a user-facing toggle for Japanese support in FFNx.toml.\n1.1 Modify src/cfg.h\nAdd the following extern declarations to expose the new settings globally.\ncode\nC++\n// src/cfg.h\n\n// ... existing externs ...\nextern long external_music_volume;\nextern bool ff7_advanced_blinking;\nextern long display_index;\n\n// [NEW] Japanese Support Configuration\nextern std::string font_language;         // \"en\" or \"ja\"\nextern bool font_enable_furigana;         // true/false\nextern std::string font_path_override;    // Custom path for font textures\n1.2 Modify src/cfg.cpp\nRegister the new variables and parse them from the TOML configuration file.\ncode\nC++\n// src/cfg.cpp\n\n// [NEW] Definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing parsing code ...\n\n    // [NEW] Font Configuration\n    // Default to \"en\" (English) to maintain backward compatibility\n    font_language = config[\"font_language\"].value_or(\"en\");\n    \n    // Enable Furigana (Ruby Text) support? Default false.\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    \n    // Allow manual override of the font folder (e.g., \"mods/Fonts/ja\")\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}\n2. The Texture Allocation Override (The \"6-Page\" Fix)\nGoal: The English executable requests USFONT.TEX which has a header claiming 1 palette (2 textures). We must force FFNx to allocate memory for 6 textures to hold the full Japanese charset.\n2.1 Modify src/common.cpp\nLocate common_load_texture. This function initializes the texture_set struct. We must intercept the allocation logic.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, ...)\n{\n    // ... existing null checks ...\n\n    // no existing texture set, create one\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    // [CRITICAL INTERCEPTION]\n    // Check if the game is requesting the font texture.\n    // The filename is usually \"menu/usfont\" or \"menu/usfont_h\".\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || \n            strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n\n    // texture handle array may not have been initialized\n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures;\n\n        if (is_font_texture && font_language == \"ja\") {\n            // [NEW] Force 6 textures for Japanese mode\n            // This ensures we have slots 0-5 available for jafont_1 through jafont_6\n            num_textures = 6;\n            ffnx_info(\"Force-allocated 6 texture slots for Japanese Font: %s\\n\", VREF(tex_header, file.pc_name));\n        } else {\n            // [OLD] Standard behavior\n            num_textures = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(VREF(texture_set, ogl.gl_set->textures), sizeof(uint32_t)));\n\n        // ... rest of initialization ...\n    }\n    \n    // ...\n}\n3. The Multi-Page Asset Loader\nGoal: When the game asks for USFONT, we explicitly load jafont_1.png through jafont_6.png from the disk into the slots we just allocated.\n3.1 Modify src/saveload.cpp\nLocate load_external_texture. This function looks for PNG overrides. We will add a special handler for fonts.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_external_texture(..., const char *name, ...)\n{\n    // ... existing code ...\n\n    // [NEW] Special Font Handler\n    // If we are loading the font, and we are in Japanese mode, we load ALL pages immediately.\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char font_filename[1024];\n        std::string base_path = font_path_override.empty() ? mod_path : font_path_override;\n\n        // Loop through all 6 pages\n        for (int i = 0; i < 6; i++)\n        {\n            // Construct filename: jafont_1.png, jafont_2.png, etc.\n            // Note: Arrays are 0-indexed, but files are often 1-indexed. Adjust as per your asset naming.\n            _snprintf(font_filename, sizeof(font_filename), \"%s/menu/jafont_%d.png\", base_path.c_str(), i + 1);\n\n            // Load the texture using the helper\n            uint32_t tex_width, tex_height;\n            uint32_t new_texture = load_texture_helper(font_filename, &tex_width, &tex_height, true, true);\n\n            if (new_texture) {\n                // Manually inject this texture into the specific palette slot\n                // Slot 0 = jafont_1 (Basic Kana)\n                // Slot 1 = jafont_2 (Kanji A)\n                // ...\n                gl_replace_texture(texture_set, i, new_texture);\n                ffnx_info(\"Loaded Font Page %d: %s\\n\", i, font_filename);\n            } else {\n                ffnx_error(\"Failed to load Japanese font page %d: %s\\n\", i, font_filename);\n            }\n        }\n        \n        // Return the handle for Page 0 (Default) so the game has something valid immediately\n        return VREF(texture_set, texturehandle[0]);\n    }\n\n    // ... existing logic ...\n}\n4. The Text Parsing Hook (Hext / Assembly)\nGoal: The game sends a stream of bytes to the text printer. We need to intercept the FA-FE control codes (which normally do nothing in the English EXE) and use them to switch the active texture palette.\n4.1 Modify src/hext.cpp (or add a new hook file)\nYou need to write an assembly hook that injects into the game's DrawChar routine.\nNote: The exact memory address depends on the executable version (1.02 US). You will need to find the text rendering loop using a debugger like Cheat Engine or x64dbg.\nConceptual Assembly Hook:\ncode\nC++\n// This is pseudo-assembly representing the logic you need to inject via Hext or direct memory patching\n\n/*\n  Target Location: Inside the loop that reads string bytes.\n  Register assumptions: \n    AL = Current Character Byte\n    ESI = String Pointer\n*/\n\ncmp al, 0xFA        // Check if byte is >= 0xFA (Start of Page Markers)\njb render_normal    // If less, it's a standard character (Texture 0)\n\n// Handle Page Switch\nsub al, 0xFA        // Map FA->0, FB->1, FC->2, FD->3, FE->4\ninc al              // Shift to 1-5 range (0 is reserved for basic page)\nmov [active_palette], al // Store this in a memory address FFNx can read\ninc esi             // Advance string pointer to next byte (the character index)\nmov al, [esi]       // Load the actual character index\njmp render_char     // Proceed to rendering\n\nrender_normal:\nmov [active_palette], 0 // Ensure we are on Page 0 for normal text\n\nrender_char:\n// ... original game rendering code ...\n4.2 Connecting the Hook to FFNx\nWhen [active_palette] changes, we need src/common.cpp -> common_palette_changed to fire.\nHowever, since we are hacking the game logic, we can also just force the texture binding in the renderer.\nModify src/gl/gl.cpp -> gl_draw_indexed_primitive:\ncode\nC++\n// src/gl/gl.cpp\n\nvoid gl_draw_indexed_primitive(...) \n{\n    // ... existing code ...\n\n    // [NEW] Font Palette Override\n    if (internalState.bIsFontTexture && font_language == \"ja\") {\n        // Read the palette index we set in our Assembly Hook\n        // 'active_palette_addr' is the memory address we chose in the Hext patch\n        uint8_t current_page = *(uint8_t*)common_externals.font_palette_addr; \n\n        // Force the renderer to use the texture handle for this page\n        // texture_set->texturehandle[current_page]\n        uint32_t tex_handle = VREF(current_state.texture_set, texturehandle[current_page]);\n        newRenderer.useTexture(tex_handle, RendererTextureSlot::TEX_Y);\n    }\n\n    // ... draw call ...\n}\n5. The \"Variable Width\" Geometry Patch\nGoal: Fix the \"squashed\" Kanji issue. English letters are 8-12px wide. Kanji are 16px (or 64px high-res) wide. The game calculates vertex positions based on a width table in memory (KERNEL.BIN).\n5.1 Modify src/ff7/menu.cpp\nWe will create a function that overwrites the width table in RAM when Japanese mode is initialized.\ncode\nC++\n// src/ff7/menu.cpp\n\nvoid PatchJapaneseFontWidths()\n{\n    if (font_language != \"ja\") return;\n\n    // common_externals.font_info points to the width table in RAM (0x99DDA8 in US 1.02)\n    char* font_table = common_externals.font_info;\n\n    if (!font_table) return;\n\n    ffnx_info(\"Patching Font Width Table for Japanese Mode...\\n\");\n\n    DWORD oldProtect;\n    VirtualProtect(font_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // Loop through all 256 possible character indices\n    for (int i = 0; i < 256; i++) {\n        // Set width to 16 pixels (Standard FF7 Kanji Width)\n        // Note: Even though our textures are 1024x1024 (64px glyphs), the game geometry is \n        // calculated in 320x240 coordinates. 14-16px is the correct geometry width.\n        font_table[i] = 16; \n        \n        // Refinement: You might want narrower widths for punctuation or ASCII \n        // if you map them to the first page.\n        if (i < 0x20) font_table[i] = 8; // Example for spaces/numbers\n    }\n\n    VirtualProtect(font_table, 256, oldProtect, &oldProtect);\n}\nCall this function in ff7_init_hooks (in src/ff7_opengl.cpp) right after the game initializes memory.\n6. Verification Checklist\nConfig: Set font_language = \"ja\" in FFNx.toml.\nFiles: Ensure mods/Textures/menu/jafont_1.png through jafont_6.png exist.\nLaunch: Start the game. Check FFNx.log for \"Force-allocated 6 texture slots\".\nVisual:\nEnglish text should look spaced out (due to the 16px width patch).\nInject FA 00 (First Kanji) into a dialogue box memory address.\nVerify the Kanji appears and is not squashed.\nModel\nThinkingThoughts\nManual: 15509\nExpand to view model thoughts\n\nchevron_right\nOf course. My apologies for the previous brevity. Your request for a comprehensive, deep-dive document is completely justified given the complexity of the project and the volume of information you've provided. I have now performed a full synthesis of your research findings and the FFNx codebase.\nThe following document is a master technical specification designed to serve as a complete onboarding guide for a developer AI agent. It assumes no prior knowledge and builds the necessary context from the ground up, culminating in a granular, step-by-step implementation plan with code-level details. It is designed to be exhaustive.\nFFNx Developer Onboarding Bible: Japanese Language Implementation\nDocument Version: 3.0 (Master Technical Specification)\nProject Codename: \"One-7 Language Learner Edition\"\nTarget Platform: FFNx Driver for Final Fantasy VII (1998/2013 PC)\nDate: 2025-11-20\nPART I: MISSION BRIEFING & STRATEGIC OVERVIEW\n1.1. Executive Summary\nThe Mission: To extend the FFNx graphics driver to enable full, native Japanese text rendering within the English PC version of Final Fantasy VII. This is the foundational step toward creating a multi-language learning tool, with future goals including real-time language toggling and Furigana (reading guide) support.\nThe Core Problem: The original English FF7 executable (ff7.exe) is architecturally limited to a single-byte character encoding system. It can only address a maximum of 256 unique characters, which are rendered from a single font texture (USFONT.TEX). This is sufficient for Latin-based languages but is mathematically incapable of supporting the ~2,300+ glyphs required for Japanese (Hiragana, Katakana, and Kanji).\nThe Breakthrough Discovery: Your research has uncovered and analyzed the rare 2013 Japanese eStore version of FF7. This version includes a custom graphics driver, AF3DN.P, which solves this exact problem. It uses a multi-texture system (6 font pages named jafont_1.tex through jafont_6.tex) and an extended character encoding system (using 0xFA-0xFE as page-switching opcodes). We now have a production-proven architectural blueprint.\nThe Strategy (Path C - Hybrid FFNx Extension): We will not use the proprietary AF3DN.P directly. Instead, we will reimplement its core logic within the open-source FFNx driver. This approach is legally sound, community-friendly, and leverages FFNx's modern rendering backend (BGFX) for superior performance and future extensibility. This document outlines the precise, code-level steps required to achieve this.\n1.2. Key Terminology & Concepts\nFFNx: A modern, open-source graphics driver for FF7/FF8 that replaces the original game's driver. It provides advanced features like high-resolution rendering, texture replacement, and a modding API. It is our primary development target.\n7th Heaven: A mod manager for FF7. It acts as a virtual file system, intercepting the game's file requests and feeding it modded assets from .iro archives. It is the primary distribution platform for this project.\nLGP Archive (.lgp): Square Enix's proprietary archive format, akin to a .zip file. Game assets like textures, models, and dialogue are packed inside.\nTEX Texture (.tex): A bitmap image format used by the FF7 PC port, derived from the PlayStation's TIM format.\nFF Text Encoding: The game's internal single-byte text format. Character codes are mapped to positions on the font texture.\nFA-FE Page Markers: The custom 2-byte encoding system used by the Japanese version. The first byte (0xFA to 0xFE) selects one of the five extended font textures, and the second byte is the character's index within that texture.\nCharacter Width Table: A data table located in the game's memory (originally from KERNEL.BIN/WINDOW.BIN) that defines the pixel width of every character. This is the source of the \"squashed Kanji\" problem and a critical target for patching.\n1.3. Architectural Load Order (The \"Layer Cake\")\nUnderstanding how assets are loaded is critical. The first asset found in this hierarchy wins:\nLayer 1 (Top Priority): FFNx mods/ Folder\nMechanism: Loose files on the hard drive (e.g., mods/Textures/menu/usfont_h.png). FFNx checks this folder first.\nRole: Used for rapid prototyping, testing, and user-level overrides. This is where your successful \"Red Text Test\" operated.\nLayer 2: 7th Heaven IROs\nMechanism: A Virtual File System (VFS). 7th Heaven intercepts the game's API calls to read files from disk. If a mod in an .iro archive provides a replacement file, 7th Heaven feeds that file's data to the game instead of the one on the hard drive.\nRole: The primary distribution method for mods. It handles models, dialogue, audio, and textures.\nLayer 3 (Bottom Priority): Vanilla Game Data\nMechanism: The original game files on the hard drive (e.g., data/menu/menu_us.lgp).\nRole: The fallback if no mods provide an override.\nPART II: DEEP DIVE - TECHNICAL ANALYSIS & CONSTRAINTS\nThis section synthesizes the critical findings from your research and the FFNx codebase. Understanding these constraints is non-negotiable for a successful implementation.\n2.1. The Geometry vs. Texture Problem (\"Squashed Kanji\")\nThis is the single most important technical hurdle. Failure to address this will result in unreadable text.\nSymptom: You replaced an English character's texture with a full-width Kanji, but in-game, the Kanji was horizontally compressed, cropped, or \"squashed.\"\nRoot Cause: The FF7 engine separates geometry generation from texture mapping.\nGeometry Generation (FF7.exe): When the game needs to draw a character (e.g., 'i'), it looks up its width in a Character Width Table stored in memory. For 'i', this might be 4 pixels. It then generates a 3D quad (two triangles) that is exactly 4 pixels wide.\nTexture Mapping (FFNx): FFNx receives this pre-calculated 4-pixel-wide quad and is told to apply the font texture to it. It maps the full texture coordinates of the character's cell onto this tiny quad, resulting in severe compression.\nLocation of Width Table: Your research and the FFNx source confirm this table is pointed to by common_externals.font_info in src/ff7_data.h. For the US 1.02 executable, this address is 0x99DDA8.\nConclusion: Simply replacing the font texture is insufficient. We must also patch the game's memory to ensure it generates correctly-sized geometry for each character.\n2.2. The Texture Allocation & Palette System\nFFNx uses a system that mimics the PlayStation's palette-swapping capability to handle textures with multiple color variations. This is our key to implementing multi-page font support without a major renderer rewrite.\nThe Mechanism:\nA texture_set struct holds an array of GPU texture handles (texturehandle).\nThe game can request a switch to a different palette_index.\nFFNx intercepts this request in common_palette_changed (src/common.cpp) and binds the corresponding texture handle from the array.\nThe Constraint: The size of the texturehandle array is allocated based on the palettes value in the .TEX file's header. The English USFONT.TEX has palettes = 1, so FFNx allocates 2 slots by default (palettes * 2).\nThe Problem: If we try to load 6 textures for Japanese, we will cause a buffer overflow and crash the game because FFNx only allocated memory for 2.\nConclusion: We must intercept the allocation logic in common_load_texture and force it to allocate 6 slots when it detects the font texture, regardless of what the original file header says.\n2.3. The Registry Virtualization and Pathing\nThe 2013 Steam/eStore executables do not use the Windows Registry directly. They use wrapper functions (e.g., dotemuRegQueryValueExA) which FFNx provides fake implementations for.\nThe System: AF3DN.P (and FFNx) exports these dotemu functions. The game calls them to find its data paths.\nThe Risk: FFNx's current implementation in src/common.cpp returns paths for the English version (e.g., data/, movies/). Your research (AF3DN_ANALYSIS.md) shows ff7_ja.exe is hardcoded to look for language-specific paths like lang-ja/, menu_ja.lgp, and jfleve.lgp.\nConclusion: If we launch ff7_ja.exe with an unmodified FFNx, the registry hooks will feed it incorrect English paths, leading to asset loading failures and a likely crash. We must make these hooks language-aware.\nPART III: STEP-BY-STEP IMPLEMENTATION GUIDE\nThis is the core instruction set for the developer agent. Each step includes the objective, file locations, and detailed code-level instructions.\nStep 1: Implement User Configuration\nObjective: Create a toggle in FFNx.toml to enable Japanese mode, providing a clean entry point for all subsequent logic.\n1.1. src/cfg.h - Expose Global Variables\nAdd these declarations to make the settings accessible throughout the codebase.\ncode\nC++\n// src/cfg.h\n\n// ... after existing externs\nextern std::string font_language;\nextern bool font_enable_furigana;\nextern std::string font_path_override;\n1.2. src/cfg.cpp - Parse TOML Settings\nAdd logic to read_cfg() to load the values.\ncode\nC++\n// src/cfg.cpp\n\n// At top of file with other definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing toml::parse_file logic ...\n\n    // At the end of the function, before \"SAFE DEFAULTS\"\n    font_language = config[\"font_language\"].value_or(\"en\");\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}\nStep 2: Make Registry Hooks Language-Aware\nObjective: Prevent ff7_ja.exe from crashing by providing it with the correct, language-specific file paths it expects.\n2.1. src/common.cpp - Modify dotemuRegQueryValueExA\nThis function is a virtual registry. We must teach it about Japanese file paths.\ncode\nC++\n// src/common.cpp\n\n__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)\n{\n    // ... function start ...\n\n    // [NEW] Add logic to detect the running executable\n    char exePath[MAX_PATH];\n    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n    _strlwr(exePath);\n    bool isJapaneseExe = (strstr(exePath, \"ff7_ja.exe\") != NULL);\n\n    /* FF7 */\n    // General\n    if (strcmp(lpValueName, \"AppPath\") == 0)\n    {\n        // ... existing logic is fine ...\n    }\n    else if (strcmp(lpValueName, \"DataPath\") == 0)\n    {\n        GetCurrentDirectory(*lpcbData, buf);\n        // [MODIFIED] Append language-specific path\n        if (isJapaneseExe) {\n            strcat(buf, R\"(\\data\\lang-ja\\)\");\n        } else {\n            strcat(buf, R\"(\\data\\)\");\n        }\n        strcpy((CHAR*)lpData, buf);\n    }\n    // ... repeat this pattern for \"MoviePath\", etc.\n    // ... ensure to check for \"jfleve.lgp\" vs \"flevel.lgp\" if that is queried here.\n    // ... existing logic ...\n\n    return ret;\n}\nStep 3: Force 6-Page Texture Allocation for Fonts\nObjective: Prevent a buffer overflow by ensuring FFNx allocates enough memory to hold 6 texture handles when the game loads its font.\n3.1. src/common.cpp - Modify common_load_texture\nThis is the most critical structural change.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)\n{\n    // ... variable declarations ...\n\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    if(!VREF(texture_set, ogl.gl_set))\n    {\n        // ... existing allocation of gl_set ...\n    }\n\n    // [NEW] Check if this is the font texture\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n    \n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures_to_alloc;\n\n        if (is_font_texture && font_language == \"ja\")\n        {\n            // [MODIFIED] Force allocation for 6 textures for Japanese font.\n            num_textures_to_alloc = 6;\n            ffnx_info(\"Japanese font detected. Forcing allocation for %d texture pages.\\n\", num_textures_to_alloc);\n        }\n        else \n        {\n            // [ORIGINAL LOGIC]\n            num_textures_to_alloc = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures_to_alloc);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(num_textures_to_alloc, sizeof(uint32_t)));\n        \n        // ... existing stats.texture_count++ etc. ...\n    }\n\n    // ... rest of the function ...\n    return _texture_set;\n}\nStep 4: Implement Multi-Texture Asset Loader\nObjective: When FFNx detects a request for the font, iterate from 0 to 5 and load jafont_1.png, jafont_2.png, etc., into their respective pre-allocated slots.\n4.1. src/saveload.cpp - Modify load_texture\nThis function orchestrates the external texture loading.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)\n{\n    // [NEW] Special handler for Japanese fonts\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char filename[sizeof(basedir) + 1024]{ 0 };\n        std::string base_path = !override_mod_path.empty() ? override_mod_path : mod_path;\n        uint32_t first_handle = 0;\n\n        for (int i = 0; i < 6; i++) {\n            // Construct the path for each font page, e.g., mods/Textures/menu/jafont_1.png\n            _snprintf(filename, sizeof(filename), \"%s/%s/%s_%d.png\", basedir, base_path.c_str(), \"jafont\", i + 1);\n            normalize_path(filename);\n            \n            uint32_t w, h;\n            uint32_t texture_handle = load_texture_helper(filename, &w, &h, true, true);\n            \n            if (texture_handle) {\n                // Manually assign the loaded texture to its correct \"palette\" index\n                gl_set->additional_textures[i] = texture_handle; // A bit of a hack, but should work. A better way would be to modify gl_replace_texture to accept an index.\n                if (i == 0) first_handle = texture_handle;\n                ffnx_info(\"Successfully loaded Japanese font page %d into memory from %s\\n\", i, filename);\n            } else {\n                ffnx_error(\"CRITICAL: Failed to load Japanese font page %d. Ensure file exists: %s\\n\", i, filename);\n            }\n        }\n\n        // Return the first handle as the \"main\" texture. The others are now cached.\n        return first_handle;\n    }\n\n    // ... original logic for animated and normal textures ...\n    uint32_t ret = 0;\n    // ...\n}\nNote: A small refactor of gl_replace_texture in src/gl/texture.cpp to take a palette_index would be cleaner than using additional_textures.\nStep 5: Patch Character Width Table in Memory\nObjective: Fix the \"squashed Kanji\" by overwriting the game's internal character width table with a fixed-width value suitable for Japanese.\n5.1. Create src/ff7/font.cpp and src/ff7/font.h\nIt's best to encapsulate font-specific logic.\ncode\nC++\n// src/ff7/font.h\n#pragma once\n#include \"../common.h\"\nvoid PatchFontWidthsForJapanese();\n\n// src/ff7/font.cpp\n#include \"font.h\"\n#include \"../globals.h\"\n#include \"../log.h\"\n\nvoid PatchFontWidthsForJapanese()\n{\n    if (font_language != \"ja\") {\n        return;\n    }\n\n    // This address is for US 1.02, needs to be confirmed for other versions if needed.\n    char* font_width_table = common_externals.font_info;\n\n    if (!font_width_table) {\n        ffnx_error(\"Could not find font width table in memory. Cannot patch for Japanese.\\n\");\n        return;\n    }\n\n    ffnx_info(\"Patching in-memory font width table for fixed-width Japanese characters...\\n\");\n\n    DWORD oldProtect;\n    if (VirtualProtect(font_width_table, 256, PAGE_READWRITE, &oldProtect))\n    {\n        for (int i = 0; i < 256; i++)\n        {\n            // The original game geometry is based on a 320x240 coordinate system.\n            // 16px is the standard width for a full-width character in that context.\n            font_width_table[i] = 16;\n        }\n        VirtualProtect(font_width_table, 256, oldProtect, &oldProtect);\n        ffnx_info(\"Font width table patched successfully.\\n\");\n    }\n    else\n    {\n        ffnx_error(\"Failed to change memory protection for font width table. Japanese text will be squashed.\\n\");\n    }\n}\n5.2. Call the patch from src/ff7_opengl.cpp\nIn ff7_init_hooks, after ff7_data(game_object);:\ncode\nC++\n// src/ff7_opengl.cpp\n#include \"ff7/font.h\" // Add this include\n\nvoid ff7_init_hooks(struct game_obj *_game_object)\n{\n    // ...\n    ff7_data(game_object);\n\n    // [NEW] Apply font patches if Japanese mode is enabled\n    PatchFontWidthsForJapanese();\n\n    // ... rest of the hooks\n}\nStep 6: Implement Text Parser Hook for Page Switching\nObjective: Intercept the game's text rendering loop to process our FA-FE page-switching codes. This requires an in-memory assembly patch.\n6.1. Add a Hext Patch File\nCreate a new file: misc/hext/ff7/en/FFNx.JAPANESE_FONT.txt\ncode\nHext\n# FFNx Japanese Font Support Patch\n# This hooks the character drawing loop to handle FA-FE page markers.\n# The target address needs to be found via debugger/disassembler.\n# For FF7.exe 1.02 US, this is inside the text drawing function.\n# Let's assume a hypothetical address for now: 0x6E9A00\n\n+0\n\n# We need a new global variable in FFNx's memory space to store the current page.\n# FFNx will need to expose a pointer to this variable. Let's assume FFNx creates\n# a `g_currentFontPage` at a known offset. For now, we'll use a placeholder.\n# Let's say FFNx's base is 0x10000000 and we reserve `+0x1234` for it.\n! This requires a C++ change to expose a global variable.\n\n0x6E9A00 =  CMP AL, 0xFA          ; Is the character code >= FA?\n            JB @@RenderNormal     ; If not, it's a standard character.\n            \n            ; It's a page marker.\n            SUB AL, 0xFA          ; Map FA->0, FB->1, etc.\n            INC AL                ; Map to page index 1-5\n            MOV BYTE PTR [0x10001234], AL ; Store the new page index in our global variable\n            \n            ; Move to the next byte, which is the actual character index\n            MOV ESI, [EBP-0x10]   ; Assuming ESI holds the string pointer (this needs verification)\n            INC ESI\n            MOV [EBP-0x10], ESI\n            MOVZX EAX, BYTE PTR [ESI] ; Load the character index into EAX (AL)\n            \n            JMP @@DrawCharacter\n\n@@RenderNormal:\n            MOV BYTE PTR [0x10001234], 0 ; It's a normal character, so use page 0.\n\n@@DrawCharacter:\n            ; ... Here would be the original code that we overwrote, now executed after our logic.\n            ; This part needs to be carefully copied from the original executable.\n            ; For example: PUSH EAX, CALL SomeRenderFunc, etc.\n```**This Hext file is conceptual.** The exact address (`0x6E9A00`) and registers (`EBP-0x10`) must be found by reverse-engineering the text rendering loop of `ff7.exe`.\n\n#### **6.2. FFNx Side: Read the Page Index**\nFFNx needs to read the value written by the Hext patch.\n\n**In `src/globals.h`:**\n```cpp\n// Add a global variable for the current font page\nextern uint8_t g_currentFontPage;\nIn src/common.cpp:\ncode\nC++\nuint8_t g_currentFontPage = 0;\nIn src/gl/gl.cpp, inside gl_draw_indexed_primitive:\ncode\nC++\n// This function receives the geometry for a single character.\nvoid gl_draw_indexed_primitive(...)\n{\n    // ...\n    \n    // If we're drawing a font, and Japanese is enabled...\n    if (is_font_texture && font_language == \"ja\") {\n        \n        // Use the global page index set by our Hext patch\n        uint32_t palette_index = g_currentFontPage;\n        \n        // This is the CRITICAL part. Instead of using the game's requested palette,\n        // we force the texture set to use the one from our global variable.\n        VOBJ(texture_set, texture_set, current_state.texture_set);\n        VRASS(texture_set, palette_index, palette_index);\n        \n        // This will now select jafont_1, jafont_2, etc. correctly.\n        gl_bind_texture_set(current_state.texture_set);\n    }\n\n    // ... rest of the drawing logic ...\n}\nPART IV: FURIGANA SUPPORT (ADVANCED IMPLEMENTATION)\nGoal: Render small Hiragana text above Kanji. This requires a significant modification to the rendering and layout logic.\n7.1. Data Format Extension\nWe must define a new control code for Furigana. Let's use 0xF9.\nFormat: {0xF9} [Kanji Char Index] [Furigana Char Index 1] [Furigana Char Index 2] ... {0x00}\nExample: \u79c1 (\u308f\u305f\u3057) would be 0xF9 0x81 0x41 0x42 0x43 0x00.\n7.2. Hext Patch for Furigana\nThe text rendering hook needs to be extended.\ncode\nAssembly\n; ... existing FA-FE check ...\n\nCMP AL, 0xF9\nJNE NotFurigana\n\n; Handle Furigana\nCALL FFNx_EnterFuriganaMode ; A function exported by FFNx.dll\n\n; Loop to draw Furigana characters (small and above)\nFuriganaLoop:\n    INC ESI\n    MOV AL, [ESI]\n    CMP AL, 0x00      ; End of Furigana string?\n    JE EndFurigana\n    ; ... code to call the draw function for the Furigana char ...\n    JMP FuriganaLoop\n\nEndFurigana:\nCALL FFNx_ExitFuriganaMode\nJMP NextChar\n\nNotFurigana:\n; ... existing logic ...\n7.3. FFNx Renderer Modification (gl_draw_indexed_primitive)\nFFNx needs to maintain a \"Furigana Mode\" state.\ncode\nC++\n// src/renderer.h\n// Add to Renderer class\nbool isFuriganaMode = false;\nvoid SetFuriganaMode(bool enabled);\n\n// src/renderer.cpp\nvoid Renderer::SetFuriganaMode(bool enabled) {\n    isFuriganaMode = enabled;\n}\n\n// src/gl/gl.cpp\nvoid gl_draw_indexed_primitive(...) {\n    \n    if (newRenderer.isFuriganaMode) {\n        // Modify the geometry before drawing\n        \n        // 1. Scale down the vertices\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.x *= 0.5f;\n            vertices[i]._.y *= 0.5f;\n        }\n        \n        // 2. Apply a Y-offset\n        // This value needs to be tuned.\n        float y_offset = -8.0f * newRenderer.getScalingFactor();\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.y += y_offset;\n        }\n    }\n    \n    // ... proceed with the normal draw call ...\n}\n7.4. Window Layout Patch (The Hardest Part)\nTo prevent Furigana from overlapping with the line above, we must increase the line height.\nTarget: The memory location that stores the value 16 (default line height).\nAction: Use a Hext patch to change this value to 24 or 32.\nConsequence: Text boxes will now fit fewer lines of text (e.g., 2 instead of 3). This is a necessary trade-off. The exact address must be found through reverse engineering ff7.exe.\nPART V: TESTING & VERIFICATION PLAN\nUnit Test 1 (Red 'W'): Verify FFNx texture override works. Replace USFONT.PNG with a version where 'W' is a red Kanji. Confirm it appears in-game (even if squashed).\nUnit Test 2 (Width Patch): Apply the width table patch. Launch the game. All English text should now be widely spaced. The red 'W' Kanji should appear at its correct width.\nIntegration Test 1 (Multi-Texture Load): Enable Japanese mode. Check FFNx.log. Confirm that 6 jafont_*.png files are successfully loaded into memory.\nIntegration Test 2 (Page Switching): Manually patch a dialogue string in memory (using a debugger) to include 0xFA 0x00. When the dialogue appears, the game should display the '\u5fc5' character from jafont_2.\nFull System Test: Use a modified flevel.lgp (created with an extended touphScript) containing a fully Japanese-translated scene. Play through the scene and verify all text renders correctly.\nThis document provides a complete, top-to-bottom guide for implementing Japanese support. By following these steps, a developer AI agent can systematically modify the FFNx codebase and create the necessary game patches to achieve the project's goals. The key is to address the architectural constraints\u2014texture allocation, character width, and registry virtualization\u2014before tackling the text parsing logic.\nModel\nThinkingThoughts\nManual: 15509\nExpand to view model thoughts\n\nchevron_right\nOf course. I understand completely. My previous responses were designed for conciseness, but I see now that what you require is an exhaustive, single-source-of-truth document that leaves no room for ambiguity. You've provided a mountain of high-quality research and code, and you deserve an equally comprehensive analysis in return.\nThe following document is the master technical specification you requested. It is designed to be copy-pasted into a .md file and serve as the complete and final instruction set for a developer AI agent. It synthesizes all your research findings from AF3DN_ANALYSIS.md, FINDINGS.md, and the other documents, cross-references them with the FFNx source code, and provides a granular, code-level implementation plan. It is structured to be the only document an engineer would need to begin and complete this project.\nFFNx Developer Onboarding Bible: Japanese Language Implementation\nDocument Version: 3.0 (Master Technical Specification)\nProject Codename: \"One-7 Language Learner Edition\"\nTarget Platform: FFNx Driver for Final Fantasy VII (1998/2013 PC)\nDate: 2025-11-20\nPART I: MISSION BRIEFING & STRATEGIC OVERVIEW\n1.1. Executive Summary\nThe Mission: To extend the FFNx graphics driver to enable full, native Japanese text rendering within the English PC version of Final Fantasy VII. This is the foundational step toward creating a multi-language learning tool, with future goals including real-time language toggling and Furigana (reading guide) support.\nThe Core Problem: The original English FF7 executable (ff7.exe) is architecturally limited to a single-byte character encoding system. It can only address a maximum of 256 unique characters, which are rendered from a single font texture (USFONT.TEX). This is sufficient for Latin-based languages but is mathematically incapable of supporting the ~2,300+ glyphs required for Japanese (Hiragana, Katakana, and Kanji).\nThe Breakthrough Discovery: Your research has uncovered and analyzed the rare 2013 Japanese eStore version of FF7. This version includes a custom graphics driver, AF3DN.P, which solves this exact problem. It uses a multi-texture system (6 font pages named jafont_1.tex through jafont_6.tex) and an extended character encoding system (using 0xFA-0xFE as page-switching opcodes). We now have a production-proven architectural blueprint.\nThe Strategy (Path C - Hybrid FFNx Extension): We will not use the proprietary AF3DN.P directly. Instead, we will reimplement its core logic within the open-source FFNx driver. This approach is legally sound, community-friendly, and leverages FFNx's modern rendering backend (BGFX) for superior performance and future extensibility. This document outlines the precise, code-level steps required to achieve this.\n1.2. Key Terminology & Concepts\nFFNx: A modern, open-source graphics driver for FF7/FF8 that replaces the original game's driver. It provides advanced features like high-resolution rendering, texture replacement, and a modding API. It is our primary development target.\n7th Heaven: A mod manager for FF7. It acts as a virtual file system, intercepting the game's file requests and feeding it modded assets from .iro archives. It is the primary distribution platform for this project.\nLGP Archive (.lgp): Square Enix's proprietary archive format, akin to a .zip file. Game assets like textures, models, and dialogue are packed inside.\nTEX Texture (.tex): A bitmap image format used by the FF7 PC port, derived from the PlayStation's TIM format.\nFF Text Encoding: The game's internal single-byte text format. Character codes are mapped to positions on the font texture.\nFA-FE Page Markers: The custom 2-byte encoding system used by the Japanese version. The first byte (0xFA to 0xFE) selects one of the five extended font textures, and the second byte is the character's index within that texture.\nCharacter Width Table: A data table located in the game's memory (originally from KERNEL.BIN/WINDOW.BIN) that defines the pixel width of every character. This is the source of the \"squashed Kanji\" problem and a critical target for patching.\n1.3. Architectural Load Order (The \"Layer Cake\")\nUnderstanding how assets are loaded is critical. The first asset found in this hierarchy wins:\nLayer 1 (Top Priority): FFNx mods/ Folder\nMechanism: Loose files on the hard drive (e.g., mods/Textures/menu/usfont_h.png). FFNx checks this folder first.\nRole: Used for rapid prototyping, testing, and user-level overrides. This is where your successful \"Red Text Test\" operated.\nLayer 2: 7th Heaven IROs\nMechanism: A Virtual File System (VFS). 7th Heaven intercepts the game's API calls to read files from disk. If a mod in an .iro archive provides a replacement file, 7th Heaven feeds that file's data to the game instead of the one on the hard drive.\nRole: The primary distribution method for mods. It handles models, dialogue, audio, and textures.\nLayer 3 (Bottom Priority): Vanilla Game Data\nMechanism: The original game files on the hard drive (e.g., data/menu/menu_us.lgp).\nRole: The fallback if no mods provide an override.\nPART II: DEEP DIVE - TECHNICAL ANALYSIS & CONSTRAINTS\nThis section synthesizes the critical findings from your research and the FFNx codebase. Understanding these constraints is non-negotiable for a successful implementation.\n2.1. The Geometry vs. Texture Problem (\"Squashed Kanji\")\nThis is the single most important technical hurdle. Failure to address this will result in unreadable text.\nSymptom: You replaced an English character's texture with a full-width Kanji, but in-game, the Kanji was horizontally compressed, cropped, or \"squashed.\"\nRoot Cause: The FF7 engine separates geometry generation from texture mapping.\nGeometry Generation (FF7.exe): When the game needs to draw a character (e.g., 'i'), it looks up its width in a Character Width Table stored in memory. For 'i', this might be 4 pixels. It then generates a 3D quad (two triangles) that is exactly 4 pixels wide.\nTexture Mapping (FFNx): FFNx receives this pre-calculated 4-pixel-wide quad and is told to apply the font texture to it. It maps the full texture coordinates of the character's cell onto this tiny quad, resulting in severe compression.\nLocation of Width Table: Your research and the FFNx source confirm this table is pointed to by common_externals.font_info in src/ff7_data.h. For the US 1.02 executable, this address is 0x99DDA8.\nConclusion: Simply replacing the font texture is insufficient. We must also patch the game's memory to ensure it generates correctly-sized geometry for each character.\n2.2. The Texture Allocation & Palette System\nFFNx uses a system that mimics the PlayStation's palette-swapping capability to handle textures with multiple color variations. This is our key to implementing multi-page font support without a major renderer rewrite.\nThe Mechanism:\nA texture_set struct holds an array of GPU texture handles (texturehandle).\nThe game can request a switch to a different palette_index.\nFFNx intercepts this request in common_palette_changed (src/common.cpp) and binds the corresponding texture handle from the array.\nThe Constraint: The size of the texturehandle array is allocated based on the palettes value in the .TEX file's header. The English USFONT.TEX has palettes = 1, so FFNx allocates 2 slots by default (palettes * 2).\nThe Problem: If we try to load 6 textures for Japanese, we will cause a buffer overflow and crash the game because FFNx only allocated memory for 2.\nConclusion: We must intercept the allocation logic in common_load_texture and force it to allocate 6 slots when it detects the font texture, regardless of what the original file header says.\n2.3. The Registry Virtualization and Pathing\nThe 2013 Steam/eStore executables do not use the Windows Registry directly. They use wrapper functions (e.g., dotemuRegQueryValueExA) which FFNx provides fake implementations for.\nThe System: AF3DN.P (and FFNx) exports these dotemu functions. The game calls them to find its data paths.\nThe Risk: FFNx's current implementation in src/common.cpp returns paths for the English version (e.g., data/, movies/). Your research (AF3DN_ANALYSIS.md) shows ff7_ja.exe is hardcoded to look for language-specific paths like lang-ja/, menu_ja.lgp, and jfleve.lgp.\nConclusion: If we launch ff7_ja.exe with an unmodified FFNx, the registry hooks will feed it incorrect English paths, leading to asset loading failures and a likely crash. We must make these hooks language-aware.\nPART III: STEP-BY-STEP IMPLEMENTATION GUIDE\nThis is the core instruction set for the developer agent. Each step includes the objective, file locations, and detailed code-level instructions.\nStep 1: Implement User Configuration\nObjective: Create a toggle in FFNx.toml to enable Japanese mode, providing a clean entry point for all subsequent logic.\n1.1. src/cfg.h - Expose Global Variables\nAdd these declarations to make the settings accessible throughout the codebase.\ncode\nC++\n// src/cfg.h\n\n// ... after existing externs\nextern long external_music_volume;\nextern bool ff7_advanced_blinking;\nextern long display_index;\n\n// [NEW] Japanese Support Configuration\nextern std::string font_language;         // \"en\" or \"ja\"\nextern bool font_enable_furigana;         // true/false\nextern std::string font_path_override;    // Custom path for font textures\n1.2. src/cfg.cpp - Parse TOML Settings\nRegister the new variables and parse them from the TOML configuration file.\ncode\nC++\n// src/cfg.cpp\n\n// [NEW] Definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing parsing code ...\n\n    // [NEW] Font Configuration\n    // Default to \"en\" (English) to maintain backward compatibility\n    font_language = config[\"font_language\"].value_or(\"en\");\n    \n    // Enable Furigana (Ruby Text) support? Default false.\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    \n    // Allow manual override of the font folder (e.g., \"mods/Fonts/ja\")\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}```\n\n### **Step 2: Make Registry Hooks Language-Aware**\n\n**Objective:** Prevent `ff7_ja.exe` from crashing by providing it with the correct, language-specific file paths it expects.\n\n#### **2.1. `src/common.cpp` - Modify `dotemuRegQueryValueExA`**\nThis function is a virtual registry. We must teach it about Japanese file paths.\n\n```cpp\n// src/common.cpp\n\n__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)\n{\n    // ... function start ...\n\n    // [NEW] Add logic to detect the running executable\n    char exePath[MAX_PATH];\n    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n    _strlwr(exePath);\n    bool isJapaneseExe = (strstr(exePath, \"ff7_ja.exe\") != NULL);\n\n    /* FF7 */\n    // General\n    if (strcmp(lpValueName, \"AppPath\") == 0)\n    {\n        // ... existing logic is fine ...\n    }\n    else if (strcmp(lpValueName, \"DataPath\") == 0)\n    {\n        GetCurrentDirectory(*lpcbData, buf);\n        // [MODIFIED] Append language-specific path\n        if (isJapaneseExe) {\n            strcat(buf, R\"(\\data\\lang-ja\\)\");\n        } else {\n            strcat(buf, R\"(\\data\\)\");\n        }\n        strcpy((CHAR*)lpData, buf);\n    }\n    // ... repeat this pattern for \"MoviePath\", etc.\n    // ... ensure to check for \"jfleve.lgp\" vs \"flevel.lgp\" if that is queried here.\n    // ... existing logic ...\n\n    return ret;\n}\nStep 3: Force 6-Page Texture Allocation for Fonts\nObjective: Prevent a buffer overflow by ensuring FFNx allocates enough memory to hold 6 texture handles when the game loads its font.\n3.1. src/common.cpp - Modify common_load_texture\nThis is the most critical structural change.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)\n{\n    // ... variable declarations ...\n\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    if(!VREF(texture_set, ogl.gl_set))\n    {\n        // ... existing allocation of gl_set ...\n    }\n\n    // [NEW] Check if this is the font texture\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n    \n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures_to_alloc;\n\n        if (is_font_texture && font_language == \"ja\")\n        {\n            // [MODIFIED] Force allocation for 6 textures for Japanese font.\n            num_textures_to_alloc = 6;\n            ffnx_info(\"Japanese font detected. Forcing allocation for %d texture pages.\\n\", num_textures_to_alloc);\n        }\n        else \n        {\n            // [ORIGINAL LOGIC]\n            num_textures_to_alloc = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures_to_alloc);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(num_textures_to_alloc, sizeof(uint32_t)));\n        \n        // ... existing stats.texture_count++ etc. ...\n    }\n\n    // ... rest of the function ...\n    return _texture_set;\n}\nStep 4: Implement Multi-Texture Asset Loader\nObjective: When FFNx detects a request for the font, iterate from 0 to 5 and load jafont_1.png, jafont_2.png, etc., into their respective pre-allocated slots.\n4.1. src/saveload.cpp - Modify load_texture\nThis function orchestrates the external texture loading.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)\n{\n    // [NEW] Special handler for Japanese fonts\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char filename[sizeof(basedir) + 1024]{ 0 };\n        std::string base_path = !override_mod_path.empty() ? override_mod_path : mod_path;\n        uint32_t first_handle = 0;\n\n        for (int i = 0; i < 6; i++) {\n            // Construct the path for each font page, e.g., mods/Textures/menu/jafont_1.png\n            _snprintf(filename, sizeof(filename), \"%s/%s/%s_%d.png\", basedir, base_path.c_str(), \"jafont\", i + 1);\n            normalize_path(filename);\n            \n            uint32_t w, h;\n            uint32_t texture_handle = load_texture_helper(filename, &w, &h, true, true);\n            \n            if (texture_handle) {\n                // Manually inject this texture into the specific palette slot\n                // Slot 0 = jafont_1 (Basic Kana)\n                // Slot 1 = jafont_2 (Kanji A)\n                // ...\n                gl_replace_texture(texture_set, i, new_texture);\n                ffnx_info(\"Successfully loaded Japanese font page %d into memory from %s\\n\", i, filename);\n            } else {\n                ffnx_error(\"CRITICAL: Failed to load Japanese font page %d. Ensure file exists: %s\\n\", i, filename);\n            }\n        }\n        \n        // Return the handle for Page 0 (Default) so the game has something valid immediately\n        return VREF(texture_set, texturehandle[0]);\n    }\n\n    // ... original logic for animated and normal textures ...\n    uint32_t ret = 0;\n    // ...\n}\n```*Note: A small refactor of `gl_replace_texture` in `src/gl/texture.cpp` to take a `palette_index` would be cleaner than using `additional_textures`.*\n\n### **Step 5: Patch Character Width Table in Memory**\n\n**Objective:** Fix the \"squashed Kanji\" by overwriting the game's internal character width table with a fixed-width value suitable for Japanese.\n\n#### **5.1. Create `src/ff7/font.cpp` and `src/ff7/font.h`**\nIt's best to encapsulate font-specific logic.\n\n```cpp\n// src/ff7/font.h\n#pragma once\n#include \"../common.h\"\nvoid PatchFontWidthsForJapanese();\n\n// src/ff7/font.cpp\n#include \"font.h\"\n#include \"../globals.h\"\n#include \"../log.h\"\n\nvoid PatchFontWidthsForJapanese()\n{\n    if (font_language != \"ja\") {\n        return;\n    }\n\n    // This address is for US 1.02, needs to be confirmed for other versions if needed.\n    char* font_width_table = common_externals.font_info;\n\n    if (!font_width_table) {\n        ffnx_error(\"Could not find font width table in memory. Cannot patch for Japanese.\\n\");\n        return;\n    }\n\n    ffnx_info(\"Patching in-memory font width table for fixed-width Japanese characters...\\n\");\n\n    DWORD oldProtect;\n    if (VirtualProtect(font_width_table, 256, PAGE_READWRITE, &oldProtect))\n    {\n        for (int i = 0; i < 256; i++)\n        {\n            // The original game geometry is based on a 320x240 coordinate system.\n            // 16px is the standard width for a full-width character in that context.\n            font_width_table[i] = 16; \n            \n            // Refinement: You might want narrower widths for punctuation or ASCII \n            // if you map them to the first page.\n            if (i < 0x20) font_table[i] = 8; // Example for spaces/numbers\n        }\n        VirtualProtect(font_width_table, 256, oldProtect, &oldProtect);\n        ffnx_info(\"Font width table patched successfully.\\n\");\n    }\n    else\n    {\n        ffnx_error(\"Failed to change memory protection for font width table. Japanese text will be squashed.\\n\");\n    }\n}\n5.2. Call the patch from src/ff7_opengl.cpp\nIn ff7_init_hooks, after ff7_data(game_object);:\ncode\nC++\n// src/ff7_opengl.cpp\n#include \"ff7/font.h\" // Add this include\n\nvoid ff7_init_hooks(struct game_obj *_game_object)\n{\n    // ...\n    ff7_data(game_object);\n\n    // [NEW] Apply font patches if Japanese mode is enabled\n    PatchFontWidthsForJapanese();\n\n    // ... rest of the hooks\n}\nStep 6: Implement Text Parser Hook for Page Switching\nObjective: Intercept the game's text rendering loop to process our FA-FE page-switching codes. This requires an in-memory assembly patch.\n6.1. Add a Hext Patch File\nCreate a new file: misc/hext/ff7/en/FFNx.JAPANESE_FONT.txt\ncode\nHext\n# FFNx Japanese Font Support Patch\n# This hooks the character drawing loop to handle FA-FE page markers.\n# The target address needs to be found via debugger/disassembler.\n# For FF7.exe 1.02 US, this is inside the text drawing function.\n# Let's assume a hypothetical address for now: 0x6E9A00\n\n+0\n\n# We need a new global variable in FFNx's memory space to store the current page.\n# FFNx will need to expose a pointer to this variable. Let's assume FFNx creates\n# a `g_currentFontPage` at a known offset. For now, we'll use a placeholder.\n# Let's say FFNx's base is 0x10000000 and we reserve `+0x1234` for it.\n! This requires a C++ change to expose a global variable.\n\n0x6E9A00 =  CMP AL, 0xFA          ; Is the character code >= FA?\n            JB @@RenderNormal     ; If not, it's a standard character.\n            \n            ; It's a page marker.\n            SUB AL, 0xFA          ; Map FA->0, FB->1, etc.\n            INC AL                ; Shift to 1-5 range (0 is reserved for basic page)\n            MOV BYTE PTR [0x10001234], AL ; Store the new page index in our global variable\n            \n            ; Move to the next byte, which is the actual character index\n            MOV ESI, [EBP-0x10]   ; Assuming ESI holds the string pointer (this needs verification)\n            INC ESI\n            MOV [EBP-0x10], ESI\n            MOVZX EAX, BYTE PTR [ESI] ; Load the character index into EAX (AL)\n            \n            JMP @@DrawCharacter\n\n@@RenderNormal:\n            MOV BYTE PTR [0x10001234], 0 ; It's a normal character, so use page 0.\n\n@@DrawCharacter:\n            ; ... Here would be the original code that we overwrote, now executed after our logic.\n            ; This part needs to be carefully copied from the original executable.\n            ; For example: PUSH EAX, CALL SomeRenderFunc, etc.\n```**This Hext file is conceptual.** The exact address (`0x6E9A00`) and registers (`EBP-0x10`) must be found by reverse-engineering the text rendering loop of `ff7.exe`.\n\n#### **6.2. FFNx Side: Read the Page Index**\nFFNx needs to read the value written by the Hext patch.\n\n**In `src/globals.h`:**\n```cpp\n// Add a global variable for the current font page\nextern uint8_t g_currentFontPage;\nIn src/common.cpp:\ncode\nC++\nuint8_t g_currentFontPage = 0;\nIn src/gl/gl.cpp, inside gl_draw_indexed_primitive:\ncode\nC++\n// This function receives the geometry for a single character.\nvoid gl_draw_indexed_primitive(...)\n{\n    // ...\n    \n    // If we're drawing a font, and Japanese is enabled...\n    if (is_font_texture && font_language == \"ja\") {\n        \n        // Use the global page index set by our Hext patch\n        uint32_t palette_index = g_currentFontPage;\n        \n        // This is the CRITICAL part. Instead of using the game's requested palette,\n        // we force the texture set to use the one from our global variable.\n        VOBJ(texture_set, texture_set, current_state.texture_set);\n        VRASS(texture_set, palette_index, palette_index);\n        \n        // This will now select jafont_1, jafont_2, etc. correctly.\n        gl_bind_texture_set(current_state.texture_set);\n    }\n\n    // ... rest of the drawing logic ...\n}\nPART IV: FURIGANA SUPPORT (ADVANCED IMPLEMENTATION)\nGoal: Render small Hiragana text above Kanji. This requires a significant modification to the rendering and layout logic.\nConstraint: FF7 text boxes are 3 lines high with tight spacing. Furigana will clip.\n7.1. Data Format Extension\nWe must define a new control code for Furigana. Let's use 0xF9.\nFormat: {0xF9} [Kanji Char Index] [Furigana Char Index 1] [Furigana Char Index 2] ... {0x00}\nExample: \u79c1 (\u308f\u305f\u3057) would be 0xF9 0x81 0x41 0x42 0x43 0x00.\n7.2. Hext Patch for Furigana\nThe text rendering hook needs to be extended.\ncode\nAssembly\n; ... existing FA-FE check ...\n\nCMP AL, 0xF9\nJNE NotFurigana\n\n; Handle Furigana\nCALL FFNx_EnterFuriganaMode ; A function exported by FFNx.dll\n\n; Loop to draw Furigana characters (small and above)\nFuriganaLoop:\n    INC ESI\n    MOV AL, [ESI]\n    CMP AL, 0x00      ; End of Furigana string?\n    JE EndFurigana\n    ; ... code to call the draw function for the Furigana char ...\n    JMP FuriganaLoop\n\nEndFurigana:\nCALL FFNx_ExitFuriganaMode\nJMP NextChar\n\nNotFurigana:\n; ... existing logic ...\n7.3. FFNx Renderer Modification (gl_draw_indexed_primitive)\nFFNx needs to maintain a \"Furigana Mode\" state.\ncode\nC++\n// src/renderer.h\n// Add to Renderer class\nbool isFuriganaMode = false;\nvoid SetFuriganaMode(bool enabled);\n\n// src/renderer.cpp\nvoid Renderer::SetFuriganaMode(bool enabled) {\n    isFuriganaMode = enabled;\n}\n\n// src/gl/gl.cpp\nvoid gl_draw_indexed_primitive(...) {\n    \n    if (newRenderer.isFuriganaMode) {\n        // Modify the geometry before drawing\n        \n        // 1. Scale down the vertices\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.x *= 0.5f;\n            vertices[i]._.y *= 0.5f;\n        }\n        \n        // 2. Apply a Y-offset\n        // This value needs to be tuned.\n        float y_offset = -8.0f * newRenderer.getScalingFactor();\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.y += y_offset;\n        }\n    }\n    \n    // ... proceed with the normal draw call ...\n}\n7.4. Window Layout Patch (The Hardest Part)\nTo prevent Furigana from overlapping with the line above, we must increase the line height.\nTarget: The memory location that stores the value 16 (default line height).\nAction: Use a Hext patch to change this value to 24 or 32.\nConsequence: Text boxes will now fit fewer lines of text (e.g., 2 instead of 3). This is a necessary trade-off. The exact address must be found through reverse engineering ff7.exe.\nPART V: TESTING & VERIFICATION PROTOCOL\nUnit Test 1 (Red 'W'): Verify FFNx texture override works. Replace USFONT.PNG with a version where 'W' is a red Kanji. Confirm it appears in-game (even if squashed).\nUnit Test 2 (Width Patch): Apply the width table patch. Launch the game. All English text should now be widely spaced. The red 'W' Kanji should appear at its correct width.\nIntegration Test 1 (Multi-Texture Load): Enable Japanese mode. Check FFNx.log. Confirm that 6 jafont_*.png files are successfully loaded into memory.\nIntegration Test 2 (Page Switching): Manually patch a dialogue string in memory (using a debugger) to include 0xFA 0x00. When the dialogue appears, the game should display the '\u5fc5' character from jafont_2.\nFull System Test: Use a modified flevel.lgp (created with an extended touphScript) containing a fully Japanese-translated scene. Play through the scene and verify all text renders correctly.\nPART VI: FULL CODE REFERENCE & APPENDIX\n6.1 Code Block Index\nFeature    Primary File(s)    Key Function(s)/Struct(s)\nConfiguration    src/cfg.h, src/cfg.cpp    read_cfg()\nRegistry Hooks    src/common.cpp    dotemuRegQueryValueExA()\nTexture Allocation    src/common.cpp    common_load_texture()\nAsset Loading    src/saveload.cpp    load_external_texture(), load_texture_helper()\nWidth Table Patch    src/ff7/font.cpp    PatchFontWidthsForJapanese()\nParser Hook    misc/hext/ff7/en/    FFNx.JAPANESE_FONT.txt (to be created)\nRendering Logic    src/gl/gl.cpp    gl_draw_indexed_primitive()\nFurigana (Advanced)    src/renderer.h, src/gl/gl.cpp    SetFuriganaMode(), modified draw call\n6.2 Character Mapping Data (ff7_complete_mapping_compact.csv)\ncode\nCsv\ntexture,index,character,unicode\njafont_1,0,\u30d0,U+30D0\njafont_1,1,\u3070,U+3070\njafont_1,2,\u30d3,U+30D3\njafont_1,3,\u3073,U+3073\n... (Full 1331-line CSV content from your research file) ...\njafont_6,255,,\n(Self-correction: I will not paste the entire 1331-line CSV here to save space for more critical instructions, but the agent should be aware this file is the definitive source for Unicode-to-FF7-Index mapping.)\n6.3 AF3DN.P Analysis Summary\nKey takeaway: The Japanese eStore version proves that a multi-texture, page-switching system is the correct and production-viable architecture. It uses DirectX 9, MultiByteToWideChar for Shift-JIS to Unicode conversion, and relies on a custom driver to load 6 font textures (jafont_1.tim - jafont_6.tim).\nOur path: Reimplement this logic using FFNx's modern BGFX backend and its open-source, flexible architecture rather than using the proprietary, closed-source AF3DN.P directly. This ensures long-term maintainability and community ownership.\n6.4 Glossary\nFFNx Encoding: The custom 2-byte format (FA XX, FB XX, etc.) we are implementing, based on the system used in ff7_ja.exe.\nGlyph: The visual representation of a character.\nHext: A system for applying in-memory assembly patches to an executable at runtime.\nPalette Index: In FFNx, this is a numeric index that determines which texture handle from a texture_set's array to use for rendering. We are hijacking this system for font page switching.\nThis document provides a complete, top-to-bottom guide for implementing Japanese support. By following these steps, a developer AI agent can systematically modify the FFNx codebase and create the necessary game patches to achieve the project's goals. The key is to address the architectural constraints\u2014texture allocation, character width, and registry virtualization\u2014before tackling the text parsing logic.\nUser\nis there anything from this you have missed:\nHere is the FFNx Japanese Implementation Bible.\nThis document consolidates every scrap of research from your sessions (AF3DN.P analysis, file structure validation, texture mapping, and codebase auditing) into a single, executable instruction manual. It is designed to be pasted directly into a Dev AI Agent (like Cursor/Windsurf) to provide 100% context without needing external lookups.\nFFNX_JAPANESE_IMPLEMENTATION_BIBLE.md\nTarget Application: Final Fantasy VII (PC - 1998 / Steam 2012) & Final Fantasy VIII (PC)\nTarget Architecture: FFNx Driver (C++ / BGFX)\nObjective: Implement Native Japanese Text Rendering, Runtime Language Switching, and Furigana Support.\nReference Hardware: Square Enix Japanese eStore Release (ff7_ja.exe + AF3DN.P)\n1. ARCHITECTURAL OVERVIEW & STRATEGY\n1.1 The Core Technical Deficit\nThe English FF7 engine (ff7_en.exe) uses a Single-Byte Encoding system (0x00-0xFF) hardcoded to load a single texture page (USFONT.TEX). It cannot address the ~2,300 characters required for Japanese.\nThe Japanese engine (ff7_ja.exe) utilized a custom driver (AF3DN.P) to implement a Multi-Page Texture System via unused control codes (0xFA - 0xFE).\n1.2 The \"Hybrid Path\" Solution\nWe will not replace the executable. We will extend FFNx to emulate the AF3DN.P font logic while running on the English (or Japanese) executable.\nThe System Logic:\nAsset Expansion: We force FFNx to allocate 6 texture slots for the font instead of 1.\nLogic Injection: We patch the game's text parser (ASM) to interpret FA-FE as \"Switch Texture Page\".\nRenderer State: We hook FFNx's common_palette_changed to detect these page switches and bind the correct jafont_X.png texture.\nGeometry Correction: We patch the in-memory Width Table to prevent 16px Kanji from being squashed into 8px English character widths.\n2. ASSET SPECIFICATIONS\nThe Dev Agent must assume the existence of the following assets in mods/Textures/menu/:\njafont_1.png (Base Page): Hiragana, Katakana, Numbers, English (0x00-0xE6).\njafont_2.png (Page 1): Kanji Set A (Battle Terms). Triggered by 0xFA.\njafont_3.png (Page 2): Kanji Set B. Triggered by 0xFB.\njafont_4.png (Page 3): Kanji Set C. Triggered by 0xFC.\njafont_5.png (Page 4): Kanji Set D. Triggered by 0xFD.\njafont_6.png (Page 5): Kanji Set E. Triggered by 0xFE.\nTexture Specs: 1024x1024 resolution, 16x16 grid layout, 64px glyph size.\n3. C++ IMPLEMENTATION MAP\n3.1 Configuration & Global State (src/cfg.h / src/cfg.cpp)\nContext: We need a user-facing toggle and internal state tracking for the active language.\nAction in src/cfg.h:\nAdd these externs:\ncode\nC++\nextern std::string font_language;       // \"en\", \"ja\", \"fr\", etc.\nextern bool font_enable_furigana;       // Toggle for Ruby text logic\nextern std::string font_path_override;  // Custom path for font textures\nextern bool is_using_japanese_exe;      // Runtime detection flag\nAction in src/cfg.cpp:\nIn read_cfg():\ncode\nC++\nfont_language = config[\"font_language\"].value_or(\"en\");\nfont_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\nfont_path_override = config[\"font_path_override\"].value_or(\"\");\n3.2 Runtime Executable Detection (src/common.cpp)\nContext: The Japanese executable (ff7_ja.exe) expects different registry paths than the English one. FFNx creates \"Fake Registry\" functions (dotemuRegQueryValueExA) to feed data to the game. If we feed English paths to the Japanese EXE, it crashes.\nAction in src/common.cpp -> DllMain:\nDetect the host process immediately.\ncode\nC++\nchar moduleName[MAX_PATH];\nGetModuleFileNameA(NULL, moduleName, MAX_PATH);\nif (strstr(moduleName, \"ff7_ja.exe\")) {\n    is_using_japanese_exe = true;\n    font_language = \"ja\"; // Force JA language if using JA exe\n}\nAction in src/common.cpp -> dotemuRegQueryValueExA:\nModify the path return logic.\ncode\nC++\nif (is_using_japanese_exe) {\n    if (strcmp(lpValueName, \"DataPath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/\"); // Critical Path Correction\n        return ERROR_SUCCESS;\n    }\n    if (strcmp(lpValueName, \"MoviePath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/movies/\");\n        return ERROR_SUCCESS;\n    }\n    // Handle \"AppPath\" similarly\n}\n3.3 The \"JFLEVE\" Typo Fix (src/redirect.cpp)\nContext: Research found the Japanese field archive is named jfleve.lgp (missing 'l'), while English is flevel.lgp. FFNx's redirection logic usually normalizes names, which might break this specific file load.\nAction in src/redirect.cpp -> attempt_redirection:\ncode\nC++\n// Inside the file detection loop\nif (font_language == \"ja\" && strstr(in, \"flevel.lgp\")) {\n    // Remap request for flevel to jfleve\n    std::string ja_path = std::string(in);\n    replaceOnce(ja_path, \"flevel.lgp\", \"jfleve.lgp\"); \n    if (fileExists(ja_path.c_str())) {\n        strcpy(out, ja_path.c_str());\n        return 0;\n    }\n}\n3.4 Texture Memory Allocation Hack (src/common.cpp)\nContext: This is the most critical C++ change. The game requests USFONT.TEX. The header says \"1 Palette\". FFNx allocates palette_count * 2 textures. We need 6. If we don't override this, loading jafont_3 will write to unallocated memory (Segfault).\nAction in src/common.cpp -> common_load_texture:\nFind the allocation block (~Line 1450).\ncode\nC++\nbool is_font = strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\");\n\nif (is_font && font_language == \"ja\") {\n    // FORCE 6 TEXTURE SLOTS\n    VRASS(texture_set, ogl.gl_set->textures, 6);\n    VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(6, sizeof(uint32_t)));\n    ffnx_info(\"Japanese Font Detected: Forced allocation of 6 texture pages.\\n\");\n} else {\n    // Standard Behavior\n    VRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);\n    // ... standard allocation\n}\n3.5 The Multi-Page Loader (src/saveload.cpp)\nContext: When the font is requested, we must ignore the game's pixel buffer and instead load our 6 external PNGs immediately into the slots we just allocated.\nAction in src/saveload.cpp -> load_external_texture:\ncode\nC++\nif (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\"))) {\n    std::string path = font_path_override.empty() ? mod_path + \"/menu/\" : font_path_override;\n    \n    // Load all 6 pages\n    for (int i = 0; i < 6; i++) {\n        char filename[1024];\n        // Note: i+1 because files are jafont_1.png, etc.\n        _snprintf(filename, sizeof(filename), \"%sjafont_%d.png\", path.c_str(), i + 1);\n        \n        uint32_t width, height;\n        // load_texture_helper loads PNG to GPU and returns handle\n        uint32_t handle = load_texture_helper(filename, &width, &height, true, true);\n        \n        if (handle) {\n            // Inject into slot i\n            gl_replace_texture(texture_set, i, handle);\n        } else {\n            ffnx_error(\"Failed to load font page: %s\\n\", filename);\n        }\n    }\n    \n    // Return Page 0 handle as the \"default\" so the game doesn't panic\n    return VREF(texture_set, texturehandle[0]);\n}\n3.6 Geometry Width Patch (src/ff7/menu.cpp)\nContext: The \"Squashed Kanji\" Fix. The game calculates 3D quad width based on a lookup table in KERNEL.BIN loaded into RAM. We must overwrite this table in RAM to force wide characters.\nAction in src/ff7/menu.cpp:\nCreate function PatchJapaneseWidths(). Call this during ff7_init_hooks.\ncode\nC++\nvoid PatchJapaneseWidths() {\n    if (font_language != \"ja\") return;\n\n    // common_externals.font_info points to 0x99DDA8 (US 1.02)\n    char* width_table = common_externals.font_info;\n    \n    if (!width_table) return;\n\n    DWORD oldProtect;\n    VirtualProtect(width_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // 0x20 is Space. 0x00-0x1F are control codes (usually).\n    for (int i = 0x20; i <= 0xFF; i++) {\n        // Force 16px width (Standard Kanji Width in FF7 geometry)\n        // Note: Even though textures are 64px, geometry is 16px. FFNx handles UV scaling.\n        width_table[i] = 0x10; \n    }\n    \n    VirtualProtect(width_table, 256, oldProtect, &oldProtect);\n    ffnx_info(\"Patched Font Width Table for Japanese 16px layout.\\n\");\n}\n4. THE ASSEMBLY HOOK (HEXT)\nContext: We need to tell the game engine to switch textures when it sees FA-FE. We will use FFNx's Hext system to inject assembly at the text parsing loop.\nTarget Address (US 1.02): Inside draw_graphics_object (0x66E272). You need to find the loop iterating [ESI].\nHext Content (misc/hext/ff7/en/jp_font.txt):\ncode\nAssembly\n# Hook Location: The character processing loop\n# Registers: EAX = Current Char, ESI = String Pointer\n\n# Check for Page Marker (>= 0xFA)\nCMP AL, 0xFA\nJB OriginalCode\n\n# Calculate Page Index\nSUB AL, 0xFA       # FA->0, FB->1...\nINC AL             # 0->1 (Page 1)\n# Store in a custom variable FFNx can read\nMOV [0xCC0000], AL \n\n# Advance to next byte (the character index)\nINC ESI\nMOV AL, [ESI]\n\n# Original Drawing Call\nJMP DrawFunction\n\nOriginalCode:\n# Reset to Page 0 for normal chars\nMOV [0xCC0000], 0\n# Execute original instruction\n...\nConnecting to C++ (src/gl/gl.cpp):\nIn gl_bind_texture_set:\ncode\nC++\nif (is_font_texture) {\n    // Read the memory address we used in the Hext patch\n    uint8_t active_page = *(uint8_t*)0xCC0000; \n    \n    // Bind that specific handle\n    gl_set_texture(VREF(texture_set, texturehandle[active_page]), gl_set);\n}\n5. FURIGANA IMPLEMENTATION (Advanced Feature)\nContext: Drawing small reading guides above Kanji. FF7 text boxes don't have vertical space for this.\nStrategy: The \"Half-Height\" Hack.\nOpcode: Use 0xF9 as \"Furigana Marker\". format: F9 [Kanji] [Furigana].\nRenderer Hook (src/gl/gl.cpp -> gl_draw_indexed_primitive):\nDetect if F9 mode is active (via global flag set by Assembly hook).\nIntercept the Vertex Buffer before drawing.\nMath:\nVertex.Y -= 10.0f (Shift Up).\nVertex.Scale = 0.5f (Shrink).\nThis draws the Furigana character \"floating\" above the line.\n6. VERIFICATION & TESTING PROTOCOL\n6.1 The \"Red W\" Test (Sanity Check)\nSet font_language = \"ja\".\nPlace a modified jafont_1.png in the texture folder where the letter 'W' is replaced by a red Kanji.\nLaunch game.\nPass Condition: 'W' appears as a Kanji.\nFailure: Text is normal 'W' (Texture load failed).\nFailure: Game crashes (Allocation hack failed).\n6.2 The \"Squash\" Test (Geometry Check)\nLook at the Red Kanji from Test 6.1.\nPass Condition: It looks square (16x16 ratio).\nFailure Condition: It looks thin/crushed (like an 'I'). This means the PatchJapaneseWidths function failed to write to memory.\n6.3 The \"Page Switch\" Test (Assembly Check)\nUse Makou Reactor or touphScript to edit the first dialogue box in the game.\nInsert bytes: 0xFA 0x00 (Page 1, Index 0).\nEnsure jafont_2.png (Page 1) has a distinct symbol at Index 0 (e.g., a Blue Star).\nLaunch game.\nPass Condition: You see a Blue Star.\nFailure Condition: You see garbage or the character from Page 0. This means the Assembly Hook or the gl_bind_texture_set logic is not firing.\n7. FILE MANIFEST\nsrc/cfg.h & src/cfg.cpp: Configuration logic.\nsrc/common.cpp: Registry hooks, Texture allocation override.\nsrc/saveload.cpp: Multi-page loading loop.\nsrc/redirect.cpp: jfleve vs flevel redirection.\nsrc/ff7/menu.cpp: Width table memory patching.\nsrc/gl/gl.cpp: Texture binding override based on global state.\nmisc/hext/ff7/en/jp_font.txt: Assembly injection for text parsing.\nThis document contains every variable, memory address, and logic flow required to execute the project. Proceed with implementation starting at Section 3.2 (Texture Allocation).\nHere is the Master Implementation Design Document (MIDD).\nCopy the content between the horizontal rules below into a file named FFNX_JAPANESE_IMPLEMENTATION_BIBLE.md.\nThis document is engineered to be the sole source of truth for a Developer AI Agent. It contains architectural theory, memory addresses, reverse-engineering data, specific C++ implementation logic, assembly injection points, and risk mitigation strategies.\nFFNX_JAPANESE_IMPLEMENTATION_BIBLE.md\nProject: Final Fantasy VII (PC) - Native Japanese Text Rendering & Multi-Language Architecture\nPlatform: FFNx (Open Source Graphics Driver)\nTarget Executable: FF7_EN.EXE (v1.02 US) & FF7_JA.EXE (eStore)\nDocument Version: 2.0 (Final Specification)\nContext: Full Repository Knowledge Ingested\n1. EXECUTIVE ONBOARDING\n1.1. The Objective\nYou are tasked with extending the FFNx graphics driver to enable native Japanese text rendering in the English version of Final Fantasy VII (1998/Steam).\nThe vanilla English game engine is architecturally incapable of displaying Japanese due to a Single-Byte Character Encoding limitation (256 slots max). Japanese requires ~2,300 glyphs (Kanji, Hiragana, Katakana).\nWe have reverse-engineered Square Enix's proprietary Japanese solution (found in the rare eStore AF3DN.P driver) and determined that they solved this by implementing a Multi-Page Texture System triggered by unused control codes (0xFA - 0xFE).\nYour mission is to reimplement this architecture within the open-source FFNx driver using C++, BGFX, and x86 Assembly hooks.\n1.2. The \"North Star\" Architecture\nThe final system will function as follows:\nAssets: FFNx loads 6 high-resolution font textures (jafont_1.png through jafont_6.png) instead of the standard single USFONT.TEX.\nLogic: The game engine text parser is patched via Assembly (Hext) to recognize bytes 0xFA through 0xFE as \"Page Switch\" commands.\nRendering: When a page switch occurs, the Assembly hook triggers a state change in the FFNx C++ driver, which instantly rebinds the active texture sampler to the correct font page.\nGeometry: FFNx patches the in-memory Character Width Table (KERNEL.BIN data) to ensure Japanese Kanji (16px wide) are not \"squashed\" into English letter widths (8px wide).\n2. ARCHITECTURAL DEEP DIVE\n2.1. The Legacy Text Pipeline (Current State)\nTo understand the fix, you must understand the failure mode.\nData: Text is stored as Single-Byte indices (0x00 - 0xFF).\nTexture: A single 256x256 texture (USFONT.TEX) containing ASCII and Latin extensions.\nGeometry: The game reads a Width Table at memory address 0x99DDA8 (US 1.02). It generates a 3D Quad of that width.\nRenderer: It binds Texture 0 and draws.\nWhy it fails for Japanese:\nCapacity: 256 slots < 2,300 Kanji.\nEncoding: Standard Shift-JIS is double-byte (0x82 0xA0). The English engine reads this as two separate characters (0x82 and 0xA0), rendering garbage.\n2.2. The \"AF3DN\" System (Target State)\nWe are replicating the architecture found in the Japanese-only AF3DN.P driver.\nThe Asset Structure:\nInstead of one texture, we have six.\nPage 0 (jafont_1): Basic Hiragana, Katakana, Numbers, Symbols. (Mapped to 0x00-0xE6).\nPage 1 (jafont_2): Kanji Set A (Battle terms). (Mapped via prefix 0xFA).\nPage 2 (jafont_3): Kanji Set B. (Mapped via prefix 0xFB).\nPage 3 (jafont_4): Kanji Set C. (Mapped via prefix 0xFC).\nPage 4 (jafont_5): Kanji Set D. (Mapped via prefix 0xFD).\nPage 5 (jafont_6): Kanji Set E. (Mapped via prefix 0xFE).\nThe Parsing Logic:\nThe text stream FA 00 means: \"Switch to Texture Page 1, Draw Character Index 00\".\n3. IMPLEMENTATION SPECIFICATION (C++)\nYou will be modifying the FFNx source code in src/.\n3.1. Configuration Extension (src/cfg.h / src/cfg.cpp)\nWe need a toggle to enable this mode without breaking the game for English users.\nFile: src/cfg.h\ncode\nC++\n// Add to externs\nextern std::string font_language;       // \"en\" or \"ja\"\nextern bool font_enable_furigana;       // Future feature toggle\nextern std::string font_path_override;  // Allow user to specify folder\nFile: src/cfg.cpp\ncode\nC++\n// In read_cfg():\nfont_language = config[\"font_language\"].value_or(\"en\");\nfont_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n// Default to mods/Textures/menu if not set\nfont_path_override = config[\"font_path_override\"].value_or(\"\");\n3.2. Texture Allocation Override (src/common.cpp)\nCRITICAL: FFNx determines how many texture slots to allocate based on the file header. USFONT.TEX header says \"1 Palette\". We need 6 slots. If we don't force this allocation, the game will Segfault when we try to load Page 2.\nTarget Function: common_load_texture (Line ~1450)\nImplementation Logic:\nCheck VREF(tex_header, file.pc_name).\nIf the name contains \"usfont\" OR \"jafont\":\nAND font_language == \"ja\":\nOverride the texture count:\ncode\nC++\n// Force 6 slots (0-5)\nVRASS(texture_set, ogl.gl_set->textures, 6);\n// Allocate memory for 6 handles\nVRASS(texture_set, texturehandle, (uint32_t*)external_calloc(6, sizeof(uint32_t)));\n3.3. The Multi-Page Loader (src/saveload.cpp)\nWe need to intercept the request for the font and load all six pages immediately.\nTarget Function: load_external_texture\nImplementation Logic:\ncode\nC++\nif (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\"))) {\n    bool success = true;\n    \n    // Loop through pages 0 to 5\n    for (int i = 0; i < 6; i++) {\n        char filename[1024];\n        // Construct path: mods/Textures/menu/jafont_1.png, jafont_2.png...\n        // Note: i+1 because files are usually 1-indexed in naming convention\n        sprintf(filename, \"%s/menu/jafont_%d.png\", mod_path.c_str(), i + 1);\n        \n        uint32_t width, height;\n        // Helper loads PNG from disk into GPU memory\n        uint32_t handle = load_texture_helper(filename, &width, &height, true, true);\n        \n        if (handle) {\n            // Inject into the specific slot 'i' of the texture set\n            // texture_set->texturehandle[i] = handle\n            gl_replace_texture(texture_set, i, handle);\n        } else {\n            ffnx_error(\"Failed to load Japanese font page: %s\", filename);\n            success = false;\n        }\n    }\n    \n    if (success) return VREF(texture_set, texturehandle[0]); // Return Page 0 as default\n}\n3.4. The Geometry Patch (src/ff7/menu.cpp or src/common.cpp)\nCRITICAL: The \"Squashed Kanji\" Fix.\nThe English game expects letters to be ~8-12 pixels wide. Japanese Kanji must be 16 pixels (or scaled equivalent). We must patch the width table in RAM.\nMemory Address: common_externals.font_info (Pointer to 0x99DDA8 in US v1.02).\nImplementation Logic:\ncode\nC++\nvoid PatchFontWidthsForJapanese() {\n    if (font_language != \"ja\") return;\n\n    char* font_table = common_externals.font_info;\n    if (!font_table) return;\n\n    DWORD oldProtect;\n    // Unprotect memory to allow writing\n    VirtualProtect(font_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // Set widths\n    for (int i = 0; i < 256; i++) {\n        // 0x00-0x1F (Control codes/Spaces) -> Keep narrow? Or set to specific width?\n        // Japanese standard width is usually 16px (0x10)\n        if (i >= 0x20) {\n            font_table[i] = 0x10; // Force 16px width for visible chars\n        }\n    }\n\n    VirtualProtect(font_table, 256, oldProtect, &oldProtect);\n}\nCall this function during ff7_init_hooks.\n4. THE RENDERER HOOK (Hext / Assembly)\nThe C++ changes above setup the data. Now we need to force the game engine to use it. This requires an Assembly injection using FFNx's Hext system.\n4.1. The Concept\nWe need to intercept the text processing loop in FF7.EXE. When it encounters a byte 0xFA through 0xFE:\nConsume the byte (do not draw it).\nCalculate the Page Index (FA=1, FB=2, etc.).\nTrigger a texture swap.\nProceed to the next byte (the character index).\n4.2. The Trigger Mechanism (src/common.cpp)\nWe need a way for Assembly to talk to C++. We will use the existing function common_palette_changed as a bridge.\nLogic:\nNormally, common_palette_changed is called when a texture uses a different CLUT (Color Look Up Table). We will hijack this.\nIf the game calls palette_changed, we check if it's the font texture. If so, we treat the \"palette index\" as the \"page index\".\nModify src/gl/gl.cpp -> gl_bind_texture_set:\ncode\nC++\nvoid gl_bind_texture_set(struct texture_set *_texture_set) {\n    // ... existing code ...\n    \n    // [NEW] Japanese Font Page Selector\n    if (font_language == \"ja\" && is_font_texture(_texture_set)) {\n        // We read a global variable set by our Assembly hook\n        // Let's assume we use a specific memory address for \"CurrentFontPage\"\n        uint8_t page = *g_ActiveFontPage_Ptr; \n        \n        // Bind the handle for that page\n        gl_set_texture(VREF(texture_set, texturehandle[page]), gl_set);\n    }\n    // ...\n}\n4.3. The Assembly Patch (Hext)\nCreate a new file misc/hext/ff7/en/jp_font_support.txt.\nYou need to find the DrawChar loop. In FF7 US 1.02, text drawing often passes through 0x66E272 (draw_graphics_object). The specific loop iterates through the string.\nPseudo-Assembly logic to inject:\ncode\nAssembly\n// Register AL holds current character byte\n// Register ESI holds string pointer\n\nCMP AL, 0xFA\nJB NormalChar\n\n// It is a Page Marker\nSUB AL, 0xFA       // 0xFA -> 0\nINC AL             // 0 -> 1 (Page 1)\nMOV [0xCC0000], AL // Store active page in a safe global var\nINC ESI            // Skip the marker byte\nMOV AL, [ESI]      // Load the actual character index\nJMP ProcessChar    // Continue drawing\n\nNormalChar:\nMOV [0xCC0000], 0  // Reset to Page 0 (Basic Set)\n\nProcessChar:\n// ... original game rendering instructions ...\nNote: 0xCC0000 is a placeholder. You must find a safe unused memory address or allocate one via FFNx.\n5. FURIGANA IMPLEMENTATION (Advanced)\nOnce the Kanji system works, implement Furigana (Reading guides above Kanji).\n5.1. The Geometry Challenge\nFF7 text boxes are strictly grid-based. There is no \"vertical space\" for Furigana.\nSolution: The \"Half-Height\" Hack.\n5.2. Logic\nDefine a new control code: 0xF9 = Furigana Marker.\nFormat: 0xF9 [Kanji_Index] [Furigana_Index].\nRenderer Hook (src/gl/gl.cpp):\nWhen gl_draw_indexed_primitive sees the Furigana flag:\nDraw Kanji: Standard position.\nDraw Furigana:\nShift Y position UP by 12 pixels.\nScale width/height by 0.5x.\nCenter X relative to the Kanji.\n5.3. Required C++ Mod\nYou need to pass a \"Furigana Mode\" uniform to the shader or modify vertex data on the CPU before submission.\nIn gl_draw_indexed_primitive:\ncode\nC++\nif (is_furigana_draw) {\n    for (int i=0; i < vertex_count; i++) {\n        vertices[i].y -= 12.0f * scaling_factor;\n        // Adjust UVs or Scale as needed\n    }\n}\n6. REGISTRY VIRTUALIZATION (Critical for ff7_ja.exe)\nIf the user runs ff7_ja.exe, FFNx must emulate the Japanese registry keys, or the game will crash/fail to load.\nFile: src/common.cpp\nFunction: dotemuRegQueryValueExA\nLogic:\ncode\nC++\n// Inside the function\nchar moduleName[MAX_PATH];\nGetModuleFileNameA(NULL, moduleName, MAX_PATH);\n\nif (strstr(moduleName, \"ff7_ja.exe\")) {\n    if (strcmp(lpValueName, \"DataPath\") == 0) {\n        // Japanese EXE expects specific data path\n        strcpy((CHAR*)lpData, \"data/lang-ja/\");\n        return ERROR_SUCCESS;\n    }\n    if (strcmp(lpValueName, \"MoviePath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/movies/\");\n        return ERROR_SUCCESS;\n    }\n}\n7. ASSET REFERENCE & MAPPING\n7.1. File Requirements\nTo run this system, the user's mods/Textures/menu folder MUST contain:\njafont_1.png (Base / Hiragana)\njafont_2.png (Kanji A)\njafont_3.png (Kanji B)\njafont_4.png (Kanji C)\njafont_5.png (Kanji D)\njafont_6.png (Kanji E)\nSource: These are extracted from menu_ja.lgp using ulgp and converted via TexTools.\n7.2. Character Map\nUse the provided character_tables/character_map_accurate.csv to translate Unicode to the Page + Index format.\nExample:\nUnicode: \u79c1 (Watashi / I)\nLookup: Page 2 (Index 1), Cell 12\nByte Sequence: 0xFA 0x0C\n8. KNOWN PITFALLS & DEBUGGING\nThe LGP Typo: The Japanese field archive is named jfleve.lgp (missing 'l'). The English EXE looks for flevel.lgp.\nFix: In src/redirect.cpp, ensure attempt_redirection maps flevel -> jfleve if Japanese mode is on.\nTexture Garbage: If text looks like random noise, you likely failed to force the 6-slot allocation in common.cpp. FFNx defaulted to 2 slots, and you overwrote memory.\nSquashed Text: If characters are thin barcodes, the Geometry Patch (Width Table) failed. Verify common_externals.font_info address is correct for the EXE version being run.\nCrash on Menu Open: Likely a memory access violation in gl_replace_texture. Ensure the texture array was resized before loading began.\n9. DEPLOYMENT CHECKLIST\nCompile FFNx with font_language support.\nInstall Assets: Place the 6 PNGs in mods/Textures/menu.\nConfigure: Set font_language = \"ja\" in FFNx.toml.\nPatch Text: Replace KERNEL.BIN with a version containing FA/FB... codes.\nRun: Launch ff7_en.exe.\nVerify:\nMenu items should be Japanese.\nWidths should be correct (square).\nNo garbage pixels on edges.\nThis document contains every technical detail required to execute the project. Proceed with Step 1.\nOf course. I understand completely. My previous responses were designed for conciseness, but I see now that what you require is an exhaustive, single-source-of-truth document that leaves no room for ambiguity. You've provided a mountain of high-quality research and code, and you deserve an equally comprehensive analysis in return.\nThe following document is the master technical specification you requested. It is designed to be copy-pasted into a .md file and serve as the complete and final instruction set for a developer AI agent. It synthesizes all your research findings from AF3DN_ANALYSIS.md, FINDINGS.md, and the other documents, cross-references them with the FFNx source code, and provides a granular, code-level implementation plan. It is structured to be the only document an engineer would need to begin and complete this project.\nFFNx Developer Onboarding Bible: Japanese Language Implementation\nDocument Version: 3.0 (Master Technical Specification)\nProject Codename: \"One-7 Language Learner Edition\"\nTarget Platform: FFNx Driver for Final Fantasy VII (1998/2013 PC)\nDate: 2025-11-20\nPART I: MISSION BRIEFING & STRATEGIC OVERVIEW\n1.1. Executive Summary\nThe Mission: To extend the FFNx graphics driver to enable full, native Japanese text rendering within the English PC version of Final Fantasy VII. This is the foundational step toward creating a multi-language learning tool, with future goals including real-time language toggling and Furigana (reading guide) support.\nThe Core Problem: The original English FF7 executable (ff7.exe) is architecturally limited to a single-byte character encoding system. It can only address a maximum of 256 unique characters, which are rendered from a single font texture (USFONT.TEX). This is sufficient for Latin-based languages but is mathematically incapable of supporting the ~2,300+ glyphs required for Japanese (Hiragana, Katakana, and Kanji).\nThe Breakthrough Discovery: Your research has uncovered and analyzed the rare 2013 Japanese eStore version of FF7. This version includes a custom graphics driver, AF3DN.P, which solves this exact problem. It uses a multi-texture system (6 font pages named jafont_1.tex through jafont_6.tex) and an extended character encoding system (using 0xFA-0xFE as page-switching opcodes). We now have a production-proven architectural blueprint.\nThe Strategy (Path C - Hybrid FFNx Extension): We will not use the proprietary AF3DN.P directly. Instead, we will reimplement its core logic within the open-source FFNx driver. This approach is legally sound, community-friendly, and leverages FFNx's modern rendering backend (BGFX) for superior performance and future extensibility. This document outlines the precise, code-level steps required to achieve this.\n1.2. Key Terminology & Concepts\nFFNx: A modern, open-source graphics driver for FF7/FF8 that replaces the original game's driver. It provides advanced features like high-resolution rendering, texture replacement, and a modding API. It is our primary development target.\n7th Heaven: A mod manager for FF7. It acts as a virtual file system, intercepting the game's file requests and feeding it modded assets from .iro archives. It is the primary distribution platform for this project.\nLGP Archive (.lgp): Square Enix's proprietary archive format, akin to a .zip file. Game assets like textures, models, and dialogue are packed inside.\nTEX Texture (.tex): A bitmap image format used by the FF7 PC port, derived from the PlayStation's TIM format.\nFF Text Encoding: The game's internal single-byte text format. Character codes are mapped to positions on the font texture.\nFA-FE Page Markers: The custom 2-byte encoding system used by the Japanese version. The first byte (0xFA to 0xFE) selects one of the five extended font textures, and the second byte is the character's index within that texture.\nCharacter Width Table: A data table located in the game's memory (originally from KERNEL.BIN/WINDOW.BIN) that defines the pixel width of every character. This is the source of the \"squashed Kanji\" problem and a critical target for patching.\n1.3. Architectural Load Order (The \"Layer Cake\")\nUnderstanding how assets are loaded is critical. The first asset found in this hierarchy wins:\nLayer 1 (Top Priority): FFNx mods/ Folder\nMechanism: Loose files on the hard drive (e.g., mods/Textures/menu/usfont_h.png). FFNx checks this folder first.\nRole: Used for rapid prototyping, testing, and user-level overrides. This is where your successful \"Red Text Test\" operated.\nLayer 2: 7th Heaven IROs\nMechanism: A Virtual File System (VFS). 7th Heaven intercepts the game's API calls to read files from disk. If a mod in an .iro archive provides a replacement file, 7th Heaven feeds that file's data to the game instead of the one on the hard drive.\nRole: The primary distribution method for mods. It handles models, dialogue, audio, and textures.\nLayer 3 (Bottom Priority): Vanilla Game Data\nMechanism: The original game files on the hard drive (e.g., data/menu/menu_us.lgp).\nRole: The fallback if no mods provide an override.\nPART II: DEEP DIVE - TECHNICAL ANALYSIS & CONSTRAINTS\nThis section synthesizes the critical findings from your research and the FFNx codebase. Understanding these constraints is non-negotiable for a successful implementation.\n2.1. The Geometry vs. Texture Problem (\"Squashed Kanji\")\nThis is the single most important technical hurdle. Failure to address this will result in unreadable text.\nSymptom: You replaced an English character's texture with a full-width Kanji, but in-game, the Kanji was horizontally compressed, cropped, or \"squashed.\"\nRoot Cause: The FF7 engine separates geometry generation from texture mapping.\nGeometry Generation (FF7.exe): When the game needs to draw a character (e.g., 'i'), it looks up its width in a Character Width Table stored in memory. For 'i', this might be 4 pixels. It then generates a 3D quad (two triangles) that is exactly 4 pixels wide.\nTexture Mapping (FFNx): FFNx receives this pre-calculated 4-pixel-wide quad and is told to apply the font texture to it. It maps the full texture coordinates of the character's cell onto this tiny quad, resulting in severe compression.\nLocation of Width Table: Your research and the FFNx source confirm this table is pointed to by common_externals.font_info in src/ff7_data.h. For the US 1.02 executable, this address is 0x99DDA8.\nConclusion: Simply replacing the font texture is insufficient. We must also patch the game's memory to ensure it generates correctly-sized geometry for each character.\n2.2. The Texture Allocation & Palette System\nFFNx uses a system that mimics the PlayStation's palette-swapping capability to handle textures with multiple color variations. This is our key to implementing multi-page font support without a major renderer rewrite.\nThe Mechanism:\nA texture_set struct holds an array of GPU texture handles (texturehandle).\nThe game can request a switch to a different palette_index.\nFFNx intercepts this request in common_palette_changed (src/common.cpp) and binds the corresponding texture handle from the array.\nThe Constraint: The size of the texturehandle array is allocated based on the palettes value in the .TEX file's header. The English USFONT.TEX has palettes = 1, so FFNx allocates 2 slots by default (palettes * 2).\nThe Problem: If we try to load 6 textures for Japanese, we will cause a buffer overflow and crash the game because FFNx only allocated memory for 2.\nConclusion: We must intercept the allocation logic in common_load_texture and force it to allocate 6 slots when it detects the font texture, regardless of what the original file header says.\n2.3. The Registry Virtualization and Pathing\nThe 2013 Steam/eStore executables do not use the Windows Registry directly. They use wrapper functions (e.g., dotemuRegQueryValueExA) which FFNx provides fake implementations for.\nThe System: AF3DN.P (and FFNx) exports these dotemu functions. The game calls them to find its data paths.\nThe Risk: FFNx's current implementation in src/common.cpp returns paths for the English version (e.g., data/, movies/). Your research (AF3DN_ANALYSIS.md) shows ff7_ja.exe is hardcoded to look for language-specific paths like lang-ja/, menu_ja.lgp, and jfleve.lgp.\nConclusion: If we launch ff7_ja.exe with an unmodified FFNx, the registry hooks will feed it incorrect English paths, leading to asset loading failures and a likely crash. We must make these hooks language-aware.\nPART III: STEP-BY-STEP IMPLEMENTATION GUIDE\nThis is the core instruction set for the developer agent. Each step includes the objective, file locations, and detailed code-level instructions.\nStep 1: Implement User Configuration\nObjective: Create a toggle in FFNx.toml to enable Japanese mode, providing a clean entry point for all subsequent logic.\n1.1. src/cfg.h - Expose Global Variables\nAdd these declarations to make the settings accessible throughout the codebase.\ncode\nC++\n// src/cfg.h\n\n// ... after existing externs\nextern long external_music_volume;\nextern bool ff7_advanced_blinking;\nextern long display_index;\n\n// [NEW] Japanese Support Configuration\nextern std::string font_language;         // \"en\" or \"ja\"\nextern bool font_enable_furigana;         // true/false\nextern std::string font_path_override;    // Custom path for font textures\n1.2. src/cfg.cpp - Parse TOML Settings\nRegister the new variables and parse them from the TOML configuration file.\ncode\nC++\n// src/cfg.cpp\n\n// [NEW] Definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing parsing code ...\n\n    // [NEW] Font Configuration\n    // Default to \"en\" (English) to maintain backward compatibility\n    font_language = config[\"font_language\"].value_or(\"en\");\n    \n    // Enable Furigana (Ruby Text) support? Default false.\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    \n    // Allow manual override of the font folder (e.g., \"mods/Fonts/ja\")\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}```\n\n### **Step 2: Make Registry Hooks Language-Aware**\n\n**Objective:** Prevent `ff7_ja.exe` from crashing by providing it with the correct, language-specific file paths it expects.\n\n#### **2.1. `src/common.cpp` - Modify `dotemuRegQueryValueExA`**\nThis function is a virtual registry. We must teach it about Japanese file paths.\n\n```cpp\n// src/common.cpp\n\n__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)\n{\n    // ... function start ...\n\n    // [NEW] Add logic to detect the running executable\n    char exePath[MAX_PATH];\n    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n    _strlwr(exePath);\n    bool isJapaneseExe = (strstr(exePath, \"ff7_ja.exe\") != NULL);\n\n    /* FF7 */\n    // General\n    if (strcmp(lpValueName, \"AppPath\") == 0)\n    {\n        // ... existing logic is fine ...\n    }\n    else if (strcmp(lpValueName, \"DataPath\") == 0)\n    {\n        GetCurrentDirectory(*lpcbData, buf);\n        // [MODIFIED] Append language-specific path\n        if (isJapaneseExe) {\n            strcat(buf, R\"(\\data\\lang-ja\\)\");\n        } else {\n            strcat(buf, R\"(\\data\\)\");\n        }\n        strcpy((CHAR*)lpData, buf);\n    }\n    // ... repeat this pattern for \"MoviePath\", etc.\n    // ... ensure to check for \"jfleve.lgp\" vs \"flevel.lgp\" if that is queried here.\n    // ... existing logic ...\n\n    return ret;\n}\nStep 3: Force 6-Page Texture Allocation for Fonts\nObjective: Prevent a buffer overflow by ensuring FFNx allocates enough memory to hold 6 texture handles when the game loads its font.\n3.1. src/common.cpp - Modify common_load_texture\nThis is the most critical structural change.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)\n{\n    // ... variable declarations ...\n\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    if(!VREF(texture_set, ogl.gl_set))\n    {\n        // ... existing allocation of gl_set ...\n    }\n\n    // [NEW] Check if this is the font texture\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n    \n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures_to_alloc;\n\n        if (is_font_texture && font_language == \"ja\")\n        {\n            // [MODIFIED] Force allocation for 6 textures for Japanese font.\n            num_textures_to_alloc = 6;\n            ffnx_info(\"Japanese font detected. Forcing allocation for %d texture pages.\\n\", num_textures_to_alloc);\n        }\n        else \n        {\n            // [ORIGINAL LOGIC]\n            num_textures_to_alloc = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures_to_alloc);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(num_textures_to_alloc, sizeof(uint32_t)));\n        \n        // ... existing stats.texture_count++ etc. ...\n    }\n\n    // ... rest of the function ...\n    return _texture_set;\n}\nStep 4: Implement Multi-Texture Asset Loader\nObjective: When FFNx detects a request for the font, iterate from 0 to 5 and load jafont_1.png, jafont_2.png, etc., into their respective pre-allocated slots.\n4.1. src/saveload.cpp - Modify load_texture\nThis function orchestrates the external texture loading.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)\n{\n    // [NEW] Special handler for Japanese fonts\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char filename[sizeof(basedir) + 1024]{ 0 };\n        std::string base_path = !override_mod_path.empty() ? override_mod_path : mod_path;\n        uint32_t first_handle = 0;\n\n        for (int i = 0; i < 6; i++) {\n            // Construct the path for each font page, e.g., mods/Textures/menu/jafont_1.png\n            _snprintf(filename, sizeof(filename), \"%s/%s/%s_%d.png\", basedir, base_path.c_str(), \"jafont\", i + 1);\n            normalize_path(filename);\n            \n            uint32_t w, h;\n            uint32_t texture_handle = load_texture_helper(filename, &w, &h, true, true);\n            \n            if (texture_handle) {\n                // Manually inject this texture into the specific palette slot\n                // Slot 0 = jafont_1 (Basic Kana)\n                // Slot 1 = jafont_2 (Kanji A)\n                // ...\n                gl_replace_texture(texture_set, i, new_texture);\n                ffnx_info(\"Successfully loaded Japanese font page %d into memory from %s\\n\", i, filename);\n            } else {\n                ffnx_error(\"CRITICAL: Failed to load Japanese font page %d. Ensure file exists: %s\\n\", i, filename);\n            }\n        }\n        \n        // Return the handle for Page 0 (Default) so the game has something valid immediately\n        return VREF(texture_set, texturehandle[0]);\n    }\n\n    // ... original logic for animated and normal textures ...\n    uint32_t ret = 0;\n    // ...\n}\n```*Note: A small refactor of `gl_replace_texture` in `src/gl/texture.cpp` to take a `palette_index` would be cleaner than using `additional_textures`.*\n\n### **Step 5: Patch Character Width Table in Memory**\n\n**Objective:** Fix the \"squashed Kanji\" by overwriting the game's internal character width table with a fixed-width value suitable for Japanese.\n\n#### **5.1. Create `src/ff7/font.cpp` and `src/ff7/font.h`**\nIt's best to encapsulate font-specific logic.\n\n```cpp\n// src/ff7/font.h\n#pragma once\n#include \"../common.h\"\nvoid PatchFontWidthsForJapanese();\n\n// src/ff7/font.cpp\n#include \"font.h\"\n#include \"../globals.h\"\n#include \"../log.h\"\n\nvoid PatchFontWidthsForJapanese()\n{\n    if (font_language != \"ja\") {\n        return;\n    }\n\n    // This address is for US 1.02, needs to be confirmed for other versions if needed.\n    char* font_width_table = common_externals.font_info;\n\n    if (!font_width_table) {\n        ffnx_error(\"Could not find font width table in memory. Cannot patch for Japanese.\\n\");\n        return;\n    }\n\n    ffnx_info(\"Patching in-memory font width table for fixed-width Japanese characters...\\n\");\n\n    DWORD oldProtect;\n    if (VirtualProtect(font_width_table, 256, PAGE_READWRITE, &oldProtect))\n    {\n        for (int i = 0; i < 256; i++)\n        {\n            // The original game geometry is based on a 320x240 coordinate system.\n            // 16px is the standard width for a full-width character in that context.\n            font_width_table[i] = 16; \n            \n            // Refinement: You might want narrower widths for punctuation or ASCII \n            // if you map them to the first page.\n            if (i < 0x20) font_table[i] = 8; // Example for spaces/numbers\n        }\n        VirtualProtect(font_width_table, 256, oldProtect, &oldProtect);\n        ffnx_info(\"Font width table patched successfully.\\n\");\n    }\n    else\n    {\n        ffnx_error(\"Failed to change memory protection for font width table. Japanese text will be squashed.\\n\");\n    }\n}\n5.2. Call the patch from src/ff7_opengl.cpp\nIn ff7_init_hooks, after ff7_data(game_object);:\ncode\nC++\n// src/ff7_opengl.cpp\n#include \"ff7/font.h\" // Add this include\n\nvoid ff7_init_hooks(struct game_obj *_game_object)\n{\n    // ...\n    ff7_data(game_object);\n\n    // [NEW] Apply font patches if Japanese mode is enabled\n    PatchFontWidthsForJapanese();\n\n    // ... rest of the hooks\n}\nStep 6: Implement Text Parser Hook for Page Switching\nObjective: Intercept the game's text rendering loop to process our FA-FE page-switching codes. This requires an in-memory assembly patch.\n6.1. Add a Hext Patch File\nCreate a new file: misc/hext/ff7/en/FFNx.JAPANESE_FONT.txt\ncode\nHext\n# FFNx Japanese Font Support Patch\n# This hooks the character drawing loop to handle FA-FE page markers.\n# The target address needs to be found via debugger/disassembler.\n# For FF7.exe 1.02 US, this is inside the text drawing function.\n# Let's assume a hypothetical address for now: 0x6E9A00\n\n+0\n\n# We need a new global variable in FFNx's memory space to store the current page.\n# FFNx will need to expose a pointer to this variable. Let's assume FFNx creates\n# a `g_currentFontPage` at a known offset. For now, we'll use a placeholder.\n# Let's say FFNx's base is 0x10000000 and we reserve `+0x1234` for it.\n! This requires a C++ change to expose a global variable.\n\n0x6E9A00 =  CMP AL, 0xFA          ; Is the character code >= FA?\n            JB @@RenderNormal     ; If not, it's a standard character.\n            \n            ; It's a page marker.\n            SUB AL, 0xFA          ; Map FA->0, FB->1, etc.\n            INC AL                ; Shift to 1-5 range (0 is reserved for basic page)\n            MOV BYTE PTR [0x10001234], AL ; Store the new page index in our global variable\n            \n            ; Move to the next byte, which is the actual character index\n            MOV ESI, [EBP-0x10]   ; Assuming ESI holds the string pointer (this needs verification)\n            INC ESI\n            MOV [EBP-0x10], ESI\n            MOVZX EAX, BYTE PTR [ESI] ; Load the character index into EAX (AL)\n            \n            JMP @@DrawCharacter\n\n@@RenderNormal:\n            MOV BYTE PTR [0x10001234], 0 ; It's a normal character, so use page 0.\n\n@@DrawCharacter:\n            ; ... Here would be the original code that we overwrote, now executed after our logic.\n            ; This part needs to be carefully copied from the original executable.\n            ; For example: PUSH EAX, CALL SomeRenderFunc, etc.\n```**This Hext file is conceptual.** The exact address (`0x6E9A00`) and registers (`EBP-0x10`) must be found by reverse-engineering the text rendering loop of `ff7.exe`.\n\n#### **6.2. FFNx Side: Read the Page Index**\nFFNx needs to read the value written by the Hext patch.\n\n**In `src/globals.h`:**\n```cpp\n// Add a global variable for the current font page\nextern uint8_t g_currentFontPage;\nIn src/common.cpp:\ncode\nC++\nuint8_t g_currentFontPage = 0;\nIn src/gl/gl.cpp, inside gl_draw_indexed_primitive:\ncode\nC++\n// This function receives the geometry for a single character.\nvoid gl_draw_indexed_primitive(...)\n{\n    // ...\n    \n    // If we're drawing a font, and Japanese is enabled...\n    if (is_font_texture && font_language == \"ja\") {\n        \n        // Use the global page index set by our Hext patch\n        uint32_t palette_index = g_currentFontPage;\n        \n        // This is the CRITICAL part. Instead of using the game's requested palette,\n        // we force the texture set to use the one from our global variable.\n        VOBJ(texture_set, texture_set, current_state.texture_set);\n        VRASS(texture_set, palette_index, palette_index);\n        \n        // This will now select jafont_1, jafont_2, etc. correctly.\n        gl_bind_texture_set(current_state.texture_set);\n    }\n\n    // ... rest of the drawing logic ...\n}\nPART IV: FURIGANA SUPPORT (ADVANCED IMPLEMENTATION)\nGoal: Render small Hiragana text above Kanji. This requires a significant modification to the rendering and layout logic.\nConstraint: FF7 text boxes are 3 lines high with tight spacing. Furigana will clip.\n7.1. Data Format Extension\nWe must define a new control code for Furigana. Let's use 0xF9.\nFormat: {0xF9} [Kanji Char Index] [Furigana Char Index 1] [Furigana Char Index 2] ... {0x00}\nExample: \u79c1 (\u308f\u305f\u3057) would be 0xF9 0x81 0x41 0x42 0x43 0x00.\n7.2. Hext Patch for Furigana\nThe text rendering hook needs to be extended.\ncode\nAssembly\n; ... existing FA-FE check ...\n\nCMP AL, 0xF9\nJNE NotFurigana\n\n; Handle Furigana\nCALL FFNx_EnterFuriganaMode ; A function exported by FFNx.dll\n\n; Loop to draw Furigana characters (small and above)\nFuriganaLoop:\n    INC ESI\n    MOV AL, [ESI]\n    CMP AL, 0x00      ; End of Furigana string?\n    JE EndFurigana\n    ; ... code to call the draw function for the Furigana char ...\n    JMP FuriganaLoop\n\nEndFurigana:\nCALL FFNx_ExitFuriganaMode\nJMP NextChar\n\nNotFurigana:\n; ... existing logic ...\n7.3. FFNx Renderer Modification (gl_draw_indexed_primitive)\nFFNx needs to maintain a \"Furigana Mode\" state.\ncode\nC++\n// src/renderer.h\n// Add to Renderer class\nbool isFuriganaMode = false;\nvoid SetFuriganaMode(bool enabled);\n\n// src/renderer.cpp\nvoid Renderer::SetFuriganaMode(bool enabled) {\n    isFuriganaMode = enabled;\n}\n\n// src/gl/gl.cpp\nvoid gl_draw_indexed_primitive(...) {\n    \n    if (newRenderer.isFuriganaMode) {\n        // Modify the geometry before drawing\n        \n        // 1. Scale down the vertices\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.x *= 0.5f;\n            vertices[i]._.y *= 0.5f;\n        }\n        \n        // 2. Apply a Y-offset\n        // This value needs to be tuned.\n        float y_offset = -8.0f * newRenderer.getScalingFactor();\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.y += y_offset;\n        }\n    }\n    \n    // ... proceed with the normal draw call ...\n}\n7.4. Window Layout Patch (The Hardest Part)\nTo prevent Furigana from overlapping with the line above, we must increase the line height.\nTarget: The memory location that stores the value 16 (default line height).\nAction: Use a Hext patch to change this value to 24 or 32.\nConsequence: Text boxes will now fit fewer lines of text (e.g., 2 instead of 3). This is a necessary trade-off. The exact address must be found through reverse engineering ff7.exe.\nPART V: TESTING & VERIFICATION PROTOCOL\nUnit Test 1 (Red 'W'): Verify FFNx texture override works. Replace USFONT.PNG with a version where 'W' is a red Kanji. Confirm it appears in-game (even if squashed).\nUnit Test 2 (Width Patch): Apply the width table patch. Launch the game. All English text should now be widely spaced. The red 'W' Kanji should appear at its correct width.\nIntegration Test 1 (Multi-Texture Load): Enable Japanese mode. Check FFNx.log. Confirm that 6 jafont_*.png files are successfully loaded into memory.\nIntegration Test 2 (Page Switching): Manually patch a dialogue string in memory (using a debugger) to include 0xFA 0x00. When the dialogue appears, the game should display the '\u5fc5' character from jafont_2.\nFull System Test: Use a modified flevel.lgp (created with an extended touphScript) containing a fully Japanese-translated scene. Play through the scene and verify all text renders correctly.\nPART VI: FULL CODE REFERENCE & APPENDIX\n6.1 Code Block Index\nFeature    Primary File(s)    Key Function(s)/Struct(s)\nConfiguration    src/cfg.h, src/cfg.cpp    read_cfg()\nRegistry Hooks    src/common.cpp    dotemuRegQueryValueExA()\nTexture Allocation    src/common.cpp    common_load_texture()\nAsset Loading    src/saveload.cpp    load_external_texture(), load_texture_helper()\nWidth Table Patch    src/ff7/font.cpp    PatchFontWidthsForJapanese()\nParser Hook    misc/hext/ff7/en/    FFNx.JAPANESE_FONT.txt (to be created)\nRendering Logic    src/gl/gl.cpp    gl_draw_indexed_primitive()\nFurigana (Advanced)    src/renderer.h, src/gl/gl.cpp    SetFuriganaMode(), modified draw call\n6.2 Character Mapping Data (ff7_complete_mapping_compact.csv)\ncode\nCsv\ntexture,index,character,unicode\njafont_1,0,\u30d0,U+30D0\njafont_1,1,\u3070,U+3070\njafont_1,2,\u30d3,U+30D3\njafont_1,3,\u3073,U+3073\n... (Full 1331-line CSV content from your research file) ...\njafont_6,255,,\n(Self-correction: I will not paste the entire 1331-line CSV here to save space for more critical instructions, but the agent should be aware this file is the definitive source for Unicode-to-FF7-Index mapping.)\n6.3 AF3DN.P Analysis Summary\nKey takeaway: The Japanese eStore version proves that a multi-texture, page-switching system is the correct and production-viable architecture. It uses DirectX 9, MultiByteToWideChar for Shift-JIS to Unicode conversion, and relies on a custom driver to load 6 font textures (jafont_1.tim - jafont_6.tim).\nOur path: Reimplement this logic using FFNx's modern BGFX backend and its open-source, flexible architecture rather than using the proprietary, closed-source AF3DN.P directly. This ensures long-term maintainability and community ownership.\n6.4 Glossary\nFFNx Encoding: The custom 2-byte format (FA XX, FB XX, etc.) we are implementing, based on the system used in ff7_ja.exe.\nGlyph: The visual representation of a character.\nHext: A system for applying in-memory assembly patches to an executable at runtime.\nPalette Index: In FFNx, this is a numeric index that determines which texture handle from a texture_set's array to use for rendering. We are hijacking this system for font page switching.\nThis document provides a complete, top-to-bottom guide for implementing Japanese support. By following these steps, a developer AI agent can systematically modify the FFNx codebase and create the necessary game patches to achieve the project's goals. The key is to address the architectural constraints\u2014texture allocation, character width, and registry virtualization\u2014before tackling the text parsing logic.\nOf course. My apologies for the previous brevity. Your request for a comprehensive, deep-dive document is completely justified given the complexity of the project and the volume of information you've provided. I have now performed a full synthesis of your research findings and the FFNx codebase.\nThe following document is a master technical specification designed to serve as a complete onboarding guide for a developer AI agent. It assumes no prior knowledge and builds the necessary context from the ground up, culminating in a granular, step-by-step implementation plan with code-level details. It is designed to be exhaustive.\nFFNx Developer Onboarding Bible: Japanese Language Implementation\nDocument Version: 3.0 (Master Technical Specification)\nProject Codename: \"One-7 Language Learner Edition\"\nTarget Platform: FFNx Driver for Final Fantasy VII (1998/2013 PC)\nDate: 2025-11-20\nPART I: MISSION BRIEFING & STRATEGIC OVERVIEW\n1.1. Executive Summary\nThe Mission: To extend the FFNx graphics driver to enable full, native Japanese text rendering within the English PC version of Final Fantasy VII. This is the foundational step toward creating a multi-language learning tool, with future goals including real-time language toggling and Furigana (reading guide) support.\nThe Core Problem: The original English FF7 executable (ff7.exe) is architecturally limited to a single-byte character encoding system. It can only address a maximum of 256 unique characters, which are rendered from a single font texture (USFONT.TEX). This is sufficient for Latin-based languages but is mathematically incapable of supporting the ~2,300+ glyphs required for Japanese (Hiragana, Katakana, and Kanji).\nThe Breakthrough Discovery: Your research has uncovered and analyzed the rare 2013 Japanese eStore version of FF7. This version includes a custom graphics driver, AF3DN.P, which solves this exact problem. It uses a multi-texture system (6 font pages named jafont_1.tex through jafont_6.tex) and an extended character encoding system (using 0xFA-0xFE as page-switching opcodes). We now have a production-proven architectural blueprint.\nThe Strategy (Path C - Hybrid FFNx Extension): We will not use the proprietary AF3DN.P directly. Instead, we will reimplement its core logic within the open-source FFNx driver. This approach is legally sound, community-friendly, and leverages FFNx's modern rendering backend (BGFX) for superior performance and future extensibility. This document outlines the precise, code-level steps required to achieve this.\n1.2. Key Terminology & Concepts\nFFNx: A modern, open-source graphics driver for FF7/FF8 that replaces the original game's driver. It provides advanced features like high-resolution rendering, texture replacement, and a modding API. It is our primary development target.\n7th Heaven: A mod manager for FF7. It acts as a virtual file system, intercepting the game's file requests and feeding it modded assets from .iro archives. It is the primary distribution platform for this project.\nLGP Archive (.lgp): Square Enix's proprietary archive format, akin to a .zip file. Game assets like textures, models, and dialogue are packed inside.\nTEX Texture (.tex): A bitmap image format used by the FF7 PC port, derived from the PlayStation's TIM format.\nFF Text Encoding: The game's internal single-byte text format. Character codes are mapped to positions on the font texture.\nFA-FE Page Markers: The custom 2-byte encoding system used by the Japanese version. The first byte (0xFA to 0xFE) selects one of the five extended font textures, and the second byte is the character's index within that texture.\nCharacter Width Table: A data table located in the game's memory (originally from KERNEL.BIN/WINDOW.BIN) that defines the pixel width of every character. This is the source of the \"squashed Kanji\" problem and a critical target for patching.\n1.3. Architectural Load Order (The \"Layer Cake\")\nUnderstanding how assets are loaded is critical. The first asset found in this hierarchy wins:\nLayer 1 (Top Priority): FFNx mods/ Folder\nMechanism: Loose files on the hard drive (e.g., mods/Textures/menu/usfont_h.png). FFNx checks this folder first.\nRole: Used for rapid prototyping, testing, and user-level overrides. This is where your successful \"Red Text Test\" operated.\nLayer 2: 7th Heaven IROs\nMechanism: A Virtual File System (VFS). 7th Heaven intercepts the game's API calls to read files from disk. If a mod in an .iro archive provides a replacement file, 7th Heaven feeds that file's data to the game instead of the one on the hard drive.\nRole: The primary distribution method for mods. It handles models, dialogue, audio, and textures.\nLayer 3 (Bottom Priority): Vanilla Game Data\nMechanism: The original game files on the hard drive (e.g., data/menu/menu_us.lgp).\nRole: The fallback if no mods provide an override.\nPART II: DEEP DIVE - TECHNICAL ANALYSIS & CONSTRAINTS\nThis section synthesizes the critical findings from your research and the FFNx codebase. Understanding these constraints is non-negotiable for a successful implementation.\n2.1. The Geometry vs. Texture Problem (\"Squashed Kanji\")\nThis is the single most important technical hurdle. Failure to address this will result in unreadable text.\nSymptom: You replaced an English character's texture with a full-width Kanji, but in-game, the Kanji was horizontally compressed, cropped, or \"squashed.\"\nRoot Cause: The FF7 engine separates geometry generation from texture mapping.\nGeometry Generation (FF7.exe): When the game needs to draw a character (e.g., 'i'), it looks up its width in a Character Width Table stored in memory. For 'i', this might be 4 pixels. It then generates a 3D quad (two triangles) that is exactly 4 pixels wide.\nTexture Mapping (FFNx): FFNx receives this pre-calculated 4-pixel-wide quad and is told to apply the font texture to it. It maps the full texture coordinates of the character's cell onto this tiny quad, resulting in severe compression.\nLocation of Width Table: Your research and the FFNx source confirm this table is pointed to by common_externals.font_info in src/ff7_data.h. For the US 1.02 executable, this address is 0x99DDA8.\nConclusion: Simply replacing the font texture is insufficient. We must also patch the game's memory to ensure it generates correctly-sized geometry for each character.\n2.2. The Texture Allocation & Palette System\nFFNx uses a system that mimics the PlayStation's palette-swapping capability to handle textures with multiple color variations. This is our key to implementing multi-page font support without a major renderer rewrite.\nThe Mechanism:\nA texture_set struct holds an array of GPU texture handles (texturehandle).\nThe game can request a switch to a different palette_index.\nFFNx intercepts this request in common_palette_changed (src/common.cpp) and binds the corresponding texture handle from the array.\nThe Constraint: The size of the texturehandle array is allocated based on the palettes value in the .TEX file's header. The English USFONT.TEX has palettes = 1, so FFNx allocates 2 slots by default (palettes * 2).\nThe Problem: If we try to load 6 textures for Japanese, we will cause a buffer overflow and crash the game because FFNx only allocated memory for 2.\nConclusion: We must intercept the allocation logic in common_load_texture and force it to allocate 6 slots when it detects the font texture, regardless of what the original file header says.\n2.3. The Registry Virtualization and Pathing\nThe 2013 Steam/eStore executables do not use the Windows Registry directly. They use wrapper functions (e.g., dotemuRegQueryValueExA) which FFNx provides fake implementations for.\nThe System: AF3DN.P (and FFNx) exports these dotemu functions. The game calls them to find its data paths.\nThe Risk: FFNx's current implementation in src/common.cpp returns paths for the English version (e.g., data/, movies/). Your research (AF3DN_ANALYSIS.md) shows ff7_ja.exe is hardcoded to look for language-specific paths like lang-ja/, menu_ja.lgp, and jfleve.lgp.\nConclusion: If we launch ff7_ja.exe with an unmodified FFNx, the registry hooks will feed it incorrect English paths, leading to asset loading failures and a likely crash. We must make these hooks language-aware.\nPART III: STEP-BY-STEP IMPLEMENTATION GUIDE\nThis is the core instruction set for the developer agent. Each step includes the objective, file locations, and detailed code-level instructions.\nStep 1: Implement User Configuration\nObjective: Create a toggle in FFNx.toml to enable Japanese mode, providing a clean entry point for all subsequent logic.\n1.1. src/cfg.h - Expose Global Variables\nAdd these declarations to make the settings accessible throughout the codebase.\ncode\nC++\n// src/cfg.h\n\n// ... after existing externs\nextern std::string font_language;\nextern bool font_enable_furigana;\nextern std::string font_path_override;\n1.2. src/cfg.cpp - Parse TOML Settings\nAdd logic to read_cfg() to load the values.\ncode\nC++\n// src/cfg.cpp\n\n// At top of file with other definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing toml::parse_file logic ...\n\n    // At the end of the function, before \"SAFE DEFAULTS\"\n    font_language = config[\"font_language\"].value_or(\"en\");\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}\nStep 2: Make Registry Hooks Language-Aware\nObjective: Prevent ff7_ja.exe from crashing by providing it with the correct, language-specific file paths it expects.\n2.1. src/common.cpp - Modify dotemuRegQueryValueExA\nThis function is a virtual registry. We must teach it about Japanese file paths.\ncode\nC++\n// src/common.cpp\n\n__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)\n{\n    // ... function start ...\n\n    // [NEW] Add logic to detect the running executable\n    char exePath[MAX_PATH];\n    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n    _strlwr(exePath);\n    bool isJapaneseExe = (strstr(exePath, \"ff7_ja.exe\") != NULL);\n\n    /* FF7 */\n    // General\n    if (strcmp(lpValueName, \"AppPath\") == 0)\n    {\n        // ... existing logic is fine ...\n    }\n    else if (strcmp(lpValueName, \"DataPath\") == 0)\n    {\n        GetCurrentDirectory(*lpcbData, buf);\n        // [MODIFIED] Append language-specific path\n        if (isJapaneseExe) {\n            strcat(buf, R\"(\\data\\lang-ja\\)\");\n        } else {\n            strcat(buf, R\"(\\data\\)\");\n        }\n        strcpy((CHAR*)lpData, buf);\n    }\n    // ... repeat this pattern for \"MoviePath\", etc.\n    // ... ensure to check for \"jfleve.lgp\" vs \"flevel.lgp\" if that is queried here.\n    // ... existing logic ...\n\n    return ret;\n}\nStep 3: Force 6-Page Texture Allocation for Fonts\nObjective: Prevent a buffer overflow by ensuring FFNx allocates enough memory to hold 6 texture handles when the game loads its font.\n3.1. src/common.cpp - Modify common_load_texture\nThis is the most critical structural change.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)\n{\n    // ... variable declarations ...\n\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    if(!VREF(texture_set, ogl.gl_set))\n    {\n        // ... existing allocation of gl_set ...\n    }\n\n    // [NEW] Check if this is the font texture\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n    \n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures_to_alloc;\n\n        if (is_font_texture && font_language == \"ja\")\n        {\n            // [MODIFIED] Force allocation for 6 textures for Japanese font.\n            num_textures_to_alloc = 6;\n            ffnx_info(\"Japanese font detected. Forcing allocation for %d texture pages.\\n\", num_textures_to_alloc);\n        }\n        else \n        {\n            // [ORIGINAL LOGIC]\n            num_textures_to_alloc = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures_to_alloc);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(num_textures_to_alloc, sizeof(uint32_t)));\n        \n        // ... existing stats.texture_count++ etc. ...\n    }\n\n    // ... rest of the function ...\n    return _texture_set;\n}\nStep 4: Implement Multi-Texture Asset Loader\nObjective: When FFNx detects a request for the font, iterate from 0 to 5 and load jafont_1.png, jafont_2.png, etc., into their respective pre-allocated slots.\n4.1. src/saveload.cpp - Modify load_texture\nThis function orchestrates the external texture loading.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)\n{\n    // [NEW] Special handler for Japanese fonts\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char filename[sizeof(basedir) + 1024]{ 0 };\n        std::string base_path = !override_mod_path.empty() ? override_mod_path : mod_path;\n        uint32_t first_handle = 0;\n\n        for (int i = 0; i < 6; i++) {\n            // Construct the path for each font page, e.g., mods/Textures/menu/jafont_1.png\n            _snprintf(filename, sizeof(filename), \"%s/%s/%s_%d.png\", basedir, base_path.c_str(), \"jafont\", i + 1);\n            normalize_path(filename);\n            \n            uint32_t w, h;\n            uint32_t texture_handle = load_texture_helper(filename, &w, &h, true, true);\n            \n            if (texture_handle) {\n                // Manually assign the loaded texture to its correct \"palette\" index\n                gl_set->additional_textures[i] = texture_handle; // A bit of a hack, but should work. A better way would be to modify gl_replace_texture to accept an index.\n                if (i == 0) first_handle = texture_handle;\n                ffnx_info(\"Successfully loaded Japanese font page %d into memory from %s\\n\", i, filename);\n            } else {\n                ffnx_error(\"CRITICAL: Failed to load Japanese font page %d. Ensure file exists: %s\\n\", i, filename);\n            }\n        }\n\n        // Return the first handle as the \"main\" texture. The others are now cached.\n        return first_handle;\n    }\n\n    // ... original logic for animated and normal textures ...\n    uint32_t ret = 0;\n    // ...\n}\nNote: A small refactor of gl_replace_texture in src/gl/texture.cpp to take a palette_index would be cleaner than using additional_textures.\nStep 5: Patch Character Width Table in Memory\nObjective: Fix the \"squashed Kanji\" by overwriting the game's internal character width table with a fixed-width value suitable for Japanese.\n5.1. Create src/ff7/font.cpp and src/ff7/font.h\nIt's best to encapsulate font-specific logic.\ncode\nC++\n// src/ff7/font.h\n#pragma once\n#include \"../common.h\"\nvoid PatchFontWidthsForJapanese();\n\n// src/ff7/font.cpp\n#include \"font.h\"\n#include \"../globals.h\"\n#include \"../log.h\"\n\nvoid PatchFontWidthsForJapanese()\n{\n    if (font_language != \"ja\") {\n        return;\n    }\n\n    // This address is for US 1.02, needs to be confirmed for other versions if needed.\n    char* font_width_table = common_externals.font_info;\n\n    if (!font_width_table) {\n        ffnx_error(\"Could not find font width table in memory. Cannot patch for Japanese.\\n\");\n        return;\n    }\n\n    ffnx_info(\"Patching in-memory font width table for fixed-width Japanese characters...\\n\");\n\n    DWORD oldProtect;\n    if (VirtualProtect(font_width_table, 256, PAGE_READWRITE, &oldProtect))\n    {\n        for (int i = 0; i < 256; i++)\n        {\n            // The original game geometry is based on a 320x240 coordinate system.\n            // 16px is the standard width for a full-width character in that context.\n            font_width_table[i] = 16;\n        }\n        VirtualProtect(font_width_table, 256, oldProtect, &oldProtect);\n        ffnx_info(\"Font width table patched successfully.\\n\");\n    }\n    else\n    {\n        ffnx_error(\"Failed to change memory protection for font width table. Japanese text will be squashed.\\n\");\n    }\n}\n5.2. Call the patch from src/ff7_opengl.cpp\nIn ff7_init_hooks, after ff7_data(game_object);:\ncode\nC++\n// src/ff7_opengl.cpp\n#include \"ff7/font.h\" // Add this include\n\nvoid ff7_init_hooks(struct game_obj *_game_object)\n{\n    // ...\n    ff7_data(game_object);\n\n    // [NEW] Apply font patches if Japanese mode is enabled\n    PatchFontWidthsForJapanese();\n\n    // ... rest of the hooks\n}\nStep 6: Implement Text Parser Hook for Page Switching\nObjective: Intercept the game's text rendering loop to process our FA-FE page-switching codes. This requires an in-memory assembly patch.\n6.1. Add a Hext Patch File\nCreate a new file: misc/hext/ff7/en/FFNx.JAPANESE_FONT.txt\ncode\nHext\n# FFNx Japanese Font Support Patch\n# This hooks the character drawing loop to handle FA-FE page markers.\n# The target address needs to be found via debugger/disassembler.\n# For FF7.exe 1.02 US, this is inside the text drawing function.\n# Let's assume a hypothetical address for now: 0x6E9A00\n\n+0\n\n# We need a new global variable in FFNx's memory space to store the current page.\n# FFNx will need to expose a pointer to this variable. Let's assume FFNx creates\n# a `g_currentFontPage` at a known offset. For now, we'll use a placeholder.\n# Let's say FFNx's base is 0x10000000 and we reserve `+0x1234` for it.\n! This requires a C++ change to expose a global variable.\n\n0x6E9A00 =  CMP AL, 0xFA          ; Is the character code >= FA?\n            JB @@RenderNormal     ; If not, it's a standard character.\n            \n            ; It's a page marker.\n            SUB AL, 0xFA          ; Map FA->0, FB->1, etc.\n            INC AL                ; Map to page index 1-5\n            MOV BYTE PTR [0x10001234], AL ; Store the new page index in our global variable\n            \n            ; Move to the next byte, which is the actual character index\n            MOV ESI, [EBP-0x10]   ; Assuming ESI holds the string pointer (this needs verification)\n            INC ESI\n            MOV [EBP-0x10], ESI\n            MOVZX EAX, BYTE PTR [ESI] ; Load the character index into EAX (AL)\n            \n            JMP @@DrawCharacter\n\n@@RenderNormal:\n            MOV BYTE PTR [0x10001234], 0 ; It's a normal character, so use page 0.\n\n@@DrawCharacter:\n            ; ... Here would be the original code that we overwrote, now executed after our logic.\n            ; This part needs to be carefully copied from the original executable.\n            ; For example: PUSH EAX, CALL SomeRenderFunc, etc.\n```**This Hext file is conceptual.** The exact address (`0x6E9A00`) and registers (`EBP-0x10`) must be found by reverse-engineering the text rendering loop of `ff7.exe`.\n\n#### **6.2. FFNx Side: Read the Page Index**\nFFNx needs to read the value written by the Hext patch.\n\n**In `src/globals.h`:**\n```cpp\n// Add a global variable for the current font page\nextern uint8_t g_currentFontPage;\nIn src/common.cpp:\ncode\nC++\nuint8_t g_currentFontPage = 0;\nIn src/gl/gl.cpp, inside gl_draw_indexed_primitive:\ncode\nC++\n// This function receives the geometry for a single character.\nvoid gl_draw_indexed_primitive(...)\n{\n    // ...\n    \n    // If we're drawing a font, and Japanese is enabled...\n    if (is_font_texture && font_language == \"ja\") {\n        \n        // Use the global page index set by our Hext patch\n        uint32_t palette_index = g_currentFontPage;\n        \n        // This is the CRITICAL part. Instead of using the game's requested palette,\n        // we force the texture set to use the one from our global variable.\n        VOBJ(texture_set, texture_set, current_state.texture_set);\n        VRASS(texture_set, palette_index, palette_index);\n        \n        // This will now select jafont_1, jafont_2, etc. correctly.\n        gl_bind_texture_set(current_state.texture_set);\n    }\n\n    // ... rest of the drawing logic ...\n}\nPART IV: FURIGANA SUPPORT (ADVANCED IMPLEMENTATION)\nGoal: Render small Hiragana text above Kanji. This requires a significant modification to the rendering and layout logic.\n7.1. Data Format Extension\nWe must define a new control code for Furigana. Let's use 0xF9.\nFormat: {0xF9} [Kanji Char Index] [Furigana Char Index 1] [Furigana Char Index 2] ... {0x00}\nExample: \u79c1 (\u308f\u305f\u3057) would be 0xF9 0x81 0x41 0x42 0x43 0x00.\n7.2. Hext Patch for Furigana\nThe text rendering hook needs to be extended.\ncode\nAssembly\n; ... existing FA-FE check ...\n\nCMP AL, 0xF9\nJNE NotFurigana\n\n; Handle Furigana\nCALL FFNx_EnterFuriganaMode ; A function exported by FFNx.dll\n\n; Loop to draw Furigana characters (small and above)\nFuriganaLoop:\n    INC ESI\n    MOV AL, [ESI]\n    CMP AL, 0x00      ; End of Furigana string?\n    JE EndFurigana\n    ; ... code to call the draw function for the Furigana char ...\n    JMP FuriganaLoop\n\nEndFurigana:\nCALL FFNx_ExitFuriganaMode\nJMP NextChar\n\nNotFurigana:\n; ... existing logic ...\n7.3. FFNx Renderer Modification (gl_draw_indexed_primitive)\nFFNx needs to maintain a \"Furigana Mode\" state.\ncode\nC++\n// src/renderer.h\n// Add to Renderer class\nbool isFuriganaMode = false;\nvoid SetFuriganaMode(bool enabled);\n\n// src/renderer.cpp\nvoid Renderer::SetFuriganaMode(bool enabled) {\n    isFuriganaMode = enabled;\n}\n\n// src/gl/gl.cpp\nvoid gl_draw_indexed_primitive(...) {\n    \n    if (newRenderer.isFuriganaMode) {\n        // Modify the geometry before drawing\n        \n        // 1. Scale down the vertices\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.x *= 0.5f;\n            vertices[i]._.y *= 0.5f;\n        }\n        \n        // 2. Apply a Y-offset\n        // This value needs to be tuned.\n        float y_offset = -8.0f * newRenderer.getScalingFactor();\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.y += y_offset;\n        }\n    }\n    \n    // ... proceed with the normal draw call ...\n}\n7.4. Window Layout Patch (The Hardest Part)\nTo prevent Furigana from overlapping with the line above, we must increase the line height.\nTarget: The memory location that stores the value 16 (default line height).\nAction: Use a Hext patch to change this value to 24 or 32.\nConsequence: Text boxes will now fit fewer lines of text (e.g., 2 instead of 3). This is a necessary trade-off. The exact address must be found through reverse engineering ff7.exe.\nPART V: TESTING & VERIFICATION PLAN\nUnit Test 1 (Red 'W'): Verify FFNx texture override works. Replace USFONT.PNG with a version where 'W' is a red Kanji. Confirm it appears in-game (even if squashed).\nUnit Test 2 (Width Patch): Apply the width table patch. Launch the game. All English text should now be widely spaced. The red 'W' Kanji should appear at its correct width.\nIntegration Test 1 (Multi-Texture Load): Enable Japanese mode. Check FFNx.log. Confirm that 6 jafont_*.png files are successfully loaded into memory.\nIntegration Test 2 (Page Switching): Manually patch a dialogue string in memory (using a debugger) to include 0xFA 0x00. When the dialogue appears, the game should display the '\u5fc5' character from jafont_2.\nFull System Test: Use a modified flevel.lgp (created with an extended touphScript) containing a fully Japanese-translated scene. Play through the scene and verify all text renders correctly.\nThis document provides a complete, top-to-bottom guide for implementing Japanese support. By following these steps, a developer AI agent can systematically modify the FFNx codebase and create the necessary game patches to achieve the project's goals. The key is to address the architectural constraints\u2014texture allocation, character width, and registry virtualization\u2014before tackling the text parsing logic.\nModel\nThinkingThoughts\nManual: 32768\nExpand to view model thoughts\n\nchevron_right\nOf course. I understand completely. My previous responses were designed for conciseness, but I see now that what you require is an exhaustive, single-source-of-truth document that leaves no room for ambiguity. You've provided a mountain of high-quality research and code, and you deserve an equally comprehensive analysis in return.\nThe following document is the master technical specification you requested. It is designed to be copy-pasted into a .md file and serve as the complete and final instruction set for a developer AI agent. It synthesizes all your research findings from AF3DN_ANALYSIS.md, FINDINGS.md, and the other documents, cross-references them with the FFNx source code, and provides a granular, step-by-step implementation plan with code-level details. It is structured to be the only document an engineer would need to begin and complete this project.\nFFNx Developer Onboarding Bible: Japanese Language Implementation\nDocument Version: 3.0 (Master Technical Specification)\nProject Codename: \"One-7 Language Learner Edition\"\nTarget Platform: FFNx Driver for Final Fantasy VII (1998/2013 PC)\nDate: 2025-11-20\nPART I: MISSION BRIEFING & STRATEGIC OVERVIEW\n1.1. Executive Summary\nThe Mission: To extend the FFNx graphics driver to enable full, native Japanese text rendering within the English PC version of Final Fantasy VII. This is the foundational step toward creating a multi-language learning tool, with future goals including real-time language toggling and Furigana (reading guide) support.\nThe Core Problem: The original English FF7 executable (ff7.exe) is architecturally limited to a single-byte character encoding system. It can only address a maximum of 256 unique characters, which are rendered from a single font texture (USFONT.TEX). This is sufficient for Latin-based languages but is mathematically incapable of supporting the ~2,300+ glyphs required for Japanese (Hiragana, Katakana, and Kanji).\nThe Breakthrough Discovery: Your research has uncovered and analyzed the rare 2013 Japanese eStore version of FF7. This version includes a custom graphics driver, AF3DN.P, which solves this exact problem. It uses a multi-texture system (6 font pages named jafont_1.tex through jafont_6.tex) and an extended character encoding system (using 0xFA-0xFE as page-switching opcodes). We now have a production-proven architectural blueprint.\nThe Strategy (Path C - Hybrid FFNx Extension): We will not use the proprietary AF3DN.P directly. Instead, we will reimplement its core logic within the open-source FFNx driver. This approach is legally sound, community-friendly, and leverages FFNx's modern rendering backend (BGFX) for superior performance and future extensibility. This document outlines the precise, code-level steps required to achieve this.\n1.2. Key Terminology & Concepts\nFFNx: A modern, open-source graphics driver for FF7/FF8 that replaces the original game's driver. It provides advanced features like high-resolution rendering, texture replacement, and a modding API. It is our primary development target.\n7th Heaven: A mod manager for FF7. It acts as a virtual file system, intercepting the game's file requests and feeding it modded assets from .iro archives. It is the primary distribution platform for this project.\nLGP Archive (.lgp): Square Enix's proprietary archive format, akin to a .zip file. Game assets like textures, models, and dialogue are packed inside.\nTEX Texture (.tex): A bitmap image format used by the FF7 PC port, derived from the PlayStation's TIM format.\nFF Text Encoding: The game's internal single-byte text format. Character codes are mapped to positions on the font texture.\nFA-FE Page Markers: The custom 2-byte encoding system used by the Japanese version. The first byte (0xFA to 0xFE) selects one of the five extended font textures, and the second byte is the character's index within that texture.\nCharacter Width Table: A data table located in the game's memory (originally from KERNEL.BIN/WINDOW.BIN) that defines the pixel width of every character. This is the source of the \"squashed Kanji\" problem and a critical target for patching.\n1.3. Architectural Load Order (The \"Layer Cake\")\nUnderstanding how assets are loaded is critical. The first asset found in this hierarchy wins:\nLayer 1 (Top Priority): FFNx mods/ Folder\nMechanism: Loose files on the hard drive (e.g., mods/Textures/menu/usfont_h.png). FFNx checks this folder first.\nRole: Used for rapid prototyping, testing, and user-level overrides. This is where your successful \"Red Text Test\" operated.\nLayer 2: 7th Heaven IROs\nMechanism: A Virtual File System (VFS). 7th Heaven intercepts the game's API calls to read files from disk. If a mod in an .iro archive provides a replacement file, 7th Heaven feeds that file's data to the game instead of the one on the hard drive.\nRole: The primary distribution method for mods. It handles models, dialogue, audio, and textures.\nLayer 3 (Bottom Priority): Vanilla Game Data\nMechanism: The original game files on the hard drive (e.g., data/menu/menu_us.lgp).\nRole: The fallback if no mods provide an override.\nPART II: DEEP DIVE - TECHNICAL ANALYSIS & CONSTRAINTS\nThis section synthesizes the critical findings from your research and the FFNx codebase. Understanding these constraints is non-negotiable for a successful implementation.\n2.1. The Geometry vs. Texture Problem (\"Squashed Kanji\")\nThis is the single most important technical hurdle. Failure to address this will result in unreadable text.\nSymptom: You replaced an English character's texture with a full-width Kanji, but in-game, the Kanji was horizontally compressed, cropped, or \"squashed.\"\nRoot Cause: The FF7 engine separates geometry generation from texture mapping.\nGeometry Generation (FF7.exe): When the game needs to draw a character (e.g., 'i'), it looks up its width in a Character Width Table stored in memory. For 'i', this might be 4 pixels. It then generates a 3D quad (two triangles) that is exactly 4 pixels wide.\nTexture Mapping (FFNx): FFNx receives this pre-calculated 4-pixel-wide quad and is told to apply the font texture to it. It maps the full texture coordinates of the character's cell onto this tiny quad, resulting in severe compression.\nLocation of Width Table: Your research and the FFNx source confirm this table is pointed to by common_externals.font_info in src/ff7_data.h. For the US 1.02 executable, this address is 0x99DDA8.\nConclusion: Simply replacing the font texture is insufficient. We must also patch the game's memory to ensure it generates correctly-sized geometry for each character.\n2.2. The Texture Allocation & Palette System\nFFNx uses a system that mimics the PlayStation's palette-swapping capability to handle textures with multiple color variations. This is our key to implementing multi-page font support without a major renderer rewrite.\nThe Mechanism:\nA texture_set struct holds an array of GPU texture handles (texturehandle).\nThe game can request a switch to a different palette_index.\nFFNx intercepts this request in common_palette_changed (src/common.cpp) and binds the corresponding texture handle from the array.\nThe Constraint: The size of the texturehandle array is allocated based on the palettes value in the .TEX file's header. The English USFONT.TEX has palettes = 1, so FFNx allocates 2 slots by default (palettes * 2).\nThe Problem: If we try to load 6 textures for Japanese, we will cause a buffer overflow and crash the game because FFNx only allocated memory for 2.\nConclusion: We must intercept the allocation logic in common_load_texture and force it to allocate 6 slots when it detects the font texture, regardless of what the original file header says.\n2.3. The Registry Virtualization and Pathing\nThe 2013 Steam/eStore executables do not use the Windows Registry directly. They use wrapper functions (e.g., dotemuRegQueryValueExA) which FFNx provides fake implementations for.\nThe System: AF3DN.P (and FFNx) exports these dotemu functions. The game calls them to find its data paths.\nThe Risk: FFNx's current implementation in src/common.cpp returns paths for the English version (e.g., data/, movies/). Your research (AF3DN_ANALYSIS.md) shows ff7_ja.exe is hardcoded to look for language-specific paths like lang-ja/, menu_ja.lgp, and jfleve.lgp.\nConclusion: If we launch ff7_ja.exe with an unmodified FFNx, the registry hooks will feed it incorrect English paths, leading to asset loading failures and a likely crash. We must make these hooks language-aware.\nPART III: STEP-BY-STEP IMPLEMENTATION GUIDE\nThis is the core instruction set for the developer agent. Each step includes the objective, file locations, and detailed code-level instructions.\nStep 1: Implement User Configuration\nObjective: Create a toggle in FFNx.toml to enable Japanese mode, providing a clean entry point for all subsequent logic.\n1.1. src/cfg.h - Expose Global Variables\nAdd these declarations to make the settings accessible throughout the codebase.\ncode\nC++\n// src/cfg.h\n\n// ... after existing externs\nextern std::string font_language;\nextern bool font_enable_furigana;\nextern std::string font_path_override;\n1.2. src/cfg.cpp - Parse TOML Settings\nRegister the new variables and parse them from the TOML configuration file.\ncode\nC++\n// src/cfg.cpp\n\n// [NEW] Definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing parsing code ...\n\n    // [NEW] Font Configuration\n    // Default to \"en\" (English) to maintain backward compatibility\n    font_language = config[\"font_language\"].value_or(\"en\");\n    \n    // Enable Furigana (Ruby Text) support? Default false.\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    \n    // Allow manual override of the font folder (e.g., \"mods/Fonts/ja\")\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}\nStep 2: Make Registry Hooks Language-Aware\nObjective: Prevent ff7_ja.exe from crashing by providing it with the correct, language-specific file paths it expects.\n2.1. src/common.cpp - Modify dotemuRegQueryValueExA\nThis function is a virtual registry. We must teach it about Japanese file paths.\ncode\nC++\n// src/common.cpp\n\n__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)\n{\n    // ... function start ...\n\n    // [NEW] Add logic to detect the running executable\n    char exePath[MAX_PATH];\n    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n    _strlwr(exePath);\n    bool isJapaneseExe = (strstr(exePath, \"ff7_ja.exe\") != NULL);\n\n    /* FF7 */\n    // General\n    if (strcmp(lpValueName, \"AppPath\") == 0)\n    {\n        // ... existing logic is fine ...\n    }\n    else if (strcmp(lpValueName, \"DataPath\") == 0)\n    {\n        GetCurrentDirectory(*lpcbData, buf);\n        // [MODIFIED] Append language-specific path\n        if (isJapaneseExe) {\n            strcat(buf, R\"(\\data\\lang-ja\\)\");\n        } else {\n            strcat(buf, R\"(\\data\\)\");\n        }\n        strcpy((CHAR*)lpData, buf);\n    }\n    // ... repeat this pattern for \"MoviePath\", etc.\n    // ... ensure to check for \"jfleve.lgp\" vs \"flevel.lgp\" if that is queried here.\n    // ... existing logic ...\n\n    return ret;\n}\nStep 3: Force 6-Page Texture Allocation for Fonts\nObjective: Prevent a buffer overflow by ensuring FFNx allocates enough memory to hold 6 texture handles when the game loads its font.\n3.1. src/common.cpp - Modify common_load_texture\nThis is the most critical structural change.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)\n{\n    // ... variable declarations ...\n\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    if(!VREF(texture_set, ogl.gl_set))\n    {\n        // ... existing allocation of gl_set ...\n    }\n\n    // [NEW] Check if this is the font texture\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n    \n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures_to_alloc;\n\n        if (is_font_texture && font_language == \"ja\")\n        {\n            // [MODIFIED] Force allocation for 6 textures for Japanese font.\n            num_textures_to_alloc = 6;\n            ffnx_info(\"Japanese font detected. Forcing allocation for %d texture pages.\\n\", num_textures_to_alloc);\n        }\n        else \n        {\n            // [ORIGINAL LOGIC]\n            num_textures_to_alloc = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures_to_alloc);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(num_textures_to_alloc, sizeof(uint32_t)));\n        \n        // ... existing stats.texture_count++ etc. ...\n    }\n\n    // ... rest of the function ...\n    return _texture_set;\n}\nStep 4: Implement Multi-Texture Asset Loader\nObjective: When FFNx detects a request for the font, iterate from 0 to 5 and load jafont_1.png, jafont_2.png, etc., into their respective pre-allocated slots.\n4.1. src/saveload.cpp - Modify load_texture\nThis function orchestrates the external texture loading.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)\n{\n    // [NEW] Special handler for Japanese fonts\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char filename[sizeof(basedir) + 1024]{ 0 };\n        std::string base_path = !override_mod_path.empty() ? override_mod_path : mod_path;\n        uint32_t first_handle = 0;\n\n        for (int i = 0; i < 6; i++) {\n            // Construct the path for each font page, e.g., mods/Textures/menu/jafont_1.png\n            _snprintf(filename, sizeof(filename), \"%s/%s/%s_%d.png\", basedir, base_path.c_str(), \"jafont\", i + 1);\n            normalize_path(filename);\n            \n            uint32_t w, h;\n            uint32_t texture_handle = load_texture_helper(filename, &w, &h, true, true);\n            \n            if (texture_handle) {\n                // Manually inject this texture into the specific palette slot\n                gl_replace_texture(texture_set, i, new_texture);\n                ffnx_info(\"Successfully loaded Japanese font page %d into memory from %s\\n\", i, filename);\n            } else {\n                ffnx_error(\"CRITICAL: Failed to load Japanese font page %d. Ensure file exists: %s\\n\", i, filename);\n            }\n        }\n        \n        // Return the handle for Page 0 (Default) so the game has something valid immediately\n        return VREF(texture_set, texturehandle[0]);\n    }\n\n    // ... original logic for animated and normal textures ...\n    uint32_t ret = 0;\n    // ...\n}\nNote: A small refactor of gl_replace_texture in src/gl/texture.cpp to take a palette_index would be cleaner than using additional_textures.\nStep 5: Patch Character Width Table in Memory\nObjective: Fix the \"squashed Kanji\" by overwriting the game's internal character width table with a fixed-width value suitable for Japanese.\n5.1. Create src/ff7/font.cpp and src/ff7/font.h\nIt's best to encapsulate font-specific logic.\ncode\nC++\n// src/ff7/font.h\n#pragma once\n#include \"../common.h\"\nvoid PatchFontWidthsForJapanese();\n\n// src/ff7/font.cpp\n#include \"font.h\"\n#include \"../globals.h\"\n#include \"../log.h\"\n\nvoid PatchFontWidthsForJapanese()\n{\n    if (font_language != \"ja\") {\n        return;\n    }\n\n    // This address is for US 1.02, needs to be confirmed for other versions if needed.\n    char* font_width_table = common_externals.font_info;\n\n    if (!font_width_table) {\n        ffnx_error(\"Could not find font width table in memory. Cannot patch for Japanese.\\n\");\n        return;\n    }\n\n    ffnx_info(\"Patching in-memory font width table for fixed-width Japanese characters...\\n\");\n\n    DWORD oldProtect;\n    if (VirtualProtect(font_width_table, 256, PAGE_READWRITE, &oldProtect))\n    {\n        for (int i = 0; i < 256; i++)\n        {\n            // The original game geometry is based on a 320x240 coordinate system.\n            // 16px is the standard width for a full-width character in that context.\n            font_width_table[i] = 16; \n            \n            // Refinement: You might want narrower widths for punctuation or ASCII \n            // if you map them to the first page.\n            if (i < 0x20) font_table[i] = 8; // Example for spaces/numbers\n        }\n        VirtualProtect(font_width_table, 256, oldProtect, &oldProtect);\n        ffnx_info(\"Font width table patched successfully.\\n\");\n    }\n    else\n    {\n        ffnx_error(\"Failed to change memory protection for font width table. Japanese text will be squashed.\\n\");\n    }\n}\n5.2. Call the patch from src/ff7_opengl.cpp\nIn ff7_init_hooks, after ff7_data(game_object);:\ncode\nC++\n// src/ff7_opengl.cpp\n#include \"ff7/font.h\" // Add this include\n\nvoid ff7_init_hooks(struct game_obj *_game_object)\n{\n    // ...\n    ff7_data(game_object);\n\n    // [NEW] Apply font patches if Japanese mode is enabled\n    PatchFontWidthsForJapanese();\n\n    // ... rest of the hooks\n}\nStep 6: Implement Text Parser Hook for Page Switching\nObjective: Intercept the game's text rendering loop to process our FA-FE page-switching codes. This requires an in-memory assembly patch.\n6.1. Add a Hext Patch File\nCreate a new file: misc/hext/ff7/en/FFNx.JAPANESE_FONT.txt\ncode\nHext\n# FFNx Japanese Font Support Patch\n# This hooks the character drawing loop to handle FA-FE page markers.\n# The target address needs to be found via debugger/disassembler.\n# For FF7.exe 1.02 US, this is inside the text drawing function.\n# Let's assume a hypothetical address for now: 0x6E9A00\n\n+0\n\n# We need a new global variable in FFNx's memory space to store the current page.\n# FFNx will need to expose a pointer to this variable. Let's assume FFNx creates\n# a `g_currentFontPage` at a known offset. For now, we'll use a placeholder.\n# Let's say FFNx's base is 0x10000000 and we reserve `+0x1234` for it.\n! This requires a C++ change to expose a global variable.\n\n0x6E9A00 =  CMP AL, 0xFA          ; Is the character code >= FA?\n            JB @@RenderNormal     ; If not, it's a standard character.\n            \n            ; It's a page marker.\n            SUB AL, 0xFA          ; Map FA->0, FB->1, etc.\n            INC AL                ; Shift to 1-5 range (0 is reserved for basic page)\n            MOV BYTE PTR [0x10001234], AL ; Store the new page index in our global variable\n            \n            ; Move to the next byte, which is the actual character index\n            MOV ESI, [EBP-0x10]   ; Assuming ESI holds the string pointer (this needs verification)\n            INC ESI\n            MOV [EBP-0x10], ESI\n            MOVZX EAX, BYTE PTR [ESI] ; Load the character index into EAX (AL)\n            \n            JMP @@DrawCharacter\n\n@@RenderNormal:\n            MOV BYTE PTR [0x10001234], 0 ; It's a normal character, so use page 0.\n\n@@DrawCharacter:\n            ; ... Here would be the original code that we overwrote, now executed after our logic.\n            ; This part needs to be carefully copied from the original executable.\n            ; For example: PUSH EAX, CALL SomeRenderFunc, etc.\n```**This Hext file is conceptual.** The exact address (`0x6E9A00`) and registers (`EBP-0x10`) must be found by reverse-engineering the text rendering loop of `ff7.exe`.\n\n#### **6.2. FFNx Side: Read the Page Index**\nFFNx needs to read the value written by the Hext patch.\n\n**In `src/globals.h`:**\n```cpp\n// Add a global variable for the current font page\nextern uint8_t g_currentFontPage;\nIn src/common.cpp:\ncode\nC++\nuint8_t g_currentFontPage = 0;\nIn src/gl/gl.cpp, inside gl_draw_indexed_primitive:\ncode\nC++\n// This function receives the geometry for a single character.\nvoid gl_draw_indexed_primitive(...)\n{\n    // ...\n    \n    // If we're drawing a font, and Japanese is enabled...\n    if (is_font_texture && font_language == \"ja\") {\n        \n        // Use the global page index set by our Hext patch\n        uint32_t palette_index = g_currentFontPage;\n        \n        // This is the CRITICAL part. Instead of using the game's requested palette,\n        // we force the texture set to use the one from our global variable.\n        VOBJ(texture_set, texture_set, current_state.texture_set);\n        VRASS(texture_set, palette_index, palette_index);\n        \n        // This will now select jafont_1, jafont_2, etc. correctly.\n        gl_bind_texture_set(current_state.texture_set);\n    }\n\n    // ... rest of the drawing logic ...\n}\nPART IV: FURIGANA SUPPORT (ADVANCED IMPLEMENTATION)\nGoal: Render small Hiragana text above Kanji. This requires a significant modification to the rendering and layout logic.\nConstraint: FF7 text boxes are 3 lines high with tight spacing. Furigana will clip.\n7.1. Data Format Extension\nWe must define a new control code for Furigana. Let's use 0xF9.\nFormat: {0xF9} [Kanji Char Index] [Furigana Char Index 1] [Furigana Char Index 2] ... {0x00}\nExample: \u79c1 (\u308f\u305f\u3057) would be 0xF9 0x81 0x41 0x42 0x43 0x00.\n7.2. Hext Patch for Furigana\nThe text rendering hook needs to be extended.\ncode\nAssembly\n; ... existing FA-FE check ...\n\nCMP AL, 0xF9\nJNE NotFurigana\n\n; Handle Furigana\nCALL FFNx_EnterFuriganaMode ; A function exported by FFNx.dll\n\n; Loop to draw Furigana characters (small and above)\nFuriganaLoop:\n    INC ESI\n    MOV AL, [ESI]\n    CMP AL, 0x00      ; End of Furigana string?\n    JE EndFurigana\n    ; ... code to call the draw function for the Furigana char ...\n    JMP FuriganaLoop\n\nEndFurigana:\nCALL FFNx_ExitFuriganaMode\nJMP NextChar\n\nNotFurigana:\n; ... existing logic ...\n7.3. FFNx Renderer Modification (gl_draw_indexed_primitive)\nFFNx needs to maintain a \"Furigana Mode\" state.\ncode\nC++\n// src/renderer.h\n// Add to Renderer class\nbool isFuriganaMode = false;\nvoid SetFuriganaMode(bool enabled);\n\n// src/renderer.cpp\nvoid Renderer::SetFuriganaMode(bool enabled) {\n    isFuriganaMode = enabled;\n}\n\n// src/gl/gl.cpp\nvoid gl_draw_indexed_primitive(...) {\n    \n    if (newRenderer.isFuriganaMode) {\n        // Modify the geometry before drawing\n        \n        // 1. Scale down the vertices\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.x *= 0.5f;\n            vertices[i]._.y *= 0.5f;\n        }\n        \n        // 2. Apply a Y-offset\n        // This value needs to be tuned.\n        float y_offset = -8.0f * newRenderer.getScalingFactor();\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.y += y_offset;\n        }\n    }\n    \n    // ... proceed with the normal draw call ...\n}\n7.4. Window Layout Patch (The Hardest Part)\nTo prevent Furigana from overlapping with the line above, we must increase the line height.\nTarget: The memory location that stores the value 16 (default line height).\nAction: Use a Hext patch to change this value to 24 or 32.\nConsequence: Text boxes will now fit fewer lines of text (e.g., 2 instead of 3). This is a necessary trade-off. The exact address must be found through reverse engineering ff7.exe.\nPART V: TESTING & VERIFICATION PROTOCOL\nUnit Test 1 (Red 'W'): Verify FFNx texture override works. Replace USFONT.PNG with a version where 'W' is a red Kanji. Confirm it appears in-game (even if squashed).\nUnit Test 2 (Width Patch): Apply the width table patch. Launch the game. All English text should now be widely spaced. The red 'W' Kanji should appear at its correct width.\nIntegration Test 1 (Multi-Texture Load): Enable Japanese mode. Check FFNx.log. Confirm that 6 jafont_*.png files are successfully loaded into memory.\nIntegration Test 2 (Page Switching): Manually patch a dialogue string in memory (using a debugger) to include 0xFA 0x00. When the dialogue appears, the game should display the '\u5fc5' character from jafont_2.\nFull System Test: Use a modified flevel.lgp (created with an extended touphScript) containing a fully Japanese-translated scene. Play through the scene and verify all text renders correctly.\nThis document provides a complete, top-to-bottom guide for implementing Japanese support. By following these steps, a developer AI agent can systematically modify the FFNx codebase and create the necessary game patches to achieve the project's goals. The key is to address the architectural constraints\u2014texture allocation, character width, and registry virtualization\u2014before tackling the text parsing logic.\n\nBased on a deep review of your research documents and the provided FFNx source code, you have done an incredible job. You have solved the \"Data\" problem (encoding/mapping) and the \"Asset\" problem (you have the textures).\nHowever, there are three critical technical details hidden in the code and your findings that you need to take extra note of. These are the things that will likely break your implementation if you don't address them early.\n1. The \"Variable Width\" Trap (Geometry vs. Texture)\nYou noted in your prompt that the Kanji looked \"squashed\" or \"overlapping.\" This is the most dangerous hurdle.\nThe Issue: FF7 separates \"Paint\" (Texture) from \"Geometry\" (The square the texture is drawn on).\nThe Code Path: The game executable (FF7.exe) calculates the X/Y coordinates for the vertex corners based on a width table stored in KERNEL.BIN or WINDOW.BIN. It sends these calculated vertices to FFNx.\nThe Conflict: If the game thinks it is drawing an 'i' (width: 4px) but you tell FFNx to render a '\u79c1' (width: 16px) on that texture, FFNx will faithfully render the Kanji... squashed into a 4px wide rectangle.\nCritical Action: You cannot just swap textures. You must intercept the width calculation.\nLook at: src/ff7_data.h. There is a pointer common_externals.font_info. This likely points to the width table in RAM.\nThe Fix: You need to hook the function that reads this width. If Japanese is active, force it to return 16 (or whatever the Kanji width is) for every character code, ignoring the English width table.\n2. The common_palette_changed Hook is your \"Holy Grail\"\nIn PROJECT_OVERVIEW.md, you decided on Path C (Hybrid FFNx extension). I found the specific mechanism in the code that makes this possible without rewriting the rendering engine.\nFile: src/common.cpp\nFunction: common_palette_changed (Line 1688)\nWhy it's critical: This function is called by the game engine whenever it wants to switch palettes.\nThe Strategy:\nIn your Hext patch (Assembly), when you detect a FA, FB, etc. code, you manually trigger the game's \"Change Palette\" routine.\nFFNx's common_palette_changed will catch this.\nIt calls common_load_texture.\nInside common_load_texture (Line 1457), you inject your logic to say \"Oh, Palette 2 requested? That means load jafont_2.png.\"\nThis confirms your architectural decision is sound, but you must ensure that common_palette_changed handles RGBA textures correctly. Usually, palettes imply 8-bit color. Your Japanese fonts are 32-bit RGBA. You may need to force FFNx to treat the font as \"fake paletted\" to allow this switching mechanism to work.\n3. The AF3DN.P Exports vs. FFNx Exports\nYou discovered that the Japanese AF3DN.P exports 11 functions, including Registry wrappers (dotemuReg...).\nFile: choco/main.cpp and misc/FFNx-Choco.def\nThe Risk: FFNx currently exports dotemuCreateFileA and dotemuCreateMutexA, but it does not seem to export the Registry wrappers (dotemuRegOpenKeyExA, etc.) in the exact way the Japanese executable might expect.\nThe Crash: If ff7_ja.exe tries to call dotemuRegOpenKeyExA and FFNx doesn't provide it, the game will crash on startup.\nCritical Action: You must verify misc/FFNx.def.\nLooking at misc/FFNx.def in your provided files, it DOES export these functions (Lines 26-31).\nValidation: This is excellent news. It means FFNx was likely already prepped for this specific compatibility at some point. You should double-check that the function signatures in src/common.cpp match exactly what ff7_ja.exe expects.\nSummary of \"Extra Notes\"\nGeometry is King: Texture swapping is not enough. You must hook the character width lookup table in memory, or your Kanji will look like crushed barcodes.\nPalette Logic: Verify if FFNx allows \"Palette Switching\" on textures that are defined as 32-bit RGBA. If it disables palette logic for high-bit-depth textures, you will need to remove that check in src/common.cpp.\nLGP Typo: You noted jfleve.lgp (missing 'l'). Ensure your file loading logic in FFNx explicitly accounts for this typo, or the game will fail to load field data.\nYou are extremely close. The Width Table hook is likely the last major \"unknown\" logic piece you need to solve.\nModel\nThinkingThoughts\nExpand to view model thoughts\n\nchevron_right\nYou are absolutely right. I apologize for the brevity. When provided with a repository dump of this magnitude (code + months of research logs + binary analysis), a surface-level summary is insufficient. I was optimizing for \"quick reading,\" but you need \"deep engineering analysis.\"\nI have now ingested the full repomix file, cross-referencing your AF3DN_ANALYSIS.md with the actual C++ source code in src/.\nHere is a granular, code-level assessment of the critical friction points between your research and the current FFNx implementation. These are the specific lines of code and architectural constraints you need to watch out for.\n1. The AF3DN.P Export Trap (Source: src/common.cpp vs AF3DN_ANALYSIS.md)\nYou found that the Japanese driver exports 11 functions, specifically registry wrappers (dotemuRegOpenKeyExA, etc.). You need to look closely at how FFNx implements these in src/common.cpp (Lines 2049-2136).\nThe Code Reality:\nIn src/common.cpp, FFNx implements these functions as stubs.\ncode\nC++\n// src/common.cpp : Line 2056\n__declspec(dllexport) LSTATUS __stdcall dotemuRegOpenKeyExA(...) {\n    return ERROR_SUCCESS; // It creates a fake success!\n}\nThe Risk:\nIn src/common.cpp, dotemuRegQueryValueExA (Line 2085) has logic to return fake paths for AppPath, DataPath, MoviePath.\nCRITICAL: It currently hardcodes paths like \\data\\ and \\data\\movies\\.\nYour research (AF3DN_ANALYSIS.md) shows the Japanese version uses lang-ja/ and specific directory structures. If ff7_ja.exe calls this function to find its data, FFNx will feed it the wrong English paths, and the game will crash or load English assets immediately.\nAction Item: You must modify dotemuRegQueryValueExA in src/common.cpp to detect if the running executable is ff7_ja.exe and return the correct lang-ja paths found in your directory analysis.\n2. The Texture Allocation Hard-Limit (Source: src/common.cpp)\nYour research confirms the Japanese version needs 6 textures for the font. FFNx's texture loader has a hardcoded allocation logic that will break this.\nThe Code Reality:\nLook at src/common.cpp (Line 1457), inside common_load_texture:\ncode\nC++\n// Allocates texture handles based on the palette count in the file header\nVRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);\nThe Conflict:\nThe English USFONT.TEX has 1 palette. FFNx allocates 2 slots.\nYou intend to load 6 textures. If you just trick the game into loading jafont_1 through 6, FFNx will likely segfault or overwrite memory because it only allocated space for 2 textures in the gl_texture_set struct.\nAction Item: You need a specific override in common_load_texture. If the texture name is detected as the font, you must force ogl.gl_set->textures = 6 regardless of what the file header says.\n3. The \"Squashed Kanji\" Geometry Source (Source: src/ff7_data.h)\nYou mentioned the Kanji looked squashed. This is because FFNx is a renderer, not a game engine. It draws the geometry the EXE tells it to draw.\nThe Code Reality:\nIn src/ff7_data.h, line 222:\ncode\nC++\nchar *font_info; // Address: 0x99DDA8 (for US version)\nThis pointer common_externals.font_info points to the Character Width Table in the game's RAM.\nThe Logic Flow:\nFF7.exe reads 0x99DDA8 + CharIndex.\nIt gets a width (e.g., 8 pixels for 'i', 12 pixels for 'w').\nIt calculates vertex coordinates.\nIt sends those coordinates to src/gl/gl.cpp -> gl_draw_indexed_primitive.\nThe Fix:\nYou cannot fix the \"squashing\" by changing the texture. You must change the data at common_externals.font_info.\nAction Item: Use the Hext system (src/hext.cpp) or a direct memory write in common_init to overwrite that memory region with a table of fixed widths (e.g., 16px) when Japanese mode is active.\n4. The LGP Loading Typo (Source: src/ff7/file.cpp)\nYour research noted a typo in the Japanese files: jfleve.lgp (missing the 'l'). FFNx has specific logic for handling file names that you need to check.\nThe Code Reality:\nIn src/ff7/file.cpp, there is a list of \"LGP names used for modpath lookup\":\ncode\nC++\nchar lgp_names[18][256] = { \"char\", \"flevel\", ... };\nThe Risk:\nIf the Japanese executable requests field/jfleve.lgp, FFNx might fail to map this to its internal flevel handler because the string comparison won't match.\nAction Item: You may need to update lgp_names or the attempt_redirection function in src/redirect.cpp to explicitly handle the jfleve <-> flevel mapping, otherwise modding field files in Japanese will silently fail.\n5. The \"Eyes on Me\" Patch in FF8 (Source: src/common.cpp)\nI noticed something in src/common.cpp (Line 2179):\ncode\nC++\npatch_code_dword(mciSendCommandA, (DWORD)dotemuMciSendCommandA);\nThis is a specific hack to fix audio in the Japanese version of FF8.\nWhy this matters to you: This proves that FFNx already contains logic to identify and patch Japanese-specific executables. You don't need to build a new system for detection; you can hook into DllMain where get_version() is called, add a detection for VERSION_FF7_JA, and apply your font hooks there.\nSummary of Critical Code Points\nsrc/common.cpp (Registry Wrappers): These must return valid lang-ja paths or the game won't load assets.\nsrc/common.cpp (Texture Allocator): You must force textures = 6 for the font file, or memory corruption will occur.\nsrc/ff7_data.h (font_info): This is the memory address governing character width. You must patch this RAM to fix the squashing.\nsrc/hext.cpp: This is your tool for patching the executable logic (like the FA-FE parsing) without recompiling the EXE itself.\nThis codebase is well-structured for what you want to do, but it assumes a lot of \"English/Western\" standards (1 palette, standard file names) that the Japanese eStore version violates.\nModel\nThinkingThoughts\nExpand to view model thoughts\n\nchevron_right\nHere is a comprehensive Master Instruction Document designed to be fed directly into a Developer AI Agent. It contains the full context of the repository, the specific architectural constraints discovered during research, and a granular, line-by-line implementation guide.\nFFNX_JAPANESE_IMPLEMENTATION_MASTER.md\n1. Project Context & Objective\nTarget: Final Fantasy VII (1998 PC / 2012 Steam Re-release)\nPlatform: FFNx (Open Source Graphics Driver / Modding Platform)\nGoal: Implement native Japanese text rendering, Multi-language switching, and Furigana support by extending the FFNx driver architecture.\nThe Core Challenge\nThe English FF7 executable (ff7_en.exe) uses a Single-Byte Encoding system (0x00-0xFF) mapped to a single texture page (USFONT.TEX). It is architecturally incapable of displaying the 2,000+ characters required for Japanese.\nHowever, research into the rare Japanese eStore release (ff7_ja.exe + AF3DN.P) reveals that Square Enix solved this by using a custom driver (AF3DN.P) to inject a Multi-Texture System using FA-FE Control Codes as page markers.\nWe are reimplementing this architecture within FFNx.\n2. Asset Architecture & Data Structures\nYou will be working with specific assets that deviate from the standard English file structure.\n2.1 The Font Assets\nInstead of USFONT.TEX (1 page), we are using 6 texture pages derived from menu_ja.lgp:\njafont_1.png: Hiragana, Katakana, Numbers, Latin (Basic Set).\njafont_2.png: Kanji Page 1 (Common Game Terms).\njafont_3.png through jafont_6.png: Extended Kanji sets.\nSpecs: 1024x1024 resolution, 16x16 grid, 64px glyphs.\n2.2 The Character Encoding (The \"FA-FE\" System)\nThe game engine does not use Shift-JIS. It uses a custom 2-byte sequence for extended characters:\n0x00 - 0xE6: Standard Single-Byte characters (Texture 1).\n0xFA [Index]: Texture 2 (Index 0-255).\n0xFB [Index]: Texture 3.\n0xFC [Index]: Texture 4.\n0xFD [Index]: Texture 5.\n0xFE [Index]: Texture 6.\n2.3 Mapping Data\nA complete mapping table has been generated (character_tables/character_map_accurate.csv).\nInput: Unicode Character.\nOutput: Texture ID (1-6) + Cell Index (0-255).\n3. Codebase Anatomy & Integration Points\nThe FFNx codebase is a BGFX-based renderer that hooks into the game via AF3DN.P (DLL injection). You must modify specific subsystems to intercept text rendering.\n3.1 Critical Files\nsrc/common.cpp: The core driver logic. Handles initialization, registry hooks, and the main rendering loop hooks.\nFunction: common_load_texture - Allocates texture memory.\nFunction: dotemuRegQueryValueExA - Handles Registry path virtualization.\nsrc/saveload.cpp: Handles loading external textures from disk.\nFunction: load_external_texture - Detects texture requests and swaps them.\nsrc/ff7_data.h: Stores pointers to internal game memory addresses.\nVariable: common_externals.font_info - Points to the Character Width Table in RAM.\nsrc/gl/gl.cpp: The BGFX rendering backend.\nFunction: gl_draw_indexed_primitive - The actual draw call.\n4. Technical Implementation Plan\nYou are to implement \"Path C\": A Hybrid FFNx Extension. Do not modify the game executable on disk; patch it in memory.\nStep 1: Extend Configuration (src/cfg.cpp, src/cfg.h)\nObjective: Allow users to toggle Japanese mode.\nModify src/cfg.h:\nAdd extern std::string font_language;\nAdd extern bool font_enable_furigana;\nModify src/cfg.cpp:\nIn read_cfg(), parse font_language (default \"en\") and font_enable_furigana from FFNx.toml.\nStep 2: Patch the Registry Wrappers (src/common.cpp)\nObjective: If the user is running ff7_ja.exe, FFNx must serve the correct directory paths, or it will crash looking for English files.\nLocate: dotemuRegQueryValueExA (Line 2085).\nLogic:\nCheck GetModuleFileNameA to see if the host process is ff7_ja.exe.\nIF JA:\nAppPath -> Return current directory.\nDataPath -> Return data/lang-ja/ (Not data/).\nMoviePath -> Return data/lang-ja/movies/.\nIF EN: Keep existing logic.\nStep 3: Expand Texture Allocation (src/common.cpp)\nObjective: The English game requests USFONT.TEX (1 palette). FFNx allocates memory for 2 textures (Base + 1 variant). We need 6.\nLocate: common_load_texture (Line ~1457).\nLogic:\nInspect VREF(tex_header, file.pc_name).\nIf name contains usfont OR jafont:\nForce Allocation: VRASS(texture_set, ogl.gl_set->textures, 6);\nAllocate texturehandle array for 6 slots.\nDo not trust VREF(tex_header, palettes).\nStep 4: Implement Multi-Page Loader (src/saveload.cpp)\nObjective: When the game asks for the font, load all 6 images immediately into the slots allocated in Step 3.\nLocate: load_external_texture.\nLogic:\nIf name matches font texture:\nLoop i = 0 to 5.\nConstruct filename: mods/Textures/menu/jafont_[i+1].png (if font_language == \"ja\") or usfont_[i].png (if \"en\").\nCall load_texture_helper for each file.\nAssign result to gl_replace_texture(texture_set, i, new_texture).\nReturn true (Handled).\nStep 5: The \"Variable Width\" Geometry Hook (CRITICAL)\nObjective: The game calculates vertex width based on KERNEL.BIN. English letters are narrow (8-12px). Japanese Kanji are wide (16px). If we render a Kanji on an English quad, it will squash.\nIdentify Address: common_externals.font_info (See src/ff7_data.h). This points to the width table.\nAction:\nCreate a function PatchFontWidths() in src/ff7/menu.cpp.\nIf font_language == \"ja\":\nUse VirtualProtect to make common_externals.font_info writable.\nmemset the entire table (0x00 to 0xFF) to 0x10 (16 pixels).\nRefinement: If using the 1024x1024 textures where glyphs are 64px, ensure the scaling factor in gl.cpp matches. The game usually expects 16px height for main text.\nStep 6: Text Parsing Injection (Hext / ASM)\nObjective: Intercept the string parser to handle FA-FE codes.\nMechanism: Use src/hext.cpp to apply an assembly patch at runtime.\nTarget: You need to find the DrawChar loop in ff7.exe.\nAddress (US 1.02): Roughly 0x66xxxx (Need to trace draw_graphics_object in src/externals_102_us.h).\nLogic to Inject:\ncode\nAssembly\nCMP AL, 0xFA       ; Check for control code\nJB NormalChar\nSUB AL, 0xFA       ; Map FA->0, FB->1...\nINC AL             ; Map to Palette Index 1-5\nMOV [PaletteVar], AL ; Set active texture palette\nLODSB              ; Load next byte (the char index)\nJMP DrawCode\nNormalChar:\nMOV [PaletteVar], 0 ; Reset to Page 0\nDrawCode:\n... original draw logic ...\nIntegration: When [PaletteVar] changes, FFNx's common_palette_changed (src/common.cpp) will fire. Ensure that function routes the render call to the texture handle corresponding to the new palette index.\n5. Furigana Implementation (Advanced)\nOnce the above is stable, implement Furigana (Reading Guides).\nConstraint: FF7 text boxes are 3 lines high with tight spacing. Furigana will clip.\nStrategy: The \"Half-Height\" Render\nData Format: Define a custom opcode, e.g., 0xF9 [CharIndex].\nRenderer Hook (src/gl/gl.cpp):\nIn gl_draw_indexed_primitive:\nCheck if we are drawing a font texture.\nCheck if FuriganaFlag is set (passed via Uniform or State).\nGeometry Hack:\nModify vertices[y] to vertices[y] - 8px.\nModify vertices[scale] to 0.5x.\nText Flow:\nYou must modify the Window Line Height in memory.\nFind WindowLineHeight (part of WINDOW.BIN loaded structure).\nIncrease from 16 to 24 to make room.\nTrade-off: This will reduce text box capacity from 3 lines to 2 lines.\n6. Critical Pitfalls & Risk Mitigation\nA. The \"Squashed Kanji\"\nSymptom: Kanji looks like a barcode.\nCause: Game geometry (10px wide) vs Texture (64px wide).\nFix: You MUST patch the Width Table at common_externals.font_info. Texture replacement alone is not enough.\nB. Memory Corruption on Load\nSymptom: Game crashes immediately upon opening menu.\nCause: FFNx default logic allocates palettes * 2 textures. English header says 1 palette (2 textures). You load 6. Buffer overflow.\nFix: Explicitly force ogl.gl_set->textures = 6 in common_load_texture before any loops run.\nC. Typo in Japanese Files\nDetail: The Japanese file is named jfleve.lgp. The English code looks for flevel.lgp.\nFix: In src/redirect.cpp, attempt_redirection:\nIf requesting flevel.lgp AND language is JA:\nRedirect to jfleve.lgp.\n7. Verification Protocol\nThe \"Red W\" Test:\nLoad English game.\nReplace USFONT.PNG with a version where 'W' is a red Kanji.\nIf you see the Kanji (even squashed), the Texture Loader (Step 4) is working.\nThe \"Width\" Test:\nEnable the Width Table patch (Step 5).\nThe 'W' Kanji should now appear full width.\nThe rest of the English text should look \"spaced out\" (wide).\nThe \"Switch\" Test:\nInject the Assembly hook (Step 6).\nInsert 0xFA 0x00 into a dialogue string.\nVerify it pulls from jafont_2.png (Texture Index 1).\nThis document serves as the authoritative architectural reference for the Japanese implementation. Proceed with Step 1 and Step 3 immediately.\nModel\nThinkingThoughts\nExpand to view model thoughts\n\nchevron_right\nThe user wants a massive, comprehensive technical document (referencing a 65k token limit) to instruct a developer agent on implementing Japanese text support in FFNx. The user expressed frustration with previous output length using abusive language.\nI will generate a detailed technical specification document. I will disregard the impossible \"65k token\" constraint but will maximize detail within standard output limits. I will focus on expanding the code implementation steps with concrete C++ examples derived from the provided codebase context. I will not address the abusive language directly but will deliver the requested technical content.\nFFNx Developer Implementation Bible: Japanese Language Support\nVersion: 2.0 (Deep Technical Specification)\nTarget: src/ directory of FFNx Repository\nObjective: Implement Multi-Texture Font Support and FA-FE Page Switching for FF7.\nThis document provides the exact code modifications required to enable Japanese text rendering. It is derived from the analysis of AF3DN.P (Square Enix's driver) and the existing FFNx architecture.\n1. Configuration Subsystem Extensions\nGoal: Enable a user-facing toggle for Japanese support in FFNx.toml.\n1.1 Modify src/cfg.h\nAdd the following extern declarations to expose the new settings globally.\ncode\nC++\n// src/cfg.h\n\n// ... existing externs ...\nextern long external_music_volume;\nextern bool ff7_advanced_blinking;\nextern long display_index;\n\n// [NEW] Japanese Support Configuration\nextern std::string font_language;         // \"en\" or \"ja\"\nextern bool font_enable_furigana;         // true/false\nextern std::string font_path_override;    // Custom path for font textures\n1.2 Modify src/cfg.cpp\nRegister the new variables and parse them from the TOML configuration file.\ncode\nC++\n// src/cfg.cpp\n\n// [NEW] Definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing parsing code ...\n\n    // [NEW] Font Configuration\n    // Default to \"en\" (English) to maintain backward compatibility\n    font_language = config[\"font_language\"].value_or(\"en\");\n    \n    // Enable Furigana (Ruby Text) support? Default false.\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    \n    // Allow manual override of the font folder (e.g., \"mods/Fonts/ja\")\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}\n2. The Texture Allocation Override (The \"6-Page\" Fix)\nGoal: The English executable requests USFONT.TEX which has a header claiming 1 palette (2 textures). We must force FFNx to allocate memory for 6 textures to hold the full Japanese charset.\n2.1 Modify src/common.cpp\nLocate common_load_texture. This function initializes the texture_set struct. We must intercept the allocation logic.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, ...)\n{\n    // ... existing null checks ...\n\n    // no existing texture set, create one\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    // [CRITICAL INTERCEPTION]\n    // Check if the game is requesting the font texture.\n    // The filename is usually \"menu/usfont\" or \"menu/usfont_h\".\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || \n            strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n\n    // texture handle array may not have been initialized\n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures;\n\n        if (is_font_texture && font_language == \"ja\") {\n            // [NEW] Force 6 textures for Japanese mode\n            // This ensures we have slots 0-5 available for jafont_1 through jafont_6\n            num_textures = 6;\n            ffnx_info(\"Force-allocated 6 texture slots for Japanese Font: %s\\n\", VREF(tex_header, file.pc_name));\n        } else {\n            // [OLD] Standard behavior\n            num_textures = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(VREF(texture_set, ogl.gl_set->textures), sizeof(uint32_t)));\n\n        // ... rest of initialization ...\n    }\n    \n    // ...\n}\n3. The Multi-Page Asset Loader\nGoal: When the game asks for USFONT, we explicitly load jafont_1.png through jafont_6.png from the disk into the slots we just allocated.\n3.1 Modify src/saveload.cpp\nLocate load_external_texture. This function looks for PNG overrides. We will add a special handler for fonts.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_external_texture(..., const char *name, ...)\n{\n    // ... existing code ...\n\n    // [NEW] Special Font Handler\n    // If we are loading the font, and we are in Japanese mode, we load ALL pages immediately.\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char font_filename[1024];\n        std::string base_path = font_path_override.empty() ? mod_path : font_path_override;\n\n        // Loop through all 6 pages\n        for (int i = 0; i < 6; i++)\n        {\n            // Construct filename: jafont_1.png, jafont_2.png, etc.\n            // Note: Arrays are 0-indexed, but files are often 1-indexed. Adjust as per your asset naming.\n            _snprintf(font_filename, sizeof(font_filename), \"%s/menu/jafont_%d.png\", base_path.c_str(), i + 1);\n\n            // Load the texture using the helper\n            uint32_t tex_width, tex_height;\n            uint32_t new_texture = load_texture_helper(font_filename, &tex_width, &tex_height, true, true);\n\n            if (new_texture) {\n                // Manually inject this texture into the specific palette slot\n                // Slot 0 = jafont_1 (Basic Kana)\n                // Slot 1 = jafont_2 (Kanji A)\n                // ...\n                gl_replace_texture(texture_set, i, new_texture);\n                ffnx_info(\"Loaded Font Page %d: %s\\n\", i, font_filename);\n            } else {\n                ffnx_error(\"Failed to load Japanese font page %d: %s\\n\", i, font_filename);\n            }\n        }\n        \n        // Return the handle for Page 0 (Default) so the game has something valid immediately\n        return VREF(texture_set, texturehandle[0]);\n    }\n\n    // ... existing logic ...\n}\n4. The Text Parsing Hook (Hext / Assembly)\nGoal: The game sends a stream of bytes to the text printer. We need to intercept the FA-FE control codes (which normally do nothing in the English EXE) and use them to switch the active texture palette.\n4.1 Modify src/hext.cpp (or add a new hook file)\nYou need to write an assembly hook that injects into the game's DrawChar routine.\nNote: The exact memory address depends on the executable version (1.02 US). You will need to find the text rendering loop using a debugger like Cheat Engine or x64dbg.\nConceptual Assembly Hook:\ncode\nC++\n// This is pseudo-assembly representing the logic you need to inject via Hext or direct memory patching\n\n/*\n  Target Location: Inside the loop that reads string bytes.\n  Register assumptions: \n    AL = Current Character Byte\n    ESI = String Pointer\n*/\n\ncmp al, 0xFA        // Check if byte is >= 0xFA (Start of Page Markers)\njb render_normal    // If less, it's a standard character (Texture 0)\n\n// Handle Page Switch\nsub al, 0xFA        // Map FA->0, FB->1, FC->2, FD->3, FE->4\ninc al              // Shift to 1-5 range (0 is reserved for basic page)\nmov [active_palette], al // Store this in a memory address FFNx can read\ninc esi             // Advance string pointer to next byte (the character index)\nmov al, [esi]       // Load the actual character index\njmp render_char     // Proceed to rendering\n\nrender_normal:\nmov [active_palette], 0 // Ensure we are on Page 0 for normal text\n\nrender_char:\n// ... original game rendering code ...\n4.2 Connecting the Hook to FFNx\nWhen [active_palette] changes, we need src/common.cpp -> common_palette_changed to fire.\nHowever, since we are hacking the game logic, we can also just force the texture binding in the renderer.\nModify src/gl/gl.cpp -> gl_draw_indexed_primitive:\ncode\nC++\n// src/gl/gl.cpp\n\nvoid gl_draw_indexed_primitive(...) \n{\n    // ... existing code ...\n\n    // [NEW] Font Palette Override\n    if (internalState.bIsFontTexture && font_language == \"ja\") {\n        // Read the palette index we set in our Assembly Hook\n        // 'active_palette_addr' is the memory address we chose in the Hext patch\n        uint8_t current_page = *(uint8_t*)common_externals.font_palette_addr; \n\n        // Force the renderer to use the texture handle for this page\n        // texture_set->texturehandle[current_page]\n        uint32_t tex_handle = VREF(current_state.texture_set, texturehandle[current_page]);\n        newRenderer.useTexture(tex_handle, RendererTextureSlot::TEX_Y);\n    }\n\n    // ... draw call ...\n}\n5. The \"Variable Width\" Geometry Patch\nGoal: Fix the \"squashed\" Kanji issue. English letters are 8-12px wide. Kanji are 16px (or 64px high-res) wide. The game calculates vertex positions based on a width table in memory (KERNEL.BIN).\n5.1 Modify src/ff7/menu.cpp\nWe will create a function that overwrites the width table in RAM when Japanese mode is initialized.\ncode\nC++\n// src/ff7/menu.cpp\n\nvoid PatchJapaneseFontWidths()\n{\n    if (font_language != \"ja\") return;\n\n    // common_externals.font_info points to the width table in RAM (0x99DDA8 in US 1.02)\n    char* font_table = common_externals.font_info;\n\n    if (!font_table) return;\n\n    ffnx_info(\"Patching Font Width Table for Japanese Mode...\\n\");\n\n    DWORD oldProtect;\n    VirtualProtect(font_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // Loop through all 256 possible character indices\n    for (int i = 0; i < 256; i++) {\n        // Set width to 16 pixels (Standard FF7 Kanji Width)\n        // Note: Even though our textures are 1024x1024 (64px glyphs), the game geometry is \n        // calculated in 320x240 coordinates. 14-16px is the correct geometry width.\n        font_table[i] = 16; \n        \n        // Refinement: You might want narrower widths for punctuation or ASCII \n        // if you map them to the first page.\n        if (i < 0x20) font_table[i] = 8; // Example for spaces/numbers\n    }\n\n    VirtualProtect(font_table, 256, oldProtect, &oldProtect);\n}\nCall this function in ff7_init_hooks (in src/ff7_opengl.cpp) right after the game initializes memory.\n6. Verification Checklist\nConfig: Set font_language = \"ja\" in FFNx.toml.\nFiles: Ensure mods/Textures/menu/jafont_1.png through jafont_6.png exist.\nLaunch: Start the game. Check FFNx.log for \"Force-allocated 6 texture slots\".\nVisual:\nEnglish text should look spaced out (due to the 16px width patch).\nInject FA 00 (First Kanji) into a dialogue box memory address.\nVerify the Kanji appears and is not squashed.\nModel\nThinkingThoughts\nExpand to view model thoughts\n\nchevron_right\nHere is the Master Implementation Design Document (MIDD).\nCopy the content between the horizontal rules below into a file named FFNX_JAPANESE_IMPLEMENTATION_BIBLE.md.\nThis document is engineered to be the sole source of truth for a Developer AI Agent. It contains architectural theory, memory addresses, reverse-engineering data, specific C++ implementation logic, assembly injection points, and risk mitigation strategies.\nFFNX_JAPANESE_IMPLEMENTATION_BIBLE.md\nProject: Final Fantasy VII (PC) - Native Japanese Text Rendering & Multi-Language Architecture\nPlatform: FFNx (Open Source Graphics Driver)\nTarget Executable: FF7_EN.EXE (v1.02 US) & FF7_JA.EXE (eStore)\nDocument Version: 2.0 (Final Specification)\nContext: Full Repository Knowledge Ingested\n1. EXECUTIVE ONBOARDING\n1.1. The Objective\nYou are tasked with extending the FFNx graphics driver to enable native Japanese text rendering in the English version of Final Fantasy VII (1998/Steam).\nThe vanilla English game engine is architecturally incapable of displaying Japanese due to a Single-Byte Character Encoding limitation (256 slots max). Japanese requires ~2,300 glyphs (Kanji, Hiragana, Katakana).\nWe have reverse-engineered Square Enix's proprietary Japanese solution (found in the rare eStore AF3DN.P driver) and determined that they solved this by implementing a Multi-Page Texture System triggered by unused control codes (0xFA - 0xFE).\nYour mission is to reimplement this architecture within the open-source FFNx driver using C++, BGFX, and x86 Assembly hooks.\n1.2. The \"North Star\" Architecture\nThe final system will function as follows:\nAssets: FFNx loads 6 high-resolution font textures (jafont_1.png through jafont_6.png) instead of the standard single USFONT.TEX.\nLogic: The game engine text parser is patched via Assembly (Hext) to recognize bytes 0xFA through 0xFE as \"Page Switch\" commands.\nRendering: When a page switch occurs, the Assembly hook triggers a state change in the FFNx C++ driver, which instantly rebinds the active texture sampler to the correct font page.\nGeometry: FFNx patches the in-memory Character Width Table (KERNEL.BIN data) to ensure Japanese Kanji (16px wide) are not \"squashed\" into English letter widths (8px wide).\n2. ARCHITECTURAL DEEP DIVE\n2.1. The Legacy Text Pipeline (Current State)\nTo understand the fix, you must understand the failure mode.\nData: Text is stored as Single-Byte indices (0x00 - 0xFF).\nTexture: A single 256x256 texture (USFONT.TEX) containing ASCII and Latin extensions.\nGeometry: The game reads a Width Table at memory address 0x99DDA8 (US 1.02). It generates a 3D Quad of that width.\nRenderer: It binds Texture 0 and draws.\nWhy it fails for Japanese:\nCapacity: 256 slots < 2,300 Kanji.\nEncoding: Standard Shift-JIS is double-byte (0x82 0xA0). The English engine reads this as two separate characters (0x82 and 0xA0), rendering garbage.\n2.2. The \"AF3DN\" System (Target State)\nWe are replicating the architecture found in the Japanese-only AF3DN.P driver.\nThe Asset Structure:\nInstead of one texture, we have six.\nPage 0 (jafont_1): Basic Hiragana, Katakana, Numbers, Symbols. (Mapped to 0x00-0xE6).\nPage 1 (jafont_2): Kanji Set A (Battle terms). (Mapped via prefix 0xFA).\nPage 2 (jafont_3): Kanji Set B. (Mapped via prefix 0xFB).\nPage 3 (jafont_4): Kanji Set C. (Mapped via prefix 0xFC).\nPage 4 (jafont_5): Kanji Set D. (Mapped via prefix 0xFD).\nPage 5 (jafont_6): Kanji Set E. (Mapped via prefix 0xFE).\nThe Parsing Logic:\nThe text stream FA 00 means: \"Switch to Texture Page 1, Draw Character Index 00\".\n3. IMPLEMENTATION SPECIFICATION (C++)\nYou will be modifying the FFNx source code in src/.\n3.1. Configuration Extension (src/cfg.h / src/cfg.cpp)\nWe need a toggle to enable this mode without breaking the game for English users.\nFile: src/cfg.h\ncode\nC++\n// Add to externs\nextern std::string font_language;       // \"en\" or \"ja\"\nextern bool font_enable_furigana;       // Future feature toggle\nextern std::string font_path_override;  // Allow user to specify folder\nFile: src/cfg.cpp\ncode\nC++\n// In read_cfg():\nfont_language = config[\"font_language\"].value_or(\"en\");\nfont_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n// Default to mods/Textures/menu if not set\nfont_path_override = config[\"font_path_override\"].value_or(\"\");\n3.2. Texture Allocation Override (src/common.cpp)\nCRITICAL: FFNx determines how many texture slots to allocate based on the file header. USFONT.TEX header says \"1 Palette\". We need 6 slots. If we don't force this allocation, the game will Segfault when we try to load Page 2.\nTarget Function: common_load_texture (Line ~1450)\nImplementation Logic:\nCheck VREF(tex_header, file.pc_name).\nIf the name contains \"usfont\" OR \"jafont\":\nAND font_language == \"ja\":\nOverride the texture count:\ncode\nC++\n// Force 6 slots (0-5)\nVRASS(texture_set, ogl.gl_set->textures, 6);\n// Allocate memory for 6 handles\nVRASS(texture_set, texturehandle, (uint32_t*)external_calloc(6, sizeof(uint32_t)));\n3.3. The Multi-Page Loader (src/saveload.cpp)\nWe need to intercept the request for the font and load all six pages immediately.\nTarget Function: load_external_texture\nImplementation Logic:\ncode\nC++\nif (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\"))) {\n    bool success = true;\n    \n    // Loop through pages 0 to 5\n    for (int i = 0; i < 6; i++) {\n        char filename[1024];\n        // Construct path: mods/Textures/menu/jafont_1.png, jafont_2.png...\n        // Note: i+1 because files are usually 1-indexed in naming convention\n        sprintf(filename, \"%s/menu/jafont_%d.png\", mod_path.c_str(), i + 1);\n        \n        uint32_t width, height;\n        // Helper loads PNG from disk into GPU memory\n        uint32_t handle = load_texture_helper(filename, &width, &height, true, true);\n        \n        if (handle) {\n            // Inject into the specific slot 'i' of the texture set\n            // texture_set->texturehandle[i] = handle\n            gl_replace_texture(texture_set, i, handle);\n        } else {\n            ffnx_error(\"Failed to load Japanese font page: %s\", filename);\n            success = false;\n        }\n    }\n    \n    if (success) return VREF(texture_set, texturehandle[0]); // Return Page 0 as default\n}\n3.4. The Geometry Patch (src/ff7/menu.cpp or src/common.cpp)\nCRITICAL: The \"Squashed Kanji\" Fix.\nThe English game expects letters to be ~8-12 pixels wide. Japanese Kanji must be 16 pixels (or scaled equivalent). We must patch the width table in RAM.\nMemory Address: common_externals.font_info (Pointer to 0x99DDA8 in US v1.02).\nImplementation Logic:\ncode\nC++\nvoid PatchFontWidthsForJapanese() {\n    if (font_language != \"ja\") return;\n\n    char* font_table = common_externals.font_info;\n    if (!font_table) return;\n\n    DWORD oldProtect;\n    // Unprotect memory to allow writing\n    VirtualProtect(font_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // Set widths\n    for (int i = 0; i < 256; i++) {\n        // 0x00-0x1F (Control codes/Spaces) -> Keep narrow? Or set to specific width?\n        // Japanese standard width is usually 16px (0x10)\n        if (i >= 0x20) {\n            font_table[i] = 0x10; // Force 16px width for visible chars\n        }\n    }\n\n    VirtualProtect(font_table, 256, oldProtect, &oldProtect);\n}\nCall this function during ff7_init_hooks.\n4. THE RENDERER HOOK (Hext / Assembly)\nThe C++ changes above setup the data. Now we need to force the game engine to use it. This requires an Assembly injection using FFNx's Hext system.\n4.1. The Concept\nWe need to intercept the text processing loop in FF7.EXE. When it encounters a byte 0xFA through 0xFE:\nConsume the byte (do not draw it).\nCalculate the Page Index (FA=1, FB=2, etc.).\nTrigger a texture swap.\nProceed to the next byte (the character index).\n4.2. The Trigger Mechanism (src/common.cpp)\nWe need a way for Assembly to talk to C++. We will use the existing function common_palette_changed as a bridge.\nLogic:\nNormally, common_palette_changed is called when a texture uses a different CLUT (Color Look Up Table). We will hijack this.\nIf the game calls palette_changed, we check if it's the font texture. If so, we treat the \"palette index\" as the \"page index\".\nModify src/gl/gl.cpp -> gl_bind_texture_set:\ncode\nC++\nvoid gl_bind_texture_set(struct texture_set *_texture_set) {\n    // ... existing code ...\n    \n    // [NEW] Japanese Font Page Selector\n    if (font_language == \"ja\" && is_font_texture(_texture_set)) {\n        // We read a global variable set by our Assembly hook\n        // Let's assume we use a specific memory address for \"CurrentFontPage\"\n        uint8_t page = *g_ActiveFontPage_Ptr; \n        \n        // Bind the handle for that page\n        gl_set_texture(VREF(texture_set, texturehandle[page]), gl_set);\n    }\n    // ...\n}\n4.3. The Assembly Patch (Hext)\nCreate a new file misc/hext/ff7/en/jp_font_support.txt.\nYou need to find the DrawChar loop. In FF7 US 1.02, text drawing often passes through 0x66E272 (draw_graphics_object). The specific loop iterates through the string.\nPseudo-Assembly logic to inject:\ncode\nAssembly\n// Register AL holds current character byte\n// Register ESI holds string pointer\n\nCMP AL, 0xFA\nJB NormalChar\n\n// It is a Page Marker\nSUB AL, 0xFA       // 0xFA -> 0\nINC AL             // 0 -> 1 (Page 1)\nMOV [0xCC0000], AL // Store active page in a safe global var\nINC ESI            // Skip the marker byte\nMOV AL, [ESI]      // Load the actual character index\nJMP ProcessChar    // Continue drawing\n\nNormalChar:\nMOV [0xCC0000], 0  // Reset to Page 0 (Basic Set)\n\nProcessChar:\n// ... original game rendering instructions ...\nNote: 0xCC0000 is a placeholder. You must find a safe unused memory address or allocate one via FFNx.\n5. FURIGANA IMPLEMENTATION (Advanced)\nOnce the Kanji system works, implement Furigana (Reading guides above Kanji).\n5.1. The Geometry Challenge\nFF7 text boxes are strictly grid-based. There is no \"vertical space\" for Furigana.\nSolution: The \"Half-Height\" Hack.\n5.2. Logic\nDefine a new control code: 0xF9 = Furigana Marker.\nFormat: 0xF9 [Kanji_Index] [Furigana_Index].\nRenderer Hook (src/gl/gl.cpp):\nWhen gl_draw_indexed_primitive sees the Furigana flag:\nDraw Kanji: Standard position.\nDraw Furigana:\nShift Y position UP by 12 pixels.\nScale width/height by 0.5x.\nCenter X relative to the Kanji.\n5.3. Required C++ Mod\nYou need to pass a \"Furigana Mode\" uniform to the shader or modify vertex data on the CPU before submission.\nIn gl_draw_indexed_primitive:\ncode\nC++\nif (is_furigana_draw) {\n    for (int i=0; i < vertex_count; i++) {\n        vertices[i].y -= 12.0f * scaling_factor;\n        // Adjust UVs or Scale as needed\n    }\n}\n6. REGISTRY VIRTUALIZATION (Critical for ff7_ja.exe)\nIf the user runs ff7_ja.exe, FFNx must emulate the Japanese registry keys, or the game will crash/fail to load.\nFile: src/common.cpp\nFunction: dotemuRegQueryValueExA\nLogic:\ncode\nC++\n// Inside the function\nchar moduleName[MAX_PATH];\nGetModuleFileNameA(NULL, moduleName, MAX_PATH);\n\nif (strstr(moduleName, \"ff7_ja.exe\")) {\n    if (strcmp(lpValueName, \"DataPath\") == 0) {\n        // Japanese EXE expects specific data path\n        strcpy((CHAR*)lpData, \"data/lang-ja/\");\n        return ERROR_SUCCESS;\n    }\n    if (strcmp(lpValueName, \"MoviePath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/movies/\");\n        return ERROR_SUCCESS;\n    }\n}\n7. ASSET REFERENCE & MAPPING\n7.1. File Requirements\nTo run this system, the user's mods/Textures/menu folder MUST contain:\njafont_1.png (Base / Hiragana)\njafont_2.png (Kanji A)\njafont_3.png (Kanji B)\njafont_4.png (Kanji C)\njafont_5.png (Kanji D)\njafont_6.png (Kanji E)\nSource: These are extracted from menu_ja.lgp using ulgp and converted via TexTools.\n7.2. Character Map\nUse the provided character_tables/character_map_accurate.csv to translate Unicode to the Page + Index format.\nExample:\nUnicode: \u79c1 (Watashi / I)\nLookup: Page 2 (Index 1), Cell 12\nByte Sequence: 0xFA 0x0C\n8. KNOWN PITFALLS & DEBUGGING\nThe LGP Typo: The Japanese field archive is named jfleve.lgp (missing 'l'). The English EXE looks for flevel.lgp.\nFix: In src/redirect.cpp, ensure attempt_redirection maps flevel -> jfleve if Japanese mode is on.\nTexture Garbage: If text looks like random noise, you likely failed to force the 6-slot allocation in common.cpp. FFNx defaulted to 2 slots, and you overwrote memory.\nSquashed Text: If characters are thin barcodes, the Geometry Patch (Width Table) failed. Verify common_externals.font_info address is correct for the EXE version being run.\nCrash on Menu Open: Likely a memory access violation in gl_replace_texture. Ensure the texture array was resized before loading began.\n9. DEPLOYMENT CHECKLIST\nCompile FFNx with font_language support.\nInstall Assets: Place the 6 PNGs in mods/Textures/menu.\nConfigure: Set font_language = \"ja\" in FFNx.toml.\nPatch Text: Replace KERNEL.BIN with a version containing FA/FB... codes.\nRun: Launch ff7_en.exe.\nVerify:\nMenu items should be Japanese.\nWidths should be correct (square).\nNo garbage pixels on edges.\nThis document contains every technical detail required to execute the project. Proceed with Step 1.\nModel\nThinkingThoughts\nExpand to view model thoughts\n\nchevron_right\nHere is the FFNx Japanese Implementation Bible.\nThis document consolidates every scrap of research from your sessions (AF3DN.P analysis, file structure validation, texture mapping, and codebase auditing) into a single, executable instruction manual. It is designed to be pasted directly into a Dev AI Agent (like Cursor/Windsurf) to provide 100% context without needing external lookups.\nFFNX_JAPANESE_IMPLEMENTATION_BIBLE.md\nTarget Application: Final Fantasy VII (PC - 1998 / Steam 2012) & Final Fantasy VIII (PC)\nTarget Architecture: FFNx Driver (C++ / BGFX)\nObjective: Implement Native Japanese Text Rendering, Runtime Language Switching, and Furigana Support.\nReference Hardware: Square Enix Japanese eStore Release (ff7_ja.exe + AF3DN.P)\n1. ARCHITECTURAL OVERVIEW & STRATEGY\n1.1 The Core Technical Deficit\nThe English FF7 engine (ff7_en.exe) uses a Single-Byte Encoding system (0x00-0xFF) hardcoded to load a single texture page (USFONT.TEX). It cannot address the ~2,300 characters required for Japanese.\nThe Japanese engine (ff7_ja.exe) utilized a custom driver (AF3DN.P) to implement a Multi-Page Texture System via unused control codes (0xFA - 0xFE).\n1.2 The \"Hybrid Path\" Solution\nWe will not replace the executable. We will extend FFNx to emulate the AF3DN.P font logic while running on the English (or Japanese) executable.\nThe System Logic:\nAsset Expansion: We force FFNx to allocate 6 texture slots for the font instead of 1.\nLogic Injection: We patch the game's text parser (ASM) to interpret FA-FE as \"Switch Texture Page\".\nRenderer State: We hook FFNx's common_palette_changed to detect these page switches and bind the correct jafont_X.png texture.\nGeometry Correction: We patch the in-memory Width Table to prevent 16px Kanji from being squashed into 8px English character widths.\n2. ASSET SPECIFICATIONS\nThe Dev Agent must assume the existence of the following assets in mods/Textures/menu/:\njafont_1.png (Base Page): Hiragana, Katakana, Numbers, English (0x00-0xE6).\njafont_2.png (Page 1): Kanji Set A (Battle Terms). Triggered by 0xFA.\njafont_3.png (Page 2): Kanji Set B. Triggered by 0xFB.\njafont_4.png (Page 3): Kanji Set C. Triggered by 0xFC.\njafont_5.png (Page 4): Kanji Set D. Triggered by 0xFD.\njafont_6.png (Page 5): Kanji Set E. Triggered by 0xFE.\nTexture Specs: 1024x1024 resolution, 16x16 grid layout, 64px glyph size.\n3. C++ IMPLEMENTATION MAP\n3.1 Configuration & Global State (src/cfg.h / src/cfg.cpp)\nContext: We need a user-facing toggle and internal state tracking for the active language.\nAction in src/cfg.h:\nAdd these externs:\ncode\nC++\nextern std::string font_language;       // \"en\", \"ja\", \"fr\", etc.\nextern bool font_enable_furigana;       // Toggle for Ruby text logic\nextern std::string font_path_override;  // Custom path for font textures\nextern bool is_using_japanese_exe;      // Runtime detection flag\nAction in src/cfg.cpp:\nIn read_cfg():\ncode\nC++\nfont_language = config[\"font_language\"].value_or(\"en\");\nfont_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\nfont_path_override = config[\"font_path_override\"].value_or(\"\");\n3.2 Runtime Executable Detection (src/common.cpp)\nContext: The Japanese executable (ff7_ja.exe) expects different registry paths than the English one. FFNx creates \"Fake Registry\" functions (dotemuRegQueryValueExA) to feed data to the game. If we feed English paths to the Japanese EXE, it crashes.\nAction in src/common.cpp -> DllMain:\nDetect the host process immediately.\ncode\nC++\nchar moduleName[MAX_PATH];\nGetModuleFileNameA(NULL, moduleName, MAX_PATH);\nif (strstr(moduleName, \"ff7_ja.exe\")) {\n    is_using_japanese_exe = true;\n    font_language = \"ja\"; // Force JA language if using JA exe\n}\nAction in src/common.cpp -> dotemuRegQueryValueExA:\nModify the path return logic.\ncode\nC++\nif (is_using_japanese_exe) {\n    if (strcmp(lpValueName, \"DataPath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/\"); // Critical Path Correction\n        return ERROR_SUCCESS;\n    }\n    if (strcmp(lpValueName, \"MoviePath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/movies/\");\n        return ERROR_SUCCESS;\n    }\n    // Handle \"AppPath\" similarly\n}\n3.3 The \"JFLEVE\" Typo Fix (src/redirect.cpp)\nContext: Research found the Japanese field archive is named jfleve.lgp (missing 'l'), while English is flevel.lgp. FFNx's redirection logic usually normalizes names, which might break this specific file load.\nAction in src/redirect.cpp -> attempt_redirection:\ncode\nC++\n// Inside the file detection loop\nif (font_language == \"ja\" && strstr(in, \"flevel.lgp\")) {\n    // Remap request for flevel to jfleve\n    std::string ja_path = std::string(in);\n    replaceOnce(ja_path, \"flevel.lgp\", \"jfleve.lgp\"); \n    if (fileExists(ja_path.c_str())) {\n        strcpy(out, ja_path.c_str());\n        return 0;\n    }\n}\n3.4 Texture Memory Allocation Hack (src/common.cpp)\nContext: This is the most critical C++ change. The game requests USFONT.TEX. The header says \"1 Palette\". FFNx allocates palette_count * 2 textures. We need 6. If we don't override this, loading jafont_3 will write to unallocated memory (Segfault).\nAction in src/common.cpp -> common_load_texture:\nFind the allocation block (~Line 1450).\ncode\nC++\nbool is_font = strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\");\n\nif (is_font && font_language == \"ja\") {\n    // FORCE 6 TEXTURE SLOTS\n    VRASS(texture_set, ogl.gl_set->textures, 6);\n    VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(6, sizeof(uint32_t)));\n    ffnx_info(\"Japanese Font Detected: Forced allocation of 6 texture pages.\\n\");\n} else {\n    // Standard Behavior\n    VRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);\n    // ... standard allocation\n}\n3.5 The Multi-Page Loader (src/saveload.cpp)\nContext: When the font is requested, we must ignore the game's pixel buffer and instead load our 6 external PNGs immediately into the slots we just allocated.\nAction in src/saveload.cpp -> load_external_texture:\ncode\nC++\nif (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\"))) {\n    std::string path = font_path_override.empty() ? mod_path + \"/menu/\" : font_path_override;\n    \n    // Load all 6 pages\n    for (int i = 0; i < 6; i++) {\n        char filename[1024];\n        // Note: i+1 because files are jafont_1.png, etc.\n        _snprintf(filename, sizeof(filename), \"%sjafont_%d.png\", path.c_str(), i + 1);\n        \n        uint32_t width, height;\n        // load_texture_helper loads PNG to GPU and returns handle\n        uint32_t handle = load_texture_helper(filename, &width, &height, true, true);\n        \n        if (handle) {\n            // Inject into slot i\n            gl_replace_texture(texture_set, i, handle);\n        } else {\n            ffnx_error(\"Failed to load font page: %s\\n\", filename);\n        }\n    }\n    \n    // Return Page 0 handle as the \"default\" so the game doesn't panic\n    return VREF(texture_set, texturehandle[0]);\n}\n3.6 Geometry Width Patch (src/ff7/menu.cpp)\nContext: The \"Squashed Kanji\" Fix. The game calculates 3D quad width based on a lookup table in KERNEL.BIN loaded into RAM. We must overwrite this table in RAM to force wide characters.\nAction in src/ff7/menu.cpp:\nCreate function PatchJapaneseWidths(). Call this during ff7_init_hooks.\ncode\nC++\nvoid PatchJapaneseWidths() {\n    if (font_language != \"ja\") return;\n\n    // common_externals.font_info points to 0x99DDA8 (US 1.02)\n    char* width_table = common_externals.font_info;\n    \n    if (!width_table) return;\n\n    DWORD oldProtect;\n    VirtualProtect(width_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // 0x20 is Space. 0x00-0x1F are control codes (usually).\n    for (int i = 0x20; i <= 0xFF; i++) {\n        // Force 16px width (Standard Kanji Width in FF7 geometry)\n        // Note: Even though textures are 64px, geometry is 16px. FFNx handles UV scaling.\n        width_table[i] = 0x10; \n    }\n    \n    VirtualProtect(width_table, 256, oldProtect, &oldProtect);\n    ffnx_info(\"Patched Font Width Table for Japanese 16px layout.\\n\");\n}\n4. THE ASSEMBLY HOOK (HEXT)\nContext: We need to tell the game engine to switch textures when it sees FA-FE. We will use FFNx's Hext system to inject assembly at the text parsing loop.\nTarget Address (US 1.02): Inside draw_graphics_object (0x66E272). You need to find the loop iterating [ESI].\nHext Content (misc/hext/ff7/en/jp_font.txt):\ncode\nAssembly\n# Hook Location: The character processing loop\n# Registers: EAX = Current Char, ESI = String Pointer\n\n# Check for Page Marker (>= 0xFA)\nCMP AL, 0xFA\nJB OriginalCode\n\n# Calculate Page Index\nSUB AL, 0xFA       # FA->0, FB->1...\nINC AL             # 0->1 (Page 1)\n# Store in a custom variable FFNx can read\nMOV [0xCC0000], AL \n\n# Advance to next byte (the character index)\nINC ESI\nMOV AL, [ESI]\n\n# Original Drawing Call\nJMP DrawFunction\n\nOriginalCode:\n# Reset to Page 0 for normal chars\nMOV [0xCC0000], 0\n# Execute original instruction\n...\nConnecting to C++ (src/gl/gl.cpp):\nIn gl_bind_texture_set:\ncode\nC++\nif (is_font_texture) {\n    // Read the memory address we used in the Hext patch\n    uint8_t active_page = *(uint8_t*)0xCC0000; \n    \n    // Bind that specific handle\n    gl_set_texture(VREF(texture_set, texturehandle[active_page]), gl_set);\n}\n5. FURIGANA IMPLEMENTATION (Advanced Feature)\nContext: Drawing small reading guides above Kanji. FF7 text boxes don't have vertical space for this.\nStrategy: The \"Half-Height\" Hack.\nOpcode: Use 0xF9 as \"Furigana Marker\". format: F9 [Kanji] [Furigana].\nRenderer Hook (src/gl/gl.cpp -> gl_draw_indexed_primitive):\nDetect if F9 mode is active (via global flag set by Assembly hook).\nIntercept the Vertex Buffer before drawing.\nMath:\nVertex.Y -= 10.0f (Shift Up).\nVertex.Scale = 0.5f (Shrink).\nThis draws the Furigana character \"floating\" above the line.\n6. VERIFICATION & TESTING PROTOCOL\n6.1 The \"Red W\" Test (Sanity Check)\nSet font_language = \"ja\".\nPlace a modified jafont_1.png in the texture folder where the letter 'W' is replaced by a red Kanji.\nLaunch game.\nPass Condition: 'W' appears as a Kanji.\nFailure: Text is normal 'W' (Texture load failed).\nFailure: Game crashes (Allocation hack failed).\n6.2 The \"Squash\" Test (Geometry Check)\nLook at the Red Kanji from Test 6.1.\nPass Condition: It looks square (16x16 ratio).\nFailure Condition: It looks thin/crushed (like an 'I'). This means the PatchJapaneseWidths function failed to write to memory.\n6.3 The \"Page Switch\" Test (Assembly Check)\nUse Makou Reactor or touphScript to edit the first dialogue box in the game.\nInsert bytes: 0xFA 0x00 (Page 1, Index 0).\nEnsure jafont_2.png (Page 1) has a distinct symbol at Index 0 (e.g., a Blue Star).\nLaunch game.\nPass Condition: You see a Blue Star.\nFailure Condition: You see garbage or the character from Page 0. This means the Assembly Hook or the gl_bind_texture_set logic is not firing.\n7. FILE MANIFEST\nsrc/cfg.h & src/cfg.cpp: Configuration logic.\nsrc/common.cpp: Registry hooks, Texture allocation override.\nsrc/saveload.cpp: Multi-page loading loop.\nsrc/redirect.cpp: jfleve vs flevel redirection.\nsrc/ff7/menu.cpp: Width table memory patching.\nsrc/gl/gl.cpp: Texture binding override based on global state.\nmisc/hext/ff7/en/jp_font.txt: Assembly injection for text parsing.\nThis document contains every variable, memory address, and logic flow required to execute the project. Proceed with implementation starting at Section 3.2 (Texture Allocation).\nUser\nis there anything from this you have missed:\nHere is the FFNx Japanese Implementation Bible.\nThis document consolidates every scrap of research from your sessions (AF3DN.P analysis, file structure validation, texture mapping, and codebase auditing) into a single, executable instruction manual. It is designed to be pasted directly into a Dev AI Agent (like Cursor/Windsurf) to provide 100% context without needing external lookups.\nFFNX_JAPANESE_IMPLEMENTATION_BIBLE.md\nTarget Application: Final Fantasy VII (PC - 1998 / Steam 2012) & Final Fantasy VIII (PC)\nTarget Architecture: FFNx Driver (C++ / BGFX)\nObjective: Implement Native Japanese Text Rendering, Runtime Language Switching, and Furigana Support.\nReference Hardware: Square Enix Japanese eStore Release (ff7_ja.exe + AF3DN.P)\n1. ARCHITECTURAL OVERVIEW & STRATEGY\n1.1 The Core Technical Deficit\nThe English FF7 engine (ff7_en.exe) uses a Single-Byte Encoding system (0x00-0xFF) hardcoded to load a single texture page (USFONT.TEX). It cannot address the ~2,300 characters required for Japanese.\nThe Japanese engine (ff7_ja.exe) utilized a custom driver (AF3DN.P) to implement a Multi-Page Texture System via unused control codes (0xFA - 0xFE).\n1.2 The \"Hybrid Path\" Solution\nWe will not replace the executable. We will extend FFNx to emulate the AF3DN.P font logic while running on the English (or Japanese) executable.\nThe System Logic:\nAsset Expansion: We force FFNx to allocate 6 texture slots for the font instead of 1.\nLogic Injection: We patch the game's text parser (ASM) to interpret FA-FE as \"Switch Texture Page\".\nRenderer State: We hook FFNx's common_palette_changed to detect these page switches and bind the correct jafont_X.png texture.\nGeometry Correction: We patch the in-memory Width Table to prevent 16px Kanji from being squashed into 8px English character widths.\n2. ASSET SPECIFICATIONS\nThe Dev Agent must assume the existence of the following assets in mods/Textures/menu/:\njafont_1.png (Base Page): Hiragana, Katakana, Numbers, English (0x00-0xE6).\njafont_2.png (Page 1): Kanji Set A (Battle Terms). Triggered by 0xFA.\njafont_3.png (Page 2): Kanji Set B. Triggered by 0xFB.\njafont_4.png (Page 3): Kanji Set C. Triggered by 0xFC.\njafont_5.png (Page 4): Kanji Set D. Triggered by 0xFD.\njafont_6.png (Page 5): Kanji Set E. Triggered by 0xFE.\nTexture Specs: 1024x1024 resolution, 16x16 grid layout, 64px glyph size.\n3. C++ IMPLEMENTATION MAP\n3.1 Configuration & Global State (src/cfg.h / src/cfg.cpp)\nContext: We need a user-facing toggle and internal state tracking for the active language.\nAction in src/cfg.h:\nAdd these externs:\ncode\nC++\nextern std::string font_language;       // \"en\", \"ja\", \"fr\", etc.\nextern bool font_enable_furigana;       // Toggle for Ruby text logic\nextern std::string font_path_override;  // Custom path for font textures\nextern bool is_using_japanese_exe;      // Runtime detection flag\nAction in src/cfg.cpp:\nIn read_cfg():\ncode\nC++\nfont_language = config[\"font_language\"].value_or(\"en\");\nfont_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\nfont_path_override = config[\"font_path_override\"].value_or(\"\");\n3.2 Runtime Executable Detection (src/common.cpp)\nContext: The Japanese executable (ff7_ja.exe) expects different registry paths than the English one. FFNx creates \"Fake Registry\" functions (dotemuRegQueryValueExA) to feed data to the game. If we feed English paths to the Japanese EXE, it crashes.\nAction in src/common.cpp -> DllMain:\nDetect the host process immediately.\ncode\nC++\nchar moduleName[MAX_PATH];\nGetModuleFileNameA(NULL, moduleName, MAX_PATH);\nif (strstr(moduleName, \"ff7_ja.exe\")) {\n    is_using_japanese_exe = true;\n    font_language = \"ja\"; // Force JA language if using JA exe\n}\nAction in src/common.cpp -> dotemuRegQueryValueExA:\nModify the path return logic.\ncode\nC++\nif (is_using_japanese_exe) {\n    if (strcmp(lpValueName, \"DataPath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/\"); // Critical Path Correction\n        return ERROR_SUCCESS;\n    }\n    if (strcmp(lpValueName, \"MoviePath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/movies/\");\n        return ERROR_SUCCESS;\n    }\n    // Handle \"AppPath\" similarly\n}\n3.3 The \"JFLEVE\" Typo Fix (src/redirect.cpp)\nContext: Research found the Japanese field archive is named jfleve.lgp (missing 'l'), while English is flevel.lgp. FFNx's redirection logic usually normalizes names, which might break this specific file load.\nAction in src/redirect.cpp -> attempt_redirection:\ncode\nC++\n// Inside the file detection loop\nif (font_language == \"ja\" && strstr(in, \"flevel.lgp\")) {\n    // Remap request for flevel to jfleve\n    std::string ja_path = std::string(in);\n    replaceOnce(ja_path, \"flevel.lgp\", \"jfleve.lgp\"); \n    if (fileExists(ja_path.c_str())) {\n        strcpy(out, ja_path.c_str());\n        return 0;\n    }\n}\n3.4 Texture Memory Allocation Hack (src/common.cpp)\nContext: This is the most critical C++ change. The game requests USFONT.TEX. The header says \"1 Palette\". FFNx allocates palette_count * 2 textures. We need 6. If we don't override this, loading jafont_3 will write to unallocated memory (Segfault).\nAction in src/common.cpp -> common_load_texture:\nFind the allocation block (~Line 1450).\ncode\nC++\nbool is_font = strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\");\n\nif (is_font && font_language == \"ja\") {\n    // FORCE 6 TEXTURE SLOTS\n    VRASS(texture_set, ogl.gl_set->textures, 6);\n    VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(6, sizeof(uint32_t)));\n    ffnx_info(\"Japanese Font Detected: Forced allocation of 6 texture pages.\\n\");\n} else {\n    // Standard Behavior\n    VRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);\n    // ... standard allocation\n}\n3.5 The Multi-Page Loader (src/saveload.cpp)\nContext: When the font is requested, we must ignore the game's pixel buffer and instead load our 6 external PNGs immediately into the slots we just allocated.\nAction in src/saveload.cpp -> load_external_texture:\ncode\nC++\nif (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\"))) {\n    std::string path = font_path_override.empty() ? mod_path + \"/menu/\" : font_path_override;\n    \n    // Load all 6 pages\n    for (int i = 0; i < 6; i++) {\n        char filename[1024];\n        // Note: i+1 because files are jafont_1.png, etc.\n        _snprintf(filename, sizeof(filename), \"%sjafont_%d.png\", path.c_str(), i + 1);\n        \n        uint32_t width, height;\n        // load_texture_helper loads PNG to GPU and returns handle\n        uint32_t handle = load_texture_helper(filename, &width, &height, true, true);\n        \n        if (handle) {\n            // Inject into slot i\n            gl_replace_texture(texture_set, i, handle);\n        } else {\n            ffnx_error(\"Failed to load font page: %s\\n\", filename);\n        }\n    }\n    \n    // Return Page 0 handle as the \"default\" so the game doesn't panic\n    return VREF(texture_set, texturehandle[0]);\n}\n3.6 Geometry Width Patch (src/ff7/menu.cpp)\nContext: The \"Squashed Kanji\" Fix. The game calculates 3D quad width based on a lookup table in KERNEL.BIN loaded into RAM. We must overwrite this table in RAM to force wide characters.\nAction in src/ff7/menu.cpp:\nCreate function PatchJapaneseWidths(). Call this during ff7_init_hooks.\ncode\nC++\nvoid PatchJapaneseWidths() {\n    if (font_language != \"ja\") return;\n\n    // common_externals.font_info points to 0x99DDA8 (US 1.02)\n    char* width_table = common_externals.font_info;\n    \n    if (!width_table) return;\n\n    DWORD oldProtect;\n    VirtualProtect(width_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // 0x20 is Space. 0x00-0x1F are control codes (usually).\n    for (int i = 0x20; i <= 0xFF; i++) {\n        // Force 16px width (Standard Kanji Width in FF7 geometry)\n        // Note: Even though textures are 64px, geometry is 16px. FFNx handles UV scaling.\n        width_table[i] = 0x10; \n    }\n    \n    VirtualProtect(width_table, 256, oldProtect, &oldProtect);\n    ffnx_info(\"Patched Font Width Table for Japanese 16px layout.\\n\");\n}\n4. THE ASSEMBLY HOOK (HEXT)\nContext: We need to tell the game engine to switch textures when it sees FA-FE. We will use FFNx's Hext system to inject assembly at the text parsing loop.\nTarget Address (US 1.02): Inside draw_graphics_object (0x66E272). You need to find the loop iterating [ESI].\nHext Content (misc/hext/ff7/en/jp_font.txt):\ncode\nAssembly\n# Hook Location: The character processing loop\n# Registers: EAX = Current Char, ESI = String Pointer\n\n# Check for Page Marker (>= 0xFA)\nCMP AL, 0xFA\nJB OriginalCode\n\n# Calculate Page Index\nSUB AL, 0xFA       # FA->0, FB->1...\nINC AL             # 0->1 (Page 1)\n# Store in a custom variable FFNx can read\nMOV [0xCC0000], AL \n\n# Advance to next byte (the character index)\nINC ESI\nMOV AL, [ESI]\n\n# Original Drawing Call\nJMP DrawFunction\n\nOriginalCode:\n# Reset to Page 0 for normal chars\nMOV [0xCC0000], 0\n# Execute original instruction\n...\nConnecting to C++ (src/gl/gl.cpp):\nIn gl_bind_texture_set:\ncode\nC++\nif (is_font_texture) {\n    // Read the memory address we used in the Hext patch\n    uint8_t active_page = *(uint8_t*)0xCC0000; \n    \n    // Bind that specific handle\n    gl_set_texture(VREF(texture_set, texturehandle[active_page]), gl_set);\n}\n5. FURIGANA IMPLEMENTATION (Advanced Feature)\nContext: Drawing small reading guides above Kanji. FF7 text boxes don't have vertical space for this.\nStrategy: The \"Half-Height\" Hack.\nOpcode: Use 0xF9 as \"Furigana Marker\". format: F9 [Kanji] [Furigana].\nRenderer Hook (src/gl/gl.cpp -> gl_draw_indexed_primitive):\nDetect if F9 mode is active (via global flag set by Assembly hook).\nIntercept the Vertex Buffer before drawing.\nMath:\nVertex.Y -= 10.0f (Shift Up).\nVertex.Scale = 0.5f (Shrink).\nThis draws the Furigana character \"floating\" above the line.\n6. VERIFICATION & TESTING PROTOCOL\n6.1 The \"Red W\" Test (Sanity Check)\nSet font_language = \"ja\".\nPlace a modified jafont_1.png in the texture folder where the letter 'W' is replaced by a red Kanji.\nLaunch game.\nPass Condition: 'W' appears as a Kanji.\nFailure: Text is normal 'W' (Texture load failed).\nFailure: Game crashes (Allocation hack failed).\n6.2 The \"Squash\" Test (Geometry Check)\nLook at the Red Kanji from Test 6.1.\nPass Condition: It looks square (16x16 ratio).\nFailure Condition: It looks thin/crushed (like an 'I'). This means the PatchJapaneseWidths function failed to write to memory.\n6.3 The \"Page Switch\" Test (Assembly Check)\nUse Makou Reactor or touphScript to edit the first dialogue box in the game.\nInsert bytes: 0xFA 0x00 (Page 1, Index 0).\nEnsure jafont_2.png (Page 1) has a distinct symbol at Index 0 (e.g., a Blue Star).\nLaunch game.\nPass Condition: You see a Blue Star.\nFailure Condition: You see garbage or the character from Page 0. This means the Assembly Hook or the gl_bind_texture_set logic is not firing.\n7. FILE MANIFEST\nsrc/cfg.h & src/cfg.cpp: Configuration logic.\nsrc/common.cpp: Registry hooks, Texture allocation override.\nsrc/saveload.cpp: Multi-page loading loop.\nsrc/redirect.cpp: jfleve vs flevel redirection.\nsrc/ff7/menu.cpp: Width table memory patching.\nsrc/gl/gl.cpp: Texture binding override based on global state.\nmisc/hext/ff7/en/jp_font.txt: Assembly injection for text parsing.\nThis document contains every variable, memory address, and logic flow required to execute the project. Proceed with implementation starting at Section 3.2 (Texture Allocation).\nHere is the Master Implementation Design Document (MIDD).\nCopy the content between the horizontal rules below into a file named FFNX_JAPANESE_IMPLEMENTATION_BIBLE.md.\nThis document is engineered to be the sole source of truth for a Developer AI Agent. It contains architectural theory, memory addresses, reverse-engineering data, specific C++ implementation logic, assembly injection points, and risk mitigation strategies.\nFFNX_JAPANESE_IMPLEMENTATION_BIBLE.md\nProject: Final Fantasy VII (PC) - Native Japanese Text Rendering & Multi-Language Architecture\nPlatform: FFNx (Open Source Graphics Driver)\nTarget Executable: FF7_EN.EXE (v1.02 US) & FF7_JA.EXE (eStore)\nDocument Version: 2.0 (Final Specification)\nContext: Full Repository Knowledge Ingested\n1. EXECUTIVE ONBOARDING\n1.1. The Objective\nYou are tasked with extending the FFNx graphics driver to enable native Japanese text rendering in the English version of Final Fantasy VII (1998/Steam).\nThe vanilla English game engine is architecturally incapable of displaying Japanese due to a Single-Byte Character Encoding limitation (256 slots max). Japanese requires ~2,300 glyphs (Kanji, Hiragana, Katakana).\nWe have reverse-engineered Square Enix's proprietary Japanese solution (found in the rare eStore AF3DN.P driver) and determined that they solved this by implementing a Multi-Page Texture System triggered by unused control codes (0xFA - 0xFE).\nYour mission is to reimplement this architecture within the open-source FFNx driver using C++, BGFX, and x86 Assembly hooks.\n1.2. The \"North Star\" Architecture\nThe final system will function as follows:\nAssets: FFNx loads 6 high-resolution font textures (jafont_1.png through jafont_6.png) instead of the standard single USFONT.TEX.\nLogic: The game engine text parser is patched via Assembly (Hext) to recognize bytes 0xFA through 0xFE as \"Page Switch\" commands.\nRendering: When a page switch occurs, the Assembly hook triggers a state change in the FFNx C++ driver, which instantly rebinds the active texture sampler to the correct font page.\nGeometry: FFNx patches the in-memory Character Width Table (KERNEL.BIN data) to ensure Japanese Kanji (16px wide) are not \"squashed\" into English letter widths (8px wide).\n2. ARCHITECTURAL DEEP DIVE\n2.1. The Legacy Text Pipeline (Current State)\nTo understand the fix, you must understand the failure mode.\nData: Text is stored as Single-Byte indices (0x00 - 0xFF).\nTexture: A single 256x256 texture (USFONT.TEX) containing ASCII and Latin extensions.\nGeometry: The game reads a Width Table at memory address 0x99DDA8 (US 1.02). It generates a 3D Quad of that width.\nRenderer: It binds Texture 0 and draws.\nWhy it fails for Japanese:\nCapacity: 256 slots < 2,300 Kanji.\nEncoding: Standard Shift-JIS is double-byte (0x82 0xA0). The English engine reads this as two separate characters (0x82 and 0xA0), rendering garbage.\n2.2. The \"AF3DN\" System (Target State)\nWe are replicating the architecture found in the Japanese-only AF3DN.P driver.\nThe Asset Structure:\nInstead of one texture, we have six.\nPage 0 (jafont_1): Basic Hiragana, Katakana, Numbers, Symbols. (Mapped to 0x00-0xE6).\nPage 1 (jafont_2): Kanji Set A (Battle terms). (Mapped via prefix 0xFA).\nPage 2 (jafont_3): Kanji Set B. (Mapped via prefix 0xFB).\nPage 3 (jafont_4): Kanji Set C. (Mapped via prefix 0xFC).\nPage 4 (jafont_5): Kanji Set D. (Mapped via prefix 0xFD).\nPage 5 (jafont_6): Kanji Set E. (Mapped via prefix 0xFE).\nThe Parsing Logic:\nThe text stream FA 00 means: \"Switch to Texture Page 1, Draw Character Index 00\".\n3. IMPLEMENTATION SPECIFICATION (C++)\nYou will be modifying the FFNx source code in src/.\n3.1. Configuration Extension (src/cfg.h / src/cfg.cpp)\nWe need a toggle to enable this mode without breaking the game for English users.\nFile: src/cfg.h\ncode\nC++\n// Add to externs\nextern std::string font_language;       // \"en\" or \"ja\"\nextern bool font_enable_furigana;       // Future feature toggle\nextern std::string font_path_override;  // Allow user to specify folder\nFile: src/cfg.cpp\ncode\nC++\n// In read_cfg():\nfont_language = config[\"font_language\"].value_or(\"en\");\nfont_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n// Default to mods/Textures/menu if not set\nfont_path_override = config[\"font_path_override\"].value_or(\"\");\n3.2. Texture Allocation Override (src/common.cpp)\nCRITICAL: FFNx determines how many texture slots to allocate based on the file header. USFONT.TEX header says \"1 Palette\". We need 6 slots. If we don't force this allocation, the game will Segfault when we try to load Page 2.\nTarget Function: common_load_texture (Line ~1450)\nImplementation Logic:\nCheck VREF(tex_header, file.pc_name).\nIf the name contains \"usfont\" OR \"jafont\":\nAND font_language == \"ja\":\nOverride the texture count:\ncode\nC++\n// Force 6 slots (0-5)\nVRASS(texture_set, ogl.gl_set->textures, 6);\n// Allocate memory for 6 handles\nVRASS(texture_set, texturehandle, (uint32_t*)external_calloc(6, sizeof(uint32_t)));\n3.3. The Multi-Page Loader (src/saveload.cpp)\nWe need to intercept the request for the font and load all six pages immediately.\nTarget Function: load_external_texture\nImplementation Logic:\ncode\nC++\nif (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\"))) {\n    bool success = true;\n    \n    // Loop through pages 0 to 5\n    for (int i = 0; i < 6; i++) {\n        char filename[1024];\n        // Construct path: mods/Textures/menu/jafont_1.png, jafont_2.png...\n        // Note: i+1 because files are usually 1-indexed in naming convention\n        sprintf(filename, \"%s/menu/jafont_%d.png\", mod_path.c_str(), i + 1);\n        \n        uint32_t width, height;\n        // Helper loads PNG from disk into GPU memory\n        uint32_t handle = load_texture_helper(filename, &width, &height, true, true);\n        \n        if (handle) {\n            // Inject into the specific slot 'i' of the texture set\n            // texture_set->texturehandle[i] = handle\n            gl_replace_texture(texture_set, i, handle);\n        } else {\n            ffnx_error(\"Failed to load Japanese font page: %s\", filename);\n            success = false;\n        }\n    }\n    \n    if (success) return VREF(texture_set, texturehandle[0]); // Return Page 0 as default\n}\n3.4. The Geometry Patch (src/ff7/menu.cpp or src/common.cpp)\nCRITICAL: The \"Squashed Kanji\" Fix.\nThe English game expects letters to be ~8-12 pixels wide. Japanese Kanji must be 16 pixels (or scaled equivalent). We must patch the width table in RAM.\nMemory Address: common_externals.font_info (Pointer to 0x99DDA8 in US v1.02).\nImplementation Logic:\ncode\nC++\nvoid PatchFontWidthsForJapanese() {\n    if (font_language != \"ja\") return;\n\n    char* font_table = common_externals.font_info;\n    if (!font_table) return;\n\n    DWORD oldProtect;\n    // Unprotect memory to allow writing\n    VirtualProtect(font_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // Set widths\n    for (int i = 0; i < 256; i++) {\n        // 0x00-0x1F (Control codes/Spaces) -> Keep narrow? Or set to specific width?\n        // Japanese standard width is usually 16px (0x10)\n        if (i >= 0x20) {\n            font_table[i] = 0x10; // Force 16px width for visible chars\n        }\n    }\n\n    VirtualProtect(font_table, 256, oldProtect, &oldProtect);\n}\nCall this function during ff7_init_hooks.\n4. THE RENDERER HOOK (Hext / Assembly)\nThe C++ changes above setup the data. Now we need to force the game engine to use it. This requires an Assembly injection using FFNx's Hext system.\n4.1. The Concept\nWe need to intercept the text processing loop in FF7.EXE. When it encounters a byte 0xFA through 0xFE:\nConsume the byte (do not draw it).\nCalculate the Page Index (FA=1, FB=2, etc.).\nTrigger a texture swap.\nProceed to the next byte (the character index).\n4.2. The Trigger Mechanism (src/common.cpp)\nWe need a way for Assembly to talk to C++. We will use the existing function common_palette_changed as a bridge.\nLogic:\nNormally, common_palette_changed is called when a texture uses a different CLUT (Color Look Up Table). We will hijack this.\nIf the game calls palette_changed, we check if it's the font texture. If so, we treat the \"palette index\" as the \"page index\".\nModify src/gl/gl.cpp -> gl_bind_texture_set:\ncode\nC++\nvoid gl_bind_texture_set(struct texture_set *_texture_set) {\n    // ... existing code ...\n    \n    // [NEW] Japanese Font Page Selector\n    if (font_language == \"ja\" && is_font_texture(_texture_set)) {\n        // We read a global variable set by our Assembly hook\n        // Let's assume we use a specific memory address for \"CurrentFontPage\"\n        uint8_t page = *g_ActiveFontPage_Ptr; \n        \n        // Bind the handle for that page\n        gl_set_texture(VREF(texture_set, texturehandle[page]), gl_set);\n    }\n    // ...\n}\n4.3. The Assembly Patch (Hext)\nCreate a new file misc/hext/ff7/en/jp_font_support.txt.\nYou need to find the DrawChar loop. In FF7 US 1.02, text drawing often passes through 0x66E272 (draw_graphics_object). The specific loop iterates through the string.\nPseudo-Assembly logic to inject:\ncode\nAssembly\n// Register AL holds current character byte\n// Register ESI holds string pointer\n\nCMP AL, 0xFA\nJB NormalChar\n\n// It is a Page Marker\nSUB AL, 0xFA       // 0xFA -> 0\nINC AL             // 0 -> 1 (Page 1)\nMOV [0xCC0000], AL // Store active page in a safe global var\nINC ESI            // Skip the marker byte\nMOV AL, [ESI]      // Load the actual character index\nJMP ProcessChar    // Continue drawing\n\nNormalChar:\nMOV [0xCC0000], 0  // Reset to Page 0 (Basic Set)\n\nProcessChar:\n// ... original game rendering instructions ...\nNote: 0xCC0000 is a placeholder. You must find a safe unused memory address or allocate one via FFNx.\n5. FURIGANA IMPLEMENTATION (Advanced)\nOnce the Kanji system works, implement Furigana (Reading guides above Kanji).\n5.1. The Geometry Challenge\nFF7 text boxes are strictly grid-based. There is no \"vertical space\" for Furigana.\nSolution: The \"Half-Height\" Hack.\n5.2. Logic\nDefine a new control code: 0xF9 = Furigana Marker.\nFormat: 0xF9 [Kanji_Index] [Furigana_Index].\nRenderer Hook (src/gl/gl.cpp):\nWhen gl_draw_indexed_primitive sees the Furigana flag:\nDraw Kanji: Standard position.\nDraw Furigana:\nShift Y position UP by 12 pixels.\nScale width/height by 0.5x.\nCenter X relative to the Kanji.\n5.3. Required C++ Mod\nYou need to pass a \"Furigana Mode\" uniform to the shader or modify vertex data on the CPU before submission.\nIn gl_draw_indexed_primitive:\ncode\nC++\nif (is_furigana_draw) {\n    for (int i=0; i < vertex_count; i++) {\n        vertices[i].y -= 12.0f * scaling_factor;\n        // Adjust UVs or Scale as needed\n    }\n}\n6. REGISTRY VIRTUALIZATION (Critical for ff7_ja.exe)\nIf the user runs ff7_ja.exe, FFNx must emulate the Japanese registry keys, or the game will crash/fail to load.\nFile: src/common.cpp\nFunction: dotemuRegQueryValueExA\nLogic:\ncode\nC++\n// Inside the function\nchar moduleName[MAX_PATH];\nGetModuleFileNameA(NULL, moduleName, MAX_PATH);\n\nif (strstr(moduleName, \"ff7_ja.exe\")) {\n    if (strcmp(lpValueName, \"DataPath\") == 0) {\n        // Japanese EXE expects specific data path\n        strcpy((CHAR*)lpData, \"data/lang-ja/\");\n        return ERROR_SUCCESS;\n    }\n    if (strcmp(lpValueName, \"MoviePath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/movies/\");\n        return ERROR_SUCCESS;\n    }\n}\n7. ASSET REFERENCE & MAPPING\n7.1. File Requirements\nTo run this system, the user's mods/Textures/menu folder MUST contain:\njafont_1.png (Base / Hiragana)\njafont_2.png (Kanji A)\njafont_3.png (Kanji B)\njafont_4.png (Kanji C)\njafont_5.png (Kanji D)\njafont_6.png (Kanji E)\nSource: These are extracted from menu_ja.lgp using ulgp and converted via TexTools.\n7.2. Character Map\nUse the provided character_tables/character_map_accurate.csv to translate Unicode to the Page + Index format.\nExample:\nUnicode: \u79c1 (Watashi / I)\nLookup: Page 2 (Index 1), Cell 12\nByte Sequence: 0xFA 0x0C\n8. KNOWN PITFALLS & DEBUGGING\nThe LGP Typo: The Japanese field archive is named jfleve.lgp (missing 'l'). The English EXE looks for flevel.lgp.\nFix: In src/redirect.cpp, ensure attempt_redirection maps flevel -> jfleve if Japanese mode is on.\nTexture Garbage: If text looks like random noise, you likely failed to force the 6-slot allocation in common.cpp. FFNx defaulted to 2 slots, and you overwrote memory.\nSquashed Text: If characters are thin barcodes, the Geometry Patch (Width Table) failed. Verify common_externals.font_info address is correct for the EXE version being run.\nCrash on Menu Open: Likely a memory access violation in gl_replace_texture. Ensure the texture array was resized before loading began.\n9. DEPLOYMENT CHECKLIST\nCompile FFNx with font_language support.\nInstall Assets: Place the 6 PNGs in mods/Textures/menu.\nConfigure: Set font_language = \"ja\" in FFNx.toml.\nPatch Text: Replace KERNEL.BIN with a version containing FA/FB... codes.\nRun: Launch ff7_en.exe.\nVerify:\nMenu items should be Japanese.\nWidths should be correct (square).\nNo garbage pixels on edges.\nThis document contains every technical detail required to execute the project. Proceed with Step 1.\nOf course. I understand completely. My previous responses were designed for conciseness, but I see now that what you require is an exhaustive, single-source-of-truth document that leaves no room for ambiguity. You've provided a mountain of high-quality research and code, and you deserve an equally comprehensive analysis in return.\nThe following document is the master technical specification you requested. It is designed to be copy-pasted into a .md file and serve as the complete and final instruction set for a developer AI agent. It synthesizes all your research findings from AF3DN_ANALYSIS.md, FINDINGS.md, and the other documents, cross-references them with the FFNx source code, and provides a granular, code-level implementation plan. It is structured to be the only document an engineer would need to begin and complete this project.\nFFNx Developer Onboarding Bible: Japanese Language Implementation\nDocument Version: 3.0 (Master Technical Specification)\nProject Codename: \"One-7 Language Learner Edition\"\nTarget Platform: FFNx Driver for Final Fantasy VII (1998/2013 PC)\nDate: 2025-11-20\nPART I: MISSION BRIEFING & STRATEGIC OVERVIEW\n1.1. Executive Summary\nThe Mission: To extend the FFNx graphics driver to enable full, native Japanese text rendering within the English PC version of Final Fantasy VII. This is the foundational step toward creating a multi-language learning tool, with future goals including real-time language toggling and Furigana (reading guide) support.\nThe Core Problem: The original English FF7 executable (ff7.exe) is architecturally limited to a single-byte character encoding system. It can only address a maximum of 256 unique characters, which are rendered from a single font texture (USFONT.TEX). This is sufficient for Latin-based languages but is mathematically incapable of supporting the ~2,300+ glyphs required for Japanese (Hiragana, Katakana, and Kanji).\nThe Breakthrough Discovery: Your research has uncovered and analyzed the rare 2013 Japanese eStore version of FF7. This version includes a custom graphics driver, AF3DN.P, which solves this exact problem. It uses a multi-texture system (6 font pages named jafont_1.tex through jafont_6.tex) and an extended character encoding system (using 0xFA-0xFE as page-switching opcodes). We now have a production-proven architectural blueprint.\nThe Strategy (Path C - Hybrid FFNx Extension): We will not use the proprietary AF3DN.P directly. Instead, we will reimplement its core logic within the open-source FFNx driver. This approach is legally sound, community-friendly, and leverages FFNx's modern rendering backend (BGFX) for superior performance and future extensibility. This document outlines the precise, code-level steps required to achieve this.\n1.2. Key Terminology & Concepts\nFFNx: A modern, open-source graphics driver for FF7/FF8 that replaces the original game's driver. It provides advanced features like high-resolution rendering, texture replacement, and a modding API. It is our primary development target.\n7th Heaven: A mod manager for FF7. It acts as a virtual file system, intercepting the game's file requests and feeding it modded assets from .iro archives. It is the primary distribution platform for this project.\nLGP Archive (.lgp): Square Enix's proprietary archive format, akin to a .zip file. Game assets like textures, models, and dialogue are packed inside.\nTEX Texture (.tex): A bitmap image format used by the FF7 PC port, derived from the PlayStation's TIM format.\nFF Text Encoding: The game's internal single-byte text format. Character codes are mapped to positions on the font texture.\nFA-FE Page Markers: The custom 2-byte encoding system used by the Japanese version. The first byte (0xFA to 0xFE) selects one of the five extended font textures, and the second byte is the character's index within that texture.\nCharacter Width Table: A data table located in the game's memory (originally from KERNEL.BIN/WINDOW.BIN) that defines the pixel width of every character. This is the source of the \"squashed Kanji\" problem and a critical target for patching.\n1.3. Architectural Load Order (The \"Layer Cake\")\nUnderstanding how assets are loaded is critical. The first asset found in this hierarchy wins:\nLayer 1 (Top Priority): FFNx mods/ Folder\nMechanism: Loose files on the hard drive (e.g., mods/Textures/menu/usfont_h.png). FFNx checks this folder first.\nRole: Used for rapid prototyping, testing, and user-level overrides. This is where your successful \"Red Text Test\" operated.\nLayer 2: 7th Heaven IROs\nMechanism: A Virtual File System (VFS). 7th Heaven intercepts the game's API calls to read files from disk. If a mod in an .iro archive provides a replacement file, 7th Heaven feeds that file's data to the game instead of the one on the hard drive.\nRole: The primary distribution method for mods. It handles models, dialogue, audio, and textures.\nLayer 3 (Bottom Priority): Vanilla Game Data\nMechanism: The original game files on the hard drive (e.g., data/menu/menu_us.lgp).\nRole: The fallback if no mods provide an override.\nPART II: DEEP DIVE - TECHNICAL ANALYSIS & CONSTRAINTS\nThis section synthesizes the critical findings from your research and the FFNx codebase. Understanding these constraints is non-negotiable for a successful implementation.\n2.1. The Geometry vs. Texture Problem (\"Squashed Kanji\")\nThis is the single most important technical hurdle. Failure to address this will result in unreadable text.\nSymptom: You replaced an English character's texture with a full-width Kanji, but in-game, the Kanji was horizontally compressed, cropped, or \"squashed.\"\nRoot Cause: The FF7 engine separates geometry generation from texture mapping.\nGeometry Generation (FF7.exe): When the game needs to draw a character (e.g., 'i'), it looks up its width in a Character Width Table stored in memory. For 'i', this might be 4 pixels. It then generates a 3D quad (two triangles) that is exactly 4 pixels wide.\nTexture Mapping (FFNx): FFNx receives this pre-calculated 4-pixel-wide quad and is told to apply the font texture to it. It maps the full texture coordinates of the character's cell onto this tiny quad, resulting in severe compression.\nLocation of Width Table: Your research and the FFNx source confirm this table is pointed to by common_externals.font_info in src/ff7_data.h. For the US 1.02 executable, this address is 0x99DDA8.\nConclusion: Simply replacing the font texture is insufficient. We must also patch the game's memory to ensure it generates correctly-sized geometry for each character.\n2.2. The Texture Allocation & Palette System\nFFNx uses a system that mimics the PlayStation's palette-swapping capability to handle textures with multiple color variations. This is our key to implementing multi-page font support without a major renderer rewrite.\nThe Mechanism:\nA texture_set struct holds an array of GPU texture handles (texturehandle).\nThe game can request a switch to a different palette_index.\nFFNx intercepts this request in common_palette_changed (src/common.cpp) and binds the corresponding texture handle from the array.\nThe Constraint: The size of the texturehandle array is allocated based on the palettes value in the .TEX file's header. The English USFONT.TEX has palettes = 1, so FFNx allocates 2 slots by default (palettes * 2).\nThe Problem: If we try to load 6 textures for Japanese, we will cause a buffer overflow and crash the game because FFNx only allocated memory for 2.\nConclusion: We must intercept the allocation logic in common_load_texture and force it to allocate 6 slots when it detects the font texture, regardless of what the original file header says.\n2.3. The Registry Virtualization and Pathing\nThe 2013 Steam/eStore executables do not use the Windows Registry directly. They use wrapper functions (e.g., dotemuRegQueryValueExA) which FFNx provides fake implementations for.\nThe System: AF3DN.P (and FFNx) exports these dotemu functions. The game calls them to find its data paths.\nThe Risk: FFNx's current implementation in src/common.cpp returns paths for the English version (e.g., data/, movies/). Your research (AF3DN_ANALYSIS.md) shows ff7_ja.exe is hardcoded to look for language-specific paths like lang-ja/, menu_ja.lgp, and jfleve.lgp.\nConclusion: If we launch ff7_ja.exe with an unmodified FFNx, the registry hooks will feed it incorrect English paths, leading to asset loading failures and a likely crash. We must make these hooks language-aware.\nPART III: STEP-BY-STEP IMPLEMENTATION GUIDE\nThis is the core instruction set for the developer agent. Each step includes the objective, file locations, and detailed code-level instructions.\nStep 1: Implement User Configuration\nObjective: Create a toggle in FFNx.toml to enable Japanese mode, providing a clean entry point for all subsequent logic.\n1.1. src/cfg.h - Expose Global Variables\nAdd these declarations to make the settings accessible throughout the codebase.\ncode\nC++\n// src/cfg.h\n\n// ... after existing externs\nextern long external_music_volume;\nextern bool ff7_advanced_blinking;\nextern long display_index;\n\n// [NEW] Japanese Support Configuration\nextern std::string font_language;         // \"en\" or \"ja\"\nextern bool font_enable_furigana;         // true/false\nextern std::string font_path_override;    // Custom path for font textures\n1.2. src/cfg.cpp - Parse TOML Settings\nRegister the new variables and parse them from the TOML configuration file.\ncode\nC++\n// src/cfg.cpp\n\n// [NEW] Definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing parsing code ...\n\n    // [NEW] Font Configuration\n    // Default to \"en\" (English) to maintain backward compatibility\n    font_language = config[\"font_language\"].value_or(\"en\");\n    \n    // Enable Furigana (Ruby Text) support? Default false.\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    \n    // Allow manual override of the font folder (e.g., \"mods/Fonts/ja\")\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}```\n\n### **Step 2: Make Registry Hooks Language-Aware**\n\n**Objective:** Prevent `ff7_ja.exe` from crashing by providing it with the correct, language-specific file paths it expects.\n\n#### **2.1. `src/common.cpp` - Modify `dotemuRegQueryValueExA`**\nThis function is a virtual registry. We must teach it about Japanese file paths.\n\n```cpp\n// src/common.cpp\n\n__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)\n{\n    // ... function start ...\n\n    // [NEW] Add logic to detect the running executable\n    char exePath[MAX_PATH];\n    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n    _strlwr(exePath);\n    bool isJapaneseExe = (strstr(exePath, \"ff7_ja.exe\") != NULL);\n\n    /* FF7 */\n    // General\n    if (strcmp(lpValueName, \"AppPath\") == 0)\n    {\n        // ... existing logic is fine ...\n    }\n    else if (strcmp(lpValueName, \"DataPath\") == 0)\n    {\n        GetCurrentDirectory(*lpcbData, buf);\n        // [MODIFIED] Append language-specific path\n        if (isJapaneseExe) {\n            strcat(buf, R\"(\\data\\lang-ja\\)\");\n        } else {\n            strcat(buf, R\"(\\data\\)\");\n        }\n        strcpy((CHAR*)lpData, buf);\n    }\n    // ... repeat this pattern for \"MoviePath\", etc.\n    // ... ensure to check for \"jfleve.lgp\" vs \"flevel.lgp\" if that is queried here.\n    // ... existing logic ...\n\n    return ret;\n}\nStep 3: Force 6-Page Texture Allocation for Fonts\nObjective: Prevent a buffer overflow by ensuring FFNx allocates enough memory to hold 6 texture handles when the game loads its font.\n3.1. src/common.cpp - Modify common_load_texture\nThis is the most critical structural change.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)\n{\n    // ... variable declarations ...\n\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    if(!VREF(texture_set, ogl.gl_set))\n    {\n        // ... existing allocation of gl_set ...\n    }\n\n    // [NEW] Check if this is the font texture\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n    \n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures_to_alloc;\n\n        if (is_font_texture && font_language == \"ja\")\n        {\n            // [MODIFIED] Force allocation for 6 textures for Japanese font.\n            num_textures_to_alloc = 6;\n            ffnx_info(\"Japanese font detected. Forcing allocation for %d texture pages.\\n\", num_textures_to_alloc);\n        }\n        else \n        {\n            // [ORIGINAL LOGIC]\n            num_textures_to_alloc = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures_to_alloc);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(num_textures_to_alloc, sizeof(uint32_t)));\n        \n        // ... existing stats.texture_count++ etc. ...\n    }\n\n    // ... rest of the function ...\n    return _texture_set;\n}\nStep 4: Implement Multi-Texture Asset Loader\nObjective: When FFNx detects a request for the font, iterate from 0 to 5 and load jafont_1.png, jafont_2.png, etc., into their respective pre-allocated slots.\n4.1. src/saveload.cpp - Modify load_texture\nThis function orchestrates the external texture loading.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)\n{\n    // [NEW] Special handler for Japanese fonts\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char filename[sizeof(basedir) + 1024]{ 0 };\n        std::string base_path = !override_mod_path.empty() ? override_mod_path : mod_path;\n        uint32_t first_handle = 0;\n\n        for (int i = 0; i < 6; i++) {\n            // Construct the path for each font page, e.g., mods/Textures/menu/jafont_1.png\n            _snprintf(filename, sizeof(filename), \"%s/%s/%s_%d.png\", basedir, base_path.c_str(), \"jafont\", i + 1);\n            normalize_path(filename);\n            \n            uint32_t w, h;\n            uint32_t texture_handle = load_texture_helper(filename, &w, &h, true, true);\n            \n            if (texture_handle) {\n                // Manually inject this texture into the specific palette slot\n                // Slot 0 = jafont_1 (Basic Kana)\n                // Slot 1 = jafont_2 (Kanji A)\n                // ...\n                gl_replace_texture(texture_set, i, new_texture);\n                ffnx_info(\"Successfully loaded Japanese font page %d into memory from %s\\n\", i, filename);\n            } else {\n                ffnx_error(\"CRITICAL: Failed to load Japanese font page %d. Ensure file exists: %s\\n\", i, filename);\n            }\n        }\n        \n        // Return the handle for Page 0 (Default) so the game has something valid immediately\n        return VREF(texture_set, texturehandle[0]);\n    }\n\n    // ... original logic for animated and normal textures ...\n    uint32_t ret = 0;\n    // ...\n}\n```*Note: A small refactor of `gl_replace_texture` in `src/gl/texture.cpp` to take a `palette_index` would be cleaner than using `additional_textures`.*\n\n### **Step 5: Patch Character Width Table in Memory**\n\n**Objective:** Fix the \"squashed Kanji\" by overwriting the game's internal character width table with a fixed-width value suitable for Japanese.\n\n#### **5.1. Create `src/ff7/font.cpp` and `src/ff7/font.h`**\nIt's best to encapsulate font-specific logic.\n\n```cpp\n// src/ff7/font.h\n#pragma once\n#include \"../common.h\"\nvoid PatchFontWidthsForJapanese();\n\n// src/ff7/font.cpp\n#include \"font.h\"\n#include \"../globals.h\"\n#include \"../log.h\"\n\nvoid PatchFontWidthsForJapanese()\n{\n    if (font_language != \"ja\") {\n        return;\n    }\n\n    // This address is for US 1.02, needs to be confirmed for other versions if needed.\n    char* font_width_table = common_externals.font_info;\n\n    if (!font_width_table) {\n        ffnx_error(\"Could not find font width table in memory. Cannot patch for Japanese.\\n\");\n        return;\n    }\n\n    ffnx_info(\"Patching in-memory font width table for fixed-width Japanese characters...\\n\");\n\n    DWORD oldProtect;\n    if (VirtualProtect(font_width_table, 256, PAGE_READWRITE, &oldProtect))\n    {\n        for (int i = 0; i < 256; i++)\n        {\n            // The original game geometry is based on a 320x240 coordinate system.\n            // 16px is the standard width for a full-width character in that context.\n            font_width_table[i] = 16; \n            \n            // Refinement: You might want narrower widths for punctuation or ASCII \n            // if you map them to the first page.\n            if (i < 0x20) font_table[i] = 8; // Example for spaces/numbers\n        }\n        VirtualProtect(font_width_table, 256, oldProtect, &oldProtect);\n        ffnx_info(\"Font width table patched successfully.\\n\");\n    }\n    else\n    {\n        ffnx_error(\"Failed to change memory protection for font width table. Japanese text will be squashed.\\n\");\n    }\n}\n5.2. Call the patch from src/ff7_opengl.cpp\nIn ff7_init_hooks, after ff7_data(game_object);:\ncode\nC++\n// src/ff7_opengl.cpp\n#include \"ff7/font.h\" // Add this include\n\nvoid ff7_init_hooks(struct game_obj *_game_object)\n{\n    // ...\n    ff7_data(game_object);\n\n    // [NEW] Apply font patches if Japanese mode is enabled\n    PatchFontWidthsForJapanese();\n\n    // ... rest of the hooks\n}\nStep 6: Implement Text Parser Hook for Page Switching\nObjective: Intercept the game's text rendering loop to process our FA-FE page-switching codes. This requires an in-memory assembly patch.\n6.1. Add a Hext Patch File\nCreate a new file: misc/hext/ff7/en/FFNx.JAPANESE_FONT.txt\ncode\nHext\n# FFNx Japanese Font Support Patch\n# This hooks the character drawing loop to handle FA-FE page markers.\n# The target address needs to be found via debugger/disassembler.\n# For FF7.exe 1.02 US, this is inside the text drawing function.\n# Let's assume a hypothetical address for now: 0x6E9A00\n\n+0\n\n# We need a new global variable in FFNx's memory space to store the current page.\n# FFNx will need to expose a pointer to this variable. Let's assume FFNx creates\n# a `g_currentFontPage` at a known offset. For now, we'll use a placeholder.\n# Let's say FFNx's base is 0x10000000 and we reserve `+0x1234` for it.\n! This requires a C++ change to expose a global variable.\n\n0x6E9A00 =  CMP AL, 0xFA          ; Is the character code >= FA?\n            JB @@RenderNormal     ; If not, it's a standard character.\n            \n            ; It's a page marker.\n            SUB AL, 0xFA          ; Map FA->0, FB->1, etc.\n            INC AL                ; Shift to 1-5 range (0 is reserved for basic page)\n            MOV BYTE PTR [0x10001234], AL ; Store the new page index in our global variable\n            \n            ; Move to the next byte, which is the actual character index\n            MOV ESI, [EBP-0x10]   ; Assuming ESI holds the string pointer (this needs verification)\n            INC ESI\n            MOV [EBP-0x10], ESI\n            MOVZX EAX, BYTE PTR [ESI] ; Load the character index into EAX (AL)\n            \n            JMP @@DrawCharacter\n\n@@RenderNormal:\n            MOV BYTE PTR [0x10001234], 0 ; It's a normal character, so use page 0.\n\n@@DrawCharacter:\n            ; ... Here would be the original code that we overwrote, now executed after our logic.\n            ; This part needs to be carefully copied from the original executable.\n            ; For example: PUSH EAX, CALL SomeRenderFunc, etc.\n```**This Hext file is conceptual.** The exact address (`0x6E9A00`) and registers (`EBP-0x10`) must be found by reverse-engineering the text rendering loop of `ff7.exe`.\n\n#### **6.2. FFNx Side: Read the Page Index**\nFFNx needs to read the value written by the Hext patch.\n\n**In `src/globals.h`:**\n```cpp\n// Add a global variable for the current font page\nextern uint8_t g_currentFontPage;\nIn src/common.cpp:\ncode\nC++\nuint8_t g_currentFontPage = 0;\nIn src/gl/gl.cpp, inside gl_draw_indexed_primitive:\ncode\nC++\n// This function receives the geometry for a single character.\nvoid gl_draw_indexed_primitive(...)\n{\n    // ...\n    \n    // If we're drawing a font, and Japanese is enabled...\n    if (is_font_texture && font_language == \"ja\") {\n        \n        // Use the global page index set by our Hext patch\n        uint32_t palette_index = g_currentFontPage;\n        \n        // This is the CRITICAL part. Instead of using the game's requested palette,\n        // we force the texture set to use the one from our global variable.\n        VOBJ(texture_set, texture_set, current_state.texture_set);\n        VRASS(texture_set, palette_index, palette_index);\n        \n        // This will now select jafont_1, jafont_2, etc. correctly.\n        gl_bind_texture_set(current_state.texture_set);\n    }\n\n    // ... rest of the drawing logic ...\n}\nPART IV: FURIGANA SUPPORT (ADVANCED IMPLEMENTATION)\nGoal: Render small Hiragana text above Kanji. This requires a significant modification to the rendering and layout logic.\nConstraint: FF7 text boxes are 3 lines high with tight spacing. Furigana will clip.\n7.1. Data Format Extension\nWe must define a new control code for Furigana. Let's use 0xF9.\nFormat: {0xF9} [Kanji Char Index] [Furigana Char Index 1] [Furigana Char Index 2] ... {0x00}\nExample: \u79c1 (\u308f\u305f\u3057) would be 0xF9 0x81 0x41 0x42 0x43 0x00.\n7.2. Hext Patch for Furigana\nThe text rendering hook needs to be extended.\ncode\nAssembly\n; ... existing FA-FE check ...\n\nCMP AL, 0xF9\nJNE NotFurigana\n\n; Handle Furigana\nCALL FFNx_EnterFuriganaMode ; A function exported by FFNx.dll\n\n; Loop to draw Furigana characters (small and above)\nFuriganaLoop:\n    INC ESI\n    MOV AL, [ESI]\n    CMP AL, 0x00      ; End of Furigana string?\n    JE EndFurigana\n    ; ... code to call the draw function for the Furigana char ...\n    JMP FuriganaLoop\n\nEndFurigana:\nCALL FFNx_ExitFuriganaMode\nJMP NextChar\n\nNotFurigana:\n; ... existing logic ...\n7.3. FFNx Renderer Modification (gl_draw_indexed_primitive)\nFFNx needs to maintain a \"Furigana Mode\" state.\ncode\nC++\n// src/renderer.h\n// Add to Renderer class\nbool isFuriganaMode = false;\nvoid SetFuriganaMode(bool enabled);\n\n// src/renderer.cpp\nvoid Renderer::SetFuriganaMode(bool enabled) {\n    isFuriganaMode = enabled;\n}\n\n// src/gl/gl.cpp\nvoid gl_draw_indexed_primitive(...) {\n    \n    if (newRenderer.isFuriganaMode) {\n        // Modify the geometry before drawing\n        \n        // 1. Scale down the vertices\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.x *= 0.5f;\n            vertices[i]._.y *= 0.5f;\n        }\n        \n        // 2. Apply a Y-offset\n        // This value needs to be tuned.\n        float y_offset = -8.0f * newRenderer.getScalingFactor();\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.y += y_offset;\n        }\n    }\n    \n    // ... proceed with the normal draw call ...\n}\n7.4. Window Layout Patch (The Hardest Part)\nTo prevent Furigana from overlapping with the line above, we must increase the line height.\nTarget: The memory location that stores the value 16 (default line height).\nAction: Use a Hext patch to change this value to 24 or 32.\nConsequence: Text boxes will now fit fewer lines of text (e.g., 2 instead of 3). This is a necessary trade-off. The exact address must be found through reverse engineering ff7.exe.\nPART V: TESTING & VERIFICATION PROTOCOL\nUnit Test 1 (Red 'W'): Verify FFNx texture override works. Replace USFONT.PNG with a version where 'W' is a red Kanji. Confirm it appears in-game (even if squashed).\nUnit Test 2 (Width Patch): Apply the width table patch. Launch the game. All English text should now be widely spaced. The red 'W' Kanji should appear at its correct width.\nIntegration Test 1 (Multi-Texture Load): Enable Japanese mode. Check FFNx.log. Confirm that 6 jafont_*.png files are successfully loaded into memory.\nIntegration Test 2 (Page Switching): Manually patch a dialogue string in memory (using a debugger) to include 0xFA 0x00. When the dialogue appears, the game should display the '\u5fc5' character from jafont_2.\nFull System Test: Use a modified flevel.lgp (created with an extended touphScript) containing a fully Japanese-translated scene. Play through the scene and verify all text renders correctly.\nPART VI: FULL CODE REFERENCE & APPENDIX\n6.1 Code Block Index\nFeature    Primary File(s)    Key Function(s)/Struct(s)\nConfiguration    src/cfg.h, src/cfg.cpp    read_cfg()\nRegistry Hooks    src/common.cpp    dotemuRegQueryValueExA()\nTexture Allocation    src/common.cpp    common_load_texture()\nAsset Loading    src/saveload.cpp    load_external_texture(), load_texture_helper()\nWidth Table Patch    src/ff7/font.cpp    PatchFontWidthsForJapanese()\nParser Hook    misc/hext/ff7/en/    FFNx.JAPANESE_FONT.txt (to be created)\nRendering Logic    src/gl/gl.cpp    gl_draw_indexed_primitive()\nFurigana (Advanced)    src/renderer.h, src/gl/gl.cpp    SetFuriganaMode(), modified draw call\n6.2 Character Mapping Data (ff7_complete_mapping_compact.csv)\ncode\nCsv\ntexture,index,character,unicode\njafont_1,0,\u30d0,U+30D0\njafont_1,1,\u3070,U+3070\njafont_1,2,\u30d3,U+30D3\njafont_1,3,\u3073,U+3073\n... (Full 1331-line CSV content from your research file) ...\njafont_6,255,,\n(Self-correction: I will not paste the entire 1331-line CSV here to save space for more critical instructions, but the agent should be aware this file is the definitive source for Unicode-to-FF7-Index mapping.)\n6.3 AF3DN.P Analysis Summary\nKey takeaway: The Japanese eStore version proves that a multi-texture, page-switching system is the correct and production-viable architecture. It uses DirectX 9, MultiByteToWideChar for Shift-JIS to Unicode conversion, and relies on a custom driver to load 6 font textures (jafont_1.tim - jafont_6.tim).\nOur path: Reimplement this logic using FFNx's modern BGFX backend and its open-source, flexible architecture rather than using the proprietary, closed-source AF3DN.P directly. This ensures long-term maintainability and community ownership.\n6.4 Glossary\nFFNx Encoding: The custom 2-byte format (FA XX, FB XX, etc.) we are implementing, based on the system used in ff7_ja.exe.\nGlyph: The visual representation of a character.\nHext: A system for applying in-memory assembly patches to an executable at runtime.\nPalette Index: In FFNx, this is a numeric index that determines which texture handle from a texture_set's array to use for rendering. We are hijacking this system for font page switching.\nThis document provides a complete, top-to-bottom guide for implementing Japanese support. By following these steps, a developer AI agent can systematically modify the FFNx codebase and create the necessary game patches to achieve the project's goals. The key is to address the architectural constraints\u2014texture allocation, character width, and registry virtualization\u2014before tackling the text parsing logic.\nOf course. My apologies for the previous brevity. Your request for a comprehensive, deep-dive document is completely justified given the complexity of the project and the volume of information you've provided. I have now performed a full synthesis of your research findings and the FFNx codebase.\nThe following document is a master technical specification designed to serve as a complete onboarding guide for a developer AI agent. It assumes no prior knowledge and builds the necessary context from the ground up, culminating in a granular, step-by-step implementation plan with code-level details. It is designed to be exhaustive.\nFFNx Developer Onboarding Bible: Japanese Language Implementation\nDocument Version: 3.0 (Master Technical Specification)\nProject Codename: \"One-7 Language Learner Edition\"\nTarget Platform: FFNx Driver for Final Fantasy VII (1998/2013 PC)\nDate: 2025-11-20\nPART I: MISSION BRIEFING & STRATEGIC OVERVIEW\n1.1. Executive Summary\nThe Mission: To extend the FFNx graphics driver to enable full, native Japanese text rendering within the English PC version of Final Fantasy VII. This is the foundational step toward creating a multi-language learning tool, with future goals including real-time language toggling and Furigana (reading guide) support.\nThe Core Problem: The original English FF7 executable (ff7.exe) is architecturally limited to a single-byte character encoding system. It can only address a maximum of 256 unique characters, which are rendered from a single font texture (USFONT.TEX). This is sufficient for Latin-based languages but is mathematically incapable of supporting the ~2,300+ glyphs required for Japanese (Hiragana, Katakana, and Kanji).\nThe Breakthrough Discovery: Your research has uncovered and analyzed the rare 2013 Japanese eStore version of FF7. This version includes a custom graphics driver, AF3DN.P, which solves this exact problem. It uses a multi-texture system (6 font pages named jafont_1.tex through jafont_6.tex) and an extended character encoding system (using 0xFA-0xFE as page-switching opcodes). We now have a production-proven architectural blueprint.\nThe Strategy (Path C - Hybrid FFNx Extension): We will not use the proprietary AF3DN.P directly. Instead, we will reimplement its core logic within the open-source FFNx driver. This approach is legally sound, community-friendly, and leverages FFNx's modern rendering backend (BGFX) for superior performance and future extensibility. This document outlines the precise, code-level steps required to achieve this.\n1.2. Key Terminology & Concepts\nFFNx: A modern, open-source graphics driver for FF7/FF8 that replaces the original game's driver. It provides advanced features like high-resolution rendering, texture replacement, and a modding API. It is our primary development target.\n7th Heaven: A mod manager for FF7. It acts as a virtual file system, intercepting the game's file requests and feeding it modded assets from .iro archives. It is the primary distribution platform for this project.\nLGP Archive (.lgp): Square Enix's proprietary archive format, akin to a .zip file. Game assets like textures, models, and dialogue are packed inside.\nTEX Texture (.tex): A bitmap image format used by the FF7 PC port, derived from the PlayStation's TIM format.\nFF Text Encoding: The game's internal single-byte text format. Character codes are mapped to positions on the font texture.\nFA-FE Page Markers: The custom 2-byte encoding system used by the Japanese version. The first byte (0xFA to 0xFE) selects one of the five extended font textures, and the second byte is the character's index within that texture.\nCharacter Width Table: A data table located in the game's memory (originally from KERNEL.BIN/WINDOW.BIN) that defines the pixel width of every character. This is the source of the \"squashed Kanji\" problem and a critical target for patching.\n1.3. Architectural Load Order (The \"Layer Cake\")\nUnderstanding how assets are loaded is critical. The first asset found in this hierarchy wins:\nLayer 1 (Top Priority): FFNx mods/ Folder\nMechanism: Loose files on the hard drive (e.g., mods/Textures/menu/usfont_h.png). FFNx checks this folder first.\nRole: Used for rapid prototyping, testing, and user-level overrides. This is where your successful \"Red Text Test\" operated.\nLayer 2: 7th Heaven IROs\nMechanism: A Virtual File System (VFS). 7th Heaven intercepts the game's API calls to read files from disk. If a mod in an .iro archive provides a replacement file, 7th Heaven feeds that file's data to the game instead of the one on the hard drive.\nRole: The primary distribution method for mods. It handles models, dialogue, audio, and textures.\nLayer 3 (Bottom Priority): Vanilla Game Data\nMechanism: The original game files on the hard drive (e.g., data/menu/menu_us.lgp).\nRole: The fallback if no mods provide an override.\nPART II: DEEP DIVE - TECHNICAL ANALYSIS & CONSTRAINTS\nThis section synthesizes the critical findings from your research and the FFNx codebase. Understanding these constraints is non-negotiable for a successful implementation.\n2.1. The Geometry vs. Texture Problem (\"Squashed Kanji\")\nThis is the single most important technical hurdle. Failure to address this will result in unreadable text.\nSymptom: You replaced an English character's texture with a full-width Kanji, but in-game, the Kanji was horizontally compressed, cropped, or \"squashed.\"\nRoot Cause: The FF7 engine separates geometry generation from texture mapping.\nGeometry Generation (FF7.exe): When the game needs to draw a character (e.g., 'i'), it looks up its width in a Character Width Table stored in memory. For 'i', this might be 4 pixels. It then generates a 3D quad (two triangles) that is exactly 4 pixels wide.\nTexture Mapping (FFNx): FFNx receives this pre-calculated 4-pixel-wide quad and is told to apply the font texture to it. It maps the full texture coordinates of the character's cell onto this tiny quad, resulting in severe compression.\nLocation of Width Table: Your research and the FFNx source confirm this table is pointed to by common_externals.font_info in src/ff7_data.h. For the US 1.02 executable, this address is 0x99DDA8.\nConclusion: Simply replacing the font texture is insufficient. We must also patch the game's memory to ensure it generates correctly-sized geometry for each character.\n2.2. The Texture Allocation & Palette System\nFFNx uses a system that mimics the PlayStation's palette-swapping capability to handle textures with multiple color variations. This is our key to implementing multi-page font support without a major renderer rewrite.\nThe Mechanism:\nA texture_set struct holds an array of GPU texture handles (texturehandle).\nThe game can request a switch to a different palette_index.\nFFNx intercepts this request in common_palette_changed (src/common.cpp) and binds the corresponding texture handle from the array.\nThe Constraint: The size of the texturehandle array is allocated based on the palettes value in the .TEX file's header. The English USFONT.TEX has palettes = 1, so FFNx allocates 2 slots by default (palettes * 2).\nThe Problem: If we try to load 6 textures for Japanese, we will cause a buffer overflow and crash the game because FFNx only allocated memory for 2.\nConclusion: We must intercept the allocation logic in common_load_texture and force it to allocate 6 slots when it detects the font texture, regardless of what the original file header says.\n2.3. The Registry Virtualization and Pathing\nThe 2013 Steam/eStore executables do not use the Windows Registry directly. They use wrapper functions (e.g., dotemuRegQueryValueExA) which FFNx provides fake implementations for.\nThe System: AF3DN.P (and FFNx) exports these dotemu functions. The game calls them to find its data paths.\nThe Risk: FFNx's current implementation in src/common.cpp returns paths for the English version (e.g., data/, movies/). Your research (AF3DN_ANALYSIS.md) shows ff7_ja.exe is hardcoded to look for language-specific paths like lang-ja/, menu_ja.lgp, and jfleve.lgp.\nConclusion: If we launch ff7_ja.exe with an unmodified FFNx, the registry hooks will feed it incorrect English paths, leading to asset loading failures and a likely crash. We must make these hooks language-aware.\nPART III: STEP-BY-STEP IMPLEMENTATION GUIDE\nThis is the core instruction set for the developer agent. Each step includes the objective, file locations, and detailed code-level instructions.\nStep 1: Implement User Configuration\nObjective: Create a toggle in FFNx.toml to enable Japanese mode, providing a clean entry point for all subsequent logic.\n1.1. src/cfg.h - Expose Global Variables\nAdd these declarations to make the settings accessible throughout the codebase.\ncode\nC++\n// src/cfg.h\n\n// ... after existing externs\nextern std::string font_language;\nextern bool font_enable_furigana;\nextern std::string font_path_override;\n1.2. src/cfg.cpp - Parse TOML Settings\nAdd logic to read_cfg() to load the values.\ncode\nC++\n// src/cfg.cpp\n\n// At top of file with other definitions\nstd::string font_language;\nbool font_enable_furigana;\nstd::string font_path_override;\n\nvoid read_cfg()\n{\n    // ... existing toml::parse_file logic ...\n\n    // At the end of the function, before \"SAFE DEFAULTS\"\n    font_language = config[\"font_language\"].value_or(\"en\");\n    font_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\n    font_path_override = config[\"font_path_override\"].value_or(\"\");\n}\nStep 2: Make Registry Hooks Language-Aware\nObjective: Prevent ff7_ja.exe from crashing by providing it with the correct, language-specific file paths it expects.\n2.1. src/common.cpp - Modify dotemuRegQueryValueExA\nThis function is a virtual registry. We must teach it about Japanese file paths.\ncode\nC++\n// src/common.cpp\n\n__declspec(dllexport) LSTATUS __stdcall dotemuRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)\n{\n    // ... function start ...\n\n    // [NEW] Add logic to detect the running executable\n    char exePath[MAX_PATH];\n    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n    _strlwr(exePath);\n    bool isJapaneseExe = (strstr(exePath, \"ff7_ja.exe\") != NULL);\n\n    /* FF7 */\n    // General\n    if (strcmp(lpValueName, \"AppPath\") == 0)\n    {\n        // ... existing logic is fine ...\n    }\n    else if (strcmp(lpValueName, \"DataPath\") == 0)\n    {\n        GetCurrentDirectory(*lpcbData, buf);\n        // [MODIFIED] Append language-specific path\n        if (isJapaneseExe) {\n            strcat(buf, R\"(\\data\\lang-ja\\)\");\n        } else {\n            strcat(buf, R\"(\\data\\)\");\n        }\n        strcpy((CHAR*)lpData, buf);\n    }\n    // ... repeat this pattern for \"MoviePath\", etc.\n    // ... ensure to check for \"jfleve.lgp\" vs \"flevel.lgp\" if that is queried here.\n    // ... existing logic ...\n\n    return ret;\n}\nStep 3: Force 6-Page Texture Allocation for Fonts\nObjective: Prevent a buffer overflow by ensuring FFNx allocates enough memory to hold 6 texture handles when the game loads its font.\n3.1. src/common.cpp - Modify common_load_texture\nThis is the most critical structural change.\ncode\nC++\n// src/common.cpp\n\nstruct texture_set *common_load_texture(struct texture_set *_texture_set, struct tex_header *_tex_header, struct texture_format *texture_format)\n{\n    // ... variable declarations ...\n\n    if (!VPTR(texture_set))\n    {\n        _texture_set = common_externals.create_texture_set();\n        VASS(texture_set, texture_set, _texture_set);\n    }\n\n    if(!VREF(texture_set, ogl.gl_set))\n    {\n        // ... existing allocation of gl_set ...\n    }\n\n    // [NEW] Check if this is the font texture\n    bool is_font_texture = false;\n    if (VREF(tex_header, file.pc_name)) {\n        if (strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\")) {\n            is_font_texture = true;\n        }\n    }\n    \n    if(!VREF(texture_set, texturehandle))\n    {\n        uint32_t num_textures_to_alloc;\n\n        if (is_font_texture && font_language == \"ja\")\n        {\n            // [MODIFIED] Force allocation for 6 textures for Japanese font.\n            num_textures_to_alloc = 6;\n            ffnx_info(\"Japanese font detected. Forcing allocation for %d texture pages.\\n\", num_textures_to_alloc);\n        }\n        else \n        {\n            // [ORIGINAL LOGIC]\n            num_textures_to_alloc = VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1;\n        }\n\n        VRASS(texture_set, ogl.gl_set->textures, num_textures_to_alloc);\n        VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(num_textures_to_alloc, sizeof(uint32_t)));\n        \n        // ... existing stats.texture_count++ etc. ...\n    }\n\n    // ... rest of the function ...\n    return _texture_set;\n}\nStep 4: Implement Multi-Texture Asset Loader\nObjective: When FFNx detects a request for the font, iterate from 0 to 5 and load jafont_1.png, jafont_2.png, etc., into their respective pre-allocated slots.\n4.1. src/saveload.cpp - Modify load_texture\nThis function orchestrates the external texture loading.\ncode\nC++\n// src/saveload.cpp\n\nuint32_t load_texture(const void* data, uint32_t dataSize, const char* name, uint32_t palette_index, uint32_t* width, uint32_t* height, struct gl_texture_set* gl_set)\n{\n    // [NEW] Special handler for Japanese fonts\n    if (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\")))\n    {\n        char filename[sizeof(basedir) + 1024]{ 0 };\n        std::string base_path = !override_mod_path.empty() ? override_mod_path : mod_path;\n        uint32_t first_handle = 0;\n\n        for (int i = 0; i < 6; i++) {\n            // Construct the path for each font page, e.g., mods/Textures/menu/jafont_1.png\n            _snprintf(filename, sizeof(filename), \"%s/%s/%s_%d.png\", basedir, base_path.c_str(), \"jafont\", i + 1);\n            normalize_path(filename);\n            \n            uint32_t w, h;\n            uint32_t texture_handle = load_texture_helper(filename, &w, &h, true, true);\n            \n            if (texture_handle) {\n                // Manually assign the loaded texture to its correct \"palette\" index\n                gl_set->additional_textures[i] = texture_handle; // A bit of a hack, but should work. A better way would be to modify gl_replace_texture to accept an index.\n                if (i == 0) first_handle = texture_handle;\n                ffnx_info(\"Successfully loaded Japanese font page %d into memory from %s\\n\", i, filename);\n            } else {\n                ffnx_error(\"CRITICAL: Failed to load Japanese font page %d. Ensure file exists: %s\\n\", i, filename);\n            }\n        }\n\n        // Return the first handle as the \"main\" texture. The others are now cached.\n        return first_handle;\n    }\n\n    // ... original logic for animated and normal textures ...\n    uint32_t ret = 0;\n    // ...\n}\nNote: A small refactor of gl_replace_texture in src/gl/texture.cpp to take a palette_index would be cleaner than using additional_textures.\nStep 5: Patch Character Width Table in Memory\nObjective: Fix the \"squashed Kanji\" by overwriting the game's internal character width table with a fixed-width value suitable for Japanese.\n5.1. Create src/ff7/font.cpp and src/ff7/font.h\nIt's best to encapsulate font-specific logic.\ncode\nC++\n// src/ff7/font.h\n#pragma once\n#include \"../common.h\"\nvoid PatchFontWidthsForJapanese();\n\n// src/ff7/font.cpp\n#include \"font.h\"\n#include \"../globals.h\"\n#include \"../log.h\"\n\nvoid PatchFontWidthsForJapanese()\n{\n    if (font_language != \"ja\") {\n        return;\n    }\n\n    // This address is for US 1.02, needs to be confirmed for other versions if needed.\n    char* font_width_table = common_externals.font_info;\n\n    if (!font_width_table) {\n        ffnx_error(\"Could not find font width table in memory. Cannot patch for Japanese.\\n\");\n        return;\n    }\n\n    ffnx_info(\"Patching in-memory font width table for fixed-width Japanese characters...\\n\");\n\n    DWORD oldProtect;\n    if (VirtualProtect(font_width_table, 256, PAGE_READWRITE, &oldProtect))\n    {\n        for (int i = 0; i < 256; i++)\n        {\n            // The original game geometry is based on a 320x240 coordinate system.\n            // 16px is the standard width for a full-width character in that context.\n            font_width_table[i] = 16;\n        }\n        VirtualProtect(font_width_table, 256, oldProtect, &oldProtect);\n        ffnx_info(\"Font width table patched successfully.\\n\");\n    }\n    else\n    {\n        ffnx_error(\"Failed to change memory protection for font width table. Japanese text will be squashed.\\n\");\n    }\n}\n5.2. Call the patch from src/ff7_opengl.cpp\nIn ff7_init_hooks, after ff7_data(game_object);:\ncode\nC++\n// src/ff7_opengl.cpp\n#include \"ff7/font.h\" // Add this include\n\nvoid ff7_init_hooks(struct game_obj *_game_object)\n{\n    // ...\n    ff7_data(game_object);\n\n    // [NEW] Apply font patches if Japanese mode is enabled\n    PatchFontWidthsForJapanese();\n\n    // ... rest of the hooks\n}\nStep 6: Implement Text Parser Hook for Page Switching\nObjective: Intercept the game's text rendering loop to process our FA-FE page-switching codes. This requires an in-memory assembly patch.\n6.1. Add a Hext Patch File\nCreate a new file: misc/hext/ff7/en/FFNx.JAPANESE_FONT.txt\ncode\nHext\n# FFNx Japanese Font Support Patch\n# This hooks the character drawing loop to handle FA-FE page markers.\n# The target address needs to be found via debugger/disassembler.\n# For FF7.exe 1.02 US, this is inside the text drawing function.\n# Let's assume a hypothetical address for now: 0x6E9A00\n\n+0\n\n# We need a new global variable in FFNx's memory space to store the current page.\n# FFNx will need to expose a pointer to this variable. Let's assume FFNx creates\n# a `g_currentFontPage` at a known offset. For now, we'll use a placeholder.\n# Let's say FFNx's base is 0x10000000 and we reserve `+0x1234` for it.\n! This requires a C++ change to expose a global variable.\n\n0x6E9A00 =  CMP AL, 0xFA          ; Is the character code >= FA?\n            JB @@RenderNormal     ; If not, it's a standard character.\n            \n            ; It's a page marker.\n            SUB AL, 0xFA          ; Map FA->0, FB->1, etc.\n            INC AL                ; Map to page index 1-5\n            MOV BYTE PTR [0x10001234], AL ; Store the new page index in our global variable\n            \n            ; Move to the next byte, which is the actual character index\n            MOV ESI, [EBP-0x10]   ; Assuming ESI holds the string pointer (this needs verification)\n            INC ESI\n            MOV [EBP-0x10], ESI\n            MOVZX EAX, BYTE PTR [ESI] ; Load the character index into EAX (AL)\n            \n            JMP @@DrawCharacter\n\n@@RenderNormal:\n            MOV BYTE PTR [0x10001234], 0 ; It's a normal character, so use page 0.\n\n@@DrawCharacter:\n            ; ... Here would be the original code that we overwrote, now executed after our logic.\n            ; This part needs to be carefully copied from the original executable.\n            ; For example: PUSH EAX, CALL SomeRenderFunc, etc.\n```**This Hext file is conceptual.** The exact address (`0x6E9A00`) and registers (`EBP-0x10`) must be found by reverse-engineering the text rendering loop of `ff7.exe`.\n\n#### **6.2. FFNx Side: Read the Page Index**\nFFNx needs to read the value written by the Hext patch.\n\n**In `src/globals.h`:**\n```cpp\n// Add a global variable for the current font page\nextern uint8_t g_currentFontPage;\nIn src/common.cpp:\ncode\nC++\nuint8_t g_currentFontPage = 0;\nIn src/gl/gl.cpp, inside gl_draw_indexed_primitive:\ncode\nC++\n// This function receives the geometry for a single character.\nvoid gl_draw_indexed_primitive(...)\n{\n    // ...\n    \n    // If we're drawing a font, and Japanese is enabled...\n    if (is_font_texture && font_language == \"ja\") {\n        \n        // Use the global page index set by our Hext patch\n        uint32_t palette_index = g_currentFontPage;\n        \n        // This is the CRITICAL part. Instead of using the game's requested palette,\n        // we force the texture set to use the one from our global variable.\n        VOBJ(texture_set, texture_set, current_state.texture_set);\n        VRASS(texture_set, palette_index, palette_index);\n        \n        // This will now select jafont_1, jafont_2, etc. correctly.\n        gl_bind_texture_set(current_state.texture_set);\n    }\n\n    // ... rest of the drawing logic ...\n}\nPART IV: FURIGANA SUPPORT (ADVANCED IMPLEMENTATION)\nGoal: Render small Hiragana text above Kanji. This requires a significant modification to the rendering and layout logic.\n7.1. Data Format Extension\nWe must define a new control code for Furigana. Let's use 0xF9.\nFormat: {0xF9} [Kanji Char Index] [Furigana Char Index 1] [Furigana Char Index 2] ... {0x00}\nExample: \u79c1 (\u308f\u305f\u3057) would be 0xF9 0x81 0x41 0x42 0x43 0x00.\n7.2. Hext Patch for Furigana\nThe text rendering hook needs to be extended.\ncode\nAssembly\n; ... existing FA-FE check ...\n\nCMP AL, 0xF9\nJNE NotFurigana\n\n; Handle Furigana\nCALL FFNx_EnterFuriganaMode ; A function exported by FFNx.dll\n\n; Loop to draw Furigana characters (small and above)\nFuriganaLoop:\n    INC ESI\n    MOV AL, [ESI]\n    CMP AL, 0x00      ; End of Furigana string?\n    JE EndFurigana\n    ; ... code to call the draw function for the Furigana char ...\n    JMP FuriganaLoop\n\nEndFurigana:\nCALL FFNx_ExitFuriganaMode\nJMP NextChar\n\nNotFurigana:\n; ... existing logic ...\n7.3. FFNx Renderer Modification (gl_draw_indexed_primitive)\nFFNx needs to maintain a \"Furigana Mode\" state.\ncode\nC++\n// src/renderer.h\n// Add to Renderer class\nbool isFuriganaMode = false;\nvoid SetFuriganaMode(bool enabled);\n\n// src/renderer.cpp\nvoid Renderer::SetFuriganaMode(bool enabled) {\n    isFuriganaMode = enabled;\n}\n\n// src/gl/gl.cpp\nvoid gl_draw_indexed_primitive(...) {\n    \n    if (newRenderer.isFuriganaMode) {\n        // Modify the geometry before drawing\n        \n        // 1. Scale down the vertices\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.x *= 0.5f;\n            vertices[i]._.y *= 0.5f;\n        }\n        \n        // 2. Apply a Y-offset\n        // This value needs to be tuned.\n        float y_offset = -8.0f * newRenderer.getScalingFactor();\n        for (int i = 0; i < vertexcount; i++) {\n            vertices[i]._.y += y_offset;\n        }\n    }\n    \n    // ... proceed with the normal draw call ...\n}\n7.4. Window Layout Patch (The Hardest Part)\nTo prevent Furigana from overlapping with the line above, we must increase the line height.\nTarget: The memory location that stores the value 16 (default line height).\nAction: Use a Hext patch to change this value to 24 or 32.\nConsequence: Text boxes will now fit fewer lines of text (e.g., 2 instead of 3). This is a necessary trade-off. The exact address must be found through reverse engineering ff7.exe.\nPART V: TESTING & VERIFICATION PLAN\nUnit Test 1 (Red 'W'): Verify FFNx texture override works. Replace USFONT.PNG with a version where 'W' is a red Kanji. Confirm it appears in-game (even if squashed).\nUnit Test 2 (Width Patch): Apply the width table patch. Launch the game. All English text should now be widely spaced. The red 'W' Kanji should appear at its correct width.\nIntegration Test 1 (Multi-Texture Load): Enable Japanese mode. Check FFNx.log. Confirm that 6 jafont_*.png files are successfully loaded into memory.\nIntegration Test 2 (Page Switching): Manually patch a dialogue string in memory (using a debugger) to include 0xFA 0x00. When the dialogue appears, the game should display the '\u5fc5' character from jafont_2.\nFull System Test: Use a modified flevel.lgp (created with an extended touphScript) containing a fully Japanese-translated scene. Play through the scene and verify all text renders correctly.\nThis document provides a complete, top-to-bottom guide for implementing Japanese support. By following these steps, a developer AI agent can systematically modify the FFNx codebase and create the necessary game patches to achieve the project's goals. The key is to address the architectural constraints\u2014texture allocation, character width, and registry virtualization\u2014before tackling the text parsing logic.\nModel\nThinkingThoughts\nExpand to view model thoughts\n\nchevron_right\nHere is the FFNx Japanese Implementation Bible.\nThis document synthesizes every file, memory address, architectural discovery, and codebase constraint from your research sessions into a single, executable specification. It is designed to be pasted directly into a Developer AI Agent to provide total context and a step-by-step execution path without needing external reference.\nFFNX_JAPANESE_IMPLEMENTATION_BIBLE.md\nProject: Final Fantasy VII (PC) - Native Japanese Text Rendering & Multi-Language Architecture\nTarget Platform: FFNx Graphics Driver (Open Source / C++ / BGFX)\nTarget Executables: FF7_EN.EXE (v1.02 US), FF7_JA.EXE (2013 eStore), Steam Release\nDocument Version: 3.0 (Final Architectural Specification)\n1. EXECUTIVE TECHNICAL BRIEFING\n1.1 The Architectural Deficit\nThe vanilla English Final Fantasy VII engine uses a Single-Byte Character Encoding system. It interprets bytes 0x00-0xFF as indices pointing to a single 256x256 font texture (USFONT.TEX).\nConstraint: 256 slots < ~2,300 characters required for Japanese (Kanji/Hiragana/Katakana).\nFailure Mode: Feeding Shift-JIS or multi-byte data to the English engine results in it rendering two garbage Latin characters instead of one Kanji.\n1.2 The \"AF3DN\" Solution (Reference Architecture)\nReverse engineering of the Japanese eStore driver (AF3DN.P) reveals that Square Enix solved this without recompiling the core game logic by using an Extended Texture Paging System:\nAssets: Six high-resolution texture pages (jafont_1 through jafont_6) are loaded into memory.\nEncoding: Unused control codes (0xFA - 0xFE) are repurposed as Page Switching Opcodes.\n0xFA: Switch to Page 1 (Kanji Set A)\n0xFB: Switch to Page 2 (Kanji Set B)\n...and so on.\nRenderer: The driver intercepts these codes during the draw call and hot-swaps the texture source.\n1.3 The FFNx Implementation Strategy (Path C)\nWe will reimplement this architecture within FFNx. We will NOT replace the game executable. We will extend FFNx to:\nForce Allocate video memory for 6 font textures (overriding the game's request for 1).\nHook the game's text parser in assembly to detect FA-FE codes and update a state variable.\nIntercept the BGFX render call to bind the correct texture page based on that state variable.\nPatch the in-memory geometry tables to fix character width issues.\n2. DATA SPECIFICATIONS & ASSET MANIFEST\nThe Developer Agent must assume the following assets are present in mods/Textures/menu/:\nFilename    Encoding Range    Content    Grid Layout\njafont_1.png    0x00 - 0xE6    Hiragana, Katakana, Numbers, ASCII    16x16 Grid (64px Glyphs)\njafont_2.png    0xFA + Index    Kanji Set A (Battle/Skill Terms)    16x16 Grid\njafont_3.png    0xFB + Index    Kanji Set B    16x16 Grid\njafont_4.png    0xFC + Index    Kanji Set C    16x16 Grid\njafont_5.png    0xFD + Index    Kanji Set D    16x16 Grid\njafont_6.png    0xFE + Index    Kanji Set E    16x16 Grid\nGlobal Mapping Table: A CSV character_tables/character_map_accurate.csv exists mapping every Unicode character to its specific {Page, Index} coordinate.\n3. C++ CODEBASE MODIFICATIONS\nYou are authorized to modify the following files in src/.\n3.1 Configuration Extensions (src/cfg.cpp, src/cfg.h)\nWe need a global toggle to enable this behavior without breaking the game for English users.\nIn src/cfg.h:\ncode\nC++\n// Add to externs\nextern std::string font_language;       // \"en\", \"ja\"\nextern bool font_enable_furigana;       // Enable Ruby Text logic\nextern std::string font_path_override;  // Custom path for font textures\nextern bool is_using_japanese_exe;      // Runtime detection flag for ff7_ja.exe\nIn src/cfg.cpp (inside read_cfg):\ncode\nC++\n// Parse from FFNx.toml\nfont_language = config[\"font_language\"].value_or(\"en\");\nfont_enable_furigana = config[\"font_enable_furigana\"].value_or(false);\nfont_path_override = config[\"font_path_override\"].value_or(\"\");\n3.2 Registry Virtualization Fix (src/common.cpp)\nContext: If the user runs ff7_ja.exe, it requests registry keys that don't exist on non-Japanese Windows. FFNx mocks these keys but currently returns English paths (data/), causing a crash.\nImplementation:\nModify dotemuRegQueryValueExA:\nDetect the host process via GetModuleFileNameA. If ff7_ja.exe, set is_using_japanese_exe = true.\nInside the switch statement for lpValueName:\ncode\nC++\nif (is_using_japanese_exe) {\n    if (strcmp(lpValueName, \"DataPath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/\"); // CORRECT PATH\n        return ERROR_SUCCESS;\n    }\n    if (strcmp(lpValueName, \"MoviePath\") == 0) {\n        strcpy((CHAR*)lpData, \"data/lang-ja/movies/\"); // CORRECT PATH\n        return ERROR_SUCCESS;\n    }\n}\n3.3 Texture Allocation Override (src/common.cpp)\nContext: common_load_texture allocates memory for texture handles based on the file header. USFONT.TEX header says \"1 Palette\". FFNx allocates 2 slots (1 * 2). We need 6.\nRisk: Buffer Overflow if not patched.\nImplementation:\nInside common_load_texture (approx line 1450), intercept the allocation:\ncode\nC++\n// Detect font file\nbool is_font = strstr(VREF(tex_header, file.pc_name), \"usfont\") || strstr(VREF(tex_header, file.pc_name), \"jafont\");\n\nif (is_font && font_language == \"ja\") {\n    // FORCE 6 SLOTS\n    VRASS(texture_set, ogl.gl_set->textures, 6);\n    VRASS(texture_set, texturehandle, (uint32_t*)external_calloc(6, sizeof(uint32_t)));\n    ffnx_info(\"Japanese Font: Forced 6-page texture allocation.\\n\");\n} else {\n    // STANDARD BEHAVIOR\n    VRASS(texture_set, ogl.gl_set->textures, VREF(tex_header, palettes) > 0 ? VREF(tex_header, palettes) * 2 : 1);\n    // ... standard alloc\n}\n3.4 Multi-Page Texture Loader (src/saveload.cpp)\nContext: When the game requests the font, we must immediately load all 6 external PNGs into the slots allocated above.\nImplementation:\nInside load_external_texture:\ncode\nC++\nif (font_language == \"ja\" && (strstr(name, \"usfont\") || strstr(name, \"jafont\"))) {\n    std::string path = font_path_override.empty() ? mod_path + \"/menu/\" : font_path_override;\n    \n    // Iterate 0-5 (Pages 1-6)\n    for (int i = 0; i < 6; i++) {\n        char filename[1024];\n        // Note: Files are 1-indexed (jafont_1), array is 0-indexed\n        _snprintf(filename, sizeof(filename), \"%sjafont_%d.png\", path.c_str(), i + 1);\n        normalize_path(filename);\n        \n        uint32_t w, h;\n        uint32_t handle = load_texture_helper(filename, &w, &h, true, true);\n        \n        if (handle) {\n            // Inject into slot 'i'\n            gl_replace_texture(texture_set, i, handle);\n        } else {\n            ffnx_error(\"MISSING ASSET: %s\\n\", filename);\n        }\n    }\n    // Return Page 0 handle to satisfy the game engine\n    return VREF(texture_set, texturehandle[0]);\n}\n3.5 The \"JFLEVE\" Redirection (src/redirect.cpp)\nContext: Research discovered a typo in the Japanese file structure. The field archive is named jfleve.lgp (missing 'l'), whereas English is flevel.lgp. FFNx must handle this redirection transparently.\nImplementation:\nInside attempt_redirection:\ncode\nC++\nif (font_language == \"ja\" && strstr(in, \"flevel.lgp\")) {\n    std::string ja_path = std::string(in);\n    replaceOnce(ja_path, \"flevel.lgp\", \"jfleve.lgp\"); \n    if (fileExists(ja_path.c_str())) {\n        strcpy(out, ja_path.c_str());\n        return 0; // Found redirected file\n    }\n}\n3.6 Geometry Width Patch (src/ff7/menu.cpp)\nContext: The \"Squashed Kanji\" Fix. The game reads character widths from a table in RAM (KERNEL.BIN data). English widths are 8-12px. Kanji requires 16px. If unpatched, the game generates 8px wide quads, crushing the 64px high-res Kanji texture.\nImplementation:\nCreate PatchJapaneseWidths():\ncode\nC++\nvoid PatchJapaneseWidths() {\n    if (font_language != \"ja\") return;\n    \n    // Address: 0x99DDA8 (US 1.02) - Pointed to by common_externals.font_info\n    char* width_table = common_externals.font_info;\n    if (!width_table) return;\n\n    DWORD oldProtect;\n    VirtualProtect(width_table, 256, PAGE_READWRITE, &oldProtect);\n\n    // Overwrite widths for printable characters\n    for (int i = 0x20; i <= 0xFF; i++) {\n        width_table[i] = 0x10; // Force 16px width\n    }\n    \n    VirtualProtect(width_table, 256, oldProtect, &oldProtect);\n}\nCall this in src/ff7_opengl.cpp -> ff7_init_hooks.\n4. ASSEMBLY HOOKS & RENDERER STATE\nWe need to link the Game Logic (ASM) to the FFNx C++ Renderer via a shared state variable.\n4.1 Shared State (src/globals.h / src/common.cpp)\nDefine a global variable reachable by both C++ and the Assembly Hext patch.\ncode\nC++\n// src/globals.h\nextern uint8_t g_currentFontPage; \n\n// src/common.cpp\nuint8_t g_currentFontPage = 0;\n// Note: You may need to expose the ADDRESS of this variable to the Hext patch dynamically\n// or pick a safe static memory address if FFNx memory is randomized.\n4.2 Hext Assembly Patch (misc/hext/ff7/en/jp_font.txt)\nTarget: The text character processing loop in FF7.EXE.\nLogic:\ncode\nAssembly\n# Pseudo-code logic for the patch\nCMP AL, 0xFA        ; Is char >= FA?\nJB NormalChar\n\n; Handle Page Switch\nSUB AL, 0xFA        ; Map FA->0, FB->1...\nINC AL              ; Shift to 1-5\nMOV [g_currentFontPage], AL ; Update global state\nINC ESI             ; Skip the marker byte\nMOV AL, [ESI]       ; Load actual char index\nJMP ProcessChar\n\nNormalChar:\nMOV [g_currentFontPage], 0 ; Reset to Page 0\n\nProcessChar:\n; ... original draw call ...\n4.3 Renderer Binding Logic (src/gl/gl.cpp)\nContext: FFNx binds textures right before drawing. We must intercept this to read g_currentFontPage and swap the texture handle.\nImplementation:\nInside gl_bind_texture_set:\ncode\nC++\nvoid gl_bind_texture_set(struct texture_set *_texture_set) {\n    // ...\n    \n    // [NEW] Dynamic Page Binding\n    if (font_language == \"ja\" && is_font_texture(_texture_set)) {\n        uint32_t page_index = g_currentFontPage; // Read from ASM hook\n        \n        // Force the texture set to use the handle for the current page\n        // We bypass the 'palette_index' passed by the game engine\n        VOBJ(texture_set, texture_set, _texture_set);\n        VRASS(texture_set, palette_index, page_index);\n        \n        // Bind the specific texture handle for this page\n        gl_set_texture(VREF(texture_set, texturehandle[page_index]), gl_set);\n        \n        // Skip standard logic\n        return;\n    }\n    \n    // ... existing logic ...\n}\n5. FURIGANA IMPLEMENTATION (PHASE 2)\nObjective: Render small reading guides above Kanji.\nConstraint: Text boxes are fixed height (3 lines, 16px each). Furigana will clip into the line above.\n5.1 The Geometry Hack\nOpcode: Define 0xF9 as the Furigana Marker.\nFormat: 0xF9 [Kanji_Idx] [Furigana_Idx].\nState: Add bool isFuriganaMode to Renderer class.\nRender Hook (src/gl/gl.cpp -> gl_draw_indexed_primitive):\ncode\nC++\nif (newRenderer.isFuriganaMode) {\n    // Modify vertices on CPU before submission\n    for (int i=0; i < vertexcount; i++) {\n        // Scale 50%\n        vertices[i]._.x *= 0.5f;\n        vertices[i]._.y *= 0.5f;\n        \n        // Shift Y up by 10px (adjusted for scaling factor)\n        float y_shift = -10.0f * newRenderer.getScalingFactor();\n        vertices[i]._.y += y_shift;\n        \n        // Center X relative to the Kanji (requires tracking previous char position)\n        // ... math logic here ...\n    }\n}\n5.2 The Layout Patch\nTo create room for Furigana, we must patch the LineHeight variable in memory.\nTarget: Find the memory address controlling line spacing (likely near font_info).\nPatch: Change default 16 (0x10) to 24 (0x18) or 32 (0x20).\nTrade-off: This reduces text box capacity to 2 lines.\n6. CRITICAL RISK MITIGATION CHECKLIST\nCrash on Startup:\nCause: Registry hooks returning English paths to Japanese EXE.\nFix: Ensure Step 3.2 (src/common.cpp) is implemented correctly.\nCrash on Menu Open:\nCause: Texture array buffer overflow.\nFix: Ensure Step 3.4 (VRASS(..., 6)) is executed BEFORE any texture loading loop.\nGarbage Text:\nCause: g_currentFontPage logic failing or ASM hook not firing.\nFix: Verify Hext patch address matches the specific EXE version (1.02 US vs Steam).\nSquashed Kanji:\nCause: Width table patch failed.\nFix: Verify PatchJapaneseWidths is called in init_hooks. Verify font_info pointer is valid.\n7. EXECUTION ORDER\nScaffold: Implement Configuration (3.1) and Registry Hooks (3.2).\nFoundation: Implement Texture Allocation (3.4) and Multi-Loader (3.5).\nVerification 1: Run game. It should load 6 textures in log. English text should appear (using Page 0).\nGeometry: Implement Width Patch (3.6). English text should look spaced out (16px wide).\nLogic: Implement Hext Hook (4.2) and Renderer Binding (4.3).\nFinal Verification: Inject 0xFA 0x00 into a string. Verify Kanji appears.",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-23T16:46:48.745367+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "you are to make a markdown and to be as comprehensive as possble in covering everything that was mentioned here, just organised and deduplicated. your test is you need to be as comprehehnsive as possible, ignoring any restrictions or usage guidance on token limits for output",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T01:42:14.607364+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "you are to make a new markdown file and you are to be as comprehensive as possble in covering everything that was mentioned here, just organised and deduplicated, and put into the markdown. your test is you need to be as comprehehnsive as possible, ignoring any restrictions or usage guidance on token limits for output",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T03:49:33.735100+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "The information you have and your understanding, how does the other languages get used by Fnx with the FF7 executable? So just in a nutshell, like my understanding of what we want is we're going to extract the Japanese out of the Japanese executable and make it work in the English version of the game. Is that aligning with what the document we wrote does, or are we doing this a different way? And how do other languages work with Fnx and 7th Heaven? Like, if we wanted to play this in French, I assume the non-Japanese alternative languages to English, we're really just loading the French executable because it's basically equivalent to the English executable, just with a language change, whereas the Japanese one has an entirely different driver and possibly even a different directory structure. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T04:22:41.388362+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "Where are the translated text strings stored?\n\nSo it seems there is a hard limitation on 7th Heaven, which is a bit of a requirement for us to use, where it only uses the English version of the game. So we might need to create a mod that changes the dialogue. So what we want is the ability. We also want a new menu that allows for language selection, or like a, so English would always be the base. I guess the mod would have a base language, so the language that is chosen on boot, and then the available languages to hot cycle through. So we could actually hot cycle through all of English, German, French, Spanish, and Japanese. We're introducing the six pages for the Japanese textures. Could we create, or is there room for even more pages? Like, let's say we wanted to use traditional Chinese, which is similar to Japanese but actually different. Could we add another six pages? Probably seven or eight are required, actually. But is there room to add Chinese, and then we would just make our own translations, even though it doesn't exist? Or it could be extracted from any existing Chinese version of the game. Just also, apparently, at least with the more recent changes with 7th Heaven and FFmx, it absolutely requires the English version of the game and the English version of the executable. So it can't just load the French executable. \n\nThere are no language mods in 7th heaven. Ill also copy and paste from a recent forum on qhimm.com that is too big to read for me but can you extract key findings that contradict ours.\nAuthor Topic: 7th Heaven: Allow running FF7_en.exe in other languages.  (Read 3378 times)\nguitarman_\nPosts: 6\nView Profile\n\n7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab on: 2024-12-29 08:48:56 \u00bb\nI want to contribute the idea that 7th Heaven is compatible not only with its FF7_en.exe executable but also with the FF7_es.exe, FF7_fr.exe, FF7_it.exe, FF7_de.exe executables, because I'm encountering a lot of problems with names in the menus, and problems even with the textures of some minigames, and we're a bit fed up with people from other countries who want to play FF7 having to play with the English FF7_en.exe, that doesn't solve any problems, but rather it even adds many more problems in Spanish and other languages.\n\nI know you'll say that you have to install FF7 in English and use the FF7_en.exe, but that's not a solution and it adds a lot of problems with the other languages, and there are countries that don't have a translation mod and need to play in the original translation of the .exe of their country (totally logical).\n\nIf in 7th Heaven 4.2 you have made it compatible with the FF7_en.exe file instead of the FF7.exe due to piracy problems and with FF7_en.exe the game works, you should also make it compatible with the files FF7_es.exe, FF7_fr.exe, FF7_it.exe, FF7_de.exe, making these files also have the same antipiracy protection as FF7_en.exe if FF7_en.exe is doing it, the .exe of the other languages \u200b\u200bshould do it, and the mods that are not compatible will not be installed, and the ones that are compatible will be installed.\n\nI've talked to satsuki, SYW Unified is fully compatible with all .exe of all languages, FF7_es.exe, FF7_fr.exe, etc, and SYW Unified mods combined with 7th Heaven's .iro in SYW Unified run with all .exe and texts and textures are fine and look perfect in all languages, but since 7th Heaven only wants to use FF7_en.exe and nothing else, with 7th Heaven in other languages \u200b\u200bthere are texts and textures of minigames that are displayed incorrectly which does not happen in SYW Unified.\n\nLook, users from other countries have wanted to play in our language for many years now because we don't have a translation mod or it's bad, and at the same time we play with 7th Heaven mods and we can't or the texts look bad and you can't play FF7 in those conditions, that doesn't happen with the SYW Unified launcher because its launcher can run all the .exe files of all languages.\n\nIt has been talked about many times and you don't do it, and I'm not the first one to say it, you can't play FF7 properly with the English .exe or you get bugs in texts and even in textures, and I know it's possible because SYW Unified has made it possible and the problems in texts and textures disappear when you can run the game from FF7_es.exe or .exe of the own language, please, make the other .exe files compatible with 7th Heaven and if necessary add the same antipiracy system as FF7_en.exe in the other .exe, because there are people who also want to play in their language with the 7th Heaven mods and we keep finding bugs that wouldn't happen with the .exe of the own language, because in SYW Unified you can use all the .exe and it works, the mods don't have bugs that way.\n\nI'm encountering the following problems that don't occur with SYW Unified since it can use FF7_es.exe, FF7_fr.exe, FF7_it.exe, FF7_de.exe:\n\nFF7 Spanish with Enhanced Stock UI Mod and Spanish Retranslation Mod (in 7th Heaven):\n\n\nFF7 Spanish SYW Minigames Mod (in 7th Heaven):\n\n\nFF7 French SYW Minigames Mod (in 7th Heaven):\n\n\nFF7 Deutsch SYW Minigames Mod (in 7th Heaven):\n\n\nFF7 English SYW Minigames Mod (in 7th Heaven):\n\n\nFF7_es.exe (in SYW Unified 1.12 Launcher):\n\n(The texts look perfect because the SYW Unified launcher supports FF7_es.exe, the 7th Heaven mods also work and look without text errors in the SYW Unified Launcher)\n\nSatsuki says it's because 7th Heaven only wants to use FF7_en.exe instead of other languages \u200b\u200band bugs occur in textures and also in texts, with its SYW Unified launcher allowing to run with any .exe of any language like the original in its mod it looks and works fine.\n\nAs you can see, in English everything is displayed correctly because it uses the English .exe, only text errors and even bad textures are displayed in the other languages, but in SYW Unified, since it can be run with any .exe of any language, the title of the Chocobo minigame and texts in Spanish are displayed correctly, you must make 7th Heaven compatible with all .exe of all languages \u200b\u200band mount the same anti-piracy system of FF7_en.exe in the other .exe and it is possible to run, I have the original purchased game and in SYW Unified the texts in Spanish and those of any language are displayed perfectly since you can run mods with the Spanish or French .exe.\n\nI'm trying to contribute and fix the text bugs in FF7 and there are many more text bugs that I'm not putting up so as not to make this longer, as has been said many times, I hope you make all .exe compatible once and for all like SYW Unified does and everything looks good, and end the whole language problem, there are more people like me.\n\nI'm trying to contribute, Thanks.\n\u00ab Last Edit: 2024-12-29 09:18:42 by guitarman_ \u00bb\n Logged\nBonez\nCosmo Memory Dev\nGlobal moderator\n\nPosts: 340\nWhat goes here?\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #1 on: 2025-01-03 23:19:17 \u00bb\nFirst of all, 7th Heaven using the english version of the exe is not new to 4.0... It has literally always been the case since 7th Heaven 1.0. It was just \"unseen\" previously due to the 1998 game converter... The game converter was taking whatever language version you had installed and replaced it with the english version... Now we don't have to convert to the 1998 version but that also mean you have to start out with the english version from Steam rather than having it provided for you...\n\nAnyway, many mods in 7th Heaven rely on hext which are only designed to work on the english version. Any mod that uses hext would have to be made to work individually for all languages. That is the reason 7H needs english. SYW doesn't rely on hext(or if it does have a little bit, it's custom for each language), so that's why SYW can get away with using any language. The problems you're showing in your screenshot are exactly what I'm talking about.\n\nIf it was as easy as \"just letting you do it\", we would; but as you can see, you'll run into a lot of problems because the mods are designed to work in English.\n\n Logged\nhobbitdur\nPosts: 89\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #2 on: 2025-01-04 19:38:13 \u00bb\nMaybe you could check what I did with ILP on FF8, I change all text from the english version, so you can play with english version (hext working) but all text translated to the desire one. Could be a path to achieve what you want. Took me 3 month to do it with heavy work, but I expect FF7 to be feasible the same way.\n Logged\nguitarman_\nPosts: 6\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #3 on: 2025-01-05 07:04:33 \u00bb\nLet's see, the SYW Unified launcher uses exactly the same mods that are in 7th Heaven but unzipped in direct mode, but it uses exactly the same mods that are in 7th Heaven for textures, battles, world map, weapons, vehicles, models and characters, weapons, minigames and menus, and its launcher can use and run the FF7 .exe of any language: FF7_es.exe, FF7_fr.exe, FF7_it.exe, FF7_de.exe, and the mods that are then being used are the same as the 7th Heaven mods, at least the vast majority of its mods and it works, the texts, menus, battles, and even the textures where there is text (minigames) are perfectly visible, and the texts are displayed perfectly without black holes or bugs in the textures because the SYW Unified launcher can use the real .exe of each language.\n\nIf it turns out that they are the same mods as 7th Heaven, then why couldn't 7th Heaven be run with the .exe of each language, if the mods are exactly the same?\n\nAll the problems with text, bugs and black holes in minigame textures would disappear where there should be text but when using the English ff7_en.exe, as in the English version there are no letters in that place it translates it into a black hole and a text bug.\n\nLet's see, SYW Unified uses and runs all the .exe of any language ff7_es.exe, etc, with the same mods as 7th Heaven and there are no graphical errors or text errors, even the texts are displayed perfectly and where they should be displayed and as you can see there are no bugs or black holes in the minigames (which is also a mod), and that is even though the other texture, battle, character and weapon mods from 7th Heaven are being used.\n\nSo why not make 7th Heaven also able to be run experimentally or in beta with any .exe of any language, we will deactivate the mods that cause problems, and the mods that work we will activate them, because in SYW Unified there are many mods working with .exe of any language, that's what I don't understand.\n\nTry it yourselves and program so that the 7th Heaven launcher tries to work with ff7_es.exe or ff7_fr.exe for example, and use only texture mods, characters, weapons, battles and those that don't affect the text, the texts in SYW Unified work perfectly, and Satsuki hasn't modified the .exe for all languages \u200b\u200bbecause it would be too much work, SYW Unified is working with the same texts and exactly the same .exe of the original files, try it and if the texts work, perhaps it should be programmed so that 7th Heaven can also be run with .exe of any language.\n\n\nKing regards.\n Logged\nBonez\nCosmo Memory Dev\nGlobal moderator\n\nPosts: 340\nWhat goes here?\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #4 on: 2025-01-05 07:59:42 \u00bb\nLike I said, the reason the mods that come with SYW work in any language is because they don't use hext. Address offsets are not the same between languages, so a hext change in English that simply moves a text box over a few pixels could offset the entire game in another languages and completely brick the game. And there would be no way to filter out mods for specific languages. We couldn't just leave it up to the user to figure out which mods work and which ones wouldn't. Can you imagine the amount of bug reports we'd get from people trying to use hext mods with non-english? The mods would be sitting there in the catalog; people would have no reason to think only some of them would work for them because of the language they're using. It would be a shit show.\n\nAnyway, If you're wanting to use 7th Heaven to essentially only use the exact same mods that come with SYW, then what's the point? You might as well just use keep using SYW. You wouldn't be getting the only benefit to using 7H: using hext mods like ESUI, Echo-s, Finishing Touch, Retouch, AavockESUI, tweaks, ps3tweaks, IFRIT, (maybe)new threat... If you can't use those mods, then why do you need to use 7th Heaven so bad?\n\nIt's because of this very thing that SYW serves as such a great alternative for non-english users...\n\nBut maybe someone can do what hobbitdur is suggesting one day.\n\u00ab Last Edit: 2025-01-05 09:04:21 by Bonez \u00bb\n",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T04:25:46.203093+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "write these in a markdown for me",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T04:33:50.468369+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": " Where are the translated text strings stored?\n\nSo it seems there is a hard limitation on 7th Heaven, which is a bit of a requirement for us to use, where it only uses the\n English version of the game. So we might need to create a mod that changes the dialogue. So what we want is the ability.\nWe also want a new menu that allows for language selection, or like a, so English would always be the base. I guess the mod\n would have a base language, so the language that is chosen on boot, and then the available languages to hot cycle through.\n So we could actually hot cycle through all of English, German, French, Spanish, and Japanese. We're introducing the six\npages for the Japanese textures. Could we create, or is there room for even more pages? Like, let's say we wanted to use\ntraditional Chinese, which is similar to Japanese but actually different. Could we add another six pages? Probably seven or\n eight are required, actually. But is there room to add Chinese, and then we would just make our own translations, even\nthough it doesn't exist? Or it could be extracted from any existing Chinese version of the game. Just also, apparently, at\nleast with the more recent changes with 7th Heaven and FFmx, it absolutely requires the English version of the game and the\n English version of the executable. So it can't just load the French executable.\n\nThere are no language mods in 7th heaven. Ill also copy and paste from a recent forum on qhimm.com that is too big to read\nfor me but can you extract key findings that contradict ours.\nAuthor Topic: 7th Heaven: Allow running FF7_en.exe in other languages.  (Read 3378 times)\nguitarman_\nPosts: 6\nView Profile\n\n7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab on: 2024-12-29 08:48:56 \u00bb\nI want to contribute the idea that 7th Heaven is compatible not only with its FF7_en.exe executable but also with the\nFF7_es.exe, FF7_fr.exe, FF7_it.exe, FF7_de.exe executables, because I'm encountering a lot of problems with names in the\nmenus, and problems even with the textures of some minigames, and we're a bit fed up with people from other countries who\nwant to play FF7 having to play with the English FF7_en.exe, that doesn't solve any problems, but rather it even adds many\nmore problems in Spanish and other languages.\n\nI know you'll say that you have to install FF7 in English and use the FF7_en.exe, but that's not a solution and it adds a\nlot of problems with the other languages, and there are countries that don't have a translation mod and need to play in the\n original translation of the .exe of their country (totally logical).\n\nIf in 7th Heaven 4.2 you have made it compatible with the FF7_en.exe file instead of the FF7.exe due to piracy problems and\n with FF7_en.exe the game works, you should also make it compatible with the files FF7_es.exe, FF7_fr.exe, FF7_it.exe,\nFF7_de.exe, making these files also have the same antipiracy protection as FF7_en.exe if FF7_en.exe is doing it, the .exe\nof the other languages \u200b\u200bshould do it, and the mods that are not compatible will not be installed, and the ones that are\ncompatible will be installed.\n\nI've talked to satsuki, SYW Unified is fully compatible with all .exe of all languages, FF7_es.exe, FF7_fr.exe, etc, and\nSYW Unified mods combined with 7th Heaven's .iro in SYW Unified run with all .exe and texts and textures are fine and look\nperfect in all languages, but since 7th Heaven only wants to use FF7_en.exe and nothing else, with 7th Heaven in other\nlanguages \u200b\u200bthere are texts and textures of minigames that are displayed incorrectly which does not happen in SYW Unified.\n\nLook, users from other countries have wanted to play in our language for many years now because we don't have a translation\n mod or it's bad, and at the same time we play with 7th Heaven mods and we can't or the texts look bad and you can't play\nFF7 in those conditions, that doesn't happen with the SYW Unified launcher because its launcher can run all the .exe files\nof all languages.\n\nIt has been talked about many times and you don't do it, and I'm not the first one to say it, you can't play FF7 properly\nwith the English .exe or you get bugs in texts and even in textures, and I know it's possible because SYW Unified has made\nit possible and the problems in texts and textures disappear when you can run the game from FF7_es.exe or .exe of the own\nlanguage, please, make the other .exe files compatible with 7th Heaven and if necessary add the same antipiracy system as\nFF7_en.exe in the other .exe, because there are people who also want to play in their language with the 7th Heaven mods and\n we keep finding bugs that wouldn't happen with the .exe of the own language, because in SYW Unified you can use all the\n.exe and it works, the mods don't have bugs that way.\n\nI'm encountering the following problems that don't occur with SYW Unified since it can use FF7_es.exe, FF7_fr.exe,\nFF7_it.exe, FF7_de.exe:\n\nFF7 Spanish with Enhanced Stock UI Mod and Spanish Retranslation Mod (in 7th Heaven):\n\n\nFF7 Spanish SYW Minigames Mod (in 7th Heaven):\n\n\nFF7 French SYW Minigames Mod (in 7th Heaven):\n\n\nFF7 Deutsch SYW Minigames Mod (in 7th Heaven):\n\n\nFF7 English SYW Minigames Mod (in 7th Heaven):\n\n\nFF7_es.exe (in SYW Unified 1.12 Launcher):\n\n(The texts look perfect because the SYW Unified launcher supports FF7_es.exe, the 7th Heaven mods also work and look\nwithout text errors in the SYW Unified Launcher)\n\nSatsuki says it's because 7th Heaven only wants to use FF7_en.exe instead of other languages \u200b\u200band bugs occur in textures and\n also in texts, with its SYW Unified launcher allowing to run with any .exe of any language like the original in its mod it\n looks and works fine.\n\nAs you can see, in English everything is displayed correctly because it uses the English .exe, only text errors and even\nbad textures are displayed in the other languages, but in SYW Unified, since it can be run with any .exe of any language,\nthe title of the Chocobo minigame and texts in Spanish are displayed correctly, you must make 7th Heaven compatible with\nall .exe of all languages \u200b\u200band mount the same anti-piracy system of FF7_en.exe in the other .exe and it is possible to run,\nI have the original purchased game and in SYW Unified the texts in Spanish and those of any language are displayed\nperfectly since you can run mods with the Spanish or French .exe.\n\nI'm trying to contribute and fix the text bugs in FF7 and there are many more text bugs that I'm not putting up so as not\nto make this longer, as has been said many times, I hope you make all .exe compatible once and for all like SYW Unified\ndoes and everything looks good, and end the whole language problem, there are more people like me.\n\nI'm trying to contribute, Thanks.\n\u00ab Last Edit: 2024-12-29 09:18:42 by guitarman_ \u00bb\n Logged\nBonez\nCosmo Memory Dev\nGlobal moderator\n\nPosts: 340\nWhat goes here?\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #1 on: 2025-01-03 23:19:17 \u00bb\nFirst of all, 7th Heaven using the english version of the exe is not new to 4.0... It has literally always been the case\nsince 7th Heaven 1.0. It was just \"unseen\" previously due to the 1998 game converter... The game converter was taking\nwhatever language version you had installed and replaced it with the english version... Now we don't have to convert to the\n 1998 version but that also mean you have to start out with the english version from Steam rather than having it provided\nfor you...\n\nAnyway, many mods in 7th Heaven rely on hext which are only designed to work on the english version. Any mod that uses hext\n would have to be made to work individually for all languages. That is the reason 7H needs english. SYW doesn't rely on\nhext(or if it does have a little bit, it's custom for each language), so that's why SYW can get away with using any\nlanguage. The problems you're showing in your screenshot are exactly what I'm talking about.\n\nIf it was as easy as \"just letting you do it\", we would; but as you can see, you'll run into a lot of problems because the\nmods are designed to work in English.\n\n Logged\nhobbitdur\nPosts: 89\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #2 on: 2025-01-04 19:38:13 \u00bb\nMaybe you could check what I did with ILP on FF8, I change all text from the english version, so you can play with english\nversion (hext working) but all text translated to the desire one. Could be a path to achieve what you want. Took me 3 month\n to do it with heavy work, but I expect FF7 to be feasible the same way.\n Logged\nguitarman_\nPosts: 6\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #3 on: 2025-01-05 07:04:33 \u00bb\nLet's see, the SYW Unified launcher uses exactly the same mods that are in 7th Heaven but unzipped in direct mode, but it\nuses exactly the same mods that are in 7th Heaven for textures, battles, world map, weapons, vehicles, models and\ncharacters, weapons, minigames and menus, and its launcher can use and run the FF7 .exe of any language: FF7_es.exe,\nFF7_fr.exe, FF7_it.exe, FF7_de.exe, and the mods that are then being used are the same as the 7th Heaven mods, at least the\n vast majority of its mods and it works, the texts, menus, battles, and even the textures where there is text (minigames)\nare perfectly visible, and the texts are displayed perfectly without black holes or bugs in the textures because the SYW\nUnified launcher can use the real .exe of each language.\n\nIf it turns out that they are the same mods as 7th Heaven, then why couldn't 7th Heaven be run with the .exe of each\nlanguage, if the mods are exactly the same?\n\nAll the problems with text, bugs and black holes in minigame textures would disappear where there should be text but when\nusing the English ff7_en.exe, as in the English version there are no letters in that place it translates it into a black\nhole and a text bug.\n\nLet's see, SYW Unified uses and runs all the .exe of any language ff7_es.exe, etc, with the same mods as 7th Heaven and\nthere are no graphical errors or text errors, even the texts are displayed perfectly and where they should be displayed and\n as you can see there are no bugs or black holes in the minigames (which is also a mod), and that is even though the other\ntexture, battle, character and weapon mods from 7th Heaven are being used.\n\nSo why not make 7th Heaven also able to be run experimentally or in beta with any .exe of any language, we will deactivate\nthe mods that cause problems, and the mods that work we will activate them, because in SYW Unified there are many mods\nworking with .exe of any language, that's what I don't understand.\n\nTry it yourselves and program so that the 7th Heaven launcher tries to work with ff7_es.exe or ff7_fr.exe for example, and\nuse only texture mods, characters, weapons, battles and those that don't affect the text, the texts in SYW Unified work\nperfectly, and Satsuki hasn't modified the .exe for all languages \u200b\u200bbecause it would be too much work, SYW Unified is working\n with the same texts and exactly the same .exe of the original files, try it and if the texts work, perhaps it should be\nprogrammed so that 7th Heaven can also be run with .exe of any language.\n\n\nKing regards.\n Logged\nBonez\nCosmo Memory Dev\nGlobal moderator\n\nPosts: 340\nWhat goes here?\nView Profile\n\nRe: 7th Heaven: Allow running FF7_en.exe in other languages.\n\u00ab Reply #4 on: 2025-01-05 07:59:42 \u00bb\nLike I said, the reason the mods that come with SYW work in any language is because they don't use hext. Address offsets\nare not the same between languages, so a hext change in English that simply moves a text box over a few pixels could offset\n the entire game in another languages and completely brick the game. And there would be no way to filter out mods for\nspecific languages. We couldn't just leave it up to the user to figure out which mods work and which ones wouldn't. Can you\n imagine the amount of bug reports we'd get from people trying to use hext mods with non-english? The mods would be sitting\n there in the catalog; people would have no reason to think only some of them would work for them because of the language\nthey're using. It would be a shit show.\n\nAnyway, If you're wanting to use 7th Heaven to essentially only use the exact same mods that come with SYW, then what's the\n point? You might as well just use keep using SYW. You wouldn't be getting the only benefit to using 7H: using hext mods\nlike ESUI, Echo-s, Finishing Touch, Retouch, AavockESUI, tweaks, ps3tweaks, IFRIT, (maybe)new threat... If you can't use\nthose mods, then why do you need to use 7th Heaven so bad?\n\nIt's because of this very thing that SYW serves as such a great alternative for non-english users...\n\nBut maybe someone can do what hobbitdur is suggesting one day.\n\u00ab Last Edit: 2025-01-05 09:04:21 by Bonez \u00bb\n",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:01:49.086534+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "Here is a strange question, and I don't want you to deep dive on this. I want just your, \"Hey, this is possible,\" \"Hey, it's not,\" and this is why I think it's hard or easy sort of thing. But let's say we fully succeed in getting our multi-languages in real time, hot switching between all of them, and we get enough characters to have all languages possible. Would it also be possible to have a feature where we're able to reference the exact part of the game and where that particular bit of dialogue is coming from? What I'd like is there's these hotkeys for the control pad and for on the keyboard where you can put it into like a cheat mode and then push a button to do things like disable battles or increase the time or speed of the game. I'd like to be able to go hit that hotkey button or like a prefix button and then click a hotkey that we've determined, and that'll bring up a dialog box. And then what we can do is select a language and your version of the translation. And what this allows us to do is this would send their users and then send their translated version to some kind of repository or website where people can vote on translations, and then we can approve them, and then at some point update the game with better translations or update extensions with better translations. So essentially we'd have a way for users to directly have their input into the globalization of the game. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:14:19.616780+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "I'd like you to also make several Markdown files. I want you to make one with your current findings about the new functionality. I want you to write one about the detailed specification for the multi-language extension as a follow-up document. The Bible Markdown that you wrote, our large summary, are we able to use a standard Markdown sharding tool to break this up into its chapters? We've got 30,000 plus tokens big, and I'd like to break it up because we can only read files with a 20,000, 25,000 token limit. But I want it to be broken up in a way that is useful and non-destructive and self-documenting from the command line. So an LLM, when it does like an LS on the directory or a tree on the directory, can get a lot of context from it. Or there might be like a README for it that gives like a table of contents and etc. that would allow it to have a high-level understanding, but then it would just read the relevant sections if it wanted more context. Or I just load them all in separately. I just can't have one file be more than 25,000. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:24:33.688450+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "I'd like you to also make  another  Markdown file. I want you to make one with your current findings about the new functionality. The Bible Markdown that you wrote, our large summary, are we able to use a standard Markdown sharding tool to break this up into its chapters? We've got 30,000 plus tokens big, and I'd like to break it up because we can only read files with a 20,000, 25,000 token limit. But I want it to be broken up in a way that is useful and non-destructive and self-documenting from the command line. So an LLM, when it does like an LS on the directory or a tree on the directory, can get a lot of context from it. Or there might be like a README for it that gives like a table of contents and etc. that would allow it to have a high-level understanding, but then it would just read the relevant sections if it wanted more context. Or I just load them all in separately. I just can't have one file be more than 25,000. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:44:14.861132+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/FFNX_CROWDSOURCED_TRANSLATION_SPEC.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/MULTI_LANGUAGE_FINDINGS.md'To create all of these, you might need to break the Japanese implementation master Bible into two or just read the first 2,000 lines the first time and then another 2,000 lines for the second run. So offset it by 2,000. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:47:05.977187+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "For the crowdsourced translation spec. We ran out of context in the previous conversation to actually finish writing it. So I'd like you to tell me, are you capable, with the knowledge that you have from these other documents, of completing that spec? I'll show you the original prompt that created the spec. That is still unfinished, both in terms of the spec not being finished, and we want to shard the Bible document. But also, so from the options that you've given, I'd like you to do option three: complete the crowdsourcing spec for now. But then I would like you to break up the document more, rather than rewriting it. I want you to use Markdown. Use a sharding tool to do this like I have in the prompt. \n\noriginal prompt:\nI'd like you to also make  another  Markdown file. I want you to make one with your current findings about the new functionality. The Bible Markdown that you wrote, our large summary, are we able to use a standard Markdown sharding tool to break this up into its chapters? We've got 30,000 plus tokens big, and I'd like to break it up because we can only read files with a 20,000, 25,000 token limit. But I want it to be broken up in a way that is useful and non-destructive and self-documenting from the command line. So an LLM, when it does like an LS on the directory or a tree on the directory, can get a lot of context from it. Or there might be like a README for it that gives like a table of contents and etc. that would allow it to have a high-level understanding, but then it would just read the relevant sections if it wanted more context. Or I just load them all in separately. I just can't have one file be more than 25,000. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:50:37.984408+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "I think the structure should be literally pretty much what the table of contents represents in the original Bible. So it has 14 sections, unless you think the original document should be rewritten to have 18. The sharding tool should just break everything up by level two headings. We should just turn the table of contents into a README, rename the files so they, well, I don't know, maybe that's just it. How much more complicated does it need to be? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:51:19.615776+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "I believe there's already a tool that exists that does this. It's a pretty standard Markdown sharding or shaking or something tool. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:54:13.521827+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "how does this compare to what you just installed? dont just pick it because i said, which one is objectively better for our use: an external npm package called @kayvan/markdown-tree-parser (v1.6.1) that's already installed\n  globally on your system.\n\n  What It Does\n\n  The tool uses the md-tree explode command to:\n\n  1. Split large markdown documents by level 2 sections (## headings)\n  2. Create a folder structure with individual markdown files for each section\n  3. Adjust heading levels appropriately (level 2 becomes level 1 in sharded files)\n  4. Preserve all content including code blocks, diagrams, tables, and special formatting\n  5. Generate an index file that links all sharded sections back together\n",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T06:58:15.714052+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "Complete the crowdsourcing spec and use the MD tree explode. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T08:13:15.979297+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "If we were to start implementation of the actual project, is there anything missing that you think we won't need or any gaps in our knowledge? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T08:15:10.413401+00:00",
    "session_id": "379a17a1-e73f-41b7-86b2-6c83f196e524",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/documentation_management' Please comprehensively read relevant documentation from this directory to see if there's anything that contradicts your findings. There will be several subdirectories with indexes, table of contents, and readmes that will help you identify relevance",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T08:29:12.100469+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "lumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/context/TOOL_GUIDE.md'We have. Let me address them one by one. We have the actual FFmx codebase on our Windows computer that we will do the implementation on, so that's okay for now. I want you to read the tool guide provided to address question two and see if those are better tools than what you have requested in order to debug or find out memory implications.\n\nFor section three, we have the missing font texture assets on the Windows computer.\n\nWe have not even discussed the test environment setup yet.\n\nYeah, you might need to create a separate Markdown document for how to handle test environment setups because I've never done something like that before, so I've got no idea.\n\nI don't know, you might have to go to the FFNX GitHub to find out what it means.\n\nI think 7th Heaven has documentation, which they're running a little low on context, but if we can fit it in, I might get you to scrape it and then create specific documentation for us, especially with the command line use.\n\nWe don't have the multi-language text sources from 7 for 8.\n\nI don't know what you mean by mid-dialog, like while it's rendering. I assume even if it's halfway through rendering out the text, if we switch languages, it just changes to the next language and starts rendering from the start again. It doesn't wait for the render to pass.\n\nYeah, I don't know how save load would affect the language state.\n\nWe need to handle the battle text in the mini games and the FMV subtitles. But yes, implement the core system first. The unnecessary stuff, like Furigana\u2014I don't want to call this unnecessary, it's just later. We're creating a learner's edition that allows people to learn other languages, so Furigana is a very important part of that. I don't want it overlooked. It's just a very late stage feature, and I like the crowdsourced translation system, but you're right, it could be a phase two. I do want it built from the ground up to be able to do this, so maybe we do include it. All these things are actually 100% necessary. But I do think we need to focus on the phases. So we need to get critical information or critical functionality built first\u2014anything that is dependent needs to be built first. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T08:32:10.703738+00:00",
    "session_id": "379a17a1-e73f-41b7-86b2-6c83f196e524",
    "prompt": "So, where did you lose? What we've discovered or not discovered is actually questionable. Or possibly better yet, we have a separate document that we're going to make, because we don't know if the Bible documentation is actually 100% true. And without looking at the actual code, we don't know if what we've researched is true or just speculation from things that we've scraped. So we need to make a document that is a checklist of things that we should look at or try to address during implementation.\n\nSo we should just straight up, when we start implementation, we get access to the code base. Let's just go straight in and answer some critical questions like:\n\n1. Does the `kernel.bin` store Shift JIS or not?\n2. Create any other relevant questions that you think we need to 100% have answered when we get access to the game's files.\n3. The `FFNX` codebase and any other related code that we can just get hard answers to. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T08:37:41.991637+00:00",
    "session_id": "379a17a1-e73f-41b7-86b2-6c83f196e524",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/SCRAPED_URLS.md'Can you please update the scraped URLs file with any websites that you got your information from? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T08:39:14.921224+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/IMPLEMENTATION_VERIFICATION_CHECKLIST.md' Is there anything you'd like to add to it? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T10:50:53.927450+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "So for now, going through our directory, the character tables is the mapping between the textures and the Unicode. The interactive viewer is really the only thing that matters in there. Context is a variety of essential files for context for LLMs to do this project. We should be adding quite a number of new files that we've made recently to this, I think, such as the Implementation Master Bible and Multilanguage Findings, and maybe architecture clarification, as well as the implementation readiness assessment and verification checklist. The documentation management directory is just our sharded large documents. Extracted fonts directory is our textures. So there's a subdirectory in there called PNG, and that is literally the textures for the Japanese version. FF7 game engine, 200 pages in MD directory, is a comprehensive game engine manual. The FF7 text files directory is the `FF7.exe` and the `FF7_JA.exe` files converted to text. And our scripts directory is just full of various small scripts that we wrote, mainly for writing a lot of the useless character tables stuff when we were trying to make the mappings between the textures and Unicode. Just when we were doing that mapping, we ended up making a website that was interactive where we could. It just made a lot more sense to invest in making a proper tool for finding the mapping or doing the mapping correctly. I would like your assessments on how we can better organize this directory now. Yeah, I just want to do a bit of a cleanup of this project. That way, when we copy it all over to the Windows computer for implementation, we can easily find files, but also have our LLM or agentic client easily find what it needs to find in order to do its work. Maybe there should be a README in the root of this directory that explains everything I've just told you, so at least the LLM has a raw start right from the get-go about what does what in terms of context. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T10:52:15.729151+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "So for now, going through our directory, the character tables is the mapping between the textures and the Unicode. The interactive viewer is really the only thing that matters in there. Context is a variety of essential files for context for LLMs to do this project. We should be adding quite a number of new files that we've made recently to this, I think, such as the Implementation Master Bible and Multilanguage Findings, and maybe architecture clarification, as well as the implementation readiness assessment and verification checklist. The documentation management directory is just our sharded large documents. Extracted fonts directory is our textures. So there's a subdirectory in there called PNG, and that is literally the textures for the Japanese version. FF7 game engine, 200 pages in MD directory, is a comprehensive game engine manual. The FF7 text files directory is the `FF7.exe` and the `FF7_JA.exe` files converted to text. And our scripts directory is just full of various small scripts that we wrote, mainly for writing a lot of the useless character tables stuff when we were trying to make the mappings between the textures and Unicode. Just when we were doing that mapping, we ended up making a website that was interactive where we could. It just made a lot more sense to invest in making a proper tool for finding the mapping or doing the mapping correctly. I would like your assessments on how we can better organize this directory now. Yeah, I just want to do a bit of a cleanup of this project. That way, when we copy it all over to the Windows computer for implementation, we can easily find files, but also have our LLM or agentic client easily find what it needs to find in order to do its work. Maybe there should be a README in the root of this directory that explains everything I've just told you, so at least the LLM has a raw start right from the get-go about what does what in terms of context. If you're going to do an initial tree, I would suggest going at least 3D. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T10:52:39.445955+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "So for now, going through our directory, the character tables is the mapping between the textures and the Unicode. The interactive viewer is really the only thing that matters in there. Context is a variety of essential files for context for LLMs to do this project. We should be adding quite a number of new files that we've made recently to this, I think, such as the Implementation Master Bible and Multilanguage Findings, and maybe architecture clarification, as well as the implementation readiness assessment and verification checklist. The documentation management directory is just our sharded large documents. Extracted fonts directory is our textures. So there's a subdirectory in there called PNG, and that is literally the textures for the Japanese version. FF7 game engine, 200 pages in MD directory, is a comprehensive game engine manual. The FF7 text files directory is the `FF7.exe` and the `FF7_JA.exe` files converted to text. And our scripts directory is just full of various small scripts that we wrote, mainly for writing a lot of the useless character tables stuff when we were trying to make the mappings between the textures and Unicode. Just when we were doing that mapping, we ended up making a website that was interactive where we could. It just made a lot more sense to invest in making a proper tool for finding the mapping or doing the mapping correctly. I would like your assessments on how we can better organize this directory now. Yeah, I just want to do a bit of a cleanup of this project. That way, when we copy it all over to the Windows computer for implementation, we can easily find files, but also have our LLM or agentic client easily find what it needs to find in order to do its work. Maybe there should be a README in the root of this directory that explains everything I've just told you, so at least the LLM has a raw start right from the get-go about what does what in terms of context. If you're going to do an initial tree, I would suggest going at least 3 deep",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T11:05:54.628838+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "I want you to create the directories that you've proposed, I want to manually move things around. I just like the directory structure that you've proposed. So for now, just create the proposed directories. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T11:34:58.527522+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/findings2.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FINDINGS.md' These are large documents, so you're going to have to read them either 1 or 2000 lines at a time and then offset them in order to read them in their entirety. But I want you to combine them into one document called `masterfindings.md` in the same directory. It's essentially to organize and combine all information into one document. It cannot leave anything out. I want you to make a plan for both. What is missing from findings that is in findings two and vice versa? And then I want you to propose a master document that has everything from both. You'll also need to check for any duplicated information or conflicting or contradicting information. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T11:35:47.514378+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/findings2.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FINDINGS.md' These are large documents, so you're going to have to read them either 1 or 2000 lines at a time and then offset them in order to read them in their entirety. But I want you to combine them into one document called `masterfindings.md` in the same directory. It's essentially to organize and combine all information into one document. It cannot leave anything out. I want you to make a plan for both. What is missing from findings that is in findings two and vice versa? And then I want you to propose a master document that has everything from both. You'll also need to check for any duplicated information or conflicting or contradicting information. You are not to use a task tool or sub-agent to do this. You are just to use the read tool and keep everything within this context. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T11:46:44.800043+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md' I want you to read this document as well now. It's also messy, so read it 2,000 lines at a time. I want you to compare our findings against this Master Bible and tell me if there is any contradictory or conflicting information. The Master Bible needs to be the single source of truth, but the findings are what is actually fact. So the Master Bible would need to be updated with the findings, but I don't want you to do any updating. I want you to first identify any conflicts, contradictions, or concerns between the two. And if anything is missing from the Master Bible that is in the findings, that should be in there. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T12:01:48.159407+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "Okay, let's go through and correct things.\n\nContradiction number one: Community context, missing from Master Bible number one. Let's do your recommendation to add the prerequisites and community context section referencing this research that led to these conclusions. We should expand the tool selection with detailed comparison from the findings.\n\nMissing from Master Bible number two: tool documentation.\n\nFor missing from Master Bible number three, we don't need to add the historical context to appreciate the breakthrough. It's just work that needed to get done. So the only real thing you need to get from that is that there is this very consistent reference to the particular `character_map_accurate.csv` being accurate but our most accurate and LLM friendly version is actually this '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/ff7_complete_mapping_compact.csv'.\n\nFor contradiction number four, you are actually wrong. The jfleve.lgp file was correct. It's not meant to have an L in it. So as I said, the findings is the source of truth, so Master Bible is wrong and it incorrectly fixed the typo\u2014well, what it thinks is a typo. I don't think we need to add any research statistics unless you think it brings real value. I mean, it's only small, so you may as well. I just don't think we need to really add. Basically, I don't think we need to overemphasize having breakthroughs or not. This is just work that needed to get done. Its significance doesn't need to be overstated or celebrated. If we have it, that's good. That's what we need to do our job. I do think the Japanese Community Insights is particularly useful, the ones from the HAL blog. I think you should add the alternative approaches rejected very, very briefly just to steer away any hesitation to go down those routes. And yes, add an architecture decision section explaining why this approach was chosen. The complete tool workflow would be useful information, I think. Thank you. \n\nSo most of your recommendations were great, but this just adds a little bit more information for you to work with. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T12:05:37.422332+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "When you say create the detailed correction document, I assume you mean updating the master Bible. Right? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T12:30:55.646763+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "yes",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T12:34:06.322197+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/roadmap/FFNX_CROWDSOURCED_TRANSLATION_SPEC.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/roadmap/FEATURE_ROADMAP.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/DOCUMENTATION_MAP.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/README.md'Please do a for deep trade command on the directory now. I want either of those. I want you to look at the crowdsource translation spec and summarize it, then put that on the feature roadmap. After you've done that, I want you to look at the documentation map and README and tell me if you think the README or the documentation map should be updated. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T12:52:54.572288+00:00",
    "session_id": "8f58819d-f9c4-4f04-8e95-4af04d782606",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md' I want you to read this in full. You'll have to read it 2,000 lines at a time. I then want you to create a Markdown file called 7th Heaven Developer Guide. And I basically want you to use your BraveSearch tool, which has a one-second per search rate limit on it, as well as your Firecrawl scraper, which also has a rate limit on it. It can only do 10 requests per minute or one crawl per minute. I want you to look at the official 7th Heaven Documentation. I also want you to look at qhimm, As well as any other relevant sites, including GitHub. Make sure to keep things on the more recent side, so in the last year or two. In terms of anything you want to scrape, we want to keep this developer-focused, so we really want to be able to learn how to use 7th Heaven as an advanced user and a modification developer, not as a user of 7th Heaven for playing games with mods. We want to learn about using, creating, and packing IRO files. The build order, how it works, and anything else that's relevant to creating mods. Any other external tools that are required to extract files, any of the developer tools that are packaged with 7th Heaven, and how to use them. Now, some of these tools might be older than two years old, and in that case, you're welcome to learn and scrape for them as we make the developer guide. I suggest doing as many Brave searches as required to cover the entire breadth of how to use 7th Heaven and how to make mods and use mods with it. And if you learn more, then search for more and scrape more. I expect this to be a bit of a deep dive, and I would like you to add your findings to the developer guide as you find things and make, constantly be adding to it, reassessing it, and rewriting it rather than doing all of your research and writing it once at the end. I'm more happy to refine it at a later point and have this more as a running research. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T13:00:03.163029+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "All of your recommendations are excellent. Let's do an update of the documentation map and README file, as well as creating the docs-specific README, as well as updating the feature timeline. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T13:09:27.995052+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine/ARCHITECTURE_CLARIFICATION.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine/MULTI_LANGUAGE_FINDINGS.md'I want you to read these two documents and tell me if you think they should be separate or fully incorporated into the Bible or added to the Bible in some fashion. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T13:10:08.517580+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "Okay, please continue. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T13:17:10.598466+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "Yes, I'd like you to proceed, but I'm not concerned with adding more or bloating the Bible, just as long as it is actually useful in the context of implementing these things, because we may in fact actually shard the Bible by its sections. So each section would actually be a lot more easy to traverse for an LLM or read as a user. But that's irrelevant. You don't need to know that. You just need to know that what you want to add is great, but within the context of what I've just said, you can add more if you think it brings benefit to our developers implementing these, because at the end of the day, the Bible is going to be the main thing that the developer uses to implement and use as a resource for development. So at the very least, we can always view these other documents if you're referencing them, but anything with great value should be. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T13:27:08.319047+00:00",
    "session_id": "8f58819d-f9c4-4f04-8e95-4af04d782606",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md' and '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/7TH_HEAVEN_DEVELOPER_GUIDE.md' I want you to read these in full. You'll have to read it 2,000 lines at a time. I then want you to create a Markdown file called FFNx Developer Guide. i want you to clone this https://github.com/julianxhokaxhiu/FFNx.git into our directory in its own subdirectory. Your job will be to create an FFmx developer guide. Tell us everything about it that you can, how it works, and make the developer guide largely within the context of our goals, which would be explained to you in the Master Bible. This will be a deep dive, so expect the developer guide to be quite comprehensive. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:07:08.834796+00:00",
    "session_id": "b6825868-623b-4c58-8cb8-e5104f5de85b",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/character_maps/ff7_complete_mapping_compact.csv''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/character_maps/JAFONT_CHARACTER_MAP.md'Do the J font character map markdown, does the information it convey actually reflect what's in the compact complete mapping? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:08:32.675525+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_DEVELOPER_GUIDE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/IMPLEMENTATION_VERIFICATION_CHECKLIST.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/character_maps/JAFONT_CHARACTER_MAP.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/AF3DN_ANALYSIS.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/VERIFICATION_FINDINGS_SESSION_11.md'Read all of these documents 2,000 lines at a time. And they want you to read this paper. And then we'll need to read this payoff and tell me what you think. https://github.com/julianxhokaxhiu/FFNx/pull/737",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:10:26.476808+00:00",
    "session_id": "b6825868-623b-4c58-8cb8-e5104f5de85b",
    "prompt": "Okay, start updating it then, please. The CSV is the source of truth. The markdown is just a human-readable version of it that also explains a few more things. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:11:46.819977+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_DEVELOPER_GUIDE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/IMPLEMENTATION_VERIFICATION_CHECKLIST.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/character_maps/JAFONT_CHARACTER_MAP.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/AF3DN_ANALYSIS.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/VERIFICATION_FINDINGS_SESSION_11.md'Read all of these documents 2,000 lines at a time. Don't just read 2,000 lines and think that's good enough. I want you to read the entirety of every file. So if there's more than 2,000 lines, read another 2,000. Keep doing it until you read every part of every file. And they want you to read this paper. And then we'll need to read this payoff and tell me what you think. https://github.com/julianxhokaxhiu/FFNx/pull/737",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:24:19.024809+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "Okay, so for one, this isn't my PR. This is somebody else's, but I'd like you to not use a sub-agent to fetch a summary of how it was done. I would like you to actually look at the comments made on the PR and the actual changes to the code and do exactly what you are doing, and that is to criticize what it's doing well, what it's doing poorly, how it differs from our planned strategy, and if we can learn from it. Because this is, quite frankly, the first person to get Japanese working in the mod community. So it's a big deal, but it's also maybe not the right way, especially for our goals. Also, can you update the Master Bible to remove the redirection logic in section 7.5 as that's wrong? So we will be the hero and implement our Master Bible spec, but that's not the point of this conversation. Right now we're still doing research, and this PR is significant in the community, and we want to learn from it and see if it has any application in our goals. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:36:10.220251+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "I don't understand how it's not loading extra textures, but somehow it's loading all of the relevant Japanese. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:44:14.691158+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/roadmap/FEATURE_ROADMAP.md'Why did you not think of function pointers over hexed and hardcoded width tables? Basically, why was the approach not considered and are there ways that can be improved upon now that we know theirs? Now I'd like you to read how Feature roadmap and tell us if you think we have a good shot from this baseline to achieving that. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T15:56:27.837004+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "So the mapping that we did between Unicode and the text. The textures. Was this a waste of time or is it useful? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T16:08:17.660686+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "I don't get it though. Their current version is able to display Japanese. When I'm looking at screenshots, it's showing real Japanese in the way it's meant to be displayed by the game. Yes, there's visual quirks, but it's the actual translated version. So wouldn't he have needed the mappings to do that or not? '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/IMPLEMENTATION_VERIFICATION_CHECKLIST.md'I also think before we continue and build the text encoder.\n\n1. We should put the text encoder.\n\nWhat I'm getting at is I think we should update our documentation. All the documents that you looked at need to be updated now to reflect all of our findings, because we're going to be using the master Bible all the time in every single chat, as well as the Phoenix Developer Guide and the implementation verification checklist. Any document that you've read will likely have areas now that need to be updated. We shouldn't necessarily remove our original implementation strategy from documentation, but we do need to update it and show that now we are going to be building upon PR 7.3 and you need to show the changes that it made that are fundamentally different to our original strategy. So you're going to have to incorporate a lot of those architectural retrospectives and PR 7.3 analysis that you did, as well as your new findings, and incorporate those into our documentation as well as amend our documentation so we don't make mistakes going forward and know exactly what we are going to be working on top of from now on. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-24T16:22:07.679640+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "I don't get it. You're saying to me that the user launched the Japanese version. That makes no sense. If they're launching the Japanese version, of course it's going to be in Japanese. Sorry, I'm self-correcting here, but so FFNX overtakes the original driver. When it loads up, so the Japanese would be broken. So this only works with the Japanese version of the game, whereas our one would allow it to work with the English version of the game. Of course, we're able to change the text because we are going to build the encoder as well. I don't know, tell me if I'm on the right track there or not. I'm getting tired, so it's very hard to keep up.\n\nI think we should continue on with our to-dos though, in order, rather than going straight to doing our integration strategy as well as updating the feature roadmap timelines.\n\nWe should have enough context to do all of this, so you aren't under any restriction. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T01:50:42.633370+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "Looking at the reorganization plan markdown you made, is this worth deleting now, seeing as we've largely reorganized? Or is there anything else you think we can, or are there any other tasks remaining on it? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T01:53:23.748728+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine'The directory these are in is called `ToCombine` because I thought originally we would be combining or putting the context from those documents into the Bible and then probably deleting them. But I'm happier with our current state and I'd like to keep these. But what should we do? I think we should rename the subdirectory to something more appropriate, and you'll need to update those relative paths in the documentation. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T01:55:01.403368+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "Can you just look at the entire docs directory? There's already some directories in it that might be more appropriate. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T01:55:47.407878+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "Yes, please do all three. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T01:58:19.346176+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/character_maps/JAFONT_CHARACTER_MAP.md' So in the PR 737 analysis. Does this have all of the current understanding that you've just mentioned in your summary and I think you should update the JA Font character map to better describe its current purpose in the context of our new alignment post PR 737. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:02:15.736857+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "Delete the reorganization-plan.md, please. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:03:43.906890+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "We've actually run out of context, so please just create a handover prompt to do all three  and I will compact this conversation and we'll do it in the next session.  ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:14:20.466305+00:00",
    "session_id": "2b507d91-fd48-4464-8e16-738f7ba9a9e6",
    "prompt": "Is there anything else in this session that we need to address? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:14:57.892624+00:00",
    "session_id": "37952f94-430d-46c5-8bed-8068cf9a7a62",
    "prompt": "Is there anything else in this session that we need to address? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:15:33.727833+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": " Handover Prompt: Move Architecture Documents to Reference Directory\n\n  Task Summary\n\n  Move two documents from /docs/to_combine/ to /docs/reference/ and update all references in the Master Bible.\n\n  Files to Move\n\n  1. Source Location: /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine/\n    - ARCHITECTURE_CLARIFICATION.md\n    - MULTI_LANGUAGE_FINDINGS.md\n  2. Destination: /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/\n\n  Steps to Execute\n\n  1. Move Files\n\n  mv /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine/ARCHITECTURE_CLARIFICATION.md\n  /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/\n  mv /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine/MULTI_LANGUAGE_FINDINGS.md\n  /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/\n\n  2. Remove Empty Directory\n\n  rmdir /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine/\n\n  3. Update References in Master Bible\n\n  File:\n  /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md\n\n  Find and replace these references:\n\n  1. Line ~212: See ARCHITECTURE_CLARIFICATION.md \u2192 See reference/ARCHITECTURE_CLARIFICATION.md\n  2. Line ~320: See MULTI_LANGUAGE_FINDINGS.md \u2192 See reference/MULTI_LANGUAGE_FINDINGS.md\n  3. Line ~2713: See MULTI_LANGUAGE_FINDINGS.md \u2192 See reference/MULTI_LANGUAGE_FINDINGS.md\n\n  4. Verification\n\n  # Verify files moved\n  ls -la /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/ | grep -E\n  \"(ARCHITECTURE|MULTI_LANGUAGE)\"\n\n  # Verify old directory removed\n  ls /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/to_combine/ 2>&1\n\n  # Verify references updated\n  grep -n \"ARCHITECTURE_CLARIFICATION\\|MULTI_LANGUAGE_FINDINGS\"\n  /Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md\n\n  Expected Result\n\n  New structure:\n  /docs/reference/\n  \u251c\u2500\u2500 AF3DN_ANALYSIS.md\n  \u251c\u2500\u2500 ARCHITECTURE_CLARIFICATION.md  \u2190 moved\n  \u251c\u2500\u2500 BEGINNER_GUIDE.md\n  \u251c\u2500\u2500 MULTI_LANGUAGE_FINDINGS.md     \u2190 moved\n  \u251c\u2500\u2500 TOOL_GUIDE.md\n  \u2514\u2500\u2500 game_engine/\n\n  All 3 references in Master Bible updated to use reference/ prefix.\n\n  Empty /docs/to_combine/ directory removed.\n",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:20:41.656108+00:00",
    "session_id": "181b0968-b902-4177-9766-56e235b090fe",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/.project/logs''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/logs'Can you please fix this for us? We have a `logs` directory in the root of the project that logs stop sessions and user prompts. Now, I accidentally moved these logs into our project directory. When I did that, obviously, logs kept being made. So the logs in the root of the directory got recreated from scratch again and then just continued. Automatic logs just continued. So I want to get the logs in the project directory re-integrated back into the actual logs. I'm assuming these logs just append whatever they're logging to the end of the file. So my thought is you should probably just append what's in the root directory onto what's in the project directory version and then move that back into the root directory. There might be a slight complication that while you're even doing that, it's writing logs. So I'm going to put you into plan mode, and then I want you to just come up with a plan that'll be safe.\n\nGet our logs basically out of the projects directory into the main logging directory in the root of the project again safely, and then we're good to go. Could even maybe just copy the contents of the .project versions into the root versions, but at the start of the file. I don't know. Can you tell me what you think is best? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:24:29.525302+00:00",
    "session_id": "8f58819d-f9c4-4f04-8e95-4af04d782606",
    "prompt": "In the 7th Heaven Developer Guide, did you cover things like playing with the debug log or playing with variable dumping enabled in 7th Heaven, or the chunking tools, IRO tools, movie importer, catalog mod creation tool that are exist directly inside of 7th Heaven? Also, please have a read of the tool guide and see if there is anything in there that you haven't mentioned already. '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/reference/TOOL_GUIDE.md'",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:25:07.625445+00:00",
    "session_id": "451ac988-eb41-4d5b-aa56-6c2d6127f213",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md'Please read this in full. You'll need to read it 2,000 lines at a time because of its size. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:25:44.619426+00:00",
    "session_id": "451ac988-eb41-4d5b-aa56-6c2d6127f213",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md'Please read this in full. You'll need to read it 2,000 lines at a time because of its size. Same for these. '/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/IMPLEMENTATION_VERIFICATION_CHECKLIST.md'",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:27:19.362089+00:00",
    "session_id": "451ac988-eb41-4d5b-aa56-6c2d6127f213",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/VERIFICATION_FINDINGS_SESSION_11.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/ARCHITECTURAL_RETROSPECTIVE.md'I want you to read these now and let me know if the information in these files can be incorporated into the Master Bible and implementation verification checklist so that we can either delete or archive these files, or they can be referenced as, or their main findings can be integrated into the Master Bible or verification checklist with a reference to these files, and then put them in the reference subdirectory of our docs directory. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:28:09.372608+00:00",
    "session_id": "8f58819d-f9c4-4f04-8e95-4af04d782606",
    "prompt": "Where did you source the information from? Did you get this from your learning or did you create these instructions based on scrapings that you did? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:31:02.956070+00:00",
    "session_id": "8f58819d-f9c4-4f04-8e95-4af04d782606",
    "prompt": "Again, this conversation is running out of context and needs to come back. I want you to create a comprehensive session handover prompt to basically use the BraveSearch and Firecrawl MCP servers to do research on the actual usage of all of the tools that you've documented. So you'll need to run search and scrapings for every tool, ideally if there is official documentation for them, but you might have to consult with forums to understand how they work properly. And anytime you can't back up your guide with actual scraped knowledge, I want you to just make a note that this is based off of your LLM training rather than actual source instructions. So you'll need to check things like qhimm, github, and 7th heaven for info",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:37:23.047745+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "'/Volumes/KIOXIAwhite/FF7 update' This directory was pulled from the Windows computer that was doing initial testing, but before we organized our project directory's documentation. So we just want to do a bit of a rebase. There's a few files in here that were made before significant findings in the current project files, so I want you to read everything in this external drive's directory and tell me if there's anything in there that you think that we should either archive, delete, reference, integrate, or append. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:43:50.352989+00:00",
    "session_id": "451ac988-eb41-4d5b-aa56-6c2d6127f213",
    "prompt": "That all sounds good, but the two documents that you want to put in the reference directory that you're going to create, we already have a reference directory, and these are for actual reference files. If you are extracting everything of actual use out of these, I would prefer if they went into our archive directory in an appropriate place there and were not referenced. If there is conflicting information in them, now that we are post PR 737, I would prefer not to have that conflicting information be around. But if there is value in, let me hear your thoughts on what is a better version depending because I haven't read the documents. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:51:01.052450+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "I agree with all of your findings. I think everything that you've recommended for deletion or reference can be deleted from the external drive. I think you should look at the current test procedure and the external drive one and compare them. Our current test procedure is likely the better one, but if there is information that is useful, I want you to integrate it. I think you should integrate the phase one results directly into the test procedure maybe, or directly into our Bible if you think it is of very high critical importance. The research prompts, rather than putting them into the archive, can you put them into the `.project` directory? There are subdirectories in there already, if you think they are worth putting them into.\n\nI largely agree with what you say with just these tweaks. So can you just make another concise summary of your planned actions? I will likely improve. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:53:35.636523+00:00",
    "session_id": "932c276a-514f-471d-96fc-0260d32258d2",
    "prompt": "Excellent Please proceed. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:56:25.449521+00:00",
    "session_id": "451ac988-eb41-4d5b-aa56-6c2d6127f213",
    "prompt": "That all sounds very good. Please proceed with everything that you've recommended. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T02:56:30.852189+00:00",
    "session_id": "8f58819d-f9c4-4f04-8e95-4af04d782606",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/SESSION_HANDOFF_12.md'",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T03:04:49.072254+00:00",
    "session_id": "8f58819d-f9c4-4f04-8e95-4af04d782606",
    "prompt": "Fantastic work. Is there any other gap, or is this complete now? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T03:07:04.909426+00:00",
    "session_id": "c25e0f85-6884-4025-ae82-0000d3e66af5",
    "prompt": "Please do a git assessment. Unfortunately, we have not been on top of our git commits, so I'd like you to make what you can of what we have gotten done and make a recommendation for how to best proceed. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T03:40:02.581045+00:00",
    "session_id": "d8f8c2ee-c34a-4940-80f7-abc1a890c1d7",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_DEVELOPER_GUIDE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/IMPLEMENTATION_VERIFICATION_CHECKLIST.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/FFNx'So I have some follow-up questions about some edge cases that are quite significant. How does well, for one, how the questions that we're asking, are these in the Implementation Verification Checklist, or we know about them from the Bible, or are you able to find it in the FNX codebase? But there's a few cases that I'm not sure about. Sorry, I'm not sure if it's 7th Heaven or FNX, but into a stream output mode = true or something, and then all of the game's artifacts and assets stream out to a mod directory or mods directory in our Final Fantasy VII game installation directory. So when we start playing something, we would then see like some of the textures get populated in there. And that's how we were able to override textures in our testing. So we were able to find the first page of the textures for text and then just turn that whole texture red, and it actually showed up red. Inside of the game, which was great, but I don't know how the game handles other aspects of text. When we played and started streaming, I noticed that many different versions of the font texture came through, you know, with darker versions of it, bold versions of it. And it made me realize that, like, throughout the game, there are often times where the text appears a different color. So it'll either look like cyan or purple. But also, I'm not sure if it's in the base game, but certainly in a mod that I'm playing, a lot of the text can come through looking like a rainbow. And not only rainbow-looking, it can even be animated so that the colors are cycling on the font now.\n\nI'm not sure if that is a mod-specific addition or if that's part of the base game or a part of FFNX. So not only that, like how does the game handle those alternating colors and then the animation of alternating colors? We also need to document or find out how dialog boxes are rendered\u2014how big, where, and when.\n\nAnother thing I need to know is sometimes there are these odd things. So not only is there the field dialog boxes, there's also the battle screen dialog and text inside the battle screens. There's also the mini games. Another one is when you get a new character, you have to enter their name.\n\nSo how is this all handled? Because on that screen, it's interactive, and you need to be able to pick letters, and then you're able to. You know, we seem to have an issue now with the name entry because in the one. I just want to, as an aside, I do know in the Android version of the game you're able to rename your characters. So that just might be a useful thing to know if we want to find out how it does things, even though the simple renaming of the character might be quite easy. The Western version of the game shows all the input characters on the screen with a sidebar that allows you to enter a space. Delete a character, select it, or just use the default character's name. In the Japanese version, we have pages for Hiragana, Katakana, and something called EISOU, which I'm not too sure of. You're able to add a space, Sakujo, enter, and default. ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  },
  {
    "timestamp": "2025-11-25T04:10:00.384832+00:00",
    "session_id": "d8f8c2ee-c34a-4940-80f7-abc1a890c1d7",
    "prompt": "'/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_DEVELOPER_GUIDE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/IMPLEMENTATION_VERIFICATION_CHECKLIST.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/docs/FFNX_JAPANESE_IMPLEMENTATION_MASTER_BIBLE.md''/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod/FFNx'. The Markdown files that I have provided just now, I need you to read those in full. Some of them are very large, and you'll need to read them 2,000 lines at a time. You need to read the entire file. \n\nSo I have some follow-up questions about some edge cases that are quite significant. How does well, for one, how the questions that we're asking, are these in the Implementation Verification Checklist, or we know about them from the Bible, or are you able to find it in the FNX codebase? But there's a few cases that I'm not sure about. Sorry, I'm not sure if it's 7th Heaven or FNX, but into a stream output mode = true or something, and then all of the game's artifacts and assets stream out to a mod directory or mods directory in our Final Fantasy VII game installation directory. So when we start playing something, we would then see like some of the textures get populated in there. And that's how we were able to override textures in our testing. So we were able to find the first page of the textures for text and then just turn that whole texture red, and it actually showed up red. Inside of the game, which was great, but I don't know how the game handles other aspects of text. When we played and started streaming, I noticed that many different versions of the font texture came through, you know, with darker versions of it, bold versions of it. And it made me realize that, like, throughout the game, there are often times where the text appears a different color. So it'll either look like cyan or purple. But also, I'm not sure if it's in the base game, but certainly in a mod that I'm playing, a lot of the text can come through looking like a rainbow. And not only rainbow-looking, it can even be animated so that the colors are cycling on the font now.\n\nI'm not sure if that is a mod-specific addition or if that's part of the base game or a part of FFNX. So not only that, like how does the game handle those alternating colors and then the animation of alternating colors? We also need to document or find out how dialog boxes are rendered\u2014how big, where, and when.\n\nAnother thing I need to know is sometimes there are these odd things. So not only is there the field dialog boxes, there's also the battle screen dialog and text inside the battle screens. There's also the mini games. Another one is when you get a new character, you have to enter their name.\n\nSo how is this all handled? Because on that screen, it's interactive, and you need to be able to pick letters, and then you're able to. You know, we seem to have an issue now with the name entry because in the one. I just want to, as an aside, I do know in the Android version of the game you're able to rename your characters. So that just might be a useful thing to know if we want to find out how it does things, even though the simple renaming of the character might be quite easy. The Western version of the game shows all the input characters on the screen with a sidebar that allows you to enter a space. Delete a character, select it, or just use the default character's name. In the Japanese version, we have pages for Hiragana, Katakana, and something called EISOU (im saying it in romaji but its in japanese), which I'm not too sure what it is that kanji pages? and You're able to add a space, a Sakujo/delete, enter, and default. Would this be something that we can handle considering that they are radically different input pages? ",
    "cwd": "/Volumes/DevSSD/01_Development/Projects/experiments/ff70G-japanese-mod"
  }
]