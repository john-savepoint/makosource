---
title: "FF7 Kernel Low-Level Libraries"
module: "Kernel"
created: "2025-12-01 23:47 JST"
modified: "2025-12-02 01:32 JST"
session_id: "850a7b53-a13a-42a8-bd80-3efe55514a38"
author: "Generated by Claude Code Documentation Standardization Agent"
status: "Complete"

llm_summary: "Documents FF7's low-level data archive formats (BIN, LZS, LGP), texture systems (TIM for PSX, TEX for PC), and 3D model format specifications. LLMs should read this when parsing game archives, implementing decompression routines, or understanding PSX-to-PC format conversion."
llm_tags: ["data-archives", "lzs-compression", "lgp-format", "tim-texture", "tex-format", "3d-models"]
llm_primary_topics: ["BIN archive format", "LZS/LZSS compression algorithm", "LGP archive structure", "TIM texture format", "TEX PC texture format", "PSX to PC model conversion"]
llm_related_docs: ["FF7_Kernel_Kernelbin.md", "FF7_Kernel_Memory_management.md", "FF7_LGP_format.md", "FF7_LZSS_format.md", "FF7_TEX_format.md", "PSX_TIM_format.md", "FF7_Playstation_Battle_Model_Format.md"]

referenced_by: []
---

<!--
STANDARDIZATION METADATA
Original: FF7_Kernel_Low_level_libraries.md
Source: merged_with_pdf_content/FF7_Kernel_Low_level_libraries.md
Standardized: 2025-12-01 23:47 JST
Cleaned: 2025-12-02 01:32 JST
Session-ID: 850a7b53-a13a-42a8-bd80-3efe55514a38
Cleanup-Session-ID: fa0164ee-f434-4a86-9e35-554e9bc551dd
Agent: FF7 Documentation Standardization Agent v1.0

Previous Merge Metadata:
EXTRACTED FROM MAJOR SECTION: 03_KERNEL.md lines 592-665
Contains LZS Archive Format and LZS Compression details extracted and merged
from the major kernel documentation section.

Standardization Changes Applied:
- Added YAML frontmatter with LLM routing metadata
- Added HTML comment metadata block with standardization history
- Fixed heading hierarchy: Promoted H4 sections (BIN Type Archives, BIN-GZIP Type Archives,
  LZS Archive Format, LZS Compression, Reference format, Example) to H4 under proper H3 parents
- Added missing H2 "Complications" section (was incorrectly at H2 level, now properly structured)
- Converted 15 wiki-style links to standard markdown format:
  * [TIM file](PSX/TIM_format) -> [TIM file](PSX_TIM_format.md)
  * [KERNEL.BIN](FF7/Kernel/Kernel.bin) -> [KERNEL.BIN](FF7_Kernel_Kernelbin.md)
  * [LZS format](FF7/LZS_format) -> [LZS format](FF7_LZSS_format.md)
  * [LGP format](FF7/LGP_format) -> [LGP Archive Format](FF7_LGP_format.md)
  * [TEX format](FF7/TEX_format) -> [TEX format](FF7_TEX_format.md)
  * [BIN archive](FF7/Kernel/Low_level_libraries#BIN) -> internal anchor link
  * And additional model format links
- Preserved HTML table for BIN-GZIP format (complex colspan structure)
- Added language tag "text" to code blocks that lacked specification
- Verified no images present in source document
- Updated cross-references to use proper .md file extensions

Cleanup Changes Applied (v2):
- Converted HTML table to GitHub-flavored markdown table
- Added GitHub alert syntax for important notes
- Improved table alignment and readability
- No encoding issues found in source

LLM CONTEXT BLOCK (Read this first for routing decisions):
This document is the foundational reference for understanding FF7's data storage and
compression systems across both PSX and PC platforms. It explains the critical difference
between PSX-native formats (TIM textures, Psy-Q libraries) and their PC conversions (TEX,
LGP archives). The LZS/LZSS compression section provides complete algorithm documentation
including the control byte scheme, reference format, offset calculation, and edge cases
(negative offsets, repeated runs) that are REQUIRED for correct decompression. For
archive extraction tools or mod loaders, this document explains BIN archive variants
(compressed vs uncompressed), LGP volume structure, and texture format relationships.
Cross-reference with FF7_LGP_format.md for detailed LGP parsing, FF7_LZSS_format.md for
additional compression details, and PSX_TIM_format.md for TIM file structure.
-->

# FF7 Kernel Low-Level Libraries

- [FF7 Kernel Low-Level Libraries](#ff7-kernel-low-level-libraries)
  - [PC to PSX Comparison](#pc-to-psx-comparison)
  - [Data Archives](#data-archives)
    - [BIN Archive Data Format](#bin-archive-data-format)
    - [LZS Archives](#lzs-archives)
    - [LGP Archives](#lgp-archives)
  - [Textures](#textures)
    - [TIM Texture Data Format for PSX](#tim-texture-data-format-for-psx)
    - [TEX Texture Data Format for PC](#tex-texture-data-format-for-pc)
  - [File Formats for 3D Models](#file-formats-for-3d-models)
    - [Model Formats for PSX](#model-formats-for-psx)
    - [Model Formats for PC](#model-formats-for-pc)

---

## PC to PSX Comparison

The files and data formats used in the PSX version of FF7 and its PC port are conceptually the same thing, and accomplish the same tasks. That being said, they both have wildly different formats, both of which were derived from a third original format that is also somewhat different to the first two.

The original PSX FF7 was created in part using Sony's Psy-Q development library. This library uses common formats that are "native" to the PSX. Often, a toolkit was used to convert common development-based formats, such as a TGA bitmap or a palleted GIF file, to something a little more suited to Psy-Q, which would be a [TIM file](PSX_TIM_format.md).

During the porting process to the PC, some of the original artwork (and artists for that matter) were no longer available. This resulted in the port team having to use the Psy-Q versions of many files, which were ill suited for the PC architecture. In our example, the [TIM file](PSX_TIM_format.md) was converted to a TEX file, which would be manipulated in the PC's video memory a little more efficiently. Sometimes the original artwork was available, such as the pictures of the characters within the menu, or the original MIDI files. Most often times it was not.

To make things a little more confusing, both systems also archive their data files in different ways, making the extraction and rendering of each file a bit of a bear. For the most part the data within each file is the same thing, just a little switched around. Here, we will cover the more generic files first, and then common files used in each module.

---

## Data Archives

To save space, quicken access time, and to obfuscate the file structure a little, most of the data files are stored in some kind of archive format. The archives remove such useful items as subdirectories and logical data placement. There is no real "native" format these are based on.

### BIN Archive Data Format

The BIN format comes as two different types. They both have the same extension, so one must open the file to see which format is which. They are best described as BIN Types and BIN-GZIP types.

#### BIN Type Archives

These are uncompressed archives. The header is 4 bytes long and gives the length of the file without the header and then the data beyond that.

#### BIN-GZIP Type Archives

Unless otherwise noted, these have a 6 byte header. After this are many gziped sections concatenated together.

| Offset | Length  | Description                                         |
|:-------|:--------|:----------------------------------------------------|
| 0x0000 | 2 bytes | Length of gzipped section 1                         |
| 0x0002 | 2 bytes | Length of ungzipped section 1                       |
| 0x0004 | 2 bytes | File type*                                          |
| 0x0006 | Varies  | `[0x1F8B080000000000...]` - Gzip header 1 and data  |
| Varies | 2 bytes | Length of gzipped section 2                         |
| Varies | 2 bytes | Length of ungzipped section 2                       |
| Varies | 2 bytes | File type*                                          |
| Varies | Varies  | `[0x1F8B080000000000...]` - Gzip header 2 and data  |
| ...    | ...     | *(pattern repeats for additional sections)*         |

**\*** This particular value might be ignored by the whatever method is decompressing these archive types. Within archives it declares that the compressed file is a particular type. These values seem to be unique to the particular archive that is being opened and is not consistent between archives.

**Example 1:** Within the [KERNEL.BIN](FF7_Kernel_Kernelbin.md) the first nine files are all different data sets so are numbered sequentially 0-8. All remaining files are text types and get labeled as type 9.

**Example 2:** Within the WINDOW.BIN file there are three files. The first two are type "0" and are textures. The third file is type "1" and not a texture.

### LZS Archives

The [LZS format](FF7_LZSS_format.md) is used throughout the PSX version of Final Fantasy 7, often ending with the .lzs extension. LZS itself stands for Lempel-Ziv-Shannon-Fano, Statistical plus Arithmetic. It was originally developed by [Professor Haruhiko Okumura](http://oku.edu.mie-u.ac.jp/~okumura/index-e.html) based on the work of [Abraham Lempel](http://www.hpl.hp.com/about/bios/abraham_lempel.html) and [Jacob Ziv](http://www.marconifoundation.org/pages/dynamic/fellows/fellow_details.php?roster_id=23).

#### LZS Archive Format

The LZS archive has a very small header at 0x00 that has the length of the decompressed file as an unsigned 32 bit integer. After that is the compressed data.

#### LZS Compression Algorithm

FF7 uses LZS compression on some of their files - more properly, a slightly modified version of LZSS compression as devised by Professor Haruhiko Okumura.

LZS data works on a control byte scheme. So each block in the file begins with a single byte indicating how much of the block is uncompressed ('literal data'), and how much is compressed ('references'). You read the byte right-to-left, with 1=literal, 0=reference.

Literal data means just that: read one byte in from the source (compressed) data, and write it straight to the output.

References take up two bytes, and are essentially a pointer to a piece of data that's been written out (i.e. is part of the data you've already decompressed). LZSS uses a 4K buffer, so it can only reference data in the last 4K of data.

#### Reference Format

A reference takes up two bytes, and has two pieces of information in it: offset (where to find the data, or which piece of data is going to be repeated), and length (how long the piece of data is going to be). The two reference bytes look like this:

```text
OOOO OOOO OOOO LLLL (O=Offset, L=Length)
```

So you get a 12-bit offset and a 4-bit length, but both of these values need modifying to work on directly. The length is easy to work with: just add 3 to it. Why? Well, if a piece of repeated data was less than 3 bytes long, you wouldn't bother repeating it - it'd take up no more space to actually just put literal data in. So all references are at least 3 in length. So a length of 0 means 3 bytes repeated, 1 means 4 bytes repeated, so on. Since we have 4 bits available, that gives us a final length ranging from 3-18 bytes long. (That also means the absolute maximum compression we can ever get using LZSS is a touch under 9:1, since the best possible is to replace 18 bytes of data with two bytes of reference, and then you have to add control bytes as well.)

Offset needs a bit work doing on it, depending on how you're actually holding your data. If all you have is an input buffer and an output buffer, what you really need is an output position in your buffer to start reading data from. In other words, if you've already written 10,000 bytes to your output, you want to know where to retrieve the repeated data from - it could fall anywhere in the past 4K of data, (i.e. from 5904 through to 9999 bytes.)

Here's how you get it:

```text
real_offset = tail - ((tail - 18 - raw_offset) mod 4096)
```

Here, 'tail' is your current output position (eg. 10,000), 'raw_offset' is the 12-bit data value you've retrieved from the compressed reference, and 'real_offset' is the position in your output buffer you can begin reading from. This is a bit complex because it's not exactly the way LZSS traditionally does (de) compression; it uses a 4K circular buffer; if you do that, the offset is more or less usable directly.

Once you've got to the start position for your reference, you just copy the appropriate length of data over to your output, and you've dealt with that piece of data.

#### Decompression Example

If we're at position 1000 in our output, and we need to read in a new control byte because we've finished with the last one. The next data to look it is:

```text
0x03, 0x53, 0x12 .....
```

We read in a control byte: $03. In binary, that's 00000011. That informs us that the current block of data has two compressed offsets (@ 2 bytes each), followed by 6 literal data bytes. Once we'd read in the next 10 bytes (the compressed data plus the literal data), we'd be ready to read in our next control byte and start again.

Looking at the first compressed reference, we read in $53 $12. That gives us a base offset of $153 (the 53 from the first byte, and the '1' from the second byte makes up the higher nybble). The base length is $2 (we just take the low nybble of the second byte).

Our final length is obviously just 5. Our position in output is still 1000. So our final offset is:

```text
=1000 - ((1000 - 18 - 339) and $FFF)
```

The 339 is just $153 in decimal.

The `(and $FFF)` is a quick way to do modulus 4096.

```text
=1000 - (643 and 0xFFF)
=1000 - 643
=357
```

So our final offset is 357. We go to position 357 in our output data, read in 5 bytes (remember the length?), then write those 5 bytes out to our output. Now we're ready to read in the next bit of data (another compressed reference), and do the procedure again...

#### LZS Decompression Edge Cases

Unfortunately, that doesn't quite cover everything - there's two more things to be aware of when decompressing data that *will* ruin you when using FF7 files, since they do use these features.

**Negative Offset (Before File Start)**

First, if you end up with a negative offset, i.e. reading data from 'before the beginning of the file', write out nulls (zero bytes). That's because the compression buffer is, by default, initialized to zeros; so it's possible, if the start of the file contains a run of zeros, that the file may reference a block you haven't written...

**Example:** If you're at position 50 in your output, it's possible you may get an offset indicating to go back 60 bytes to offset -10! If you have to read 5 bytes from there, it's simple: you just write out 5 nulls. However, you *could* have to read 15 bytes from there. In that case, you write out 10 nulls (the part of the data 'before' the file start), then the 5 bytes from the beginning of the file.

**Repeated Run (Past Output End)**

Secondly, you can have a repeated run. This is almost the opposite problem: when you go off the end of your output. Say you're at offset 100 in your output, and you have to go to offset 95 to read in a reference. That's OK ... but what if the reference length is >5? In that case, you loop the output. So if you had to write out 15 bytes, you'd write out the five bytes that *were* available ... and then write them out again ... then again, to make up the 15 bytes you needed.

> [!IMPORTANT]
> The FF7 files use both of these 'tricks', so you can't ignore them!

### LGP Archives

The LGP file format is only used for the PC port of Final Fantasy 7. These are large "volume" type archives that hold most of the game's data. These archives can hold thousands of files. Unlike the BIN or LZS type files, this archive does reference the data within it by filename. Its file format is explained in [LGP Archive Format](FF7_LGP_format.md).

---

## Textures

A texture is just a picture that is placed into video memory. It is later manipulated by the engine and displayed on the screen. The native format of a texture was the Psy-Q [TIM](PSX_TIM_format.md) (Texture Image Map). This is used as the native format for the PSX version as well, with a few caveats explained below. The file can hold multiple color look up tables. This was one of the reasons why a video card on the PC that could do palleted data at high color depths was needed.

### TIM Texture Data Format for PSX

The [TIM files](PSX_TIM_format.md) are found both in raw format and also within several archives, including [BIN](#bin-archive-data-format), [LZS](#lzs-archives), or even MNU. The format proper has the ability to contain 24 bit bitmaps, but is not used in FF7. The format was created because the PSX does not have direct access to its VRAM, and must go through the GPU for any graphic access. A [TIM file](PSX_TIM_format.md) is a clean way to load a texture and color look up table into VRAM.

### TEX Texture Data Format for PC

TEX files are texture files for the PC. The format for these files is documented in [TEX Format](FF7_TEX_format.md).

---

## File Formats for 3D Models

During the development process, 3D models contain a good deal of information needed by the artist every time they save or load the model. When the model is finished, it is often exported and broken up into smaller files with many unneeded attributes stripped from them. When the models for FF7 were created, they were exported into Psy-Q's 3D library formats. These include resource data (.RSD), polygon data (.PLY), polygon groups (.GRP), materials (.MAT), textures (.TIM), skeletal hierarchy (.HRC), and animation (.ANM).

The models are handled differently between modules. The models in the "battle" modules have a different animation system than the field models. When the models were converted to the PC version, they were taken from the Psy-Q formats to a more PC-friendly one. Some are even the original, uncompiled, Psy-Q files.

### Model Formats for PSX

The PlayStation models are stored in the following directories:

- `\ENEMY1`, `\ENEMY2`, `\ENEMY3`, `\ENEMY4`, `\ENEMY5`, `\ENEMY6` - Battle models
- `\FIELD` - Field models and field character models
- `\MAGIC` - Summon magic
- `\STAGE1`, `\STAGE2` - Battle scenes

Battle model names for special characters and party characters are stored in `\ENEMY6`; all models of this type end in an .LZS extension. The same goes with summon magic used - they are stored with their animations etc. in `\MAGIC` with a .LZS extension.

The only exception to this extension is the FIELD models, which use the extensions BSX and BCX for scene models and character models respectively.

The [PlayStation battle model format](FF7_Playstation_Battle_Model_Format.md) is different than the PlayStation field model format (see [Field BSX](FF7_Field_Module.md#psx-bsx-format)). Also, the PlayStation battle scene format is similar but not identical to the [PlayStation battle model format](FF7_Playstation_Battle_Model_Format.md).

### Model Formats for PC

The PC models are stored in the LGP files in the `/DATA` directory. The names for the models were obfuscated a little. The data can be found in the Hierarchy files (.HRC), Resource data files (.RSD), and Polygon files (.P).

For more information on PC model formats, see the related Battle and Field module documentation.
